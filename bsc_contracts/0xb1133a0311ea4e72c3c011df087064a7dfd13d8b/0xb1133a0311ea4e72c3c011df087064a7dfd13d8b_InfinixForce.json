{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n     event Transfer(address indexed from, address indexed to, uint256 value);\r\n     event Approval(address indexed owner, address indexed spender, uint256 value);\r\n   \r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract InfinixForce {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    IERC20 public token;\r\n    uint256 public registrationFee = 10e18; // 10 USDC with 18 decimals\r\n  uint256 public totalContributions;\r\n    uint256 public numberOfUsers;\r\n    address public randomUser;\r\n    address[] public userAddresses;\r\n\r\n\r\n    mapping(address => uint256) public userIDs;\r\n    mapping(uint256 => address) public idToAddress;\r\n   mapping(address => address ) public referrers;\r\n\r\n  mapping(address => address payable) public userDirectReferrer;\r\n    mapping(address => uint256) referralRewards;\r\n    mapping(uint256 => bool) public paymentsMade;\r\n    mapping(address => bool) public userLevels;\r\n    mapping(address => uint) public userCurrentLevel;\r\n    mapping(address => uint256) public RandomRewards;\r\n    mapping(address => uint256) public totalRewards;\r\n    mapping(address => uint256) public UpgradeIncome;\r\n    mapping(address => User) public users;\r\n   \r\n    struct User {\r\n    uint256 id;\r\n    address referrer;\r\n    uint256 level;\r\n    address[] directReferrals;\r\n\r\n}\r\n\r\n    uint public totalLevels;\r\n    mapping(uint => uint) public levelPrices;\r\n\r\n    event Registration(address indexed user, address indexed directReferrer);\r\n    event LevelPurchased(address indexed user, uint indexed level, uint amount, address indexed referrer);\r\n    event SponsorRewardsDistributed(address indexed user, uint indexed level, uint amount, address indexed directReferrer);\r\n    event RandomRewardsDistributed(address indexed user, uint amount);\r\n    event RegistrationFeeChanged(uint256 newFee);\r\n\r\n        constructor(address _token) {\r\n        owner = msg.sender;\r\n        setTokenContract(_token);\r\n        numberOfUsers = 1;\r\n        userIDs[owner] = numberOfUsers;\r\n        idToAddress[numberOfUsers] = owner;\r\n        totalLevels = 9;\r\n        levelPrices[1] = 10e18 ;\r\n        levelPrices[2] = 10e18 ;\r\n        levelPrices[3] = 10e18 ;\r\n        levelPrices[4] = 10e18 ;\r\n        levelPrices[5] = 10e18 ;\r\n        levelPrices[6] = 10e18 ;\r\n        levelPrices[7] = 10e18 ;\r\n        levelPrices[8] = 10e18 ;\r\n        levelPrices[9] = 10e18 ;\r\n\r\n        userLevels[owner] = true;\r\n        userCurrentLevel[owner] = totalLevels;\r\n    }\r\n\r\n    function setTokenContract(address _token) public onlyOwner {\r\n        require(_token != address(0), \"Invalid token address\");\r\n        token = IERC20(_token);\r\n    }\r\n\r\n   \r\n    function setRegistrationFee(uint256 newFee) external onlyOwner {\r\n        require(newFee > 0, \"Registration fee must be greater than zero\");\r\n        registrationFee = newFee;\r\n            \r\n                emit RegistrationFeeChanged(newFee);\r\n    }\r\n\r\n  function getUpgradeIncome(address user) public view returns (uint256) {\r\n    return UpgradeIncome[user];\r\n}  \r\n     function LevelUpgradeIncome(address user) external view returns (uint256) {\r\n    return totalRewards[user];\r\n}\r\n    function getLastRegistration() external view returns (uint256 userID, address referrer) {\r\n        require(numberOfUsers > 0, \"No registrations available\");\r\n\r\n        uint256 lastUserID = numberOfUsers;\r\n\r\n        require(userIDs[idToAddress[lastUserID]] != 0, \"No registration made by the last user\");\r\n\r\n        userID = lastUserID;\r\n        referrer = referrers[idToAddress[lastUserID]];\r\n\r\n        return (userID, referrer);\r\n    }\r\nfunction getRefferresInfos(address user) external view returns (address[] memory, uint256[] memory, uint256[] memory) {\r\n    address[] memory referrerAddresses = new address[](totalLevels);\r\n    uint256[] memory referrerIDs = new uint256[](totalLevels);\r\n    uint256[] memory referrerLevels = new uint256[](totalLevels);\r\n\r\n    address referrer = referrers[user];\r\n\r\n    for (uint256 i = 0; i < totalLevels; i++) {\r\n        if (referrer == address(0)) {\r\n            break;\r\n        }\r\n\r\n        referrerAddresses[i] = referrer;\r\n        referrerIDs[i] = userIDs[referrer];\r\n        referrerLevels[i] = userCurrentLevel[referrer];\r\n\r\n        referrer = referrers[referrer];\r\n    }\r\n\r\n    return (referrerAddresses, referrerIDs, referrerLevels);\r\n}\r\n\r\nfunction getDirectReferrals(address user) external view returns (address[] memory) {\r\n    return users[user].directReferrals;\r\n}\r\n\r\nfunction getTotalRefferalIcome(address user) external view returns (uint256) {\r\n    return referralRewards[user];\r\n}\r\n\r\n \r\n    \r\n     function register(address directReferrer) external {\r\n        require(userIDs[msg.sender] == 0, \"User already registered\");\r\n        require(directReferrer != msg.sender, \"Cannot be your own referrer\");\r\n\r\n        // Ensure the user has approved the contract to spend the registration fee\r\n        require(token.allowance(msg.sender, address(this)) >= registrationFee, \"Insufficient allowance\");\r\n\r\n        // Check if the user has enough balance\r\n        require(token.balanceOf(msg.sender) >= registrationFee, \"Insufficient balance\");\r\n\r\n        // Transfer the registration fee from the user's allowance\r\n        require(token.transferFrom(msg.sender, address(this), registrationFee), \"Token transfer failed\");\r\n\r\n        // Assuming token is an instance of the USDC token contract\r\n        address contractAddress = address(this);\r\n        token.approve(contractAddress, registrationFee);\r\n\r\n         numberOfUsers = numberOfUsers.add(1);\r\n        uint256 userID = numberOfUsers;\r\n        userIDs[msg.sender] = userID;\r\n        idToAddress[userID] = msg.sender;\r\n        referrers[msg.sender] = directReferrer;\r\n\r\n        // Distribute referral rewards\r\n        _distributeReferralRewards(msg.sender, registrationFee);\r\n\r\n        // Distribute random registration reward\r\n        _distributeRandomRegistrationReward(registrationFee);\r\n\r\n        // Update contribution tracking\r\n        totalContributions = totalContributions.add(registrationFee);\r\n\r\n        // Emit registration event\r\n        emit Registration(msg.sender, directReferrer);\r\n\r\n    // Check and record direct referrals\r\n    if (directReferrer != address(0) && userIDs[directReferrer] <= numberOfUsers) {\r\n        address referrerAddress = directReferrer;\r\n        users[referrerAddress].directReferrals.push(msg.sender);\r\n    }\r\n\r\n\r\n      }   \r\n      \r\n       function _distributeReferralRewards(address user, uint256 amount) internal {\r\n        address directReferrer = referrers[user];\r\n        address indirectReferrer = referrers[directReferrer];\r\n        address indirectReferrerOfReferrer = referrers[indirectReferrer];\r\n\r\n        uint256 directReferrerReward = amount.mul(50).div(100);\r\n        uint256 indirectReferrerReward = amount.mul(10).div(100);\r\n        uint256 indirectReferrerOfReferrerReward = amount.mul(10).div(100);\r\n        uint256 non_working = amount.mul(10).div(100);\r\n\r\n        if (userIDs[indirectReferrer] != 0) {\r\n            require(token.transfer(indirectReferrer, indirectReferrerReward), \"Token transfer failed\");\r\n            referralRewards[indirectReferrer] = referralRewards[indirectReferrer].add(indirectReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, indirectReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        if (userIDs[indirectReferrerOfReferrer] != 0) {\r\n            require(token.transfer(indirectReferrerOfReferrer, indirectReferrerOfReferrerReward), \"Token transfer failed\");\r\n            referralRewards[indirectReferrerOfReferrer] = referralRewards[indirectReferrerOfReferrer].add(indirectReferrerOfReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, indirectReferrerOfReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        if (userIDs[directReferrer] != 0) {\r\n            require(token.transfer(directReferrer, directReferrerReward), \"Token transfer failed\");\r\n            referralRewards[directReferrer] = referralRewards[directReferrer].add(directReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, directReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        // Distribute creator reward\r\n        require(token.transfer(owner, non_working), \"Token transfer failed\");\r\n    }\r\n\r\n  function _distributeRandomRegistrationReward(uint256 amount) internal {\r\n    uint256 remainingReward = amount.mul(20).div(100);\r\n    uint256 userLimit = numberOfUsers;\r\n\r\n    if (userLimit > 4) {\r\n        userLimit = 4;\r\n    }\r\n\r\n    for (uint256 i = 0; i < userLimit; i++) {\r\n        uint256 randomUserID;\r\n\r\n        randomUserID = uint256(keccak256(abi.encodePacked(block.timestamp, i, numberOfUsers))) % numberOfUsers + 1;\r\n        randomUser = idToAddress[randomUserID];\r\n\r\n        // Assuming your token contract is ERC-20 compliant\r\n        IERC20(token).transfer(randomUser, remainingReward.div(userLimit));\r\n        paymentsMade[randomUserID] = true;\r\n        RandomRewards[randomUser] = RandomRewards[randomUser].add(remainingReward.div(userLimit));\r\n    }\r\n\r\n    if (numberOfUsers < 4) {\r\n        uint256 remainingFunds = IERC20(token).balanceOf(address(this));\r\n        // Assuming your token contract is ERC-20 compliant\r\n        IERC20(token).transfer(owner, remainingFunds);\r\n    }\r\n\r\n}\r\n\r\nfunction distributeRegEarnings() external {\r\n    require(totalContributions > 0, \"No contributions to distribute\");\r\n\r\n    uint256 remainingReward = IERC20(token).balanceOf(address(this)).mul(20).div(100);\r\n    uint256 ownerReward = IERC20(token).balanceOf(address(this)).mul(10).div(100);\r\n\r\n    _distributeRandomRegistrationReward(remainingReward);\r\n\r\n    // Assuming your token contract is ERC-20 compliant\r\n    IERC20(token).transfer(owner, ownerReward);\r\n\r\n    totalContributions = 0;\r\n}\r\n\r\n// Purchase a level using tokens\r\nfunction purchaseLevel(uint256 _level) external {\r\n    require(_level > 0 && _level <= totalLevels, \"Invalid level\");\r\n    require(token.allowance(msg.sender, address(this)) >= levelPrices[_level], \"Insufficient allowance\");\r\n    require(token.balanceOf(msg.sender) >= levelPrices[_level], \"Insufficient balance\");\r\n    require(!hasLevel(msg.sender, _level), \"User already has the level\");\r\n\r\n    if (_level > 1) {\r\n        require(hasLevel(msg.sender, _level - 1), \"Previous level must be activated\");\r\n    }\r\n\r\n    // Transfer tokens from the user's allowance\r\n    require(token.transferFrom(msg.sender, address(this), levelPrices[_level]), \"Token transfer failed\");\r\n\r\n    distributeLevelRewards(msg.sender, _level);\r\n\r\n    userCurrentLevel[msg.sender] = _level;\r\n    userLevels[msg.sender] = true;\r\n\r\n    emit LevelPurchased(msg.sender, _level, levelPrices[_level], referrers[msg.sender]);\r\n}\r\n\r\n// Distribute rewards for purchasing a level using tokens\r\nfunction distributeLevelRewards(address user, uint256 _level) internal {\r\n    address referrer = findReferrerForUserLevel(user, _level);\r\n\r\n    uint256 transferAmount = (levelPrices[_level] * 30) / 100;\r\n\r\n    // Transfer tokens to the referrer\r\n    if (referrer != address(0) && hasLevel(referrer, _level)) {\r\n        require(token.transfer(referrer, transferAmount), \"Token transfer to referrer failed\");\r\n    } else {\r\n        // Transfer tokens to the owner if there is no valid referrer\r\n        require(token.transfer(owner, transferAmount), \"Token transfer to owner failed\");\r\n    }\r\n\r\n    UpgradeIncome[user] = UpgradeIncome[user].add(transferAmount);\r\n\r\n    // Distribute additional upgrade rewards\r\n    _distributeUpgraderewards(user, _level);\r\n}\r\n\r\n// Check if the referrer has the required level\r\nfunction hasRequiredLevel(address _referrer, uint256 _requiredLevel) internal view returns (bool) {\r\n    return userCurrentLevel[_referrer] >= _requiredLevel;\r\n\r\n\r\n}\r\n\r\nfunction _distributeUpgraderewards(address user, uint256 _level) internal {\r\n    uint256 amount = levelPrices[_level];\r\n   address [4] memory referrersChain = [\r\n    referrers[user],\r\n    referrers[referrers[user]],\r\n    referrers[referrers[referrers[user]]],\r\n    referrers[referrers[referrers[referrers[user]]]]\r\n];\r\n\r\n    uint256 rewardPercentage = 10;\r\n\r\n    for (uint256 i = 0; i < referrersChain.length; i++) {\r\n        address  currentReferrer = (referrersChain[i]);\r\n        \r\n        if (hasRequiredLevel(currentReferrer, _level)) {\r\n            uint256 rewardAmount = (amount * rewardPercentage) / 100;\r\n            \r\n            if (userIDs[currentReferrer] != 0) {\r\n                token.transfer(currentReferrer, rewardAmount);\r\n                referralRewards[currentReferrer] += rewardAmount;\r\n            } else {\r\n                userIDs[currentReferrer] = 0;\r\n                token.transfer(owner, rewardAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    uint256 creatorReward = (amount * rewardPercentage) / 100;\r\n    token.transfer(owner, creatorReward);\r\n\r\n    for (uint256 i = 0; i < referrersChain.length; i++) {\r\n        address  currentReferrer = (referrersChain[i]);\r\n        totalRewards[currentReferrer] += creatorReward;\r\n    }\r\n\r\n     _distributeRandomUpgrade(amount, _level);\r\n}\r\n\r\n\r\n\r\n  function     _distributeRandomUpgrade(uint256 amount,uint256 ) internal {\r\n    uint256 remainingReward = amount.mul(20).div(100);\r\n    uint256 userLimit = numberOfUsers;\r\n\r\n    if (userLimit > 4) {\r\n        userLimit = 4;\r\n    }\r\n\r\n    for (uint256 i = 0; i < userLimit; i++) {\r\n        uint256 randomUserID;\r\n\r\n        randomUserID = uint256(keccak256(abi.encodePacked(block.timestamp, i, numberOfUsers))) % numberOfUsers + 1;\r\n        randomUser = idToAddress[randomUserID];\r\n\r\n        // Assuming your token contract is ERC-20 compliant\r\n        IERC20(token).transfer(randomUser, remainingReward.div(userLimit));\r\n        paymentsMade[randomUserID] = true;\r\n        RandomRewards[randomUser] = RandomRewards[randomUser].add(remainingReward.div(userLimit));\r\n    }\r\n\r\n    if (numberOfUsers < 4) {\r\n        uint256 remainingFunds = IERC20(token).balanceOf(address(this));\r\n        // Assuming your token contract is ERC-20 compliant\r\n        IERC20(token).transfer(owner, remainingFunds);\r\n    }\r\n\r\n}\r\n\r\n function findReferrerForUserLevel(address _user, uint _userLevel) internal view returns (address payable) {\r\n        address payable referrer = userDirectReferrer[_user];\r\n\r\n        // Parcourir les niveaux jusqu'\u00e0 atteindre le niveau d'activation de l'utilisateur\r\n        for (uint i = 1; i < _userLevel; i++) {\r\n            referrer = userDirectReferrer[referrer];\r\n\r\n            // Si le parrain n'existe pas ou n'a pas le niveau activ\u00e9, revenir au parrain direct (ID 1)\r\n            if (referrer == address(0) || !hasLevel(referrer, i + 1)) {\r\n                referrer = userDirectReferrer[_user];\r\n                break;\r\n            }\r\n        }\r\n\r\n        return referrer;\r\n    }\r\n    function getUserCurrentLevel(address _user) external view returns (uint) {\r\n        return userCurrentLevel[_user];\r\n    }\r\n\r\n    function getUserDirectReferrer(address _user) external view returns (address) {\r\n        return referrers[_user];\r\n    }\r\n\r\n\r\n    function hasLevel(address _user, uint _level) internal view returns (bool) {\r\n        return userLevels[_user] && userCurrentLevel[_user] >= _level;\r\n    }\r\n\r\n     \r\n\r\n    function distributeUpgradeearnings() external {\r\n        require(totalContributions > 0, \"No contributions to distribute\");\r\n        require(address(this).balance > 0, \"Contract balance is zero\");\r\n\r\n        uint256 ownerReward = address(this).balance.mul(10).div(100);\r\n\r\n      \r\n   _distributeUpgraderewards(msg.sender, userCurrentLevel[msg.sender]);\r\n\r\n        require(token.transfer(owner, ownerReward));\r\n\r\n        totalContributions = 0;\r\n    }\r\n\r\n    function changeOwner(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        \r\n            revert();\r\n            \r\n        \r\n        \r\n         \r\n    } \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"LevelPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RandomRewardsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"RegistrationFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"SponsorRewardsDistributed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LevelUpgradeIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RandomRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UpgradeIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeRegEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeUpgradeearnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectReferrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastRegistration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRefferresInfos\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalRefferalIcome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUpgradeIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserCurrentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserDirectReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentsMade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"purchaseLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userCurrentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDirectReferrer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLevels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InfinixForce", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c6e07189bc7565d53ce1c7744879620ccc70c17f", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://71d6a49afcafcc553a7bb0b42a406e6edecf3427dd116abc63fc38211cfe1203"}