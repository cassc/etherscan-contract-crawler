{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BonusContract.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n/*\\nhttps://dars.one/\\n*/\\npragma solidity 0.7.6;\\nimport \\\"./lib/IBEP20.sol\\\";\\nimport \\\"./lib/SafeMath.sol\\\";\\nimport \\\"./lib/ECDSA.sol\\\";\\nimport \\\"./lib/TransferHelper.sol\\\";\\n\\npragma experimental ABIEncoderV2;\\n\\ncontract BonusContract{\\n\\n    using SafeMath for uint256;\\n    using ECDSA for bytes32;\\n    using TransferHelper for IBEP20;\\n\\n    struct User {\\n        uint128 id;\\n        uint128 bonusNonce;\\n        uint256 totalBuy;\\n        uint256 totalBuyOutside;\\n        uint256 totalBuySpecial;\\n        uint256 affectedBuySpecial;\\n        uint256 totalUpgrade;\\n        uint256 totalBonus;  \\n    }\\n\\n    struct Packet{\\n        uint256 id;\\n        uint256 packetType;\\n        uint256 qty;\\n        uint256 packetPrice;\\n        address target;\\n        bool upgradable;\\n        bool affecting;\\n        bool cartDependent;\\n    }\\n    mapping(bytes32=>Packet) private packets;\\n    mapping(address=>bool) public migrated;\\n    bytes32[] private allPackets;\\n    \\n    IBEP20 immutable public bonusToken;\\n    address immutable public darsBasis;\\n    uint256 immutable public chainId;\\n    uint256 immutable public darsPercent;\\n    address immutable public companyOwner;\\n    address immutable public darsSigner;\\n    address public companySigner;\\n    address public migrationsAdmin;\\n    uint256 public bonusPercent;\\n    address public companyContract;\\n    string  public darsName;\\n    string  public Url;  \\n    uint128 public lastUserId = 0;\\n    uint128 public lastPacketId = 0;\\n    bool public lowBalance = false;\\n    bool public salesStopped = false;\\n    uint256 public totalWithdrawBonus;\\n    uint256 public totalBuy;\\n    uint256 public totalBuyOutside;\\n    uint256 public totalBuySpecial;\\n    uint256 public totalUpgrade;\\n    uint256 public lastWithdrawalTimestamp;\\n    uint256 constant public maxTermWithoutCompanySignature = 15552000;//180 days\\n\\n    \\n\\n    mapping(address => User) public users;\\n    mapping(uint128 => address) private usersID;\\n    \\n    modifier onlyCompanyOwner() {\\n        require(companyOwner == msg.sender, \\\"caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyDarsSigner() {\\n        require(darsSigner == msg.sender, \\\"caller is not darsSigner\\\");\\n        _;\\n    }\\n\\n\\n    event PacketAdded(uint256 id,\\n                uint256 packetType,\\n                uint256 qty,\\n                uint256 packetPrice,\\n                address targetContract,\\n                bytes32 singlePacketUID,\\n                bool upgradeable,\\n                bool affecting,\\n                bool cartDependent);\\n\\n    event PacketUpdated(uint256 id,\\n                uint256 qty,\\n                uint256 packetPrice,\\n                address targetContract,\\n                bytes32 singlePacketUID,\\n                bool upgradeable,\\n                bool affecting,\\n                bool cartDependent);\\n\\n    event Migrations(address user, \\n                    uint256 totalBuy,\\n                    uint256 totalBuyOutside,\\n                    uint256 totalBuySpecial,\\n                    uint256 affectedBuySpecial,\\n                    uint256 totalUpgrade);\\n\\n    event Withdraw(address user, uint256 amount,uint128 nextnonce);\\n    event Registration(address user, uint128 userId);\\n    event Buy(address user,uint256 price,bytes32 orderUID);\\n    event BuyOutside(address user,uint256 price,uint256 marketing);\\n    event BuySpecial(address user,uint256 price,bytes32 singlePacketUID);\\n    event UpgradeSpecial(address user,uint256 price,bytes32 singlePacketUID);\\n\\n    constructor(address _companyOwner,\\n                address _companySigner,\\n                address _darsSigner,\\n                address _companyContract,\\n                address _bonusToken,\\n                uint256 _darsPercent,\\n                uint256 _bonusPercent,\\n                string memory _darsName, \\n                string memory _Url) {\\n\\n        darsBasis = msg.sender;//parent, Dars platform base contract\\n        companyOwner = _companyOwner;\\n        darsSigner = _darsSigner;\\n        companySigner = _companySigner;\\n        companyContract = _companyContract;\\n        darsName = _darsName;\\n        Url = _Url;\\n        bonusPercent = _bonusPercent;\\n        darsPercent = _darsPercent;\\n        bonusToken=IBEP20(_bonusToken);\\n        uint256 _chainId;\\n        assembly {\\n            _chainId := chainid()\\n        }\\n        chainId=_chainId;\\n        lastWithdrawalTimestamp=block.timestamp;\\n    }\\n\\n    function antiSabotage(bool _lowBalance) external onlyDarsSigner {\\n       lowBalance=_lowBalance; \\n    }\\n\\n    function withdrawBonus(uint256 amount, bytes calldata signatureDars,bytes calldata signatureCompany) external {\\n        uint128 id=users[msg.sender].id;\\n        require(id>0,\\\"The user doesn't exist!\\\");\\n        require(amount>0,\\\"bonus must be greater than 0\\\");\\n        bytes32 hash=createHash(id,amount,users[msg.sender].bonusNonce);\\n        hash=hash.toEthSignedMessageHash();\\n        require(hash.recover(signatureDars)==darsSigner,\\\"dars signature is wrong\\\");\\n        bool isSolvent=bonusToken.balanceOf(address(this))>=amount;\\n        \\n        if((block.timestamp-lastWithdrawalTimestamp)<maxTermWithoutCompanySignature){\\n            require(hash.recover(signatureCompany)==companySigner,\\\"company signature is wrong\\\");\\n            lastWithdrawalTimestamp=block.timestamp;\\n        }else{\\n            salesStopped=true;\\n        }\\n        \\n        if(isSolvent){\\n            users[msg.sender].bonusNonce++;\\n            users[msg.sender].totalBonus=users[msg.sender].totalBonus.add(amount);\\n            totalWithdrawBonus=totalWithdrawBonus.add(amount);\\n            lowBalance=false;                     \\n            bonusToken.safeTransfer(address(msg.sender), amount);\\n            emit Withdraw(msg.sender,amount,users[msg.sender].bonusNonce);\\n        }else{\\n            require(lowBalance==false,\\\"low contract balance..Please contact to support of company.\\\");\\n            lowBalance=true;\\n        }\\n\\n    }\\n\\n\\n    function dbMigrations(address _user,\\n                        uint256 _totalBuy,\\n                        uint256 _totalBuyOutside,\\n                        uint256 _totalBuySpecial,\\n                        uint256 _affectedBuySpecial,\\n                        uint256 _totalUpgrade) external {\\n        \\n        require(migrationsAdmin==msg.sender,\\\"this caller is not a migration admin\\\");\\n        require(migrated[_user]==false,\\\"this user already migrated\\\");                    \\n        if(users[_user].id==0){\\n            _registration(_user);\\n        }\\n        migrated[_user]=true;\\n        User storage user = users[_user];\\n        user.totalBuy=user.totalBuy.add(_totalBuy);\\n        user.totalBuyOutside=user.totalBuyOutside.add(_totalBuyOutside);\\n        user.totalBuySpecial=user.totalBuySpecial.add(_totalBuySpecial);\\n        user.affectedBuySpecial=user.affectedBuySpecial.add(_affectedBuySpecial);\\n        user.totalUpgrade=user.totalUpgrade.add(_totalUpgrade);\\n        \\n        emit Migrations(_user, \\n                    user.totalBuy,\\n                    user.totalBuyOutside,\\n                    user.totalBuySpecial,\\n                    user.affectedBuySpecial,\\n                    user.totalUpgrade);\\n\\n    }\\n\\n    function _registration(address newUser) internal {\\n\\n        User memory user = User({\\n            id: ++lastUserId,\\n            bonusNonce: uint128(0),\\n            totalBuy: 0,\\n            totalBuyOutside:0,\\n            totalBuySpecial: 0,\\n            affectedBuySpecial:0,\\n            totalUpgrade:0,\\n            totalBonus: 0\\n        });\\n        users[newUser] = user;\\n        usersID[lastUserId]=newUser;\\n        emit Registration(newUser, lastUserId);\\n\\n    } \\n\\n    function _buy(address payer,uint256 price) internal {\\n        \\n        require(price > 0, \\\"price must be greater than 0\\\");\\n        require(!lowBalance, \\\"operations suspended, low balance for bonuses\\\");\\n        require(!salesStopped, \\\"this company under liquidation, the sale is stopped\\\");\\n        require(\\n            bonusToken.allowance(payer, address(this)) >=\\n                price,\\n            \\\"Increase the allowance first,call the approve method\\\"\\n        );\\n        \\n        bonusToken.safeTransferFrom(\\n            payer,\\n            address(this),\\n            price\\n        );\\n        uint256 toDarsAmount=price.mul(darsPercent).div(100);\\n        uint256 toBonusAmount=price.mul(bonusPercent).div(100);\\n        uint256 toCompanyAmount=price.sub(toDarsAmount.add(toBonusAmount));\\n        \\n        if(toDarsAmount>0){\\n            bonusToken.safeTransfer(darsBasis, toDarsAmount);\\n        }\\n\\n        if(toCompanyAmount>0){\\n            bonusToken.safeTransfer(companyContract, toCompanyAmount);\\n        }\\n\\n    }\\n\\n    //marketing 0-DEFAULT\\n    function buyOutside(address user,uint256 price,uint256 marketing) external {\\n        require(users[user].id>0,\\\"user not exist\\\");\\n        _buy(msg.sender,price);\\n        totalBuyOutside=totalBuyOutside.add(price);       \\n        users[user].totalBuyOutside=users[user].totalBuyOutside.add(price);\\n        emit BuyOutside(user,price,marketing);\\n    }\\n\\n    function buy(uint256 price,bytes32 orderUID) external {\\n        _buy(msg.sender,price);\\n        if(users[msg.sender].id==0){\\n            _registration(msg.sender);\\n        }\\n        totalBuy=totalBuy.add(price);       \\n        users[msg.sender].totalBuy=users[msg.sender].totalBuy.add(price);\\n        emit Buy(msg.sender,price,orderUID);\\n    }\\n\\n    function buySpecial(uint256 price,bytes32 singlePacketUID) external {\\n\\n        require(price > 0 && packets[singlePacketUID].packetPrice==price,\\\"bad packet price or packet not avaible\\\");\\n        _buy(msg.sender,price); \\n        if(users[msg.sender].id==0){\\n            _registration(msg.sender);\\n        }\\n        totalBuySpecial=totalBuySpecial.add(price);\\n        users[msg.sender].totalBuySpecial=users[msg.sender].totalBuySpecial.add(price);\\n\\n        if(packets[singlePacketUID].affecting){\\n            users[msg.sender].affectedBuySpecial=users[msg.sender].affectedBuySpecial.add(price);\\n        }\\n\\n        if(packets[singlePacketUID].target!=address(0)){\\n            (bool success,) = packets[singlePacketUID].target\\n            .call(abi.encodeWithSignature(\\\"delivery(address,uint256,uint256,uint256,uint256)\\\",\\n            msg.sender,packets[singlePacketUID].packetType,packets[singlePacketUID].qty,packets[singlePacketUID].id,price));\\n            require(success,\\\"delivery call FAIL\\\");\\n        }\\n        \\n        emit BuySpecial(msg.sender,price,singlePacketUID);\\n    }\\n\\n    function upgradeSpecial(uint256 maxPrice,bytes32 singlePacketUID) external {\\n        require(users[msg.sender].id>0,\\\"user not exist\\\");\\n\\n        (bool success,uint256 price) = getUpgradePriceIfAvailable(msg.sender,singlePacketUID);\\n        require(success,\\\"This upgrade is not available\\\");\\n        require(price <= maxPrice,\\\"bad upgrade price, maybe the packet price was changed\\\");\\n        _buy(msg.sender,price);\\n        totalUpgrade=totalUpgrade.add(price);\\n        users[msg.sender].totalUpgrade=users[msg.sender].totalUpgrade.add(price);\\n        \\n        if(packets[singlePacketUID].affecting){\\n            users[msg.sender].affectedBuySpecial=users[msg.sender].affectedBuySpecial.add(price);\\n        }      \\n\\n        if(packets[singlePacketUID].target!=address(0)){\\n            (success,) = packets[singlePacketUID].target\\n            .call(abi.encodeWithSignature(\\\"upgradeDelivery(address,uint256,uint256,uint256,uint256)\\\",\\n            msg.sender,packets[singlePacketUID].packetType,packets[singlePacketUID].qty,packets[singlePacketUID].id,price));\\n            require(success,\\\"upgradeDelivery call FAIL\\\");\\n        }\\n        \\n        emit UpgradeSpecial(msg.sender,price,singlePacketUID);\\n\\n    }\\n\\n    function getUpgradePriceIfAvailable(address user,bytes32 singlePacketUID) public view returns (bool,uint256) {\\n\\n        if(users[user].id > 0 && packets[singlePacketUID].packetPrice>0 && packets[singlePacketUID].upgradable){\\n            uint256 affected=users[user].affectedBuySpecial;\\n            if(packets[singlePacketUID].cartDependent){\\n                affected = affected.add(users[user].totalBuy).add(users[user].totalBuyOutside);\\n            }\\n            if(packets[singlePacketUID].packetPrice>affected){\\n                return (true,packets[singlePacketUID].packetPrice.sub(affected)); \\n            }\\n        }\\n        return (false,0);\\n    }\\n\\n    function getPacketsList() public view returns (bytes32[] memory) {\\n        return allPackets;\\n    }\\n\\n    function uidToId(bytes32 singlePacketUID) external view returns (uint256){\\n        return packets[singlePacketUID].id;\\n    }\\n\\n    function getPacketByUID(bytes32 singlePacketUID) external view returns (Packet memory){\\n        \\n        return packets[singlePacketUID];\\n    }\\n\\n    function getPacketByID(uint256 packetId) external view returns (Packet memory){\\n        require(packetId > 0 && packetId <= lastPacketId, \\\"wrong Id\\\");\\n        bytes32 id = allPackets[packetId-1];\\n        return packets[id];\\n    }\\n\\n    function isPacketActive(bytes32 singlePacketUID) external view returns(bool){\\n        return (packets[singlePacketUID].target != address(0));\\n    } \\n\\n    function createHash(uint128 to, uint256 amount, uint128 nonce) internal view returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(chainId, this, to, amount, nonce));\\n    }\\n    \\n    function isUserExists(address user) external view returns (bool) {\\n        return (users[user].id > 0);\\n    }\\n\\n    function getUserNonce(address user) external view returns (uint128) {\\n        return users[user].bonusNonce;\\n    }\\n\\n    function addressToId(address user) external view returns (uint128) {\\n        require(users[user].id>0,\\\"The user doesn't exist!\\\");\\n        return users[user].id;\\n    }\\n\\n    function idToAddress(uint128 id) external view returns (address) {\\n        require(id>0 && id<=lastUserId,\\\"The user doesn't exist!\\\");\\n        return usersID[id];\\n    }\\n    /*\\n        TYPE_PACKAGE = 1;\\n        TYPE_ACTIVITY = 2;\\n        TYPE_ONE_TIME_FEE = 3;\\n    */\\n    function addPacket(uint256 _qty,\\n                    uint256 _packetType,\\n                    uint256 _packetPrice, \\n                    address _target,\\n                    bytes32 singlePacketUID,\\n                    bool _upgradable,\\n                    bool _affecting,\\n                    bool _cartDependent) external onlyCompanyOwner {\\n        \\n        if(_target!=address(0)){\\n            uint32 size;\\n            assembly {\\n                size := extcodesize(_target)\\n            }\\n            require(size != 0, \\\"The target must be a contract or zero address\\\");\\n        }\\n        \\n\\n        if(packets[singlePacketUID].id>0){\\n            require(packets[singlePacketUID].packetType==_packetType,\\\"type change not available\\\");\\n            packets[singlePacketUID].qty=_qty;\\n            packets[singlePacketUID].packetPrice=_packetPrice;\\n            packets[singlePacketUID].target=_target;\\n            packets[singlePacketUID].upgradable=_upgradable;\\n            packets[singlePacketUID].affecting=_affecting;\\n            packets[singlePacketUID].cartDependent=_cartDependent;\\n            emit PacketUpdated(packets[singlePacketUID].id,_qty,_packetPrice, _target, singlePacketUID,_upgradable,_affecting,_cartDependent);\\n        }else{\\n            packets[singlePacketUID]=Packet(\\n            {id:++lastPacketId,\\n            packetType:_packetType,\\n            qty:_qty,\\n            packetPrice:_packetPrice,\\n            target:_target,\\n            upgradable:_upgradable,\\n            affecting:_affecting,\\n            cartDependent:_cartDependent\\n            });\\n            allPackets.push(singlePacketUID);\\n            emit PacketAdded(lastPacketId,_packetType,_qty,_packetPrice, _target, singlePacketUID,_upgradable,_affecting,_cartDependent);\\n        }\\n        \\n    }\\n\\n    function setMigrationsAdmin(address _migrationsAdmin) external onlyCompanyOwner {\\n        migrationsAdmin = _migrationsAdmin;\\n    }\\n\\n    function setBonusPercent(uint256 newPercent) external onlyCompanyOwner {\\n        require(newPercent>0 && newPercent <= uint256(100).sub(darsPercent),\\\"bad percent\\\");\\n        bonusPercent = newPercent;\\n    }\\n    \\n    function setCompanyUrl(string calldata _Url) external onlyCompanyOwner {\\n        Url = _Url;\\n    }\\n    function setCompanyContract(address _companyContract) external onlyCompanyOwner {\\n        companyContract = _companyContract;\\n    }\\n\\n    function setCompanySigner(address _companySigner) external onlyCompanyOwner {\\n        companySigner = _companySigner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.4 <0.8.0;\\n\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.4 <0.8.0;\\n\\n/**\\n * Copyright (c) 2016-2019 zOS Global Limited\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.4 <0.8.0;\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TransferHelper {\\n    using SafeMath for uint256;\\n\\n    function safeTransfer(\\n        IBEP20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            address(token).call(\\n                abi.encodeWithSelector(token.transfer.selector, to, value)\\n            );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IBEP20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            address(token).call(\\n                abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n            );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IBEP20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance =\\n            token.allowance(address(this), spender).add(value);\\n\\n        (bool success, bytes memory data) =\\n            address(token).call(\\n                abi.encodeWithSelector(token.approve.selector,spender,newAllowance)\\n            );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"INCREASE_ALLOWANCE_FAILED\\\"\\n        );     \\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_companyOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_companySigner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_darsSigner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_companyContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonusToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_darsPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusPercent\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_darsName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Url\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderUID\",\"type\":\"bytes32\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"name\":\"BuyOutside\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"}],\"name\":\"BuySpecial\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBuyOutside\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBuySpecial\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"affectedBuySpecial\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalUpgrade\",\"type\":\"uint256\"}],\"name\":\"Migrations\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packetPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"upgradeable\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"affecting\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"cartDependent\",\"type\":\"bool\"}],\"name\":\"PacketAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packetPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"upgradeable\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"affecting\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"cartDependent\",\"type\":\"bool\"}],\"name\":\"PacketUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"userId\",\"type\":\"uint128\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"}],\"name\":\"UpgradeSpecial\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nextnonce\",\"type\":\"uint128\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Url\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_qty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_packetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_packetPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_upgradable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_affecting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_cartDependent\",\"type\":\"bool\"}],\"name\":\"addPacket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addressToId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lowBalance\",\"type\":\"bool\"}],\"name\":\"antiSabotage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"orderUID\",\"type\":\"bytes32\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"name\":\"buyOutside\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"}],\"name\":\"buySpecial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companySigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsBasis\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalBuyOutside\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalBuySpecial\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_affectedBuySpecial\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalUpgrade\",\"type\":\"uint256\"}],\"name\":\"dbMigrations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packetId\",\"type\":\"uint256\"}],\"name\":\"getPacketByID\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packetPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"upgradable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"affecting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"cartDependent\",\"type\":\"bool\"}],\"internalType\":\"struct BonusContract.Packet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"}],\"name\":\"getPacketByUID\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packetPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"upgradable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"affecting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"cartDependent\",\"type\":\"bool\"}],\"internalType\":\"struct BonusContract.Packet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPacketsList\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"}],\"name\":\"getUpgradePriceIfAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserNonce\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"id\",\"type\":\"uint128\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"}],\"name\":\"isPacketActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPacketId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWithdrawalTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTermWithoutCompanySignature\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"migrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationsAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salesStopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPercent\",\"type\":\"uint256\"}],\"name\":\"setBonusPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_companyContract\",\"type\":\"address\"}],\"name\":\"setCompanyContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_companySigner\",\"type\":\"address\"}],\"name\":\"setCompanySigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_Url\",\"type\":\"string\"}],\"name\":\"setCompanyUrl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_migrationsAdmin\",\"type\":\"address\"}],\"name\":\"setMigrationsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyOutside\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuySpecial\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUpgrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"}],\"name\":\"uidToId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"singlePacketUID\",\"type\":\"bytes32\"}],\"name\":\"upgradeSpecial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"id\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"bonusNonce\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"totalBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBuyOutside\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBuySpecial\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"affectedBuySpecial\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUpgrade\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatureDars\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatureCompany\",\"type\":\"bytes\"}],\"name\":\"withdrawBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BonusContract", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bac5e7d0f79ffea16c301c58665caa0fa54d6938000000000000000000000000b951f37d51b334779fd143a516f5b6e9b8c04f00000000000000000000000000dd8be8ec1127c7354b543a2e890dba5a4dad1729000000000000000000000000972aa1c98d4e822462d7e8c8420f208e609e95f100000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000c616d7a6e6770726f6a65637400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012706c6174666f726d67616c6178792e636f6d0000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}