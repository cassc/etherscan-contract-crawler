{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Reflecto.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libs/IBEP20.sol\\\";\\nimport \\\"./libs/Auth.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\nimport \\\"./libs/IDEX.sol\\\";\\nimport \\\"./libs/IProviderPair.sol\\\";\\nimport \\\"./libs/ICalculator.sol\\\";\\nimport \\\"./DividendDistributor.sol\\\";\\n\\ninterface IReflectoRewards {\\n    function _updateRewardsPerToken() external;\\n\\n    function _updateUserRewards(address user) external;\\n}\\n\\ncontract Reflecto is IBEP20, Auth {\\n    using SafeMath for uint256;\\n\\n    struct Swap {\\n        uint256 liquidityFee;\\n        uint256 reflectionFee;\\n        uint256 marketingFee;\\n        uint256 gasWalletFee;\\n        uint256 totalFee;\\n        uint256 swapThreshold;\\n    }\\n\\n    struct Processing {\\n        bool onSell;\\n        bool onBuy;\\n        bool onTransfer;\\n    }\\n\\n    Processing public whenProcess;\\n    uint256 public constant MASK = type(uint128).max;\\n    address BUSD;\\n    address Crypter;\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\n    address DEAD_NON_CHECKSUM = 0x000000000000000000000000000000000000dEaD;\\n\\n    string constant _name = \\\"Reflecto\\\";\\n    string constant _symbol = \\\"RTO\\\";\\n    uint8 constant _decimals = 9;\\n\\n    uint256 _totalSupply = 1_000_000_000_000_000 * (10**_decimals);\\n\\n    mapping(address => uint256) _balances;\\n    mapping(address => uint256) public nonces;\\n    mapping(address => mapping(address => uint256)) _allowances;\\n\\n    mapping(address => bool) isFeeExempt;\\n    mapping(address => bool) isTxLimitExempt;\\n    mapping(address => bool) isDividendExempt;\\n\\n    IDEXRouter[] public routers;\\n    mapping(address => bool) public isBNBRouter;\\n    uint256 routerIndex = 0;\\n    IDEXRouter public defaultRouter;\\n    bool public isDefaultForSwap = false;\\n\\n    address public calculator;\\n\\n    address public autoLiquidityReceiver;\\n    address public marketingFeeReceiver;\\n    address public gasWalletFeeReceiver;\\n\\n    uint256 targetLiquidity = 25;\\n    uint256 targetLiquidityDenominator = 100;\\n\\n    uint256 public launchedAt;\\n    uint256 public launchedAtTimestamp;\\n\\n    uint256 buybackMultiplierNumerator = 200;\\n    uint256 buybackMultiplierDenominator = 100;\\n    uint256 buybackMultiplierTriggeredAt;\\n    uint256 buybackMultiplierLength = 30 minutes;\\n\\n    bool public autoBuybackEnabled = false;\\n    mapping(address => bool) buyBacker;\\n    mapping(address => bool) public pairs;\\n    uint256 autoBuybackCap;\\n    uint256 autoBuybackAccumulator;\\n    uint256 autoBuybackAmount;\\n    uint256 autoBuybackBlockPeriod = 1 minutes;\\n    uint256 autoBuybackBlockLast;\\n    bool public isRoundRobinBuyback = false;\\n\\n    IReflectoRewards public reflectoRewards;\\n\\n    bool isCancelingEnabled = true;\\n    uint256 burnDivider = 0;\\n    bool isBuyBackEnabled = true;\\n    uint256 buyBackDivider = 0;\\n\\n    bool isSentToPoolEnabled = true;\\n\\n    uint256 public minimumStakingLimit = 100000000000000000000;\\n\\n    DividendDistributor distributor;\\n    // address public distributorAddress;\\n    uint256 distributorGas = 500000;\\n\\n    // --- EIP712 niceties ---\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\\n\\n    bool public swapEnabled = true;\\n    bool public isSwapOnSell = true;\\n\\n    mapping(address => uint256) public timeOfSell;\\n    mapping(address => uint256) public amountOfSell;\\n    uint256 public sellLimit = 100000000000000000000;\\n\\n    uint256 public maxCancelingAmount = 100000000000000000000;\\n\\n    uint256 public burnCounter = 0;\\n\\n    bool inSwap;\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    mapping(address => bool) public isUserMigrated;\\n    bool public isMigrationEnded;\\n\\n    constructor() Auth(msg.sender) {\\n        isFeeExempt[msg.sender] = true;\\n        isTxLimitExempt[msg.sender] = true;\\n        isDividendExempt[address(this)] = true;\\n        isDividendExempt[DEAD] = true;\\n        buyBacker[msg.sender] = true;\\n\\n        autoLiquidityReceiver = msg.sender;\\n        marketingFeeReceiver = msg.sender;\\n        gasWalletFeeReceiver = msg.sender;\\n\\n        _balances[msg.sender] = _totalSupply;\\n\\n        whenProcess.onBuy = true;\\n        whenProcess.onSell = true;\\n        whenProcess.onTransfer = true;\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(_name)),\\n                keccak256(bytes(version())),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\n    }\\n\\n    function setProcessing(\\n        bool _onBuy,\\n        bool _onSell,\\n        bool _onTransfer\\n    ) external authorized {\\n        whenProcess.onBuy = _onBuy;\\n        whenProcess.onSell = _onSell;\\n        whenProcess.onTransfer = _onTransfer;\\n    }\\n\\n    function endMigration() external authorized {\\n        isMigrationEnded = true;\\n    }\\n\\n    function setAutoStakingContract(address reflectoRewardsContract)\\n        external\\n        authorized\\n    {\\n        isDividendExempt[reflectoRewardsContract] = true;\\n        isFeeExempt[reflectoRewardsContract] = true;\\n        reflectoRewards = IReflectoRewards(reflectoRewardsContract);\\n    }\\n\\n    function setSellCancelingEnabled(bool _isEnabled) external authorized {\\n        isCancelingEnabled = _isEnabled;\\n    }\\n\\n    function setMaxSellCancelingAmount(uint256 _amount) external authorized {\\n        maxCancelingAmount = _amount;\\n    }\\n\\n    function setEnableRoundRobinBuyback(bool _isEnabled) external authorized {\\n        isRoundRobinBuyback = _isEnabled;\\n    }\\n\\n    function setPoolSendEnabled(bool _isEnabled) external authorized {\\n        isSentToPoolEnabled = _isEnabled;\\n    }\\n\\n    function addPair(address pairAddress) external authorized {\\n        pairs[pairAddress] = true;\\n        isDividendExempt[pairAddress] = true;\\n    }\\n\\n    function deletePair(address pairAddress) external authorized {\\n        pairs[pairAddress] = false;\\n        isDividendExempt[pairAddress] = false;\\n    }\\n\\n    function setDefaultRouter(address router, bool isBNB) external authorized {\\n        defaultRouter = IDEXRouter(router);\\n        isBNBRouter[router] = isBNB;\\n        _allowances[address(this)][router] = _totalSupply;\\n    }\\n\\n    function setDefaultRouterFromSwapBack(bool isEnabled) external authorized {\\n        isDefaultForSwap = isEnabled;\\n    }\\n\\n    function addRouter(address router, bool isBNB) external authorized {\\n        IDEXRouter routerNew = IDEXRouter(router);\\n        _allowances[address(this)][router] = _totalSupply;\\n        isBNBRouter[router] = isBNB;\\n        routers.push(routerNew);\\n        routerIndex = 0;\\n    }\\n\\n    function removeRouter(uint256 index) external authorized {\\n        IDEXRouter routerLast = routers[routers.length - 1];\\n        routers[index] = routerLast;\\n        routers.pop();\\n        routerIndex = 0;\\n    }\\n\\n    function getRouter() internal view returns (IDEXRouter) {\\n        if (isDefaultForSwap) {\\n            return defaultRouter;\\n        }\\n        IDEXRouter currentRouter = routers[routerIndex];\\n\\n        return currentRouter;\\n    }\\n\\n    function updateRouterIndex() internal {\\n        if (routerIndex + 1 > routers.length - 1) {\\n            routerIndex = 0;\\n        } else {\\n            routerIndex = routerIndex + 1;\\n        }\\n    }\\n\\n    function setFeeCalulator(address calc) external authorized {\\n        calculator = calc;\\n    }\\n\\n    function setMinimumStakingLimitAmount(uint256 amount) external authorized {\\n        minimumStakingLimit = amount;\\n    }\\n\\n    /// @dev Setting the version as a function so that it can be overriden\\n    function version() public pure virtual returns (string memory) {\\n        return \\\"1\\\";\\n    }\\n\\n    function getChainID() external view returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    receive() external payable {}\\n\\n    // For testing\\n    function donate() external payable {}\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return owner;\\n    }\\n\\n    modifier onlyBuybacker() {\\n        require(buyBacker[msg.sender] == true, \\\"\\\");\\n        _;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address holder, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, _totalSupply);\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        return _transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (_allowances[sender][msg.sender] != _totalSupply) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\\n                .sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function migrateV1ToV2(address[] memory v1holders)\\n        external\\n        authorized\\n        returns (bool)\\n    {\\n        require(isMigrationEnded == false, \\\"Migration completed\\\");\\n\\n        for (uint256 i = 0; i < v1holders.length; i++) {\\n            uint256 bHolder = IBEP20(0xaeFCb0411c83B5422Fcf122efEA6D262D2455012)\\n                .balanceOf(v1holders[i]);\\n            if (\\n                bHolder > 0 &&\\n                bHolder < 20000000000000000000000 &&\\n                !isUserMigrated[v1holders[i]]\\n            ) {\\n                _balances[msg.sender] = _balances[msg.sender].sub(\\n                    bHolder,\\n                    \\\"Insufficient Balance\\\"\\n                );\\n                _balances[v1holders[i]] = bHolder;\\n                isUserMigrated[v1holders[i]] = true;\\n                emit Transfer(msg.sender, v1holders[i], bHolder);\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n        if (\\n            (isDividendExempt[sender] || isDividendExempt[recipient]) &&\\n            (!shouldTakeFee(sender) || !shouldTakeFee(recipient))\\n        ) {\\n            _basicTransfer(sender, recipient, amount);\\n            if (!isDividendExempt[sender]) {\\n                try distributor.setShare(sender, _balances[sender]) {} catch {}\\n            }\\n            if (!isDividendExempt[recipient]) {\\n                try\\n                    distributor.setShare(recipient, _balances[recipient])\\n                {} catch {}\\n            }\\n            setStakes(sender, recipient);\\n            if (pairs[recipient]) {\\n                ICalculator(calculator).registerBuySell(amount, false);\\n            } else if (pairs[sender]) {\\n                ICalculator(calculator).registerBuySell(amount, true);\\n            }\\n            return true;\\n        }\\n\\n        if (shouldAutoBuyback()) {\\n            autoBuybackBlockLast = block.timestamp;\\n            algoBB(pairs[recipient], amount);\\n        }\\n\\n        Fees memory allFees = ICalculator(calculator).getFees();\\n        uint256 swapThreshold = ICalculator(calculator).getSwapThreshold();\\n        if (shouldSwapBack(recipient, swapThreshold)) {\\n            swapBack(\\n                Swap(\\n                    pairs[recipient]\\n                        ? allFees.sellLiquidityFee\\n                        : allFees.buyLiquidityFee,\\n                    pairs[recipient]\\n                        ? allFees.sellReflectionFee\\n                        : allFees.buyReflectionFee,\\n                    pairs[recipient]\\n                        ? allFees.sellDevelopmentFee\\n                        : allFees.buyDevelopmentFee,\\n                    pairs[recipient]\\n                        ? allFees.sellGasWalletFee\\n                        : allFees.buyGasWalletFee,\\n                    pairs[recipient] ? allFees.sellTotal : allFees.buyTotal,\\n                    swapThreshold\\n                )\\n            );\\n        }\\n\\n        uint256 amountReceived;\\n        if (\\n            ICalculator(calculator).isCustomFeeReceiverOrSender(\\n                sender,\\n                recipient\\n            )\\n        ) {\\n            if (!pairs[recipient] && !pairs[sender]) {\\n                amountReceived = amount;\\n                if (whenProcess.onTransfer) {\\n                    try distributor.process(distributorGas) {} catch {}\\n                }\\n            } else {\\n                Fees memory usersFees = ICalculator(calculator).getUserFees(\\n                    sender,\\n                    recipient\\n                );\\n                amountReceived = !shouldTakeFee(sender) ||\\n                    !shouldTakeFee(recipient)\\n                    ? amount\\n                    : takeFee(\\n                        sender,\\n                        amount,\\n                        pairs[recipient]\\n                            ? usersFees.sellTotal\\n                            : usersFees.buyTotal,\\n                        usersFees.buyFeeDenominator\\n                    );\\n\\n                if (pairs[recipient]) {\\n                    ICalculator(calculator).registerBuySell(amount, false);\\n                    if (whenProcess.onSell) {\\n                        try distributor.process(distributorGas) {} catch {}\\n                    }\\n                } else if (pairs[sender]) {\\n                    ICalculator(calculator).registerBuySell(amount, true);\\n                    if (whenProcess.onBuy) {\\n                        try distributor.process(distributorGas) {} catch {}\\n                    }\\n                }\\n            }\\n        } else if (pairs[recipient]) {\\n            checkTxLimit(sender, amount);\\n            // sell\\n            amountReceived = !shouldTakeFee(sender) || !shouldTakeFee(recipient)\\n                ? amount\\n                : takeFee(\\n                    sender,\\n                    amount,\\n                    allFees.sellTotal,\\n                    allFees.sellFeeDenominator\\n                );\\n            ICalculator(calculator).registerBuySell(amount, false);\\n            if (whenProcess.onSell) {\\n                try distributor.process(distributorGas) {} catch {}\\n            }\\n        } else if (pairs[sender]) {\\n            // buy\\n            amountReceived = !shouldTakeFee(sender) || !shouldTakeFee(recipient)\\n                ? amount\\n                : takeFee(\\n                    sender,\\n                    amount,\\n                    allFees.buyTotal,\\n                    allFees.buyFeeDenominator\\n                );\\n            ICalculator(calculator).registerBuySell(amount, true);\\n            if (whenProcess.onBuy) {\\n                try distributor.process(distributorGas) {} catch {}\\n            }\\n        } else if (allFees.transferFee > 0) {\\n            amountReceived = !shouldTakeFee(sender) || !shouldTakeFee(recipient)\\n                ? amount\\n                : takeFee(\\n                    sender,\\n                    amount,\\n                    allFees.transferFee,\\n                    allFees.buyFeeDenominator\\n                );\\n            if (timeOfSell[sender] + 1 days > block.timestamp) {\\n                timeOfSell[recipient] = timeOfSell[sender];\\n                amountOfSell[recipient] = amountOfSell[sender];\\n            }\\n            if (whenProcess.onTransfer) {\\n                try distributor.process(distributorGas) {} catch {}\\n            }\\n        } else {\\n            amountReceived = amount;\\n            if (timeOfSell[sender] + 1 days > block.timestamp) {\\n                timeOfSell[recipient] = timeOfSell[sender];\\n                amountOfSell[recipient] = amountOfSell[sender];\\n            }\\n            if (whenProcess.onTransfer) {\\n                try distributor.process(distributorGas) {} catch {}\\n            }\\n        }\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\n\\n        if (!isDividendExempt[sender]) {\\n            try distributor.setShare(sender, _balances[sender]) {} catch {}\\n        }\\n        if (!isDividendExempt[recipient]) {\\n            try\\n                distributor.setShare(recipient, _balances[recipient])\\n            {} catch {}\\n        }\\n        setStakes(sender, recipient);\\n        updateRouterIndex();\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n\\n    function setStakes(address sender, address recipient) internal {\\n        try reflectoRewards._updateRewardsPerToken() {} catch {}\\n        try reflectoRewards._updateUserRewards(sender) {} catch {}\\n        try reflectoRewards._updateUserRewards(recipient) {} catch {}\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function checkTxLimit(address sender, uint256 amount) internal {\\n        if (timeOfSell[sender] + 1 days < block.timestamp) {\\n            amountOfSell[sender] = 0;\\n        }\\n        require(\\n            (amount + amountOfSell[sender] <= sellLimit) ||\\n                isTxLimitExempt[sender],\\n            \\\"Exceeded TX daily limit\\\"\\n        );\\n\\n        timeOfSell[sender] = block.timestamp;\\n        amountOfSell[sender] = amountOfSell[sender] + amount;\\n    }\\n\\n    function shouldTakeFee(address sender) internal view returns (bool) {\\n        return !isFeeExempt[sender];\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        uint256 amount,\\n        uint256 totalFee,\\n        uint256 denominator\\n    ) internal returns (uint256) {\\n        uint256 feeAmount = amount.mul(totalFee).div(denominator);\\n\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount.sub(feeAmount);\\n    }\\n\\n    function shouldSwapBack(address recipient, uint256 _swapThreshold)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return\\n            (pairs[recipient] || !isSwapOnSell) &&\\n            !pairs[msg.sender] &&\\n            !inSwap &&\\n            swapEnabled &&\\n            _balances[address(this)] >= _swapThreshold;\\n    }\\n\\n    function sendToThePool(uint256 _swapThreshold) internal returns (bool) {\\n        if (!isSentToPoolEnabled) {\\n            return true;\\n        }\\n        // return true if disabled\\n        (bool shoudFundByPressure, uint256 amount) = ICalculator(calculator)\\n            .getFundPoolByPressureData(\\n                _swapThreshold,\\n                address(reflectoRewards),\\n                minimumStakingLimit\\n            );\\n        if (shoudFundByPressure) {\\n            fundStakingPool(amount);\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function fundStakingPool(uint256 amount) internal {\\n        _balances[address(this)] = _balances[address(this)].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[address(reflectoRewards)] = _balances[\\n            address(reflectoRewards)\\n        ].add(amount);\\n        emit Transfer(address(this), address(reflectoRewards), amount);\\n    }\\n\\n    function algoBB(bool isSell, uint256 amount) internal {\\n        IDEXRouter router = getRouter();\\n        address pairOfRouter = IDEXFactory(router.factory()).getPair(\\n            isBNBRouter[address(router)] ? router.WBNB() : router.WETH(),\\n            address(this)\\n        );\\n\\n        (bool shouldBB, uint256 amountToBuy) = ICalculator(calculator)\\n            .getAlgoBuybackData(amount, isSell, pairOfRouter);\\n\\n        if (!shouldBB) {\\n            return;\\n        }\\n\\n        uint256 beforeBB = _balances[DEAD];\\n        buyTokens(amountToBuy, DEAD);\\n        burnCounter = burnCounter.add(_balances[DEAD].sub(beforeBB));\\n    }\\n\\n    function getPath(IDEXRouter router)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = isBNBRouter[address(router)] ? router.WBNB() : router.WETH();\\n        return path;\\n    }\\n\\n    function swapBack(Swap memory swap) internal swapping {\\n        if (!sendToThePool(swap.swapThreshold)) {\\n            return;\\n        }\\n        IDEXRouter router = getRouter();\\n        address pairOfRouter = IDEXFactory(router.factory()).getPair(\\n            isBNBRouter[address(router)] ? router.WBNB() : router.WETH(),\\n            address(this)\\n        );\\n\\n        uint256 dynamicLiquidityFee = isOverLiquified(\\n            targetLiquidity,\\n            targetLiquidityDenominator,\\n            pairOfRouter\\n        )\\n            ? 0\\n            : swap.liquidityFee;\\n        uint256 amountToLiquify = swap\\n            .swapThreshold\\n            .mul(dynamicLiquidityFee)\\n            .div(swap.totalFee)\\n            .div(2);\\n        uint256 amountToSwap = swap.swapThreshold.sub(amountToLiquify);\\n        (uint256 priceDataBeforeSwap, , ) = ICalculator(calculator).getPrices(\\n            pairOfRouter\\n        );\\n        uint256 balanceBefore = address(this).balance;\\n\\n        isBNBRouter[address(router)]\\n            ? router.swapExactTokensForBNBSupportingFeeOnTransferTokens(\\n                amountToSwap,\\n                0,\\n                getPath(router),\\n                address(this),\\n                block.timestamp\\n            )\\n            : router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                amountToSwap,\\n                0,\\n                getPath(router),\\n                address(this),\\n                block.timestamp\\n            );\\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\\n        uint256 totalBNBFee = swap.totalFee.sub(dynamicLiquidityFee.div(2));\\n        uint256 amountBNBLiquidity = amountBNB\\n            .mul(dynamicLiquidityFee)\\n            .div(totalBNBFee)\\n            .div(2);\\n\\n        try\\n            distributor.deposit{\\n                value: amountBNB.mul(swap.reflectionFee).div(totalBNBFee)\\n            }()\\n        {} catch {}\\n        payable(marketingFeeReceiver).transfer(\\n            amountBNB.mul(swap.marketingFee).div(totalBNBFee)\\n        );\\n        payable(gasWalletFeeReceiver).transfer(\\n            amountBNB.mul(swap.gasWalletFee).div(totalBNBFee)\\n        );\\n        if (amountToLiquify > 0) {\\n            isBNBRouter[address(router)]\\n                ? router.addLiquidityBNB{value: amountBNBLiquidity}(\\n                    address(this),\\n                    amountToLiquify,\\n                    0,\\n                    0,\\n                    autoLiquidityReceiver,\\n                    block.timestamp\\n                )\\n                : router.addLiquidityETH{value: amountBNBLiquidity}(\\n                    address(this),\\n                    amountToLiquify,\\n                    0,\\n                    0,\\n                    autoLiquidityReceiver,\\n                    block.timestamp\\n                );\\n            emit AutoLiquify(amountBNBLiquidity, amountToLiquify);\\n        }\\n\\n        if (isCancelingEnabled) {\\n            (\\n                bool sholdCancel,\\n                uint256 cancelingAmount,\\n                address targetAddress\\n            ) = ICalculator(calculator).getSellCancelingAmount(\\n                    pairOfRouter,\\n                    priceDataBeforeSwap\\n                );\\n            if (\\n                _balances[targetAddress] >= cancelingAmount &&\\n                cancelingAmount > 0 &&\\n                cancelingAmount <= maxCancelingAmount &&\\n                sholdCancel\\n            ) {\\n                if (burnDivider > 0) {\\n                    cancelingAmount = cancelingAmount.div(burnDivider);\\n                }\\n                _balances[targetAddress] = _balances[targetAddress].sub(\\n                    cancelingAmount\\n                );\\n                _totalSupply = _totalSupply.sub(cancelingAmount);\\n                try reflectoRewards._updateRewardsPerToken() {} catch {}\\n                IProviderPair(pairOfRouter).sync();\\n            }\\n        }\\n    }\\n\\n    function shouldAutoBuyback() internal view returns (bool) {\\n        return\\n            !pairs[msg.sender] &&\\n            !inSwap &&\\n            autoBuybackEnabled &&\\n            autoBuybackBlockLast + autoBuybackBlockPeriod <= block.timestamp;\\n    }\\n\\n    function triggerZeusBuyback(uint256 amount, bool triggerBuybackMultiplier)\\n        external\\n        authorized\\n    {\\n        uint256 beforeBB = _balances[DEAD];\\n        buyTokens(amount, DEAD);\\n        burnCounter = burnCounter + _balances[DEAD].sub(beforeBB);\\n        if (triggerBuybackMultiplier) {\\n            buybackMultiplierTriggeredAt = block.timestamp;\\n            emit BuybackMultiplierActive(buybackMultiplierLength);\\n        }\\n    }\\n\\n    function clearBuybackMultiplier() external authorized {\\n        buybackMultiplierTriggeredAt = 0;\\n    }\\n\\n    function buyTokens(uint256 amount, address to) internal swapping {\\n        address[] memory path = new address[](2);\\n        IDEXRouter selectedRouter = !isRoundRobinBuyback\\n            ? defaultRouter\\n            : getRouter();\\n        address WBNB_OR_WETH = isBNBRouter[address(selectedRouter)]\\n            ? selectedRouter.WBNB()\\n            : selectedRouter.WETH();\\n        path[0] = WBNB_OR_WETH;\\n        path[1] = address(this);\\n\\n        isBNBRouter[address(selectedRouter)]\\n            ? selectedRouter.swapExactBNBForTokensSupportingFeeOnTransferTokens{\\n                value: amount\\n            }(0, path, to, block.timestamp)\\n            : selectedRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n                value: amount\\n            }(0, path, to, block.timestamp);\\n    }\\n\\n    function setAutoBuybackSettings(bool _enabled, uint256 period)\\n        external\\n        authorized\\n    {\\n        autoBuybackEnabled = _enabled;\\n        autoBuybackBlockPeriod = period;\\n    }\\n\\n    function setDividendDistributer(address distributer) external authorized {\\n        isDividendExempt[distributer] = true;\\n        isFeeExempt[distributer] = true;\\n        distributor = DividendDistributor(distributer);\\n    }\\n\\n    function setBuybackMultiplierSettings(\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 length\\n    ) external authorized {\\n        require(numerator / denominator <= 2 && numerator > denominator);\\n        buybackMultiplierNumerator = numerator;\\n        buybackMultiplierDenominator = denominator;\\n        buybackMultiplierLength = length;\\n    }\\n\\n    function launched() internal view returns (bool) {\\n        return launchedAt != 0;\\n    }\\n\\n    function launch() public authorized {\\n        require(launchedAt == 0, \\\"Already launched.\\\");\\n        launchedAt = block.number;\\n        launchedAtTimestamp = block.timestamp;\\n    }\\n\\n    function setSellLimit(uint256 amount) external authorized {\\n        require(\\n            amount >= 100000000000000000000,\\n            \\\"Put amount greater then 100b\\\"\\n        );\\n        sellLimit = amount;\\n    }\\n\\n    function setIsDividendExempt(address holder, bool exempt)\\n        external\\n        authorized\\n    {\\n        require(holder != address(this) && !pairs[holder]);\\n        isDividendExempt[holder] = exempt;\\n        if (exempt) {\\n            distributor.setShare(holder, 0);\\n        } else {\\n            distributor.setShare(holder, _balances[holder]);\\n        }\\n    }\\n\\n    function setIsFeeExempt(address holder, bool exempt) external authorized {\\n        isFeeExempt[holder] = exempt;\\n    }\\n\\n    function setIsTxLimitExempt(address holder, bool exempt)\\n        external\\n        authorized\\n    {\\n        isTxLimitExempt[holder] = exempt;\\n    }\\n\\n    function setFeeReceivers(\\n        address _autoLiquidityReceiver,\\n        address _marketingFeeReceiver,\\n        address _gasWalletReceiver\\n    ) external authorized {\\n        autoLiquidityReceiver = _autoLiquidityReceiver;\\n        marketingFeeReceiver = _marketingFeeReceiver;\\n        gasWalletFeeReceiver = _gasWalletReceiver;\\n    }\\n\\n    function setSwapBackSettings(bool _enabled) external authorized {\\n        swapEnabled = _enabled;\\n    }\\n\\n    function setSwapBackOnSell(bool _isSwapBackOnSell) external authorized {\\n        isSwapOnSell = _isSwapBackOnSell;\\n    }\\n\\n    function setTargetLiquidity(uint256 _target, uint256 _denominator)\\n        external\\n        authorized\\n    {\\n        targetLiquidity = _target;\\n        targetLiquidityDenominator = _denominator;\\n    }\\n\\n    function setDistributionCriteria(\\n        uint256 _minPeriod,\\n        uint256 _minDistribution\\n    ) external authorized {\\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\\n    }\\n\\n    function setDistributorSettings(uint256 gas) external authorized {\\n        require(gas < 999999);\\n        distributorGas = gas;\\n    }\\n\\n    function getCirculatingSupply() public view returns (uint256) {\\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\\n    }\\n\\n    function getLiquidityBacking(uint256 accuracy, address pair)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\\n    }\\n\\n    function isOverLiquified(\\n        uint256 target,\\n        uint256 accuracy,\\n        address pair\\n    ) public view returns (bool) {\\n        return getLiquidityBacking(accuracy, pair) > target;\\n    }\\n\\n    /**\\n     * @dev Sets the allowance granted to `spender` by `owner`.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     */\\n    function _setAllowance(\\n        address owner,\\n        address spender,\\n        uint256 wad\\n    ) internal virtual returns (bool) {\\n        _allowances[owner][spender] = wad;\\n        emit Approval(owner, spender, wad);\\n\\n        return true;\\n    }\\n\\n    // --- Approve by signature ---\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        holder,\\n                        spender,\\n                        nonce,\\n                        expiry,\\n                        allowed\\n                    )\\n                )\\n            )\\n        );\\n\\n        require(holder != address(0), \\\"Reflecto/invalid-address-0\\\");\\n        require(\\n            holder == ecrecover(digest, v, r, s),\\n            \\\"Reflecto/invalid-permit\\\"\\n        );\\n        require(\\n            expiry == 0 || block.timestamp <= expiry,\\n            \\\"Reflecto/permit-expired\\\"\\n        );\\n        require(nonce == nonces[holder]++, \\\"Reflecto/invalid-nonce\\\");\\n        uint256 wad = allowed ? _totalSupply : 0;\\n        _setAllowance(holder, spender, wad);\\n    }\\n\\n    function convertTokensToBuyBack(address token) external authorized {\\n        address[] memory bnbPath = new address[](2);\\n        address WBNB_OR_WETH = isBNBRouter[address(defaultRouter)]\\n            ? defaultRouter.WBNB()\\n            : defaultRouter.WETH();\\n        bnbPath[0] = token;\\n        bnbPath[1] = WBNB_OR_WETH;\\n        uint256 amountIn = IBEP20(token).balanceOf(address(this));\\n\\n        uint256 deadline = block.timestamp + 1000;\\n        IBEP20(token).approve(address(defaultRouter), amountIn);\\n\\n        isBNBRouter[address(defaultRouter)]\\n            ? defaultRouter.swapExactTokensForBNBSupportingFeeOnTransferTokens(\\n                amountIn,\\n                0,\\n                bnbPath,\\n                address(this),\\n                deadline\\n            )\\n            : defaultRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                amountIn,\\n                0,\\n                bnbPath,\\n                address(this),\\n                deadline\\n            );\\n    }\\n\\n    function burnTokenFromContract() external authorized {\\n        uint256 balanceOfContract = balanceOf(address(this));\\n        uint256 swapThreshold = ICalculator(calculator).getSwapThreshold();\\n        require(\\n            balanceOfContract > swapThreshold,\\n            \\\"Threshold is gt then blance\\\"\\n        );\\n\\n        uint256 amountToBurn = balanceOfContract - swapThreshold;\\n\\n        _balances[address(this)] = _balances[address(this)].sub(\\n            amountToBurn,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[DEAD] = _balances[DEAD].add(amountToBurn);\\n        burnCounter = burnCounter.add(amountToBurn);\\n\\n        emit Transfer(address(this), DEAD, amountToBurn);\\n    }\\n\\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\\n    event BuybackMultiplierActive(uint256 duration);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBEP20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function getOwner() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address _owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Auth {\\n    address internal owner;\\n    mapping(address => bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be contract owner\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"!OWNER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be authorized\\n     */\\n    modifier authorized() {\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Authorize address. Owner only\\n     */\\n    function authorize(address adr) public onlyOwner {\\n        authorizations[adr] = true;\\n    }\\n\\n    /**\\n     * Remove address' authorization. Owner only\\n     */\\n    function unauthorize(address adr) public onlyOwner {\\n        authorizations[adr] = false;\\n    }\\n\\n    /**\\n     * Check if address is owner\\n     */\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    /**\\n     * Return address' authorization status\\n     */\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    /**\\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\\n     */\\n    function transferOwnership(address payable adr) public onlyOwner {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * SAFEMATH LIBRARY\\n */\\nlibrary SafeMath {\\n    function tryAdd(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function trySub(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function tryMul(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function tryDiv(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function tryMod(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/IDEX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function WBNB() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityBNB(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactBNBForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactTokensForBNBSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IDEXFactory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/IProviderPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IProviderPair {\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112,\\n            uint112,\\n            uint32\\n        );\\n\\n    function sync() external;\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/ICalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nstruct Fees {\\n    uint256 buyLiquidityFee;\\n    uint256 sellLiquidityFee;\\n    uint256 buyBuybackFee;\\n    uint256 sellBuybackFee;\\n    uint256 buyGasWalletFee;\\n    uint256 sellGasWalletFee;\\n    uint256 buyReflectionFee;\\n    uint256 sellReflectionFee;\\n    uint256 buyDevelopmentFee;\\n    uint256 sellDevelopmentFee;\\n    uint256 buyTotal;\\n    uint256 sellTotal;\\n    uint256 buyFeeDenominator;\\n    uint256 sellFeeDenominator;\\n    uint256 transferFee;\\n}\\n\\ninterface ICalculator {\\n    function getFees() external view returns (Fees memory);\\n\\n    function registerBuySell(uint256 amount, bool isBuy) external;\\n\\n    function isCustomFeeReceiverOrSender(address sender, address receiver)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getPressure() external view returns (uint256, uint256);\\n\\n    function getFundPoolByPressureData(\\n        uint256 swapThreshold,\\n        address poolAddress,\\n        uint256 minPoolAmount\\n    ) external view returns (bool, uint256);\\n\\n    function getSwapThreshold() external view returns (uint256);\\n\\n    function getUserFees(address sender, address receiver)\\n        external\\n        view\\n        returns (Fees memory);\\n    \\n    function getAlgoBuybackData(\\n        uint256 amount,\\n        bool isSell,\\n        address pair\\n    ) external view returns (bool, uint256);\\n\\n    function getSellCancelingAmount(address pair, uint256 priceDataBeforeSwap)\\n        external\\n        view\\n        returns (bool, uint256, address);\\n\\n    function getPrices(address ratePair)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/DividendDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libs/IDividendDistributor.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\nimport \\\"./libs/IBEP20.sol\\\";\\nimport \\\"./libs/IDEX.sol\\\";\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\ncontract DividendDistributor is IDividendDistributor, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    address _owner;\\n    address _token;\\n\\n    struct Share {\\n        uint256 amount;\\n        uint256 totalExcluded;\\n        uint256 totalRealised;\\n        address[] tokensToDistribute;\\n        uint256 tokenIndexDistributed;\\n        bool isInit;\\n    }\\n\\n    address public WBNB;\\n    IDEXRouter public router;\\n    IDEXRouter public ourDexRouter;\\n    bool public roundRobinEnabled = false;\\n    bool public isOurDexRouter = true;\\n    mapping(address => bool) public isTokenSupportedOnOurDex;\\n\\n    address defaultRewardToken = 0x4Be8c674C51674bEb729832682bBA5E5b105b6e2;\\n    address defaultForContracts = 0x4Be8c674C51674bEb729832682bBA5E5b105b6e2;\\n\\n    address[] shareholders;\\n    mapping(address => uint256) shareholderIndexes;\\n    mapping(address => uint256) shareholderClaims;\\n\\n    mapping(address => Share) public shares;\\n    mapping(address => bool) public allRewardTokens;\\n\\n    address[] public allRewardsTokenList;\\n\\n    mapping(address => bool) public blacklistedTokens;\\n\\n    mapping(address => uint256) public rewardTokenExpirationTime;\\n    mapping(address => uint256) public rewardTokenFeePaid;\\n    address[] public allPendingRewardsTokenList;\\n    mapping(address => bool) private pendingRewardTokens;\\n    mapping(address => address) private rewardTokenFeePayers;\\n\\n    mapping(address => uint256) public dividendsDistributedPerToken;\\n    mapping(address => uint256) public shouldClaimOnSetShare;\\n    mapping(address => mapping(address => uint256))\\n        public dividendsDistributedPerUser;\\n\\n    mapping(address => IDEXRouter) public customRouter;\\n    mapping(address => bool) public haveCustomRouter;\\n\\n    uint256 public totalShares;\\n    uint256 public totalDividends;\\n    uint256 public totalDistributed;\\n    uint256 public dividendsPerShare;\\n    uint256 public dividendsPerShareAccuracyFactor = 10**36;\\n\\n    uint256 public minPeriod = 1 hours;\\n    uint256 public minDistribution = 0.001 * (10**18);\\n\\n    uint256 public feeForTokenListening = 20 ether;\\n    uint256 public feeExpirationInDays = 30 days;\\n\\n    uint256 public addMyTokenFee = 10000000000000000;\\n    mapping(address => bool) public tokensToListFree;\\n\\n    mapping(address => uint256) gaslessClaimTimestamp;\\n\\n    uint256 public gaslessClaimPeriod = 86400;\\n\\n    address public feeAddress;\\n\\n    uint256 currentIndex;\\n\\n    bool initialized;\\n\\n    event RewardTokenTransferFailed(uint256 time, address tokenAddress);\\n    event RewardTokenTransferSuccess(\\n        uint256 time,\\n        address tokenAddress,\\n        address holder,\\n        uint256 amount\\n    );\\n\\n    event ListToken(\\n        address rewardToken,\\n        uint256 expirationTime,\\n        uint256 status\\n    );\\n    event AllowAddingButNotListToken(address rewardToken, uint256 status);\\n    event BlackListToken(address rewardToken);\\n\\n    modifier initialization() {\\n        require(!initialized);\\n        _;\\n        initialized = true;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner);\\n        _;\\n    }\\n\\n    modifier onlyToken() {\\n        require(msg.sender == _token);\\n        _;\\n    }\\n\\n    constructor(address _router, address reflecto) {\\n        router = _router != address(0)\\n            ? IDEXRouter(_router)\\n            : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        _owner = msg.sender;\\n        feeAddress = msg.sender;\\n        _token = reflecto;\\n        WBNB = router.WETH();\\n\\n        allRewardTokens[defaultRewardToken] = true;\\n        allRewardsTokenList.push(defaultRewardToken);\\n        rewardTokenExpirationTime[defaultRewardToken] =\\n            block.timestamp +\\n            36525 days;\\n    }\\n\\n    function setDistributionCriteria(\\n        uint256 _minPeriod,\\n        uint256 _minDistribution\\n    ) external override onlyToken {\\n        minPeriod = _minPeriod;\\n        minDistribution = _minDistribution;\\n    }\\n\\n    function setAddMyTokenFee(uint256 _addMyTokenFee) external onlyOwner {\\n        addMyTokenFee = _addMyTokenFee;\\n    }\\n\\n    function setFreeMyTokenToAdd(address _rewardToken, bool _isFree)\\n        external\\n        onlyOwner\\n    {\\n        tokensToListFree[_rewardToken] = _isFree;\\n    }\\n\\n    function rewardsTokensCount() public view returns (uint256 count) {\\n        return allRewardsTokenList.length;\\n    }\\n\\n    function rewardsTokens()\\n        public\\n        view\\n        returns (address[] memory rewardTokens)\\n    {\\n        return allRewardsTokenList;\\n    }\\n\\n    function pendingRewardsTokens()\\n        public\\n        view\\n        returns (address[] memory rewardTokens)\\n    {\\n        return allPendingRewardsTokenList;\\n    }\\n\\n    function getUsersRewardsTokens(address shareholder)\\n        public\\n        view\\n        returns (address[] memory token)\\n    {\\n        return shares[shareholder].tokensToDistribute;\\n    }\\n\\n    function getUsersTotalEarned(address shareholder)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return shares[shareholder].totalRealised;\\n    }\\n\\n    function setTokenListeningExpirationIn(uint256 time) external onlyOwner {\\n        feeExpirationInDays = time;\\n    }\\n\\n    function setOwnRouter(address _router) external onlyOwner {\\n        ourDexRouter = IDEXRouter(_router);\\n    }\\n\\n    function setTokenSupportedByOurDex(\\n        address _tokenOnOurDex,\\n        bool _isSupported\\n    ) external onlyOwner {\\n        isTokenSupportedOnOurDex[_tokenOnOurDex] = _isSupported;\\n    }\\n\\n    function setOtherRouter(address _router) external onlyOwner {\\n        router = IDEXRouter(_router);\\n        WBNB = router.WETH();\\n    }\\n\\n    function setCustomRouter(\\n        address _rewardToken,\\n        address _router,\\n        bool isSet\\n    ) external onlyOwner {\\n        customRouter[_rewardToken] = IDEXRouter(_router);\\n        haveCustomRouter[_rewardToken] = isSet;\\n    }\\n\\n    function setRoundRoubinRouter(bool _isEnabled) external onlyOwner {\\n        roundRobinEnabled = _isEnabled;\\n    }\\n\\n    function getRouter(address tokenSupportedByOwnDex)\\n        internal\\n        returns (IDEXRouter)\\n    {\\n        if (haveCustomRouter[tokenSupportedByOwnDex]) {\\n            return customRouter[tokenSupportedByOwnDex];\\n        }\\n        if (!roundRobinEnabled) {\\n            return router;\\n        }\\n        if (!isTokenSupportedOnOurDex[tokenSupportedByOwnDex]) {\\n            return router;\\n        }\\n\\n        if (!isOurDexRouter) {\\n            isOurDexRouter = true;\\n            return router;\\n        }\\n        isOurDexRouter = false;\\n        return ourDexRouter;\\n    }\\n\\n    function setDefaultRewardTokenForContracts(address _defaultForContracts)\\n        external\\n        onlyOwner\\n    {\\n        defaultForContracts = _defaultForContracts;\\n    }\\n\\n    function setDefaultRewardToken(address rewardToken) external onlyOwner {\\n        defaultRewardToken = rewardToken;\\n        allRewardTokens[rewardToken] = true;\\n        allRewardsTokenList.push(rewardToken);\\n        rewardTokenExpirationTime[rewardToken] = block.timestamp + 36525 days;\\n    }\\n\\n    function addRewardTokenToList(address rewardToken, uint256 duration)\\n        external\\n        onlyOwner\\n    {\\n        allRewardTokens[rewardToken] = true;\\n        allRewardsTokenList.push(rewardToken);\\n        rewardTokenExpirationTime[rewardToken] = block.timestamp + duration;\\n        emit ListToken(rewardToken, block.timestamp + duration, 1);\\n    }\\n\\n    function approveTokenAdding(address rewardToken) external onlyOwner {\\n        allRewardTokens[rewardToken] = true;\\n        emit AllowAddingButNotListToken(rewardToken, 1);\\n    }\\n\\n    function rejectTokenAdding(address rewardToken) external onlyOwner {\\n        require(\\n            rewardToken != address(defaultRewardToken),\\n            \\\"Cannot disable default token\\\"\\n        );\\n        allRewardTokens[rewardToken] = false;\\n        emit AllowAddingButNotListToken(rewardToken, 2);\\n    }\\n\\n    function blacklistRewardToken(address rewardToken, bool isBlacklisted)\\n        external\\n        onlyOwner\\n    {\\n        blacklistedTokens[rewardToken] = isBlacklisted;\\n        emit BlackListToken(rewardToken);\\n    }\\n\\n    function removeRewardTokenFromList(uint256 index, address rewardToken)\\n        external\\n        onlyOwner\\n    {\\n        require(allRewardsTokenList[index] == rewardToken, \\\"Index not correct\\\");\\n        if (allRewardsTokenList[index] != address(defaultRewardToken)) {\\n            allRewardTokens[rewardToken] = false;\\n        }\\n        removeItemFromArray(allRewardsTokenList, index);\\n        emit ListToken(rewardToken, 0, 2);\\n    }\\n\\n    function setFeeAddress(address feeTo) external onlyOwner {\\n        feeAddress = feeTo;\\n    }\\n\\n    function setReflectoAddress(address reflectoAddress) external onlyOwner {\\n        _token = reflectoAddress;\\n    }\\n\\n    function setListeningFee(uint256 fee) external onlyOwner {\\n        feeForTokenListening = fee;\\n    }\\n\\n    function setShare(address shareholder, uint256 amount)\\n        external\\n        override\\n        onlyToken\\n    {\\n        if (!shares[shareholder].isInit) {\\n            shares[shareholder].tokensToDistribute = [defaultRewardToken];\\n            shares[shareholder].tokenIndexDistributed = 0;\\n            shares[shareholder].isInit = true;\\n        }\\n\\n        if (\\n            shares[shareholder].amount > 0 &&\\n            shouldClaimOnSetShare[shareholder] + 40 < block.timestamp\\n        ) {\\n            shouldClaimOnSetShare[shareholder] = block.timestamp;\\n            distributeDividend(shareholder);\\n        }\\n\\n        if (amount > 0 && shares[shareholder].amount == 0) {\\n            addShareholder(shareholder);\\n        } else if (amount == 0 && shares[shareholder].amount > 0) {\\n            removeShareholder(shareholder);\\n        }\\n\\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\n        shares[shareholder].amount = amount;\\n\\n        shares[shareholder].totalExcluded = getCumulativeDividends(\\n            shares[shareholder].amount\\n        );\\n    }\\n\\n    function migrate(address[] memory rshareholders, address oldDis)\\n        external\\n        onlyOwner\\n    {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < rshareholders.length; i++) {\\n            uint256 balance = IDividendDistributorOld(oldDis)\\n                .getShareholderAmount(rshareholders[i]);\\n            if (balance == 0 || shares[rshareholders[i]].amount > 0) {\\n                continue;\\n            }\\n\\n            shares[rshareholders[i]]\\n                .tokensToDistribute = IDividendDistributorOld(oldDis)\\n                .getUsersRewardsTokens(rshareholders[i]);\\n            shares[rshareholders[i]].totalRealised = 0;\\n\\n            shares[rshareholders[i]].tokenIndexDistributed = 0;\\n            shares[rshareholders[i]].isInit = true;\\n            shares[rshareholders[i]].amount = balance;\\n            shares[rshareholders[i]].totalExcluded = getCumulativeDividends(\\n                balance\\n            );\\n            addShareholder(rshareholders[i]);\\n            total = total.add(balance);\\n        }\\n\\n        totalShares = totalShares.add(total);\\n    }\\n\\n    function migrateTokens(\\n        address[] memory _rewardTokens,\\n        uint256[] memory _durations,\\n        uint256[] memory _dividendsDistributedPerTokens\\n    ) external onlyOwner {\\n        for (uint256 i = 0; i < _rewardTokens.length; i++) {\\n            if (allRewardTokens[_rewardTokens[i]]) {\\n                continue;\\n            }\\n            allRewardTokens[_rewardTokens[i]] = true;\\n            allRewardsTokenList.push(_rewardTokens[i]);\\n            rewardTokenExpirationTime[_rewardTokens[i]] =\\n                block.timestamp +\\n                _durations[i];\\n            dividendsDistributedPerToken[\\n                _rewardTokens[i]\\n            ] = _dividendsDistributedPerTokens[i];\\n        }\\n    }\\n\\n    // TODO: add external fallback function\\n    function deposit() external payable override onlyToken {\\n        uint256 amount = msg.value;\\n\\n        totalDividends = totalDividends.add(amount);\\n        dividendsPerShare = dividendsPerShare.add(\\n            dividendsPerShareAccuracyFactor.mul(amount).div(totalShares)\\n        );\\n    }\\n\\n    function process(uint256 gas) external override onlyToken {\\n        uint256 shareholderCount = shareholders.length;\\n\\n        if (shareholderCount == 0) {\\n            return;\\n        }\\n\\n        uint256 gasUsed = 0;\\n        uint256 gasLeft = gasleft();\\n        uint256 iterations = 0;\\n        while (gasUsed < gas && iterations < shareholderCount) {\\n            if (currentIndex >= shareholderCount) {\\n                currentIndex = 0;\\n            }\\n\\n            if (shouldDistribute(shareholders[currentIndex])) {\\n                shouldClaimOnSetShare[shareholders[currentIndex]] = block\\n                    .timestamp;\\n                distributeDividend(shareholders[currentIndex]);\\n            }\\n\\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\\n            gasLeft = gasleft();\\n            currentIndex++;\\n            iterations++;\\n        }\\n    }\\n\\n    function shouldDistribute(address shareholder)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return\\n            shareholderClaims[shareholder] + minPeriod < block.timestamp &&\\n            getUnpaidEarnings(shareholder) > minDistribution;\\n    }\\n\\n    function listMyToken(address rewardToken) external payable {\\n        require(\\n            msg.value == feeForTokenListening,\\n            \\\"Send correct amount for listening\\\"\\n        );\\n\\n        require(\\n            !pendingRewardTokens[rewardToken],\\n            \\\"Reward token already waiting for approval\\\"\\n        );\\n\\n        require(!allRewardTokens[rewardToken], \\\"This token is already listed\\\");\\n\\n        require(\\n            allRewardsTokenList.length < 100,\\n            \\\"Maximum 100 tokens allowed to be on list\\\"\\n        );\\n        // addTokenToPending list\\n        allPendingRewardsTokenList.push(rewardToken);\\n        emit ListToken(rewardToken, 0, 0);\\n        // set amount fee\\n        rewardTokenFeePaid[rewardToken] = msg.value;\\n\\n        rewardTokenFeePayers[rewardToken] = msg.sender;\\n\\n        pendingRewardTokens[rewardToken] = true;\\n    }\\n\\n    function approveToken(address rewardToken, uint256 index)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            allPendingRewardsTokenList[index] == rewardToken,\\n            \\\"Index not correct\\\"\\n        );\\n        allRewardTokens[rewardToken] = true;\\n        allRewardsTokenList.push(rewardToken);\\n\\n        // remove token from pending\\n        removeItemFromArray(allPendingRewardsTokenList, index);\\n\\n        // set time when expires\\n        rewardTokenExpirationTime[rewardToken] =\\n            block.timestamp +\\n            feeExpirationInDays;\\n        payable(feeAddress).transfer(rewardTokenFeePaid[rewardToken]);\\n        pendingRewardTokens[rewardToken] = false;\\n\\n        emit ListToken(rewardToken, rewardTokenExpirationTime[rewardToken], 1);\\n    }\\n\\n    function rejectToken(address rewardToken, uint256 index)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            allPendingRewardsTokenList[index] == rewardToken,\\n            \\\"Index not correct\\\"\\n        );\\n\\n        // remove token from pending\\n        removeItemFromArray(allPendingRewardsTokenList, index);\\n\\n        pendingRewardTokens[rewardToken] = false;\\n\\n        // retuurn fee\\n        payable(rewardTokenFeePayers[rewardToken]).transfer(\\n            rewardTokenFeePaid[rewardToken]\\n        );\\n        emit ListToken(rewardToken, 0, 2);\\n    }\\n\\n    function closeExpiredListenings() external {\\n        for (uint256 i = 0; i < allRewardsTokenList.length; i++) {\\n            if (\\n                block.timestamp >\\n                rewardTokenExpirationTime[allRewardsTokenList[i]]\\n            ) {\\n                emit ListToken(allRewardsTokenList[i], 0, 4);\\n                allRewardTokens[allRewardsTokenList[i]] = false;\\n                removeItemFromArray(allRewardsTokenList, i);\\n            }\\n        }\\n    }\\n\\n    function removeItemFromArray(address[] storage array, uint256 index)\\n        internal\\n    {\\n        array[index] = array[array.length - 1];\\n        array.pop();\\n    }\\n\\n    function addMyRewardToken(address rewardToken) external payable {\\n        require(\\n            msg.value == addMyTokenFee || tokensToListFree[rewardToken],\\n            \\\"This token cannot be listed free\\\"\\n        );\\n        require(\\n            shares[msg.sender].isInit,\\n            \\\"You need to get Reflecto to be able to set rewards\\\"\\n        );\\n\\n        require(\\n            shares[msg.sender].tokensToDistribute.length <= 12,\\n            \\\"Maximum 12 tokens allowed\\\"\\n        );\\n\\n        require(\\n            allRewardTokens[rewardToken],\\n            \\\"Token is not listed on Reflecto\\\"\\n        );\\n        for (\\n            uint256 i = 0;\\n            i < shares[msg.sender].tokensToDistribute.length;\\n            i++\\n        ) {\\n            if (shares[msg.sender].tokensToDistribute[i] == rewardToken) {\\n                revert(\\\"This token has already added as reward token\\\");\\n            }\\n        }\\n\\n        payable(feeAddress).transfer(msg.value);\\n\\n        shares[msg.sender].tokensToDistribute.push(rewardToken);\\n    }\\n\\n    function removeMyRewardToken(address rewardToken, uint256 index) external {\\n        require(\\n            shares[msg.sender].isInit,\\n            \\\"You need to get Reflecto to be able do remove token\\\"\\n        );\\n\\n        require(\\n            shares[msg.sender].tokensToDistribute[index] == rewardToken,\\n            \\\"Not correct index\\\"\\n        );\\n        removeItemFromArray(shares[msg.sender].tokensToDistribute, index);\\n        shares[msg.sender].tokenIndexDistributed = 0;\\n    }\\n\\n    function distributeDividend(address shareholder) internal {\\n        if (shares[shareholder].amount == 0) {\\n            return;\\n        }\\n\\n        uint256 amount = getUnpaidEarnings(shareholder);\\n\\n        if (amount > 0) {\\n            totalDistributed = totalDistributed.add(amount);\\n\\n            uint256 totalRewardsTokens = shares[shareholder]\\n                .tokensToDistribute\\n                .length;\\n            if (totalRewardsTokens > 0) {\\n                address rewardToken = shares[shareholder].tokensToDistribute[\\n                    shares[shareholder].tokenIndexDistributed\\n                ];\\n\\n                if (WBNB != rewardToken && !blacklistedTokens[rewardToken]) {\\n                    sentRewardInToken(shareholder, amount, rewardToken);\\n                } else if (!isContract(shareholder)) {\\n                    sentRewardInBNB(shareholder, amount);\\n                } else {\\n                    sentRewardInToken(shareholder, amount, defaultForContracts);\\n                }\\n\\n                emit RewardTokenTransferSuccess(\\n                    block.timestamp,\\n                    rewardToken,\\n                    shareholder,\\n                    amount\\n                );\\n\\n                if (\\n                    shares[shareholder].tokenIndexDistributed + 1 >\\n                    totalRewardsTokens - 1\\n                ) {\\n                    shares[shareholder].tokenIndexDistributed = 0;\\n                } else {\\n                    shares[shareholder].tokenIndexDistributed =\\n                        shares[shareholder].tokenIndexDistributed +\\n                        1;\\n                }\\n            } else if (!isContract(shareholder)) {\\n                sentRewardInBNB(shareholder, amount);\\n            } else {\\n                sentRewardInToken(shareholder, amount, defaultForContracts);\\n            }\\n\\n            shareholderClaims[shareholder] = block.timestamp;\\n            shares[shareholder].totalRealised = shares[shareholder]\\n                .totalRealised\\n                .add(amount);\\n            shares[shareholder].totalExcluded = getCumulativeDividends(\\n                shares[shareholder].amount\\n            );\\n        }\\n    }\\n\\n    function isContract(address _addr) internal view returns (bool) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n\\n    function distributeDividendClaim(\\n        address shareholder,\\n        address rewardToken,\\n        uint256 devidedBy,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            totalDistributed = totalDistributed.add(amount);\\n\\n            uint256 totalRewardsTokens = devidedBy;\\n            if (totalRewardsTokens > 0) {\\n                if (WBNB != rewardToken && !blacklistedTokens[rewardToken]) {\\n                    sentRewardInToken(shareholder, amount, rewardToken);\\n                } else {\\n                    sentRewardInBNB(shareholder, amount);\\n                }\\n\\n                emit RewardTokenTransferSuccess(\\n                    block.timestamp,\\n                    rewardToken,\\n                    shareholder,\\n                    amount\\n                );\\n            } else {\\n                sentRewardInBNB(shareholder, amount);\\n            }\\n\\n            shareholderClaims[shareholder] = block.timestamp;\\n            shares[shareholder].totalRealised = shares[shareholder]\\n                .totalRealised\\n                .add(amount);\\n            shares[shareholder].totalExcluded = getCumulativeDividends(\\n                shares[shareholder].amount\\n            );\\n        }\\n    }\\n\\n    function sentRewardInBNB(address shareholder, uint256 amount) internal {\\n        uint256 balanceBefore = shareholder.balance;\\n        payable(shareholder).transfer(amount);\\n        uint256 balanceToAdd = shareholder.balance.sub(balanceBefore);\\n        dividendsDistributedPerToken[WBNB] = dividendsDistributedPerToken[WBNB]\\n            .add(balanceToAdd);\\n\\n        dividendsDistributedPerUser[shareholder][\\n            WBNB\\n        ] = dividendsDistributedPerUser[shareholder][WBNB].add(balanceToAdd);\\n    }\\n\\n    function sentRewardInToken(\\n        address shareholder,\\n        uint256 amount,\\n        address rewardTokenAddress\\n    ) internal {\\n        IBEP20 rewardToken = IBEP20(rewardTokenAddress);\\n        address[] memory path = new address[](2);\\n        IDEXRouter routerInst = getRouter(rewardTokenAddress);\\n        path[0] = routerInst.WETH();\\n        path[1] = rewardTokenAddress;\\n        uint256 amountBefore = rewardToken.balanceOf(shareholder);\\n\\n        try\\n            routerInst.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n                value: amount\\n            }(0, path, shareholder, block.timestamp + 100)\\n        {\\n            uint256 amountAfter = rewardToken.balanceOf(shareholder);\\n\\n            dividendsDistributedPerToken[\\n                rewardTokenAddress\\n            ] = dividendsDistributedPerToken[rewardTokenAddress].add(\\n                amountAfter.sub(amountBefore)\\n            );\\n\\n            dividendsDistributedPerUser[shareholder][\\n                rewardTokenAddress\\n            ] = dividendsDistributedPerUser[shareholder][rewardTokenAddress]\\n                .add(amountAfter.sub(amountBefore));\\n        } catch Error(string memory reason) {\\n            sentRewardInBNB(shareholder, amount);\\n            emit RewardTokenTransferFailed(block.timestamp, rewardTokenAddress);\\n        }\\n    }\\n\\n    function claimDividend(address shareholder, address[] memory rewardTokens)\\n        external\\n        nonReentrant\\n    {\\n        claim(shareholder, rewardTokens);\\n    }\\n\\n    function claim(address shareholder, address[] memory rewardTokens)\\n        internal\\n    {\\n        if (shares[shareholder].amount == 0) {\\n            revert(\\\"No Reflecto in account\\\");\\n        }\\n\\n        uint256 amount = getUnpaidEarnings(shareholder);\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\n        uint256 amountPerToken = amount.div(rewardTokens.length);\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\n            if (!allRewardTokens[rewardTokens[i]]) {\\n                revert(\\\"Select reward token not listed\\\");\\n            }\\n            distributeDividendClaim(\\n                shareholder,\\n                rewardTokens[i],\\n                rewardTokens.length,\\n                amountPerToken\\n            );\\n        }\\n    }\\n\\n    function gaslessClaim(\\n        address _to,\\n        address[] memory _rewardTokens,\\n        bytes32 _messageHash,\\n        bytes memory signature\\n    ) external onlyOwner nonReentrant {\\n        require(\\n            block.timestamp >=\\n                gaslessClaimTimestamp[_to].add(gaslessClaimPeriod),\\n            \\\"Cannot reclaim before 1 day\\\"\\n        );\\n        require(\\n            verify(_to, _messageHash, signature),\\n            \\\"signature is not matching\\\"\\n        );\\n        gaslessClaimTimestamp[_to] = block.timestamp;\\n        claim(_to, _rewardTokens);\\n    }\\n\\n    function getMessageHash(\\n        address _to,\\n        uint256 _amount,\\n        string memory _message,\\n        uint256 _nonceH\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_to, _amount, _message, _nonceH));\\n    }\\n\\n    function verify(\\n        address _signer,\\n        bytes32 _messageHash,\\n        bytes memory signature\\n    ) internal pure returns (bool) {\\n        return recoverSigner(_messageHash, signature) == _signer;\\n    }\\n\\n    function recoverSigner(\\n        bytes32 _ethSignedMessageHash,\\n        bytes memory _signature\\n    ) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory sig)\\n        public\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\n\\n        assembly {\\n            /*\\n            First 32 bytes stores the length of the signature\\n\\n            add(sig, 32) = pointer of sig + 32\\n            effectively, skips first 32 bytes of signature\\n\\n            mload(p) loads next 32 bytes starting at the memory address p into memory\\n            */\\n\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        // return (r, s, v);\\n    }\\n\\n    function setClaimPeriod(uint256 gaslessClaimPeriod_) external onlyOwner {\\n        gaslessClaimPeriod = gaslessClaimPeriod_;\\n    }\\n\\n    function getUnpaidEarnings(address shareholder)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (shares[shareholder].amount == 0) {\\n            return 0;\\n        }\\n\\n        uint256 shareholderTotalDividends = getCumulativeDividends(\\n            shares[shareholder].amount\\n        );\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\n\\n        if (shareholderTotalDividends <= shareholderTotalExcluded) {\\n            return 0;\\n        }\\n\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\\n    }\\n\\n    function getCumulativeDividends(uint256 share)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\n    }\\n\\n    function addShareholder(address shareholder) internal {\\n        shareholderIndexes[shareholder] = shareholders.length;\\n        shareholders.push(shareholder);\\n    }\\n\\n    function getShareholders()\\n        external\\n        view\\n        onlyOwner\\n        returns (address[] memory)\\n    {\\n        return shareholders;\\n    }\\n\\n    function getShareholderAmount(address shareholder)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return shares[shareholder].amount;\\n    }\\n\\n    function removeShareholder(address shareholder) internal {\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[\\n            shareholders.length - 1\\n        ];\\n        shareholderIndexes[\\n            shareholders[shareholders.length - 1]\\n        ] = shareholderIndexes[shareholder];\\n        shareholders.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/IDividendDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IDividendDistributor {\\n    function setDistributionCriteria(\\n        uint256 _minPeriod,\\n        uint256 _minDistribution\\n    ) external;\\n\\n    function setShare(address shareholder, uint256 amount) external;\\n\\n    function deposit() external payable;\\n\\n    function process(uint256 gas) external;\\n}\\n\\ninterface IDividendDistributorOld {\\n    function getUsersRewardsTokens(address shareholder)\\n        external view\\n        returns (address[] memory token);\\n\\n    function getShareholderAmount(address shareholder)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"BuybackMultiplierActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"}],\"name\":\"addPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBNB\",\"type\":\"bool\"}],\"name\":\"addRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountOfSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoBuybackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTokenFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearBuybackMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"convertTokensToBuyBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRouter\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"}],\"name\":\"deletePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasWalletFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBNBRouter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDefaultForSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMigrationEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRoundRobinBuyback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapOnSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUserMigrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAtTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxCancelingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"v1holders\",\"type\":\"address[]\"}],\"name\":\"migrateV1ToV2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStakingLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectoRewards\",\"outputs\":[{\"internalType\":\"contract IReflectoRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"routers\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setAutoBuybackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reflectoRewardsContract\",\"type\":\"address\"}],\"name\":\"setAutoStakingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"setBuybackMultiplierSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBNB\",\"type\":\"bool\"}],\"name\":\"setDefaultRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"setDefaultRouterFromSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setDistributorSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"distributer\",\"type\":\"address\"}],\"name\":\"setDividendDistributer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"setEnableRoundRobinBuyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"calc\",\"type\":\"address\"}],\"name\":\"setFeeCalulator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasWalletReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMaxSellCancelingAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinimumStakingLimitAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"setPoolSendEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_onBuy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_onSell\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_onTransfer\",\"type\":\"bool\"}],\"name\":\"setProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"setSellCancelingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSellLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isSwapBackOnSell\",\"type\":\"bool\"}],\"name\":\"setSwapBackOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"setTargetLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeOfSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"triggerBuybackMultiplier\",\"type\":\"bool\"}],\"name\":\"triggerZeusBuyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whenProcess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"onSell\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"onBuy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"onTransfer\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Reflecto", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}