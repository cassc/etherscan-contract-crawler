{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n\\n            if (returndata.length \\u003e 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nimport \\\"./Context.sol\\\";\\n\\n\\ninterface IERC20Metadata is IERC20 {\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint256);\\n}\\n\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n    \\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint256) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n    unchecked {\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance \\u003e= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n    unchecked {\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n    }\\n\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n    unchecked {\\n        _balances[sender] = senderBalance - amount;\\n    }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance \\u003e= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n    unchecked {\\n        _balances[account] = accountBalance - amount;\\n    }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IterableMapping.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nlibrary IterableMapping {\\n    struct Map {\\n        address[] keys;\\n        mapping(address =\\u003e uint) values;\\n        mapping(address =\\u003e uint) indexOf;\\n        mapping(address =\\u003e bool) inserted;\\n    }\\n\\n    function get(Map storage map, address key) public view returns (uint) {\\n        return map.values[key];\\n    }\\n\\n    function getIndexOfKey(Map storage map, address key) public view returns (int) {\\n        if(!map.inserted[key]) {\\n            return -1;\\n        }\\n        return int(map.indexOf[key]);\\n    }\\n\\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\\n        return map.keys[index];\\n    }\\n\\n\\n\\n    function size(Map storage map) public view returns (uint) {\\n        return map.keys.length;\\n    }\\n\\n    function set(Map storage map, address key, uint val) public {\\n        if (map.inserted[key]) {\\n            map.values[key] = val;\\n        } else {\\n            map.inserted[key] = true;\\n            map.values[key] = val;\\n            map.indexOf[key] = map.keys.length;\\n            map.keys.push(key);\\n        }\\n    }\\n\\n    function remove(Map storage map, address key) public {\\n        if (!map.inserted[key]) {\\n            return;\\n        }\\n\\n        delete map.inserted[key];\\n        delete map.values[key];\\n\\n        uint index = map.indexOf[key];\\n        uint lastIndex = map.keys.length - 1;\\n        address lastKey = map.keys[lastIndex];\\n\\n        map.indexOf[lastKey] = index;\\n        delete map.indexOf[key];\\n\\n        map.keys[index] = lastKey;\\n        map.keys.pop();\\n    }\\n}\\n\"},\"LifeTokenDividends.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IterableMapping.sol\\\";\\n\\ninterface DividendPayingTokenOptionalInterface {\\n    function withdrawableDividendOf(address _owner) external view returns(uint256);\\n    function withdrawnDividendOf(address _owner) external view returns(uint256);\\n    function accumulativeDividendOf(address _owner) external view returns(uint256);\\n}\\n\\ninterface DividendPayingTokenInterface {\\n    function dividendOf(address _owner) external view returns(uint256);\\n    function distributeDividends() external payable;\\n    function withdrawDividend() external;\\n\\n    event DividendsDistributed(address indexed from, uint256 weiAmount);\\n    event DividendWithdrawn(address indexed to, uint256 weiAmount);\\n}\\n\\nlibrary SafeMathUint {\\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\\n        int256 b = int256(a);\\n        require(b \\u003e= 0);\\n        return b;\\n    }\\n}\\n\\nlibrary SafeMathInt {\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        \\n        require(!(a == - 2**255 \\u0026\\u0026 b == -1) \\u0026\\u0026 !(b == - 2**255 \\u0026\\u0026 a == -1));\\n\\n        int256 c = a * b;\\n        require((b == 0) || (c / b == a));\\n        return c;\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n\\n        require(!(a == - 2**255 \\u0026\\u0026 b == -1) \\u0026\\u0026 (b \\u003e 0));\\n\\n        return a / b;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        require((b \\u003e= 0 \\u0026\\u0026 a - b \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 a - b \\u003e a));\\n\\n        return a - b;\\n    }\\n\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\n        return c;\\n    }\\n\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\n        require(a \\u003e= 0);\\n        return uint256(a);\\n    }\\n}\\n\\nlibrary SafeMath {\\n\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    unchecked {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n    }\\n\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    unchecked {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n    }\\n\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    unchecked {\\n\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n    }\\n\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    unchecked {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n    }\\n\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    unchecked {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n    unchecked {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n    unchecked {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n    unchecked {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n    }\\n}\\n\\n\\ncontract DividendPayingToken is ERC20, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {\\n    using SafeMath for uint256;\\n    using SafeMathUint for uint256;\\n    using SafeMathInt for int256;\\n\\n    uint256 constant internal magnitude = 2**128;\\n\\n    uint256 internal magnifiedDividendPerShare;\\n\\n    mapping(address =\\u003e int256) internal magnifiedDividendCorrections;\\n    mapping(address =\\u003e uint256) internal withdrawnDividends;\\n\\n    uint256 public totalDividendsDistributed;\\n\\n    constructor(string memory _name, string memory _symbol)  ERC20(_name, _symbol) {\\n\\n    }\\n\\n    receive() external payable {\\n        distributeDividends();\\n    }\\n\\n    function distributeDividends() public override payable {\\n        require(totalSupply() \\u003e 0);\\n\\n        if (msg.value \\u003e 0) {\\n            magnifiedDividendPerShare = magnifiedDividendPerShare.add(\\n                (msg.value).mul(magnitude) / totalSupply()\\n            );\\n            emit DividendsDistributed(msg.sender, msg.value);\\n\\n            totalDividendsDistributed = totalDividendsDistributed.add(msg.value);\\n        }\\n    }\\n\\n    function withdrawDividend() public virtual override {\\n        _withdrawDividendOfUser(payable(msg.sender));\\n    }\\n\\n    function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\\n        uint256 _withdrawableDividend = withdrawableDividendOf(user);\\n        if (_withdrawableDividend \\u003e 0) {\\n            withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\\n            emit DividendWithdrawn(user, _withdrawableDividend);\\n            (bool success,) = user.call{value: _withdrawableDividend, gas: 3000}(\\\"\\\");\\n\\n            if(!success) {\\n                withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\\n                return 0;\\n            }\\n\\n            return _withdrawableDividend;\\n        }\\n\\n        return 0;\\n    }\\n\\n    function dividendOf(address _owner) public view override returns(uint256) {\\n        return withdrawableDividendOf(_owner);\\n    }\\n\\n    function withdrawableDividendOf(address _owner) public view override returns(uint256) {\\n        return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\\n    }\\n\\n    function withdrawnDividendOf(address _owner) public view override returns(uint256) {\\n        return withdrawnDividends[_owner];\\n    }\\n\\n    function accumulativeDividendOf(address _owner) public view override returns(uint256) {\\n        return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\\n        .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal virtual override {\\n        require(false);\\n\\n        int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();\\n        magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);\\n        magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);\\n    }\\n\\n    function _mint(address account, uint256 value) internal override {\\n        super._mint(account, value);\\n\\n        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\\n        .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\\n    }\\n\\n    function _burn(address account, uint256 value) internal override {\\n        super._burn(account, value);\\n\\n        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\\n        .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\\n    }\\n\\n    function _setBalance(address account, uint256 newBalance) internal {\\n        uint256 currentBalance = balanceOf(account);\\n\\n        if(newBalance \\u003e currentBalance) {\\n            uint256 mintAmount = newBalance.sub(currentBalance);\\n            _mint(account, mintAmount);\\n        } else if(newBalance \\u003c currentBalance) {\\n            uint256 burnAmount = currentBalance.sub(newBalance);\\n            _burn(account, burnAmount);\\n        }\\n    }\\n}\\n\\ncontract LifeTokenDividends is DividendPayingToken, Ownable {\\n    using SafeMath for uint256;\\n    using SafeMathInt for int256;\\n    using IterableMapping for IterableMapping.Map;\\n\\n    IterableMapping.Map private tokenHoldersMap;\\n    uint256 public lastProcessedIndex;\\n\\n    mapping (address =\\u003e bool) public excludedFromDividends;\\n    \\n\\n    mapping (address =\\u003e uint256) public lastClaimTimes;\\n\\n    uint256 public claimWait;\\n    uint256 public minimumTokenBalanceForDividends;\\n\\n    event ExcludeFromDividends(address indexed account);\\n    event mUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n    event MinimumTokenBalanceForDividendsUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n    event UpdateDistributionBalanceOfUser(address account, uint256 newBalance);\\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\\n\\n    constructor() DividendPayingToken(\\\"LifeToken (LTN) Dividends\\\", \\\"LTNDividends\\\") {\\n        claimWait = 3600;\\n        minimumTokenBalanceForDividends = 300000000 * (10**decimals());\\n    }\\n\\n    function _transfer(address, address, uint256) internal pure override {\\n        require(false, \\\"LifeToken (LTN) Dividends: No transfers allowed\\\");\\n    }\\n\\n    function withdrawDividend() public pure override {\\n        require(false, \\\"LifeToken (LTN) Dividends: withdrawDividend disabled. Use the \\u0027claim\\u0027 function on the main Life Token v2 contract.\\\");\\n    }\\n\\n    function excludeFromDividends(address account) external onlyOwner {\\n        require(!excludedFromDividends[account]);\\n        excludedFromDividends[account] = true;\\n\\n        _setBalance(account, 0);\\n        tokenHoldersMap.remove(account);\\n\\n        emit ExcludeFromDividends(account);\\n    }\\n\\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\\n        claimWait = newClaimWait;\\n    }\\n\\n    function updateMinimumTokenBalanceForDividends(uint256 newTokenBalance) external onlyOwner {\\n        emit MinimumTokenBalanceForDividendsUpdated(newTokenBalance, minimumTokenBalanceForDividends);\\n        minimumTokenBalanceForDividends = newTokenBalance;\\n    }\\n    \\n    function getMinimumTokenBalanceForDividends() external view returns(uint256) {\\n        return minimumTokenBalanceForDividends;\\n    }\\n\\n    function getLastProcessedIndex() external view returns(uint256) {\\n        return lastProcessedIndex;\\n    }\\n\\n    function getNumberOfTokenHolders() external view returns(uint256) {\\n        return tokenHoldersMap.keys.length;\\n    }\\n\\n\\n\\n    function getAccount(address _account) public view returns (\\n        address account,\\n        int256 index,\\n        int256 iterationsUntilProcessed,\\n        uint256 withdrawableDividends,\\n        uint256 totalDividends,\\n        uint256 lastClaimTime,\\n        uint256 nextClaimTime,\\n        uint256 secondsUntilAutoClaimAvailable) {\\n        account = _account;\\n\\n        index = tokenHoldersMap.getIndexOfKey(account);\\n\\n        iterationsUntilProcessed = -1;\\n\\n        if(index \\u003e= 0) {\\n            if(uint256(index) \\u003e lastProcessedIndex) {\\n                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\\n            }\\n            else {\\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length \\u003e lastProcessedIndex ?\\n                tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\\n                0;\\n\\n                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\\n            }\\n        }\\n\\n\\n        withdrawableDividends = withdrawableDividendOf(account);\\n        totalDividends = accumulativeDividendOf(account);\\n\\n        lastClaimTime = lastClaimTimes[account];\\n\\n        nextClaimTime = lastClaimTime \\u003e 0 ?\\n        lastClaimTime.add(claimWait) :\\n        0;\\n\\n        secondsUntilAutoClaimAvailable = nextClaimTime \\u003e block.timestamp ?\\n        nextClaimTime.sub(block.timestamp) :\\n        0;\\n    }\\n\\n    function getAccountAtIndex(uint256 index)\\n    public view returns (\\n        address,\\n        int256,\\n        int256,\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256) {\\n        if(index \\u003e= tokenHoldersMap.size()) {\\n            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\\n        }\\n\\n        address account = tokenHoldersMap.getKeyAtIndex(index);\\n\\n        return getAccount(account);\\n    }\\n\\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\n        if(lastClaimTime \\u003e block.timestamp)  {\\n            return false;\\n        }\\n\\n        return block.timestamp.sub(lastClaimTime) \\u003e= claimWait;\\n    }\\n\\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\\n        if(excludedFromDividends[account]) {\\n            return;\\n        }\\n\\n        if(newBalance \\u003e= minimumTokenBalanceForDividends) {\\n            _setBalance(account, newBalance);\\n            tokenHoldersMap.set(account, newBalance);\\n        }\\n        else {\\n            _setBalance(account, 0);\\n            tokenHoldersMap.remove(account);\\n        }\\n\\n        emit UpdateDistributionBalanceOfUser(account, newBalance);\\n\\n        processAccount(account, true);\\n    }\\n\\n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\\n        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\\n\\n        if(numberOfTokenHolders == 0) {\\n            return (0, 0, lastProcessedIndex);\\n        }\\n\\n        uint256 _lastProcessedIndex = lastProcessedIndex;\\n\\n        uint256 gasUsed = 0;\\n\\n        uint256 gasLeft = gasleft();\\n\\n        uint256 iterations = 0;\\n        uint256 claims = 0;\\n\\n        while(gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c numberOfTokenHolders) {\\n            _lastProcessedIndex++;\\n\\n            if(_lastProcessedIndex \\u003e= tokenHoldersMap.keys.length) {\\n                _lastProcessedIndex = 0;\\n            }\\n\\n            address account = tokenHoldersMap.keys[_lastProcessedIndex];\\n\\n            if(canAutoClaim(lastClaimTimes[account])) {\\n                if(processAccount(payable(account), true)) {\\n                    claims++;\\n                }\\n            }\\n\\n            iterations++;\\n\\n            uint256 newGasLeft = gasleft();\\n\\n            if(gasLeft \\u003e newGasLeft) {\\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\\n            }\\n\\n            gasLeft = newGasLeft;\\n        }\\n\\n        lastProcessedIndex = _lastProcessedIndex;\\n\\n        return (iterations, claims, lastProcessedIndex);\\n    }\\n\\n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\\n        uint256 amount = _withdrawDividendOfUser(account);\\n\\n        if(amount \\u003e 0) {\\n            lastClaimTimes[account] = block.timestamp;\\n            emit Claim(account, amount, automatic);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\"},\"LifeTokenV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/*\\n     (               )\\n     )\\\\ )  *   )  ( /(             )\\n    (()/(` )  /(  )\\\\()) (   (   ( /(\\n     /(_))( )(_))((_)\\\\  )\\\\  )\\\\  )(_))\\n    (_)) (_(_())  _((_)((_)((_)((_)\\n    | |  |_   _| | \\\\| |\\\\ \\\\ / / |_  )\\n    | |__  | |   | .` | \\\\ V /   / /\\n    |____| |_|   |_|\\\\_|  \\\\_/   /___|\\n\\n    Please check out our WhitePaper over at https://www.thelifetoken.com/\\n    to get an overview of our contract!\\n*/\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nimport \\\"./Address.sol\\\";\\n\\nimport \\\"./Context.sol\\\";\\n\\nimport \\\"./Ownable.sol\\\";\\n\\nimport \\\"./PancakeFactory.sol\\\";\\n\\nimport \\\"./PancakeRouter.sol\\\";\\n\\nimport \\\"./LifeTokenDividends.sol\\\";\\n\\ncontract LifeTokenV2 is Context, IERC20, Ownable {\\n    using Address for address;\\n\\n    enum TransferType {\\n        Default,\\n        Buy,\\n        Sell,\\n        Excluded\\n    }\\n\\n    struct IsExcluded {\\n        bool fromFee;\\n    }\\n\\n    address payable public _charityAddress =\\n        payable(0x52AFe67Dd36Bc0F2fBE4efAE2233B592c75e7538);\\n    address payable public _marketingAddress =\\n        payable(0x7F329F7575FDf8b01eb8B989d7754728dd1647A9);\\n    address payable public _buyBackAddress =\\n        payable(0xC4955fb6E39f9B5e6AaCA059991C46c92A7073f0);\\n    address public immutable _burnAddress = 0x000000000000000000000000000000000000dEaD;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n    mapping(address =\\u003e uint128) private _balances;\\n    mapping(address =\\u003e IsExcluded) private _isExcluded;\\n    LifeTokenDividends public _dividends;\\n\\n    TransferType private _transferType = TransferType.Default;\\n\\n    bool private _lockSwap;\\n    uint8 private _contractToggles;\\n    uint24 private constant DENOMINATOR = 100000;\\n    uint64 private _creationDate = uint64(block.timestamp);\\n    uint128 private _totalSupply = (10**13) * (10**18); /// 10 Trillion\\n\\n    bytes32 private _contractTrackerZero;\\n    bytes32 private _contractTrackerOne;\\n    bytes32 private _contractTrackerTwo;\\n    bytes32 private _contractTrackerThree;\\n\\n    IPancakeRouter02 public  PancakeRouter;\\n    address public  PancakePair;\\n\\n    event UpdateDividendsContract(\\n        address indexed oldAddress,\\n        address indexed newAddress\\n    );\\n    event BuybackAndBurnTokens(uint256 bnbSwapped, uint256 tokensBurned);\\n    event AddLiquidity(uint256 tokensIn, uint256 bnbIn, address path);\\n    event SwapTokensForBNB(uint128 tokensSold, uint128 bnbReceived);\\n    event SendToWallet(\\n        string indexed wallet,\\n        address indexed walletAddress,\\n        uint256 bnbForLP\\n    );\\n    event TrackerUpdated(\\n        bytes32 indexed tracker,\\n        uint128 oldValue,\\n        uint128 newValue,\\n        bool indexed added\\n    );\\n    event ProcessingGasAmountUpdated(uint256 oldValue, uint256 newValue);\\n    event ProcessingDividendsError(address msgSender);\\n    event ProcessedDividends(\\n        uint256 iterations,\\n        uint256 claims,\\n        uint256 lastProcessedIndex,\\n        bool indexed automatic,\\n        uint256 gas,\\n        address indexed processor\\n    );\\n\\n    modifier LockSwap() {\\n        _lockSwap = true;\\n        _;\\n        _lockSwap = false;\\n    }\\n\\n    constructor() {\\n        _dividends = new LifeTokenDividends();\\n\\n        _dividends.excludeFromDividends(address(_dividends));\\n        _dividends.excludeFromDividends(address(this));\\n        _dividends.excludeFromDividends(_charityAddress);\\n        _dividends.excludeFromDividends(_marketingAddress);\\n        _dividends.excludeFromDividends(_buyBackAddress);\\n        _dividends.excludeFromDividends(owner());\\n        _dividends.excludeFromDividends(_burnAddress);\\n\\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\\n            0x10ED43C718714eb63d5aA57B78B54704E256024E // (mainnet)\\n            //0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3 // (testnet router)\\n        );\\n        address pancakePair = IPancakeFactory(pancakeRouter.factory())\\n            .createPair(address(this), pancakeRouter.WETH());\\n        PancakeRouter = pancakeRouter;\\n        PancakePair = pancakePair;\\n        _dividends.excludeFromDividends(PancakePair);\\n        setTracker(3, 0, 500000, false); /// Set gas for processing to 500,000 wei\\n        setTracker(3, 1, 500000000 * (10**18), false); /// Set minimum before sell to 500 million tokens\\n\\n        _isExcluded[owner()].fromFee = true;\\n        _isExcluded[address(this)].fromFee = true;\\n        _balances[owner()] = _totalSupply;\\n        _approve(address(this), address(PancakeRouter), _totalSupply);\\n        emit Transfer(address(0), owner(), _balances[owner()]);\\n    }\\n\\n    receive() external payable {}\\n\\n    function transfer(address to, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _verify(_msgSender(), to);\\n        _transfer(_msgSender(), to, uint128(amount));\\n        return true;\\n    }\\n\\n    \\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, uint128(amount));\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n    unchecked {\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n        return true;\\n    }\\n\\n    \\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n    \\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function setNewDividendsContract(address newAddress) external onlyOwner {\\n        require(\\n            newAddress != address(_dividends),\\n            \\\"Dividends Contract address must not be the same\\\"\\n        );\\n\\n        LifeTokenDividends newDividendsContract = LifeTokenDividends(\\n            payable(newAddress)\\n        );\\n\\n        require(\\n            newDividendsContract.owner() == address(this),\\n            \\\"The New Dividends Contract must be owned by this contract\\\"\\n        );\\n\\n        newDividendsContract.excludeFromDividends(\\n            address(newDividendsContract)\\n        );\\n        newDividendsContract.excludeFromDividends(address(this));\\n        newDividendsContract.excludeFromDividends(owner());\\n        newDividendsContract.excludeFromDividends(address(PancakeRouter));\\n\\n        emit UpdateDividendsContract(address(_dividends), newAddress);\\n\\n        _dividends = newDividendsContract;\\n    }\\n\\n    /// Token Amount for trigger selling tokens\\n    function setGasForProcessingDividends(uint128 gasAmount)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            gasAmount \\u003e= 200000 \\u0026\\u0026 gasAmount \\u003c= 1000000,\\n            \\\"Gas for processing must be between 200,000 and 1,000,000\\\"\\n        );\\n        uint128 oldGasAmount = _getTracker(3, 0);\\n        require(\\n            gasAmount != oldGasAmount,\\n            \\\"Gas amount already set to that value\\\"\\n        );\\n        emit ProcessingGasAmountUpdated(oldGasAmount, gasAmount);\\n        setTracker(3, 0, gasAmount, false);\\n    }\\n\\n    /// Token Amount for trigger selling tokens (min required 1)\\n    function setMinimumTokensBeforeSell(uint128 tokenAmount)\\n        external\\n        onlyOwner\\n    {\\n        require(tokenAmount \\u003e= 1, \\\"Token amount must be at least 1\\\");\\n\\n        setTracker(3, 1, tokenAmount * (10**18), false);\\n    }\\n\\n    function setCharityAddress(address newAddress) external onlyOwner {\\n        _charityAddress = payable(newAddress);\\n    }\\n\\n    function setMarketingAddress(address newAddress) external onlyOwner {\\n        _marketingAddress = payable(newAddress);\\n    }\\n    \\n    function setBuyBackAddress(address newAddress) external onlyOwner {\\n        _buyBackAddress = payable(newAddress);\\n    }\\n\\n    function burn(uint128 amount) external {\\n        _verify(_msgSender(), _burnAddress);\\n        require(\\n            _balances[_msgSender()] \\u003e= amount,\\n            \\\"Balance must be greater than amount\\\"\\n        );\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    function excludeFromFee(address account) external onlyOwner {\\n        require(\\n            !_isExcluded[account].fromFee,\\n            \\\"Account already Excluded from Fee\\\"\\n        );\\n        _isExcluded[account].fromFee = true;\\n    }\\n\\n    function includeInFee(address account) external onlyOwner {\\n        require(\\n            _isExcluded[account].fromFee,\\n            \\\"Account already Included in Fee\\\"\\n        );\\n        _isExcluded[account].fromFee = false;\\n    }\\n\\n\\n    /// Set amount expected via tokens (do not add decimals)\\n    function setMinimumTokensToEarnDividends(\\n        uint128 minimumTokenBalanceForDividends\\n    ) external onlyOwner {\\n        _dividends.updateMinimumTokenBalanceForDividends(\\n            minimumTokenBalanceForDividends\\n        );\\n    }\\n\\n    function updateClaimWait(uint24 claimWait) external onlyOwner {\\n        _dividends.updateClaimWait(claimWait);\\n    }\\n\\n    function processDividendTracker(uint256 gas) external {\\n        (\\n            uint256 iterations,\\n            uint256 claims,\\n            uint256 lastProcessedIndex\\n        ) = _dividends.process(gas);\\n\\n        emit ProcessedDividends(\\n            iterations,\\n            claims,\\n            lastProcessedIndex,\\n            false,\\n            gas,\\n            tx.origin\\n        );\\n    }\\n\\n    function claim() external {\\n        _dividends.processAccount(_msgSender(), false);\\n    }\\n\\n    function getAccountDividendsInfo(address account)\\n        external\\n        view\\n        returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return _dividends.getAccount(account);\\n    }\\n\\n    function getDividendsAddress() external view returns (address) {\\n        return address(_dividends);\\n    }\\n\\n    function getMinimumTokenBalanceToEarnDividends()\\n        external\\n        view\\n        returns (uint128)\\n    {\\n        return uint128(_dividends.minimumTokenBalanceForDividends());\\n    }\\n\\n    function getMinimumTokensBeforeSell() external view returns (uint128) {\\n        return _getTracker(3, 1);\\n    }\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply - _balances[_burnAddress];\\n    }\\n\\n    function balanceOf(address account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _balances[account];\\n    }\\n\\n    function getTracker(uint8 index, uint8 subIndex)\\n        external\\n        view\\n        returns (uint128)\\n    {\\n        return _getTracker(index, subIndex);\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance \\u003e= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n    unchecked {\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n    }\\n\\n        return true;\\n    }\\n\\n    function isExcludedFromFee(address account) external view returns (bool) {\\n        return _isExcluded[account].fromFee;\\n    }\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"Life Token v2\\\";\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return \\\"LTNv2\\\";\\n    }\\n\\n    function decimals() external pure returns (uint256) {\\n        return 18;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint128 amount\\n    ) private {\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\n        require(\\n            _balances[from] \\u003e= amount,\\n            \\\"Balance must be greater than amount\\\"\\n        );\\n\\n        if (_isExcluded[from].fromFee || _isExcluded[to].fromFee) {\\n            _transferType = TransferType.Excluded;\\n        } else if (to == PancakePair || from == PancakePair) {\\n            _transferType = to == PancakePair\\n                ? TransferType.Sell\\n                : TransferType.Buy;\\n        } else {\\n            _transferType = TransferType.Default;\\n        }\\n\\n        uint128 tokenFees;\\n        if (!_lockSwap \\u0026\\u0026 _transferType != TransferType.Excluded) {\\n            (\\n                uint16 charityRate,\\n                uint16 marketingRate,\\n                uint16 dividendsRate,\\n                uint16 liquidityPoolRate,\\n                uint16 buyBackBurnRate\\n            ) = getRates();\\n\\n            uint128 minimumTokensForSell = _getTracker(3, 1);\\n            uint128 charityFee;\\n            uint128 marketingFee;\\n            uint128 dividendsFee;\\n            uint128 liquidityFee;\\n            uint128 buyBackFee;\\n\\n            if (charityRate \\u003e 0)\\n                charityFee = (amount * charityRate) / DENOMINATOR;\\n\\n            if (marketingRate \\u003e 0)\\n                marketingFee = (amount * marketingRate) / DENOMINATOR;\\n\\n            if (dividendsRate \\u003e 0)\\n                dividendsFee = (amount * dividendsRate) / DENOMINATOR;\\n\\n            if (liquidityPoolRate \\u003e 0) \\n                liquidityFee = (amount * liquidityPoolRate) / DENOMINATOR;\\n\\n            if (buyBackBurnRate \\u003e 0)\\n                buyBackFee += (amount * buyBackBurnRate) / DENOMINATOR;\\n\\n            tokenFees +=\\n                charityFee +\\n                marketingFee +\\n                dividendsFee +\\n                liquidityFee +\\n                buyBackFee;\\n\\n            _balances[address(this)] += tokenFees;\\n            \\n            if (\\n                _balances[address(this)] \\u003e= minimumTokensForSell \\u0026\\u0026\\n                _transferType == TransferType.Sell\\n            ) {\\n                sellTokensPlusAddLiquidity(minimumTokensForSell);\\n            } else {\\n                setTracker(0, 0, charityFee, true);\\n                setTracker(0, 1, marketingFee, true);\\n                setTracker(1, 0, dividendsFee, true);\\n                setTracker(1, 1, liquidityFee, true);\\n                setTracker(2, 0, buyBackFee, true);\\n            }\\n        }\\n\\n        finishTransfer(from, to, tokenFees, amount);\\n    }\\n\\n    function sellTokensPlusAddLiquidity(\\n        uint128 minimumTokensForSell\\n    ) private LockSwap {\\n        (uint128 tokensToSell, uint128 tokensForLP) = getExtraLiquidation(\\n            minimumTokensForSell\\n        );\\n\\n        uint128 liquidityBnb;\\n        if (tokensToSell \\u003e 0) {\\n            liquidityBnb = sellTokensAndSendBnb(tokensToSell);\\n        }\\n        \\n        if (tokensForLP \\u003e 0 \\u0026\\u0026 liquidityBnb \\u003e 0) {\\n            addLiquidity(tokensForLP, liquidityBnb);\\n        }\\n    }\\n    \\n    function getExtraLiquidation(uint128 minimumTokensForSell)\\n        private\\n        returns (uint128, uint128)\\n    {\\n        (\\n            uint16 charityRate,\\n            uint16 marketingRate,\\n            uint16 dividendsRate,\\n            uint16 liquidityPoolRate,\\n            uint16 buyBackBurnRate\\n        ) = getRates();\\n        uint24 commonRateDenominator = charityRate +\\n            marketingRate +\\n            dividendsRate +\\n            liquidityPoolRate +\\n            buyBackBurnRate + 12000;\\n        uint128 charityFee;\\n        uint128 marketingFee;\\n        uint128 dividendsFee;\\n        uint128 liquidityFee;\\n        uint128 buybackFee;\\n\\n        if (charityRate \\u003e 0) {\\n            charityFee = minimumTokensForSell * (charityRate + 1000) / commonRateDenominator;\\n\\n            setTracker(0, 0, charityFee, false);\\n        }\\n        \\n        if (marketingRate \\u003e 0) {\\n            marketingFee = minimumTokensForSell * (marketingRate + 2000) / commonRateDenominator;\\n\\n            setTracker(0, 1, marketingFee, false);\\n        }\\n        if (dividendsRate \\u003e 0) {\\n            dividendsFee = minimumTokensForSell * (dividendsRate + 5000) / commonRateDenominator;\\n\\n            setTracker(1, 0, dividendsFee, false);\\n        }\\n        if (liquidityPoolRate \\u003e 0) {\\n            liquidityFee = minimumTokensForSell * (liquidityPoolRate + 2000) / commonRateDenominator;\\n\\n            setTracker(1, 1, liquidityFee, false);\\n            liquidityFee /= 2;\\n        }\\n\\n        if (buyBackBurnRate \\u003e 0) {\\n            buybackFee = minimumTokensForSell * (buyBackBurnRate + 2000) / commonRateDenominator;\\n\\n            setTracker(2, 0, buybackFee, false);\\n        }\\n\\n        return (\\n            (charityFee +\\n                marketingFee +\\n                dividendsFee +\\n                liquidityFee +\\n                buybackFee),\\n            liquidityFee\\n        );\\n    }\\n\\n\\n    function sellTokensAndSendBnb(uint128 tokensToSell)\\n        private \\n        returns (uint128)\\n    {\\n\\n        // generate the Pancake pair path of token -\\u003e weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = PancakeRouter.WETH();\\n        \\n        _approve(address(this), address(PancakeRouter), tokensToSell);\\n        \\n        // make the swap\\n        PancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokensToSell,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        \\n        uint128 liquidityFee;\\n        (\\n            uint16 charityRate,\\n            uint16 marketingRate,\\n            uint16 dividendsRate,\\n            uint16 liquidityPoolRate,\\n            uint16 buybackRate\\n        ) = getRates();\\n        \\n\\n        uint24 commonRateDenominator = charityRate + marketingRate + dividendsRate + liquidityPoolRate + buybackRate + 12000;\\n        if (address(this).balance \\u003e 0) {\\n            \\n            if (liquidityPoolRate \\u003e 0) {\\n                liquidityFee = uint128(address(this).balance);\\n                liquidityFee *= (liquidityPoolRate + 2000) ;\\n            }\\n        }\\n\\n        sendBNB(commonRateDenominator, address(this).balance);\\n\\n        emit SwapTokensForBNB(tokensToSell, uint128(address(this).balance));\\n        \\n\\n        return (liquidityFee / commonRateDenominator);\\n        \\n        \\n    }\\n\\n    function sendBNB(\\n        uint24 commonRateDenominator,\\n        uint256 bnbReceived\\n    ) private {\\n        bool success;\\n\\n        (\\n            uint16 charityRate,\\n            uint16 marketingRate,\\n            uint16 dividendsRate,\\n            ,\\n\\n        ) = getRates();\\n\\n        if (charityRate \\u003e 0) {\\n            uint256 charityBNB = (bnbReceived * (charityRate + 1000) / commonRateDenominator);\\n\\n            (success, ) = _charityAddress.call{value: charityBNB}(\\\"\\\");\\n\\n            if (success)\\n                emit SendToWallet(\\\"Charity\\\", _charityAddress, charityBNB);\\n        }\\n\\n        if (marketingRate \\u003e 0) {\\n            uint256 marketingBNB = (bnbReceived * (marketingRate + 2000) / commonRateDenominator);\\n\\n            (success, ) = _marketingAddress.call{value: marketingBNB}(\\\"\\\");\\n\\n            if (success)\\n                emit SendToWallet(\\\"Marketing\\\", _marketingAddress, marketingBNB);\\n        }\\n\\n        if (dividendsRate \\u003e 0) {\\n            uint256 dividendsBNB = (bnbReceived * (dividendsRate + 5000) / commonRateDenominator);\\n\\n            (success, ) = address(_dividends).call{value: dividendsBNB}(\\\"\\\");\\n\\n            if (success)\\n                emit SendToWallet(\\n                    \\\"Dividends\\\",\\n                    address(_dividends),\\n                    dividendsBNB\\n                );\\n        }\\n    }\\n    \\n    \\n\\n    function addLiquidity(uint128 tokenAmount, uint128 bnbAmount) private {\\n        bool success;\\n        _approve(address(this), address(PancakeRouter), tokenAmount);\\n\\n        PancakeRouter.addLiquidityETH{value: bnbAmount}(\\n            address(this),\\n            tokenAmount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        emit AddLiquidity(tokenAmount, bnbAmount, PancakePair);\\n        \\n        uint256 buyBackBNB = address(this).balance;\\n\\n        (success, ) = _buyBackAddress.call{value: buyBackBNB}(\\\"\\\");\\n\\n        if (success)\\n            emit SendToWallet(\\\"Marketing\\\", _buyBackAddress, buyBackBNB);\\n    }\\n\\n    function getRates()\\n        private\\n        view\\n        returns (\\n            uint16,\\n            uint16,\\n            uint16,\\n            uint16,\\n            uint16\\n        )\\n    {\\n        uint16 charityRate;\\n        uint16 marketingRate;\\n        uint16 dividendsRate;\\n        uint16 liquidityPoolRate;\\n        uint16 buyBackBurnRate;\\n        uint64 timepassed = uint64(block.timestamp);\\n\\n        if (\\n            _transferType == TransferType.Buy ||\\n            _transferType == TransferType.Default\\n        ) {\\n            charityRate = 1000;\\n            marketingRate = 2000;\\n            dividendsRate = 5000;\\n            liquidityPoolRate = 2000;\\n            buyBackBurnRate = 2000;\\n        } else {\\n            charityRate = 1000;\\n\\n            if (timepassed \\u003e= (_creationDate + 7 weeks)) {\\n                dividendsRate = 11000;\\n                liquidityPoolRate = 2000;\\n            } else if (timepassed \\u003e= (_creationDate + 6 weeks)) {\\n                dividendsRate = 10250;\\n                liquidityPoolRate = 2750;\\n            } else if (timepassed \\u003e= (_creationDate + 5 weeks)) {\\n                dividendsRate = 9500;\\n                liquidityPoolRate = 3250;\\n            } else if (timepassed \\u003e= (_creationDate + 4 weeks)) {\\n                dividendsRate = 8750;\\n                liquidityPoolRate = 4250;\\n            } else if (timepassed \\u003e= (_creationDate + 3 weeks)) {\\n                dividendsRate = 8000;\\n                liquidityPoolRate = 7000;\\n            } else if (timepassed \\u003e= (_creationDate + 2 weeks)) {\\n                dividendsRate = 7250;\\n                liquidityPoolRate = 9750;\\n            } else if (timepassed \\u003e= (_creationDate + 1 weeks)) {\\n                // Day 7+\\n                dividendsRate = 6500;\\n                liquidityPoolRate = 14500;\\n            } else {\\n                // Day 0+\\n                dividendsRate = 5750;\\n                liquidityPoolRate = 19250;\\n            }\\n\\n            if (timepassed \\u003e= (_creationDate + 4 weeks)) {\\n                // Day 28+\\n                marketingRate = 2000;\\n                buyBackBurnRate = 2000;\\n            } else if (timepassed \\u003e= (_creationDate + 3 weeks)) {\\n                // Day 21+\\n                marketingRate = 2000;\\n                buyBackBurnRate = 3000;\\n            } else if (timepassed \\u003e= (_creationDate + 2 weeks)) {\\n                // Day 14+\\n                marketingRate = 3000;\\n                buyBackBurnRate = 3000;\\n            } else {\\n                // Day 0-14\\n                marketingRate = 4000;\\n                buyBackBurnRate = 3000;\\n            }\\n        }\\n\\n        return (\\n            charityRate,\\n            marketingRate,\\n            dividendsRate,\\n            liquidityPoolRate,\\n            buyBackBurnRate\\n        );\\n    }\\n\\n    function finishTransfer(\\n        address from,\\n        address to,\\n        uint128 tokenFees,\\n        uint256 amount\\n    ) private {\\n        uint256 amountMinusFees = amount - tokenFees;\\n\\n        _balances[from] -= uint128(amount);\\n        _balances[to] += (uint128(amount) - tokenFees);\\n\\n        if (tokenFees \\u003e 0) emit Transfer(from, address(this), tokenFees);\\n        emit Transfer(from, to, amountMinusFees);\\n\\n        try _dividends.setBalance(payable(from), _balances[from]) {} catch {}\\n        try _dividends.setBalance(payable(to), _balances[to]) {} catch {}\\n\\n        if (!_lockSwap) {\\n            uint256 gas = _getTracker(3, 0);\\n\\n            try _dividends.process(gas) returns (\\n                uint256 iterations,\\n                uint256 claims,\\n                uint256 lastProcessedIndex\\n            ) {\\n                emit ProcessedDividends(\\n                    iterations,\\n                    claims,\\n                    lastProcessedIndex,\\n                    true,\\n                    gas,\\n                    tx.origin\\n                );\\n            } catch {\\n                emit ProcessingDividendsError(msg.sender);\\n            }\\n        }\\n    }\\n\\n    function _burn(address from, uint128 amount) private {\\n        _balances[from] -= amount;\\n        _balances[_burnAddress] += amount;\\n\\n        emit Transfer(from, _burnAddress, amount);\\n    }\\n\\n    /// Sets internal trackers used to keep track of which tokens are being used where.\\n    function setTracker(\\n        uint8 index,\\n        uint8 subIndex,\\n        uint128 value,\\n        bool add\\n    ) private {\\n        require(index \\u003c= 3, \\\"index must be lower\\\");\\n        require(subIndex \\u003c= 1, \\\"subIndex must be lower\\\");\\n\\n        bytes32 tracker;\\n        if (index == 0) {\\n            tracker = _contractTrackerZero;\\n        } else if (index == 1) {\\n            tracker = _contractTrackerOne;\\n        } else if (index == 2) {\\n            tracker = _contractTrackerTwo;\\n        } else if (index == 3) {\\n            tracker = _contractTrackerThree;\\n        }\\n\\n        subIndex *= 128;\\n\\n        uint128 oldValue = uint128(bytes16(tracker \\u003c\\u003c subIndex));\\n        uint128 newValue;\\n\\n        if (index == 3) {\\n            newValue = value;\\n        } else {\\n            if (add) {\\n                newValue = oldValue + value;\\n            } else if (oldValue \\u003e= value) {\\n                newValue = oldValue - value;\\n            } else if (oldValue \\u003c value) {\\n                newValue = 0;\\n            }\\n        }\\n\\n        tracker \\u0026= ~(bytes32(bytes16(~uint128(0))) \\u003e\\u003e subIndex);\\n        tracker |= bytes32(bytes16(uint128(newValue))) \\u003e\\u003e subIndex;\\n\\n        if (index == 0) {\\n            _contractTrackerZero = tracker;\\n        } else if (index == 1) {\\n            _contractTrackerOne = tracker;\\n        } else if (index == 2) {\\n            _contractTrackerTwo = tracker;\\n        } else if (index == 3) {\\n            _contractTrackerThree = tracker;\\n        }\\n\\n        emit TrackerUpdated(tracker, oldValue, newValue, add);\\n    }\\n\\n    function _getTracker(uint8 index, uint8 subIndex)\\n        private\\n        view\\n        returns (uint128)\\n    {\\n        require(index \\u003c= 3, \\\"index too high\\\");\\n        require(subIndex \\u003c= 1, \\\"subIndex too high\\\");\\n        subIndex *= 128;\\n\\n        uint128 value;\\n\\n        if (index == 0) {\\n            value = uint128(bytes16(_contractTrackerZero \\u003c\\u003c subIndex));\\n        } else if (index == 1) {\\n            value = uint128(bytes16(_contractTrackerOne \\u003c\\u003c subIndex));\\n        } else if (index == 2) {\\n            value = uint128(bytes16(_contractTrackerTwo \\u003c\\u003c subIndex));\\n        } else if (index == 3) {\\n            value = uint128(bytes16(_contractTrackerThree \\u003c\\u003c subIndex));\\n        }\\n\\n        return value;\\n    }\\n\\n    function _verify(address from, address to) private pure {\\n        require(from != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: approve to the zero address\\\");\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./Context.sol\\\";\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n    address private _previousOwner;\\n    uint256 private _lockTime;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _owner = address(0);\\n        emit OwnershipTransferred(_owner, address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _owner = newOwner;\\n        emit OwnershipTransferred(_owner, newOwner);\\n    }\\n\\n    function getUnlockTime() public view returns (uint256) {\\n        return _lockTime;\\n    }\\n\\n    function getTime() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /// @param time Value in seconds\\n    function lock(uint256 time) external virtual onlyOwner {\\n        _previousOwner = _owner;\\n        _owner = address(0);\\n        _lockTime = block.timestamp + time;\\n        emit OwnershipTransferred(_owner, address(0));\\n    }\\n\\n    function unlock() public virtual {\\n        require(_previousOwner == msg.sender, \\\"You don\\u0027t have permission to unlock\\\");\\n        require(block.timestamp \\u003e _lockTime , \\\"Contract is locked until 7 days\\\");\\n        _owner = _previousOwner;\\n        emit OwnershipTransferred(_owner, _previousOwner);\\n    }\\n}\\n\"},\"PancakeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.8.0;\\n\\ninterface IPancakeFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\n\\ninterface IPancakeERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\\n\\ninterface IPancakeCallee {\\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\\n\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IPancakePair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"},\"PancakeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\n// File: contracts\\\\interfaces\\\\IPancakeRouter02.sol\\n\\npragma solidity \\u003e=0.6.2;\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"path\",\"type\":\"address\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"}],\"name\":\"BuybackAndBurnTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"ProcessingDividendsError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"ProcessingGasAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"wallet\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbForLP\",\"type\":\"uint256\"}],\"name\":\"SendToWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"tokensSold\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"bnbReceived\",\"type\":\"uint128\"}],\"name\":\"SwapTokensForBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tracker\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"oldValue\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newValue\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"added\",\"type\":\"bool\"}],\"name\":\"TrackerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateDividendsContract\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PancakePair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PancakeRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyBackAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_charityAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_dividends\",\"outputs\":[{\"internalType\":\"contract LifeTokenDividends\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividendsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumTokenBalanceToEarnDividends\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumTokensBeforeSell\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"subIndex\",\"type\":\"uint8\"}],\"name\":\"getTracker\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setBuyBackAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setCharityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"gasAmount\",\"type\":\"uint128\"}],\"name\":\"setGasForProcessingDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setMarketingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"tokenAmount\",\"type\":\"uint128\"}],\"name\":\"setMinimumTokensBeforeSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"minimumTokenBalanceForDividends\",\"type\":\"uint128\"}],\"name\":\"setMinimumTokensToEarnDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setNewDividendsContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"claimWait\",\"type\":\"uint24\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LifeTokenV2", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "IterableMapping:26881902e0506282b7535a105f12ed457d8e0c9b", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://aafa04a326bd16d0ba6b29d746075b0557751a765666e189667b5ad5dba5574f"}