{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/CandaoQuest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\ninterface IOnChainRef {\\n    function getReferralParent(address child) external view returns (address);\\n}\\n\\ncontract CandaoQuest {\\n    event NewQuest(\\n        uint256 questId,\\n        address owner,\\n        address[] token,\\n        uint256[] amount,\\n        uint256 timestamp\\n    );\\n\\n    event NewReward(address recipient, uint256 questId);\\n\\n    event DeletedReward(address recipient, uint256 questId);\\n\\n    event ClaimedReward(address recipient, uint256 questId);\\n\\n    event QuestCancelled(uint256 questId);\\n\\n    struct Quest {\\n        address owner;\\n        address[] token;\\n        uint256[] amount;\\n        address claimUser;\\n    }\\n\\n    // Counter for quest Ids\\n    using Counters for Counters.Counter;\\n    Counters.Counter private _questIds;\\n\\n    mapping(uint256 => Quest) public quests;\\n\\n    IOnChainRef private _refContract;\\n\\n    constructor(address refAddress_) {\\n        _refContract = IOnChainRef(refAddress_);\\n    }\\n\\n    function startQuest(\\n        address[] memory token_,\\n        uint256[] memory amount_,\\n        uint256 timestamp\\n    ) public returns (uint256) {\\n        // Transfer tokens to contract\\n        for (uint i = 0; i < token_.length; i++) {\\n            IERC20(token_[i]).transferFrom(\\n                msg.sender,\\n                address(this),\\n                amount_[i]\\n            );\\n        }\\n\\n        // Add new quest\\n        quests[_questIds.current()] = Quest(\\n            msg.sender,\\n            token_,\\n            amount_,\\n            address(0)\\n        );\\n        uint256 newId = _questIds.current();\\n\\n        emit NewQuest(newId, msg.sender, token_, amount_, timestamp);\\n\\n        _questIds.increment();\\n\\n        return newId;\\n    }\\n\\n    function giveReward(address recipient_, uint256 questId_) public {\\n        Quest storage quest = quests[questId_];\\n        require(quest.owner == msg.sender, \\\"Must be Quest creator\\\");\\n\\n        // Set user that can claim reward\\n        quest.claimUser = recipient_;\\n\\n        emit NewReward(recipient_, questId_);\\n    }\\n\\n    function removeReward(uint256 questId_) public {\\n        Quest storage quest = quests[questId_];\\n        require(quest.owner == msg.sender, \\\"Must be Quest creator\\\");\\n\\n        // Save old recipient for event\\n        address oldRecipient = quest.claimUser;\\n\\n        // Delete old recipient\\n        quest.claimUser = address(0);\\n\\n        emit DeletedReward(oldRecipient, questId_);\\n    }\\n\\n    function claimRewards(uint256 questId_) public {\\n        Quest storage quest = quests[questId_];\\n        require(\\n            quest.claimUser == msg.sender,\\n            \\\"No reward available for sender\\\"\\n        );\\n        address parent = _refContract.getReferralParent(msg.sender);\\n\\n        if (parent == address(0)) {\\n            for (uint i = 0; i < quest.token.length; i++) {\\n                IERC20(quest.token[i]).transfer(msg.sender, quest.amount[i]);\\n            }\\n        } else {\\n            for (uint i = 0; i < quest.token.length; i++) {\\n                IERC20(quest.token[i]).transfer(\\n                    msg.sender,\\n                    (quest.amount[i] * 4) / 5\\n                );\\n                IERC20(quest.token[i]).transfer(parent, quest.amount[i] / 5);\\n            }\\n        }\\n        emit ClaimedReward(msg.sender, questId_);\\n    }\\n\\n    function cancelQuest(uint256 questId_) public {\\n        Quest storage quest = quests[questId_];\\n        require(quest.owner == msg.sender, \\\"Not quest owner\\\");\\n\\n        // Transfer all tokens back to quest creator\\n        for (uint i = 0; i < quest.token.length; i++) {\\n            IERC20(quest.token[i]).transfer(msg.sender, quest.amount[i]);\\n        }\\n\\n        // Remove owner and claim user\\n        quest.owner = address(0);\\n        quest.claimUser = address(0);\\n\\n        emit QuestCancelled(questId_);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"refAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"questId\",\"type\":\"uint256\"}],\"name\":\"ClaimedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"questId\",\"type\":\"uint256\"}],\"name\":\"DeletedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"questId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"token\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"NewQuest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"questId\",\"type\":\"uint256\"}],\"name\":\"NewReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"questId\",\"type\":\"uint256\"}],\"name\":\"QuestCancelled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"questId_\",\"type\":\"uint256\"}],\"name\":\"cancelQuest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"questId_\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"questId_\",\"type\":\"uint256\"}],\"name\":\"giveReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"quests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"claimUser\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"questId_\",\"type\":\"uint256\"}],\"name\":\"removeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"token_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"startQuest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CandaoQuest", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bd0ab18c65c50a70c216986f121137e00b182879", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}