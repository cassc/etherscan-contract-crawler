{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity >=0.8.0;\r\n\r\n// ============ Internal Imports ============\r\n\r\ninterface IMessageRecipient {\r\n    function handle(\r\n        uint32 _origin,\r\n        bytes32 _sender,\r\n        bytes calldata _message\r\n    ) external payable;\r\n}\r\n\r\n/*@@@@@@@       @@@@@@@@@\r\n @@@@@@@@@       @@@@@@@@@\r\n  @@@@@@@@@       @@@@@@@@@\r\n   @@@@@@@@@       @@@@@@@@@\r\n    @@@@@@@@@@@@@@@@@@@@@@@@@\r\n     @@@@@  HYPERLANE  @@@@@@@\r\n    @@@@@@@@@@@@@@@@@@@@@@@@@\r\n   @@@@@@@@@       @@@@@@@@@\r\n  @@@@@@@@@       @@@@@@@@@\r\n @@@@@@@@@       @@@@@@@@@\r\n@@@@@@@@@       @@@@@@@@*/\r\n\r\ninterface IPostDispatchHook {\r\n    enum Types {\r\n        UNUSED,\r\n        ROUTING,\r\n        AGGREGATION,\r\n        MERKLE_TREE,\r\n        INTERCHAIN_GAS_PAYMASTER,\r\n        FALLBACK_ROUTING,\r\n        ID_AUTH_ISM,\r\n        PAUSABLE,\r\n        PROTOCOL_FEE\r\n    }\r\n\r\n    /**\r\n     * @notice Returns an enum that represents the type of hook\r\n     */\r\n    function hookType() external view returns (uint8);\r\n\r\n    /**\r\n     * @notice Returns whether the hook supports metadata\r\n     * @param metadata metadata\r\n     * @return Whether the hook supports metadata\r\n     */\r\n    function supportsMetadata(\r\n        bytes calldata metadata\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Post action after a message is dispatched via the Mailbox\r\n     * @param metadata The metadata required for the hook\r\n     * @param message The message passed from the Mailbox.dispatch() call\r\n     */\r\n    function postDispatch(\r\n        bytes calldata metadata,\r\n        bytes calldata message\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Compute the payment required by the postDispatch call\r\n     * @param metadata The metadata required for the hook\r\n     * @param message The message passed from the Mailbox.dispatch() call\r\n     * @return Quoted payment for the postDispatch call\r\n     */\r\n    function quoteDispatch(\r\n        bytes calldata metadata,\r\n        bytes calldata message\r\n    ) external view returns (uint256);\r\n}\r\n\r\ninterface IInterchainSecurityModule {\r\n    enum Types {\r\n        UNUSED,\r\n        ROUTING,\r\n        AGGREGATION,\r\n        LEGACY_MULTISIG,\r\n        MERKLE_ROOT_MULTISIG,\r\n        MESSAGE_ID_MULTISIG,\r\n        NULL, // used with relayer carrying no metadata\r\n        CCIP_READ\r\n    }\r\n\r\n    /**\r\n     * @notice Returns an enum that represents the type of security model\r\n     * encoded by this ISM.\r\n     * @dev Relayers infer how to fetch and format metadata.\r\n     */\r\n    function moduleType() external view returns (uint8);\r\n\r\n    /**\r\n     * @notice Defines a security model responsible for verifying interchain\r\n     * messages based on the provided metadata.\r\n     * @param _metadata Off-chain metadata provided by a relayer, specific to\r\n     * the security model encoded by the module (e.g. validator signatures)\r\n     * @param _message Hyperlane encoded interchain message\r\n     * @return True if the message was verified\r\n     */\r\n    function verify(\r\n        bytes calldata _metadata,\r\n        bytes calldata _message\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface ISpecifiesInterchainSecurityModule {\r\n    function interchainSecurityModule()\r\n        external\r\n        view\r\n        returns (IInterchainSecurityModule);\r\n}\r\n\r\n// ============ Internal Imports ============\r\n\r\ninterface IMailbox {\r\n    // ============ Events ============\r\n    /**\r\n     * @notice Emitted when a new message is dispatched via Hyperlane\r\n     * @param sender The address that dispatched the message\r\n     * @param destination The destination domain of the message\r\n     * @param recipient The message recipient address on `destination`\r\n     * @param message Raw bytes of message\r\n     */\r\n    event Dispatch(\r\n        address indexed sender,\r\n        uint32 indexed destination,\r\n        bytes32 indexed recipient,\r\n        bytes message\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a new message is dispatched via Hyperlane\r\n     * @param messageId The unique message identifier\r\n     */\r\n    event DispatchId(bytes32 indexed messageId);\r\n\r\n    /**\r\n     * @notice Emitted when a Hyperlane message is processed\r\n     * @param messageId The unique message identifier\r\n     */\r\n    event ProcessId(bytes32 indexed messageId);\r\n\r\n    /**\r\n     * @notice Emitted when a Hyperlane message is delivered\r\n     * @param origin The origin domain of the message\r\n     * @param sender The message sender address on `origin`\r\n     * @param recipient The address that handled the message\r\n     */\r\n    event Process(\r\n        uint32 indexed origin,\r\n        bytes32 indexed sender,\r\n        address indexed recipient\r\n    );\r\n\r\n    function localDomain() external view returns (uint32);\r\n\r\n    function delivered(bytes32 messageId) external view returns (bool);\r\n\r\n    function defaultIsm() external view returns (IInterchainSecurityModule);\r\n\r\n    function defaultHook() external view returns (IPostDispatchHook);\r\n\r\n    function requiredHook() external view returns (IPostDispatchHook);\r\n\r\n    function latestDispatchedId() external view returns (bytes32);\r\n\r\n    function dispatch(\r\n        uint32 destinationDomain,\r\n        bytes32 recipientAddress,\r\n        bytes calldata messageBody\r\n    ) external payable returns (bytes32 messageId);\r\n\r\n    function quoteDispatch(\r\n        uint32 destinationDomain,\r\n        bytes32 recipientAddress,\r\n        bytes calldata messageBody\r\n    ) external view returns (uint256 fee);\r\n\r\n    function dispatch(\r\n        uint32 destinationDomain,\r\n        bytes32 recipientAddress,\r\n        bytes calldata body,\r\n        bytes calldata defaultHookMetadata\r\n    ) external payable returns (bytes32 messageId);\r\n\r\n    function quoteDispatch(\r\n        uint32 destinationDomain,\r\n        bytes32 recipientAddress,\r\n        bytes calldata messageBody,\r\n        bytes calldata defaultHookMetadata\r\n    ) external view returns (uint256 fee);\r\n\r\n    function dispatch(\r\n        uint32 destinationDomain,\r\n        bytes32 recipientAddress,\r\n        bytes calldata body,\r\n        bytes calldata customHookMetadata,\r\n        IPostDispatchHook customHook\r\n    ) external payable returns (bytes32 messageId);\r\n\r\n    function quoteDispatch(\r\n        uint32 destinationDomain,\r\n        bytes32 recipientAddress,\r\n        bytes calldata messageBody,\r\n        bytes calldata customHookMetadata,\r\n        IPostDispatchHook customHook\r\n    ) external view returns (uint256 fee);\r\n\r\n    function process(\r\n        bytes calldata metadata,\r\n        bytes calldata message\r\n    ) external payable;\r\n\r\n    function recipientIsm(\r\n        address recipient\r\n    ) external view returns (IInterchainSecurityModule module);\r\n}\r\n\r\nlibrary TypeCasts {\r\n    // alignment preserving cast\r\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(_addr)));\r\n    }\r\n\r\n    // alignment preserving cast\r\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\r\n        return address(uint160(uint256(_buf)));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Hyperlane Message Library\r\n * @notice Library for formatted messages used by Mailbox\r\n **/\r\nlibrary Message {\r\n    using TypeCasts for bytes32;\r\n\r\n    uint256 private constant VERSION_OFFSET = 0;\r\n    uint256 private constant NONCE_OFFSET = 1;\r\n    uint256 private constant ORIGIN_OFFSET = 5;\r\n    uint256 private constant SENDER_OFFSET = 9;\r\n    uint256 private constant DESTINATION_OFFSET = 41;\r\n    uint256 private constant RECIPIENT_OFFSET = 45;\r\n    uint256 private constant BODY_OFFSET = 77;\r\n\r\n    /**\r\n     * @notice Returns formatted (packed) Hyperlane message with provided fields\r\n     * @dev This function should only be used in memory message construction.\r\n     * @param _version The version of the origin and destination Mailboxes\r\n     * @param _nonce A nonce to uniquely identify the message on its origin chain\r\n     * @param _originDomain Domain of origin chain\r\n     * @param _sender Address of sender as bytes32\r\n     * @param _destinationDomain Domain of destination chain\r\n     * @param _recipient Address of recipient on destination chain as bytes32\r\n     * @param _messageBody Raw bytes of message body\r\n     * @return Formatted message\r\n     */\r\n    function formatMessage(\r\n        uint8 _version,\r\n        uint32 _nonce,\r\n        uint32 _originDomain,\r\n        bytes32 _sender,\r\n        uint32 _destinationDomain,\r\n        bytes32 _recipient,\r\n        bytes calldata _messageBody\r\n    ) internal pure returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                _version,\r\n                _nonce,\r\n                _originDomain,\r\n                _sender,\r\n                _destinationDomain,\r\n                _recipient,\r\n                _messageBody\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message ID.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return ID of `_message`\r\n     */\r\n    function id(bytes memory _message) internal pure returns (bytes32) {\r\n        return keccak256(_message);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message version.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Version of `_message`\r\n     */\r\n    function version(bytes calldata _message) internal pure returns (uint8) {\r\n        return uint8(bytes1(_message[VERSION_OFFSET:NONCE_OFFSET]));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message nonce.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Nonce of `_message`\r\n     */\r\n    function nonce(bytes calldata _message) internal pure returns (uint32) {\r\n        return uint32(bytes4(_message[NONCE_OFFSET:ORIGIN_OFFSET]));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message origin domain.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Origin domain of `_message`\r\n     */\r\n    function origin(bytes calldata _message) internal pure returns (uint32) {\r\n        return uint32(bytes4(_message[ORIGIN_OFFSET:SENDER_OFFSET]));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message sender as bytes32.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Sender of `_message` as bytes32\r\n     */\r\n    function sender(bytes calldata _message) internal pure returns (bytes32) {\r\n        return bytes32(_message[SENDER_OFFSET:DESTINATION_OFFSET]);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message sender as address.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Sender of `_message` as address\r\n     */\r\n    function senderAddress(\r\n        bytes calldata _message\r\n    ) internal pure returns (address) {\r\n        return sender(_message).bytes32ToAddress();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message destination domain.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Destination domain of `_message`\r\n     */\r\n    function destination(\r\n        bytes calldata _message\r\n    ) internal pure returns (uint32) {\r\n        return uint32(bytes4(_message[DESTINATION_OFFSET:RECIPIENT_OFFSET]));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message recipient as bytes32.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Recipient of `_message` as bytes32\r\n     */\r\n    function recipient(\r\n        bytes calldata _message\r\n    ) internal pure returns (bytes32) {\r\n        return bytes32(_message[RECIPIENT_OFFSET:BODY_OFFSET]);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message recipient as address.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Recipient of `_message` as address\r\n     */\r\n    function recipientAddress(\r\n        bytes calldata _message\r\n    ) internal pure returns (address) {\r\n        return recipient(_message).bytes32ToAddress();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the message body.\r\n     * @param _message ABI encoded Hyperlane message.\r\n     * @return Body of `_message`\r\n     */\r\n    function body(\r\n        bytes calldata _message\r\n    ) internal pure returns (bytes calldata) {\r\n        return bytes(_message[BODY_OFFSET:]);\r\n    }\r\n}\r\n\r\n// ============ External Imports ============\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized != type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\nabstract contract MailboxClient is OwnableUpgradeable {\r\n    using Message for bytes;\r\n\r\n    IMailbox public immutable mailbox;\r\n\r\n    uint32 public immutable localDomain;\r\n\r\n    IPostDispatchHook public hook;\r\n\r\n    IInterchainSecurityModule public interchainSecurityModule;\r\n\r\n    uint256[48] private __GAP; // gap for upgrade safety\r\n\r\n    // ============ Modifiers ============\r\n    modifier onlyContract(address _contract) {\r\n        require(\r\n            Address.isContract(_contract),\r\n            \"MailboxClient: invalid mailbox\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyContractOrNull(address _contract) {\r\n        require(\r\n            Address.isContract(_contract) || _contract == address(0),\r\n            \"MailboxClient: invalid contract setting\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Only accept messages from an Hyperlane Mailbox contract\r\n     */\r\n    modifier onlyMailbox() {\r\n        require(\r\n            msg.sender == address(mailbox),\r\n            \"MailboxClient: sender not mailbox\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _mailbox) onlyContract(_mailbox) {\r\n        mailbox = IMailbox(_mailbox);\r\n        localDomain = mailbox.localDomain();\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address of the application's custom hook.\r\n     * @param _hook The address of the hook contract.\r\n     */\r\n    function setHook(address _hook) public onlyContractOrNull(_hook) onlyOwner {\r\n        hook = IPostDispatchHook(_hook);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address of the application's custom interchain security module.\r\n     * @param _module The address of the interchain security module contract.\r\n     */\r\n    function setInterchainSecurityModule(\r\n        address _module\r\n    ) public onlyContractOrNull(_module) onlyOwner {\r\n        interchainSecurityModule = IInterchainSecurityModule(_module);\r\n    }\r\n\r\n    // ======== Initializer =========\r\n    function _MailboxClient_initialize(\r\n        address _hook,\r\n        address _interchainSecurityModule,\r\n        address _owner\r\n    ) internal onlyInitializing {\r\n        __Ownable_init();\r\n        setHook(_hook);\r\n        setInterchainSecurityModule(_interchainSecurityModule);\r\n        _transferOwnership(_owner);\r\n    }\r\n\r\n    function _isLatestDispatched(bytes32 id) internal view returns (bool) {\r\n        return mailbox.latestDispatchedId() == id;\r\n    }\r\n\r\n    function _metadata(\r\n        uint32 /*_destinationDomain*/\r\n    ) internal view virtual returns (bytes memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function _dispatch(\r\n        uint32 _destinationDomain,\r\n        bytes32 _recipient,\r\n        bytes memory _messageBody\r\n    ) internal virtual returns (bytes32) {\r\n        return\r\n            _dispatch(_destinationDomain, _recipient, msg.value, _messageBody);\r\n    }\r\n\r\n    function _dispatch(\r\n        uint32 _destinationDomain,\r\n        bytes32 _recipient,\r\n        uint256 _value,\r\n        bytes memory _messageBody\r\n    ) internal virtual returns (bytes32) {\r\n        return\r\n            mailbox.dispatch{value: _value}(\r\n                _destinationDomain,\r\n                _recipient,\r\n                _messageBody,\r\n                _metadata(_destinationDomain),\r\n                hook\r\n            );\r\n    }\r\n\r\n    function _quoteDispatch(\r\n        uint32 _destinationDomain,\r\n        bytes32 _recipient,\r\n        bytes memory _messageBody\r\n    ) internal view virtual returns (uint256) {\r\n        return\r\n            mailbox.quoteDispatch(\r\n                _destinationDomain,\r\n                _recipient,\r\n                _messageBody,\r\n                _metadata(_destinationDomain),\r\n                hook\r\n            );\r\n    }\r\n}\r\n\r\n// ============ External Imports ============\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableMap.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```solidity\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Library for managing an enumerable variant of Solidity's\r\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\r\n * type.\r\n *\r\n * Maps have the following properties:\r\n *\r\n * - Entries are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```solidity\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableMap.UintToAddressMap private myMap;\r\n * }\r\n * ```\r\n *\r\n * The following map types are supported:\r\n *\r\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\r\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\r\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\r\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\r\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableMap.\r\n * ====\r\n */\r\nlibrary EnumerableMap {\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Map type with\r\n    // bytes32 keys and values.\r\n    // The Map implementation uses private functions, and user-facing\r\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\r\n    // the underlying Map.\r\n    // This means that we can only create new EnumerableMaps for types that fit\r\n    // in bytes32.\r\n\r\n    struct Bytes32ToBytes32Map {\r\n        // Storage of keys\r\n        EnumerableSet.Bytes32Set _keys;\r\n        mapping(bytes32 => bytes32) _values;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\r\n        map._values[key] = value;\r\n        return map._keys.add(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a key-value pair from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\r\n        delete map._values[key];\r\n        return map._keys.remove(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\r\n        return map._keys.contains(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of key-value pairs in the map. O(1).\r\n     */\r\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\r\n        return map._keys.length();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of entries inside the\r\n     * array, and it may change when more entries are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\r\n        bytes32 key = map._keys.at(index);\r\n        return (key, map._values[key]);\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\r\n        bytes32 value = map._values[key];\r\n        if (value == bytes32(0)) {\r\n            return (contains(map, key), bytes32(0));\r\n        } else {\r\n            return (true, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\r\n        bytes32 value = map._values[key];\r\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        Bytes32ToBytes32Map storage map,\r\n        bytes32 key,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes32) {\r\n        bytes32 value = map._values[key];\r\n        require(value != 0 || contains(map, key), errorMessage);\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the an array containing all the keys\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\r\n        return map._keys.values();\r\n    }\r\n\r\n    // UintToUintMap\r\n\r\n    struct UintToUintMap {\r\n        Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\r\n        return set(map._inner, bytes32(key), bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\r\n        return remove(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\r\n        return contains(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(UintToUintMap storage map) internal view returns (uint256) {\r\n        return length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the map. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\r\n        (bytes32 key, bytes32 value) = at(map._inner, index);\r\n        return (uint256(key), uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\r\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\r\n        return (success, uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\r\n        return uint256(get(map._inner, bytes32(key)));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(UintToUintMap storage map, uint256 key, string memory errorMessage) internal view returns (uint256) {\r\n        return uint256(get(map._inner, bytes32(key), errorMessage));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the an array containing all the keys\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = keys(map._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintToAddressMap\r\n\r\n    struct UintToAddressMap {\r\n        Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\r\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\r\n        return remove(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\r\n        return contains(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\r\n        return length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the map. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\r\n        (bytes32 key, bytes32 value) = at(map._inner, index);\r\n        return (uint256(key), address(uint160(uint256(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\r\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\r\n        return (success, address(uint160(uint256(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\r\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        UintToAddressMap storage map,\r\n        uint256 key,\r\n        string memory errorMessage\r\n    ) internal view returns (address) {\r\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the an array containing all the keys\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = keys(map._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressToUintMap\r\n\r\n    struct AddressToUintMap {\r\n        Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\r\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\r\n        return remove(map._inner, bytes32(uint256(uint160(key))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\r\n        return contains(map._inner, bytes32(uint256(uint160(key))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\r\n        return length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the map. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\r\n        (bytes32 key, bytes32 value) = at(map._inner, index);\r\n        return (address(uint160(uint256(key))), uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\r\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\r\n        return (success, uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\r\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        AddressToUintMap storage map,\r\n        address key,\r\n        string memory errorMessage\r\n    ) internal view returns (uint256) {\r\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the an array containing all the keys\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\r\n        bytes32[] memory store = keys(map._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Bytes32ToUintMap\r\n\r\n    struct Bytes32ToUintMap {\r\n        Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\r\n        return set(map._inner, key, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\r\n        return remove(map._inner, key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\r\n        return contains(map._inner, key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\r\n        return length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the map. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\r\n        (bytes32 key, bytes32 value) = at(map._inner, index);\r\n        return (key, uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\r\n        (bool success, bytes32 value) = tryGet(map._inner, key);\r\n        return (success, uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\r\n        return uint256(get(map._inner, key));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        Bytes32ToUintMap storage map,\r\n        bytes32 key,\r\n        string memory errorMessage\r\n    ) internal view returns (uint256) {\r\n        return uint256(get(map._inner, key, errorMessage));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the an array containing all the keys\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = keys(map._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// extends EnumerableMap with uint256 => bytes32 type\r\n// modelled after https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/utils/structs/EnumerableMap.sol\r\nlibrary EnumerableMapExtended {\r\n    using EnumerableMap for EnumerableMap.Bytes32ToBytes32Map;\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n\r\n    struct UintToBytes32Map {\r\n        EnumerableMap.Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    // ============ Library Functions ============\r\n    function keys(\r\n        UintToBytes32Map storage map\r\n    ) internal view returns (uint256[] memory _keys) {\r\n        uint256 _length = map._inner.length();\r\n        _keys = new uint256[](_length);\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            _keys[i] = uint256(map._inner._keys.at(i));\r\n        }\r\n    }\r\n\r\n    function uint32Keys(\r\n        UintToBytes32Map storage map\r\n    ) internal view returns (uint32[] memory _keys) {\r\n        uint256[] memory uint256keys = keys(map);\r\n        _keys = new uint32[](uint256keys.length);\r\n        for (uint256 i = 0; i < uint256keys.length; i++) {\r\n            _keys[i] = uint32(uint256keys[i]);\r\n        }\r\n    }\r\n\r\n    function set(\r\n        UintToBytes32Map storage map,\r\n        uint256 key,\r\n        bytes32 value\r\n    ) internal {\r\n        map._inner.set(bytes32(key), value);\r\n    }\r\n\r\n    function get(\r\n        UintToBytes32Map storage map,\r\n        uint256 key\r\n    ) internal view returns (bytes32) {\r\n        return map._inner.get(bytes32(key));\r\n    }\r\n\r\n    function tryGet(\r\n        UintToBytes32Map storage map,\r\n        uint256 key\r\n    ) internal view returns (bool, bytes32) {\r\n        return map._inner.tryGet(bytes32(key));\r\n    }\r\n\r\n    function remove(\r\n        UintToBytes32Map storage map,\r\n        uint256 key\r\n    ) internal returns (bool) {\r\n        return map._inner.remove(bytes32(key));\r\n    }\r\n\r\n    function contains(\r\n        UintToBytes32Map storage map,\r\n        uint256 key\r\n    ) internal view returns (bool) {\r\n        return map._inner.contains(bytes32(key));\r\n    }\r\n\r\n    function length(\r\n        UintToBytes32Map storage map\r\n    ) internal view returns (uint256) {\r\n        return map._inner.length();\r\n    }\r\n\r\n    function at(\r\n        UintToBytes32Map storage map,\r\n        uint256 index\r\n    ) internal view returns (uint256, bytes32) {\r\n        (bytes32 key, bytes32 value) = map._inner.at(index);\r\n        return (uint256(key), value);\r\n    }\r\n}\r\n\r\n// ============ External Imports ============\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(int256 value) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\nabstract contract Router is MailboxClient, IMessageRecipient {\r\n    using EnumerableMapExtended for EnumerableMapExtended.UintToBytes32Map;\r\n    using Strings for uint32;\r\n\r\n    // ============ Mutable Storage ============\r\n    EnumerableMapExtended.UintToBytes32Map internal _routers;\r\n\r\n    uint256[48] private __GAP; // gap for upgrade safety\r\n\r\n    constructor(address _mailbox) MailboxClient(_mailbox) {}\r\n\r\n    // ============ External functions ============\r\n    function domains() external view returns (uint32[] memory) {\r\n        return _routers.uint32Keys();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the Router contract for the given domain\r\n     * @param _domain The remote domain ID.\r\n     * @dev Returns 0 address if no router is enrolled for the given domain\r\n     * @return router The address of the Router contract for the given domain\r\n     */\r\n    function routers(uint32 _domain) public view virtual returns (bytes32) {\r\n        (, bytes32 _router) = _routers.tryGet(_domain);\r\n        return _router;\r\n    }\r\n\r\n    /**\r\n     * @notice Unregister the domain\r\n     * @param _domain The domain of the remote Application Router\r\n     */\r\n    function unenrollRemoteRouter(uint32 _domain) external virtual onlyOwner {\r\n        _unenrollRemoteRouter(_domain);\r\n    }\r\n\r\n    /**\r\n     * @notice Register the address of a Router contract for the same Application on a remote chain\r\n     * @param _domain The domain of the remote Application Router\r\n     * @param _router The address of the remote Application Router\r\n     */\r\n    function enrollRemoteRouter(\r\n        uint32 _domain,\r\n        bytes32 _router\r\n    ) external virtual onlyOwner {\r\n        _enrollRemoteRouter(_domain, _router);\r\n    }\r\n\r\n    /**\r\n     * @notice Batch version of `enrollRemoteRouter`\r\n     * @param _domains The domains of the remote Application Routers\r\n     * @param _addresses The addresses of the remote Application Routers\r\n     */\r\n    function enrollRemoteRouters(\r\n        uint32[] calldata _domains,\r\n        bytes32[] calldata _addresses\r\n    ) external virtual onlyOwner {\r\n        require(_domains.length == _addresses.length, \"!length\");\r\n        uint256 length = _domains.length;\r\n        for (uint256 i = 0; i < length; i += 1) {\r\n            _enrollRemoteRouter(_domains[i], _addresses[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Batch version of `unenrollRemoteRouter`\r\n     * @param _domains The domains of the remote Application Routers\r\n     */\r\n    function unenrollRemoteRouters(\r\n        uint32[] calldata _domains\r\n    ) external virtual onlyOwner {\r\n        uint256 length = _domains.length;\r\n        for (uint256 i = 0; i < length; i += 1) {\r\n            _unenrollRemoteRouter(_domains[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Handles an incoming message\r\n     * @param _origin The origin domain\r\n     * @param _sender The sender address\r\n     * @param _message The message\r\n     */\r\n    function handle(\r\n        uint32 _origin,\r\n        bytes32 _sender,\r\n        bytes calldata _message\r\n    ) external payable virtual override onlyMailbox {\r\n        bytes32 _router = _mustHaveRemoteRouter(_origin);\r\n        require(_router == _sender, \"Enrolled router does not match sender\");\r\n        _handle(_origin, _sender, _message);\r\n    }\r\n\r\n    // ============ Virtual functions ============\r\n    function _handle(\r\n        uint32 _origin,\r\n        bytes32 _sender,\r\n        bytes calldata _message\r\n    ) internal virtual;\r\n\r\n    // ============ Internal functions ============\r\n\r\n    /**\r\n     * @notice Set the router for a given domain\r\n     * @param _domain The domain\r\n     * @param _address The new router\r\n     */\r\n    function _enrollRemoteRouter(\r\n        uint32 _domain,\r\n        bytes32 _address\r\n    ) internal virtual {\r\n        _routers.set(_domain, _address);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the router for a given domain\r\n     * @param _domain The domain\r\n     */\r\n    function _unenrollRemoteRouter(uint32 _domain) internal virtual {\r\n        require(_routers.remove(_domain), _domainNotFoundError(_domain));\r\n    }\r\n\r\n    /**\r\n     * @notice Return true if the given domain / router is the address of a remote Application Router\r\n     * @param _domain The domain of the potential remote Application Router\r\n     * @param _address The address of the potential remote Application Router\r\n     */\r\n    function _isRemoteRouter(\r\n        uint32 _domain,\r\n        bytes32 _address\r\n    ) internal view returns (bool) {\r\n        return routers(_domain) == _address;\r\n    }\r\n\r\n    /**\r\n     * @notice Assert that the given domain has a Application Router registered and return its address\r\n     * @param _domain The domain of the chain for which to get the Application Router\r\n     * @return _router The address of the remote Application Router on _domain\r\n     */\r\n    function _mustHaveRemoteRouter(\r\n        uint32 _domain\r\n    ) internal view returns (bytes32) {\r\n        (bool contained, bytes32 _router) = _routers.tryGet(_domain);\r\n        require(contained, _domainNotFoundError(_domain));\r\n        return _router;\r\n    }\r\n\r\n    function _domainNotFoundError(\r\n        uint32 _domain\r\n    ) internal pure returns (string memory) {\r\n        return\r\n            string.concat(\r\n                \"No router enrolled for domain: \",\r\n                _domain.toString()\r\n            );\r\n    }\r\n\r\n    function _dispatch(\r\n        uint32 _destinationDomain,\r\n        bytes memory _messageBody\r\n    ) internal virtual returns (bytes32) {\r\n        return _dispatch(_destinationDomain, msg.value, _messageBody);\r\n    }\r\n\r\n    function _dispatch(\r\n        uint32 _destinationDomain,\r\n        uint256 _value,\r\n        bytes memory _messageBody\r\n    ) internal virtual returns (bytes32) {\r\n        bytes32 _router = _mustHaveRemoteRouter(_destinationDomain);\r\n        return\r\n            super._dispatch(_destinationDomain, _router, _value, _messageBody);\r\n    }\r\n\r\n    function _quoteDispatch(\r\n        uint32 _destinationDomain,\r\n        bytes memory _messageBody\r\n    ) internal view virtual returns (uint256) {\r\n        bytes32 _router = _mustHaveRemoteRouter(_destinationDomain);\r\n        return super._quoteDispatch(_destinationDomain, _router, _messageBody);\r\n    }\r\n}\r\n\r\n/*@@@@@@@       @@@@@@@@@\r\n @@@@@@@@@       @@@@@@@@@\r\n  @@@@@@@@@       @@@@@@@@@\r\n   @@@@@@@@@       @@@@@@@@@\r\n    @@@@@@@@@@@@@@@@@@@@@@@@@\r\n     @@@@@  HYPERLANE  @@@@@@@\r\n    @@@@@@@@@@@@@@@@@@@@@@@@@\r\n   @@@@@@@@@       @@@@@@@@@\r\n  @@@@@@@@@       @@@@@@@@@\r\n @@@@@@@@@       @@@@@@@@@\r\n@@@@@@@@@       @@@@@@@@*/\r\n\r\n/**\r\n * Format of metadata:\r\n *\r\n * [0:2] variant\r\n * [2:34] msg.value\r\n * [34:66] Gas limit for message (IGP)\r\n * [66:86] Refund address for message (IGP)\r\n * [86:] Custom metadata\r\n */\r\nlibrary StandardHookMetadata {\r\n    struct Metadata {\r\n        uint16 variant;\r\n        uint256 msgValue;\r\n        uint256 gasLimit;\r\n        address refundAddress;\r\n    }\r\n\r\n    uint8 private constant VARIANT_OFFSET = 0;\r\n    uint8 private constant MSG_VALUE_OFFSET = 2;\r\n    uint8 private constant GAS_LIMIT_OFFSET = 34;\r\n    uint8 private constant REFUND_ADDRESS_OFFSET = 66;\r\n    uint256 private constant MIN_METADATA_LENGTH = 86;\r\n\r\n    uint16 public constant VARIANT = 1;\r\n\r\n    /**\r\n     * @notice Returns the variant of the metadata.\r\n     * @param _metadata ABI encoded standard hook metadata.\r\n     * @return variant of the metadata as uint8.\r\n     */\r\n    function variant(bytes calldata _metadata) internal pure returns (uint16) {\r\n        if (_metadata.length < VARIANT_OFFSET + 2) return 0;\r\n        return uint16(bytes2(_metadata[VARIANT_OFFSET:VARIANT_OFFSET + 2]));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the specified value for the message.\r\n     * @param _metadata ABI encoded standard hook metadata.\r\n     * @param _default Default fallback value.\r\n     * @return Value for the message as uint256.\r\n     */\r\n    function msgValue(\r\n        bytes calldata _metadata,\r\n        uint256 _default\r\n    ) internal pure returns (uint256) {\r\n        if (_metadata.length < MSG_VALUE_OFFSET + 32) return _default;\r\n        return\r\n            uint256(bytes32(_metadata[MSG_VALUE_OFFSET:MSG_VALUE_OFFSET + 32]));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the specified gas limit for the message.\r\n     * @param _metadata ABI encoded standard hook metadata.\r\n     * @param _default Default fallback gas limit.\r\n     * @return Gas limit for the message as uint256.\r\n     */\r\n    function gasLimit(\r\n        bytes calldata _metadata,\r\n        uint256 _default\r\n    ) internal pure returns (uint256) {\r\n        if (_metadata.length < GAS_LIMIT_OFFSET + 32) return _default;\r\n        return\r\n            uint256(bytes32(_metadata[GAS_LIMIT_OFFSET:GAS_LIMIT_OFFSET + 32]));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the specified refund address for the message.\r\n     * @param _metadata ABI encoded standard hook metadata.\r\n     * @param _default Default fallback refund address.\r\n     * @return Refund address for the message as address.\r\n     */\r\n    function refundAddress(\r\n        bytes calldata _metadata,\r\n        address _default\r\n    ) internal pure returns (address) {\r\n        if (_metadata.length < REFUND_ADDRESS_OFFSET + 20) return _default;\r\n        return\r\n            address(\r\n                bytes20(\r\n                    _metadata[REFUND_ADDRESS_OFFSET:REFUND_ADDRESS_OFFSET + 20]\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns any custom metadata.\r\n     * @param _metadata ABI encoded standard hook metadata.\r\n     * @return Custom metadata.\r\n     */\r\n    function getCustomMetadata(\r\n        bytes calldata _metadata\r\n    ) internal pure returns (bytes calldata) {\r\n        if (_metadata.length < MIN_METADATA_LENGTH) return _metadata[0:0];\r\n        return _metadata[MIN_METADATA_LENGTH:];\r\n    }\r\n\r\n    /**\r\n     * @notice Formats the specified gas limit and refund address into standard hook metadata.\r\n     * @param _msgValue msg.value for the message.\r\n     * @param _gasLimit Gas limit for the message.\r\n     * @param _refundAddress Refund address for the message.\r\n     * @param _customMetadata Additional metadata to include in the standard hook metadata.\r\n     * @return ABI encoded standard hook metadata.\r\n     */\r\n    function formatMetadata(\r\n        uint256 _msgValue,\r\n        uint256 _gasLimit,\r\n        address _refundAddress,\r\n        bytes memory _customMetadata\r\n    ) internal pure returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                VARIANT,\r\n                _msgValue,\r\n                _gasLimit,\r\n                _refundAddress,\r\n                _customMetadata\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Formats the specified gas limit and refund address into standard hook metadata.\r\n     * @param _msgValue msg.value for the message.\r\n     * @return ABI encoded standard hook metadata.\r\n     */\r\n    function overrideMsgValue(\r\n        uint256 _msgValue\r\n    ) internal view returns (bytes memory) {\r\n        return formatMetadata(_msgValue, uint256(0), msg.sender, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Formats the specified gas limit and refund address into standard hook metadata.\r\n     * @param _gasLimit Gas limit for the message.\r\n     * @return ABI encoded standard hook metadata.\r\n     */\r\n    function overrideGasLimit(\r\n        uint256 _gasLimit\r\n    ) internal view returns (bytes memory) {\r\n        return formatMetadata(uint256(0), _gasLimit, msg.sender, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Formats the specified refund address into standard hook metadata.\r\n     * @param _refundAddress Refund address for the message.\r\n     * @return ABI encoded standard hook metadata.\r\n     */\r\n    function overrideRefundAddress(\r\n        address _refundAddress\r\n    ) internal pure returns (bytes memory) {\r\n        return formatMetadata(uint256(0), uint256(0), _refundAddress, \"\");\r\n    }\r\n}\r\n\r\nabstract contract GasRouter is Router {\r\n    // ============ Mutable Storage ============\r\n    mapping(uint32 => uint256) public destinationGas;\r\n\r\n    struct GasRouterConfig {\r\n        uint32 domain;\r\n        uint256 gas;\r\n    }\r\n\r\n    constructor(address _mailbox) Router(_mailbox) {}\r\n\r\n    /**\r\n     * @notice Sets the gas amount dispatched for each configured domain.\r\n     * @param gasConfigs The array of GasRouterConfig structs\r\n     */\r\n    function setDestinationGas(\r\n        GasRouterConfig[] calldata gasConfigs\r\n    ) external onlyOwner {\r\n        for (uint256 i = 0; i < gasConfigs.length; i += 1) {\r\n            _setDestinationGas(gasConfigs[i].domain, gasConfigs[i].gas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the gas amount dispatched for each configured domain.\r\n     * @param domain The destination domain ID\r\n     * @param gas The gas limit\r\n     */\r\n    function setDestinationGas(uint32 domain, uint256 gas) external onlyOwner {\r\n        _setDestinationGas(domain, gas);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the gas payment required to dispatch a message to the given domain's router.\r\n     * @param _destinationDomain The domain of the router.\r\n     * @return _gasPayment Payment computed by the registered InterchainGasPaymaster.\r\n     */\r\n    function quoteGasPayment(\r\n        uint32 _destinationDomain\r\n    ) external view returns (uint256 _gasPayment) {\r\n        return _quoteDispatch(_destinationDomain, \"\");\r\n    }\r\n\r\n    function _metadata(\r\n        uint32 _destination\r\n    ) internal view virtual override returns (bytes memory) {\r\n        return\r\n            StandardHookMetadata.overrideGasLimit(destinationGas[_destination]);\r\n    }\r\n\r\n    function _setDestinationGas(uint32 domain, uint256 gas) internal {\r\n        destinationGas[domain] = gas;\r\n    }\r\n}\r\n\r\nlibrary TokenMessage {\r\n    function format(\r\n        bytes32 _recipient,\r\n        uint256 _amount,\r\n        bytes memory _metadata\r\n    ) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(_recipient, _amount, _metadata);\r\n    }\r\n\r\n    function recipient(bytes calldata message) internal pure returns (bytes32) {\r\n        return bytes32(message[0:32]);\r\n    }\r\n\r\n    function amount(bytes calldata message) internal pure returns (uint256) {\r\n        return uint256(bytes32(message[32:64]));\r\n    }\r\n\r\n    // alias for ERC721\r\n    function tokenId(bytes calldata message) internal pure returns (uint256) {\r\n        return amount(message);\r\n    }\r\n\r\n    function metadata(\r\n        bytes calldata message\r\n    ) internal pure returns (bytes calldata) {\r\n        return message[64:];\r\n    }\r\n}\r\n\r\n/**\r\n * @title Hyperlane Token Router that extends Router with abstract token (ERC20/ERC721) remote transfer functionality.\r\n * @author Abacus Works\r\n */\r\nabstract contract TokenRouter is GasRouter {\r\n    using TypeCasts for bytes32;\r\n    using TypeCasts for address;\r\n    using TokenMessage for bytes;\r\n\r\n    /**\r\n     * @dev Emitted on `transferRemote` when a transfer message is dispatched.\r\n     * @param destination The identifier of the destination chain.\r\n     * @param recipient The address of the recipient on the destination chain.\r\n     * @param amount The amount of tokens burnt on the origin chain.\r\n     */\r\n    event SentTransferRemote(\r\n        uint32 indexed destination,\r\n        bytes32 indexed recipient,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on `_handle` when a transfer message is processed.\r\n     * @param origin The identifier of the origin chain.\r\n     * @param recipient The address of the recipient on the destination chain.\r\n     * @param amount The amount of tokens minted on the destination chain.\r\n     */\r\n    event ReceivedTransferRemote(\r\n        uint32 indexed origin,\r\n        bytes32 indexed recipient,\r\n        uint256 amount\r\n    );\r\n\r\n    constructor(address _mailbox) GasRouter(_mailbox) {}\r\n\r\n    /**\r\n     * @notice Transfers `_amountOrId` token to `_recipient` on `_destination` domain.\r\n     * @dev Delegates transfer logic to `_transferFromSender` implementation.\r\n     * @dev Emits `SentTransferRemote` event on the origin chain.\r\n     * @param _destination The identifier of the destination chain.\r\n     * @param _recipient The address of the recipient on the destination chain.\r\n     * @param _amountOrId The amount or identifier of tokens to be sent to the remote recipient.\r\n     * @return messageId The identifier of the dispatched message.\r\n     */\r\n    function transferRemote(\r\n        uint32 _destination,\r\n        bytes32 _recipient,\r\n        uint256 _amountOrId\r\n    ) external payable virtual returns (bytes32 messageId) {\r\n        return\r\n            _transferRemote(_destination, _recipient, _amountOrId, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `_amountOrId` token to `_recipient` on `_destination` domain.\r\n     * @dev Delegates transfer logic to `_transferFromSender` implementation.\r\n     * @dev Emits `SentTransferRemote` event on the origin chain.\r\n     * @param _destination The identifier of the destination chain.\r\n     * @param _recipient The address of the recipient on the destination chain.\r\n     * @param _amountOrId The amount or identifier of tokens to be sent to the remote recipient.\r\n     * @param _gasPayment The amount of native token to pay for interchain gas.\r\n     * @return messageId The identifier of the dispatched message.\r\n     */\r\n    function _transferRemote(\r\n        uint32 _destination,\r\n        bytes32 _recipient,\r\n        uint256 _amountOrId,\r\n        uint256 _gasPayment\r\n    ) internal returns (bytes32 messageId) {\r\n        bytes memory metadata = _transferFromSender(_amountOrId);\r\n        messageId = _dispatch(\r\n            _destination,\r\n            _gasPayment,\r\n            TokenMessage.format(_recipient, _amountOrId, metadata)\r\n        );\r\n        emit SentTransferRemote(_destination, _recipient, _amountOrId);\r\n    }\r\n\r\n    /**\r\n     * @dev Should transfer `_amountOrId` of tokens from `msg.sender` to this token router.\r\n     * @dev Called by `transferRemote` before message dispatch.\r\n     * @dev Optionally returns `metadata` associated with the transfer to be passed in message.\r\n     */\r\n    function _transferFromSender(\r\n        uint256 _amountOrId\r\n    ) internal virtual returns (bytes memory metadata);\r\n\r\n    /**\r\n     * @notice Returns the balance of `account` on this token router.\r\n     * @param account The address to query the balance of.\r\n     * @return The balance of `account`.\r\n     */\r\n    function balanceOf(address account) external virtual returns (uint256);\r\n\r\n    /**\r\n     * @dev Mints tokens to recipient when router receives transfer message.\r\n     * @dev Emits `ReceivedTransferRemote` event on the destination chain.\r\n     * @param _origin The identifier of the origin chain.\r\n     * @param _message The encoded remote transfer message containing the recipient address and amount.\r\n     */\r\n    function _handle(\r\n        uint32 _origin,\r\n        bytes32,\r\n        bytes calldata _message\r\n    ) internal virtual override {\r\n        bytes32 recipient = _message.recipient();\r\n        uint256 amount = _message.amount();\r\n        bytes calldata metadata = _message.metadata();\r\n        _transferTo(recipient.bytes32ToAddress(), amount, metadata);\r\n        emit ReceivedTransferRemote(_origin, recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Should transfer `_amountOrId` of tokens from this token router to `_recipient`.\r\n     * @dev Called by `handle` after message decoding.\r\n     * @dev Optionally handles `metadata` associated with transfer passed in message.\r\n     */\r\n    function _transferTo(\r\n        address _recipient,\r\n        uint256 _amountOrId,\r\n        bytes calldata metadata\r\n    ) internal virtual;\r\n}\r\n\r\n/**\r\n * @title Hyperlane Native Token Router that extends ERC20 with remote transfer functionality.\r\n * @author Abacus Works\r\n * @dev Supply on each chain is not constant but the aggregate supply across all chains is.\r\n */\r\ncontract HypNative is TokenRouter {\r\n    /**\r\n     * @dev Emitted when native tokens are donated to the contract.\r\n     * @param sender The address of the sender.\r\n     * @param amount The amount of native tokens donated.\r\n     */\r\n    event Donation(address indexed sender, uint256 amount);\r\n\r\n    constructor(address _mailbox) TokenRouter(_mailbox) {}\r\n\r\n    /**\r\n     * @inheritdoc TokenRouter\r\n     * @dev uses (`msg.value` - `_amount`) as interchain gas payment and `msg.sender` as refund address.\r\n     */\r\n    function transferRemote(\r\n        uint32 _destination,\r\n        bytes32 _recipient,\r\n        uint256 _amount\r\n    ) public payable virtual override returns (bytes32 messageId) {\r\n        require(msg.value >= _amount, \"Native: amount exceeds msg.value\");\r\n        uint256 gasPayment = msg.value - _amount;\r\n        return _transferRemote(_destination, _recipient, _amount, gasPayment);\r\n    }\r\n\r\n    function balanceOf(\r\n        address _account\r\n    ) external view override returns (uint256) {\r\n        return _account.balance;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc TokenRouter\r\n     * @dev No-op because native amount is transferred in `msg.value`\r\n     * @dev Compiler will not include this in the bytecode.\r\n     */\r\n    function _transferFromSender(\r\n        uint256\r\n    ) internal pure override returns (bytes memory) {\r\n        return bytes(\"\"); // no metadata\r\n    }\r\n\r\n    /**\r\n     * @dev Sends `_amount` of native token to `_recipient` balance.\r\n     * @inheritdoc TokenRouter\r\n     */\r\n    function _transferTo(\r\n        address _recipient,\r\n        uint256 _amount,\r\n        bytes calldata // no metadata\r\n    ) internal virtual override {\r\n        Address.sendValue(payable(_recipient), _amount);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Donation(msg.sender, msg.value);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mailbox\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Donation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"origin\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedTransferRemote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SentTransferRemote\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"destinationGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domains\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_router\",\"type\":\"bytes32\"}],\"name\":\"enrollRemoteRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_domains\",\"type\":\"uint32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_addresses\",\"type\":\"bytes32[]\"}],\"name\":\"enrollRemoteRouters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"handle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hook\",\"outputs\":[{\"internalType\":\"contract IPostDispatchHook\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainSecurityModule\",\"outputs\":[{\"internalType\":\"contract IInterchainSecurityModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mailbox\",\"outputs\":[{\"internalType\":\"contract IMailbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_destinationDomain\",\"type\":\"uint32\"}],\"name\":\"quoteGasPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasPayment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"routers\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setDestinationGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"internalType\":\"struct GasRouter.GasRouterConfig[]\",\"name\":\"gasConfigs\",\"type\":\"tuple[]\"}],\"name\":\"setDestinationGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hook\",\"type\":\"address\"}],\"name\":\"setHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"setInterchainSecurityModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferRemote\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"unenrollRemoteRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_domains\",\"type\":\"uint32[]\"}],\"name\":\"unenrollRemoteRouters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HypNative", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000fe8ba65dd05dde886a387d97efc95b736bb9c0ef", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f6235eba42cd965ec8797320b70fa3f71041a56ca31e8577e21f58323505f76e"}