{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PRBProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.18;\\n\\nimport { IPRBProxy } from \\\"./interfaces/IPRBProxy.sol\\\";\\nimport { IPRBProxyPlugin } from \\\"./interfaces/IPRBProxyPlugin.sol\\\";\\nimport { IPRBProxyRegistry } from \\\"./interfaces/IPRBProxyRegistry.sol\\\";\\nimport { PRBProxy } from \\\"./PRBProxy.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d  \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557   \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u255d \u2588\u2588\u2557   \u2588\u2588\u2551\\n\u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n\\n*/\\n\\n/// @title PRBProxyRegistry\\n/// @dev See the documentation in {IPRBProxyRegistry}.\\ncontract PRBProxyRegistry is IPRBProxyRegistry {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTANTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    string public constant override VERSION = \\\"4.0.1\\\";\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                USER-FACING STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    ConstructorParams public override constructorParams;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  INTERNAL STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    mapping(address owner => mapping(IPRBProxyPlugin plugin => bytes4[] methods)) internal _methods;\\n\\n    mapping(address owner => mapping(address envoy => mapping(address target => bool permission))) internal _permissions;\\n\\n    mapping(address owner => mapping(bytes4 method => IPRBProxyPlugin plugin)) internal _plugins;\\n\\n    mapping(address owner => IPRBProxy proxy) internal _proxies;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     MODIFIERS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Checks that the caller has a proxy.\\n    modifier onlyCallerWithProxy() {\\n        if (address(_proxies[msg.sender]) == address(0)) {\\n            revert PRBProxyRegistry_UserDoesNotHaveProxy(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /// @notice Check that the user does not have a proxy.\\n    modifier onlyNonProxyOwner(address user) {\\n        IPRBProxy proxy = _proxies[user];\\n        if (address(proxy) != address(0)) {\\n            revert PRBProxyRegistry_UserHasProxy(user, proxy);\\n        }\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                           USER-FACING CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function getMethodsByOwner(address owner, IPRBProxyPlugin plugin) external view returns (bytes4[] memory methods) {\\n        methods = _methods[owner][plugin];\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function getMethodsByProxy(\\n        IPRBProxy proxy,\\n        IPRBProxyPlugin plugin\\n    )\\n        external\\n        view\\n        returns (bytes4[] memory methods)\\n    {\\n        methods = _methods[proxy.owner()][plugin];\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function getPermissionByOwner(\\n        address owner,\\n        address envoy,\\n        address target\\n    )\\n        external\\n        view\\n        returns (bool permission)\\n    {\\n        permission = _permissions[owner][envoy][target];\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function getPermissionByProxy(\\n        IPRBProxy proxy,\\n        address envoy,\\n        address target\\n    )\\n        external\\n        view\\n        returns (bool permission)\\n    {\\n        permission = _permissions[proxy.owner()][envoy][target];\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function getPluginByOwner(address owner, bytes4 method) external view returns (IPRBProxyPlugin plugin) {\\n        plugin = _plugins[owner][method];\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function getPluginByProxy(IPRBProxy proxy, bytes4 method) external view returns (IPRBProxyPlugin plugin) {\\n        plugin = _plugins[proxy.owner()][method];\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function getProxy(address user) external view returns (IPRBProxy proxy) {\\n        proxy = _proxies[user];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                         USER-FACING NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function deploy() external override onlyNonProxyOwner(msg.sender) returns (IPRBProxy proxy) {\\n        proxy = _deploy({ owner: msg.sender, target: address(0), data: \\\"\\\" });\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function deployAndExecute(\\n        address target,\\n        bytes calldata data\\n    )\\n        external\\n        override\\n        onlyNonProxyOwner(msg.sender)\\n        returns (IPRBProxy proxy)\\n    {\\n        proxy = _deploy({ owner: msg.sender, target: target, data: data });\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function deployFor(address user) external override onlyNonProxyOwner(user) returns (IPRBProxy proxy) {\\n        proxy = _deploy({ owner: user, target: address(0), data: \\\"\\\" });\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function deployAndExecuteAndInstallPlugin(\\n        address target,\\n        bytes calldata data,\\n        IPRBProxyPlugin plugin\\n    )\\n        external\\n        override\\n        onlyNonProxyOwner(msg.sender)\\n        returns (IPRBProxy proxy)\\n    {\\n        proxy = _deploy({ owner: msg.sender, target: target, data: data });\\n        _installPlugin(plugin);\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function deployAndInstallPlugin(IPRBProxyPlugin plugin)\\n        external\\n        onlyNonProxyOwner(msg.sender)\\n        returns (IPRBProxy proxy)\\n    {\\n        proxy = _deploy({ owner: msg.sender, target: address(0), data: \\\"\\\" });\\n        _installPlugin(plugin);\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function installPlugin(IPRBProxyPlugin plugin) external override onlyCallerWithProxy {\\n        _installPlugin(plugin);\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function setPermission(address envoy, address target, bool permission) external override onlyCallerWithProxy {\\n        address owner = msg.sender;\\n        _permissions[owner][envoy][target] = permission;\\n        emit SetPermission(owner, _proxies[owner], envoy, target, permission);\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function uninstallPlugin(IPRBProxyPlugin plugin) external override onlyCallerWithProxy {\\n        // Retrieve the methods originally installed by this plugin.\\n        address owner = msg.sender;\\n        bytes4[] memory methods = _methods[owner][plugin];\\n\\n        // The plugin must be a known, previously installed plugin.\\n        uint256 length = methods.length;\\n        if (length == 0) {\\n            revert PRBProxyRegistry_PluginUnknown(plugin);\\n        }\\n\\n        // Uninstall every method in the list.\\n        for (uint256 i = 0; i < length;) {\\n            delete _plugins[owner][methods[i]];\\n            unchecked {\\n                i += 1;\\n            }\\n        }\\n\\n        // Remove the methods from the reverse mapping.\\n        delete _methods[owner][plugin];\\n\\n        // Log the plugin uninstallation.\\n        emit UninstallPlugin(owner, _proxies[owner], plugin, methods);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                          INTERNAL NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @dev See the documentation for the user-facing functions that call this internal function.\\n    function _deploy(address owner, address target, bytes memory data) internal returns (IPRBProxy proxy) {\\n        // Use the address of the owner as the CREATE2 salt.\\n        bytes32 salt = bytes32(abi.encodePacked(owner));\\n\\n        // Set the owner and empty out the target and the data to prevent reentrancy.\\n        constructorParams = ConstructorParams({ owner: owner, target: target, data: data });\\n\\n        // Deploy the proxy with CREATE2.\\n        proxy = new PRBProxy{ salt: salt }();\\n        delete constructorParams;\\n\\n        // Associate the owner and the proxy.\\n        _proxies[owner] = proxy;\\n\\n        // Log the creation of the proxy.\\n        emit DeployProxy({ operator: msg.sender, owner: owner, proxy: proxy });\\n    }\\n\\n    /// @dev See the documentation for the user-facing functions that call this internal function.\\n    function _installPlugin(IPRBProxyPlugin plugin) internal {\\n        // Retrieve the methods to install.\\n        bytes4[] memory methods = plugin.getMethods();\\n\\n        // The plugin must implement at least one method.\\n        uint256 length = methods.length;\\n        if (length == 0) {\\n            revert PRBProxyRegistry_PluginWithZeroMethods(plugin);\\n        }\\n\\n        // Install every method in the list.\\n        address owner = msg.sender;\\n        for (uint256 i = 0; i < length;) {\\n            // Check for collisions.\\n            bytes4 method = methods[i];\\n            if (address(_plugins[owner][method]) != address(0)) {\\n                revert PRBProxyRegistry_PluginMethodCollision({\\n                    currentPlugin: _plugins[owner][method],\\n                    newPlugin: plugin,\\n                    method: method\\n                });\\n            }\\n            _plugins[owner][method] = plugin;\\n            unchecked {\\n                i += 1;\\n            }\\n        }\\n\\n        // Set the methods in the reverse mapping.\\n        _methods[owner][plugin] = methods;\\n\\n        // Log the plugin installation.\\n        emit InstallPlugin(owner, _proxies[owner], plugin, methods);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPRBProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport { IPRBProxyPlugin } from \\\"./IPRBProxyPlugin.sol\\\";\\nimport { IPRBProxyRegistry } from \\\"./IPRBProxyRegistry.sol\\\";\\n\\n/// @title IPRBProxy\\n/// @notice Proxy contract to compose transactions on behalf of the owner.\\ninterface IPRBProxy {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when a target contract reverts without a specified reason.\\n    error PRBProxy_ExecutionReverted();\\n\\n    /// @notice Thrown when an unauthorized account tries to execute a delegate call.\\n    error PRBProxy_ExecutionUnauthorized(address owner, address caller, address target);\\n\\n    /// @notice Thrown when the fallback function fails to find an installed plugin for the method selector.\\n    error PRBProxy_PluginNotInstalledForMethod(address caller, address owner, bytes4 method);\\n\\n    /// @notice Thrown when a plugin execution reverts without a specified reason.\\n    error PRBProxy_PluginReverted(IPRBProxyPlugin plugin);\\n\\n    /// @notice Thrown when a non-contract address is passed as the target.\\n    error PRBProxy_TargetNotContract(address target);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when a target contract is delegate called.\\n    event Execute(address indexed target, bytes data, bytes response);\\n\\n    /// @notice Emitted when a plugin is run for a provided method.\\n    event RunPlugin(IPRBProxyPlugin indexed plugin, bytes data, bytes response);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The address of the owner account or contract, which controls the proxy.\\n    function owner() external view returns (address);\\n\\n    /// @notice The address of the registry that has deployed this proxy.\\n    function registry() external view returns (IPRBProxyRegistry);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                               NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Delegate calls to the provided target contract by forwarding the data. It returns the data it\\n    /// gets back, and bubbles up any potential revert.\\n    ///\\n    /// @dev Emits an {Execute} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must be either the owner or an envoy with permission.\\n    /// - `target` must be a contract.\\n    ///\\n    /// @param target The address of the target contract.\\n    /// @param data Function selector plus ABI encoded data.\\n    /// @return response The response received from the target contract, if any.\\n    function execute(address target, bytes calldata data) external payable returns (bytes memory response);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPRBProxyPlugin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// @title IPRBProxyPlugin\\n/// @notice Interface for plugin contracts that can be installed on a proxy.\\n/// @dev Plugins are contracts that enable the proxy to interact with and respond to calls from other contracts. These\\n/// plugins are run via the proxy's fallback function.\\n///\\n/// This interface is meant to be directly inherited by plugin implementations.\\ninterface IPRBProxyPlugin {\\n    /// @notice Retrieves the methods implemented by the plugin.\\n    /// @dev The registry pulls these methods when installing the plugin.\\n    ///\\n    /// Requirements:\\n    /// - The plugin must implement at least one method.\\n    ///\\n    /// @return methods The array of the methods implemented by the plugin.\\n    function getMethods() external returns (bytes4[] memory methods);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPRBProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport { IPRBProxy } from \\\"./IPRBProxy.sol\\\";\\nimport { IPRBProxyPlugin } from \\\"./IPRBProxyPlugin.sol\\\";\\n\\n/// @title IPRBProxyRegistry\\n/// @notice Deploys new proxies via CREATE2 and keeps a registry of owners to proxies. Proxies can only be deployed\\n/// once per owner, and they cannot be transferred. The registry also supports installing plugins, which are used\\n/// for extending the functionality of the proxy.\\ninterface IPRBProxyRegistry {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when trying to install a plugin that implements a method already implemented by another\\n    /// installed plugin.\\n    error PRBProxyRegistry_PluginMethodCollision(\\n        IPRBProxyPlugin currentPlugin, IPRBProxyPlugin newPlugin, bytes4 method\\n    );\\n\\n    /// @notice Thrown when trying to uninstall an unknown plugin.\\n    error PRBProxyRegistry_PluginUnknown(IPRBProxyPlugin plugin);\\n\\n    /// @notice Thrown when trying to install a plugin that doesn't implement any method.\\n    error PRBProxyRegistry_PluginWithZeroMethods(IPRBProxyPlugin plugin);\\n\\n    /// @notice Thrown when a function requires the user to have a proxy.\\n    error PRBProxyRegistry_UserDoesNotHaveProxy(address user);\\n\\n    /// @notice Thrown when a function requires the user to not have a proxy.\\n    error PRBProxyRegistry_UserHasProxy(address user, IPRBProxy proxy);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when a new proxy is deployed.\\n    event DeployProxy(address indexed operator, address indexed owner, IPRBProxy proxy);\\n\\n    /// @notice Emitted when a plugin is installed.\\n    event InstallPlugin(\\n        address indexed owner, IPRBProxy indexed proxy, IPRBProxyPlugin indexed plugin, bytes4[] methods\\n    );\\n\\n    /// @notice Emitted when an envoy's permission is updated.\\n    event SetPermission(\\n        address indexed owner, IPRBProxy indexed proxy, address indexed envoy, address target, bool newPermission\\n    );\\n\\n    /// @notice Emitted when a plugin is uninstalled.\\n    event UninstallPlugin(\\n        address indexed owner, IPRBProxy indexed proxy, IPRBProxyPlugin indexed plugin, bytes4[] methods\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      STRUCTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @param owner The address of the user who will own the proxy.\\n    /// @param target The address of the target to delegate call to. Can be set to zero.\\n    /// @param data The call data to be passed to the target. Can be set to zero.\\n    struct ConstructorParams {\\n        address owner;\\n        address target;\\n        bytes data;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The release version of the proxy system, which applies to both the registry and deployed proxies.\\n    /// @dev This is stored in the registry rather than the proxy to save gas for end users.\\n    function VERSION() external view returns (string memory);\\n\\n    /// @notice The parameters used in constructing the proxy, which the registry sets transiently during proxy\\n    /// deployment.\\n    /// @dev The proxy constructor fetches these parameters.\\n    function constructorParams() external view returns (address owner, address target, bytes memory data);\\n\\n    /// @notice Retrieves the list of installed methods for the provided plugin.\\n    /// @dev An empty array is returned if the plugin is unknown.\\n    /// @param owner The proxy owner for the query.\\n    /// @param plugin The plugin for the query.\\n    function getMethodsByOwner(address owner, IPRBProxyPlugin plugin) external view returns (bytes4[] memory methods);\\n\\n    /// @notice Retrieves the list of installed methods for the provided plugin.\\n    /// @dev An empty array is returned if the plugin is unknown.\\n    /// @param proxy The proxy for the query.\\n    /// @param plugin The plugin for the query.\\n    function getMethodsByProxy(\\n        IPRBProxy proxy,\\n        IPRBProxyPlugin plugin\\n    )\\n        external\\n        view\\n        returns (bytes4[] memory methods);\\n\\n    /// @notice Retrieves a boolean flag that indicates whether the provided envoy has permission to call the provided\\n    /// target.\\n    /// @param owner The proxy owner for the query.\\n    /// @param envoy The address checked for permission to call the target.\\n    /// @param target The address of the target.\\n    function getPermissionByOwner(\\n        address owner,\\n        address envoy,\\n        address target\\n    )\\n        external\\n        view\\n        returns (bool permission);\\n\\n    /// @notice Retrieves a boolean flag that indicates whether the provided envoy has permission to call the provided\\n    /// target.\\n    /// @param proxy The proxy for the query.\\n    /// @param envoy The address checked for permission to call the target.\\n    /// @param target The address of the target.\\n    function getPermissionByProxy(\\n        IPRBProxy proxy,\\n        address envoy,\\n        address target\\n    )\\n        external\\n        view\\n        returns (bool permission);\\n\\n    /// @notice Retrieves the address of the plugin installed for the provided method selector.\\n    /// @dev The zero address is returned if no plugin is installed.\\n    /// @param owner The proxy owner for the query.\\n    /// @param method The method selector for the query.\\n    function getPluginByOwner(address owner, bytes4 method) external view returns (IPRBProxyPlugin plugin);\\n\\n    /// @notice Retrieves the address of the plugin installed for the provided method selector.\\n    /// @dev The zero address is returned if no plugin is installed.\\n    /// @param proxy The proxy for the query.\\n    /// @param method The method selector for the query.\\n    function getPluginByProxy(IPRBProxy proxy, bytes4 method) external view returns (IPRBProxyPlugin plugin);\\n\\n    /// @notice Retrieves the proxy for the provided user.\\n    /// @param user The user address for the query.\\n    function getProxy(address user) external view returns (IPRBProxy proxy);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                               NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Deploys a new proxy for the caller.\\n    ///\\n    /// @dev Emits a {DeployProxy} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must not have a proxy.\\n    ///\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deploy() external returns (IPRBProxy proxy);\\n\\n    /// @notice This function performs two actions:\\n    /// 1. Deploys a new proxy for the caller\\n    /// 2. Delegate calls to the provided target, returning the data it gets back, and bubbling up any potential revert.\\n    ///\\n    /// @dev Emits a {DeployProxy} and {Execute} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must not have a proxy.\\n    /// - `target` must be a contract.\\n    ///\\n    /// @param target The address of the target.\\n    /// @param data Function selector plus ABI-encoded data.\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deployAndExecute(address target, bytes calldata data) external returns (IPRBProxy proxy);\\n\\n    /// @notice This function performs three actions:\\n    /// 1. Deploys a new proxy for the caller\\n    /// 2. Delegate calls to the provided target, returning the data it gets back, and bubbling up any potential revert.\\n    /// 3. Installs the provided plugin on the newly deployed proxy.\\n    ///\\n    /// @dev Emits a {DeployProxy}, {Execute}, and {InstallPlugin} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must not have a proxy.\\n    /// - See the requirements in `installPlugin`.\\n    /// - See the requirements in `execute`.\\n    ///\\n    /// @param target The address of the target.\\n    /// @param data Function selector plus ABI-encoded data.\\n    /// @param plugin The address of the plugin to install.\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deployAndExecuteAndInstallPlugin(\\n        address target,\\n        bytes calldata data,\\n        IPRBProxyPlugin plugin\\n    )\\n        external\\n        returns (IPRBProxy proxy);\\n\\n    /// @notice This function performs two actions:\\n    /// 1. Deploys a new proxy for the caller.\\n    /// 2. Installs the provided plugin on the newly deployed proxy.\\n    ///\\n    /// @dev Emits a {DeployProxy} and {InstallPlugin} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must not have a proxy.\\n    /// - See the requirements in `installPlugin`.\\n    ///\\n    /// @param plugin The address of the plugin to install.\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deployAndInstallPlugin(IPRBProxyPlugin plugin) external returns (IPRBProxy proxy);\\n\\n    /// @notice Deploys a new proxy for the provided user.\\n    ///\\n    /// @dev Emits a {DeployProxy} event.\\n    ///\\n    /// Requirements:\\n    /// - The user must not have a proxy already.\\n    ///\\n    /// @param user The address that will own the proxy.\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deployFor(address user) external returns (IPRBProxy proxy);\\n\\n    /// @notice Installs the provided plugin on the caller's proxy, and saves the list of methods implemented by the\\n    /// plugin so that they can be referenced later.\\n    ///\\n    /// @dev Emits an {InstallPlugin} event.\\n    ///\\n    /// Notes:\\n    /// - Installing a plugin is a potentially dangerous operation, because anyone can run the plugin.\\n    /// - Plugin methods that have the same selectors as {IPRBProxy.execute}, {IPRBProxy.owner}, and\\n    /// {IPRBProxy.registry} can be installed, but they can never be run.\\n    ///\\n    /// Requirements:\\n    /// - The caller must have a proxy.\\n    /// - The plugin must have at least one implemented method.\\n    /// - There must be no method collision with any other plugin installed by the caller.\\n    ///\\n    /// @param plugin The address of the plugin to install.\\n    function installPlugin(IPRBProxyPlugin plugin) external;\\n\\n    /// @notice Gives or takes a permission from an envoy to call the provided target and function selector\\n    /// on behalf of the caller's proxy.\\n    ///\\n    /// @dev Emits a {SetPermission} event.\\n    ///\\n    /// Notes:\\n    /// - It is not an error to set the same permission.\\n    ///\\n    /// Requirements:\\n    /// - The caller must have a proxy.\\n    ///\\n    /// @param envoy The address of the account the caller is giving or taking permission from.\\n    /// @param target The address of the target.\\n    /// @param permission The boolean permission to set.\\n    function setPermission(address envoy, address target, bool permission) external;\\n\\n    /// @notice Uninstalls the plugin from the caller's proxy, and removes the list of methods originally implemented by\\n    /// the plugin.\\n    ///\\n    /// @dev Emits an {UninstallPlugin} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must have a proxy.\\n    /// - The plugin must be a known, previously installed plugin.\\n    ///\\n    /// @param plugin The address of the plugin to uninstall.\\n    function uninstallPlugin(IPRBProxyPlugin plugin) external;\\n}\\n\"\r\n    },\r\n    \"src/PRBProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.18;\\n\\nimport { IPRBProxy } from \\\"./interfaces/IPRBProxy.sol\\\";\\nimport { IPRBProxyPlugin } from \\\"./interfaces/IPRBProxyPlugin.sol\\\";\\nimport { IPRBProxyRegistry } from \\\"./interfaces/IPRBProxyRegistry.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d  \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557   \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u255d \u2588\u2588\u2557   \u2588\u2588\u2551\\n\u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n\\n*/\\n\\n/// @title PRBProxy\\n/// @dev See the documentation in {IPRBProxy}.\\ncontract PRBProxy is IPRBProxy {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTANTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IPRBProxy\\n    address public immutable override owner;\\n\\n    /// @inheritdoc IPRBProxy\\n    IPRBProxyRegistry public immutable override registry;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Creates the proxy by fetching the constructor params from the registry, optionally delegate calling\\n    /// to a target contract if one is provided.\\n    /// @dev The rationale of this approach is to have the proxy's CREATE2 address not depend on any constructor params.\\n    constructor() {\\n        registry = IPRBProxyRegistry(msg.sender);\\n        (address owner_, address target, bytes memory data) = registry.constructorParams();\\n        owner = owner_;\\n        if (target != address(0)) {\\n            _execute(target, data);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FALLBACK FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Fallback function used to run plugins.\\n    /// @dev WARNING: anyone can call this function and thus run any installed plugin.\\n    fallback(bytes calldata data) external payable returns (bytes memory response) {\\n        // Check if the function selector points to a known installed plugin.\\n        IPRBProxyPlugin plugin = registry.getPluginByOwner({ owner: owner, method: msg.sig });\\n        if (address(plugin) == address(0)) {\\n            revert PRBProxy_PluginNotInstalledForMethod({ caller: msg.sender, owner: owner, method: msg.sig });\\n        }\\n\\n        // Delegate call to the plugin.\\n        bool success;\\n        (success, response) = address(plugin).delegatecall(data);\\n\\n        // Log the plugin run.\\n        emit RunPlugin(plugin, data, response);\\n\\n        // Check if the call was successful or not.\\n        if (!success) {\\n            // If there is return data, the delegate call reverted with a reason or a custom error, which we bubble up.\\n            if (response.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(response)\\n                    revert(add(32, response), returndata_size)\\n                }\\n            } else {\\n                revert PRBProxy_PluginReverted(plugin);\\n            }\\n        }\\n    }\\n\\n    /// @dev Called when `msg.value` is not zero and the call data is empty.\\n    receive() external payable { }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                         USER-FACING NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IPRBProxy\\n    function execute(address target, bytes calldata data) external payable override returns (bytes memory response) {\\n        // Check that the caller is either the owner or an envoy with permission.\\n        if (owner != msg.sender) {\\n            bool permission = registry.getPermissionByOwner({ owner: owner, envoy: msg.sender, target: target });\\n            if (!permission) {\\n                revert PRBProxy_ExecutionUnauthorized({ owner: owner, caller: msg.sender, target: target });\\n            }\\n        }\\n\\n        // Delegate call to the target contract, and handle the response.\\n        response = _execute(target, data);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                          INTERNAL NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Executes a DELEGATECALL to the provided target with the provided data.\\n    /// @dev Shared logic between the constructor and the `execute` function.\\n    function _execute(address target, bytes memory data) internal returns (bytes memory response) {\\n        // Check that the target is a contract.\\n        if (target.code.length == 0) {\\n            revert PRBProxy_TargetNotContract(target);\\n        }\\n\\n        // Delegate call to the target contract.\\n        bool success;\\n        (success, response) = target.delegatecall(data);\\n\\n        // Log the execution.\\n        emit Execute(target, data, response);\\n\\n        // Check if the call was successful or not.\\n        if (!success) {\\n            // If there is return data, the delegate call reverted with a reason or a custom error, which we bubble up.\\n            if (response.length > 0) {\\n                assembly {\\n                    // The length of the data is at `response`, while the actual data is at `response + 32`.\\n                    let returndata_size := mload(response)\\n                    revert(add(response, 32), returndata_size)\\n                }\\n            } else {\\n                revert PRBProxy_ExecutionReverted();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"prb-test/=lib/prb-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"currentPlugin\",\"type\":\"address\"},{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"newPlugin\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"method\",\"type\":\"bytes4\"}],\"name\":\"PRBProxyRegistry_PluginMethodCollision\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"PRBProxyRegistry_PluginUnknown\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"PRBProxyRegistry_PluginWithZeroMethods\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"PRBProxyRegistry_UserDoesNotHaveProxy\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"PRBProxyRegistry_UserHasProxy\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"DeployProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"methods\",\"type\":\"bytes4[]\"}],\"name\":\"InstallPlugin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"envoy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newPermission\",\"type\":\"bool\"}],\"name\":\"SetPermission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"methods\",\"type\":\"bytes4[]\"}],\"name\":\"UninstallPlugin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"constructorParams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deployAndExecute\",\"outputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"deployAndExecuteAndInstallPlugin\",\"outputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"deployAndInstallPlugin\",\"outputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"deployFor\",\"outputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"getMethodsByOwner\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"methods\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"getMethodsByProxy\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"methods\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"envoy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"getPermissionByOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"permission\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"envoy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"getPermissionByProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"permission\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"method\",\"type\":\"bytes4\"}],\"name\":\"getPluginByOwner\",\"outputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"method\",\"type\":\"bytes4\"}],\"name\":\"getPluginByProxy\",\"outputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getProxy\",\"outputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"installPlugin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"envoy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"permission\",\"type\":\"bool\"}],\"name\":\"setPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"uninstallPlugin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PRBProxyRegistry", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}