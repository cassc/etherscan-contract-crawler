{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ImpossibleERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport './libraries/SafeMath.sol';\\n\\nimport './interfaces/IImpossibleERC20.sol';\\nimport './interfaces/IERC20.sol';\\n\\ncontract ImpossibleERC20 is IImpossibleERC20 {\\n    using SafeMath for uint256;\\n\\n    string public override name = 'Impossible Swap LPs';\\n    string public override symbol = 'IF-LP';\\n    uint8 public constant override decimals = 18;\\n    uint256 public override totalSupply;\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant override PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public override nonces;\\n\\n    constructor() {\\n        // Initializes a placeholder name/domain separator for testing permit typehashs\\n        _setupDomainSeparator();\\n    }\\n\\n    function _initBetterDesc(address _token0, address _token1) internal {\\n        // This sets name/symbol to include tokens in LP token\\n        string memory desc = string(abi.encodePacked(IERC20(_token0).symbol(), '/', IERC20(_token1).symbol()));\\n        name = string(abi.encodePacked('Impossible Swap LPs: ', desc));\\n        symbol = string(abi.encodePacked('IF-LP: ', desc));\\n        _setupDomainSeparator();\\n    }\\n\\n    function _setupDomainSeparator() internal {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name)),\\n                keccak256(bytes('1')),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(deadline >= block.timestamp, 'IF: EXPIRED');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'IF: INVALID_SIGNATURE');\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, 'SafeMath: division by zero');\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImpossibleERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IImpossibleERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/test/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport '../ImpossibleERC20.sol';\\n\\ncontract ERC20 is ImpossibleERC20 {\\n    constructor(uint256 _totalSupply) {\\n        _mint(msg.sender, _totalSupply);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ImpossiblePair.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport './ImpossibleERC20.sol';\\n\\nimport './libraries/Math.sol';\\nimport './libraries/ReentrancyGuard.sol';\\n\\nimport './interfaces/IImpossiblePair.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IImpossibleSwapFactory.sol';\\nimport './interfaces/IImpossibleCallee.sol';\\n\\n/**\\n    @title  Pair contract for Impossible Swap V3\\n    @author Impossible Finance\\n    @notice This factory builds upon basic Uni V2 Pair by adding xybk\\n            invariant, ability to switch between invariants/boost levels,\\n            and ability to set asymmetrical tuning.\\n    @dev    See documentation at: https://docs.impossible.finance/impossible-swap/overview\\n*/\\n\\ncontract ImpossiblePair is IImpossiblePair, ImpossibleERC20, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    uint256 public constant override MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\n    /**\\n     @dev Timestamps, not block numbers\\n    */\\n    uint256 private constant THIRTY_MINS = 108000;\\n    uint32 private constant TWO_WEEKS = 1209600;\\n    uint32 private constant ONE_DAY = 86400;\\n\\n    /**\\n     @dev tradeFee is fee collected per swap in basis points. Init at 30bp.\\n    */\\n    uint16 private tradeFee = 30;\\n\\n    /**\\n     @dev tradeState Tracks what directional trades are allowed for this pair.\\n    */\\n    TradeState private tradeState;\\n\\n    bool private isXybk;\\n\\n    address public override factory;\\n    address public override token0;\\n    address public override token1;\\n    address public router;\\n    address public routerExtension;\\n\\n    uint128 private reserve0;\\n    uint128 private reserve1;\\n\\n    uint256 public kLast;\\n\\n    /**\\n     @dev These are the variables for boost.\\n     @dev Boosts in practice are a function of oldBoost, newBoost, startBlock and endBlock\\n     @dev We linearly interpolate between oldBoost and newBoost over the blocks\\n     @dev Note that governance being able to instantly change boosts is dangerous\\n     @dev Boost0 applies when pool balance0 >= balance1 (when token1 is the more expensive token)\\n     @dev Boost1 applies when pool balance1 > balance0 (when token0 is the more expensive token)\\n    */\\n    uint32 private oldBoost0 = 1;\\n    uint32 private oldBoost1 = 1;\\n    uint32 private newBoost0 = 1;\\n    uint32 private newBoost1 = 1;\\n    uint32 private currBoost0 = 1;\\n    uint32 private currBoost1 = 1;\\n\\n    /**\\n     @dev BSC mines 10m blocks a year. uint32 will last 400 years before overflowing\\n    */\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    /**\\n     @dev withdrawalFeeRatio is the fee collected on burn. Init as 1/201=0.4795% fee (if feeOn)\\n    */\\n    uint256 public withdrawalFeeRatio = 201; //\\n\\n    /**\\n     @dev Delay sets the duration for boost changes over time. Init as 1 day\\n     @dev In test environment, set to 50 blocks.\\n    */\\n    uint256 public override delay = ONE_DAY;\\n\\n    modifier onlyIFRouter() {\\n        require(msg.sender == router || msg.sender == routerExtension, 'IF: FORBIDDEN');\\n        _;\\n    }\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == IImpossibleSwapFactory(factory).governance(), 'IF: FORBIDDEN');\\n        _;\\n    }\\n\\n    /**\\n     @notice Gets the fee per swap in basis points, as well as if this pair is uni or xybk\\n     @return _tradeFee Fee per swap in basis points\\n     @return _tradeState What trades are allowed for this pair\\n     @return _isXybk Boolean if this swap is using uniswap or xybk\\n    */\\n    function getPairSettings()\\n        external\\n        view\\n        override\\n        returns (\\n            uint16 _tradeFee,\\n            TradeState _tradeState,\\n            bool _isXybk\\n        )\\n    {\\n        _tradeFee = tradeFee;\\n        _tradeState = tradeState;\\n        _isXybk = isXybk;\\n    }\\n\\n    /**\\n     @notice Gets the reserves in the pair contract\\n     @return _reserve0 Reserve amount of token0 in the pair\\n     @return _reserve1 Reserve amount of token1 in the pair\\n    */\\n    function getReserves() public view override returns (uint256 _reserve0, uint256 _reserve1) {\\n        _reserve0 = uint256(reserve0);\\n        _reserve1 = uint256(reserve1);\\n    }\\n\\n    /**\\n     @notice Getter for the stored boost state\\n     @dev Helper function for internal use. If uni invariant, all boosts=1\\n     @return _newBoost0 New boost0 value\\n     @return _newBoost1 New boost1 value\\n     @return _oldBoost0 Old boost0 value\\n     @return _oldBoost1 Old boost1 value\\n    */\\n    function getBoost()\\n        internal\\n        view\\n        returns (\\n            uint32 _newBoost0,\\n            uint32 _newBoost1,\\n            uint32 _oldBoost0,\\n            uint32 _oldBoost1,\\n            uint32 _currBoost0,\\n            uint32 _currBoost1\\n        )\\n    {\\n        _newBoost0 = newBoost0;\\n        _newBoost1 = newBoost1;\\n        _oldBoost0 = oldBoost0;\\n        _oldBoost1 = oldBoost1;\\n        _currBoost0 = currBoost0;\\n        _currBoost1 = currBoost1;\\n    }\\n\\n    /**\\n     @notice Helper function to calculate a linearly interpolated boost\\n     @dev Calculations: old + |new - old| * (curr-start)/end-start\\n     @param oldBst The old boost\\n     @param newBst The new boost\\n     @param end The endblock which linear interpolation ends at\\n     @return uint256 Linearly interpolated boost value\\n    */\\n    function linInterpolate(\\n        uint32 oldBst,\\n        uint32 newBst,\\n        uint256 end\\n    ) internal view returns (uint256) {\\n        uint256 start = startTime;\\n        if (newBst > oldBst) {\\n            /// old + diff * (curr-start) / (end-start)\\n            return\\n                uint256(oldBst).add(\\n                    (uint256(newBst).sub(uint256(oldBst))).mul(block.timestamp.sub(start)).div(end.sub(start))\\n                );\\n        } else {\\n            /// old - diff * (curr-start) / (end-start)\\n            return\\n                uint256(oldBst).sub(\\n                    (uint256(oldBst).sub(uint256(newBst))).mul(block.timestamp.sub(start)).div(end.sub(start))\\n                );\\n        }\\n    }\\n\\n    /**\\n     @notice Function to get/calculate actual boosts in the system\\n     @dev If block.timestamp > endBlock, just return new boosts\\n     @return _boost0 The actual boost0 value\\n     @return _boost1 The actual boost1 value\\n    */\\n    function calcBoost() public view override returns (uint256 _boost0, uint256 _boost1) {\\n        uint256 _endTime = endTime;\\n        if (block.timestamp >= _endTime) {\\n            (uint32 _newBoost0, uint32 _newBoost1, , , , ) = getBoost();\\n            _boost0 = uint256(_newBoost0);\\n            _boost1 = uint256(_newBoost1);\\n        } else {\\n            (\\n                uint32 _newBoost0,\\n                uint32 _newBoost1,\\n                uint32 _oldBoost0,\\n                uint32 _oldBoost1,\\n                uint32 _currBoost0,\\n                uint32 _currBoost1\\n            ) = getBoost();\\n            _boost0 = linInterpolate(_oldBoost0, _newBoost0, _endTime);\\n            _boost1 = linInterpolate(_oldBoost1, _newBoost1, _endTime);\\n            if (xybkComputeK(_boost0, _boost1) < kLast) {\\n                _boost0 = _currBoost0;\\n                _boost1 = _currBoost1;\\n            }\\n        }\\n    }\\n\\n    function calcBoostWithUpdate() internal returns (uint256 _boost0, uint256 _boost1) {\\n        (_boost0, _boost1) = calcBoost();\\n        currBoost0 = uint32(_boost0);\\n        currBoost1 = uint32(_boost1);\\n    }\\n\\n    /**\\n     @notice Safe transfer implementation for tokens\\n     @dev Requires the transfer to succeed and return either null or True\\n     @param token The token to transfer\\n     @param to The address to transfer to\\n     @param value The amount of tokens to transfer\\n    */\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'IF: TRANSFER_FAILED');\\n    }\\n\\n    /**\\n     @notice Switches pool from uniswap invariant to xybk invariant\\n     @dev Can only be called by IF governance\\n     @dev Requires the pool to be uniswap invariant currently\\n     @param _newBoost0 The new boost0\\n     @param _newBoost1 The new boost1\\n    */\\n    function makeXybk(uint32 _newBoost0, uint32 _newBoost1) external onlyGovernance nonReentrant {\\n        require(!isXybk, 'IF: IS_ALREADY_XYBK');\\n        _updateBoost(_newBoost0, _newBoost1);\\n        isXybk = true;\\n        emit ChangeInvariant(isXybk, _newBoost0, _newBoost1);\\n    }\\n\\n    /**\\n     @notice Switches pool from xybk invariant to uniswap invariant\\n     @dev Can only be called by IF governance\\n     @dev Requires the pool to be xybk invariant currently\\n    */\\n    function makeUni() external onlyGovernance nonReentrant {\\n        require(isXybk, 'IF: IS_ALREADY_UNI');\\n        require(block.timestamp >= endTime, 'IF: BOOST_ALREADY_CHANGING');\\n        require(newBoost0 == 1 && newBoost1 == 1, 'IF: INVALID_BOOST');\\n        isXybk = false;\\n        oldBoost0 = 1; // Set boost to 1\\n        oldBoost1 = 1; // xybk with boost=1 is just xy=k formula\\n        emit ChangeInvariant(isXybk, newBoost0, newBoost1);\\n    }\\n\\n    /**\\n     @notice Setter function for trade fee per swap\\n     @dev Can only be called by IF governance\\n     @dev uint8 fee means 255 basis points max, or max trade fee of 2.56%\\n     @dev uint8 type means fee cannot be negative\\n     @param _newFee The new trade fee collected per swap, in basis points\\n    */\\n    function updateTradeFees(uint8 _newFee) external onlyGovernance {\\n        uint16 _oldFee = tradeFee;\\n        tradeFee = uint16(_newFee);\\n        emit UpdatedTradeFees(_oldFee, _newFee);\\n    }\\n\\n    /**\\n     @notice Setter function for time delay for boost changes\\n     @dev Can only be called by IF governance\\n     @dev Delay must be between 30 minutes and 2 weeks\\n     @param _newDelay The new time delay in seconds\\n    */\\n    function updateDelay(uint256 _newDelay) external onlyGovernance {\\n        require(_newDelay >= THIRTY_MINS && delay <= TWO_WEEKS, 'IF: INVALID_DELAY');\\n        uint256 _oldDelay = delay;\\n        delay = _newDelay;\\n        emit UpdatedDelay(_oldDelay, _newDelay);\\n    }\\n\\n    /**\\n     @notice Setter function for trade state for this pair\\n     @dev Can only be called by IF governance\\n     @param _tradeState See line 45 for TradeState enum settings\\n    */\\n    function updateTradeState(TradeState _tradeState) external onlyGovernance nonReentrant {\\n        require(isXybk, 'IF: IS_CURRENTLY_UNI');\\n        tradeState = _tradeState;\\n        emit UpdatedTradeState(_tradeState);\\n    }\\n\\n    /**\\n     @notice Setter function for pool boost state\\n     @dev Can only be called by IF governance\\n     @dev Pool has to be using xybk invariant to update boost\\n     @param _newBoost0 The new boost0\\n     @param _newBoost1 The new boost1\\n    */\\n    function updateBoost(uint32 _newBoost0, uint32 _newBoost1) external onlyGovernance nonReentrant {\\n        require(isXybk, 'IF: IS_CURRENTLY_UNI');\\n        _updateBoost(_newBoost0, _newBoost1);\\n    }\\n\\n    /**\\n     @notice Internal helper function to change boosts\\n     @dev _newBoost0 and _newBoost1 have to be between 1 and 1000000\\n     @dev Pool cannot already have changing boosts\\n     @param _newBoost0 The new boost0\\n     @param _newBoost1 The new boost1\\n    */\\n    function _updateBoost(uint32 _newBoost0, uint32 _newBoost1) internal {\\n        require(\\n            _newBoost0 >= 1 && _newBoost1 >= 1 && _newBoost0 <= 1000000 && _newBoost1 <= 1000000,\\n            'IF: INVALID_BOOST'\\n        );\\n        uint256 _blockTimestamp = block.timestamp;\\n        require(_blockTimestamp >= endTime, 'IF: BOOST_ALREADY_CHANGING');\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves();\\n        _mintFee(_reserve0, _reserve1);\\n        oldBoost0 = newBoost0;\\n        oldBoost1 = newBoost1;\\n        newBoost0 = _newBoost0;\\n        newBoost1 = _newBoost1;\\n        startTime = _blockTimestamp;\\n        endTime = _blockTimestamp + delay;\\n        emit UpdatedBoost(oldBoost0, oldBoost1, newBoost0, newBoost1, startTime, endTime);\\n    }\\n\\n    /**\\n     @notice Setter function for the withdrawal fee that goes to Impossible per burn\\n     @dev Can only be called by IF governance\\n     @dev Fee is 1/_newFeeRatio. So <1% is 1/(>=100)\\n     @param _newFeeRatio The new fee ratio\\n    */\\n    function updateWithdrawalFeeRatio(uint256 _newFeeRatio) external onlyGovernance {\\n        require(_newFeeRatio >= 100, 'IF: INVALID_FEE'); // capped at 1%\\n        uint256 _oldFeeRatio = withdrawalFeeRatio;\\n        withdrawalFeeRatio = _newFeeRatio;\\n        emit UpdatedWithdrawalFeeRatio(_oldFeeRatio, _newFeeRatio);\\n    }\\n\\n    /**\\n     @notice Constructor function for pair address\\n     @dev For pairs associated with IF swap, msg.sender is always the factory\\n    */\\n    constructor() {\\n        factory = msg.sender;\\n    }\\n\\n    /**\\n     @notice Initialization function by factory on deployment\\n     @dev Can only be called by factory, and will only be called once\\n     @dev _initBetterDesc adds token0/token1 symbols to ERC20 LP name, symbol\\n     @param _token0 Address of token0 in pair\\n     @param _token0 Address of token1 in pair\\n     @param _router Address of trusted IF router\\n    */\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _router,\\n        address _routerExtension\\n    ) external override {\\n        require(msg.sender == factory, 'IF: FORBIDDEN');\\n        router = _router;\\n        routerExtension = _routerExtension;\\n        token0 = _token0;\\n        token1 = _token1;\\n        _initBetterDesc(_token0, _token1);\\n    }\\n\\n    /**\\n     @notice Updates reserve state in pair\\n     @dev No TWAP/oracle functionality\\n     @param balance0 The new balance for token0\\n     @param balance1 The new balance for token1\\n    */\\n    function _update(uint256 balance0, uint256 balance1) private {\\n        reserve0 = uint128(balance0);\\n        reserve1 = uint128(balance1);\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    /**\\n     @notice Mints fee to IF governance multisig treasury\\n     @dev If feeOn, mint liquidity equal to 4/5th of growth in sqrt(K)\\n     @param _reserve0 The latest balance for token0 for fee calculations\\n     @param _reserve1 The latest balance for token1 for fee calculations\\n     @return feeOn If the mint/burn fee is turned on in this pair\\n    */\\n    function _mintFee(uint256 _reserve0, uint256 _reserve1) private returns (bool feeOn) {\\n        address feeTo = IImpossibleSwapFactory(factory).feeTo();\\n        feeOn = feeTo != address(0);\\n        uint256 oldK = kLast; // gas savings\\n        if (feeOn) {\\n            if (oldK != 0) {\\n                (uint256 _boost0, uint256 _boost1) = calcBoostWithUpdate();\\n                uint256 newRootK = isXybk\\n                    ? Math.sqrt(xybkComputeK(_boost0, _boost1))\\n                    : Math.sqrt(_reserve0.mul(_reserve1));\\n                uint256 oldRootK = Math.sqrt(oldK);\\n                if (newRootK > oldRootK) {\\n                    uint256 numerator = totalSupply.mul(newRootK.sub(oldRootK)).mul(4);\\n                    uint256 denominator = newRootK.add(oldRootK.mul(4));\\n                    uint256 liquidity = numerator / denominator;\\n                    if (liquidity > 0) _mint(feeTo, liquidity);\\n                }\\n            }\\n        } else if (oldK != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    /**\\n     @notice Mints LP tokens based on sent underlying tokens. Underlying tokens must already be sent to contract\\n     @dev Function should be called from IF router unless you know what you're doing\\n     @dev Openzeppelin reentrancy guards are used\\n     @dev First mint must have both token0 and token1. \\n     @param to The address to mint LP tokens to\\n     @return liquidity The amount of LP tokens minted\\n    */\\n    function mint(address to) external override nonReentrant returns (uint256 liquidity) {\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n        uint256 amount0 = balance0.sub(_reserve0);\\n        uint256 amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidity = Math.min(\\n                _reserve0 > 0 ? amount0.mul(_totalSupply) / _reserve0 : uint256(-1),\\n                _reserve1 > 0 ? amount1.mul(_totalSupply) / _reserve1 : uint256(-1)\\n            );\\n        }\\n        require(liquidity > 0, 'IF: INSUFFICIENT_LIQUIDITY_MINTED');\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1);\\n        (uint256 _boost0, uint256 _boost1) = calcBoostWithUpdate();\\n        if (feeOn) kLast = isXybk ? xybkComputeK(_boost0, _boost1) : balance0.mul(balance1);\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    /**\\n     @notice Burns LP tokens and returns underlying tokens. LP tokens must already be sent to contract\\n     @dev Function should be called from IF router unless you know what you're doing\\n     @dev Openzeppelin reentrancy guards are used\\n     @param to The address to send underlying tokens to\\n     @return amount0 The amount of token0's sent\\n     @return amount1 The amount of token1's sent\\n    */\\n    function burn(address to) external override nonReentrant returns (uint256 amount0, uint256 amount1) {\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        {\\n            uint256 _totalSupply = totalSupply;\\n            amount0 = liquidity.mul(balance0) / _totalSupply;\\n            amount1 = liquidity.mul(balance1) / _totalSupply;\\n            require(amount0 > 0 || amount1 > 0, 'IF: INSUFFICIENT_LIQUIDITY_BURNED');\\n\\n            address _feeTo = IImpossibleSwapFactory(factory).feeTo();\\n            // Burning fees are paid if burn tx doesnt originate from not IF fee collector\\n            if (feeOn && tx.origin != _feeTo) {\\n                uint256 _feeRatio = withdrawalFeeRatio; // default is 1/201 ~= 0.4975%\\n                amount0 -= amount0.div(_feeRatio);\\n                amount1 -= amount1.div(_feeRatio);\\n                // Transfers withdrawalFee of LP tokens to IF feeTo\\n                uint256 transferAmount = liquidity.div(_feeRatio);\\n                _safeTransfer(address(this), IImpossibleSwapFactory(factory).feeTo(), transferAmount);\\n                _burn(address(this), liquidity.sub(transferAmount));\\n            } else {\\n                _burn(address(this), liquidity);\\n            }\\n\\n            _safeTransfer(_token0, to, amount0);\\n            _safeTransfer(_token1, to, amount1);\\n        }\\n\\n        {\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n            _update(balance0, balance1);\\n            if (feeOn) kLast = isXybk ? xybkComputeK(balance0, balance1) : balance0.mul(balance1);\\n        }\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    /**\\n     @notice Performs a swap operation. Tokens must already be sent to contract\\n     @dev Input/output amount of tokens must >0 and pool needs to have sufficient liquidity\\n     @dev Openzeppelin reentrancy guards are used\\n     @dev Post-swap invariant check is performed (either uni or xybk)\\n     @param amount0Out The amount of token0's to output\\n     @param amount1Out The amount of token1's to output\\n     @param to The address to output tokens to\\n     @param data Call data allowing for another function call\\n    */\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external override onlyIFRouter nonReentrant {\\n        require(amount0Out > 0 || amount1Out > 0, 'IF: INSUFFICIENT_OUTPUT_AMOUNT');\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\\n        require(amount0Out <= _reserve0 && amount1Out <= _reserve1, 'IF: INSUFFICIENT_LIQUIDITY');\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n        uint256 amount0In;\\n        uint256 amount1In;\\n        {\\n            require(to != token0 && to != token1, 'IF: INVALID_TO');\\n            if (amount0Out > 0) _safeTransfer(token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out > 0) _safeTransfer(token1, to, amount1Out); // optimistically transfer tokens\\n            if (data.length > 0) IImpossibleCallee(to).ImpossibleCall(msg.sender, amount0Out, amount1Out, data);\\n            balance0 = IERC20(token0).balanceOf(address(this));\\n            balance1 = IERC20(token1).balanceOf(address(this));\\n            // Check bounds\\n            amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n            amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        }\\n\\n        require(amount0In > 0 || amount1In > 0, 'IF: INSUFFICIENT_INPUT_AMOUNT');\\n\\n        {\\n            // Avoid stack too deep errors\\n            bool _isXybk = isXybk;\\n            uint256 _tradeFee = uint256(tradeFee);\\n            uint256 balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(_tradeFee)); // tradeFee amt of basis pts\\n            uint256 balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(_tradeFee)); // tradeFee amt of basis pts\\n            if (_isXybk) {\\n                // Check if trade is legal\\n                TradeState _tradeState = tradeState;\\n                require(\\n                    (_tradeState == TradeState.SELL_ALL) ||\\n                        (_tradeState == TradeState.SELL_TOKEN_0 && amount1Out == 0) ||\\n                        (_tradeState == TradeState.SELL_TOKEN_1 && amount0Out == 0),\\n                    'IF: TRADE_NOT_ALLOWED'\\n                );\\n\\n                (uint256 boost0, uint256 boost1) = calcBoost(); // dont update boost\\n                uint256 scaledOldK = xybkComputeK(boost0, boost1).mul(10000**2);\\n                require(\\n                    xybkCheckK(boost0, boost1, balance0Adjusted, balance1Adjusted, scaledOldK),\\n                    'IF: INSUFFICIENT_XYBK_K'\\n                );\\n            } else {\\n                require(\\n                    balance0Adjusted.mul(balance1Adjusted) >= _reserve0.mul(_reserve1).mul(10000**2),\\n                    'IF: INSUFFICIENT_UNI_K'\\n                );\\n            }\\n        }\\n\\n        _update(balance0, balance1);\\n\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    /** \\n     @notice Calculates xybk K value\\n     @dev Uses library function, same as router\\n     @param _boost0 boost0 to calculate xybk K with\\n     @param _boost1 boost1 to calculate xybk K with\\n     @return k The k value given these reserves and boost values\\n     */\\n    function xybkComputeK(uint256 _boost0, uint256 _boost1) internal view returns (uint256 k) {\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves();\\n        uint256 boost = (_reserve0 > _reserve1) ? _boost0.sub(1) : _boost1.sub(1);\\n        uint256 denom = boost.mul(2).add(1); // 1+2*boost\\n        uint256 term = boost.mul(_reserve0.add(_reserve1)).div(denom.mul(2)); // boost*(x+y)/(2+4*boost)\\n        k = (Math.sqrt(term**2 + _reserve0.mul(_reserve1).div(denom)) + term)**2;\\n    }\\n\\n    /**\\n     @notice Performing K invariant check through an approximation from old K\\n     @dev More details on math at: https://docs.impossible.finance/impossible-swap/swap-math\\n     @dev If K_new >= K_old, correctness should still hold\\n     @param boost0 Current boost0 in pair\\n     @param boost1 Current boost1 in pair\\n     @param balance0 Current state of balance0 in pair\\n     @param balance1 Current state of balance1 in pair\\n     @param oldK The pre-swap K value\\n     @return bool Whether the new balances satisfy the K check for xybk\\n    */\\n    function xybkCheckK(\\n        uint256 boost0,\\n        uint256 boost1,\\n        uint256 balance0,\\n        uint256 balance1,\\n        uint256 oldK\\n    ) internal pure returns (bool) {\\n        uint256 oldSqrtK = Math.sqrt(oldK);\\n        uint256 boost = (balance0 > balance1) ? boost0.sub(1) : boost1.sub(1);\\n        uint256 innerTerm = boost.mul(oldSqrtK);\\n        return (balance0.add(innerTerm)).mul(balance1.add(innerTerm)).div((boost.add(1))**2) >= oldK;\\n    }\\n\\n    /**\\n     @notice Forces balances to match reserves\\n     @dev Requires balance0 >= reserve0 and balance1 >= reserve1\\n     @param to Address to send excess underlying tokens to\\n    */\\n    function skim(address to) external override nonReentrant {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves();\\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(_reserve0));\\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(_reserve1));\\n    }\\n\\n    /**\\n     @notice Forces reserves to match balances\\n    */\\n    function sync() external override nonReentrant {\\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\\n        _update(_balance0, _balance1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, 'ReentrancyGuard: reentrant call');\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImpossiblePair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport './IImpossibleERC20.sol';\\n\\ninterface IImpossiblePair is IImpossibleERC20 {\\n    enum TradeState {\\n        SELL_ALL,\\n        SELL_TOKEN_0,\\n        SELL_TOKEN_1,\\n        SELL_NONE\\n    }\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint256 reserve0, uint256 reserve1);\\n    event ChangeInvariant(bool _isXybk, uint256 _newBoost0, uint256 _newBoost1);\\n    event UpdatedTradeFees(uint256 _oldFee, uint256 _newFee);\\n    event UpdatedDelay(uint256 _oldDelay, uint256 _newDelay);\\n    event UpdatedTradeState(TradeState _tradeState);\\n    event UpdatedWithdrawalFeeRatio(uint256 _oldWithdrawalFee, uint256 _newWithdrawalFee);\\n    event UpdatedBoost(\\n        uint32 _oldBoost0,\\n        uint32 _oldBoost1,\\n        uint32 _newBoost0,\\n        uint32 _newBoost1,\\n        uint256 _start,\\n        uint256 _end\\n    );\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address); // address of token0\\n\\n    function token1() external view returns (address); // address of token1\\n\\n    function getReserves() external view returns (uint256, uint256); // reserves of token0/token1\\n\\n    function calcBoost() external view returns (uint256, uint256);\\n\\n    function mint(address) external returns (uint256);\\n\\n    function burn(address) external returns (uint256, uint256);\\n\\n    function swap(\\n        uint256,\\n        uint256,\\n        address,\\n        bytes calldata\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function getPairSettings()\\n        external\\n        view\\n        returns (\\n            uint16,\\n            TradeState,\\n            bool\\n        ); // Uses single storage slot, save gas\\n\\n    function delay() external view returns (uint256); // Amount of time delay required before any change to boost etc, denoted in seconds\\n\\n    function initialize(\\n        address,\\n        address,\\n        address,\\n        address\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImpossibleSwapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IImpossibleSwapFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n    event UpdatedGovernance(address governance);\\n\\n    function feeTo() external view returns (address);\\n\\n    function governance() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setGovernance(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImpossibleCallee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IImpossibleCallee {\\n    function ImpossibleCall(\\n        address sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ImpossibleSwapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport './ImpossiblePair.sol';\\nimport './ImpossibleWrappedToken.sol';\\n\\nimport './interfaces/IImpossibleSwapFactory.sol';\\n\\n/**\\n    @title  Swap Factory for Impossible Swap V3\\n    @author Impossible Finance\\n    @notice This factory builds upon basic Uni V2 factory by changing \\\"feeToSetter\\\"\\n            to \\\"governance\\\" and adding a whitelist\\n    @dev    See documentation at: https://docs.impossible.finance/impossible-swap/overview\\n*/\\n\\ncontract ImpossibleSwapFactory is IImpossibleSwapFactory {\\n    address public override feeTo;\\n    address public override governance;\\n    address public router;\\n    address public routerExtension;\\n    bool public whitelist;\\n    mapping(address => bool) public approvedTokens;\\n\\n    mapping(address => mapping(address => address)) public override getPair;\\n    address[] public override allPairs;\\n\\n    /**\\n     @notice The constructor for the IF swap factory\\n     @param _governance The address for IF Governance\\n    */\\n    constructor(address _governance) {\\n        governance = _governance;\\n    }\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == governance, 'IF: FORBIDDEN');\\n        _;\\n    }\\n\\n    /**\\n     @notice The constructor for the IF swap factory\\n     @dev _governance The address for IF Governance\\n     @return uint256 The current number of pairs in the IF swap\\n    */\\n    function allPairsLength() external view override returns (uint256) {\\n        return allPairs.length;\\n    }\\n\\n    /**\\n     @notice Sets router address in factory\\n     @dev Router is checked in pair contracts to ensure calls are from IF routers only\\n     @dev Can only be set by IF governance\\n     @param _router The address of the IF router\\n     @param _routerExtension The address of the IF router extension\\n    */\\n    function setRouterAndExtension(address _router, address _routerExtension) external onlyGovernance {\\n        router = _router;\\n        routerExtension = _routerExtension;\\n    }\\n\\n    /**\\n     @notice Either allow or stop a token from being a valid token for new pair contracts\\n     @dev Changes can only be made by IF governance\\n     @param token The address of the token\\n     @param allowed The boolean to include/exclude this token in the whitelist\\n    */\\n    function changeTokenAccess(address token, bool allowed) external onlyGovernance {\\n        approvedTokens[token] = allowed;\\n    }\\n\\n    /**\\n     @notice Turns on or turns off the whitelist feature\\n     @dev Can only be set by IF governance\\n     @param b The boolean that whitelist is set to\\n    */\\n    function setWhitelist(bool b) external onlyGovernance {\\n        whitelist = b;\\n    }\\n\\n    /**\\n     @notice Creates a new Impossible Pair contract\\n     @dev If whitelist is on, can only use approved tokens in whitelist\\n     @dev tokenA must not be equal to tokenB\\n     @param tokenA The address of token A. Token A will be in the new Pair contract\\n     @param tokenB The address of token B. Token B will be in the new Pair contract\\n     @return pair The address of the created pair containing token A and token B\\n    */\\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\\n        if (whitelist) {\\n            require(approvedTokens[tokenA] && approvedTokens[tokenB], 'IF: RESTRICTED_TOKENS');\\n        }\\n        require(tokenA != tokenB, 'IF: IDENTICAL_ADDRESSES');\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'IF: ZERO_ADDRESS');\\n        require(getPair[token0][token1] == address(0), 'IF: PAIR_EXISTS');\\n\\n        bytes memory bytecode = type(ImpossiblePair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n\\n        IImpossiblePair(pair).initialize(token0, token1, router, routerExtension);\\n\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair;\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    /**\\n     @notice Sets the address that fees from the swap are paid to\\n     @dev Can only be called by IF governance\\n     @param _feeTo The address that will receive swap fees\\n    */\\n    function setFeeTo(address _feeTo) external override onlyGovernance {\\n        feeTo = _feeTo;\\n    }\\n\\n    /**\\n     @notice Sets the address for IF governance\\n     @dev Can only be called by IF governance\\n     @param _governance The address of the new IF governance\\n    */\\n    function setGovernance(address _governance) external override onlyGovernance {\\n        governance = _governance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ImpossibleWrappedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\n\\npragma solidity =0.7.6;\\n\\nimport './libraries/TransferHelper.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/ReentrancyGuard.sol';\\n\\nimport './interfaces/IImpossibleWrappedToken.sol';\\nimport './interfaces/IERC20.sol';\\n\\ncontract ImpossibleWrappedToken is IImpossibleWrappedToken, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    string public override name;\\n    string public override symbol;\\n    uint8 public override decimals = 18;\\n    uint256 public override totalSupply;\\n\\n    IERC20 public underlying;\\n    uint256 public underlyingBalance;\\n    uint256 public ratioNum;\\n    uint256 public ratioDenom;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    constructor(\\n        address _underlying,\\n        uint256 _ratioNum,\\n        uint256 _ratioDenom\\n    ) {\\n        underlying = IERC20(_underlying);\\n        ratioNum = _ratioNum;\\n        ratioDenom = _ratioDenom;\\n        string memory desc = string(abi.encodePacked(underlying.symbol()));\\n        name = string(abi.encodePacked('IF-Wrapped ', desc));\\n        symbol = string(abi.encodePacked('WIF ', desc));\\n    }\\n\\n    // amt = amount of wrapped tokens\\n    function deposit(address dst, uint256 sendAmt) public override nonReentrant returns (uint256 wad) {\\n        TransferHelper.safeTransferFrom(address(underlying), msg.sender, address(this), sendAmt);\\n        uint256 receiveAmt = IERC20(underlying).balanceOf(address(this)).sub(underlyingBalance);\\n        wad = receiveAmt.mul(ratioNum).div(ratioDenom);\\n        balanceOf[dst] = balanceOf[dst].add(wad);\\n        totalSupply = totalSupply.add(wad);\\n        underlyingBalance = underlyingBalance.add(receiveAmt);\\n        emit Transfer(address(0), dst, wad);\\n    }\\n\\n    // wad = amount of wrapped tokens\\n    function withdraw(address dst, uint256 wad) public override nonReentrant returns (uint256 transferAmt) {\\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(wad);\\n        totalSupply = totalSupply.sub(wad);\\n        transferAmt = wad.mul(ratioDenom).div(ratioNum);\\n        TransferHelper.safeTransfer(address(underlying), dst, transferAmt);\\n        underlyingBalance = underlyingBalance.sub(transferAmt);\\n        emit Transfer(msg.sender, address(0), wad);\\n    }\\n\\n    function amtToUnderlyingAmt(uint256 amt) public view override returns (uint256) {\\n        return amt.mul(ratioDenom).div(ratioNum);\\n    }\\n\\n    function approve(address guy, uint256 wad) public override returns (bool) {\\n        allowance[msg.sender][guy] = wad;\\n        emit Approval(msg.sender, guy, wad);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint256 wad) public override returns (bool) {\\n        require(dst != address(0x0), 'IF Wrapper: INVALID_DST');\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) public override returns (bool) {\\n        require(balanceOf[src] >= wad, '');\\n        require(dst != address(0x0), 'IF Wrapper: INVALID_DST');\\n\\n        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {\\n            require(allowance[src][msg.sender] >= wad, 'ImpossibleWrapper: INSUFF_ALLOWANCE');\\n            allowance[src][msg.sender] -= wad;\\n        }\\n\\n        balanceOf[src] -= wad;\\n        balanceOf[dst] += wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImpossibleWrappedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport './IERC20.sol';\\n\\ninterface IImpossibleWrappedToken is IERC20 {\\n    function deposit(address, uint256) external returns (uint256);\\n\\n    function withdraw(address, uint256) external returns (uint256);\\n\\n    function amtToUnderlyingAmt(uint256) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/ImpossibleRouterExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport './interfaces/IImpossiblePair.sol';\\nimport './interfaces/IImpossibleSwapFactory.sol';\\nimport './interfaces/IImpossibleRouterExtension.sol';\\n\\nimport './libraries/ImpossibleLibrary.sol';\\n\\ncontract ImpossibleRouterExtension is IImpossibleRouterExtension {\\n    address public immutable override factory;\\n\\n    constructor(address _factory) {\\n        factory = _factory;\\n    }\\n\\n    /**\\n     @notice Helper function for basic swap\\n     @dev Requires the initial amount to have been sent to the first pair contract\\n     @param amounts[] An array of trade amounts. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n    */\\n    function swap(uint256[] memory amounts, address[] memory path) public override {\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0, ) = ImpossibleLibrary.sortTokens(input, output);\\n            uint256 amountOut = amounts[i + 1];\\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\\n                ? (uint256(0), amountOut)\\n                : (amountOut, uint256(0));\\n            address to = i < path.length - 2 ? ImpossibleLibrary.pairFor(factory, output, path[i + 2]) : msg.sender;\\n            IImpossiblePair(ImpossibleLibrary.pairFor(factory, input, output)).swap(\\n                amount0Out,\\n                amount1Out,\\n                to,\\n                new bytes(0)\\n            );\\n        }\\n    }\\n\\n    /**\\n     @notice Helper function for swap supporting fee on transfer tokens\\n     @dev Requires the initial amount to have been sent to the first pair contract\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n    */\\n    function swapSupportingFeeOnTransferTokens(address[] memory path) public override {\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (uint256 amount0Out, uint256 amount1Out) = ImpossibleLibrary.getAmountOutFeeOnTransfer(\\n                input,\\n                output,\\n                factory\\n            );\\n            address to = i < path.length - 2 ? ImpossibleLibrary.pairFor(factory, output, path[i + 2]) : msg.sender;\\n            IImpossiblePair(ImpossibleLibrary.pairFor(factory, input, output)).swap(\\n                amount0Out,\\n                amount1Out,\\n                to,\\n                new bytes(0)\\n            );\\n        }\\n    }\\n\\n    /**\\n     @notice Helper function for adding liquidity\\n     @dev Logic is unchanged from uniswap-V2-Router02\\n     @param tokenA The address of underlying tokenA to add\\n     @param tokenB The address of underlying tokenB to add\\n     @param amountADesired The desired amount of tokenA to add\\n     @param amountBDesired The desired amount of tokenB to add\\n     @param amountAMin The min amount of tokenA to add (amountAMin:amountBDesired sets bounds on ratio)\\n     @param amountBMin The min amount of tokenB to add (amountADesired:amountBMin sets bounds on ratio)\\n     @return amountA Actual amount of tokenA added as liquidity to pair\\n     @return amountB Actual amount of tokenB added as liquidity to pair\\n    */\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) public override returns (uint256 amountA, uint256 amountB) {\\n        // create the pair if it doesn't exist yet\\n        if (IImpossibleSwapFactory(factory).getPair(tokenA, tokenB) == address(0)) {\\n            IImpossibleSwapFactory(factory).createPair(tokenA, tokenB);\\n        }\\n        (uint256 reserveA, uint256 reserveB, ) = ImpossibleLibrary.getReserves(factory, tokenA, tokenB);\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else if (reserveA == 0) {\\n            amountB = amountBDesired;\\n        } else if (reserveB == 0) {\\n            amountA = amountADesired;\\n        } else {\\n            uint256 amountBOptimal = ImpossibleLibrary.quote(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal <= amountBDesired) {\\n                require(amountBOptimal >= amountBMin, 'ImpossibleRouter: INSUFFICIENT_B_AMOUNT');\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint256 amountAOptimal = ImpossibleLibrary.quote(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal <= amountADesired);\\n                require(amountAOptimal >= amountAMin, 'ImpossibleRouter: INSUFFICIENT_A_AMOUNT');\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    /**\\n     @notice Helper function for removing liquidity\\n     @dev Logic is unchanged from uniswap-V2-Router02\\n     @param tokenA The address of underlying tokenA in LP token\\n     @param tokenB The address of underlying tokenB in LP token\\n     @param pair The address of the pair corresponding to tokenA and tokenB\\n     @param amountAMin The min amount of underlying tokenA that has to be received\\n     @param amountBMin The min amount of underlying tokenB that has to be received\\n     @return amountA Actual amount of underlying tokenA received\\n     @return amountB Actual amount of underlying tokenB received\\n    */\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        address pair,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) public override returns (uint256 amountA, uint256 amountB) {\\n        (uint256 amount0, uint256 amount1) = IImpossiblePair(pair).burn(msg.sender);\\n        (address token0, ) = ImpossibleLibrary.sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n        require(amountA >= amountAMin, 'ImpossibleRouter: INSUFFICIENT_A_AMOUNT');\\n        require(amountB >= amountBMin, 'ImpossibleRouter: INSUFFICIENT_B_AMOUNT');\\n    }\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) public pure virtual override returns (uint256 amountB) {\\n        return ImpossibleLibrary.quote(amountA, reserveA, reserveB);\\n    }\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        address tokenOut\\n    ) public view virtual override returns (uint256 amountOut) {\\n        return ImpossibleLibrary.getAmountOut(amountIn, tokenIn, tokenOut, factory);\\n    }\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        address tokenIn,\\n        address tokenOut\\n    ) public view virtual override returns (uint256 amountIn) {\\n        return ImpossibleLibrary.getAmountIn(amountOut, tokenIn, tokenOut, factory);\\n    }\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory amounts)\\n    {\\n        return ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n    }\\n\\n    function getAmountsIn(uint256 amountOut, address[] memory path)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory amounts)\\n    {\\n        return ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImpossibleRouterExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport './IImpossiblePair.sol';\\n\\ninterface IImpossibleRouterExtension {\\n    function factory() external returns (address factoryAddr);\\n\\n    function swap(uint256[] memory amounts, address[] memory path) external;\\n\\n    function swapSupportingFeeOnTransferTokens(address[] memory path) external;\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        address pair,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        address tokenOut\\n    ) external view returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        address tokenIn,\\n        address tokenOut\\n    ) external view returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ImpossibleLibrary.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: GPL-3\\npragma solidity >=0.5.0;\\n\\nimport '../interfaces/IImpossiblePair.sol';\\nimport '../interfaces/IERC20.sol';\\n\\nimport './SafeMath.sol';\\nimport './Math.sol';\\n\\nlibrary ImpossibleLibrary {\\n    using SafeMath for uint256;\\n\\n    /**\\n     @notice Sorts tokens in ascending order\\n     @param tokenA The address of token A\\n     @param tokenB The address of token B\\n     @return token0 The address of token 0 (lexicographically smaller than addr of token 1)\\n     @return token1 The address of token 1 (lexicographically larger than addr of token 0)\\n    */\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'ImpossibleLibrary: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'ImpossibleLibrary: ZERO_ADDRESS');\\n    }\\n\\n    /**\\n     @notice Computes the pair contract create2 address deterministically\\n     @param factory The address of the token factory (pair contract deployer)\\n     @param tokenA The address of token A\\n     @param tokenB The address of token B\\n     @return pair The address of the pair containing token A and B\\n    */\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex'ff',\\n                        factory,\\n                        keccak256(abi.encodePacked(token0, token1)),\\n                        hex'fc84b622ba228c468b74c2d99bfe9454ffac280ac017f05a02feb9f739aeb1e4' // init code hash                    \\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     @notice Obtains the token reserves in the pair contract\\n     @param factory The address of the token factory (pair contract deployer)\\n     @param tokenA The address of token A\\n     @param tokenB The address of token B\\n     @return reserveA The amount of token A in reserves\\n     @return reserveB The amount of token B in reserves\\n     @return pair The address of the pair containing token A and B\\n    */\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 reserveA,\\n            uint256 reserveB,\\n            address pair\\n        )\\n    {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        pair = pairFor(factory, tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1) = IImpossiblePair(pair).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    /**\\n     @notice Quote returns amountB based on some amountA, in the ratio of reserveA:reserveB\\n     @param amountA The amount of token A\\n     @param reserveA The amount of reserveA\\n     @param reserveB The amount of reserveB\\n     @return amountB The amount of token B that matches amount A in the ratio of reserves\\n    */\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, 'ImpossibleLibrary: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'ImpossibleLibrary: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    /**\\n     @notice Internal function to compute the K value for an xybk pair based on token balances and boost\\n     @dev More details on math at: https://docs.impossible.finance/impossible-swap/swap-math\\n     @dev Implementation is the same as in pair\\n     @param boost0 Current boost0 in pair\\n     @param boost1 Current boost1 in pair\\n     @param balance0 Current state of balance0 in pair\\n     @param balance1 Current state of balance1 in pair\\n     @return k Value of K invariant\\n    */\\n    function xybkComputeK(\\n        uint256 boost0,\\n        uint256 boost1,\\n        uint256 balance0,\\n        uint256 balance1\\n    ) internal pure returns (uint256 k) {\\n        uint256 boost = (balance0 > balance1) ? boost0.sub(1) : boost1.sub(1);\\n        uint256 denom = boost.mul(2).add(1); // 1+2*boost\\n        uint256 term = boost.mul(balance0.add(balance1)).div(denom.mul(2)); // boost*(x+y)/(2+4*boost)\\n        k = (Math.sqrt(term**2 + balance0.mul(balance1).div(denom)) + term)**2;\\n    }\\n\\n    /**\\n     @notice Internal helper function for calculating artificial liquidity\\n     @dev More details on math at: https://docs.impossible.finance/impossible-swap/swap-math\\n     @param _boost The boost variable on the correct side for the pair contract\\n     @param _sqrtK The sqrt of the invariant variable K in xybk formula\\n     @return uint256 The artificial liquidity term\\n    */\\n    function calcArtiLiquidityTerm(uint256 _boost, uint256 _sqrtK) internal pure returns (uint256) {\\n        return (_boost - 1).mul(_sqrtK);\\n    }\\n\\n    /**\\n     @notice Quotes maximum output given exact input amount of tokens and addresses of tokens in pair\\n     @dev The library function considers custom swap fees/invariants/asymmetric tuning of pairs\\n     @dev However, library function doesn't consider limits created by hardstops\\n     @param amountIn The input amount of token A\\n     @param tokenIn The address of input token\\n     @param tokenOut The address of output token\\n     @param factory The address of the factory contract\\n     @return amountOut The maximum output amount of token B for a valid swap\\n    */\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        address tokenOut,\\n        address factory\\n    ) internal view returns (uint256 amountOut) {\\n        require(amountIn > 0, 'ImpossibleLibrary: INSUFFICIENT_INPUT_AMOUNT');\\n        uint256 reserveIn;\\n        uint256 reserveOut;\\n        uint256 amountInPostFee;\\n        address pair;\\n        bool isMatch;\\n        {\\n            // Avoid stack too deep\\n            (address token0, ) = sortTokens(tokenIn, tokenOut);\\n            isMatch = tokenIn == token0;\\n            (reserveIn, reserveOut, pair) = getReserves(factory, tokenIn, tokenOut);\\n        }\\n        uint256 artiLiqTerm;\\n        bool isXybk;\\n        {\\n            // Avoid stack too deep\\n            uint256 fee;\\n            IImpossiblePair.TradeState tradeState;\\n            (fee, tradeState, isXybk) = IImpossiblePair(pair).getPairSettings();\\n            amountInPostFee = amountIn.mul(10000 - fee);\\n            require(\\n                (tradeState == IImpossiblePair.TradeState.SELL_ALL) ||\\n                    (tradeState == IImpossiblePair.TradeState.SELL_TOKEN_0 && !isMatch) ||\\n                    (tradeState == IImpossiblePair.TradeState.SELL_TOKEN_1 && isMatch),\\n                'ImpossibleLibrary: TRADE_NOT_ALLOWED'\\n            );\\n        }\\n\\n        /// If xybk invariant, set reserveIn/reserveOut to artificial liquidity instead of actual liquidity\\n        if (isXybk) {\\n            (uint256 boost0, uint256 boost1) = IImpossiblePair(pair).calcBoost();\\n            uint256 sqrtK = Math.sqrt(\\n                xybkComputeK(boost0, boost1, isMatch ? reserveIn : reserveOut, isMatch ? reserveOut : reserveIn)\\n            );\\n            /// since balance0=balance1 only at sqrtK, if final balanceIn >= sqrtK means balanceIn >= balanceOut\\n            /// Use post-fee balances to maintain consistency with pair contract K invariant check\\n            if (amountInPostFee.add(reserveIn.mul(10000)) >= sqrtK.mul(10000)) {\\n                /// If tokenIn = token0, balanceIn > sqrtK => balance0>sqrtK, use boost0\\n                artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost0 : boost1, sqrtK);\\n                /// If balance started from <sqrtK and ended at >sqrtK and boosts are different, there'll be different amountIn/Out\\n                /// Don't need to check in other case for reserveIn < reserveIn.add(x) <= sqrtK since that case doesnt cross midpt\\n                if (reserveIn < sqrtK && boost0 != boost1) {\\n                    /// Break into 2 trades => start point -> midpoint (sqrtK, sqrtK), then midpoint -> final point\\n                    amountOut = reserveOut.sub(sqrtK);\\n                    amountInPostFee = amountInPostFee.sub((sqrtK.sub(reserveIn)).mul(10000));\\n                    reserveIn = sqrtK;\\n                    reserveOut = sqrtK;\\n                }\\n            } else {\\n                /// If tokenIn = token0, balanceIn < sqrtK => balance0<sqrtK, use boost1\\n                artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost1 : boost0, sqrtK);\\n            }\\n        }\\n        uint256 numerator = amountInPostFee.mul(reserveOut.add(artiLiqTerm));\\n        uint256 denominator = (reserveIn.add(artiLiqTerm)).mul(10000).add(amountInPostFee);\\n        uint256 lastSwapAmountOut = numerator / denominator;\\n        amountOut = (lastSwapAmountOut > reserveOut) ? reserveOut.add(amountOut) : lastSwapAmountOut.add(amountOut);\\n    }\\n\\n    /**\\n     @notice Quotes minimum input given exact output amount of tokens and addresses of tokens in pair\\n     @dev The library function considers custom swap fees/invariants/asymmetric tuning of pairs\\n     @dev However, library function doesn't consider limits created by hardstops\\n     @param amountOut The desired output amount of token A\\n     @param tokenIn The address of input token\\n     @param tokenOut The address of output token\\n     @param factory The address of the factory contract\\n     @return amountIn The minimum input amount of token A for a valid swap\\n    */\\n    function getAmountIn(\\n        uint256 amountOut,\\n        address tokenIn,\\n        address tokenOut,\\n        address factory\\n    ) internal view returns (uint256 amountIn) {\\n        require(amountOut > 0, 'ImpossibleLibrary: INSUFFICIENT_INPUT_AMOUNT');\\n\\n        uint256 reserveIn;\\n        uint256 reserveOut;\\n        uint256 artiLiqTerm;\\n        uint256 fee;\\n        bool isMatch;\\n        {\\n            // Avoid stack too deep\\n            bool isXybk;\\n            uint256 boost0;\\n            uint256 boost1;\\n            {\\n                // Avoid stack too deep\\n                (address token0, ) = sortTokens(tokenIn, tokenOut);\\n                isMatch = tokenIn == token0;\\n            }\\n            {\\n                // Avoid stack too deep\\n                address pair;\\n                (reserveIn, reserveOut, pair) = getReserves(factory, tokenIn, tokenOut);\\n                IImpossiblePair.TradeState tradeState;\\n                (fee, tradeState, isXybk) = IImpossiblePair(pair).getPairSettings();\\n                require(\\n                    (tradeState == IImpossiblePair.TradeState.SELL_ALL) ||\\n                        (tradeState == IImpossiblePair.TradeState.SELL_TOKEN_0 && !isMatch) ||\\n                        (tradeState == IImpossiblePair.TradeState.SELL_TOKEN_1 && isMatch),\\n                    'ImpossibleLibrary: TRADE_NOT_ALLOWED'\\n                );\\n                (boost0, boost1) = IImpossiblePair(pair).calcBoost();\\n            }\\n            if (isXybk) {\\n                uint256 sqrtK = Math.sqrt(\\n                    xybkComputeK(boost0, boost1, isMatch ? reserveIn : reserveOut, isMatch ? reserveOut : reserveIn)\\n                );\\n                /// since balance0=balance1 only at sqrtK, if final balanceOut >= sqrtK means balanceOut >= balanceIn\\n                if (reserveOut.sub(amountOut) >= sqrtK) {\\n                    /// If tokenIn = token0, balanceOut > sqrtK => balance1>sqrtK, use boost1\\n                    artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost1 : boost0, sqrtK);\\n                } else {\\n                    /// If tokenIn = token0, balanceOut < sqrtK => balance0>sqrtK, use boost0\\n                    artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost0 : boost1, sqrtK);\\n                    /// If balance started from <sqrtK and ended at >sqrtK and boosts are different, there'll be different amountIn/Out\\n                    /// Don't need to check in other case for reserveOut > reserveOut.sub(x) >= sqrtK since that case doesnt cross midpt\\n                    if (reserveOut > sqrtK && boost0 != boost1) {\\n                        /// Break into 2 trades => start point -> midpoint (sqrtK, sqrtK), then midpoint -> final point\\n                        amountIn = sqrtK.sub(reserveIn).mul(10000); /// Still need to divide by (10000 - fee). Do with below calculation to prevent early truncation\\n                        amountOut = amountOut.sub(reserveOut.sub(sqrtK));\\n                        reserveOut = sqrtK;\\n                        reserveIn = sqrtK;\\n                    }\\n                }\\n            }\\n        }\\n        uint256 numerator = (reserveIn.add(artiLiqTerm)).mul(amountOut).mul(10000);\\n        uint256 denominator = (reserveOut.add(artiLiqTerm)).sub(amountOut);\\n        amountIn = (amountIn.add((numerator / denominator)).div(10000 - fee)).add(1);\\n    }\\n\\n    /**\\n     @notice Quotes maximum output given some uncertain input amount of tokens and addresses of tokens in pair\\n     @dev The library function considers custom swap fees/invariants/asymmetric tuning of pairs\\n     @dev However, library function doesn't consider limits created by hardstops\\n     @param tokenIn The address of input token\\n     @param tokenOut The address of output token\\n     @param factory The address of the factory contract\\n     @return uint256 The maximum possible output amount of token A\\n     @return uint256 The maximum possible output amount of token B\\n    */\\n    function getAmountOutFeeOnTransfer(\\n        address tokenIn,\\n        address tokenOut,\\n        address factory\\n    ) internal view returns (uint256, uint256) {\\n        uint256 reserveIn;\\n        uint256 reserveOut;\\n        address pair;\\n        bool isMatch;\\n        {\\n            // Avoid stack too deep\\n            (address token0, ) = sortTokens(tokenIn, tokenOut);\\n            isMatch = tokenIn == token0;\\n            (reserveIn, reserveOut, pair) = getReserves(factory, tokenIn, tokenOut); /// Should be reserve0/1 but reuse variables to save stack\\n        }\\n        uint256 amountOut;\\n        uint256 artiLiqTerm;\\n        uint256 amountInPostFee;\\n        bool isXybk;\\n        {\\n            // Avoid stack too deep\\n            uint256 fee;\\n            uint256 balanceIn = IERC20(tokenIn).balanceOf(address(pair));\\n            require(balanceIn > reserveIn, 'ImpossibleLibrary: INSUFFICIENT_INPUT_AMOUNT');\\n            IImpossiblePair.TradeState tradeState;\\n            (fee, tradeState, isXybk) = IImpossiblePair(pair).getPairSettings();\\n            require(\\n                (tradeState == IImpossiblePair.TradeState.SELL_ALL) ||\\n                    (tradeState == IImpossiblePair.TradeState.SELL_TOKEN_0 && !isMatch) ||\\n                    (tradeState == IImpossiblePair.TradeState.SELL_TOKEN_1 && isMatch),\\n                'ImpossibleLibrary: TRADE_NOT_ALLOWED'\\n            );\\n            amountInPostFee = (balanceIn.sub(reserveIn)).mul(10000 - fee);\\n        }\\n        /// If xybk invariant, set reserveIn/reserveOut to artificial liquidity instead of actual liquidity\\n        if (isXybk) {\\n            (uint256 boost0, uint256 boost1) = IImpossiblePair(pair).calcBoost();\\n            uint256 sqrtK = Math.sqrt(\\n                xybkComputeK(boost0, boost1, isMatch ? reserveIn : reserveOut, isMatch ? reserveOut : reserveIn)\\n            );\\n            /// since balance0=balance1 only at sqrtK, if final balanceIn >= sqrtK means balanceIn >= balanceOut\\n            /// Use post-fee balances to maintain consistency with pair contract K invariant check\\n            if (amountInPostFee.add(reserveIn.mul(10000)) >= sqrtK.mul(10000)) {\\n                /// If tokenIn = token0, balanceIn > sqrtK => balance0>sqrtK, use boost0\\n                artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost0 : boost1, sqrtK);\\n                /// If balance started from <sqrtK and ended at >sqrtK and boosts are different, there'll be different amountIn/Out\\n                /// Don't need to check in other case for reserveIn < reserveIn.add(x) <= sqrtK since that case doesnt cross midpt\\n                if (reserveIn < sqrtK && boost0 != boost1) {\\n                    /// Break into 2 trades => start point -> midpoint (sqrtK, sqrtK), then midpoint -> final point\\n                    amountOut = reserveOut.sub(sqrtK);\\n                    amountInPostFee = amountInPostFee.sub(sqrtK.sub(reserveIn));\\n                    reserveOut = sqrtK;\\n                    reserveIn = sqrtK;\\n                }\\n            } else {\\n                /// If tokenIn = token0, balanceIn < sqrtK => balance0<sqrtK, use boost0\\n                artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost1 : boost0, sqrtK);\\n            }\\n        }\\n        uint256 numerator = amountInPostFee.mul(reserveOut.add(artiLiqTerm));\\n        uint256 denominator = (reserveIn.add(artiLiqTerm)).mul(10000).add(amountInPostFee);\\n        uint256 lastSwapAmountOut = numerator / denominator;\\n        amountOut = (lastSwapAmountOut > reserveOut) ? reserveOut.add(amountOut) : lastSwapAmountOut.add(amountOut);\\n        return isMatch ? (uint256(0), amountOut) : (amountOut, uint256(0));\\n    }\\n\\n    /**\\n     @notice Quotes maximum output given exact input amount of tokens and addresses of tokens in trade sequence\\n     @dev The library function considers custom swap fees/invariants/asymmetric tuning of pairs\\n     @dev However, library function doesn't consider limits created by hardstops\\n     @param factory The address of the IF factory\\n     @param amountIn The input amount of token A\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @return amounts The maximum possible output amount of all tokens through sequential swaps\\n    */\\n    function getAmountsOut(\\n        address factory,\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, 'ImpossibleLibrary: INVALID_PATH');\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i < path.length - 1; i++) {\\n            amounts[i + 1] = getAmountOut(amounts[i], path[i], path[i + 1], factory);\\n        }\\n    }\\n\\n    /**\\n     @notice Quotes minimum input given exact output amount of tokens and addresses of tokens in trade sequence\\n     @dev The library function considers custom swap fees/invariants/asymmetric tuning of pairs\\n     @dev However, library function doesn't consider limits created by hardstops\\n     @param factory The address of the IF factory\\n     @param amountOut The output amount of token A\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @return amounts The minimum output amount required of all tokens through sequential swaps\\n    */\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, 'ImpossibleLibrary: INVALID_PATH');\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\n            amounts[i - 1] = getAmountIn(amounts[i], path[i - 1], path[i], factory);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/DeflatingERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport '../libraries/SafeMath.sol';\\n\\ncontract DeflatingERC20 {\\n    using SafeMath for uint256;\\n\\n    string public constant name = 'Deflating Test Token';\\n    string public constant symbol = 'DTT';\\n    uint8 public constant decimals = 18;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public nonces;\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    constructor(uint256 _totalSupply) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name)),\\n                keccak256(bytes('1')),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n        _mint(msg.sender, _totalSupply);\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        uint256 burnAmount = value / 100;\\n        _burn(from, burnAmount);\\n        uint256 transferAmount = value.sub(burnAmount);\\n        balanceOf[from] = balanceOf[from].sub(transferAmount);\\n        balanceOf[to] = balanceOf[to].add(transferAmount);\\n        emit Transfer(from, to, transferAmount);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.timestamp, 'EXPIRED');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ImpossibleWrapperFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport './ImpossibleWrappedToken.sol';\\n\\nimport './interfaces/IImpossibleWrapperFactory.sol';\\nimport './interfaces/IERC20.sol';\\n\\n/**\\n    @title  Wrapper Factory for Impossible Swap V3\\n    @author Impossible Finance\\n    @notice This factory builds upon basic Uni V2 factory by changing \\\"feeToSetter\\\"\\n            to \\\"governance\\\" and adding a whitelist\\n    @dev    See documentation at: https://docs.impossible.finance/impossible-swap/overview\\n*/\\n\\ncontract ImpossibleWrapperFactory is IImpossibleWrapperFactory {\\n    address public governance;\\n    mapping(address => address) public override tokensToWrappedTokens;\\n    mapping(address => address) public override wrappedTokensToTokens;\\n\\n    /**\\n     @notice The constructor for the IF swap factory\\n     @param _governance The address for IF Governance\\n    */\\n    constructor(address _governance) {\\n        governance = _governance;\\n    }\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == governance, 'IF: FORBIDDEN');\\n        _;\\n    }\\n\\n    /**\\n     @notice Sets the address for IF governance\\n     @dev Can only be called by IF governance\\n     @param _governance The address of the new IF governance\\n    */\\n    function setGovernance(address _governance) external onlyGovernance {\\n        governance = _governance;\\n    }\\n\\n    /**\\n     @notice Creates a pair with some ratio\\n     @dev underlying The address of token to wrap\\n     @dev ratioNumerator The numerator value of the ratio to apply for ratio * underlying = wrapped underlying\\n     @dev ratioDenominator The denominator value of the ratio to apply for ratio * underlying = wrapped underlying\\n    */\\n    function createPairing(\\n        address underlying,\\n        uint256 ratioNumerator,\\n        uint256 ratioDenominator\\n    ) external onlyGovernance returns (address) {\\n        require(\\n            tokensToWrappedTokens[underlying] == address(0x0) && wrappedTokensToTokens[underlying] == address(0x0),\\n            'IF: PAIR_EXISTS'\\n        );\\n        require(ratioNumerator != 0 && ratioDenominator != 0, 'IF: INVALID_RATIO');\\n        ImpossibleWrappedToken wrapper = new ImpossibleWrappedToken(underlying, ratioNumerator, ratioDenominator);\\n        tokensToWrappedTokens[underlying] = address(wrapper);\\n        wrappedTokensToTokens[address(wrapper)] = underlying;\\n        emit WrapCreated(underlying, address(wrapper), ratioNumerator, ratioDenominator);\\n        return address(wrapper);\\n    }\\n\\n    /**\\n     @notice Deletes a pairing\\n     @notice requires supply of wrapped token to be 0\\n     @dev wrapper The address of the wrapper\\n    */\\n    function deletePairing(address wrapper) external onlyGovernance {\\n        require(ImpossibleWrappedToken(wrapper).totalSupply() == 0, 'IF: NONZERO_SUPPLY');\\n        address _underlying = wrappedTokensToTokens[wrapper];\\n        require(ImpossibleWrappedToken(wrapper).underlying() == IERC20(_underlying), 'IF: INVALID_TOKEN');\\n        require(_underlying != address(0x0), 'IF: Address must have pair');\\n        delete tokensToWrappedTokens[_underlying];\\n        delete wrappedTokensToTokens[wrapper];\\n        emit WrapDeleted(_underlying, address(wrapper));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImpossibleWrapperFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IImpossibleWrapperFactory {\\n    event WrapCreated(address, address, uint256, uint256);\\n    event WrapDeleted(address, address);\\n\\n    function tokensToWrappedTokens(address) external view returns (address);\\n\\n    function wrappedTokensToTokens(address) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/ImpossibleRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport './libraries/TransferHelper.sol';\\nimport './libraries/ReentrancyGuard.sol';\\nimport './libraries/ImpossibleLibrary.sol';\\nimport './libraries/SafeMath.sol';\\n\\nimport './interfaces/IImpossibleSwapFactory.sol';\\nimport './interfaces/IImpossibleRouterExtension.sol';\\nimport './interfaces/IImpossibleRouter.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IWETH.sol';\\nimport './interfaces/IImpossibleWrappedToken.sol';\\nimport './interfaces/IImpossibleWrapperFactory.sol';\\n\\n/**\\n    @title  Router for Impossible Swap V3\\n    @author Impossible Finance\\n    @notice This router builds upon basic Uni V2 Router02 by allowing custom\\n            calculations based on settings in pairs (uni/xybk/custom fees)\\n    @dev    See documentation at: https://docs.impossible.finance/impossible-swap/overview\\n    @dev    Very little logical changes made in Router02. Most changes to accomodate xybk are in Library\\n*/\\n\\ncontract ImpossibleRouter is IImpossibleRouter, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    address public immutable override factory;\\n    address public immutable override wrapFactory;\\n\\n    address private utilitySettingAdmin;\\n\\n    address public override routerExtension; // Can be set by utility setting admin once only\\n    address public override WETH; // Can be set by utility setting admin once only\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline >= block.timestamp, 'ImpossibleRouter: EXPIRED');\\n        _;\\n    }\\n\\n    /**\\n     @notice Constructor for IF Router\\n     @param _pairFactory Address of IF Pair Factory\\n     @param _wrapFactory Address of IF\\n     @param _utilitySettingAdmin Admin address allowed to set addresses of utility contracts (once)\\n    */\\n    constructor(\\n        address _pairFactory,\\n        address _wrapFactory,\\n        address _utilitySettingAdmin\\n    ) {\\n        factory = _pairFactory;\\n        wrapFactory = _wrapFactory;\\n        utilitySettingAdmin = _utilitySettingAdmin;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    /**\\n     @notice Used to set addresses of utility contracts\\n     @dev Only allows setter to set these addresses once for trustlessness\\n     @dev Must set both WETH and routerExtension at the same time, else swap will be bricked\\n     @param _WETH address of WETH contract\\n     @param _routerExtension address of router interface contract\\n     */\\n    function setUtilities(address _WETH, address _routerExtension) public {\\n        require(WETH == address(0x0) && routerExtension == address(0x0));\\n        require(msg.sender == utilitySettingAdmin, 'IF: ?');\\n        WETH = _WETH;\\n        routerExtension = _routerExtension;\\n    }\\n\\n    /**\\n     @notice Helper function for sending tokens that might need to be wrapped\\n     @param token The address of the token that might have a wrapper\\n     @param src The source to take underlying tokens from\\n     @param dst The destination to send wrapped tokens to\\n     @param amt The amount of tokens to send (wrapped tokens, not underlying)\\n    */\\n    function wrapSafeTransfer(\\n        address token,\\n        address src,\\n        address dst,\\n        uint256 amt\\n    ) internal {\\n        address underlying = IImpossibleWrapperFactory(wrapFactory).wrappedTokensToTokens(token);\\n        if (underlying == address(0x0)) {\\n            TransferHelper.safeTransferFrom(token, src, dst, amt);\\n        } else {\\n            uint256 underlyingAmt = IImpossibleWrappedToken(token).amtToUnderlyingAmt(amt);\\n            TransferHelper.safeTransferFrom(underlying, src, address(this), underlyingAmt);\\n            TransferHelper.safeApprove(underlying, token, underlyingAmt);\\n            IImpossibleWrappedToken(token).deposit(dst, underlyingAmt);\\n        }\\n    }\\n\\n    /**\\n     @notice Helper function for sending tokens that might need to be unwrapped\\n     @param token The address of the token that might be wrapped\\n     @param dst The destination to send underlying tokens to\\n     @param amt The amount of wrapped tokens to send (wrapped tokens, not underlying)\\n    */\\n    function unwrapSafeTransfer(\\n        address token,\\n        address dst,\\n        uint256 amt\\n    ) internal {\\n        address underlying = IImpossibleWrapperFactory(wrapFactory).wrappedTokensToTokens(token);\\n        if (underlying == address(0x0)) {\\n            TransferHelper.safeTransfer(token, dst, amt);\\n        } else {\\n            IImpossibleWrappedToken(token).withdraw(dst, amt);\\n        }\\n    }\\n\\n    /**\\n     @notice Swap function - receive maximum output given fixed input\\n     @dev Openzeppelin reentrancy guards\\n     @param amountIn The exact input amount`\\n     @param amountOutMin The minimum output amount allowed for a successful swap\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n     @return amounts Array of actual output token amounts received per swap, sequentially.\\n    */\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        wrapSafeTransfer(path[0], msg.sender, ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]);\\n        IImpossibleRouterExtension(routerExtension).swap(amounts, path);\\n        unwrapSafeTransfer(path[path.length - 1], to, amounts[amounts.length - 1]);\\n    }\\n\\n    /**\\n     @notice Swap function - receive desired output amount given a maximum input amount\\n     @dev Openzeppelin reentrancy guards\\n     @param amountOut The exact output amount desired\\n     @param amountInMax The maximum input amount allowed for a successful swap\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n     @return amounts Array of actual output token amounts received per swap, sequentially.\\n    */\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] <= amountInMax, 'ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT');\\n        wrapSafeTransfer(path[0], msg.sender, ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]);\\n        IImpossibleRouterExtension(routerExtension).swap(amounts, path);\\n        unwrapSafeTransfer(path[path.length - 1], to, amountOut);\\n    }\\n\\n    /**\\n     @notice Swap function - receive maximum output given fixed input of ETH\\n     @dev Openzeppelin reentrancy guards\\n     @param amountOutMin The minimum output amount allowed for a successful swap\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n     @return amounts Array of actual output token amounts received per swap, sequentially.\\n    */\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        require(path[0] == WETH, 'ImpossibleRouter: INVALID_PATH');\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, msg.value, path);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n        IImpossibleRouterExtension(routerExtension).swap(amounts, path);\\n        unwrapSafeTransfer(path[path.length - 1], to, amounts[amounts.length - 1]);\\n    }\\n\\n    /**\\n    @notice Swap function - receive desired ETH output amount given a maximum input amount\\n     @dev Openzeppelin reentrancy guards\\n     @param amountOut The exact output amount desired\\n     @param amountInMax The maximum input amount allowed for a successful swap\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n     @return amounts Array of actual output token amounts received per swap, sequentially.\\n    */\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        require(path[path.length - 1] == WETH, 'ImpossibleRouter: INVALID_PATH');\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] <= amountInMax, 'ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT');\\n        wrapSafeTransfer(path[0], msg.sender, ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]);\\n        IImpossibleRouterExtension(routerExtension).swap(amounts, path);\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    /**\\n     @notice Swap function - receive maximum ETH output given fixed input of tokens\\n     @dev Openzeppelin reentrancy guards\\n     @param amountIn The amount of input tokens\\n     @param amountOutMin The minimum ETH output amount required for successful swaps\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n     @return amounts Array of actual output token amounts received per swap, sequentially.\\n    */\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        require(path[path.length - 1] == WETH, 'ImpossibleRouter: INVALID_PATH');\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        wrapSafeTransfer(path[0], msg.sender, ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]);\\n        IImpossibleRouterExtension(routerExtension).swap(amounts, path);\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    /**\\n     @notice Swap function - receive maximum tokens output given fixed ETH input\\n     @dev Openzeppelin reentrancy guards\\n     @param amountOut The minimum output amount in tokens required for successful swaps\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n     @return amounts Array of actual output token amounts received per swap, sequentially.\\n    */\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        require(path[0] == WETH, 'ImpossibleRouter: INVALID_PATH');\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] <= msg.value, 'ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT');\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n        IImpossibleRouterExtension(routerExtension).swap(amounts, path);\\n        unwrapSafeTransfer(path[path.length - 1], to, amountOut);\\n        // refund dust eth, if any\\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n\\n    /**\\n     @notice Swap function for fee on transfer tokens, no WETH/WBNB\\n     @param amountIn The amount of input tokens\\n     @param amountOutMin The minimum token output amount required for successful swaps\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n    */\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant {\\n        wrapSafeTransfer(path[0], msg.sender, ImpossibleLibrary.pairFor(factory, path[0], path[1]), amountIn);\\n        IImpossibleRouterExtension(routerExtension).swapSupportingFeeOnTransferTokens(path);\\n        uint256 balance = IERC20(path[path.length - 1]).balanceOf(address(this));\\n        require(balance >= amountOutMin, 'ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        unwrapSafeTransfer(path[path.length - 1], to, balance);\\n    }\\n\\n    /**\\n     @notice Swap function for fee on transfer tokens with WETH/WBNB\\n     @param amountOutMin The minimum underlying token output amount required for successful swaps\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n    */\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable virtual override ensure(deadline) nonReentrant {\\n        require(path[0] == WETH, 'ImpossibleRouter: INVALID_PATH');\\n        uint256 amountIn = msg.value;\\n        IWETH(WETH).deposit{value: amountIn}();\\n        assert(IWETH(WETH).transfer(ImpossibleLibrary.pairFor(factory, path[0], path[1]), amountIn));\\n        IImpossibleRouterExtension(routerExtension).swapSupportingFeeOnTransferTokens(path);\\n        uint256 balance = IERC20(path[path.length - 1]).balanceOf(address(this));\\n        require(balance >= amountOutMin, 'ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        unwrapSafeTransfer(path[path.length - 1], to, balance);\\n    }\\n\\n    /**\\n     @notice Swap function for fee on transfer tokens, no WETH/WBNB\\n     @param amountIn The amount of input tokens\\n     @param amountOutMin The minimum ETH output amount required for successful swaps\\n     @param path[] An array of token addresses. Trades are made from arr idx 0 to arr end idx sequentially\\n     @param to The address that receives the output tokens\\n     @param deadline The block number after which this transaction is invalid\\n    */\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant {\\n        require(path[path.length - 1] == WETH, 'ImpossibleRouter: INVALID_PATH');\\n        wrapSafeTransfer(path[0], msg.sender, ImpossibleLibrary.pairFor(factory, path[0], path[1]), amountIn);\\n        IImpossibleRouterExtension(routerExtension).swapSupportingFeeOnTransferTokens(path);\\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\\n        require(amountOut >= amountOutMin, 'ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        IWETH(WETH).withdraw(amountOut);\\n        TransferHelper.safeTransferETH(to, amountOut);\\n    }\\n\\n    /**\\n     @notice Function for basic add liquidity functionality\\n     @dev Openzeppelin reentrancy guards\\n     @param tokenA The address of underlying tokenA to add\\n     @param tokenB The address of underlying tokenB to add\\n     @param amountADesired The desired amount of tokenA to add\\n     @param amountBDesired The desired amount of tokenB to add\\n     @param amountAMin The min amount of tokenA to add (amountAMin:amountBDesired sets bounds on ratio)\\n     @param amountBMin The min amount of tokenB to add (amountADesired:amountBMin sets bounds on ratio)\\n     @param to The address to mint LP tokens to\\n     @param deadline The block number after which this transaction is invalid\\n     @return amountA Amount of tokenA added as liquidity to pair\\n     @return amountB Actual amount of tokenB added as liquidity to pair\\n     @return liquidity Actual amount of LP tokens minted\\n    */\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        nonReentrant\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountA, amountB) = IImpossibleRouterExtension(routerExtension).addLiquidity(\\n            tokenA,\\n            tokenB,\\n            amountADesired,\\n            amountBDesired,\\n            amountAMin,\\n            amountBMin\\n        );\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        wrapSafeTransfer(tokenA, msg.sender, pair, amountA);\\n        wrapSafeTransfer(tokenB, msg.sender, pair, amountB);\\n        liquidity = IImpossiblePair(pair).mint(to);\\n    }\\n\\n    /**\\n     @notice Function for add liquidity functionality with 1 token being WETH/WBNB\\n     @dev Openzeppelin reentrancy guards\\n     @param token The address of the non-ETH underlying token to add\\n     @param amountTokenDesired The desired amount of non-ETH underlying token to add\\n     @param amountTokenMin The min amount of non-ETH underlying token to add (amountTokenMin:ETH sent sets bounds on ratio)\\n     @param amountETHMin The min amount of WETH/WBNB to add (amountTokenDesired:amountETHMin sets bounds on ratio)\\n     @param to The address to mint LP tokens to\\n     @param deadline The block number after which this transaction is invalid\\n     @return amountToken Amount of non-ETH underlying token added as liquidity to pair\\n     @return amountETH Actual amount of WETH/WBNB added as liquidity to pair\\n     @return liquidity Actual amount of LP tokens minted\\n    */\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        nonReentrant\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountToken, amountETH) = IImpossibleRouterExtension(routerExtension).addLiquidity(\\n            token,\\n            WETH,\\n            amountTokenDesired,\\n            msg.value,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        wrapSafeTransfer(token, msg.sender, pair, amountToken);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(pair, amountETH));\\n        liquidity = IImpossiblePair(pair).mint(to);\\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any\\n    }\\n\\n    /**\\n     @notice Function for basic remove liquidity functionality\\n     @dev Openzeppelin reentrancy guards\\n     @param tokenA The address of underlying tokenA in LP token\\n     @param tokenB The address of underlying tokenB in LP token\\n     @param liquidity The amount of LP tokens to burn\\n     @param amountAMin The min amount of underlying tokenA that has to be received\\n     @param amountBMin The min amount of underlying tokenB that has to be received\\n     @param to The address to send underlying tokens to\\n     @param deadline The block number after which this transaction is invalid\\n     @return amountA Actual amount of underlying tokenA received\\n     @return amountB Actual amount of underlying tokenB received\\n    */\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) public virtual override ensure(deadline) nonReentrant returns (uint256 amountA, uint256 amountB) {\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        IImpossiblePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (amountA, amountB) = IImpossibleRouterExtension(routerExtension).removeLiquidity(\\n            tokenA,\\n            tokenB,\\n            pair,\\n            amountAMin,\\n            amountBMin\\n        );\\n        unwrapSafeTransfer(tokenA, to, amountA);\\n        unwrapSafeTransfer(tokenB, to, amountB);\\n    }\\n\\n    /**\\n     @notice Function for remove liquidity functionality with 1 token being WETH/WBNB\\n     @dev Openzeppelin reentrancy guards\\n     @param token The address of the non-ETH underlying token to receive\\n     @param liquidity The amount of LP tokens to burn\\n     @param amountTokenMin The desired amount of non-ETH underlying token that has to be received\\n     @param amountETHMin The min amount of ETH that has to be received\\n     @param to The address to send underlying tokens to\\n     @param deadline The block number after which this transaction is invalid\\n     @return amountToken Actual amount of non-ETH underlying token received\\n     @return amountETH Actual amount of WETH/WBNB received\\n    */\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) public virtual override ensure(deadline) nonReentrant returns (uint256 amountToken, uint256 amountETH) {\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        IImpossiblePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (amountToken, amountETH) = IImpossibleRouterExtension(routerExtension).removeLiquidity(\\n            token,\\n            WETH,\\n            pair,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        unwrapSafeTransfer(token, to, amountToken);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    /**\\n    @notice Function for remove liquidity functionality using EIP712 permit\\n     @dev Openzeppelin reentrancy guards\\n     @param tokenA The address of underlying tokenA in LP token\\n     @param tokenB The address of underlying tokenB in LP token\\n     @param liquidity The amount of LP tokens to burn\\n     @param amountAMin The min amount of underlying tokenA that has to be received\\n     @param amountBMin The min amount of underlying tokenB that has to be received\\n     @param to The address to send underlying tokens to\\n     @param deadline The block number after which this transaction is invalid\\n     @param approveMax How much tokens are approved for transfer (liquidity, or max)\\n     @param v,r,s Variables that construct a valid EVM signature\\n     @return amountA Actual amount of underlying tokenA received\\n     @return amountB Actual amount of underlying tokenB received\\n    */\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override returns (uint256 amountA, uint256 amountB) {\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IImpossiblePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        return removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\\n    }\\n\\n    /**\\n     @notice Function for remove liquidity functionality using EIP712 permit with 1 token being WETH/WBNB\\n     @param token The address of the non-ETH underlying token to receive\\n     @param liquidity The amount of LP tokens to burn\\n     @param amountTokenMin The desired amount of non-ETH underlying token that has to be received\\n     @param amountETHMin The min amount of ETH that has to be received\\n     @param to The address to send underlying tokens to\\n     @param deadline The block number after which this transaction is invalid\\n     @param approveMax How much tokens are approved for transfer (liquidity, or max)\\n     @param v,r,s Variables that construct a valid EVM signature\\n     @return amountToken Actual amount of non-ETH underlying token received\\n     @return amountETH Actual amount of WETH/WBNB received\\n    */\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IImpossiblePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\\n    }\\n\\n    /**\\n     @notice Function for remove liquidity functionality with 1 token being WETH/WBNB\\n     @dev This is used when non-WETH/WBNB underlying token is fee-on-transfer: e.g. FEI algo stable v1\\n     @dev Openzeppelin reentrancy guards\\n     @param token The address of the non-ETH underlying token to receive\\n     @param liquidity The amount of LP tokens to burn\\n     @param amountTokenMin The desired amount of non-ETH underlying token that has to be received\\n     @param amountETHMin The min amount of ETH that has to be received\\n     @param to The address to send underlying tokens to\\n     @param deadline The block number after which this transaction is invalid\\n     @return amountETH Actual amount of WETH/WBNB received\\n    */\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) public virtual override ensure(deadline) nonReentrant returns (uint256 amountETH) {\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        IImpossiblePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (, amountETH) = IImpossibleRouterExtension(routerExtension).removeLiquidity(\\n            token,\\n            WETH,\\n            pair,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        unwrapSafeTransfer(token, to, IERC20(token).balanceOf(address(this)));\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    /**\\n     @notice Function for remove liquidity functionality using EIP712 permit with 1 token being WETH/WBNB\\n     @dev This is used when non-WETH/WBNB underlying token is fee-on-transfer: e.g. FEI algo stable v1\\n     @param token The address of the non-ETH underlying token to receive\\n     @param liquidity The amount of LP tokens to burn\\n     @param amountTokenMin The desired amount of non-ETH underlying token that has to be received\\n     @param amountETHMin The min amount of ETH that has to be received\\n     @param to The address to send underlying tokens to\\n     @param deadline The block number after which this transaction is invalid\\n     @param approveMax How much tokens are approved for transfer (liquidity, or max)\\n     @param v,r,s Variables that construct a valid EVM signature\\n     @return amountETH Actual amount of WETH/WBNB received\\n    */\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override returns (uint256 amountETH) {\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IImpossiblePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n            token,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            to,\\n            deadline\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImpossibleRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity >=0.6.2;\\n\\ninterface IImpossibleRouter {\\n    function factory() external view returns (address factoryAddr);\\n\\n    function routerExtension() external view returns (address routerExtensionAddr);\\n\\n    function wrapFactory() external view returns (address wrapFactoryAddr);\\n\\n    function WETH() external view returns (address WETHAddr);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pairFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrapFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_utilitySettingAdmin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETHSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerExtension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_routerExtension\",\"type\":\"address\"}],\"name\":\"setUtilities\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ImpossibleRouter", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004233ad9b8b7c1ccf0818907908a7f0796a3df85f000000000000000000000000f72255b8e25024ce3976d70dfbce8e437fe410e10000000000000000000000003c9584426432eb851e5689230d5cfc50659103d5", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1d47bb6aa4c4e5a635ca01716e6be81c6af6f3e867a84fc2495526c9765ca442"}