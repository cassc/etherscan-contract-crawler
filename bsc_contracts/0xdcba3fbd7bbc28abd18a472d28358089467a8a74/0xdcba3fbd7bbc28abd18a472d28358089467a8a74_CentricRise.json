{"SourceCode": "{\"Administrable.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.6;\\n\\nimport \\u0027./Claimable.sol\\u0027;\\n\\ncontract Administrable is Claimable {\\n    mapping(address =\\u003e bool) public isAdmin;\\n\\n    event AdminAppointed(address admin);\\n    event AdminDismissed(address admin);\\n\\n    constructor() {\\n        isAdmin[owner] = true;\\n\\n        emit AdminAppointed(owner);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin[msg.sender], \\u0027NOT_AN_ADMIN\\u0027);\\n        _;\\n    }\\n\\n    function appointAdmin(address _newAdmin) public onlyContractOwner() returns (bool success) {\\n        if (isAdmin[_newAdmin] == false) {\\n            isAdmin[_newAdmin] = true;\\n        }\\n\\n        emit AdminAppointed(_newAdmin);\\n        return true;\\n    }\\n\\n    function dismissAdmin(address _admin) public onlyContractOwner() returns (bool success) {\\n        isAdmin[_admin] = false;\\n\\n        emit AdminDismissed(_admin);\\n        return true;\\n    }\\n}\\n\"},\"BEP20.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.6;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./Administrable.sol\\u0027;\\n\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract BEP20 is IBEP20, Administrable {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    using SafeMath for uint256;\\n\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    uint256 private _totalBurnt;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function getOwner() public view override returns (address) {\\n        return owner;\\n    }\\n\\n    function totalBurnt() public view returns (uint256) {\\n        return _totalBurnt;\\n    }\\n\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n        require(spender != address(0), \\u0027spender cannot be address(0)\\u0027);\\n\\n        _allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public override returns (bool) {\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n        _transfer(from, to, value);\\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        require(spender != address(0), \\u0027spender cannot be address(0)\\u0027);\\n\\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        require(spender != address(0), \\u0027spender cannot be address(0)\\u0027);\\n\\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(from != address(0), \\u0027from cannot be address(0)\\u0027);\\n        require(to != address(0), \\u0027to cannot be address(0)\\u0027);\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0), \\u0027account cannot be address(0)\\u0027);\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\u0027account cannot be address(0)\\u0027);\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n\\n        _totalBurnt = _totalBurnt.add(value);\\n\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    function _burnFrom(address account, uint256 value) internal {\\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\\n        _burn(account, value);\\n    }\\n}\\n\"},\"CentricRise.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.6;\\n\\nimport \\u0027./BEP20.sol\\u0027;\\nimport \\u0027./RoundMath.sol\\u0027;\\nimport \\u0027./DateLib.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\nabstract contract SwapInterface {\\n    function totalSupply() public view virtual returns (uint256);\\n\\n    function balanceOf(address who) external view virtual returns (uint256);\\n\\n    function mintFromRise(address to, uint256 value) public virtual returns (bool);\\n\\n    function burnFromRise(address tokensOwner, uint256 value) external virtual returns (bool);\\n}\\n\\ncontract CentricRise is BEP20 {\\n    using RoundMath for uint256;\\n    using DateLib for uint256;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * STATE VARIABLES\\n     */\\n    address public swapContract;\\n    uint256 public quarantineBalance;\\n    uint256 public lastBlockNumber; // number of last created block\\n    uint256 public lastBalancedHour;\\n\\n    // Price of Rise in USD has base of PRICE_BASE\\n    uint256 constant PRICE_BASE = 10**8;\\n\\n    // Inital price of Rise in USD\\n    uint256 constant INITIAL_PRICE = 8302083331; // first block to mint is 450895 - $83.04040810\\n\\n    // Structure of a Price Block\\n    struct Block {\\n        uint256 risePrice; // USD price of Rise for the block\\n        uint256 growthRate; // FutureGrowthRate value at the time of block creation\\n        //solium-disable-next-line max-len\\n        uint256 change; // percentage (base of PRICE_BASE), RisePrice change relative to prev. block\\n        uint256 created; // hours, Unix epoch time\\n    }\\n\\n    // Price Blocks for a given hour (number of hours since epoch time)\\n    mapping(uint256 =\\u003e Block) public hoursToBlock;\\n\\n    /**\\n     * Price factors for months with [28, 29, 30, 31] days,\\n     * price factors determine compounding hourly growth\\n     * from the headling monthly growthRate,\\n     * calculated as (1+r)^(1/t)-1\\n     * where:\\n     * r - growthRate,\\n     * t - number of hours in a given month\\n     *\\n     * e.g.: for growthRate=2850 (2850/GROWTH_RATE_BASE=0.285=28.5%)\\n     * price factors are (considering PRICE_FACTOR_BASE): [37322249, 36035043, 34833666, 33709810]\\n     */\\n    mapping(uint256 =\\u003e uint256[4]) public growthRateToPriceFactors;\\n    uint256 constant GROWTH_RATE_BASE = 10**4;\\n    uint256 constant PRICE_FACTOR_BASE = 10**11;\\n\\n    bool public priceFactorsLocked = false;\\n\\n    event DoBalance(uint256 indexed currentHour, uint256 riseAmountBurnt);\\n\\n    event ConvertToSwap(\\n        address indexed converter,\\n        uint256 riseAmountSent,\\n        uint256 swapAmountReceived\\n    );\\n\\n    event ConvertToRise(\\n        address indexed converter,\\n        uint256 swapAmountSent,\\n        uint256 riseAmountReceived\\n    );\\n\\n    event MintSwap(address receiver, uint256 amount);\\n\\n    event BurnSwap(uint256 amountBurnt);\\n\\n    event PriceFactorSet(\\n        uint256 growthRate,\\n        uint256 priceFactor0,\\n        uint256 priceFactor1,\\n        uint256 priceFactor2,\\n        uint256 priceFactor3\\n    );\\n\\n    event BlockCreated(\\n        uint256 blockNumber,\\n        uint256 risePrice,\\n        uint256 growthRate,\\n        uint256 change,\\n        uint256 created\\n    );\\n\\n    event QuarantineBalanceBurnt(uint256 amount);\\n\\n    event LostTokensBurnt(uint256 amount);\\n\\n    /**\\n     * Creates Rise contract. Also sets the Swap address\\n     * to the contract storage to be able to interact with it.\\n     * Mints 1 billion tokens to _mintSaver address.\\n     */\\n    constructor(address _mintSaver, address _swapContract) BEP20(\\u0027Centric RISE\\u0027, \\u0027CNR\\u0027, 8) {\\n        _mint(_mintSaver, 100000000000000000); // 1 Billion\\n        swapContract = _swapContract;\\n    }\\n\\n    // Returns price of Rise for the current hour\\n    function getCurrentPrice() external view returns (uint256) {\\n        require(hoursToBlock[getCurrentHour()].risePrice \\u003e 0, \\u0027BLOCK_NOT_DEFINED\\u0027);\\n        return hoursToBlock[getCurrentHour()].risePrice;\\n    }\\n\\n    // Returns price of Rise at a specified hour\\n    function getPrice(uint256 _hour) external view returns (uint256) {\\n        require(hoursToBlock[_hour].risePrice \\u003e 0, \\u0027BLOCK_NOT_DEFINED\\u0027);\\n        return hoursToBlock[_hour].risePrice;\\n    }\\n\\n    /**\\n     *  Returns Price Block data\\n     *  uint256 risePrice;     // USD price of Rise for the block\\n     *  uint256 growthRate;    // growthRate value of the risePrice\\n     *  uint256 change;        // percentage (base of PRICE_BASE), RisePrice change relative to prev. block\\n     *  uint256 created;       // hours, unix epoch time\\n     */\\n    function getBlockData(uint256 _hoursEpoch)\\n        external\\n        view\\n        returns (\\n            uint256 _risePrice,\\n            uint256 _growthRate,\\n            uint256 _change,\\n            uint256 _created\\n        )\\n    {\\n        require(_hoursEpoch \\u003e 0, \\u0027EMPTY_HOURS_VALUE\\u0027);\\n        require(hoursToBlock[_hoursEpoch].risePrice \\u003e 0, \\u0027BLOCK_NOT_DEFINED\\u0027);\\n\\n        _risePrice = hoursToBlock[_hoursEpoch].risePrice;\\n        _growthRate = hoursToBlock[_hoursEpoch].growthRate;\\n        _change = hoursToBlock[_hoursEpoch].change;\\n        _created = hoursToBlock[_hoursEpoch].created;\\n\\n        return (_risePrice, _growthRate, _change, _created);\\n    }\\n\\n    /**\\n     * Single call creates ONE Price Block with specified monthly _growthRate.\\n     * For creating a batch of blocks function needs to be run according amount of times.\\n     * Admin should always make sure that there is a block for the currentHour\\n     * and if not - create it. Otherwise users will not be able to convert tokens\\n     * until a new block is created.\\n     * _blockNumber - always has to be lastBlockNumber + 1 (works only as a security check)\\n     * _growthRate - must be specified in growthRateToPriceFactors\\n     * percentage (fraction of 1, e.g.: 0.3)\\n     * presented as integer with base of GROWTH_RATE_BASE (to be divided by GROWTH_RATE_BASE to get a fraction of 1)\\n     */\\n    function doCreateBlock(uint256 _blockNumber, uint256 _growthRate)\\n        external\\n        onlyAdmin()\\n        returns (bool _success)\\n    {\\n        require(priceFactorsLocked, \\u0027PRICE_FACTORS_MUST_BE_LOCKED\\u0027);\\n\\n        require(_growthRate != 0, \\u0027GROWTH_RATE_CAN_NOT_BE_ZERO\\u0027);\\n        require(_growthRate \\u003c GROWTH_RATE_BASE, \\u0027GROWTH_RATE_IS_GREATER_THAN_GROWTH_RATE_BASE\\u0027);\\n        require(growthRateToPriceFactors[_growthRate][0] \\u003e 0, \\u0027GROWTH_RATE_IS_NOT_SPECIFIED\\u0027);\\n\\n        require(_createBlock(_blockNumber, _growthRate), \\u0027FAILED_TO_CREATE_BLOCK\\u0027);\\n        return true;\\n    }\\n\\n    /**\\n     * set growthRateToPriceFactors\\n     * _priceFactors - see comments for mapping growthRateToPriceFactors\\n     */\\n    function setPriceFactors(uint256 _growthRate, uint256[4] memory _priceFactors)\\n        external\\n        onlyAdmin()\\n        returns (bool _success)\\n    {\\n        require(priceFactorsLocked == false, \\u0027PRICE_FACTORS_ALREADY_LOCKED\\u0027);\\n\\n        require(_growthRate != 0, \\u0027GROWTH_RATE_CAN_NOT_BE_ZERO\\u0027);\\n        require(_growthRate \\u003c GROWTH_RATE_BASE, \\u0027GROWTH_RATE_IS_GREATER_THAN_GROWTH_RATE_BASE\\u0027);\\n\\n        require(_priceFactors[0] \\u003e 0, \\u0027PRICE_FACTOR_0_CAN_NOT_BE_ZERO\\u0027);\\n        require(_priceFactors[0] \\u003c 103200117, \\u0027PRICE_FACTOR_0_IS_TOO_BIG\\u0027);\\n        require(_priceFactors[1] \\u003e 0, \\u0027PRICE_FACTOR_1_CAN_NOT_BE_ZERO\\u0027);\\n        require(_priceFactors[1] \\u003c 99639720, \\u0027PRICE_FACTOR_1_IS_TOO_BIG\\u0027);\\n        require(_priceFactors[2] \\u003e 0, \\u0027PRICE_FACTOR_2_CAN_NOT_BE_ZERO\\u0027);\\n        require(_priceFactors[2] \\u003c 96316797, \\u0027PRICE_FACTOR_2_IS_TOO_BIG\\u0027);\\n        require(_priceFactors[3] \\u003e 0, \\u0027PRICE_FACTOR_3_CAN_NOT_BE_ZERO\\u0027);\\n        require(_priceFactors[3] \\u003c 93208356, \\u0027PRICE_FACTOR_3_IS_TOO_BIG\\u0027);\\n\\n        require(\\n            _priceFactors[0] \\u003e _priceFactors[1] \\u0026\\u0026\\n                _priceFactors[1] \\u003e _priceFactors[2] \\u0026\\u0026\\n                _priceFactors[2] \\u003e _priceFactors[3],\\n            \\u0027PRICE_FACTORS_ARE_NOT_VALID\\u0027\\n        );\\n\\n        growthRateToPriceFactors[_growthRate] = _priceFactors;\\n\\n        emit PriceFactorSet(\\n            _growthRate,\\n            _priceFactors[0],\\n            _priceFactors[1],\\n            _priceFactors[2],\\n            _priceFactors[3]\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * Call only after all priceFactors have been set\\n     * Call before creating first block\\n     */\\n    function lockPriceFactors() external onlyAdmin() returns (bool _success) {\\n        priceFactorsLocked = true;\\n        return true;\\n    }\\n\\n    /**\\n     * Public function that burns Rise from quarantine\\n     * according to the burnQuarantine() formula.\\n     * Needed for economic logic of Rise token.\\n     */\\n    function doBalance() external returns (bool _success) {\\n        require(hoursToBlock[getCurrentHour()].risePrice != 0, \\u0027CURRENT_PRICE_BLOCK_NOT_DEFINED\\u0027);\\n        require(lastBalancedHour \\u003c getCurrentHour(), \\u0027CHANGE_IS_ALREADY_BURNT_IN_THIS_HOUR\\u0027);\\n\\n        lastBalancedHour = getCurrentHour();\\n\\n        uint256 _riseBurnt = _burnQuarantined();\\n\\n        emit DoBalance(getCurrentHour(), _riseBurnt);\\n        return true;\\n    }\\n\\n    /**\\n     * Public function that allows users to convert Swap tokens to Rise ones.\\n     * Amount of received Rise tokens depends on the risePrice of the current block.\\n     */\\n    function convertToRise(uint256 _swapAmount) external returns (bool _success) {\\n        require(hoursToBlock[getCurrentHour()].risePrice != 0, \\u0027CURRENT_PRICE_BLOCK_NOT_DEFINED\\u0027);\\n\\n        require(\\n            SwapInterface(swapContract).balanceOf(msg.sender) \\u003e= _swapAmount,\\n            \\u0027INSUFFICIENT_SWAP_BALANCE\\u0027\\n        );\\n\\n        require(\\n            SwapInterface(swapContract).burnFromRise(msg.sender, _swapAmount),\\n            \\u0027BURNING_SWAP_FAILED\\u0027\\n        );\\n\\n        emit BurnSwap(_swapAmount);\\n\\n        uint256 _riseToDequarantine =\\n            (_swapAmount.mul(PRICE_BASE)).div(hoursToBlock[getCurrentHour()].risePrice);\\n\\n        quarantineBalance = quarantineBalance.sub(_riseToDequarantine);\\n        require(this.transfer(msg.sender, _riseToDequarantine), \\u0027CONVERT_TO_RISE_FAILED\\u0027);\\n\\n        emit ConvertToRise(msg.sender, _swapAmount, _riseToDequarantine);\\n        return true;\\n    }\\n\\n    /**\\n     * Public function that allows users to convert Rise tokens to Swap ones.\\n     * Amount of received Swap tokens depends on the risePrice of a current block.\\n     */\\n    function convertToSwap(uint256 _riseAmount) external returns (uint256) {\\n        require(hoursToBlock[getCurrentHour()].risePrice != 0, \\u0027CURRENT_PRICE_BLOCK_NOT_DEFINED\\u0027);\\n\\n        require(balanceOf(msg.sender) \\u003e= _riseAmount, \\u0027INSUFFICIENT_RISE_BALANCE\\u0027);\\n\\n        quarantineBalance = quarantineBalance.add(_riseAmount);\\n        require(transfer(address(this), _riseAmount), \\u0027RISE_TRANSFER_FAILED\\u0027);\\n\\n        uint256 _swapToIssue =\\n            (_riseAmount.mul(hoursToBlock[getCurrentHour()].risePrice)).div(PRICE_BASE);\\n\\n        require(\\n            SwapInterface(swapContract).mintFromRise(msg.sender, _swapToIssue),\\n            \\u0027SWAP_MINT_FAILED\\u0027\\n        );\\n\\n        emit MintSwap(msg.sender, _swapToIssue);\\n\\n        emit ConvertToSwap(msg.sender, _riseAmount, _swapToIssue);\\n        return _swapToIssue;\\n    }\\n\\n    /**\\n     * Function is needed to burn lost tokens that probably were sent\\n     * to the contract address by mistake.\\n     */\\n    function burnLostTokens() external onlyContractOwner() returns (bool _success) {\\n        uint256 _amount = balanceOf(address(this)).sub(quarantineBalance);\\n\\n        _burn(address(this), _amount);\\n\\n        emit LostTokensBurnt(_amount);\\n        return true;\\n    }\\n\\n    /**\\n     * Internal function that implements logic to burn a part of Rise tokens on quarantine.\\n     * Formula is based on network capitalization rules -\\n     * Network capitalization of quarantined Rise must be equal to\\n     * network capitalization of Swap\\n     * calculated as (q * pRISE - c * pSWAP) / pRISE\\n     * where:\\n     * q - quarantined Rise,\\n     * pRISE - current risePrice\\n     * c - current swap supply\\n     * pSwap - Swap pegged price ($1 USD fixed conversion price)\\n     */\\n    function _burnQuarantined() internal returns (uint256) {\\n        uint256 _quarantined = quarantineBalance;\\n        uint256 _currentPrice = hoursToBlock[getCurrentHour()].risePrice;\\n        uint256 _swapSupply = SwapInterface(swapContract).totalSupply();\\n\\n        uint256 _riseToBurn =\\n            ((((_quarantined.mul(_currentPrice)).div(PRICE_BASE)).sub(_swapSupply)).mul(PRICE_BASE))\\n                .div(_currentPrice);\\n\\n        quarantineBalance = quarantineBalance.sub(_riseToBurn);\\n        _burn(address(this), _riseToBurn);\\n\\n        emit QuarantineBalanceBurnt(_riseToBurn);\\n        return _riseToBurn;\\n    }\\n\\n    /**\\n     * Internal function for creating a new Price Block.\\n     */\\n    function _createBlock(uint256 _expectedBlockNumber, uint256 _growthRate)\\n        internal\\n        returns (bool _success)\\n    {\\n        uint256 _lastPrice;\\n        uint256 _nextBlockNumber;\\n\\n        if (lastBlockNumber == 0) {\\n            require(_expectedBlockNumber \\u003e getCurrentHour(), \\u0027FIRST_BLOCK_MUST_BE_IN_THE_FUTURE\\u0027);\\n            require(\\n                _expectedBlockNumber \\u003c getCurrentHour() + 365 * 24,\\n                \\u0027FIRST_BLOCK_MUST_BE_WITHIN_ONE_YEAR\\u0027\\n            );\\n            _lastPrice = INITIAL_PRICE;\\n            _nextBlockNumber = _expectedBlockNumber;\\n        } else {\\n            _lastPrice = hoursToBlock[lastBlockNumber].risePrice;\\n            _nextBlockNumber = lastBlockNumber.add(1);\\n        }\\n\\n        require(_nextBlockNumber == _expectedBlockNumber, \\u0027WRONG_BLOCK_NUMBER\\u0027);\\n\\n        uint256 _risePriceFactor;\\n\\n        uint256 _monthBlocks = (_nextBlockNumber * 60 * 60 * 1000).getHoursInMonth();\\n        if (_monthBlocks == 28 * 24) _risePriceFactor = growthRateToPriceFactors[_growthRate][0];\\n        else if (_monthBlocks == 29 * 24)\\n            _risePriceFactor = growthRateToPriceFactors[_growthRate][1];\\n        else if (_monthBlocks == 30 * 24)\\n            _risePriceFactor = growthRateToPriceFactors[_growthRate][2];\\n        else _risePriceFactor = growthRateToPriceFactors[_growthRate][3];\\n\\n        uint256 _risePrice =\\n            ((_risePriceFactor.mul(_lastPrice)).add(_lastPrice.mul(PRICE_FACTOR_BASE))).ceilDiv(\\n                PRICE_FACTOR_BASE\\n            );\\n\\n        uint256 _change = (_risePrice.sub(_lastPrice)).mul(PRICE_BASE).roundDiv(_lastPrice);\\n        uint256 _created = getCurrentHour();\\n\\n        hoursToBlock[_nextBlockNumber] = Block({\\n            risePrice: _risePrice,\\n            growthRate: _growthRate,\\n            change: _change,\\n            created: _created\\n        });\\n\\n        lastBlockNumber = _nextBlockNumber;\\n\\n        emit BlockCreated(_nextBlockNumber, _risePrice, _growthRate, _change, _created);\\n        return true;\\n    }\\n\\n    // For testing purposes\\n    function getCurrentTime() public view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    // Helper function\\n    function getCurrentHour() public view returns (uint256) {\\n        return getCurrentTime().div(1 hours);\\n    }\\n}\\n\"},\"Claimable.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.6;\\n\\nabstract contract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    function isOwner() public view returns (bool) {\\n        return (owner == msg.sender);\\n    }\\n\\n    modifier onlyContractOwner() {\\n        require(isOwner(), \\u0027Not a contract owner\\u0027);\\n        _;\\n    }\\n}\\n\\ncontract Claimable is Ownable {\\n    address public pendingOwner;\\n\\n    function transferOwnership(address _newOwner) public onlyContractOwner() {\\n        pendingOwner = _newOwner;\\n    }\\n\\n    function claimOwnership() public {\\n        require(msg.sender == pendingOwner, \\u0027Not a pending owner\\u0027);\\n\\n        address previousOwner = owner;\\n        owner = msg.sender;\\n        pendingOwner = address(0);\\n\\n        emit OwnershipTransferred(previousOwner, msg.sender);\\n    }\\n}\\n\"},\"DateLib.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.6;\\n\\nlibrary DateLib {\\n    uint256 constant DAY_IN_SECONDS = 86400;\\n    uint256 constant YEAR_IN_SECONDS = 31536000;\\n    uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\\n\\n    uint16 constant ORIGIN_YEAR = 1970;\\n\\n    function getHoursInMonth(uint256 _timestamp) internal pure returns (uint256) {\\n        uint256 timestamp = _timestamp / 1000;\\n\\n        uint256 secondsAccountedFor = 0;\\n        uint256 buf;\\n        uint8 i;\\n\\n        uint16 year;\\n        uint8 month;\\n\\n        // Year\\n        year = _getYear(timestamp);\\n        buf = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - buf);\\n\\n        // Month\\n        uint256 secondsInMonth;\\n        for (i = 1; i \\u003c= 12; i++) {\\n            secondsInMonth = DAY_IN_SECONDS * _getDaysInMonth(i, year);\\n            if (secondsInMonth + secondsAccountedFor \\u003e timestamp) {\\n                month = i;\\n                break;\\n            }\\n            secondsAccountedFor += secondsInMonth;\\n        }\\n\\n        return (_getDaysInMonth(month, year) * 24);\\n    }\\n\\n    function _getDaysInMonth(uint8 _month, uint16 _year) private pure returns (uint256) {\\n        if (\\n            _month == 1 ||\\n            _month == 3 ||\\n            _month == 5 ||\\n            _month == 7 ||\\n            _month == 8 ||\\n            _month == 10 ||\\n            _month == 12\\n        ) {\\n            return 31;\\n        } else if (_month == 4 || _month == 6 || _month == 9 || _month == 11) {\\n            return 30;\\n        } else if (isLeapYear(_year)) {\\n            return 29;\\n        } else {\\n            return 28;\\n        }\\n    }\\n\\n    function _getYear(uint256 _timestamp) private pure returns (uint16) {\\n        uint256 secondsAccountedFor = 0;\\n        uint16 year;\\n        uint256 numLeapYears;\\n\\n        // Year\\n        year = uint16(ORIGIN_YEAR + _timestamp / YEAR_IN_SECONDS);\\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\n\\n        while (secondsAccountedFor \\u003e _timestamp) {\\n            if (isLeapYear(uint16(year - 1))) {\\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n            } else {\\n                secondsAccountedFor -= YEAR_IN_SECONDS;\\n            }\\n            year -= 1;\\n        }\\n        return year;\\n    }\\n\\n    function isLeapYear(uint16 _year) private pure returns (bool) {\\n        if (_year % 4 != 0) {\\n            return false;\\n        }\\n        if (_year % 100 != 0) {\\n            return true;\\n        }\\n        if (_year % 400 != 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function leapYearsBefore(uint256 _year) private pure returns (uint256) {\\n        uint256 year = _year - 1;\\n        return year / 4 - year / 100 + year / 400;\\n    }\\n}\\n\"},\"RoundMath.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.6;\\n\\n/// @dev Math operations with safety checks that revert on error\\nlibrary RoundMath {\\n    /// @dev Integer division of two numbers rounding the quotient, reverts on division by zero.\\n    function roundDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\u0027DIVIDING_ERROR\\u0027);\\n        uint256 c = (((a * 10) / b) + 5) / 10;\\n        return c;\\n    }\\n\\n    /// @dev Integer division of two numbers ceiling the quotient, reverts on division by zero.\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\u0027DIVIDING_ERROR\\u0027);\\n        uint256 c = a / b;\\n        if (a % b \\u003e 0) {\\n            c = c + 1;\\n        }\\n        return c;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.6;\\n\\n/// @dev Math operations with safety checks that revert on error\\nlibrary SafeMath {\\n    /// @dev Multiplies two numbers, reverts on overflow.\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\u0027MUL_ERROR\\u0027);\\n\\n        return c;\\n    }\\n\\n    /// @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\u0027DIVIDING_ERROR\\u0027);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    /// @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\u0027SUB_ERROR\\u0027);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    /// @dev Adds two numbers, reverts on overflow.\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\u0027ADD_ERROR\\u0027);\\n        return c;\\n    }\\n\\n    /// @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero.\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\u0027MOD_ERROR\\u0027);\\n        return a % b;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mintSaver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminAppointed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminDismissed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"risePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"growthRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"change\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"}],\"name\":\"BlockCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBurnt\",\"type\":\"uint256\"}],\"name\":\"BurnSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"converter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"riseAmountReceived\",\"type\":\"uint256\"}],\"name\":\"ConvertToRise\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"converter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"riseAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapAmountReceived\",\"type\":\"uint256\"}],\"name\":\"ConvertToSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentHour\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"riseAmountBurnt\",\"type\":\"uint256\"}],\"name\":\"DoBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LostTokensBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"growthRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceFactor0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceFactor1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceFactor2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceFactor3\",\"type\":\"uint256\"}],\"name\":\"PriceFactorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"QuarantineBalanceBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"appointAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnLostTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapAmount\",\"type\":\"uint256\"}],\"name\":\"convertToRise\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_riseAmount\",\"type\":\"uint256\"}],\"name\":\"convertToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"dismissAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_growthRate\",\"type\":\"uint256\"}],\"name\":\"doCreateBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hoursEpoch\",\"type\":\"uint256\"}],\"name\":\"getBlockData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_risePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_growthRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_change\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_created\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentHour\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hour\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"growthRateToPriceFactors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hoursToBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"risePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"growthRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"change\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBalancedHour\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockPriceFactors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFactorsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quarantineBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_growthRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"_priceFactors\",\"type\":\"uint256[4]\"}],\"name\":\"setPriceFactors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CentricRise", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001ea71306849a189e17d00668eea81416e2f6d19d000000000000000000000000f6cb4ad242bab681effc5de40f7c8ff921a12d63", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://562cef5fb22f35271316dfd581aa36d0385add4d1743ee293c29f17ef247baa9"}