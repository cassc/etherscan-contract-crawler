{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/_erc/ERC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./IERC.sol\\\";\\r\\n\\r\\nabstract contract ERC is IERC20_ {\\r\\n    string  internal  _symbol;\\r\\n    uint8   internal  _decimals;\\r\\n    uint256 internal  _url;\\r\\n    uint256 internal  _ver;                             /// version\\r\\n    address internal  _owner;                           /// superuser\\r\\n    address internal  _minter;                          /// optional minter contract\\r\\n    ///////////////////////////////////////////////////////\\r\\n    struct Permit {\\r\\n        uint128 allowance;\\r\\n        uint128 limit;\\r\\n    }\\r\\n    uint256 internal  _totalSupply;\\r\\n    mapping(address => mapping(address => Permit))  internal _permits;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        uint256 max,                                    /// maximum tokens to mint, 0 as unlimited\\r\\n        uint160 owner,\\r\\n        uint256 version\\r\\n    ) {\\r\\n        unchecked {\\r\\n            address me = address(this);\\r\\n            uint128 mintable = (max == 0) ? Num.MAX128 : uint128(max);\\r\\n            _permits[me][_owner = address(owner)].limit =\\r\\n            _permits[Num._0][me].limit = mintable;      /// mintability\\r\\n            _ver = version;\\r\\n            _symbol = symbol_;\\r\\n            _decimals = decimals_;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    modifier ByMint() {\\r\\n        require(msg.sender == _minter,\\\"()\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function name() external view virtual override returns(string memory) {\\r\\n        uint256 url = _url;\\r\\n        return (url == 0) ? _symbol : _toString(url);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function symbol() public view virtual override returns(string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function decimals() external view virtual override returns(uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _permitted(address permitter, address permittee, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if((permitter == Num._0)                    /// this is exclusively for permission to config this contract\\r\\n             &&(permittee == _owner))                   /// and for contract owner only! (unconfiguratable after giving up ownership)\\r\\n                return true;\\r\\n            Permit memory permit = _permits[permitter][permittee];\\r\\n            if(permit.limit >= Num.MAX128)              /// permission between users enable futher uses of defi/game-fi\\r\\n                return true;\\r\\n            if(permit.limit < n)\\r\\n                return false;\\r\\n            permit.limit -= n;\\r\\n            _permits[permitter][permittee] = permit;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission can be issued exclusively by the permitter itself\\r\\n    function _issuePermit(address permitter, address permittee, uint256 amount) internal virtual returns(bool) {\\r\\n        uint256 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if((n == 0)||(permittee == permitter))\\r\\n                return false;\\r\\n            Permit memory p = _permits[permitter][permittee];\\r\\n            if(p.limit < Num.MAX128) {\\r\\n                n += p.limit;                           /// be careful to avoid overflow\\r\\n                p.limit = (n < Num.MAX128) ? uint128(n) : Num.MAX128;\\r\\n                _permits[permitter][permittee] = p;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission can be cancelled only by its holder!\\r\\n    function _cancelPermit(address permitter, address permittee, address payer, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if(permittee == permitter)\\r\\n                return false;\\r\\n            Permit memory p = _permits[permitter][permittee];\\r\\n            if(p.limit == 0)\\r\\n                return false;\\r\\n            if((n == 0)||(n >= p.limit))                /// cancel all of remaining permits\\r\\n                n = p.limit;\\r\\n            bool toAllowance = (payer == permitter);\\r\\n            if(toAllowance) {\\r\\n                amount = uint256(n)+p.allowance;        /// convert permission into allowance\\r\\n                p.allowance = (amount < Num.MAX128) ? uint128(amount) : Num.MAX128;\\r\\n            }\\r\\n            else {\\r\\n                Permit memory pay = _permits[payer][permitter];\\r\\n                if(pay.limit == 0)\\r\\n                    return false;\\r\\n                if(n > pay.limit) n = pay.limit;        /// cannot pass permits over payer's limit\\r\\n                if(pay.limit < Num.MAX128) {\\r\\n                    pay.limit -= n;                     /// (payer->permitter) permission reduced\\r\\n                    _permits[payer][permitter] = pay;\\r\\n                }\\r\\n                if(payer != permittee) {\\r\\n                    pay = _permits[payer][permittee];\\r\\n                    amount = uint256(n)+pay.limit;      /// pass permission to payer, or eliminate debt loop\\r\\n                    pay.limit = (amount < Num.MAX128) ? uint128(amount) : Num.MAX128;\\r\\n                    _permits[payer][permittee] = pay;\\r\\n                }\\r\\n            }\\r\\n            if(p.limit < Num.MAX128) p.limit -= n;      /// permission (permitter->permittee) cancelled\\r\\n            else if(!toAllowance)\\r\\n                return true;\\r\\n            _permits[permitter][permittee] = p;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission check (for owner) to config this contract\\r\\n    function _config(uint256 permission, uint256 value) internal virtual returns(bool) {\\r\\n        require(_permitted(Num._0,msg.sender,permission),\\\"!\\\");\\r\\n        return value >= 0;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _toString(uint256 u) internal view virtual returns(string memory) {\\r\\n        unchecked {\\r\\n            uint b;\\r\\n            for(; b < 256; b += 8)\\r\\n                if((0xFF&(u>>b)) == 0)\\r\\n                    break;\\r\\n            if(b == 0) return \\\"\\\";\\r\\n            bytes memory z = new bytes(b>>3);\\r\\n            for(uint i = 0; i < b; i += 8)\\r\\n                z[i>>3] = bytes1(uint8(u>>i));\\r\\n            u = _url;\\r\\n            return string(z);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./ERC.sol\\\";\\r\\n\\r\\ncontract ERC20 is ERC, IERC20 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    struct Account {\\r\\n        uint128 balance;                                /// account balance in weis, or the mapped lower 128b of escaped access\\r\\n        uint32  context;                                /// account context, or the mapped higher 32b of escaped access\\r\\n        uint96  escaped;\\r\\n    }\\r\\n    mapping(address => Account)                     internal _accounts;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        uint256 max,                                    /// maximum tokens to mint, 0 as unlimited\\r\\n        uint160 owner,\\r\\n        uint256 version\\r\\n    ) ERC(symbol_,decimals_,max,owner,version) {\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function totalSupply() external view virtual override returns(uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function balanceOf(address account) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            uint160 cmd;\\r\\n            address minter = _minter;\\r\\n            if(account == Num._0)                       /// burned tokens\\r\\n                return _accounts[Num._0].balance;\\r\\n            if(minter.code.length > 0) {                /// extended implementation in 'minter' contract\\r\\n                (v,cmd) = IESC20(minter).Insight(msg.sender,account,Num.NULL);\\r\\n                if(cmd == 0) return v;\\r\\n            }\\r\\n            (v,cmd) = _insight(account,Num.NULL);\\r\\n            if(cmd == 0) return v;                      /// escaped addresses are handled as following\\r\\n            if(cmd == Num.VERSION   ) return _ver;\\r\\n            if(cmd == Num.OWNER     ) return uint160(_owner);\\r\\n            if(cmd == Num.DELEGATE  ) return uint160(_minter);\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function allowance(address owner, address spender) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            if(spender == Num._0) v = _permits[owner][msg.sender].limit;\\r\\n            else if(owner == Num._0) v = _permits[msg.sender][spender].limit;\\r\\n            else {\\r\\n                uint160 cmd;\\r\\n                address minter = _minter;\\r\\n                if(minter.code.length > 0) {            /// extended implementation in 'minter' contract\\r\\n                    (v,cmd) = IESC20(minter).Insight(msg.sender,owner,spender);\\r\\n                    if(cmd == 0) return v;\\r\\n                }\\r\\n                (v,cmd) = _insight(owner,spender);\\r\\n                if(cmd == 0) return v;                  /// escaped addresses are handled as following\\r\\n                if(cmd == Num.BALANCE) return _accounts[spender].balance;\\r\\n                if(cmd == Num.ESCAPED) return _accounts[spender].escaped;\\r\\n                return 0;\\r\\n            }\\r\\n            return (v == Num.MAX128) ? Num.MAX256 : v;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function approve(address spender, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,spender,Num.NULL,amount))\\r\\n                    return true;\\r\\n            _permits[msg.sender][spender].allowance = uint128(amount);\\r\\n            emit Approval(msg.sender,spender,amount);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transfer(address to, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            if(amount == 0)                             /// transfer owner when called by owner and 'amount'== 0\\r\\n                if(_transferOwner(msg.sender,to))\\r\\n                    return true;\\r\\n            if(to < Num.MAP_)                           /// burn tokens if 'to'== 0x0~0xF\\r\\n                return _burn(msg.sender,amount);\\r\\n            address minter = _minter;\\r\\n            if(minter == msg.sender)                    /// mintable by 'minter' contract only\\r\\n                return _mint(to,amount);\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,Num.NULL,to,amount))\\r\\n                    return true;\\r\\n            uint160 cmd = _transfer(Num.NULL,to,amount);\\r\\n            if(cmd == 0) return true;                   /// escaped addresses are handled as following\\r\\n            if(cmd == Num.URL) return _config(cmd,_url = amount);\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transferFrom(address from, address to, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(cmd == Num._900)                         /// for extenal to verify/spend permission between users\\r\\n                return _permitted((msg.sender == minter) ? Num._0 : msg.sender,to,amount);\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,from,to,amount))\\r\\n                    return true;\\r\\n            if(_transfer(from,to,amount) == 0)\\r\\n                return true;                            /// escaped addresses are handled as following\\r\\n            if(cmd == Num.DEBT) return _issuePermit(msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTOFF) return _cancelPermit(to,msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTPASS) return _cancelPermit(to,msg.sender,address(uint160(amount)),uint128(amount>>160));\\r\\n            if(cmd == Num.DELEGATE) return _config(cmd,uint160(_minter = to));\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _insight(address from, address to) internal virtual view returns(uint256,uint160) {\\r\\n        unchecked {\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(Num._Escaped(from))                      /// escaped address handling, overridable in sub class if necessary\\r\\n                return (0,cmd);\\r\\n            if(to == Num.NULL)                          /// called by 'balanceOf()'\\r\\n                return (_accounts[from].balance,0);\\r\\n            uint128 a = _permits[from][to].allowance;   /// called by 'allowance()'\\r\\n            uint256 v = (a == Num.MAX128) ? Num.MAX256 : a;\\r\\n            return (v,0);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _transferOwner(address from, address to) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            if(Num._Escaped(to)||(from == to))\\r\\n                return false;\\r\\n            require(from == _owner,\\\"!\\\");                /// only owner can transfer his ownership\\r\\n            if((_owner = to) == Num._0)                 /// transfer owner\\r\\n                emit Transfer(from,to,0);               /// the ownership is permanently given up when 'to'== 0x0\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// possibly overrided by sub class\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual returns(uint160) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            bool directpay = (from == Num.NULL);        /// if called by 'transfer()'\\r\\n            address map = directpay ? to : from;\\r\\n            if(Num._Escaped(map))                       /// escaped address handling, overridable in sub class if necessary\\r\\n                return uint160(map);\\r\\n            if(directpay) from = msg.sender;\\r\\n            if((from == to)||(to == Num._0)||(n == 0))\\r\\n                return 0;\\r\\n            if(msg.sender != from)                        /// check/spend allowance if necessary\\r\\n                _spend(from,n);\\r\\n            Account memory a = _accounts[from];\\r\\n            require(a.balance >= n,\\\"$\\\");                /// revert if insufficient fund of 'from'\\r\\n            a.balance -= n;\\r\\n            _accounts[from] = a;\\r\\n            _accounts[to].balance += n;\\r\\n            if((from != Num._0)                         /// event in _mint()\\r\\n               &&(to != Num._0))                        /// event in _burn()\\r\\n                emit Transfer(from,to,n);\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// spend allowance in transferFrom()\\r\\n    function _spend(address from, uint128 n) internal virtual {\\r\\n        unchecked {\\r\\n            Permit memory permit = _permits[from][msg.sender];\\r\\n            if(permit.allowance >= Num.MAX128)          /// infinte allowance\\r\\n                return;\\r\\n            if(permit.allowance >= n)                   /// bingo\\r\\n                permit.allowance -= n;\\r\\n            else {                                      /// uncommon path: permit.limit is introduced for further defi uses\\r\\n                if(permit.limit < Num.MAX128) {         /// and is exclusively issued by owner\\r\\n                    n -= permit.allowance;\\r\\n                    require(permit.limit >= n,\\\"*\\\");\\r\\n                    permit.limit -= n;\\r\\n                } else if(permit.allowance == 0)        /// gas saving\\r\\n                    return;\\r\\n                permit.allowance = 0;\\r\\n            }\\r\\n            _permits[from][msg.sender] = permit;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _burn(address from, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            Account memory a = _accounts[from];\\r\\n            require(a.balance >= n,\\\"$\\\");\\r\\n            _totalSupply -= n;\\r\\n            a.balance -= n;\\r\\n            _accounts[from] = a;\\r\\n            _accounts[Num._0].balance += n;\\r\\n            emit Transfer(from,Num._0,n);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// possibly overrided by sub class\\r\\n    function _mint(address to, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            Permit memory reserve = _permits[Num._0][address(this)];\\r\\n            if(reserve.limit < Num.MAX128) {            /// default implementation to constrain minting limit\\r\\n                if(reserve.limit < n)\\r\\n                    n = reserve.limit;\\r\\n                reserve.limit -= n;\\r\\n                _permits[Num._0][address(this)] = reserve;\\r\\n            }\\r\\n            _totalSupply += n;\\r\\n            _accounts[to].balance += n;\\r\\n            emit Transfer(Num._0,to,n);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/IERC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\n/// import \\\"hardhat/console.sol\\\";\\r\\n\\r\\ninterface IERC20_ {\\r\\n    /////////////////////////////////////////////////////// interface of the ERC20 standard as defined in the EIP\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\ninterface IERC20 is IERC20_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Receiver {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function onERC20Received(address from, address to, uint256 amount, uint256 data) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface IERC721Receiver {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\r\\n}\\r\\ninterface IERC165 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\ninterface IERC721Enumerable_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function totalSupply() external view returns(uint256);\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns(uint256);\\r\\n    function tokenByIndex(uint256 index) external view returns(uint256);\\r\\n}\\r\\ninterface IERC721Metadata_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function name() external view returns(string memory);\\r\\n/// function symbol() external view returns(string memory);\\r\\n    function tokenURI(uint256 tokenId) external view returns(string memory);\\r\\n}\\r\\ninterface IERC721_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function balanceOf(address owner) external view returns(uint256 balance);\\r\\n    function ownerOf(uint256 tokenId) external view returns(address);\\r\\n    function getApproved(uint256 tokenId) external view returns(address);\\r\\n    function isApprovedForAll(address owner, address operator) external view returns(bool);\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n/// function approve(address to, uint256 tokenId) external;\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n}\\r\\ninterface IESC20 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Insight(address caller, address from, address to) external view returns(uint256,uint160);\\r\\n    function Escape(address caller, address from, address to, uint256 amount) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface ISwap {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Swap(\\r\\n        address payer,                                  /// shall =caller if 'token' != USSSD\\r\\n                                                        /// or, caller must own a debt of payer and owe to this contract\\r\\n        uint256 amount,                                 /// amount of 'token' to sell\\r\\n        address token,                                  /// IERC20 token to sell\\r\\n        address tokenToReceive,                         /// IERC20 token to receive\\r\\n        uint256 minToReceive,                           /// minimum amount of 'tokenToReceive' to swap\\r\\n        address recipient                               /// target wallet\\r\\n    ) external returns(uint256);                        /// actual tokens received\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Estimate(uint256 amount, address token, address tokenToReceive) external view returns(uint256);\\r\\n}\\r\\n\\r\\n///////////////////////////////////////////////////////////\\r\\ninterface IDaoAgency {\\r\\n    function ApplyDao(address agent) external returns (address);\\r\\n}\\r\\n\\r\\nlibrary Num {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant MAX256      = type(uint256).max;\\r\\n    uint256 public constant MAX160      = type(uint160).max;\\r\\n    uint128 public constant MAX128      = type(uint128).max;\\r\\n    uint64  public constant MAX64       = type(uint64 ).max;\\r\\n    uint32  public constant MAX32       = type(uint32 ).max;\\r\\n    uint256 public constant GWEI        = 10**9;\\r\\n    uint256 public constant TWEI        = 10**12;\\r\\n    uint256 public constant _0_000001   = 10**12;\\r\\n    uint256 public constant _0_00001    = 10**13;\\r\\n    uint256 public constant _0_0001     = 10**14;\\r\\n    uint256 public constant _0_001      = 10**15;\\r\\n    uint256 public constant _0_01       = 10**16;\\r\\n    uint256 public constant _0_1        = 10**17;\\r\\n    uint256 public constant _1          = 10**18;\\r\\n    uint256 public constant _10         = 10**19;\\r\\n    uint256 public constant _100        = 10**20;\\r\\n    uint256 public constant _1000       = 10**21;\\r\\n    uint256 public constant _10000      = 10**22;\\r\\n    uint256 public constant _100000     = 10**23;\\r\\n    uint256 public constant _1000000    = 10**24;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant CENT        = 10**16;\\r\\n    uint256 public constant DIME        = 10**17;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    address public constant _0          = address(0);\\r\\n    address public constant MAP_        = address(0x10);\\r\\n    address public constant _MAP        = address(0xFFFFFFFFFF);\\r\\n    address public constant ESC         = address(0xFFFFFFFFFFFFFFFF);\\r\\n    address public constant NULL        = address(type(uint160).max);\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Mapped(address a) internal pure returns(bool) {\\r\\n        return (MAP_ <= a)&&(a <= _MAP);\\r\\n    }\\r\\n    function _Mapped(address a, address b) internal pure returns(bool) {\\r\\n        return _Mapped((a != NULL) ? a : b);\\r\\n    }\\r\\n    function _Escaped(address a) internal pure returns(bool) {\\r\\n        return (MAP_ <= a)&&(a <= ESC);\\r\\n    }\\r\\n    function _Escaped(address a, address b) internal pure returns(bool) {\\r\\n        return _Escaped((a != NULL) ? a : b);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant _900        =  0x900;\\r\\n    uint160 public constant URL         =  0x192;\\r\\n    uint160 public constant GAS         =  0x9a5;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant SN          =   0x50;\\r\\n    uint160 public constant VERSION     =   0x51;\\r\\n    uint160 public constant VER2        =   0x52;\\r\\n    uint160 public constant ACCOUNT     =   0xAC;\\r\\n    uint160 public constant BLK         =   0xB1;\\r\\n    uint160 public constant HASH        =   0xB5;\\r\\n    uint160 public constant BALANCE     =   0xBA;\\r\\n    uint160 public constant ESCAPE      =   0xE5;\\r\\n    uint160 public constant ESCAPED     =   0xED;\\r\\n    uint160 public constant CTX         =   0xFC;\\r\\n    uint160 public constant STATUS      =   0xFF;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant USD         = 0xadd0;\\r\\n    uint160 public constant USD1        = 0xadd1;\\r\\n    uint160 public constant USD2        = 0xadd2;\\r\\n    uint160 public constant TOKEN       = 0xadd8;\\r\\n    uint160 public constant USD_        = 0xadd9;\\r\\n    uint160 public constant NFT         = 0xaddA;\\r\\n    uint160 public constant BIND        = 0xaddB;\\r\\n    uint160 public constant SWAP        = 0xaddC;\\r\\n    uint160 public constant DAO         = 0xaddD;\\r\\n    uint160 public constant OWNER       = 0xaddE;\\r\\n    uint160 public constant DELEGATE    = 0xaddF;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant DEBT        = 0xDeb0;\\r\\n    uint160 public constant DEBTOFF     = 0xDeb1;\\r\\n    uint160 public constant DEBTPASS    = 0xDeb2;\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/USSSD.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\n\\r\\ninterface ISSSwap is IESC20, ISwap {\\r\\n    function Balance(address u, uint256 balance, int256 perK) external view returns(uint256);\\r\\n    function Budget(address token, address owner, address spender, uint256 balance, uint256 limit) external view returns(uint256);\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Rebalance(address u) external returns(uint256);\\r\\n    function Buy(uint256 usdPaid, address tokenToBuy, address recipient) external returns(uint256);\\r\\n}\\r\\n\\r\\ncontract USSSD is ERC20 {\\r\\n    address internal  _usd;                             /// wrapped stablecoin depending on chain: USDC on [ETH], USDT on [BNB/TRON]\\r\\n    uint24  internal  _daos;                            /// up to date prefix for registered dao addresse\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        uint256 build,\\r\\n        address publisher\\r\\n    ) ERC20(\\\"U$D\\\",18,0,uint160(build),uint160(publisher)) {\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _Rebind(address mint) internal returns(uint256) {\\r\\n        unchecked {\\r\\n            _minter = mint;\\r\\n            uint256 usd;\\r\\n            if(mint.code.length > 0) {\\r\\n                (usd,) = IESC20(mint).Insight(address(this),address(Num.USD),Num.NULL);\\r\\n                _usd = address(uint160(usd));\\r\\n            }\\r\\n            return usd;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Budget(address token, address owner, address spender) internal view returns(uint256) {\\r\\n        unchecked {\\r\\n            Permit memory p = _permits[owner][spender];\\r\\n            uint256 limit = uint256(p.allowance)+p.limit;\\r\\n            uint256 balance = _accounts[owner].balance;\\r\\n            return ISSSwap(_minter).Budget(token,owner,spender,balance,limit);\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// burn U$D and return wrapped USD (USDT e.g.) or other tokens\\r\\n    function _BurnToReturn(address minter, address account, uint128 n, uint160 token, address recipient) internal returns(bool) {\\r\\n        unchecked {\\r\\n            Account memory a = _accounts[account];\\r\\n            if((n == 0)||(n > a.balance))               /// burn all\\r\\n                n = uint128(a.balance);\\r\\n            if(n == 0)\\r\\n                return false;\\r\\n            bool directpay = (token == Num.USD);        /// no swapping need when returning wrapped USD tokens\\r\\n            if(!IERC20(_usd).transfer(directpay ? recipient : minter,n))\\r\\n                return false;\\r\\n            a.balance -= n;\\r\\n            _accounts[account] = a;\\r\\n            if(!directpay)                              /// swapping is involed when returning other tokens\\r\\n                ISSSwap(minter).Buy(n,address(token),recipient);\\r\\n            _totalSupply -= n;                          /// burned\\r\\n            _accounts[Num._0].balance += n;\\r\\n            emit Transfer(account,Num._0,n);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// apply DAO to get a mapped address and post-transfer event calls\\r\\n    function _RegisterDao(address applicant, uint32 commission) internal returns(bool) {\\r\\n        unchecked {\\r\\n            Account memory a;\\r\\n            uint160 dao = uint160(applicant);\\r\\n            a.balance = uint128(dao);\\r\\n            a.context = uint32(dao>>128);\\r\\n            dao = _daos;\\r\\n            require(dao < 0xFFFFFF,'@');                /// run out-of registerable limit\\r\\n            _daos = uint24(++ dao);\\r\\n            _accounts[address(dao<<40)] = a;            /// create mapped DAO account\\r\\n            a = _accounts[applicant];\\r\\n            a.escaped = uint96(dao<<72);\\r\\n            a.context = commission;                     /// applicant's commission rate: 25% = 1<<30\\r\\n            _accounts[applicant] = a;                   /// update applicant's account\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// find mapped DAO address for escaped access\\r\\n    function _MapToDao(address to, uint128 n) internal virtual returns(address,uint128) {\\r\\n        unchecked {\\r\\n            address dao = address(uint160(to)&~uint160(Num._MAP));\\r\\n            Account memory a = _accounts[dao];\\r\\n            to = address((uint160(a.context)<<128)|a.balance);\\r\\n            require(to != Num._0,\\\"@\\\");\\r\\n            uint256 commission = _accounts[to].context;\\r\\n            if(commission > 0) {                        /// charge commission for escapped transactions if applicable\\r\\n                uint96 escaped = uint96((commission*n)>>32);\\r\\n                if(escaped > 0) {\\r\\n                    a.escaped += escaped;               /// accumulate commission contribution of given escaped account\\r\\n                    _accounts[dao] = a;\\r\\n                    n -= escaped;\\r\\n                    address owner = _owner;             /// commssion goes to contract owner (if there is one)\\r\\n                    _accounts[(owner == Num._0) ? address(this) : owner].balance += escaped;\\r\\n                }\\r\\n            }\\r\\n            return (to,n);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Escape(uint160 cmd, address to, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if(to == Num.NULL) {                        /// called by 'transfer()'\\r\\n            } else {                                    /// called by 'transferFrom()'\\r\\n                if(cmd == Num.DELEGATE  ) return _config(cmd,_Rebind(to));\\r\\n                if(cmd == Num.TOKEN     ) return _BurnToReturn(_minter,msg.sender,n,uint160(to),msg.sender);\\r\\n                if((cmd == Num.GAS)                     /// e.g. BSC: buy BNB\\r\\n                 ||(cmd == Num.USD)                     /// e.g. BSC: return USDT\\r\\n                 ||(cmd == Num.USD1)                    /// e.g. BSC: return USDC\\r\\n                 ||(cmd == Num.USD2))                   /// e.g. BSC: return BUSD\\r\\n                    return _BurnToReturn(_minter,msg.sender,n,cmd,to);\\r\\n            }\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function approve(address spender, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            if(msg.sender == _minter)                   /// only 'minter' is allowed to register DAO\\r\\n                return _RegisterDao(spender,uint32(amount));\\r\\n            _permits[msg.sender][spender].allowance = uint128(amount);\\r\\n            emit Approval(msg.sender,spender,amount);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _burn(address from, uint256 amount) override internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if(from == Num._0)\\r\\n                return false;\\r\\n            address minter = _minter;\\r\\n            ISSSwap(minter).Rebalance(from);\\r\\n            return _BurnToReturn(minter,from,n,Num.USD,from);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _mint(address to, uint256 amount) override internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            _totalSupply += n;\\r\\n            _accounts[to].balance += n;\\r\\n            emit Transfer(Num._0,to,n);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _insight(address from, address to) override internal virtual view returns(uint256,uint160) {\\r\\n        unchecked {\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(Num._Mapped(from)) {\\r\\n                if(to == Num.NULL) {                    /// called by 'balanceOf()'\\r\\n                    if(cmd == Num.DAO       ) return (Num._1*_daos,0);\\r\\n                } else {                                /// called by 'allowance()'\\r\\n                    if(cmd == Num.DAO       ) return (Num._1*(_accounts[to].escaped>>72),0);\\r\\n                    if(cmd == Num.ESCAPE    ) return ((Num._100*_accounts[to].context)>>32,0);\\r\\n                    if(cmd == Num.TOKEN     ) return (_Budget(to,msg.sender,_minter),0);\\r\\n                    if(cmd == Num.STATUS    ) return (_Budget(address(this),to,to),0);\\r\\n                }\\r\\n                return (0,cmd);\\r\\n            }\\r\\n            if(to == Num.NULL) {                        /// called by 'balanceOf()'\\r\\n                Account memory acc = _accounts[from];\\r\\n                if(from > Num.ESC)                      /// return a normal user's total balance\\r\\n                    return (ISSSwap(_minter).Balance(from,acc.balance,1024),0);\\r\\n                return ((uint160(acc.context)<<128)\\r\\n                                |acc.balance,           /// get DAO contract address from its mapped address\\r\\n                                0);\\r\\n            }\\r\\n            uint128 a = _permits[from][to].allowance;   /// called by 'allowance()'\\r\\n            uint256 v = (a == Num.MAX128) ? Num.MAX256 : a;\\r\\n            return (v,0);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _transfer(address from, address to, uint256 amount) override internal virtual returns(uint160) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            if(minter.code.length > 0)                  /// pledge unhandled USDT/USDC etc. for 'operator'\\r\\n                ISSSwap(minter).Rebalance(msg.sender);\\r\\n            bool directpay = (from == Num.NULL);        /// called by 'transfer()'\\r\\n            address map = directpay ? to : from;\\r\\n            uint160 cmd = uint160(map);\\r\\n            if(Num._Mapped(map))                        /// handle escapped address\\r\\n                return _Escape(cmd,directpay ? Num.NULL : to,amount) ? 0 : cmd;\\r\\n            uint128 m = uint128(amount);\\r\\n            uint128 n = m;\\r\\n            address arg = to;\\r\\n            if(map > Num.ESC) {                         /// normal user address\\r\\n                if(directpay) from = msg.sender;\\r\\n            } else if(map <= Num._MAP)\\r\\n                map = Num.NULL;\\r\\n            else {                                      /// mapped DAO address\\r\\n                if(directpay) arg = msg.sender;\\r\\n                (to,n) = _MapToDao(map,n);\\r\\n                from = msg.sender;\\r\\n            }\\r\\n            if(msg.sender != from) {                    /// check/spend allowance for 'transferFrom()'\\r\\n                ISSSwap(minter).Rebalance(from);        /// pledge unhandled USDT/USDC etc. for 'from'\\r\\n                if(m > 0) _spend(from,m);\\r\\n            }\\r\\n            if(m > 0) {\\r\\n                if(to < Num.MAP_)\\r\\n                    return _burn(to,n) ? 0 : 0;\\r\\n                Account memory a = _accounts[from];\\r\\n                require(a.balance >= m,\\\"$\\\");\\r\\n                a.balance -= m;\\r\\n                _accounts[from] = a;\\r\\n                _accounts[to].balance += n;\\r\\n                ISSSwap(minter).Rebalance(to);          /// pledge unhandled USDT/USDC etc. for 'to'\\r\\n            }\\r\\n            if((map <= Num.ESC)&&(to.code.length > 0))  /// notify escaped recipient (contract) address\\r\\n                IERC20Receiver(to).onERC20Received(msg.sender,arg,n,cmd);\\r\\n            if((from != Num._0)                         /// event in _mint()\\r\\n               &&(to != Num._0))                        /// event in _burn()\\r\\n                emit Transfer(from,to,m);\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"build\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"publisher\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "USSSD", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001e092827737257ccffaf783cb4b792d1f240fa37000000000000000000000000f2af5b171cc1b46908a8d91b335c20f8bb76e120", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3c47fe2f69ba1b1872ef342013e4b979b89890d2bb688ba8c4e33f57f6bb14a9"}