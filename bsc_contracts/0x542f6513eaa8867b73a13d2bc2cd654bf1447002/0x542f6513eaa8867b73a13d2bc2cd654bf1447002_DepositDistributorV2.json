{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/DepositDistributorV2.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ncontract DepositDistributorV2 is ERC1155Holder, Ownable, ReentrancyGuard {\\n\\n// ERC1155 token and deposit-related state variables\\n    IERC1155 public erc1155Token; // ERC1155 token interface\\n   \\n    uint256 public gasReserve; // Ether reserve for gas costs\\n\\n    uint256 private daoTokenId; // DAO token ID\\n\\n\\n    bool public paused = false;\\n\\n\\n    // Staking-related state variables\\n    mapping(address => uint256) public stakedAt; // Timestamp when a user staked their tokens\\n    mapping(address => uint256) public stakedTokens; // Mapping of staked tokens per user\\n    address[] public stakedUsers; // Array of staked user addresses\\n    mapping(address => uint256) public stakedBalances; // Mapping of staked token balances per user\\n    mapping(address => uint256) public stakedUserIndexes; // Mapping of user indexes in the stakedUsers array\\n    uint256 public constant MINIMUM_STAKING_DURATION = 21 days; // Minimum staking duration\\n\\n    // Deposit-related state variables\\n    mapping(uint256 => uint256) public depositTimestamps; // Mapping of deposit timestamps\\n    mapping(address => uint256) public balances; // Mapping of user balances\\n    mapping(address => mapping(uint256 => bool)) private claimed; // Mapping of claimed deposits per user\\n    mapping(address => bool) public allowList; // Mapping of allowed addresses for depositing\\n   \\n    uint256 private totalDeposits; // Total deposits for rewards distribution\\n    uint256 private totalDeposited; // Total deposited funds in the contract\\n\\n\\n    mapping(address => mapping(address => uint256)) private balancesTokensErc20; // balances[token][user]\\n    uint256 private totalDepositsErc20; // Total deposits for rewards distribution\\n    mapping(address => mapping(uint256 => bool)) private claimedErc20; // Mapping of claimed deposits per user\\n    mapping(address => uint256) private totalDepositedTokensErc20; // totalDeposited[token]\\n\\n    mapping(address => mapping(uint256 => mapping(address => uint256))) private balancesERC1155; // balancesERC1155[token][tokenId][user]\\n    mapping(address => mapping(uint256 => uint256)) private totalDepositedERC1155; // totalDepositedERC1155[token][tokenId]\\n    mapping(address => mapping(uint256 => bool)) private claimedERC1155;\\n    uint256 private totalDepositsErc1155; // Total deposits for rewards distributionEr\\n\\n\\n    uint256 private daoTokenTotalSupply; // Total supply of the DAO token\\n\\n    // Beneficiary state variable\\n    address public theGameDAOTreasury; // Address of the theGameDAOTreasury for unclaimed rewards\\n    address public unclaimedErc1155Receiver; // Address of the theGameDAOTreasury for unclaimed rewards\\n\\n    // Events declaration\\n    event Deposited(\\n        address indexed depositor,\\n        uint256 amount,\\n        uint256 totalDeposited\\n    );\\n    event Distributed(uint256 totalDistributed, uint256 unclaimedRewards);\\n    event DistributedErc20(uint256 totalDistributedErc20, uint256 unclaimedRewards);\\n    event DistributedErc1155(uint256 totalDistributedErc1155, uint256 unclaimedRewards);\\n\\n\\n    event DepositedErc20(\\n        address indexed depositor,\\n        address token,\\n        uint256 tokenId,\\n        uint256 totalDepositedTokensErc20\\n    );\\n\\n    event DepositedErc1155(\\n        address indexed depositor,\\n        address token,\\n        uint256 tokenId,\\n        uint256 totalDepositedTokensErc1155\\n    );\\n\\n    \\n\\n    event Claimed(address indexed claimer, uint256 amount);\\n    event ClaimedErc20(address indexed claimer, uint256 amountErc20);\\n    event ClaimedEc1155(address indexed claimer, uint256 amountErc1155);\\n\\n    event Staked(address indexed staker, uint256 amount);\\n    event Unstaked(address indexed unstaker, uint256 amount);\\n\\n    constructor(\\n        address _erc1155StakeToken,\\n        address _unclaimedErc1155Receiver,\\n        uint256 _daoTokenId,\\n        address _theGameDAOTreasury,\\n        uint256 _initialTotalSupply\\n    ) Ownable() {\\n        erc1155Token = IERC1155(_erc1155StakeToken);\\n        daoTokenId = _daoTokenId;\\n        theGameDAOTreasury = _theGameDAOTreasury;\\n        unclaimedErc1155Receiver = _unclaimedErc1155Receiver;\\n        daoTokenTotalSupply = _initialTotalSupply;\\n\\n    }\\n\\n\\n    // Function to deposit Ether for gas costs\\n    function depositForGas() external payable onlyOwner {\\n        require(msg.value > 0, \\\"No ether provided\\\");\\n        gasReserve += msg.value; // Add the received Ether to the gas reserve\\n    }\\n\\n    // Function to withdraw Ether for gas costs\\n    function withdrawForGas(uint256 amount) external onlyOwner {\\n        require(amount <= gasReserve, \\\"Insufficient gas reserve\\\");\\n        gasReserve -= amount; // Deduct the amount from the gas reserve\\n        (bool success, ) = payable(owner()).call{value: amount}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    // Function to deposit ERC1155 tokens restricted to addresses on the allow list\\n    function depositERC1155(address token, uint256 tokenId, uint256 amount) external onlyAllowList {\\n    // Transfer ERC1155 tokens to this contract\\n    IERC1155(token).safeTransferFrom(msg.sender, address(this), tokenId, amount, \\\"\\\");\\n\\n    totalDepositedERC1155[token][tokenId] += amount;\\n    distributeERC1155(token, tokenId);\\n\\n    depositTimestamps[totalDeposits] = block.timestamp;\\n\\n    totalDeposits += 1;\\n\\n    emit DepositedErc1155(msg.sender, token, tokenId, totalDepositedERC1155[token][tokenId]);\\n}\\n\\n    function distributeERC1155(address token, uint256 tokenId) private  {\\n    if (stakedUsers.length == 0) {\\n        IERC1155(token).safeTransferFrom(address(this), unclaimedErc1155Receiver, tokenId, totalDepositedERC1155[token][tokenId], \\\"\\\");\\n        totalDepositedERC1155[token][tokenId] = 0;\\n    }\\n\\n    uint256 totalDistributed = 0;\\n\\n    for (uint256 i = 0; i < stakedUsers.length; i++) {\\n        address member = stakedUsers[i];\\n        uint256 balance = stakedBalances[member];\\n\\n        uint256 share = (balance * totalDepositedERC1155[token][tokenId]) / (daoTokenTotalSupply);\\n        balancesERC1155[token][tokenId][member] += share;\\n        totalDistributed += share;\\n    }\\n\\n    uint256 unclaimedRewards = totalDepositedERC1155[token][tokenId] - totalDistributed;\\n    IERC1155(token).safeTransferFrom(address(this), theGameDAOTreasury, tokenId, unclaimedRewards, \\\"\\\");\\n    totalDepositedERC1155[token][tokenId] = 0;\\n\\n    emit DistributedErc1155(totalDistributed, unclaimedRewards);\\n}\\n\\n\\n    function claimERC1155(uint256 tokenId, address token) external nonReentrant {\\n        require(balancesERC1155[token][tokenId][msg.sender] > 0, \\\"No balance to claim\\\");\\n        require(\\n            !claimedERC1155[msg.sender][totalDeposits],\\n            \\\"Already claimed for this deposit\\\"\\n        );\\n        require(isStaked(msg.sender), \\\"Not staked\\\");\\n        claimedERC1155[msg.sender][totalDeposits] = true;\\n\\n        uint256 balance = balancesERC1155[token][tokenId][msg.sender];\\n        balancesERC1155[token][tokenId][msg.sender] = 0;\\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, tokenId, balance, \\\"\\\");\\n\\n        emit Claimed(msg.sender, balance);\\n    }\\n\\n    // Function to deposit ERC20 tokens restricted to addresses on the allow list\\n\\n\\n    function depositERC20(address token, uint256 amount) external onlyAllowList {\\n    // IERC20 erc20Token = IERC20(token);\\n    // Transfer ERC20 tokens to this contract\\n    IERC20(token).transferFrom(msg.sender, address(this), amount);\\n\\n    totalDepositedTokensErc20[token] += amount;\\n    distributeERC20(token);\\n\\n    depositTimestamps[totalDepositsErc20] = block.timestamp;\\n\\n    totalDepositsErc20 += 1;\\n\\n    emit DepositedErc20(msg.sender, token, amount, totalDepositedTokensErc20[token]);\\n}\\n   function distributeERC20(address token) private  {\\n    if (stakedUsers.length == 0) {\\n        require(IERC20(token).transfer(theGameDAOTreasury, totalDepositedTokensErc20[token]), \\\"Transfer failed.\\\");\\n        totalDepositedTokensErc20[token] = 0;\\n    }\\n\\n    uint256 totalDistributedErc20 = 0;\\n\\n    for (uint256 i = 0; i < stakedUsers.length; i++) {\\n        address member = stakedUsers[i];\\n        uint256 balance = stakedBalances[member];\\n\\n        uint256 share = (balance * totalDepositedTokensErc20[token]) / daoTokenTotalSupply;\\n        balancesTokensErc20[token][member] += share;\\n        totalDistributedErc20 += share;\\n    }\\n\\n    uint256 unclaimedRewards = totalDepositedTokensErc20[token] - totalDistributedErc20;\\n    require(IERC20(token).transfer(theGameDAOTreasury, unclaimedRewards), \\\"Transfer failed.\\\");\\n    totalDepositedTokensErc20[token] = 0;\\n\\n    emit DistributedErc20(totalDistributedErc20, unclaimedRewards);\\n}\\n\\n\\n\\n    function claimERC20(address token) external nonReentrant {\\n    require(balancesTokensErc20[token][msg.sender] > 0, \\\"No balance to claim\\\");\\n    require(!claimedErc20[msg.sender][totalDepositsErc20],\\\"Already claimed for this deposit\\\");\\n    require(isStaked(msg.sender), \\\"Not staked\\\");\\n    claimedErc20[msg.sender][totalDepositsErc20] = true;\\n\\n    uint256 balanceErc20 = balancesTokensErc20[token][msg.sender];\\n    balancesTokensErc20[token][msg.sender] = 0;\\n    require(IERC20(token).transfer(msg.sender, balanceErc20), \\\"Transfer failed.\\\");\\n\\n    emit ClaimedErc20(msg.sender, balanceErc20);\\n}\\n\\n    // Function to deposit funds restricted to addresses on the allow list\\n    function deposit(\\n        uint256 amount\\n    ) external payable onlyAllowList {\\n         require(amount > 0, \\\"Amount must be greater than zero\\\");\\n        require(msg.value == amount, \\\"Incorrect deposit amount\\\");\\n\\n        totalDeposited += amount;\\n        distribute();\\n\\n        depositTimestamps[totalDeposits] = block.timestamp;\\n\\n        totalDeposits += 1;\\n\\n        emit Deposited(msg.sender, amount, totalDeposited);\\n    }\\n\\n    // Function to stake tokens\\n    function distribute() private  {\\n\\n        if (stakedUsers.length == 0) {\\n        return;\\n    }\\n\\n\\n        uint256 totalDistributed = 0;\\n\\n        for (uint256 i = 0; i < stakedUsers.length; i++) {\\n            address member = stakedUsers[i];\\n            uint256 balance = stakedBalances[member];\\n\\n            uint256 share = (balance * totalDeposited) / (daoTokenTotalSupply);\\n            balances[member] += share;\\n            totalDistributed += share;\\n        }\\n\\n        uint256 unclaimedRewards = totalDeposited - totalDistributed;\\n        (bool success, ) = payable(theGameDAOTreasury).call{value: unclaimedRewards}(\\n            \\\"\\\"\\n        );\\n        require(success, \\\"Transfer failed.\\\");\\n        totalDeposited = 0;\\n\\n        emit Distributed(totalDistributed, unclaimedRewards);\\n    }\\n\\n    // Function to claim rewards restricted to DAO members\\n    function claim() external nonReentrant {\\n        require(balances[msg.sender] > 0, \\\"No balance to claim\\\");\\n        require(\\n            !claimed[msg.sender][totalDeposits],\\n            \\\"Already claimed for this deposit\\\"\\n        );\\n        require(isStaked(msg.sender), \\\"Not staked\\\");\\n        claimed[msg.sender][totalDeposits] = true;\\n\\n        uint256 balance = balances[msg.sender];\\n        balances[msg.sender] = 0;\\n        (bool success, ) = payable(msg.sender).call{value: balance}(\\\"\\\");\\n        require(success, \\\"Transfer failed.\\\");\\n\\n        emit Claimed(msg.sender, balance);\\n    }\\n\\n    // Function to stake tokens\\n    function stake() external nonReentrant {\\n        uint256 userBalance = erc1155Token.balanceOf(msg.sender, daoTokenId);\\n        require(userBalance > 0, \\\"Sender is not a member\\\");\\n        require(stakedAt[msg.sender] == 0, \\\"Already staked\\\");\\n\\n        erc1155Token.safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            daoTokenId,\\n            userBalance,\\n            \\\"\\\"\\n        );\\n\\n        stakedAt[msg.sender] = block.timestamp;\\n        stakedTokens[msg.sender] = userBalance;\\n        stakedBalances[msg.sender] = userBalance;\\n        stakedUsers.push(msg.sender);\\n        stakedUserIndexes[msg.sender] = stakedUsers.length - 1;\\n\\n        emit Staked(msg.sender, userBalance);\\n    }\\n\\n \\n    // Function to stop staking during emergencies, only callable by the contract owner\\n    function emergencyUnstake() external onlyOwner {\\n        paused = true;\\n    }\\n\\n    // Function to resume staking, only callable by the contract owner\\n    function resumeStaking() external onlyOwner {\\n        paused = false;\\n    }\\n\\n    // Function to unstake tokens\\n    function unstake() external nonReentrant {\\n        require(stakedAt[msg.sender] > 0, \\\"Not staked\\\");\\n        if (!paused) {\\n            uint256 stakedTime = block.timestamp - stakedAt[msg.sender];\\n            require(\\n                stakedTime >= MINIMUM_STAKING_DURATION,\\n                \\\"Minimum staking duration not reached\\\"\\n            );\\n        }\\n\\n        uint256 userStakedTokens = stakedTokens[msg.sender];\\n        erc1155Token.safeTransferFrom(\\n            address(this),\\n            msg.sender,\\n            daoTokenId,\\n            userStakedTokens,\\n            \\\"\\\"\\n        );\\n\\n        stakedAt[msg.sender] = 0;\\n        stakedTokens[msg.sender] = 0;\\n        stakedBalances[msg.sender] = 0;\\n\\n        uint256 userIndex = stakedUserIndexes[msg.sender];\\n        uint256 lastIndex = stakedUsers.length - 1;\\n        stakedUsers[userIndex] = stakedUsers[lastIndex];\\n        stakedUserIndexes[stakedUsers[userIndex]] = userIndex;\\n        stakedUsers.pop();\\n\\n        emit Unstaked(msg.sender, userStakedTokens);\\n    }\\n\\n    // Function to check whether a member is staked\\n    function isStaked(address member) public view returns (bool) {\\n        return stakedAt[member] > 0;\\n    }\\n\\n    // Function to add an address to the allow list, restricted to the contract owner\\n    function addToAllowList(address _user) external onlyOwner {\\n        allowList[_user] = true;\\n    }\\n\\n    // Function to remove an address from the allow list, restricted to the contract owner\\n    function removeFromAllowList(address _user) external onlyOwner {\\n        allowList[_user] = false;\\n    }\\n\\n    // Modifier to restrict access to addresses on the allow list\\n    modifier onlyAllowList() {\\n        require(allowList[msg.sender], \\\"Sender not on allow list\\\");\\n        _;\\n    }\\n\\n    fallback() external payable {\\n        revert(\\\"Direct transfers not allowed\\\");\\n    }\\n\\n    receive() external payable {\\n        revert(\\\"Direct transfers not allowed\\\");\\n    }\\n\\n    // Function to get the total number of deposits made to the contract\\n    function getTotalDeposits() external view returns (uint256) {\\n        return totalDeposits;\\n    }\\n\\n    // Function to get the total amount of funds deposited to the contract\\n    function getTotalDeposited() external view returns (uint256) {\\n        return totalDeposited;\\n    }\\n\\n    // Function to get the total supply of the DAO token\\n    function getDaoTokenTotalSupply() external view returns (uint256) {\\n        return daoTokenTotalSupply;\\n    }\\n\\n    // Function to get the ID of the DAO token\\n    function getDaoTokenId() external view returns (uint256) {\\n        return daoTokenId;\\n    }\\n\\n    function getStakedBalance(address user) public view returns (uint256) {\\n    return stakedBalances[user];\\n\\n    }\\n\\n    function getStakedTokens(address user) public view returns (uint256) {\\n    return stakedTokens[user];\\n    \\n    }\\n\\n    function getBalance(address user) public view returns (uint256) {\\n    return balances[user];\\n    \\n    }\\n\\n    // Function to check if a specific address has claimed rewards\\n    function hasClaimed(\\n        address user,\\n        uint256 depositIndex\\n    ) external view returns (bool) {\\n        return claimed[user][depositIndex];\\n    }\\n\\n    // Function to check if a specific address has claimed rewards\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc1155StakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_unclaimedErc1155Receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_daoTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_theGameDAOTreasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialTotalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountErc1155\",\"type\":\"uint256\"}],\"name\":\"ClaimedEc1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountErc20\",\"type\":\"uint256\"}],\"name\":\"ClaimedErc20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDeposited\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDepositedTokensErc1155\",\"type\":\"uint256\"}],\"name\":\"DepositedErc1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDepositedTokensErc20\",\"type\":\"uint256\"}],\"name\":\"DepositedErc20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDistributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedRewards\",\"type\":\"uint256\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDistributedErc1155\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedRewards\",\"type\":\"uint256\"}],\"name\":\"DistributedErc1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDistributedErc20\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedRewards\",\"type\":\"uint256\"}],\"name\":\"DistributedErc20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"unstaker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"MINIMUM_STAKING_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addToAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositForGas\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc1155Token\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDaoTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDaoTokenTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getStakedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositIndex\",\"type\":\"uint256\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeFromAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resumeStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedUserIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"theGameDAOTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unclaimedErc1155Receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawForGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DepositDistributorV2", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007cf4e5794087691637d421b6fd304112fb190db6000000000000000000000000a253202a05a1971c7c86d9036e81d5ccb2a18271000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065a4beba7ea7ee793e6e3c24157256ca842b0f030000000000000000000000000000000000000000000000000000000000002710", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}