{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface ve {\r\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint);\r\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint);\r\n    function totalSupplyAt(uint _block) external view returns (uint);\r\n    function totalSupplyAtT(uint t) external view returns (uint);\r\n    function ownerOf(uint) external view returns (address);\r\n    function create_lock(uint _value, uint _lock_duration) external returns (uint);\r\n}\r\n\r\ncontract Reward {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct EpochInfo {\r\n        uint startTime;\r\n        uint endTime;\r\n        uint rewardPerSecond; // totalReward * RewardMultiplier / (endBlock - startBlock)\r\n        uint totalPower;\r\n        uint startBlock;\r\n    }\r\n\r\n    /// @dev Ve nft\r\n    address public immutable _ve;\r\n    /// @dev reward erc20 token, USDT\r\n    address public immutable rewardToken;\r\n    /// @dev RewardMultiplier\r\n    uint immutable RewardMultiplier = 10000000;\r\n    /// @dev BlockMultiplier\r\n    uint immutable BlockMultiplier = 1000000000000000000;\r\n\r\n    /// @dev reward epochs.\r\n    EpochInfo[] public epochInfo;\r\n\r\n    /// @dev user's last claim time.\r\n    mapping(uint => mapping(uint => uint)) public userLastClaimTime; // tokenId -> epoch id -> last claim timestamp\\\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    event LogClaimReward(uint tokenId, uint reward);\r\n    event LogAddEpoch(uint epochId, EpochInfo epochInfo);\r\n    event LogAddEpoch(uint startTime, uint epochLength, uint epochCount, uint startEpochId);\r\n    event LogTransferAdmin(address pendingAdmin);\r\n    event LogAcceptAdmin(address admin);\r\n\r\n    constructor (\r\n        address _ve_,\r\n        address rewardToken_\r\n    ) {\r\n        admin = msg.sender;\r\n        _ve = _ve_;\r\n        rewardToken = rewardToken_;\r\n        // add init point\r\n        addCheckpoint();\r\n    }\r\n    \r\n    struct Point {\r\n        uint256 ts;\r\n        uint256 blk; // block\r\n    }\r\n\r\n    /// @dev list of checkpoints, used in getBlockByTime\r\n    Point[] public point_history;\r\n   \r\n    /// @notice add checkpoint to point_history\r\n    /// called in constructor, addEpoch, addEpochBatch and claimReward\r\n    /// point_history increments without repetition, length always >= 1\r\n    function addCheckpoint() internal {\r\n        point_history.push(Point(block.timestamp, block.number));\r\n    }\r\n    \r\n    /// @notice estimate last block number before given time\r\n    /// @return blockNumber\r\n    function getBlockByTime(uint _time) public view returns (uint) {\r\n        // Binary search\r\n        uint _min = 0;\r\n        uint _max = point_history.length - 1; // asserting length >= 2\r\n        for (uint i = 0; i < 128; ++i) {\r\n            // Will be always enough for 128-bit numbers\r\n            if (_min >= _max) {\r\n                break;\r\n            }\r\n            uint _mid = (_min + _max + 1) / 2;\r\n            if (point_history[_mid].ts <= _time) {\r\n                _min = _mid;\r\n            } else {\r\n                _max = _mid - 1;\r\n            }\r\n        }\r\n\r\n        Point memory point0 = point_history[_min];\r\n        Point memory point1 = point_history[_min + 1];\r\n        if (_time == point0.ts) {\r\n            return point0.blk;\r\n        }\r\n        // asserting point0.blk < point1.blk, point0.ts < point1.ts\r\n        uint block_slope; // dblock/dt\r\n        block_slope = (BlockMultiplier * (point1.blk - point0.blk)) / (point1.ts - point0.ts);\r\n        uint dblock = (block_slope * (_time - point0.ts)) / BlockMultiplier;\r\n        return point0.blk + dblock;\r\n    }\r\n\r\n    function withdrawFee(uint amount) external onlyAdmin {\r\n        IERC20(rewardToken).safeTransfer(admin, amount);\r\n    }\r\n\r\n    function transferAdmin(address _admin) external onlyAdmin {\r\n        pendingAdmin = _admin;\r\n        emit LogTransferAdmin(pendingAdmin);\r\n    }\r\n\r\n    function acceptAdmin() external {\r\n        require(msg.sender == pendingAdmin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n        emit LogAcceptAdmin(admin);\r\n    }\r\n\r\n    /// @notice add one epoch\r\n    /// @return epochId\r\n    /// @return accurateTotalReward\r\n    function addEpoch(uint startTime, uint endTime, uint totalReward) external onlyAdmin returns(uint, uint) {\r\n        assert(block.timestamp < endTime && startTime < endTime);\r\n        if (epochInfo.length > 0) {\r\n            require(epochInfo[epochInfo.length - 1].endTime <= startTime);\r\n        }\r\n        (uint epochId, uint accurateTotalReward) = _addEpoch(startTime, endTime, totalReward);\r\n        uint lastPointTime = point_history[point_history.length - 1].ts;\r\n        if (lastPointTime < block.timestamp) {\r\n            addCheckpoint();\r\n        }\r\n        emit LogAddEpoch(epochId, epochInfo[epochId]);\r\n        return (epochId, accurateTotalReward);\r\n    }\r\n\r\n    /// @notice add a batch of continuous epochs\r\n    /// @return firstEpochId\r\n    /// @return lastEpochId\r\n    /// @return accurateTotalReward\r\n    function addEpochBatch(uint startTime, uint epochLength, uint epochCount, uint totalReward) external onlyAdmin returns(uint, uint, uint) {\r\n        require(block.timestamp < startTime + epochLength);\r\n        if (epochInfo.length > 0) {\r\n            require(epochInfo[epochInfo.length - 1].endTime <= startTime);\r\n        }\r\n        uint _reward = totalReward / epochCount;\r\n        uint _epochId;\r\n        uint accurateTR;\r\n        uint _start = startTime;\r\n        uint _end = _start + epochLength;\r\n        for (uint i = 0; i < epochCount; i++) {\r\n            (_epochId, accurateTR) = _addEpoch(_start, _end, _reward);\r\n            _start = _end;\r\n            _end = _start + epochLength;\r\n        }\r\n        uint lastPointTime = point_history[point_history.length - 1].ts;\r\n        if (lastPointTime < block.timestamp) {\r\n            addCheckpoint();\r\n        }\r\n        emit LogAddEpoch(startTime, epochLength, epochCount, _epochId + 1 - epochCount);\r\n        return (_epochId + 1 - epochCount, _epochId, accurateTR * epochCount);\r\n    }\r\n\r\n    /// @notice add one epoch\r\n    /// @return epochId\r\n    /// @return accurateTotalReward\r\n    function _addEpoch(uint startTime, uint endTime, uint totalReward) internal returns(uint, uint) {\r\n        uint rewardPerSecond = totalReward * RewardMultiplier / (endTime - startTime);\r\n        uint epochId = epochInfo.length;\r\n        epochInfo.push(EpochInfo(startTime, endTime, rewardPerSecond, 1, 1));\r\n        uint accurateTotalReward = (endTime - startTime) * rewardPerSecond / RewardMultiplier;\r\n        return (epochId, accurateTotalReward);\r\n    }\r\n\r\n    /// @notice set epoch reward\r\n    function updateEpochReward(uint epochId, uint totalReward) external onlyAdmin {\r\n        require(block.timestamp < epochInfo[epochId].startTime);\r\n        epochInfo[epochId].rewardPerSecond = totalReward * RewardMultiplier / (epochInfo[epochId].endTime - epochInfo[epochId].startTime);\r\n    }\r\n\r\n    /// @notice query pending reward by epoch\r\n    /// @return pendingReward\r\n    /// @return finished\r\n    /// panic when block.timestamp < epoch.startTime\r\n    function _pendingRewardSingle(uint tokenId, uint lastClaimTime, EpochInfo memory epoch) internal view returns (uint, bool) {\r\n        uint last = lastClaimTime >= epoch.startTime ? lastClaimTime : epoch.startTime;\r\n        if (last >= epoch.endTime) {\r\n            return (0, true);\r\n        }\r\n        if (epoch.totalPower == 0) {\r\n            return (0, true);\r\n        }\r\n        \r\n        uint end = block.timestamp;\r\n        bool finished = false;\r\n        if (end > epoch.endTime) {\r\n            end = epoch.endTime;\r\n            finished = true;\r\n        }\r\n\r\n        uint power = ve(_ve).balanceOfAtNFT(tokenId, epoch.startBlock);\r\n        \r\n        uint reward = epoch.rewardPerSecond * (end - last) * power / (epoch.totalPower * RewardMultiplier);\r\n        return (reward, finished);\r\n    }\r\n\r\n    function checkpointAndCheckEpoch(uint epochId) public {\r\n        uint lastPointTime = point_history[point_history.length - 1].ts;\r\n        if (lastPointTime < block.timestamp) {\r\n            addCheckpoint();\r\n        }\r\n        checkEpoch(epochId);\r\n    }\r\n\r\n    function checkEpoch(uint epochId) internal {\r\n        if (epochInfo[epochId].startBlock == 1) {\r\n            epochInfo[epochId].startBlock = getBlockByTime(epochInfo[epochId].startTime);\r\n        }\r\n        if (epochInfo[epochId].totalPower == 1) {\r\n            epochInfo[epochId].totalPower = ve(_ve).totalSupplyAt(epochInfo[epochId].startBlock);\r\n        }\r\n    }\r\n\r\n    struct Interval {\r\n        uint startEpoch;\r\n        uint endEpoch;\r\n    }\r\n\r\n    struct IntervalReward {\r\n        uint startEpoch;\r\n        uint endEpoch;\r\n        uint reward;\r\n    }\r\n\r\n    function claimRewardMany(uint[] calldata tokenIds, Interval[][] calldata intervals) public returns (uint[] memory rewards) {\r\n        require(tokenIds.length == intervals.length, \"length not equal\");\r\n        rewards = new uint[] (tokenIds.length);\r\n        for (uint i = 0; i < tokenIds.length; i++) {\r\n            rewards[i] = claimReward(tokenIds[i], intervals[i]);\r\n        }\r\n        return rewards;\r\n    }\r\n\r\n    function claimReward(uint tokenId, Interval[] calldata intervals) public returns (uint reward) {\r\n        for (uint i = 0; i < intervals.length; i++) {\r\n            reward += claimReward(tokenId, intervals[i].startEpoch, intervals[i].endEpoch);\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    /// @notice claim reward in range\r\n    function claimReward(uint tokenId, uint startEpoch, uint endEpoch) public returns (uint reward) {\r\n        require(msg.sender == ve(_ve).ownerOf(tokenId));\r\n        require(endEpoch < epochInfo.length, \"claim out of range\");\r\n        EpochInfo memory epoch;\r\n        uint lastPointTime = point_history[point_history.length - 1].ts;\r\n        for (uint i = startEpoch; i <= endEpoch; i++) {\r\n            epoch = epochInfo[i];\r\n            if (block.timestamp < epoch.startTime) {\r\n                break;\r\n            }\r\n            if (lastPointTime < epoch.startTime) {\r\n                // this branch runs 0 or 1 time\r\n                lastPointTime = block.timestamp;\r\n                addCheckpoint();\r\n            }\r\n            checkEpoch(i);\r\n            (uint reward_i, bool finished) = _pendingRewardSingle(tokenId, userLastClaimTime[tokenId][i], epochInfo[i]);\r\n            if (reward_i > 0) {\r\n                reward += reward_i;\r\n                userLastClaimTime[tokenId][i] = block.timestamp;\r\n            }\r\n            if (!finished) {\r\n                break;\r\n            }\r\n        }\r\n        IERC20(rewardToken).safeTransfer(ve(_ve).ownerOf(tokenId), reward);\r\n        emit LogClaimReward(tokenId, reward);\r\n        return reward;\r\n    }\r\n\r\n    /// @notice get epoch by time\r\n    function getEpochIdByTime(uint _time) view public returns (uint) {\r\n        assert(epochInfo[0].startTime <= _time);\r\n        if (_time > epochInfo[epochInfo.length - 1].startTime) {\r\n            return epochInfo.length - 1;\r\n        }\r\n        // Binary search\r\n        uint _min = 0;\r\n        uint _max = epochInfo.length - 1; // asserting length >= 2\r\n        for (uint i = 0; i < 128; ++i) {\r\n            // Will be always enough for 128-bit numbers\r\n            if (_min >= _max) {\r\n                break;\r\n            }\r\n            uint _mid = (_min + _max + 1) / 2;\r\n            if (epochInfo[_mid].startTime <= _time) {\r\n                _min = _mid;\r\n            } else {\r\n                _max = _mid - 1;\r\n            }\r\n        }\r\n        return _min;\r\n    }\r\n\r\n    /**\r\n    External read functions\r\n     */\r\n    struct RewardInfo {\r\n        uint epochId;\r\n        uint reward;\r\n    }\r\n\r\n    uint constant MaxQueryLength = 50;\r\n\r\n    /// @notice get epoch info\r\n    /// @return startTime\r\n    /// @return endTime\r\n    /// @return totalReward\r\n    function getEpochInfo(uint epochId) public view returns (uint, uint, uint) {\r\n        if (epochId >= epochInfo.length) {\r\n            return (0,0,0);\r\n        }\r\n        EpochInfo memory epoch = epochInfo[epochId];\r\n        uint totalReward = (epoch.endTime - epoch.startTime) * epoch.rewardPerSecond / RewardMultiplier;\r\n        return (epoch.startTime, epoch.endTime, totalReward);\r\n    }\r\n\r\n    function getCurrentEpochId() public view returns (uint) {\r\n        uint currentEpochId = getEpochIdByTime(block.timestamp);\r\n        return currentEpochId;\r\n    }\r\n\r\n    /// @notice only for external view functions\r\n    /// Time beyond last checkpoint resulting in inconsistent estimated block number.\r\n    function getBlockByTimeWithoutLastCheckpoint(uint _time) public view returns (uint) {\r\n        if (point_history[point_history.length - 1].ts >= _time) {\r\n            return getBlockByTime(_time);\r\n        }\r\n        Point memory point0 = point_history[point_history.length - 1];\r\n        if (_time == point0.ts) {\r\n            return point0.blk;\r\n        }\r\n        uint block_slope;\r\n        block_slope = (BlockMultiplier * (block.number - point0.blk)) / (block.timestamp - point0.ts);\r\n        uint dblock = (block_slope * (_time - point0.ts)) / BlockMultiplier;\r\n        return point0.blk + dblock;\r\n    }\r\n\r\n    function getEpochStartBlock(uint epochId) public view returns (uint) {\r\n        if (epochInfo[epochId].startBlock == 1) {\r\n            return getBlockByTimeWithoutLastCheckpoint(epochInfo[epochId].startTime);\r\n        }\r\n        return epochInfo[epochId].startBlock;\r\n    }\r\n\r\n    function getEpochTotalPower(uint epochId) public view returns (uint) {\r\n        if (epochInfo[epochId].totalPower == 1) {\r\n            uint blk = getEpochStartBlock(epochId);\r\n            if (blk > block.number) {\r\n                return ve(_ve).totalSupplyAtT(epochInfo[epochId].startTime);\r\n            }\r\n            return ve(_ve).totalSupplyAt(blk);\r\n        }\r\n        return epochInfo[epochId].totalPower;\r\n    }\r\n\r\n    /// @notice get user's power at epochId\r\n    function getUserPower(uint tokenId, uint epochId) view public returns (uint) {\r\n        EpochInfo memory epoch = epochInfo[epochId];\r\n        uint blk = getBlockByTimeWithoutLastCheckpoint(epoch.startTime);\r\n        if (blk < block.number) {\r\n            return ve(_ve).balanceOfAtNFT(tokenId, blk);\r\n        }\r\n        return ve(_ve).balanceOfNFTAt(tokenId, epochInfo[epochId].startTime);\r\n    }\r\n\r\n    /// @notice\r\n    /// Current epoch reward is inaccurate\r\n    /// because the checkpoint may not have been added.\r\n    function getPendingRewardSingle(uint tokenId, uint epochId) public view returns (uint reward, bool finished) {\r\n        if (epochId > getCurrentEpochId()) {\r\n            return (0, false);\r\n        }\r\n        EpochInfo memory epoch = epochInfo[epochId];\r\n        uint startBlock = getEpochStartBlock(epochId);\r\n        uint totalPower = getEpochTotalPower(epochId);\r\n        if (totalPower == 0) {\r\n            return (0, true);\r\n        }\r\n        uint power = ve(_ve).balanceOfAtNFT(tokenId, startBlock);\r\n\r\n        uint last = userLastClaimTime[tokenId][epochId];\r\n        last = last >= epoch.startTime ? last : epoch.startTime;\r\n        if (last >= epoch.endTime) {\r\n            return (0, true);\r\n        }\r\n        \r\n        uint end = block.timestamp;\r\n        finished = false;\r\n        if (end > epoch.endTime) {\r\n            end = epoch.endTime;\r\n            finished = true;\r\n        }\r\n        \r\n        reward = epoch.rewardPerSecond * (end - last) * power / (totalPower * RewardMultiplier);\r\n        return (reward, finished);\r\n    }\r\n\r\n    /// @notice get claimable reward\r\n    function pendingReward(uint tokenId, uint start, uint end) public view returns (IntervalReward[] memory intervalRewards) {\r\n        uint current = getCurrentEpochId();\r\n        require(start <= end);\r\n        if (end > current) {\r\n            end = current;\r\n        }\r\n        RewardInfo[] memory rewards = new RewardInfo[](end - start + 1);\r\n        for (uint i = start; i <= end; i++) {\r\n            if (block.timestamp < epochInfo[i].startTime) {\r\n                break;\r\n            }\r\n            (uint reward_i,) = getPendingRewardSingle(tokenId, i);\r\n            rewards[i-start] = RewardInfo(i, reward_i);\r\n        }\r\n\r\n        // omit zero rewards and convert epoch list to intervals\r\n        IntervalReward[] memory intervalRewards_0 = new IntervalReward[] (rewards.length);\r\n        uint intv = 0;\r\n        uint intvCursor = 0;\r\n        uint sum = 0;\r\n        for (uint i = 0; i < rewards.length; i++) {\r\n            if (rewards[i].reward == 0) {\r\n                if (i != intvCursor) {\r\n                    intervalRewards_0[intv] = IntervalReward(rewards[intvCursor].epochId, rewards[i-1].epochId, sum);\r\n                    intv++;\r\n                    sum = 0;\r\n                }\r\n                intvCursor = i + 1;\r\n                continue;\r\n            }\r\n            sum += rewards[i].reward;\r\n        }\r\n        if (sum > 0) {\r\n            intervalRewards_0[intv] = IntervalReward(rewards[intvCursor].epochId, rewards[rewards.length-1].epochId, sum);\r\n            intervalRewards = new IntervalReward[] (intv+1);\r\n            // Copy interval array\r\n            for (uint i = 0; i < intv+1; i++) {\r\n                intervalRewards[i] = intervalRewards_0[i];\r\n            }\r\n        } else {\r\n            intervalRewards = new IntervalReward[] (intv);\r\n            // Copy interval array\r\n            for (uint i = 0; i < intv; i++) {\r\n                intervalRewards[i] = intervalRewards_0[i];\r\n            }\r\n        }\r\n        \r\n        return intervalRewards;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ve_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"LogAcceptAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Reward.EpochInfo\",\"name\":\"epochInfo\",\"type\":\"tuple\"}],\"name\":\"LogAddEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startEpochId\",\"type\":\"uint256\"}],\"name\":\"LogAddEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"LogClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"LogTransferAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_ve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"}],\"name\":\"addEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"}],\"name\":\"addEpochBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"checkpointAndCheckEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch\",\"type\":\"uint256\"}],\"internalType\":\"struct Reward.Interval[]\",\"name\":\"intervals\",\"type\":\"tuple[]\"}],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch\",\"type\":\"uint256\"}],\"internalType\":\"struct Reward.Interval[][]\",\"name\":\"intervals\",\"type\":\"tuple[][]\"}],\"name\":\"claimRewardMany\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getBlockByTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getBlockByTimeWithoutLastCheckpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getEpochIdByTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"getEpochInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"getEpochStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"getEpochTotalPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"getPendingRewardSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"getUserPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"pendingReward\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"internalType\":\"struct Reward.IntervalReward[]\",\"name\":\"intervalRewards\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"point_history\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blk\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"}],\"name\":\"updateEpochReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userLastClaimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Reward", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003f6727defb15996d13b3461dae0ba7263ca3cac50000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://64c86e84a3f849b32ab63402f812a7be8a0ee9767105674b0a426e039483215b"}