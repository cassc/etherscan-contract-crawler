{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.23;\r\n\r\n/// @dev contains all the common struct and enums used for data communication between chains.\r\n\r\n/// @dev There are two transaction types in Superform Protocol\r\nenum TransactionType {\r\n    DEPOSIT,\r\n    WITHDRAW\r\n}\r\n\r\n/// @dev Message types can be INIT, RETURN (for successful Deposits) and FAIL (for failed withdraws)\r\nenum CallbackType {\r\n    INIT,\r\n    RETURN,\r\n    FAIL\r\n}\r\n\r\n/// @dev Payloads are stored, updated (deposits) or processed (finalized)\r\nenum PayloadState {\r\n    STORED,\r\n    UPDATED,\r\n    PROCESSED\r\n}\r\n\r\n/// @dev contains all the common struct used for interchain token transfers.\r\nstruct LiqRequest {\r\n    /// @dev generated data\r\n    bytes txData;\r\n    /// @dev input token for deposits, desired output token on target liqDstChainId for withdraws. Must be set for\r\n    /// txData to be updated on destination for withdraws\r\n    address token;\r\n    /// @dev intermediary token on destination. Relevant for xChain deposits where a destination swap is needed for\r\n    /// validation purposes\r\n    address interimToken;\r\n    /// @dev what bridge to use to move tokens\r\n    uint8 bridgeId;\r\n    /// @dev dstChainId = liqDstchainId for deposits. For withdraws it is the target chain id for where the underlying\r\n    /// is to be delivered\r\n    uint64 liqDstChainId;\r\n    /// @dev currently this amount is used as msg.value in the txData call.\r\n    uint256 nativeAmount;\r\n}\r\n\r\n/// @dev main struct that holds required multi vault data for an action\r\nstruct MultiVaultSFData {\r\n    // superformids must have same destination. Can have different underlyings\r\n    uint256[] superformIds;\r\n    uint256[] amounts; // on deposits, amount of token to deposit on dst, on withdrawals, superpositions to burn\r\n    uint256[] outputAmounts; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\r\n    uint256[] maxSlippages;\r\n    LiqRequest[] liqRequests; // if length = 1; amount = sum(amounts) | else  amounts must match the amounts being sent\r\n    bytes permit2data;\r\n    bool[] hasDstSwaps;\r\n    bool[] retain4626s; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\r\n    address receiverAddress;\r\n    /// this address must always be an EOA otherwise funds may be lost\r\n    address receiverAddressSP;\r\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\r\n    bytes extraFormData; // extraFormData\r\n}\r\n\r\n/// @dev main struct that holds required single vault data for an action\r\nstruct SingleVaultSFData {\r\n    // superformids must have same destination. Can have different underlyings\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 outputAmount; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\r\n    uint256 maxSlippage;\r\n    LiqRequest liqRequest; // if length = 1; amount = sum(amounts)| else  amounts must match the amounts being sent\r\n    bytes permit2data;\r\n    bool hasDstSwap;\r\n    bool retain4626; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\r\n    address receiverAddress;\r\n    /// this address must always be an EOA otherwise funds may be lost\r\n    address receiverAddressSP;\r\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\r\n    bytes extraFormData; // extraFormData\r\n}\r\n\r\n/// @dev overarching struct for multiDst requests with multi vaults\r\nstruct MultiDstMultiVaultStateReq {\r\n    uint8[][] ambIds;\r\n    uint64[] dstChainIds;\r\n    MultiVaultSFData[] superformsData;\r\n}\r\n\r\n/// @dev overarching struct for single cross chain requests with multi vaults\r\nstruct SingleXChainMultiVaultStateReq {\r\n    uint8[] ambIds;\r\n    uint64 dstChainId;\r\n    MultiVaultSFData superformsData;\r\n}\r\n\r\n/// @dev overarching struct for multiDst requests with single vaults\r\nstruct MultiDstSingleVaultStateReq {\r\n    uint8[][] ambIds;\r\n    uint64[] dstChainIds;\r\n    SingleVaultSFData[] superformsData;\r\n}\r\n\r\n/// @dev overarching struct for single cross chain requests with single vaults\r\nstruct SingleXChainSingleVaultStateReq {\r\n    uint8[] ambIds;\r\n    uint64 dstChainId;\r\n    SingleVaultSFData superformData;\r\n}\r\n\r\n/// @dev overarching struct for single direct chain requests with single vaults\r\nstruct SingleDirectSingleVaultStateReq {\r\n    SingleVaultSFData superformData;\r\n}\r\n\r\n/// @dev overarching struct for single direct chain requests with multi vaults\r\nstruct SingleDirectMultiVaultStateReq {\r\n    MultiVaultSFData superformData;\r\n}\r\n\r\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\r\n/// @dev realize that receiverAddressSP is not passed, only needed on source chain to mint\r\nstruct InitMultiVaultData {\r\n    uint256 payloadId;\r\n    uint256[] superformIds;\r\n    uint256[] amounts;\r\n    uint256[] outputAmounts;\r\n    uint256[] maxSlippages;\r\n    LiqRequest[] liqData;\r\n    bool[] hasDstSwaps;\r\n    bool[] retain4626s;\r\n    address receiverAddress;\r\n    bytes extraFormData;\r\n}\r\n\r\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\r\nstruct InitSingleVaultData {\r\n    uint256 payloadId;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 outputAmount;\r\n    uint256 maxSlippage;\r\n    LiqRequest liqData;\r\n    bool hasDstSwap;\r\n    bool retain4626;\r\n    address receiverAddress;\r\n    bytes extraFormData;\r\n}\r\n\r\n/// @dev struct for Emergency Queue\r\nstruct QueuedWithdrawal {\r\n    address receiverAddress;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 srcPayloadId;\r\n    bool isProcessed;\r\n}\r\n\r\n/// @dev all statuses of the timelock payload\r\nenum TimelockStatus {\r\n    UNAVAILABLE,\r\n    PENDING,\r\n    PROCESSED\r\n}\r\n\r\n/// @dev holds information about the timelock payload\r\nstruct TimelockPayload {\r\n    uint8 isXChain;\r\n    uint64 srcChainId;\r\n    uint256 lockedTill;\r\n    InitSingleVaultData data;\r\n    TimelockStatus status;\r\n}\r\n\r\n/// @dev struct that contains the type of transaction, callback flags and other identification, as well as the vaults\r\n/// data in params\r\nstruct AMBMessage {\r\n    uint256 txInfo; // tight packing of  TransactionType txType,  CallbackType flag  if multi/single vault, registry id,\r\n        // srcSender and srcChainId\r\n    bytes params; // decoding txInfo will point to the right datatype of params. Refer PayloadHelper.sol\r\n}\r\n\r\n/// @dev struct that contains the information required for broadcasting changes\r\nstruct BroadcastMessage {\r\n    bytes target;\r\n    bytes32 messageType;\r\n    bytes message;\r\n}\r\n\r\n/// @dev struct that contains info on returned data from destination\r\nstruct ReturnMultiData {\r\n    uint256 payloadId;\r\n    uint256[] superformIds;\r\n    uint256[] amounts;\r\n}\r\n\r\n/// @dev struct that contains info on returned data from destination\r\nstruct ReturnSingleData {\r\n    uint256 payloadId;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n}\r\n\r\n/// @dev struct that contains the data on the fees to pay to the AMBs\r\nstruct AMBExtraData {\r\n    uint256[] gasPerAMB;\r\n    bytes[] extraDataPerAMB;\r\n}\r\n\r\n/// @dev struct that contains the data on the fees to pay to the AMBs on broadcasts\r\nstruct BroadCastAMBExtraData {\r\n    uint256[] gasPerDst;\r\n    bytes[] extraDataPerDst;\r\n}\r\n\r\n/// @title IBaseRouter\r\n/// @dev Interface for abstract BaseRouter\r\n/// @author Zeropoint Labs\r\ninterface IBaseRouter {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev Performs single direct x single vault deposits\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function singleDirectSingleVaultDeposit(SingleDirectSingleVaultStateReq memory req_) external payable;\r\n\r\n    /// @dev Performs single xchain destination x single vault deposits\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function singleXChainSingleVaultDeposit(SingleXChainSingleVaultStateReq memory req_) external payable;\r\n\r\n    /// @dev Performs single direct x multi vault deposits\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function singleDirectMultiVaultDeposit(SingleDirectMultiVaultStateReq memory req_) external payable;\r\n\r\n    /// @dev Performs single destination x multi vault deposits\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function singleXChainMultiVaultDeposit(SingleXChainMultiVaultStateReq memory req_) external payable;\r\n\r\n    /// @dev Performs multi destination x single vault deposits\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function multiDstSingleVaultDeposit(MultiDstSingleVaultStateReq calldata req_) external payable;\r\n\r\n    /// @dev Performs multi destination x multi vault deposits\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function multiDstMultiVaultDeposit(MultiDstMultiVaultStateReq calldata req_) external payable;\r\n\r\n    /// @dev Performs single direct x single vault withdraws\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function singleDirectSingleVaultWithdraw(SingleDirectSingleVaultStateReq memory req_) external payable;\r\n\r\n    /// @dev Performs single xchain destination x single vault withdraws\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function singleXChainSingleVaultWithdraw(SingleXChainSingleVaultStateReq memory req_) external payable;\r\n\r\n    /// @dev Performs single direct x multi vault withdraws\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function singleDirectMultiVaultWithdraw(SingleDirectMultiVaultStateReq memory req_) external payable;\r\n\r\n    /// @dev Performs single destination x multi vault withdraws\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function singleXChainMultiVaultWithdraw(SingleXChainMultiVaultStateReq memory req_) external payable;\r\n\r\n    /// @dev Performs multi destination x single vault withdraws\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function multiDstSingleVaultWithdraw(MultiDstSingleVaultStateReq calldata req_) external payable;\r\n\r\n    /// @dev Performs multi destination x multi vault withdraws\r\n    /// @param req_ is the request object containing all the necessary data for the action\r\n    function multiDstMultiVaultWithdraw(MultiDstMultiVaultStateReq calldata req_) external payable;\r\n\r\n    /// @dev Forwards dust to Paymaster\r\n    /// @param token_ the token to forward\r\n    function forwardDustToPaymaster(address token_) external;\r\n}\r\n\r\n/// @title ISuperRegistry\r\n/// @dev Interface for SuperRegistry\r\n/// @author Zeropoint Labs\r\ninterface ISuperRegistry {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev emitted when permit2 is set.\r\n    event SetPermit2(address indexed permit2);\r\n\r\n    /// @dev is emitted when an address is set.\r\n    event AddressUpdated(\r\n        bytes32 indexed protocolAddressId, uint64 indexed chainId, address indexed oldAddress, address newAddress\r\n    );\r\n\r\n    /// @dev is emitted when a new token bridge is configured.\r\n    event SetBridgeAddress(uint256 indexed bridgeId, address indexed bridgeAddress);\r\n\r\n    /// @dev is emitted when a new bridge validator is configured.\r\n    event SetBridgeValidator(uint256 indexed bridgeId, address indexed bridgeValidator);\r\n\r\n    /// @dev is emitted when a new amb is configured.\r\n    event SetAmbAddress(uint8 indexed ambId_, address indexed ambAddress_, bool indexed isBroadcastAMB_);\r\n\r\n    /// @dev is emitted when a new state registry is configured.\r\n    event SetStateRegistryAddress(uint8 indexed registryId_, address indexed registryAddress_);\r\n\r\n    /// @dev is emitted when a new delay is configured.\r\n    event SetDelay(uint256 indexed oldDelay_, uint256 indexed newDelay_);\r\n\r\n    /// @dev is emitted when a new vault limit is configured\r\n    event SetVaultLimitPerDestination(uint64 indexed chainId_, uint256 indexed vaultLimit_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev gets the deposit rescue delay\r\n    function delay() external view returns (uint256);\r\n\r\n    /// @dev returns the permit2 address\r\n    function PERMIT2() external view returns (address);\r\n\r\n    /// @dev returns the id of the superform router module\r\n    function SUPERFORM_ROUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform factory module\r\n    function SUPERFORM_FACTORY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform transmuter\r\n    function SUPER_TRANSMUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform paymaster contract\r\n    function PAYMASTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform payload helper contract\r\n    function PAYMENT_HELPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry module\r\n    function CORE_STATE_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the timelock form state registry module\r\n    function TIMELOCK_STATE_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcast state registry module\r\n    function BROADCAST_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the super positions module\r\n    function SUPER_POSITIONS() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the super rbac module\r\n    function SUPER_RBAC() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the payload helper module\r\n    function PAYLOAD_HELPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the dst swapper keeper\r\n    function DST_SWAPPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the emergency queue\r\n    function EMERGENCY_QUEUE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform receiver\r\n    function SUPERFORM_RECEIVER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the payment admin keeper\r\n    function PAYMENT_ADMIN() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry processor keeper\r\n    function CORE_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcast registry processor keeper\r\n    function BROADCAST_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the timelock form state registry processor keeper\r\n    function TIMELOCK_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_UPDATER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_RESCUER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_DISPUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function DST_SWAPPER_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev gets the address of a contract on current chain\r\n    /// @param id_ is the id of the contract\r\n    function getAddress(bytes32 id_) external view returns (address);\r\n\r\n    /// @dev gets the address of a contract on a target chain\r\n    /// @param id_ is the id of the contract\r\n    /// @param chainId_ is the chain id of that chain\r\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view returns (address);\r\n\r\n    /// @dev gets the address of a bridge\r\n    /// @param bridgeId_ is the id of a bridge\r\n    /// @return bridgeAddress_ is the address of the form\r\n    function getBridgeAddress(uint8 bridgeId_) external view returns (address bridgeAddress_);\r\n\r\n    /// @dev gets the address of a bridge validator\r\n    /// @param bridgeId_ is the id of a bridge\r\n    /// @return bridgeValidator_ is the address of the form\r\n    function getBridgeValidator(uint8 bridgeId_) external view returns (address bridgeValidator_);\r\n\r\n    /// @dev gets the address of a amb\r\n    /// @param ambId_ is the id of a bridge\r\n    /// @return ambAddress_ is the address of the form\r\n    function getAmbAddress(uint8 ambId_) external view returns (address ambAddress_);\r\n\r\n    /// @dev gets the id of the amb\r\n    /// @param ambAddress_ is the address of an amb\r\n    /// @return ambId_ is the identifier of an amb\r\n    function getAmbId(address ambAddress_) external view returns (uint8 ambId_);\r\n\r\n    /// @dev gets the address of the registry\r\n    /// @param registryId_ is the id of the state registry\r\n    /// @return registryAddress_ is the address of the state registry\r\n    function getStateRegistry(uint8 registryId_) external view returns (address registryAddress_);\r\n\r\n    /// @dev gets the id of the registry\r\n    /// @notice reverts if the id is not found\r\n    /// @param registryAddress_ is the address of the state registry\r\n    /// @return registryId_ is the id of the state registry\r\n    function getStateRegistryId(address registryAddress_) external view returns (uint8 registryId_);\r\n\r\n    /// @dev gets the safe vault limit\r\n    /// @param chainId_ is the id of the remote chain\r\n    /// @return vaultLimitPerDestination_ is the safe number of vaults to deposit\r\n    /// without hitting out of gas error\r\n    function getVaultLimitPerDestination(uint64 chainId_) external view returns (uint256 vaultLimitPerDestination_);\r\n\r\n    /// @dev helps validate if an address is a valid state registry\r\n    /// @param registryAddress_ is the address of the state registry\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidStateRegistry(address registryAddress_) external view returns (bool valid_);\r\n\r\n    /// @dev helps validate if an address is a valid amb implementation\r\n    /// @param ambAddress_ is the address of the amb implementation\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidAmbImpl(address ambAddress_) external view returns (bool valid_);\r\n\r\n    /// @dev helps validate if an address is a valid broadcast amb implementation\r\n    /// @param ambAddress_ is the address of the broadcast amb implementation\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidBroadcastAmbImpl(address ambAddress_) external view returns (bool valid_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev sets the deposit rescue delay\r\n    /// @param delay_ the delay in seconds before the deposit rescue can be finalized\r\n    function setDelay(uint256 delay_) external;\r\n\r\n    /// @dev sets the permit2 address\r\n    /// @param permit2_ the address of the permit2 contract\r\n    function setPermit2(address permit2_) external;\r\n\r\n    /// @dev sets the safe vault limit\r\n    /// @param chainId_ is the remote chain identifier\r\n    /// @param vaultLimit_ is the max limit of vaults per transaction\r\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external;\r\n\r\n    /// @dev sets a new address on a specific chain.\r\n    /// @param id_ the identifier of the address on that chain\r\n    /// @param newAddress_ the new address on that chain\r\n    /// @param chainId_ the chain id of that chain\r\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) external;\r\n\r\n    /// @dev allows admin to set the bridge address for an bridge id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param bridgeId_         represents the bridge unique identifier.\r\n    /// @param bridgeAddress_    represents the bridge address.\r\n    /// @param bridgeValidator_  represents the bridge validator address.\r\n    function setBridgeAddresses(\r\n        uint8[] memory bridgeId_,\r\n        address[] memory bridgeAddress_,\r\n        address[] memory bridgeValidator_\r\n    )\r\n        external;\r\n\r\n    /// @dev allows admin to set the amb address for an amb id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param ambId_         represents the bridge unique identifier.\r\n    /// @param ambAddress_    represents the bridge address.\r\n    /// @param isBroadcastAMB_ represents whether the amb implementation supports broadcasting\r\n    function setAmbAddress(\r\n        uint8[] memory ambId_,\r\n        address[] memory ambAddress_,\r\n        bool[] memory isBroadcastAMB_\r\n    )\r\n        external;\r\n\r\n    /// @dev allows admin to set the state registry address for an state registry id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param registryId_    represents the state registry's unique identifier.\r\n    /// @param registryAddress_    represents the state registry's address.\r\n    function setStateRegistryAddress(uint8[] memory registryId_, address[] memory registryAddress_) external;\r\n}\r\n\r\nlibrary Error {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  CONFIGURATION ERRORS                    //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown in protocol setup\r\n\r\n    /// @dev thrown if chain id exceeds max(uint64)\r\n    error BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\r\n\r\n    /// @dev thrown if not possible to revoke a role in broadcasting\r\n    error CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\r\n\r\n    /// @dev thrown if not possible to revoke last admin\r\n    error CANNOT_REVOKE_LAST_ADMIN();\r\n\r\n    /// @dev thrown if trying to set again pseudo immutables in super registry\r\n    error DISABLED();\r\n\r\n    /// @dev thrown if rescue delay is not yet set for a chain\r\n    error DELAY_NOT_SET();\r\n\r\n    /// @dev thrown if get native token price estimate in paymentHelper is 0\r\n    error INVALID_NATIVE_TOKEN_PRICE();\r\n\r\n    /// @dev thrown if wormhole refund chain id is not set\r\n    error REFUND_CHAIN_ID_NOT_SET();\r\n\r\n    /// @dev thrown if wormhole relayer is not set\r\n    error RELAYER_NOT_SET();\r\n\r\n    /// @dev thrown if a role to be revoked is not assigned\r\n    error ROLE_NOT_ASSIGNED();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  AUTHORIZATION ERRORS                    //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown if functions cannot be called\r\n\r\n    /// COMMON AUTHORIZATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if caller is not address(this), internal call\r\n    error INVALID_INTERNAL_CALL();\r\n\r\n    /// @dev thrown if msg.sender is not a valid amb implementation\r\n    error NOT_AMB_IMPLEMENTATION();\r\n\r\n    /// @dev thrown if msg.sender is not an allowed broadcaster\r\n    error NOT_ALLOWED_BROADCASTER();\r\n\r\n    /// @dev thrown if msg.sender is not broadcast amb implementation\r\n    error NOT_BROADCAST_AMB_IMPLEMENTATION();\r\n\r\n    /// @dev thrown if msg.sender is not broadcast state registry\r\n    error NOT_BROADCAST_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not core state registry\r\n    error NOT_CORE_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not emergency admin\r\n    error NOT_EMERGENCY_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not emergency queue\r\n    error NOT_EMERGENCY_QUEUE();\r\n\r\n    /// @dev thrown if msg.sender is not minter\r\n    error NOT_MINTER();\r\n\r\n    /// @dev thrown if msg.sender is not minter state registry\r\n    error NOT_MINTER_STATE_REGISTRY_ROLE();\r\n\r\n    /// @dev thrown if msg.sender is not paymaster\r\n    error NOT_PAYMASTER();\r\n\r\n    /// @dev thrown if msg.sender is not payment admin\r\n    error NOT_PAYMENT_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not protocol admin\r\n    error NOT_PROTOCOL_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not state registry\r\n    error NOT_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not super registry\r\n    error NOT_SUPER_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not superform router\r\n    error NOT_SUPERFORM_ROUTER();\r\n\r\n    /// @dev thrown if msg.sender is not a superform\r\n    error NOT_SUPERFORM();\r\n\r\n    /// @dev thrown if msg.sender is not superform factory\r\n    error NOT_SUPERFORM_FACTORY();\r\n\r\n    /// @dev thrown if msg.sender is not timelock form\r\n    error NOT_TIMELOCK_SUPERFORM();\r\n\r\n    /// @dev thrown if msg.sender is not timelock state registry\r\n    error NOT_TIMELOCK_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not user or disputer\r\n    error NOT_VALID_DISPUTER();\r\n\r\n    /// @dev thrown if the msg.sender is not privileged caller\r\n    error NOT_PRIVILEGED_CALLER(bytes32 role);\r\n\r\n    /// STATE REGISTRY AUTHORIZATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev layerzero adapter specific error, thrown if caller not layerzero endpoint\r\n    error CALLER_NOT_ENDPOINT();\r\n\r\n    /// @dev hyperlane adapter specific error, thrown if caller not hyperlane mailbox\r\n    error CALLER_NOT_MAILBOX();\r\n\r\n    /// @dev wormhole relayer specific error, thrown if caller not wormhole relayer\r\n    error CALLER_NOT_RELAYER();\r\n\r\n    /// @dev thrown if src chain sender is not valid\r\n    error INVALID_SRC_SENDER();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  INPUT VALIDATION ERRORS                 //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown if input variables are not valid\r\n\r\n    /// COMMON INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if there is an array length mismatch\r\n    error ARRAY_LENGTH_MISMATCH();\r\n\r\n    /// @dev thrown if payload id does not exist\r\n    error INVALID_PAYLOAD_ID();\r\n\r\n    /// @dev error thrown when msg value should be zero in certain payable functions\r\n    error MSG_VALUE_NOT_ZERO();\r\n\r\n    /// @dev thrown if amb ids length is 0\r\n    error ZERO_AMB_ID_LENGTH();\r\n\r\n    /// @dev thrown if address input is address 0\r\n    error ZERO_ADDRESS();\r\n\r\n    /// @dev thrown if amount input is 0\r\n    error ZERO_AMOUNT();\r\n\r\n    /// @dev thrown if value input is 0\r\n    error ZERO_INPUT_VALUE();\r\n\r\n    /// SUPERFORM ROUTER INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if the vaults data is invalid\r\n    error INVALID_SUPERFORMS_DATA();\r\n\r\n    /// @dev thrown if receiver address is not set\r\n    error RECEIVER_ADDRESS_NOT_SET();\r\n\r\n    /// SUPERFORM FACTORY INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if a form is not ERC165 compatible\r\n    error ERC165_UNSUPPORTED();\r\n\r\n    /// @dev thrown if a form is not form interface compatible\r\n    error FORM_INTERFACE_UNSUPPORTED();\r\n\r\n    /// @dev error thrown if form implementation address already exists\r\n    error FORM_IMPLEMENTATION_ALREADY_EXISTS();\r\n\r\n    /// @dev error thrown if form implementation id already exists\r\n    error FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\r\n\r\n    /// @dev thrown if a form does not exist\r\n    error FORM_DOES_NOT_EXIST();\r\n\r\n    /// @dev thrown if form id is larger than max uint16\r\n    error INVALID_FORM_ID();\r\n\r\n    /// @dev thrown if superform not on factory\r\n    error SUPERFORM_ID_NONEXISTENT();\r\n\r\n    /// @dev thrown if same vault and form implementation is used to create new superform\r\n    error VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\r\n\r\n    /// FORM INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if in case of no txData, if liqData.token != vault.asset()\r\n    /// in case of txData, if token output of swap != vault.asset()\r\n    error DIFFERENT_TOKENS();\r\n\r\n    /// @dev thrown if the amount in direct withdraw is not correct\r\n    error DIRECT_WITHDRAW_INVALID_LIQ_REQUEST();\r\n\r\n    /// @dev thrown if the amount in xchain withdraw is not correct\r\n    error XCHAIN_WITHDRAW_INVALID_LIQ_REQUEST();\r\n\r\n    /// LIQUIDITY BRIDGE INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev error thrown when txData selector of lifi bridged is a blacklisted selector\r\n    error BLACKLISTED_SELECTOR();\r\n\r\n    /// @dev thrown if a certain action of the user is not allowed given the txData provided\r\n    error INVALID_ACTION();\r\n\r\n    /// @dev thrown if in deposits, the liqDstChainId doesn't match the stateReq dstChainId\r\n    error INVALID_DEPOSIT_LIQ_DST_CHAIN_ID();\r\n\r\n    /// @dev thrown if index is invalid\r\n    error INVALID_INDEX();\r\n\r\n    /// @dev thrown if the chain id in the txdata is invalid\r\n    error INVALID_TXDATA_CHAIN_ID();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to a destination call present\r\n    error INVALID_TXDATA_NO_DESTINATIONCALL_ALLOWED();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to wrong receiver\r\n    error INVALID_TXDATA_RECEIVER();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to wrong token\r\n    error INVALID_TXDATA_TOKEN();\r\n\r\n    /// @dev thrown if txData is not present (in case of xChain actions)\r\n    error NO_TXDATA_PRESENT();\r\n\r\n    /// STATE REGISTRY INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if payload is being updated with final amounts length different than amounts length\r\n    error DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\r\n\r\n    /// @dev thrown if payload is being updated with tx data length different than liq data length\r\n    error DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\r\n\r\n    /// @dev thrown if keeper update final token is different than the vault underlying\r\n    error INVALID_UPDATE_FINAL_TOKEN();\r\n\r\n    /// @dev thrown if broadcast finality for wormhole is invalid\r\n    error INVALID_BROADCAST_FINALITY();\r\n\r\n    /// @dev thrown if amb id is not valid leading to an address 0 of the implementation\r\n    error INVALID_BRIDGE_ID();\r\n\r\n    /// @dev thrown if chain id involved in xchain message is invalid\r\n    error INVALID_CHAIN_ID();\r\n\r\n    /// @dev thrown if payload update amount isn't equal to dst swapper amount\r\n    error INVALID_DST_SWAP_AMOUNT();\r\n\r\n    /// @dev thrown if message amb and proof amb are the same\r\n    error INVALID_PROOF_BRIDGE_ID();\r\n\r\n    /// @dev thrown if order of proof AMBs is incorrect, either duplicated or not incrementing\r\n    error INVALID_PROOF_BRIDGE_IDS();\r\n\r\n    /// @dev thrown if rescue data lengths are invalid\r\n    error INVALID_RESCUE_DATA();\r\n\r\n    /// @dev thrown if delay is invalid\r\n    error INVALID_TIMELOCK_DELAY();\r\n\r\n    /// @dev thrown if amounts being sent in update payload mean a negative slippage\r\n    error NEGATIVE_SLIPPAGE();\r\n\r\n    /// @dev thrown if slippage is outside of bounds\r\n    error SLIPPAGE_OUT_OF_BOUNDS();\r\n\r\n    /// SUPERPOSITION INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if src senders mismatch in state sync\r\n    error SRC_SENDER_MISMATCH();\r\n\r\n    /// @dev thrown if src tx types mismatch in state sync\r\n    error SRC_TX_TYPE_MISMATCH();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  EXECUTION ERRORS                        //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown due to function execution logic\r\n\r\n    /// COMMON EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if the swap in a direct deposit resulted in insufficient tokens\r\n    error DIRECT_DEPOSIT_SWAP_FAILED();\r\n\r\n    /// @dev thrown if payload is not unique\r\n    error DUPLICATE_PAYLOAD();\r\n\r\n    /// @dev thrown if native tokens fail to be sent to superform contracts\r\n    error FAILED_TO_SEND_NATIVE();\r\n\r\n    /// @dev thrown if allowance is not correct to deposit\r\n    error INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\r\n\r\n    /// @dev thrown if contract has insufficient balance for operations\r\n    error INSUFFICIENT_BALANCE();\r\n\r\n    /// @dev thrown if native amount is not at least equal to the amount in the request\r\n    error INSUFFICIENT_NATIVE_AMOUNT();\r\n\r\n    /// @dev thrown if payload cannot be decoded\r\n    error INVALID_PAYLOAD();\r\n\r\n    /// @dev thrown if payload status is invalid\r\n    error INVALID_PAYLOAD_STATUS();\r\n\r\n    /// @dev thrown if payload type is invalid\r\n    error INVALID_PAYLOAD_TYPE();\r\n\r\n    /// LIQUIDITY BRIDGE EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if we try to decode the final swap output token in a xChain liquidity bridging action\r\n    error CANNOT_DECODE_FINAL_SWAP_OUTPUT_TOKEN();\r\n\r\n    /// @dev thrown if liquidity bridge fails for erc20 or native tokens\r\n    error FAILED_TO_EXECUTE_TXDATA(address token);\r\n\r\n    /// @dev thrown if asset being used for deposit mismatches in multivault deposits\r\n    error INVALID_DEPOSIT_TOKEN();\r\n\r\n    /// STATE REGISTRY EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if bridge tokens haven't arrived to destination\r\n    error BRIDGE_TOKENS_PENDING();\r\n\r\n    /// @dev thrown if withdrawal tx data cannot be updated\r\n    error CANNOT_UPDATE_WITHDRAW_TX_DATA();\r\n\r\n    /// @dev thrown if rescue passed dispute deadline\r\n    error DISPUTE_TIME_ELAPSED();\r\n\r\n    /// @dev thrown if message failed to reach the specified level of quorum needed\r\n    error INSUFFICIENT_QUORUM();\r\n\r\n    /// @dev thrown if broadcast payload is invalid\r\n    error INVALID_BROADCAST_PAYLOAD();\r\n\r\n    /// @dev thrown if broadcast fee is invalid\r\n    error INVALID_BROADCAST_FEE();\r\n\r\n    /// @dev thrown if retry fees is less than required\r\n    error INVALID_RETRY_FEE();\r\n\r\n    /// @dev thrown if broadcast message type is wrong\r\n    error INVALID_MESSAGE_TYPE();\r\n\r\n    /// @dev thrown if payload hash is invalid during `retryMessage` on Layezero implementation\r\n    error INVALID_PAYLOAD_HASH();\r\n\r\n    /// @dev thrown if update payload function was called on a wrong payload\r\n    error INVALID_PAYLOAD_UPDATE_REQUEST();\r\n\r\n    /// @dev thrown if a state registry id is 0\r\n    error INVALID_REGISTRY_ID();\r\n\r\n    /// @dev thrown if a form state registry id is 0\r\n    error INVALID_FORM_REGISTRY_ID();\r\n\r\n    /// @dev thrown if trying to finalize the payload but the withdraw is still locked\r\n    error LOCKED();\r\n\r\n    /// @dev thrown if payload is already updated (during xChain deposits)\r\n    error PAYLOAD_ALREADY_UPDATED();\r\n\r\n    /// @dev thrown if payload is already processed\r\n    error PAYLOAD_ALREADY_PROCESSED();\r\n\r\n    /// @dev thrown if payload is not in UPDATED state\r\n    error PAYLOAD_NOT_UPDATED();\r\n\r\n    /// @dev thrown if rescue is still in timelocked state\r\n    error RESCUE_LOCKED();\r\n\r\n    /// @dev thrown if rescue is already proposed\r\n    error RESCUE_ALREADY_PROPOSED();\r\n\r\n    /// @dev thrown if payload hash is zero during `retryMessage` on Layezero implementation\r\n    error ZERO_PAYLOAD_HASH();\r\n\r\n    /// DST SWAPPER EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if process dst swap is tried for processed payload id\r\n    error DST_SWAP_ALREADY_PROCESSED();\r\n\r\n    /// @dev thrown if indices have duplicates\r\n    error DUPLICATE_INDEX();\r\n\r\n    /// @dev thrown if failed dst swap is already updated\r\n    error FAILED_DST_SWAP_ALREADY_UPDATED();\r\n\r\n    /// @dev thrown if indices are out of bounds\r\n    error INDEX_OUT_OF_BOUNDS();\r\n\r\n    /// @dev thrown if failed swap token amount is 0\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP();\r\n\r\n    /// @dev thrown if failed swap token amount is not 0 and if token balance is less than amount (non zero)\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_TOKEN_BALANCE();\r\n\r\n    /// @dev thrown if failed swap token amount is not 0 and if native amount is less than amount (non zero)\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_NATIVE_BALANCE();\r\n\r\n    /// @dev forbid xChain deposits with destination swaps without interim token set (for user protection)\r\n    error INVALID_INTERIM_TOKEN();\r\n\r\n    /// @dev thrown if dst swap output is less than minimum expected\r\n    error INVALID_SWAP_OUTPUT();\r\n\r\n    /// FORM EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if try to forward 4626 share from the superform\r\n    error CANNOT_FORWARD_4646_TOKEN();\r\n\r\n    /// @dev thrown in KYCDAO form if no KYC token is present\r\n    error NO_VALID_KYC_TOKEN();\r\n\r\n    /// @dev thrown in forms where a certain functionality is not allowed or implemented\r\n    error NOT_IMPLEMENTED();\r\n\r\n    /// @dev thrown if form implementation is PAUSED, users cannot perform any action\r\n    error PAUSED();\r\n\r\n    /// @dev thrown if shares != deposit output or assets != redeem output when minting SuperPositions\r\n    error VAULT_IMPLEMENTATION_FAILED();\r\n\r\n    /// @dev thrown if withdrawal tx data is not updated\r\n    error WITHDRAW_TOKEN_NOT_UPDATED();\r\n\r\n    /// @dev thrown if withdrawal tx data is not updated\r\n    error WITHDRAW_TX_DATA_NOT_UPDATED();\r\n\r\n    /// @dev thrown when redeeming from vault yields zero collateral\r\n    error WITHDRAW_ZERO_COLLATERAL();\r\n\r\n    /// PAYMENT HELPER EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if chainlink is reporting an improper price\r\n    error CHAINLINK_MALFUNCTION();\r\n\r\n    /// @dev thrown if chainlink is reporting an incomplete round\r\n    error CHAINLINK_INCOMPLETE_ROUND();\r\n\r\n    /// @dev thrown if feed decimals is not 8\r\n    error CHAINLINK_UNSUPPORTED_DECIMAL();\r\n\r\n    /// EMERGENCY QUEUE EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if emergency withdraw is not queued\r\n    error EMERGENCY_WITHDRAW_NOT_QUEUED();\r\n\r\n    /// @dev thrown if emergency withdraw is already processed\r\n    error EMERGENCY_WITHDRAW_PROCESSED_ALREADY();\r\n\r\n    /// SUPERPOSITION EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if uri cannot be updated\r\n    error DYNAMIC_URI_FROZEN();\r\n\r\n    /// @dev thrown if tx history is not found while state sync\r\n    error TX_HISTORY_NOT_FOUND();\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC-20 standard as defined in the ERC.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n *\r\n * ==== Security Considerations\r\n *\r\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\r\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\r\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\r\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\r\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\r\n * generally recommended is:\r\n *\r\n * ```solidity\r\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\r\n *     doThing(..., value);\r\n * }\r\n *\r\n * function doThing(..., uint256 value) public {\r\n *     token.safeTransferFrom(msg.sender, address(this), value);\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\r\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\r\n * {SafeERC20-safeTransferFrom}).\r\n *\r\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\r\n * contracts should have entry points that don't rely on permit.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     *\r\n     * CAUTION: See Security Considerations above.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC-20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Indicates a failed `decreaseAllowance` request.\r\n     */\r\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        forceApprove(token, spender, oldAllowance + value);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\r\n     * value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\r\n        unchecked {\r\n            uint256 currentAllowance = token.allowance(address(this), spender);\r\n            if (currentAllowance < requestedDecrease) {\r\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\r\n            }\r\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\r\n    }\r\n}\r\n\r\n/// @title BaseRouter\r\n/// @dev Abstract implementation that allows Routers to implement the logic\r\n/// @author Zeropoint Labs\r\nabstract contract BaseRouter is IBaseRouter {\r\n    using SafeERC20 for IERC20;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                         CONSTANTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    ISuperRegistry public immutable superRegistry;\r\n    uint64 public immutable CHAIN_ID;\r\n    uint8 internal constant STATE_REGISTRY_TYPE = 1;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                      CONSTRUCTOR                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @param superRegistry_ the superform registry contract\r\n    constructor(address superRegistry_) {\r\n        if (superRegistry_ == address(0)) {\r\n            revert Error.ZERO_ADDRESS();\r\n        }\r\n\r\n        if (block.chainid > type(uint64).max) {\r\n            revert Error.BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\r\n        }\r\n\r\n        CHAIN_ID = uint64(block.chainid);\r\n        superRegistry = ISuperRegistry(superRegistry_);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @notice receive enables processing native token transfers into the smart contract.\r\n    /// @notice liquidity bridge fails without a native receive function.\r\n    receive() external payable { }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleDirectSingleVaultDeposit(SingleDirectSingleVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        virtual\r\n        override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleXChainSingleVaultDeposit(SingleXChainSingleVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        virtual\r\n        override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleDirectMultiVaultDeposit(SingleDirectMultiVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        virtual\r\n        override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleXChainMultiVaultDeposit(SingleXChainMultiVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        virtual\r\n        override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function multiDstSingleVaultDeposit(MultiDstSingleVaultStateReq calldata req_) external payable virtual override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function multiDstMultiVaultDeposit(MultiDstMultiVaultStateReq calldata req_) external payable virtual override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleDirectSingleVaultWithdraw(SingleDirectSingleVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        virtual\r\n        override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleXChainSingleVaultWithdraw(SingleXChainSingleVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        virtual\r\n        override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleDirectMultiVaultWithdraw(SingleDirectMultiVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        virtual\r\n        override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleXChainMultiVaultWithdraw(SingleXChainMultiVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        virtual\r\n        override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function multiDstSingleVaultWithdraw(MultiDstSingleVaultStateReq calldata req_) external payable virtual override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function multiDstMultiVaultWithdraw(MultiDstMultiVaultStateReq calldata req_) external payable virtual override;\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function forwardDustToPaymaster(address token_) external virtual override;\r\n}\r\n\r\n/// @title IBaseRouterImplementation\r\n/// @dev Interface for BaseRouterImplementation\r\n/// @author Zeropoint Labs\r\ninterface IBaseRouterImplementation is IBaseRouter {\r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev For local memory variable loading and avoiding stack too deep errors\r\n    struct ActionLocalVars {\r\n        AMBMessage ambMessage;\r\n        LiqRequest liqRequest;\r\n        uint64 srcChainId;\r\n        uint256 currentPayloadId;\r\n        uint256 liqRequestsLen;\r\n    }\r\n\r\n    struct DispatchAMBMessageVars {\r\n        TransactionType txType;\r\n        bytes ambData;\r\n        uint256[] superformIds;\r\n        address srcSender;\r\n        uint8[] ambIds;\r\n        uint8 multiVaults;\r\n        uint64 srcChainId;\r\n        uint64 dstChainId;\r\n        uint256 currentPayloadId;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a cross-chain deposit multi vault transaction is initiated.\r\n    event CrossChainInitiatedDepositMulti(\r\n        uint256 indexed payloadId,\r\n        uint64 indexed dstChainId,\r\n        uint256[] superformIds,\r\n        uint256[] amountsIn,\r\n        uint8[] bridgeIds,\r\n        uint8[] ambIds\r\n    );\r\n\r\n    /// @dev is emitted when a cross-chain deposit single vault transaction is initiated.\r\n    event CrossChainInitiatedDepositSingle(\r\n        uint256 indexed payloadId,\r\n        uint64 indexed dstChainId,\r\n        uint256 superformIds,\r\n        uint256 amountIn,\r\n        uint8 bridgeId,\r\n        uint8[] ambIds\r\n    );\r\n\r\n    /// @dev is emitted when a cross-chain withdraw multi vault transaction is initiated.\r\n    event CrossChainInitiatedWithdrawMulti(\r\n        uint256 indexed payloadId, uint64 indexed dstChainId, uint256[] superformIds, uint8[] ambIds\r\n    );\r\n\r\n    /// @dev is emitted when a cross-chain withdraw single vault transaction is initiated.\r\n    event CrossChainInitiatedWithdrawSingle(\r\n        uint256 indexed payloadId, uint64 indexed dstChainId, uint256 superformIds, uint8[] ambIds\r\n    );\r\n\r\n    /// @dev is emitted when a direct chain action is complete\r\n    event Completed();\r\n\r\n    /// @dev is emitted when dust is forwarded to paymaster\r\n    event RouterDustForwardedToPaymaster(address indexed token, uint256 indexed amount);\r\n}\r\n\r\n/// @title IBaseStateRegistry\r\n/// @dev Interface for BaseStateRegistry\r\n/// @author ZeroPoint Labs\r\ninterface IBaseStateRegistry {\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a cross-chain payload is received in the state registry\r\n    event PayloadReceived(uint64 indexed srcChainId, uint64 indexed dstChainId, uint256 indexed payloadId);\r\n\r\n    /// @dev is emitted when a cross-chain proof is received in the state registry\r\n    /// NOTE: comes handy if quorum required is more than 0\r\n    event ProofReceived(bytes indexed proof);\r\n\r\n    /// @dev is emitted when a payload id gets updated\r\n    event PayloadUpdated(uint256 indexed payloadId);\r\n\r\n    /// @dev is emitted when a payload id gets processed\r\n    event PayloadProcessed(uint256 indexed payloadId);\r\n\r\n    /// @dev is emitted when the super registry address is updated\r\n    event SuperRegistryUpdated(address indexed superRegistry);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows users to read the total payloads received by the registry\r\n    function payloadsCount() external view returns (uint256);\r\n\r\n    /// @dev allows user to read the payload state\r\n    /// uint256 payloadId_ is the unique payload identifier allocated on the destination chain\r\n    function payloadTracking(uint256 payloadId_) external view returns (PayloadState payloadState_);\r\n\r\n    /// @dev allows users to read the bytes payload_ stored per payloadId_\r\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\r\n    /// @return payloadBody_ the crosschain data received\r\n    function payloadBody(uint256 payloadId_) external view returns (bytes memory payloadBody_);\r\n\r\n    /// @dev allows users to read the uint256 payloadHeader stored per payloadId_\r\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\r\n    /// @return payloadHeader_ the crosschain header received\r\n    function payloadHeader(uint256 payloadId_) external view returns (uint256 payloadHeader_);\r\n\r\n    /// @dev allows users to read the ambs that delivered the payload id\r\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\r\n    /// @return ambIds_ is the identifier of ambs that delivered the message and proof\r\n    function getMessageAMB(uint256 payloadId_) external view returns (uint8[] memory ambIds_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows core contracts to send payload to a destination chain.\r\n    /// @param srcSender_ is the caller of the function (used for gas refunds).\r\n    /// @param ambIds_ is the identifier of the arbitrary message bridge to be used\r\n    /// @param dstChainId_ is the internal chainId used throughout the protocol\r\n    /// @param message_ is the crosschain payload to be sent\r\n    /// @param extraData_ defines all the message bridge related overrides\r\n    /// NOTE: dstChainId_ is mapped to message bridge's destination id inside it's implementation contract\r\n    /// NOTE: ambIds_ are superform assigned unique identifier for arbitrary message bridges\r\n    function dispatchPayload(\r\n        address srcSender_,\r\n        uint8[] memory ambIds_,\r\n        uint64 dstChainId_,\r\n        bytes memory message_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable;\r\n\r\n    /// @dev allows state registry to receive messages from message bridge implementations\r\n    /// @param srcChainId_ is the superform chainId from which the payload is dispatched/sent\r\n    /// @param message_ is the crosschain payload received\r\n    /// NOTE: Only {IMPLEMENTATION_CONTRACT} role can call this function.\r\n    function receivePayload(uint64 srcChainId_, bytes memory message_) external;\r\n\r\n    /// @dev allows privileged actors to process cross-chain payloads\r\n    /// @param payloadId_ is the identifier of the cross-chain payload\r\n    /// NOTE: Only {CORE_STATE_REGISTRY_PROCESSOR_ROLE} role can call this function\r\n    /// NOTE: this should handle reverting the state on source chain in-case of failure\r\n    /// (or) can implement scenario based reverting like in coreStateRegistry\r\n    function processPayload(uint256 payloadId_) external payable;\r\n}\r\n\r\n/// @title IPayMaster\r\n/// @dev Interface for PayMaster\r\n/// @author ZeroPoint Labs\r\ninterface IPayMaster {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a new payment is made\r\n    event Payment(address indexed user, uint256 indexed amount);\r\n\r\n    /// @dev is emitted when  tokens are moved out of paymaster\r\n    event TokenWithdrawn(address indexed receiver, address indexed token, uint256 indexed amount);\r\n\r\n    /// @dev is emitted when native tokens are moved out of paymaster\r\n    event NativeWithdrawn(address indexed receiver, uint256 indexed amount);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev withdraws token funds from pay master to target id from superRegistry\r\n    /// @param superRegistryId_ is the id of the target address in superRegistry\r\n    /// @param token_ is the token to withdraw from pay master\r\n    /// @param amount_ is the amount to withdraw from pay master\r\n    function withdrawTo(bytes32 superRegistryId_, address token_, uint256 amount_) external;\r\n\r\n    /// @dev withdraws native funds from pay master to target id from superRegistry\r\n    /// @param superRegistryId_ is the id of the target address in superRegistry\r\n    /// @param nativeAmount_ is the amount to withdraw from pay master\r\n    function withdrawNativeTo(bytes32 superRegistryId_, uint256 nativeAmount_) external;\r\n\r\n    /// @dev withdraws fund from pay master to target id from superRegistry\r\n    /// @param superRegistryId_ is the id of the target address in superRegistry\r\n    /// @param req_ is the off-chain generated liquidity request to move funds\r\n    /// @param dstChainId_ is the destination chain id\r\n    function rebalanceTo(bytes32 superRegistryId_, LiqRequest memory req_, uint64 dstChainId_) external;\r\n\r\n    /// @dev retries a stuck payload on any supported amb using funds from paymaster\r\n    /// @param ambId_ is the identifier of the AMB\r\n    /// @param nativeValue_ is the native fees to be sent along the transaction\r\n    /// @param data_ is the amb specific encoded retry data [check individual AMB implementations]\r\n    function treatAMB(uint8 ambId_, uint256 nativeValue_, bytes memory data_) external;\r\n\r\n    /// @dev accepts payment from user\r\n    /// @param user_ is the wallet address of the paying user\r\n    function makePayment(address user_) external payable;\r\n}\r\n\r\n/// @title IPaymentHelper\r\n/// @dev Interface for PaymentHelper\r\n/// @author ZeroPoint Labs\r\ninterface IPaymentHelper {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @param nativeFeedOracle is the native price feed oracle\r\n    /// @param gasPriceOracle is the gas price oracle\r\n    /// @param swapGasUsed is the swap gas params\r\n    /// @param updateGasUsed is the update gas params\r\n    /// @param depositGasUsed is the deposit per vault gas on the chain\r\n    /// @param withdrawGasUsed is the withdraw per vault gas on the chain\r\n    /// @param defaultNativePrice is the native price on the specified chain\r\n    /// @param defaultGasPrice is the gas price on the specified chain\r\n    /// @param dstGasPerByte is the gas per size of data on the specified chain\r\n    /// @param ackGasCost is the gas cost for processing acknowledgements on src chain\r\n    /// @param timelockCost is the extra cost for processing timelocked payloads\r\n    /// @param emergencyCost is the extra cost for processing emergency payloads\r\n    struct PaymentHelperConfig {\r\n        address nativeFeedOracle;\r\n        address gasPriceOracle;\r\n        uint256 swapGasUsed;\r\n        uint256 updateGasUsed;\r\n        uint256 depositGasUsed;\r\n        uint256 withdrawGasUsed;\r\n        uint256 defaultNativePrice;\r\n        uint256 defaultGasPrice;\r\n        uint256 dstGasPerByte;\r\n        uint256 ackGasCost;\r\n        uint256 timelockCost;\r\n        uint256 emergencyCost;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    event ChainConfigUpdated(uint64 indexed chainId_, uint256 indexed configType_, bytes indexed config_);\r\n    event ChainConfigAdded(uint64 chainId_, PaymentHelperConfig config_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the amb overrides & gas to be used\r\n    /// @param dstChainId_ is the unique dst chain identifier\r\n    /// @param ambIds_ is the identifiers of arbitrary message bridges to be used\r\n    /// @param message_ is the encoded cross-chain payload\r\n    function calculateAMBData(\r\n        uint64 dstChainId_,\r\n        uint8[] calldata ambIds_,\r\n        bytes memory message_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 totalFees, bytes memory extraData);\r\n\r\n    /// @dev returns the amb overrides & gas to be used\r\n    /// @return extraData the amb specific override information\r\n    function getRegisterTransmuterAMBData() external view returns (bytes memory extraData);\r\n\r\n    /// @dev returns the gas fees estimation in native tokens if we send message through a combination of AMBs\r\n    /// @param ambIds_ is the identifier of different AMBs\r\n    /// @param dstChainId_ is the identifier of the destination chain\r\n    /// @param message_ is the cross-chain message\r\n    /// @param extraData_ is any amb-specific information\r\n    /// @return ambFees is the native_tokens to be sent along the transaction for all the ambIds_ included\r\n    function estimateAMBFees(\r\n        uint8[] memory ambIds_,\r\n        uint64 dstChainId_,\r\n        bytes memory message_,\r\n        bytes[] memory extraData_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 ambFees, uint256[] memory);\r\n\r\n    /// @dev estimates the gas fees for multiple destination and multi vault operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateMultiDstMultiVault(\r\n        MultiDstMultiVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for multiple destination and single vault operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateMultiDstSingleVault(\r\n        MultiDstSingleVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for single destination and multi vault operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateSingleXChainMultiVault(\r\n        SingleXChainMultiVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for single destination and single vault operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateSingleXChainSingleVault(\r\n        SingleXChainSingleVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for same chain operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateSingleDirectSingleVault(\r\n        SingleDirectSingleVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for multiple same chain operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateSingleDirectMultiVault(\r\n        SingleDirectMultiVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev admin can configure a remote chain for first time\r\n    /// @param chainId_ is the identifier of new chain id\r\n    /// @param config_ is the chain config\r\n    function addRemoteChain(uint64 chainId_, PaymentHelperConfig calldata config_) external;\r\n\r\n    /// @dev admin can specifically configure/update certain configuration of a remote chain\r\n    /// @param chainId_ is the remote chain's identifier\r\n    /// @param configType_ is the type of config from 1 -> 6\r\n    /// @param config_ is the encoded new configuration\r\n    function updateRemoteChain(uint64 chainId_, uint256 configType_, bytes memory config_) external;\r\n\r\n    /// @dev admin updates config for register transmuter amb params\r\n    /// @param extraDataForTransmuter_ is the broadcast extra data\r\n    function updateRegisterAERC20Params(bytes memory extraDataForTransmuter_) external;\r\n}\r\n\r\n/// @title ISuperformFactory\r\n/// @dev Interface for SuperformFactory\r\n/// @author ZeroPoint Labs\r\ninterface ISuperformFactory {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                         CONSTANTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    enum PauseStatus {\r\n        NON_PAUSED,\r\n        PAUSED\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev emitted when a new formImplementation is entered into the factory\r\n    /// @param formImplementation is the address of the new form implementation\r\n    /// @param formImplementationId is the id of the formImplementation\r\n    /// @param formStateRegistryId is any additional state registry id of the formImplementation\r\n    event FormImplementationAdded(\r\n        address indexed formImplementation, uint256 indexed formImplementationId, uint8 indexed formStateRegistryId\r\n    );\r\n\r\n    /// @dev emitted when a new Superform is created\r\n    /// @param formImplementationId is the id of the form implementation\r\n    /// @param vault is the address of the vault\r\n    /// @param superformId is the id of the superform\r\n    /// @param superform is the address of the superform\r\n    event SuperformCreated(\r\n        uint256 indexed formImplementationId, address indexed vault, uint256 indexed superformId, address superform\r\n    );\r\n\r\n    /// @dev emitted when a new SuperRegistry is set\r\n    /// @param superRegistry is the address of the super registry\r\n    event SuperRegistrySet(address indexed superRegistry);\r\n\r\n    /// @dev emitted when a form implementation is paused\r\n    /// @param formImplementationId is the id of the form implementation\r\n    /// @param paused is the new paused status\r\n    event FormImplementationPaused(uint256 indexed formImplementationId, PauseStatus indexed paused);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the number of forms\r\n    /// @return forms_ is the number of forms\r\n    function getFormCount() external view returns (uint256 forms_);\r\n\r\n    /// @dev returns the number of superforms\r\n    /// @return superforms_ is the number of superforms\r\n    function getSuperformCount() external view returns (uint256 superforms_);\r\n\r\n    /// @dev returns the address of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return formImplementation_ is the address of the form implementation\r\n    function getFormImplementation(uint32 formImplementationId_) external view returns (address formImplementation_);\r\n\r\n    /// @dev returns the form state registry id of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return stateRegistryId_ is the additional state registry id of the form\r\n    function getFormStateRegistryId(uint32 formImplementationId_) external view returns (uint8 stateRegistryId_);\r\n\r\n    /// @dev returns the paused status of form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return paused_ is the current paused status of the form formImplementationId_\r\n    function isFormImplementationPaused(uint32 formImplementationId_) external view returns (bool paused_);\r\n\r\n    /// @dev returns the address of a superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return superform_ is the address of the superform\r\n    /// @return formImplementationId_ is the id of the form implementation\r\n    /// @return chainId_ is the chain id\r\n    function getSuperform(uint256 superformId_)\r\n        external\r\n        pure\r\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_);\r\n\r\n    /// @dev returns if an address has been added to a Form\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return isSuperform_ bool if it exists\r\n    function isSuperform(uint256 superformId_) external view returns (bool isSuperform_);\r\n\r\n    /// @dev Reverse query of getSuperform, returns all superforms for a given vault\r\n    /// @param vault_ is the address of a vault\r\n    /// @return superformIds_ is the id of the superform\r\n    /// @return superforms_ is the address of the superform\r\n    function getAllSuperformsFromVault(address vault_)\r\n        external\r\n        view\r\n        returns (uint256[] memory superformIds_, address[] memory superforms_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows an admin to add a Form implementation to the factory\r\n    /// @param formImplementation_ is the address of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation (generated off-chain and equal in all chains)\r\n    /// @param formStateRegistryId_ is the id of any additional state registry for that form\r\n    /// @dev formStateRegistryId_ 1 is default for all form implementations, pass in formStateRegistryId_ only if an\r\n    /// additional state registry is required\r\n    function addFormImplementation(\r\n        address formImplementation_,\r\n        uint32 formImplementationId_,\r\n        uint8 formStateRegistryId_\r\n    )\r\n        external;\r\n\r\n    /// @dev To add new vaults to Form implementations, fusing them together into Superforms\r\n    /// @param formImplementationId_ is the form implementation we want to attach the vault to\r\n    /// @param vault_ is the address of the vault\r\n    /// @return superformId_ is the id of the created superform\r\n    /// @return superform_ is the address of the created superform\r\n    function createSuperform(\r\n        uint32 formImplementationId_,\r\n        address vault_\r\n    )\r\n        external\r\n        returns (uint256 superformId_, address superform_);\r\n\r\n    /// @dev to synchronize superforms added to different chains using broadcast registry\r\n    /// @param data_ is the cross-chain superform id\r\n    function stateSyncBroadcast(bytes memory data_) external payable;\r\n\r\n    /// @dev allows an admin to change the status of a form\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @param status_ is the new status\r\n    /// @param extraData_ is optional & passed when broadcasting of status is needed\r\n    function changeFormImplementationPauseStatus(\r\n        uint32 formImplementationId_,\r\n        PauseStatus status_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC-165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\r\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\r\n */\r\ninterface IERC4626 is IERC20, IERC20Metadata {\r\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\r\n}\r\n\r\n/// @title IBaseForm\r\n/// @dev Interface for BaseForm\r\n/// @author ZeroPoint Labs\r\ninterface IBaseForm is IERC165 {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                           //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a new vault is added by the admin.\r\n    event VaultAdded(uint256 indexed id, IERC4626 indexed vault);\r\n\r\n    /// @dev is emitted when a payload is processed by the destination contract.\r\n    event Processed(\r\n        uint64 indexed srcChainID,\r\n        uint64 indexed dstChainId,\r\n        uint256 indexed srcPayloadId,\r\n        uint256 amount,\r\n        address vault\r\n    );\r\n\r\n    /// @dev is emitted when an emergency withdrawal is processed\r\n    event EmergencyWithdrawalProcessed(address indexed refundAddress, uint256 indexed amount);\r\n\r\n    /// @dev is emitted when dust is forwarded to the paymaster\r\n    event FormDustForwardedToPaymaster(address indexed token, uint256 indexed amount);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @notice get Superform name of the ERC20 vault representation\r\n    /// @return The ERC20 name\r\n    function superformYieldTokenName() external view returns (string memory);\r\n\r\n    /// @notice get Superform symbol of the ERC20 vault representation\r\n    /// @return The ERC20 symbol\r\n    function superformYieldTokenSymbol() external view returns (string memory);\r\n\r\n    /// @notice get the state registry id associated with the vault\r\n    function getStateRegistryId() external view returns (uint8);\r\n\r\n    /// @notice Returns the vault address\r\n    /// @return The address of the vault\r\n    function getVaultAddress() external view returns (address);\r\n\r\n    /// @notice Returns the vault address\r\n    /// @return The address of the vault asset\r\n    function getVaultAsset() external view returns (address);\r\n\r\n    /// @notice Returns the name of the vault.\r\n    /// @return The name of the vault\r\n    function getVaultName() external view returns (string memory);\r\n\r\n    /// @notice Returns the symbol of a vault.\r\n    /// @return The symbol associated with a vault\r\n    function getVaultSymbol() external view returns (string memory);\r\n\r\n    /// @notice Returns the number of decimals in a vault for accounting purposes\r\n    /// @return The number of decimals in the vault balance\r\n    function getVaultDecimals() external view returns (uint256);\r\n\r\n    /// @notice Returns the amount of underlying tokens each share of a vault is worth.\r\n    /// @return The pricePerVaultShare value\r\n    function getPricePerVaultShare() external view returns (uint256);\r\n\r\n    /// @notice Returns the amount of vault shares owned by the form.\r\n    /// @return The form's vault share balance\r\n    function getVaultShareBalance() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of underlying managed in the ERC4626 vault\r\n    function getTotalAssets() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of unredeemed vault shares in circulation\r\n    function getTotalSupply() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of assets received if shares are actually redeemed\r\n    /// @notice https://eips.ethereum.org/EIPS/eip-4626\r\n    function getPreviewPricePerVaultShare() external view returns (uint256);\r\n\r\n    /// @dev API may need to know state of funds deployed\r\n    function previewDepositTo(uint256 assets_) external view returns (uint256);\r\n\r\n    /// @notice positionBalance() -> .vaultIds&destAmounts\r\n    /// @return how much of an asset + interest (accrued) is to withdraw from the Vault\r\n    function previewWithdrawFrom(uint256 assets_) external view returns (uint256);\r\n\r\n    /// @dev API may need to know state of funds deployed\r\n    function previewRedeemFrom(uint256 shares_) external view returns (uint256);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev process same chain id deposits\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @return shares  The amount of vault shares received\r\n    function directDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 shares);\r\n\r\n    /// @dev process same chain id deposits\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @param srcChainId_ The chain id of the source chain\r\n    /// @return shares  The amount of vault shares received\r\n    /// @dev is shares is `0` then no further action/acknowledgement needs to be sent\r\n    function xChainDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        external\r\n        returns (uint256 shares);\r\n\r\n    /// @dev process withdrawal of asset from a vault\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @return assets  The amount of assets received\r\n    function directWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        external\r\n        returns (uint256 assets);\r\n\r\n    /// @dev process withdrawal of asset from a vault\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @param srcChainId_ The chain id of the source chain\r\n    /// @return assets The amount of assets received\r\n    function xChainWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        external\r\n        returns (uint256 assets);\r\n\r\n    /// @dev process withdrawal of shares if form is paused\r\n    /// @param receiverAddress_ The address to refund the shares to\r\n    /// @param amount_ The amount of vault shares to refund\r\n    function emergencyWithdraw(address receiverAddress_, uint256 amount_) external;\r\n\r\n    /// @dev moves all dust in the contract to Paymaster contract\r\n    /// @param token_ The address of the token to forward\r\n    function forwardDustToPaymaster(address token_) external;\r\n}\r\n\r\n/// @title Bridge Validator Interface\r\n/// @dev Interface all Bridge Validators must follow\r\n/// @author Zeropoint Labs\r\ninterface IBridgeValidator {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    struct ValidateTxDataArgs {\r\n        bytes txData;\r\n        uint64 srcChainId;\r\n        uint64 dstChainId;\r\n        uint64 liqDstChainId;\r\n        bool deposit;\r\n        address superform;\r\n        address receiverAddress;\r\n        address liqDataToken;\r\n        address liqDataInterimToken;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev validates the receiver of the liquidity request\r\n    /// @param txData_ is the txData of the cross chain deposit\r\n    /// @param receiver_ is the address of the receiver to validate\r\n    /// @return valid_ if the address is valid\r\n    function validateReceiver(bytes calldata txData_, address receiver_) external pure returns (bool valid_);\r\n\r\n    /// @dev validates the txData of a cross chain deposit\r\n    /// @param args_ the txData arguments to validate in txData\r\n    /// @return hasDstSwap if the txData contains a destination swap\r\n    function validateTxData(ValidateTxDataArgs calldata args_) external view returns (bool hasDstSwap);\r\n\r\n    /// @dev decodes the txData and returns the amount of input token on source\r\n    /// @param txData_ is the txData of the cross chain deposit\r\n    /// @param genericSwapDisallowed_ true if generic swaps are disallowed\r\n    /// @return amount_ the amount expected\r\n    function decodeAmountIn(\r\n        bytes calldata txData_,\r\n        bool genericSwapDisallowed_\r\n    )\r\n        external\r\n        pure\r\n        returns (uint256 amount_);\r\n\r\n    /// @dev decodes neccesary information for processing swaps on the destination chain\r\n    /// @param txData_ is the txData to be decoded\r\n    /// @return token_ is the address of the token\r\n    /// @return amount_ the amount expected\r\n    function decodeDstSwap(bytes calldata txData_) external pure returns (address token_, uint256 amount_);\r\n\r\n    /// @dev decodes the final output token address (for only direct chain actions!)\r\n    /// @param txData_ is the txData to be decoded\r\n    /// @return token_ the address of the token\r\n    function decodeSwapOutputToken(bytes calldata txData_) external pure returns (address token_);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\r\n\r\n/**\r\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\r\n     *\r\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\r\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\r\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\r\n     * reentrancy guards when interacting with untrusted contracts.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\r\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\r\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\r\n     * reentrancy guards when interacting with untrusted contracts.\r\n     *\r\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `values` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC1155A is IERC1155 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Event emitted when single id approval is set\r\n    event ApprovalForOne(address indexed owner, address indexed spender, uint256 id, uint256 amount);\r\n    event TransmutedBatchToERC20(address user, uint256[] ids, uint256[] amounts);\r\n    event TransmutedBatchToERC1155A(address user, uint256[] ids, uint256[] amounts);\r\n    event TransmutedToERC20(address user, uint256 id, uint256 amount);\r\n    event TransmutedToERC1155A(address user, uint256 id, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n    /// @dev for batch operations, if there is a length mismatch\r\n    error LENGTH_MISMATCH();\r\n\r\n    /// @dev operator is not an owner of ids or not enough of allowance, or is not approvedForAll\r\n    error NOT_AUTHORIZED();\r\n\r\n    /// @dev if allowance is lower than amount for the operation\r\n    error NOT_ENOUGH_ALLOWANCE();\r\n\r\n    /// @dev Thrown when AERC20 was already registered\r\n    error AERC20_ALREADY_REGISTERED();\r\n\r\n    /// @dev Thrown when AERC20 was not registered\r\n    error AERC20_NOT_REGISTERED();\r\n\r\n    /// @dev allowance amount cannot be decreased below zero\r\n    error DECREASED_ALLOWANCE_BELOW_ZERO();\r\n\r\n    /// @dev address is 0\r\n    error ZERO_ADDRESS();\r\n\r\n    /// @dev forbids transfers to address 0\r\n    error TRANSFER_TO_ADDRESS_ZERO();\r\n\r\n    /// @dev forbids registering a saErc20 if no associated erc1155a has been minted yet first\r\n    error ID_NOT_MINTED_YET();\r\n    /*//////////////////////////////////////////////////////////////\r\n                              SINGLE APPROVE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Public function for setting single id approval\r\n    /// @dev Notice `owner` param, it will always be msg.sender, see _setApprovalForOne()\r\n    function setApprovalForOne(address spender, uint256 id, uint256 amount) external;\r\n\r\n    /// @notice Public getter for existing single id approval\r\n    /// @dev Re-adapted from ERC20\r\n    function allowance(address owner, address spender, uint256 id) external returns (uint256);\r\n\r\n    /// @notice Public function for increasing single id approval amount\r\n    /// @dev Re-adapted from ERC20\r\n    function increaseAllowance(address spender, uint256 id, uint256 addedValue) external returns (bool);\r\n\r\n    /// @notice Public function for decreasing single id approval amount\r\n    /// @dev Re-adapted from ERC20\r\n    function decreaseAllowance(address spender, uint256 id, uint256 subtractedValue) external returns (bool);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              MULTI APPROVE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Public function for setting multiple id approval\r\n    /// @dev extension of sigle id approval\r\n    function setApprovalForMany(address spender, uint256[] memory ids, uint256[] memory amounts) external;\r\n\r\n    /// @notice Public function for increasing multiple id approval amount at once\r\n    /// @dev extension of single id increase allowance\r\n    function increaseAllowanceForMany(\r\n        address spender,\r\n        uint256[] memory ids,\r\n        uint256[] memory addedValues\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    /// @notice Public function for decreasing multiple id approval amount at once\r\n    /// @dev extension of single id decrease allowance\r\n    function decreaseAllowanceForMany(\r\n        address spender,\r\n        uint256[] memory ids,\r\n        uint256[] memory subtractedValues\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    AERC20 AND TRANSMUTE LOGIC \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Function set to virtual so that implementing protocols may introduce RBAC here or perform other changes\r\n    /// @notice payable to allow any implementing cross-chain protocol to be paid for fees for relaying this action to\r\n    /// various chain\r\n    /// @param id of the ERC1155 to create a ERC20 for\r\n    function registerAERC20(uint256 id) external payable returns (address);\r\n\r\n    /// @notice Use transmuteBatchToERC20 to transmute multiple ERC1155 ids into separate ERC20\r\n    /// Easier to transmute to 1155A than to transmute back to aErc20 because of ERC1155 beauty!\r\n    /// @param onBehalfOf address of the user on whose behalf this transmutation is happening\r\n    /// @param ids ids of the ERC1155A to transmute\r\n    /// @param amounts amounts of the ERC1155A to transmute\r\n    function transmuteBatchToERC20(address onBehalfOf, uint256[] memory ids, uint256[] memory amounts) external;\r\n\r\n    /// @notice Use transmuteBatchToERC1155A to transmute multiple ERC20 ids into separate ERC1155\r\n    /// @param onBehalfOf address of the user on whose behalf this transmutation is happening\r\n    /// @param ids ids of the ERC20 to transmute\r\n    /// @param amounts amounts of the ERC20 to transmute\r\n    function transmuteBatchToERC1155A(address onBehalfOf, uint256[] memory ids, uint256[] memory amounts) external;\r\n\r\n    /// @param onBehalfOf address of the user on whose behalf this transmutation is happening\r\n    /// @param id id of the ERC20s to transmute to aErc20\r\n    /// @param amount amount of the ERC20s to transmute to aErc20\r\n    function transmuteToERC20(address onBehalfOf, uint256 id, uint256 amount) external;\r\n\r\n    /// @param onBehalfOf address of the user on whose behalf this transmutation is happening\r\n    /// @param id id of the ERC20s to transmute to erc1155\r\n    /// @param amount amount of the ERC20s to transmute to erc1155\r\n    function transmuteToERC1155A(address onBehalfOf, uint256 id, uint256 amount) external;\r\n\r\n    /// @notice Public getter for the address of the aErc20 token for a given ERC1155 id\r\n    /// @param id id of the ERC1155 to get the aErc20 token address for\r\n    /// @return aERC20 address of the aErc20 token for the given ERC1155 id\r\n    function getERC20TokenAddress(uint256 id) external view returns (address aERC20);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                METADATA \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Compute return string from baseURI set for this contract and unique vaultId\r\n    function uri(uint256 id) external view returns (string memory);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            SUPPLY GETTERS \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Public getter for existing single id total supply\r\n    function totalSupply(uint256 id) external view returns (uint256);\r\n\r\n    /// @notice Public getter to know if a token id exists\r\n    /// @dev determines based on total supply for the id\r\n    function exists(uint256 id) external view returns (bool);\r\n\r\n    /// @dev handy helper to check if a AERC20 is registered\r\n    /// @param id of the ERC1155 to check if a AERC20 exists for\r\n    function aERC20Exists(uint256 id) external view returns (bool);\r\n}\r\n\r\n/// @title ISuperPositions\r\n/// @dev Interface for SuperPositions\r\n/// @author Zeropoint Labs\r\ninterface ISuperPositions is IERC1155A {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          STRUCTS                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    struct TxHistory {\r\n        uint256 txInfo;\r\n        address receiverAddressSP;\r\n    }\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a dynamic uri is updated\r\n    event DynamicURIUpdated(string indexed oldURI, string indexed newURI, bool indexed frozen);\r\n\r\n    /// @dev is emitted when a cross-chain transaction is completed.\r\n    event Completed(uint256 indexed txId);\r\n\r\n    /// @dev is emitted when a aErc20 token is registered\r\n    event AERC20TokenRegistered(uint256 indexed tokenId, address indexed tokenAddress);\r\n\r\n    /// @dev is emitted when a tx info is saved\r\n    event TxHistorySet(uint256 indexed payloadId, uint256 txInfo, address indexed receiverAddress);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the payload header and the receiver address for a tx id on the source chain\r\n    /// @param txId_ is the identifier of the transaction issued by superform router\r\n    /// @return txInfo is the header of the payload\r\n    /// @return receiverAddressSP is the address of the receiver of superPositions\r\n    function txHistory(uint256 txId_) external view returns (uint256 txInfo, address receiverAddressSP);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev saves the message being sent together with the associated id formulated in a router\r\n    /// @param payloadId_ is the id of the message being saved\r\n    /// @param txInfo_ is the header of the AMBMessage of the transaction being saved\r\n    /// @param receiverAddressSP_ is the address of the receiver of superPositions\r\n    function updateTxHistory(uint256 payloadId_, uint256 txInfo_, address receiverAddressSP_) external;\r\n\r\n    /// @dev allows minter to mint shares on source\r\n    /// @param receiverAddress_ is the beneficiary of shares\r\n    /// @param id_ is the id of the shares\r\n    /// @param amount_ is the amount of shares to mint\r\n    function mintSingle(address receiverAddress_, uint256 id_, uint256 amount_) external;\r\n\r\n    /// @dev allows minter to mint shares on source in batch\r\n    /// @param receiverAddress_ is the beneficiary of shares\r\n    /// @param ids_ are the ids of the shares\r\n    /// @param amounts_ are the amounts of shares to mint\r\n    function mintBatch(address receiverAddress_, uint256[] memory ids_, uint256[] memory amounts_) external;\r\n\r\n    /// @dev allows superformRouter to burn shares on source\r\n    /// @notice burn is done optimistically by the router in the beginning of the withdraw transactions\r\n    /// @notice in case the withdraw tx fails on the destination, shares are reminted through stateSync\r\n    /// @param srcSender_ is the address of the sender\r\n    /// @param id_ is the id of the shares\r\n    /// @param amount_ is the amount of shares to burn\r\n    function burnSingle(address srcSender_, uint256 id_, uint256 amount_) external;\r\n\r\n    /// @dev allows burner to burn shares on source in batch\r\n    /// @param srcSender_ is the address of the sender\r\n    /// @param ids_ are the ids of the shares\r\n    /// @param amounts_ are the amounts of shares to burn\r\n    function burnBatch(address srcSender_, uint256[] memory ids_, uint256[] memory amounts_) external;\r\n\r\n    /// @dev allows state registry contract to mint shares on source\r\n    /// @param data_ is the received information to be processed.\r\n    /// @return srcChainId_ is the decoded srcChainId.\r\n    function stateMultiSync(AMBMessage memory data_) external returns (uint64 srcChainId_);\r\n\r\n    /// @dev allows state registry contract to mint shares on source\r\n    /// @param data_ is the received information to be processed.\r\n    /// @return srcChainId_ is the decoded srcChainId.\r\n    function stateSync(AMBMessage memory data_) external returns (uint64 srcChainId_);\r\n\r\n    /// @dev sets the dynamic uri for NFT\r\n    /// @param dynamicURI_ is the dynamic uri of the NFT\r\n    /// @param freeze_ is to prevent updating the metadata once migrated to IPFS\r\n    function setDynamicURI(string memory dynamicURI_, bool freeze_) external;\r\n\r\n    /// @dev allows to create sERC0 using broadcast state registry\r\n    /// @param data_ is the crosschain payload\r\n    function stateSyncBroadcast(bytes memory data_) external payable;\r\n}\r\n\r\nlibrary DataLib {\r\n    function packTxInfo(\r\n        uint8 txType_,\r\n        uint8 callbackType_,\r\n        uint8 multi_,\r\n        uint8 registryId_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 txInfo)\r\n    {\r\n        txInfo = uint256(txType_);\r\n        txInfo |= uint256(callbackType_) << 8;\r\n        txInfo |= uint256(multi_) << 16;\r\n        txInfo |= uint256(registryId_) << 24;\r\n        txInfo |= uint256(uint160(srcSender_)) << 32;\r\n        txInfo |= uint256(srcChainId_) << 192;\r\n    }\r\n\r\n    function decodeTxInfo(uint256 txInfo_)\r\n        internal\r\n        pure\r\n        returns (uint8 txType, uint8 callbackType, uint8 multi, uint8 registryId, address srcSender, uint64 srcChainId)\r\n    {\r\n        txType = uint8(txInfo_);\r\n        callbackType = uint8(txInfo_ >> 8);\r\n        multi = uint8(txInfo_ >> 16);\r\n        registryId = uint8(txInfo_ >> 24);\r\n        srcSender = address(uint160(txInfo_ >> 32));\r\n        srcChainId = uint64(txInfo_ >> 192);\r\n    }\r\n\r\n    /// @dev returns the vault-form-chain pair of a superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return superform_ is the address of the superform\r\n    /// @return formImplementationId_ is the form id\r\n    /// @return chainId_ is the chain id\r\n    function getSuperform(uint256 superformId_)\r\n        internal\r\n        pure\r\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_)\r\n    {\r\n        superform_ = address(uint160(superformId_));\r\n        formImplementationId_ = uint32(superformId_ >> 160);\r\n        chainId_ = uint64(superformId_ >> 192);\r\n\r\n        if (chainId_ == 0) {\r\n            revert Error.INVALID_CHAIN_ID();\r\n        }\r\n    }\r\n\r\n    /// @dev returns the vault-form-chain pair of an array of superforms\r\n    /// @param superformIds_  array of superforms\r\n    /// @return superforms_ are the address of the vaults\r\n    function getSuperforms(uint256[] memory superformIds_) internal pure returns (address[] memory superforms_) {\r\n        uint256 len = superformIds_.length;\r\n        superforms_ = new address[](len);\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            (superforms_[i],,) = getSuperform(superformIds_[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev returns the destination chain of a given superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return chainId_ is the chain id\r\n    function getDestinationChain(uint256 superformId_) internal pure returns (uint64 chainId_) {\r\n        chainId_ = uint64(superformId_ >> 192);\r\n\r\n        if (chainId_ == 0) {\r\n            revert Error.INVALID_CHAIN_ID();\r\n        }\r\n    }\r\n\r\n    /// @dev generates the superformId\r\n    /// @param superform_ is the address of the superform\r\n    /// @param formImplementationId_ is the type of the form\r\n    /// @param chainId_ is the chain id on which the superform is deployed\r\n    function packSuperform(\r\n        address superform_,\r\n        uint32 formImplementationId_,\r\n        uint64 chainId_\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 superformId_)\r\n    {\r\n        superformId_ = uint256(uint160(superform_));\r\n        superformId_ |= uint256(formImplementationId_) << 160;\r\n        superformId_ |= uint256(chainId_) << 192;\r\n    }\r\n}\r\n\r\n/// @title Liquidity Handler.\r\n/// @author https://github.com/dragonfly-xyz/useful-solidity-patterns/blob/main/patterns/permit2/Permit2Vault.sol\r\n/// @dev Minimal Permit2 interface, derived from\r\n/// @dev https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol\r\ninterface IPermit2 {\r\n    // Token and amount in a permit message.\r\n    struct TokenPermissions {\r\n        // Token to transfer.\r\n        IERC20 token;\r\n        // Amount to transfer.\r\n        uint256 amount;\r\n    }\r\n\r\n    // The permit2 message.\r\n    struct PermitTransferFrom {\r\n        // Permitted token and amount.\r\n        TokenPermissions permitted;\r\n        // Unique identifier for this permit.\r\n        uint256 nonce;\r\n        // Expiration for this permit.\r\n        uint256 deadline;\r\n    }\r\n\r\n    // Transfer details for permitTransferFrom().\r\n    struct SignatureTransferDetails {\r\n        // Recipient of tokens.\r\n        address to;\r\n        // Amount to transfer.\r\n        uint256 requestedAmount;\r\n    }\r\n\r\n    // Consume a permit2 message and transfer tokens.\r\n    function permitTransferFrom(\r\n        PermitTransferFrom calldata permit,\r\n        SignatureTransferDetails calldata transferDetails,\r\n        address owner,\r\n        bytes calldata signature\r\n    )\r\n        external;\r\n}\r\n\r\n/// @title LiquidityHandler\r\n/// @dev Executes an action with tokens to either bridge from Chain A -> Chain B or swap on same chain\r\n/// @dev To be inherited by contracts that move liquidity\r\n/// @author ZeroPoint Labs\r\nabstract contract LiquidityHandler {\r\n    using SafeERC20 for IERC20;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                         CONSTANTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    address constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  INTERNAL FUNCTIONS                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev dispatches tokens via a liquidity bridge or exchange\r\n    /// @param bridge_ Bridge address to pass tokens to\r\n    /// @param txData_ liquidity bridge data\r\n    /// @param token_ Token caller deposits into superform\r\n    /// @param amount_ Amount of tokens to deposit\r\n    /// @param nativeAmount_ msg.value or msg.value + native tokens\r\n    function _dispatchTokens(\r\n        address bridge_,\r\n        bytes memory txData_,\r\n        address token_,\r\n        uint256 amount_,\r\n        uint256 nativeAmount_\r\n    )\r\n        internal\r\n        virtual\r\n    {\r\n        if (amount_ == 0) {\r\n            revert Error.ZERO_AMOUNT();\r\n        }\r\n\r\n        if (bridge_ == address(0)) {\r\n            revert Error.ZERO_ADDRESS();\r\n        }\r\n\r\n        if (token_ != NATIVE) {\r\n            IERC20(token_).safeIncreaseAllowance(bridge_, amount_);\r\n        } else {\r\n            if (nativeAmount_ < amount_) revert Error.INSUFFICIENT_NATIVE_AMOUNT();\r\n            if (nativeAmount_ > address(this).balance) revert Error.INSUFFICIENT_BALANCE();\r\n        }\r\n\r\n        (bool success,) = payable(bridge_).call{ value: nativeAmount_ }(txData_);\r\n        if (!success) revert Error.FAILED_TO_EXECUTE_TXDATA(token_);\r\n\r\n        if (token_ != NATIVE) {\r\n            IERC20 token = IERC20(token_);\r\n            if (token.allowance(address(this), bridge_) > 0) token.forceApprove(bridge_, 0);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\n/**\r\n * @dev Interface that must be implemented by smart contracts in order to receive\r\n * ERC-1155 token transfers.\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\r\n\r\n/**\r\n * @dev Standard ERC-20 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\r\n */\r\ninterface IERC20Errors {\r\n    /**\r\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     */\r\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC20InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC20InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     */\r\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC20InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC20InvalidSpender(address spender);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC-721 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\r\n */\r\ninterface IERC721Errors {\r\n    /**\r\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\r\n     * Used in balance queries.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721InvalidOwner(address owner);\r\n\r\n    /**\r\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721NonexistentToken(uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param tokenId Identifier number of a token.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC721InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC721InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC721InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC721InvalidOperator(address operator);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC-1155 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\r\n */\r\ninterface IERC1155Errors {\r\n    /**\r\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC1155InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC1155InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC1155MissingApprovalForAll(address operator, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC1155InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC1155InvalidOperator(address operator);\r\n\r\n    /**\r\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\r\n     * Used in batch transfers.\r\n     * @param idsLength Length of the array of token identifiers\r\n     * @param valuesLength Length of the array of token amounts\r\n     */\r\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\r\n}\r\n\r\n/// @title BaseRouterImplementation\r\n/// @dev Extends BaseRouter with standard internal execution functions\r\n/// @author Zeropoint Labs\r\nabstract contract BaseRouterImplementation is IBaseRouterImplementation, BaseRouter, LiquidityHandler {\r\n    using SafeERC20 for IERC20;\r\n    using DataLib for uint256;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                     STATE VARIABLES                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev tracks the total payloads\r\n    uint256 public payloadIds;\r\n    uint256 internal constant ENTIRE_SLIPPAGE = 10_000;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    struct ValidateAndDispatchTokensArgs {\r\n        LiqRequest liqRequest;\r\n        address superform;\r\n        uint64 srcChainId;\r\n        uint64 dstChainId;\r\n        address srcSender;\r\n        bool deposit;\r\n    }\r\n\r\n    struct DirectDepositArgs {\r\n        address superform;\r\n        uint256 payloadId;\r\n        uint256 superformId;\r\n        uint256 amount;\r\n        uint256 outputAmount;\r\n        uint256 maxSlippage;\r\n        bool retain4626;\r\n        LiqRequest liqData;\r\n        address receiverAddress;\r\n        bytes extraFormData;\r\n        uint256 msgValue;\r\n        address srcSender;\r\n    }\r\n\r\n    struct SingleDepositLocalVars {\r\n        address superform;\r\n        uint256 shares;\r\n    }\r\n\r\n    struct SingleDepositArgs {\r\n        address srcSender;\r\n        bytes permit2data;\r\n        address receiverAddressSP;\r\n        InitSingleVaultData vaultData;\r\n    }\r\n\r\n    struct MultiDepositLocalVars {\r\n        uint256 len;\r\n        address[] superforms;\r\n        uint256[] shares;\r\n        bool[] mints;\r\n    }\r\n\r\n    struct MultiDepositArgs {\r\n        address srcSender;\r\n        bytes permit2data;\r\n        address receiverAddressSP;\r\n        InitMultiVaultData vaultData;\r\n    }\r\n\r\n    struct SingleTokenForwardLocalVars {\r\n        IERC20 token;\r\n        uint256 txDataLength;\r\n        uint256 totalAmount;\r\n        uint256 amountIn;\r\n        uint8 bridgeId;\r\n        address permit2;\r\n    }\r\n\r\n    struct MultiTokenForwardLocalVars {\r\n        IERC20 token;\r\n        uint256 len;\r\n        uint256 totalAmount;\r\n        uint256 permit2dataLen;\r\n        uint256 targetLen;\r\n        uint256[] amountsIn;\r\n        uint8[] bridgeIds;\r\n        address permit2;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                      CONSTRUCTOR                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @param superRegistry_ the superform registry contract\r\n    constructor(address superRegistry_) BaseRouter(superRegistry_) { }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                CORE INTERNAL FUNCTIONS                   //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev getter for PERMIT2 in case it is not supported or set on a given chain\r\n    function _getPermit2() internal view returns (address) {\r\n        return superRegistry.PERMIT2();\r\n    }\r\n\r\n    /// @dev returns the address from super registry\r\n    function _getAddress(bytes32 id_) internal view returns (address) {\r\n        return superRegistry.getAddress(id_);\r\n    }\r\n\r\n    /// @dev handles same-chain single vault deposit\r\n    function _singleDirectSingleVaultDeposit(SingleDirectSingleVaultStateReq memory req_) internal virtual {\r\n        /// @dev validate superformData\r\n        if (\r\n            !_validateSuperformData(\r\n                req_.superformData.superformId,\r\n                req_.superformData.amount,\r\n                req_.superformData.outputAmount,\r\n                req_.superformData.maxSlippage,\r\n                req_.superformData.receiverAddress,\r\n                req_.superformData.receiverAddressSP,\r\n                CHAIN_ID,\r\n                true,\r\n                ISuperformFactory(_getAddress(keccak256(\"SUPERFORM_FACTORY\"))),\r\n                false\r\n            )\r\n        ) {\r\n            revert Error.INVALID_SUPERFORMS_DATA();\r\n        }\r\n\r\n        InitSingleVaultData memory vaultData = InitSingleVaultData(\r\n            0,\r\n            req_.superformData.superformId,\r\n            req_.superformData.amount,\r\n            req_.superformData.outputAmount,\r\n            req_.superformData.maxSlippage,\r\n            req_.superformData.liqRequest,\r\n            false,\r\n            req_.superformData.retain4626,\r\n            req_.superformData.receiverAddress,\r\n            req_.superformData.extraFormData\r\n        );\r\n\r\n        /// @dev same chain action & forward residual payment to Paymaster\r\n        _directSingleDeposit(\r\n            SingleDepositArgs(\r\n                msg.sender, req_.superformData.permit2data, req_.superformData.receiverAddressSP, vaultData\r\n            )\r\n        );\r\n        emit Completed();\r\n    }\r\n\r\n    /// @dev handles cross-chain single vault deposit\r\n    function _singleXChainSingleVaultDeposit(SingleXChainSingleVaultStateReq memory req_) internal virtual {\r\n        /// @dev validate the action\r\n        ActionLocalVars memory vars;\r\n        vars.srcChainId = CHAIN_ID;\r\n        if (vars.srcChainId == req_.dstChainId) revert Error.INVALID_ACTION();\r\n\r\n        /// @dev validate superformData\r\n        if (\r\n            !_validateSuperformData(\r\n                req_.superformData.superformId,\r\n                req_.superformData.amount,\r\n                req_.superformData.outputAmount,\r\n                req_.superformData.maxSlippage,\r\n                req_.superformData.receiverAddress,\r\n                req_.superformData.receiverAddressSP,\r\n                req_.dstChainId,\r\n                true,\r\n                ISuperformFactory(_getAddress(keccak256(\"SUPERFORM_FACTORY\"))),\r\n                false\r\n            )\r\n        ) {\r\n            revert Error.INVALID_SUPERFORMS_DATA();\r\n        }\r\n\r\n        vars.currentPayloadId = ++payloadIds;\r\n\r\n        InitSingleVaultData memory ambData = InitSingleVaultData(\r\n            vars.currentPayloadId,\r\n            req_.superformData.superformId,\r\n            req_.superformData.amount,\r\n            req_.superformData.outputAmount,\r\n            req_.superformData.maxSlippage,\r\n            req_.superformData.liqRequest,\r\n            req_.superformData.hasDstSwap,\r\n            req_.superformData.retain4626,\r\n            req_.superformData.receiverAddress,\r\n            req_.superformData.extraFormData\r\n        );\r\n\r\n        (address superform,,) = req_.superformData.superformId.getSuperform();\r\n\r\n        (uint256 amountIn, uint8 bridgeId) =\r\n            _singleVaultTokenForward(msg.sender, address(0), req_.superformData.permit2data, ambData, true);\r\n\r\n        LiqRequest memory emptyRequest;\r\n\r\n        /// @dev dispatch liquidity data\r\n        if (\r\n            _validateAndDispatchTokens(\r\n                ValidateAndDispatchTokensArgs(\r\n                    req_.superformData.liqRequest, superform, vars.srcChainId, req_.dstChainId, msg.sender, true\r\n                )\r\n            )\r\n        ) emptyRequest.interimToken = req_.superformData.liqRequest.interimToken;\r\n\r\n        /// @dev overrides user set liqData to just contain interimToken in case there is a dstSwap\r\n        /// @dev this information is needed in case the dstSwap fails so that we can validate the interimToken in\r\n        /// DstSwapper.sol on destination\r\n        ambData.liqData = emptyRequest;\r\n\r\n        uint256[] memory superformIds = new uint256[](1);\r\n        superformIds[0] = req_.superformData.superformId;\r\n\r\n        /// @dev dispatch message information, notice multiVaults is set to 0\r\n        _dispatchAmbMessage(\r\n            DispatchAMBMessageVars(\r\n                TransactionType.DEPOSIT,\r\n                abi.encode(ambData),\r\n                superformIds,\r\n                msg.sender,\r\n                req_.ambIds,\r\n                0,\r\n                vars.srcChainId,\r\n                req_.dstChainId,\r\n                vars.currentPayloadId\r\n            ),\r\n            req_.superformData.receiverAddressSP\r\n        );\r\n\r\n        emit CrossChainInitiatedDepositSingle(\r\n            vars.currentPayloadId, req_.dstChainId, req_.superformData.superformId, amountIn, bridgeId, req_.ambIds\r\n        );\r\n    }\r\n\r\n    /// @dev handles same-chain multi vault deposit\r\n    function _singleDirectMultiVaultDeposit(SingleDirectMultiVaultStateReq memory req_) internal virtual {\r\n        /// @dev validate superformData\r\n        if (!_validateSuperformsData(req_.superformData, CHAIN_ID, true)) {\r\n            revert Error.INVALID_SUPERFORMS_DATA();\r\n        }\r\n\r\n        InitMultiVaultData memory vaultData = InitMultiVaultData(\r\n            0,\r\n            req_.superformData.superformIds,\r\n            req_.superformData.amounts,\r\n            req_.superformData.outputAmounts,\r\n            req_.superformData.maxSlippages,\r\n            req_.superformData.liqRequests,\r\n            new bool[](req_.superformData.amounts.length),\r\n            req_.superformData.retain4626s,\r\n            req_.superformData.receiverAddress,\r\n            req_.superformData.extraFormData\r\n        );\r\n\r\n        /// @dev same chain action & forward residual payment to Paymaster\r\n        _directMultiDeposit(\r\n            MultiDepositArgs(\r\n                msg.sender, req_.superformData.permit2data, req_.superformData.receiverAddressSP, vaultData\r\n            )\r\n        );\r\n        emit Completed();\r\n    }\r\n\r\n    /// @dev handles cross-chain multi vault deposit\r\n    function _singleXChainMultiVaultDeposit(SingleXChainMultiVaultStateReq memory req_) internal virtual {\r\n        /// @dev validate the action\r\n        ActionLocalVars memory vars;\r\n        vars.srcChainId = CHAIN_ID;\r\n        if (vars.srcChainId == req_.dstChainId) revert Error.INVALID_ACTION();\r\n\r\n        /// @dev validate superformsData\r\n        if (!_validateSuperformsData(req_.superformsData, req_.dstChainId, true)) {\r\n            revert Error.INVALID_SUPERFORMS_DATA();\r\n        }\r\n\r\n        vars.currentPayloadId = ++payloadIds;\r\n\r\n        InitMultiVaultData memory ambData = InitMultiVaultData(\r\n            vars.currentPayloadId,\r\n            req_.superformsData.superformIds,\r\n            req_.superformsData.amounts,\r\n            req_.superformsData.outputAmounts,\r\n            req_.superformsData.maxSlippages,\r\n            req_.superformsData.liqRequests,\r\n            req_.superformsData.hasDstSwaps,\r\n            req_.superformsData.retain4626s,\r\n            req_.superformsData.receiverAddress,\r\n            req_.superformsData.extraFormData\r\n        );\r\n\r\n        address superform;\r\n        uint256 len = req_.superformsData.superformIds.length;\r\n\r\n        (uint256[] memory amountsIn, uint8[] memory bridgeIds) =\r\n            _multiVaultTokenForward(msg.sender, new address[](0), req_.superformsData.permit2data, ambData, true);\r\n\r\n        /// @dev empties the liqData after multiVaultTokenForward\r\n        ambData.liqData = new LiqRequest[](len);\r\n\r\n        /// @dev this loop is what allows to deposit to >1 different underlying on destination\r\n        /// @dev if a loop fails in a validation the whole chain should be reverted\r\n        for (uint256 i; i < len; ++i) {\r\n            vars.liqRequest = req_.superformsData.liqRequests[i];\r\n\r\n            (superform,,) = req_.superformsData.superformIds[i].getSuperform();\r\n\r\n            /// @dev dispatch liquidity data\r\n            if (\r\n                _validateAndDispatchTokens(\r\n                    ValidateAndDispatchTokensArgs(\r\n                        vars.liqRequest, superform, vars.srcChainId, req_.dstChainId, msg.sender, true\r\n                    )\r\n                )\r\n            ) ambData.liqData[i].interimToken = vars.liqRequest.interimToken;\r\n        }\r\n\r\n        /// @dev dispatch message information, notice multiVaults is set to 1\r\n        _dispatchAmbMessage(\r\n            DispatchAMBMessageVars(\r\n                TransactionType.DEPOSIT,\r\n                abi.encode(ambData),\r\n                req_.superformsData.superformIds,\r\n                msg.sender,\r\n                req_.ambIds,\r\n                1,\r\n                vars.srcChainId,\r\n                req_.dstChainId,\r\n                vars.currentPayloadId\r\n            ),\r\n            req_.superformsData.receiverAddressSP\r\n        );\r\n\r\n        emit CrossChainInitiatedDepositMulti(\r\n            vars.currentPayloadId, req_.dstChainId, req_.superformsData.superformIds, amountsIn, bridgeIds, req_.ambIds\r\n        );\r\n    }\r\n\r\n    /// @dev handles same-chain single vault withdraw\r\n    function _singleDirectSingleVaultWithdraw(SingleDirectSingleVaultStateReq memory req_) internal virtual {\r\n        /// @dev validate Superform data\r\n        if (\r\n            !_validateSuperformData(\r\n                req_.superformData.superformId,\r\n                req_.superformData.amount,\r\n                req_.superformData.outputAmount,\r\n                req_.superformData.maxSlippage,\r\n                req_.superformData.receiverAddress,\r\n                req_.superformData.receiverAddressSP,\r\n                CHAIN_ID,\r\n                false,\r\n                ISuperformFactory(_getAddress(keccak256(\"SUPERFORM_FACTORY\"))),\r\n                false\r\n            )\r\n        ) {\r\n            revert Error.INVALID_SUPERFORMS_DATA();\r\n        }\r\n\r\n        ISuperPositions(_getAddress(keccak256(\"SUPER_POSITIONS\"))).burnSingle(\r\n            msg.sender, req_.superformData.superformId, req_.superformData.amount\r\n        );\r\n\r\n        InitSingleVaultData memory vaultData = InitSingleVaultData(\r\n            0,\r\n            req_.superformData.superformId,\r\n            req_.superformData.amount,\r\n            req_.superformData.outputAmount,\r\n            req_.superformData.maxSlippage,\r\n            req_.superformData.liqRequest,\r\n            false,\r\n            req_.superformData.retain4626,\r\n            req_.superformData.receiverAddress,\r\n            req_.superformData.extraFormData\r\n        );\r\n\r\n        /// @dev same chain action\r\n        _directSingleWithdraw(vaultData, msg.sender);\r\n        emit Completed();\r\n    }\r\n\r\n    /// @dev handles cross-chain single vault withdraw\r\n    function _singleXChainSingleVaultWithdraw(SingleXChainSingleVaultStateReq memory req_) internal virtual {\r\n        /// @dev validate the action\r\n        ActionLocalVars memory vars;\r\n        vars.srcChainId = CHAIN_ID;\r\n\r\n        if (vars.srcChainId == req_.dstChainId) {\r\n            revert Error.INVALID_ACTION();\r\n        }\r\n\r\n        /// @dev validate the Superforms data\r\n        if (\r\n            !_validateSuperformData(\r\n                req_.superformData.superformId,\r\n                req_.superformData.amount,\r\n                req_.superformData.outputAmount,\r\n                req_.superformData.maxSlippage,\r\n                req_.superformData.receiverAddress,\r\n                req_.superformData.receiverAddressSP,\r\n                req_.dstChainId,\r\n                false,\r\n                ISuperformFactory(_getAddress(keccak256(\"SUPERFORM_FACTORY\"))),\r\n                false\r\n            )\r\n        ) {\r\n            revert Error.INVALID_SUPERFORMS_DATA();\r\n        }\r\n\r\n        ISuperPositions(_getAddress(keccak256(\"SUPER_POSITIONS\"))).burnSingle(\r\n            msg.sender, req_.superformData.superformId, req_.superformData.amount\r\n        );\r\n\r\n        vars.currentPayloadId = ++payloadIds;\r\n\r\n        InitSingleVaultData memory ambData = InitSingleVaultData(\r\n            vars.currentPayloadId,\r\n            req_.superformData.superformId,\r\n            req_.superformData.amount,\r\n            req_.superformData.outputAmount,\r\n            req_.superformData.maxSlippage,\r\n            req_.superformData.liqRequest,\r\n            false,\r\n            req_.superformData.retain4626,\r\n            req_.superformData.receiverAddress,\r\n            req_.superformData.extraFormData\r\n        );\r\n\r\n        uint256[] memory superformIds = new uint256[](1);\r\n        superformIds[0] = req_.superformData.superformId;\r\n\r\n        /// @dev dispatch message information, notice multiVaults is set to 0\r\n        _dispatchAmbMessage(\r\n            DispatchAMBMessageVars(\r\n                TransactionType.WITHDRAW,\r\n                abi.encode(ambData),\r\n                superformIds,\r\n                msg.sender,\r\n                req_.ambIds,\r\n                0,\r\n                vars.srcChainId,\r\n                req_.dstChainId,\r\n                vars.currentPayloadId\r\n            ),\r\n            req_.superformData.receiverAddressSP\r\n        );\r\n\r\n        emit CrossChainInitiatedWithdrawSingle(\r\n            vars.currentPayloadId, req_.dstChainId, req_.superformData.superformId, req_.ambIds\r\n        );\r\n    }\r\n\r\n    /// @dev handles same-chain multi vault withdraw\r\n    function _singleDirectMultiVaultWithdraw(SingleDirectMultiVaultStateReq memory req_) internal virtual {\r\n        ActionLocalVars memory vars;\r\n        vars.srcChainId = CHAIN_ID;\r\n\r\n        /// @dev validates the Superform data\r\n        if (!_validateSuperformsData(req_.superformData, vars.srcChainId, false)) {\r\n            revert Error.INVALID_SUPERFORMS_DATA();\r\n        }\r\n\r\n        /// @dev SuperPositions are burnt optimistically here\r\n        ISuperPositions(_getAddress(keccak256(\"SUPER_POSITIONS\"))).burnBatch(\r\n            msg.sender, req_.superformData.superformIds, req_.superformData.amounts\r\n        );\r\n\r\n        InitMultiVaultData memory vaultData = InitMultiVaultData(\r\n            0,\r\n            req_.superformData.superformIds,\r\n            req_.superformData.amounts,\r\n            req_.superformData.outputAmounts,\r\n            req_.superformData.maxSlippages,\r\n            req_.superformData.liqRequests,\r\n            new bool[](req_.superformData.superformIds.length),\r\n            req_.superformData.retain4626s,\r\n            req_.superformData.receiverAddress,\r\n            req_.superformData.extraFormData\r\n        );\r\n\r\n        /// @dev same chain action & forward residual payment to Paymaster\r\n        _directMultiWithdraw(vaultData, msg.sender);\r\n        emit Completed();\r\n    }\r\n\r\n    /// @dev handles cross-chain multi vault withdraw\r\n    function _singleXChainMultiVaultWithdraw(SingleXChainMultiVaultStateReq memory req_) internal virtual {\r\n        /// @dev validate the action\r\n        ActionLocalVars memory vars;\r\n        vars.srcChainId = CHAIN_ID;\r\n        if (vars.srcChainId == req_.dstChainId) {\r\n            revert Error.INVALID_ACTION();\r\n        }\r\n\r\n        /// @dev validate superformsData\r\n        if (!_validateSuperformsData(req_.superformsData, req_.dstChainId, false)) {\r\n            revert Error.INVALID_SUPERFORMS_DATA();\r\n        }\r\n\r\n        ISuperPositions(_getAddress(keccak256(\"SUPER_POSITIONS\"))).burnBatch(\r\n            msg.sender, req_.superformsData.superformIds, req_.superformsData.amounts\r\n        );\r\n\r\n        vars.currentPayloadId = ++payloadIds;\r\n\r\n        InitMultiVaultData memory ambData = InitMultiVaultData(\r\n            vars.currentPayloadId,\r\n            req_.superformsData.superformIds,\r\n            req_.superformsData.amounts,\r\n            req_.superformsData.outputAmounts,\r\n            req_.superformsData.maxSlippages,\r\n            req_.superformsData.liqRequests,\r\n            new bool[](req_.superformsData.amounts.length),\r\n            req_.superformsData.retain4626s,\r\n            req_.superformsData.receiverAddress,\r\n            req_.superformsData.extraFormData\r\n        );\r\n\r\n        /// @dev dispatch message information, notice multiVaults is set to 1\r\n        _dispatchAmbMessage(\r\n            DispatchAMBMessageVars(\r\n                TransactionType.WITHDRAW,\r\n                abi.encode(ambData),\r\n                req_.superformsData.superformIds,\r\n                msg.sender,\r\n                req_.ambIds,\r\n                1,\r\n                vars.srcChainId,\r\n                req_.dstChainId,\r\n                vars.currentPayloadId\r\n            ),\r\n            req_.superformsData.receiverAddressSP\r\n        );\r\n\r\n        emit CrossChainInitiatedWithdrawMulti(\r\n            vars.currentPayloadId, req_.dstChainId, req_.superformsData.superformIds, req_.ambIds\r\n        );\r\n    }\r\n\r\n    function _validateAndDispatchTokens(ValidateAndDispatchTokensArgs memory args_)\r\n        internal\r\n        virtual\r\n        returns (bool hasDstSwap)\r\n    {\r\n        address bridgeValidator = superRegistry.getBridgeValidator(args_.liqRequest.bridgeId);\r\n        /// @dev validates remaining params of txData\r\n        hasDstSwap = IBridgeValidator(bridgeValidator).validateTxData(\r\n            IBridgeValidator.ValidateTxDataArgs(\r\n                args_.liqRequest.txData,\r\n                args_.srcChainId,\r\n                args_.dstChainId,\r\n                args_.liqRequest.liqDstChainId,\r\n                args_.deposit,\r\n                args_.superform,\r\n                args_.srcSender,\r\n                args_.liqRequest.token,\r\n                args_.liqRequest.interimToken\r\n            )\r\n        );\r\n\r\n        /// @dev dispatches tokens through the selected liquidity bridge to the destination contract\r\n        _dispatchTokens(\r\n            superRegistry.getBridgeAddress(args_.liqRequest.bridgeId),\r\n            args_.liqRequest.txData,\r\n            args_.liqRequest.token,\r\n            IBridgeValidator(bridgeValidator).decodeAmountIn(args_.liqRequest.txData, true),\r\n            args_.liqRequest.nativeAmount\r\n        );\r\n    }\r\n\r\n    function _dispatchAmbMessage(DispatchAMBMessageVars memory vars_, address receiverAddressSP_) internal virtual {\r\n        uint256 txInfo = DataLib.packTxInfo(\r\n            uint8(vars_.txType),\r\n            uint8(CallbackType.INIT),\r\n            vars_.multiVaults,\r\n            STATE_REGISTRY_TYPE,\r\n            vars_.srcSender,\r\n            vars_.srcChainId\r\n        );\r\n\r\n        bytes memory ambMessage = abi.encode(AMBMessage(txInfo, vars_.ambData));\r\n\r\n        (uint256 fees, bytes memory extraData) = IPaymentHelper(_getAddress(keccak256(\"PAYMENT_HELPER\")))\r\n            .calculateAMBData(vars_.dstChainId, vars_.ambIds, ambMessage);\r\n\r\n        ISuperPositions(_getAddress(keccak256(\"SUPER_POSITIONS\"))).updateTxHistory(\r\n            vars_.currentPayloadId, txInfo, receiverAddressSP_\r\n        );\r\n\r\n        /// @dev this call dispatches the message to the AMB bridge through dispatchPayload\r\n        IBaseStateRegistry(_getAddress(keccak256(\"CORE_STATE_REGISTRY\"))).dispatchPayload{ value: fees }(\r\n            vars_.srcSender, vars_.ambIds, vars_.dstChainId, ambMessage, extraData\r\n        );\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                INTERNAL DEPOSIT HELPERS                  //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @notice fulfils the final stage of same chain deposit action\r\n    function _directDeposit(DirectDepositArgs memory args) internal virtual returns (uint256 shares) {\r\n        // @dev deposits token to a given vault and mint vault positions directly through the form\r\n        shares = IBaseForm(args.superform).directDepositIntoVault{ value: args.msgValue }(\r\n            InitSingleVaultData(\r\n                args.payloadId,\r\n                args.superformId,\r\n                args.amount,\r\n                args.outputAmount,\r\n                args.maxSlippage,\r\n                args.liqData,\r\n                false,\r\n                args.retain4626,\r\n                args.receiverAddress,\r\n                args.extraFormData\r\n            ),\r\n            args.srcSender\r\n        );\r\n    }\r\n\r\n    /// @notice deposits to single vault on the same chain\r\n    /// @dev calls `_directDeposit`\r\n    function _directSingleDeposit(SingleDepositArgs memory args_) internal virtual {\r\n        SingleDepositLocalVars memory v;\r\n\r\n        // @dev decode superforms\r\n        (v.superform,,) = args_.vaultData.superformId.getSuperform();\r\n\r\n        _singleVaultTokenForward(args_.srcSender, v.superform, args_.permit2data, args_.vaultData, false);\r\n\r\n        // @dev deposits token to a given vault and mint vault positions.\r\n        v.shares = _directDeposit(\r\n            DirectDepositArgs(\r\n                v.superform,\r\n                args_.vaultData.payloadId,\r\n                args_.vaultData.superformId,\r\n                args_.vaultData.amount,\r\n                args_.vaultData.outputAmount,\r\n                args_.vaultData.maxSlippage,\r\n                args_.vaultData.retain4626,\r\n                args_.vaultData.liqData,\r\n                args_.vaultData.receiverAddress,\r\n                args_.vaultData.extraFormData,\r\n                args_.vaultData.liqData.nativeAmount,\r\n                args_.srcSender\r\n            )\r\n        );\r\n\r\n        if (v.shares != 0 && !args_.vaultData.retain4626) {\r\n            // @dev mint super positions at the end of the deposit action if user doesn't retain 4626\r\n            ISuperPositions(_getAddress(keccak256(\"SUPER_POSITIONS\"))).mintSingle(\r\n                args_.receiverAddressSP, args_.vaultData.superformId, v.shares\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice deposits to multiple vaults on the same chain\r\n    /// @dev loops and call `_directDeposit`\r\n    function _directMultiDeposit(MultiDepositArgs memory args_) internal virtual {\r\n        MultiDepositLocalVars memory v;\r\n        v.len = args_.vaultData.superformIds.length;\r\n\r\n        v.superforms = new address[](v.len);\r\n        v.shares = new uint256[](v.len);\r\n\r\n        /// @dev decode superforms\r\n        v.superforms = DataLib.getSuperforms(args_.vaultData.superformIds);\r\n\r\n        _multiVaultTokenForward(args_.srcSender, v.superforms, args_.permit2data, args_.vaultData, false);\r\n\r\n        for (uint256 i; i < v.len; ++i) {\r\n            /// @dev deposits token to a given vault and mint vault positions.\r\n            v.shares[i] = _directDeposit(\r\n                DirectDepositArgs(\r\n                    v.superforms[i],\r\n                    args_.vaultData.payloadId,\r\n                    args_.vaultData.superformIds[i],\r\n                    args_.vaultData.amounts[i],\r\n                    args_.vaultData.outputAmounts[i],\r\n                    args_.vaultData.maxSlippages[i],\r\n                    args_.vaultData.retain4626s[i],\r\n                    args_.vaultData.liqData[i],\r\n                    args_.vaultData.receiverAddress,\r\n                    args_.vaultData.extraFormData,\r\n                    args_.vaultData.liqData[i].nativeAmount,\r\n                    args_.srcSender\r\n                )\r\n            );\r\n\r\n            /// @dev if retain4626 is set to True, set the amount of SuperPositions to mint to 0\r\n            if (v.shares[i] != 0 && args_.vaultData.retain4626s[i]) {\r\n                v.shares[i] = 0;\r\n            }\r\n        }\r\n\r\n        /// @dev in direct deposits, SuperPositions are minted right after depositing to vaults\r\n        ISuperPositions(_getAddress(keccak256(\"SUPER_POSITIONS\"))).mintBatch(\r\n            args_.receiverAddressSP, args_.vaultData.superformIds, v.shares\r\n        );\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                INTERNAL WITHDRAW HELPERS                 //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @notice fulfils the final stage of same chain withdrawal action\r\n    function _directWithdraw(\r\n        address superform_,\r\n        uint256 payloadId_,\r\n        uint256 superformId_,\r\n        uint256 amount_,\r\n        uint256 outputAmount_,\r\n        uint256 maxSlippage_,\r\n        LiqRequest memory liqData_,\r\n        bool retain4626_,\r\n        address receiverAddress_,\r\n        bytes memory extraFormData_,\r\n        address srcSender_\r\n    )\r\n        internal\r\n        virtual\r\n    {\r\n        /// @dev in direct withdraws, form is called directly\r\n        IBaseForm(superform_).directWithdrawFromVault(\r\n            InitSingleVaultData(\r\n                payloadId_,\r\n                superformId_,\r\n                amount_,\r\n                outputAmount_,\r\n                maxSlippage_,\r\n                liqData_,\r\n                false,\r\n                retain4626_,\r\n                receiverAddress_,\r\n                extraFormData_\r\n            ),\r\n            srcSender_\r\n        );\r\n    }\r\n\r\n    /// @notice withdraws from single vault on the same chain\r\n    /// @dev call `_directWithdraw`\r\n    function _directSingleWithdraw(InitSingleVaultData memory vaultData_, address srcSender_) internal virtual {\r\n        /// @dev decode superforms\r\n        (address superform,,) = vaultData_.superformId.getSuperform();\r\n\r\n        _directWithdraw(\r\n            superform,\r\n            vaultData_.payloadId,\r\n            vaultData_.superformId,\r\n            vaultData_.amount,\r\n            vaultData_.outputAmount,\r\n            vaultData_.maxSlippage,\r\n            vaultData_.liqData,\r\n            vaultData_.retain4626,\r\n            vaultData_.receiverAddress,\r\n            vaultData_.extraFormData,\r\n            srcSender_\r\n        );\r\n    }\r\n\r\n    /// @notice withdraws from multiple vaults on the same chain\r\n    /// @dev loops and call `_directWithdraw`\r\n    function _directMultiWithdraw(InitMultiVaultData memory vaultData_, address srcSender_) internal virtual {\r\n        /// @dev decode superforms\r\n        address[] memory superforms = DataLib.getSuperforms(vaultData_.superformIds);\r\n        uint256 len = superforms.length;\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            /// @dev deposits token to a given vault and mint vault positions.\r\n            _directWithdraw(\r\n                superforms[i],\r\n                vaultData_.payloadId,\r\n                vaultData_.superformIds[i],\r\n                vaultData_.amounts[i],\r\n                vaultData_.outputAmounts[i],\r\n                vaultData_.maxSlippages[i],\r\n                vaultData_.liqData[i],\r\n                vaultData_.retain4626s[i],\r\n                vaultData_.receiverAddress,\r\n                vaultData_.extraFormData,\r\n                srcSender_\r\n            );\r\n        }\r\n    }\r\n\r\n    function _forwardDustToPaymaster(address token_) internal {\r\n        if (token_ == address(0)) revert Error.ZERO_ADDRESS();\r\n\r\n        address paymaster = _getAddress(keccak256(\"PAYMASTER\"));\r\n        IERC20 token = IERC20(token_);\r\n\r\n        uint256 dust = token.balanceOf(address(this));\r\n        if (dust != 0) {\r\n            token.safeTransfer(paymaster, dust);\r\n            emit RouterDustForwardedToPaymaster(token_, dust);\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //               INTERNAL VALIDATION HELPERS                //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    function _validateSuperformData(\r\n        uint256 superformId_,\r\n        uint256 amount_,\r\n        uint256 outputAmount_,\r\n        uint256 maxSlippage_,\r\n        address receiverAddress_,\r\n        address receiverAddressSP_,\r\n        uint64 dstChainId_,\r\n        bool isDeposit_,\r\n        ISuperformFactory factory_,\r\n        bool multi_\r\n    )\r\n        internal\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        /// @dev if same chain, validate if the superform exists on factory\r\n        if (dstChainId_ == CHAIN_ID && !factory_.isSuperform(superformId_)) {\r\n            return false;\r\n        }\r\n\r\n        /// @dev the dstChainId_ (in the state request) must match the superforms' chainId (superform must exist on\r\n        /// destination)\r\n        (, uint32 formImplementationId, uint64 sfDstChainId) = superformId_.getSuperform();\r\n\r\n        if (dstChainId_ != sfDstChainId) return false;\r\n\r\n        /// @dev 10000 = 100% slippage\r\n        if (maxSlippage_ > ENTIRE_SLIPPAGE) return false;\r\n\r\n        /// @dev amounts can't be 0\r\n        if (amount_ == 0 || outputAmount_ == 0) return false;\r\n\r\n        /// @dev only validate this for non multi case (multi case is validated in _validateSuperformsData)\r\n        /// @dev ensure that receiver address is set always\r\n        /// @dev in deposits, this is important for receive4626 (on destination). It is also important for refunds on\r\n        /// destination\r\n        /// @dev in withdraws, this is important for the user to receive their tokens in the liqDstChainId\r\n        if (!multi_ && receiverAddress_ == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        /// @dev redundant check on same chain, but helpful on xchain actions to halt deposits earlier\r\n        if (isDeposit_) {\r\n            if (factory_.isFormImplementationPaused(formImplementationId)) {\r\n                return false;\r\n            }\r\n\r\n            /// @dev only validate this for non multi case (multi case is validated in _validateSuperformsData)\r\n            if (!multi_) {\r\n                if (receiverAddressSP_ == address(0)) {\r\n                    return false;\r\n                } else {\r\n                    /// @dev if receiverAddressSP_ is set and is a contract, it must implement onERC1155Received\r\n                    _doSafeTransferAcceptanceCheck(receiverAddressSP_);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _validateSuperformsData(\r\n        MultiVaultSFData memory superformsData_,\r\n        uint64 dstChainId_,\r\n        bool deposit_\r\n    )\r\n        internal\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        uint256 len = superformsData_.amounts.length;\r\n        uint256 lenSuperforms = superformsData_.superformIds.length;\r\n        uint256 liqRequestsLen = superformsData_.liqRequests.length;\r\n\r\n        /// @dev empty requests are not allowed, as well as requests with length mismatch\r\n        if (len == 0 || liqRequestsLen == 0) return false;\r\n        if (len != liqRequestsLen) return false;\r\n\r\n        /// @dev all other length checks\r\n        if (\r\n            lenSuperforms != len || lenSuperforms != superformsData_.outputAmounts.length\r\n                || lenSuperforms != superformsData_.maxSlippages.length\r\n                || lenSuperforms != superformsData_.hasDstSwaps.length\r\n                || lenSuperforms != superformsData_.retain4626s.length\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        /// @dev deposits beyond multi vault limit for a given destination chain blocked\r\n        if (lenSuperforms > superRegistry.getVaultLimitPerDestination(dstChainId_)) {\r\n            return false;\r\n        }\r\n\r\n        /// @dev since this is a multi case, validate receiverAddress here once\r\n        if (superformsData_.receiverAddress == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        /// @dev since this is a multi case, validate receiverAddressSP here once\r\n        if (deposit_) {\r\n            if (superformsData_.receiverAddressSP == address(0)) {\r\n                return false;\r\n            } else {\r\n                /// @dev if receiverAddressSP_ is set and is a contract, it must implement onERC1155Received\r\n                _doSafeTransferAcceptanceCheck(superformsData_.receiverAddressSP);\r\n            }\r\n        }\r\n\r\n        ISuperformFactory factory = ISuperformFactory(_getAddress(keccak256(\"SUPERFORM_FACTORY\")));\r\n\r\n        /// @dev slippage, amount, paused status validation\r\n        for (uint256 i; i < len; ++i) {\r\n            if (\r\n                !_validateSuperformData(\r\n                    superformsData_.superformIds[i],\r\n                    superformsData_.amounts[i],\r\n                    superformsData_.outputAmounts[i],\r\n                    superformsData_.maxSlippages[i],\r\n                    superformsData_.receiverAddress,\r\n                    superformsData_.receiverAddressSP,\r\n                    dstChainId_,\r\n                    deposit_,\r\n                    factory,\r\n                    true\r\n                )\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            /// @dev ensure interimTokens aren't repeated on destination chains\r\n            address interimToken = superformsData_.liqRequests[i].interimToken;\r\n            if (interimToken != address(0)) {\r\n                for (uint256 j; j < i; ++j) {\r\n                    if (j != i) {\r\n                        if (interimToken == superformsData_.liqRequests[j].interimToken) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //             INTERNAL FEE FORWARDING HELPERS              //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev forwards the residual payment to Paymaster\r\n    function _forwardPayment(uint256 _balanceBefore) internal virtual {\r\n        if (address(this).balance < _balanceBefore) revert Error.INSUFFICIENT_BALANCE();\r\n\r\n        /// @dev deducts what's already available sends what's left in msg.value to Paymaster\r\n        uint256 residualPayment = address(this).balance - _balanceBefore;\r\n\r\n        if (residualPayment != 0) {\r\n            IPayMaster(_getAddress(keccak256(\"PAYMASTER\"))).makePayment{ value: residualPayment }(msg.sender);\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //       INTERNAL SAME CHAIN TOKEN SETTLEMENT HELPERS       //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    function _singleVaultTokenForward(\r\n        address srcSender_,\r\n        address target_,\r\n        bytes memory permit2data_,\r\n        InitSingleVaultData memory vaultData_,\r\n        bool xChain\r\n    )\r\n        internal\r\n        virtual\r\n        returns (uint256, uint8)\r\n    {\r\n        SingleTokenForwardLocalVars memory v;\r\n\r\n        v.bridgeId = vaultData_.liqData.bridgeId;\r\n\r\n        v.txDataLength = vaultData_.liqData.txData.length;\r\n\r\n        if (v.txDataLength == 0 && xChain) {\r\n            revert Error.NO_TXDATA_PRESENT();\r\n        }\r\n\r\n        if (v.txDataLength != 0) {\r\n            v.amountIn = IBridgeValidator(superRegistry.getBridgeValidator(v.bridgeId)).decodeAmountIn(\r\n                vaultData_.liqData.txData, false\r\n            );\r\n        } else {\r\n            v.amountIn = vaultData_.amount;\r\n        }\r\n\r\n        if (vaultData_.liqData.token != NATIVE) {\r\n            v.token = IERC20(vaultData_.liqData.token);\r\n\r\n            if (permit2data_.length != 0) {\r\n                v.permit2 = _getPermit2();\r\n\r\n                (uint256 nonce, uint256 deadline, bytes memory signature) =\r\n                    abi.decode(permit2data_, (uint256, uint256, bytes));\r\n\r\n                /// @dev moves the tokens from the user to the router\r\n                IPermit2(v.permit2).permitTransferFrom(\r\n                    // The permit message.\r\n                    IPermit2.PermitTransferFrom({\r\n                        permitted: IPermit2.TokenPermissions({ token: v.token, amount: v.amountIn }),\r\n                        nonce: nonce,\r\n                        deadline: deadline\r\n                    }),\r\n                    // The transfer recipient and amount.\r\n                    IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: v.amountIn }),\r\n                    // The owner of the tokens, which must also be\r\n                    // the signer of the message, otherwise this call\r\n                    // will fail.\r\n                    srcSender_,\r\n                    // The packed signature that was the result of signing\r\n                    // the EIP712 hash of `permit`.\r\n                    signature\r\n                );\r\n            } else {\r\n                if (v.token.allowance(srcSender_, address(this)) < v.amountIn) {\r\n                    revert Error.INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\r\n                }\r\n\r\n                /// @dev moves the tokens from the user to the router\r\n                v.token.safeTransferFrom(srcSender_, address(this), v.amountIn);\r\n            }\r\n\r\n            if (target_ != address(0)) {\r\n                /// @dev approves the input amount to the target\r\n                v.token.safeIncreaseAllowance(target_, v.amountIn);\r\n            }\r\n        }\r\n\r\n        return (v.amountIn, v.bridgeId);\r\n    }\r\n\r\n    function _multiVaultTokenForward(\r\n        address srcSender_,\r\n        address[] memory targets_,\r\n        bytes memory permit2data_,\r\n        InitMultiVaultData memory vaultData_,\r\n        bool xChain\r\n    )\r\n        internal\r\n        virtual\r\n        returns (uint256[] memory, uint8[] memory)\r\n    {\r\n        MultiTokenForwardLocalVars memory v;\r\n\r\n        address token = vaultData_.liqData[0].token;\r\n        v.len = vaultData_.liqData.length;\r\n\r\n        v.amountsIn = new uint256[](v.len);\r\n        v.bridgeIds = new uint8[](v.len);\r\n\r\n        for (uint256 i; i < v.len; ++i) {\r\n            v.bridgeIds[i] = vaultData_.liqData[i].bridgeId;\r\n            if (vaultData_.liqData[i].txData.length != 0) {\r\n                v.amountsIn[i] = IBridgeValidator(superRegistry.getBridgeValidator(v.bridgeIds[i])).decodeAmountIn(\r\n                    vaultData_.liqData[i].txData, false\r\n                );\r\n            } else {\r\n                v.amountsIn[i] = vaultData_.amounts[i];\r\n            }\r\n        }\r\n\r\n        if (token != NATIVE) {\r\n            v.token = IERC20(token);\r\n\r\n            v.permit2dataLen = permit2data_.length;\r\n\r\n            for (uint256 i; i < v.len; ++i) {\r\n                if (vaultData_.liqData[i].token != address(v.token)) {\r\n                    revert Error.INVALID_DEPOSIT_TOKEN();\r\n                }\r\n\r\n                uint256 txDataLength = vaultData_.liqData[i].txData.length;\r\n                if (txDataLength == 0 && xChain) {\r\n                    revert Error.NO_TXDATA_PRESENT();\r\n                }\r\n\r\n                v.totalAmount += v.amountsIn[i];\r\n            }\r\n\r\n            if (v.totalAmount == 0) {\r\n                revert Error.ZERO_AMOUNT();\r\n            }\r\n\r\n            if (v.permit2dataLen != 0) {\r\n                (uint256 nonce, uint256 deadline, bytes memory signature) =\r\n                    abi.decode(permit2data_, (uint256, uint256, bytes));\r\n\r\n                v.permit2 = _getPermit2();\r\n\r\n                /// @dev moves the tokens from the user to the router\r\n                IPermit2(v.permit2).permitTransferFrom(\r\n                    // The permit message.\r\n                    IPermit2.PermitTransferFrom({\r\n                        permitted: IPermit2.TokenPermissions({ token: v.token, amount: v.totalAmount }),\r\n                        nonce: nonce,\r\n                        deadline: deadline\r\n                    }),\r\n                    // The transfer recipient and amount.\r\n                    IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: v.totalAmount }),\r\n                    // The owner of the tokens, which must also be\r\n                    // the signer of the message, otherwise this call\r\n                    // will fail.\r\n                    srcSender_,\r\n                    // The packed signature that was the result of signing\r\n                    // the EIP712 hash of `permit`.\r\n                    signature\r\n                );\r\n            } else {\r\n                if (v.token.allowance(srcSender_, address(this)) < v.totalAmount) {\r\n                    revert Error.INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\r\n                }\r\n\r\n                /// @dev moves the tokens from the user to the router\r\n                v.token.safeTransferFrom(srcSender_, address(this), v.totalAmount);\r\n            }\r\n\r\n            /// @dev approves individual final targets if needed here\r\n            v.targetLen = targets_.length;\r\n            for (uint256 i; i < v.targetLen; ++i) {\r\n                /// @dev approves the superform\r\n                v.token.safeIncreaseAllowance(targets_[i], v.amountsIn[i]);\r\n            }\r\n        }\r\n\r\n        return (v.amountsIn, v.bridgeIds);\r\n    }\r\n\r\n    /// @dev implementation copied from OpenZeppelin 5.0 and stripped down\r\n    function _doSafeTransferAcceptanceCheck(address to) private view {\r\n        if (to.code.length > 0) {\r\n            try IERC165(to).supportsInterface(type(IERC1155Receiver).interfaceId) returns (bool supported) {\r\n                if (!supported) revert IERC1155Errors.ERC1155InvalidReceiver(to);\r\n            } catch {\r\n                revert IERC1155Errors.ERC1155InvalidReceiver(to);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @title SuperformRouter\r\n/// @dev Routes funds and action information to a remote execution chain\r\n/// @author Zeropoint Labs\r\ncontract SuperformRouter is BaseRouterImplementation {\r\n    //////////////////////////////////////////////////////////////\r\n    //                      CONSTRUCTOR                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @param superRegistry_ the superform registry contract\r\n    constructor(address superRegistry_) BaseRouterImplementation(superRegistry_) { }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleDirectSingleVaultDeposit(SingleDirectSingleVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n\r\n        _singleDirectSingleVaultDeposit(req_);\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleXChainSingleVaultDeposit(SingleXChainSingleVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n\r\n        _singleXChainSingleVaultDeposit(req_);\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleDirectMultiVaultDeposit(SingleDirectMultiVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n\r\n        _singleDirectMultiVaultDeposit(req_);\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleXChainMultiVaultDeposit(SingleXChainMultiVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n\r\n        _singleXChainMultiVaultDeposit(req_);\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function multiDstSingleVaultDeposit(MultiDstSingleVaultStateReq calldata req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n        uint256 len = req_.dstChainIds.length;\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            if (CHAIN_ID == req_.dstChainIds[i]) {\r\n                _singleDirectSingleVaultDeposit(SingleDirectSingleVaultStateReq(req_.superformsData[i]));\r\n            } else {\r\n                _singleXChainSingleVaultDeposit(\r\n                    SingleXChainSingleVaultStateReq(req_.ambIds[i], req_.dstChainIds[i], req_.superformsData[i])\r\n                );\r\n            }\r\n        }\r\n\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function multiDstMultiVaultDeposit(MultiDstMultiVaultStateReq calldata req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n        uint256 len = req_.dstChainIds.length;\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            if (CHAIN_ID == req_.dstChainIds[i]) {\r\n                _singleDirectMultiVaultDeposit(SingleDirectMultiVaultStateReq(req_.superformsData[i]));\r\n            } else {\r\n                _singleXChainMultiVaultDeposit(\r\n                    SingleXChainMultiVaultStateReq(req_.ambIds[i], req_.dstChainIds[i], req_.superformsData[i])\r\n                );\r\n            }\r\n        }\r\n\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleDirectSingleVaultWithdraw(SingleDirectSingleVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n\r\n        _singleDirectSingleVaultWithdraw(req_);\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleXChainSingleVaultWithdraw(SingleXChainSingleVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n\r\n        _singleXChainSingleVaultWithdraw(req_);\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleDirectMultiVaultWithdraw(SingleDirectMultiVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n\r\n        _singleDirectMultiVaultWithdraw(req_);\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function singleXChainMultiVaultWithdraw(SingleXChainMultiVaultStateReq memory req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n\r\n        _singleXChainMultiVaultWithdraw(req_);\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function multiDstSingleVaultWithdraw(MultiDstSingleVaultStateReq calldata req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n        uint256 len = req_.dstChainIds.length;\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            if (CHAIN_ID == req_.dstChainIds[i]) {\r\n                _singleDirectSingleVaultWithdraw(SingleDirectSingleVaultStateReq(req_.superformsData[i]));\r\n            } else {\r\n                _singleXChainSingleVaultWithdraw(\r\n                    SingleXChainSingleVaultStateReq(req_.ambIds[i], req_.dstChainIds[i], req_.superformsData[i])\r\n                );\r\n            }\r\n        }\r\n\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function multiDstMultiVaultWithdraw(MultiDstMultiVaultStateReq calldata req_)\r\n        external\r\n        payable\r\n        override(BaseRouter, IBaseRouter)\r\n    {\r\n        uint256 balanceBefore = address(this).balance - msg.value;\r\n        uint256 len = req_.dstChainIds.length;\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            if (CHAIN_ID == req_.dstChainIds[i]) {\r\n                _singleDirectMultiVaultWithdraw(SingleDirectMultiVaultStateReq(req_.superformsData[i]));\r\n            } else {\r\n                _singleXChainMultiVaultWithdraw(\r\n                    SingleXChainMultiVaultStateReq(req_.ambIds[i], req_.dstChainIds[i], req_.superformsData[i])\r\n                );\r\n            }\r\n        }\r\n\r\n        _forwardPayment(balanceBefore);\r\n    }\r\n\r\n    /// @inheritdoc IBaseRouter\r\n    function forwardDustToPaymaster(address token_) external override(BaseRouter, IBaseRouter) {\r\n        _forwardDustToPaymaster(token_);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BLOCK_CHAIN_ID_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"FAILED_TO_EXECUTE_TXDATA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_NATIVE_AMOUNT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ACTION\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_CHAIN_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_DEPOSIT_TOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_SUPERFORMS_DATA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NO_TXDATA_PRESENT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_AMOUNT\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Completed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"bridgeIds\",\"type\":\"uint8[]\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"}],\"name\":\"CrossChainInitiatedDepositMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"superformIds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"}],\"name\":\"CrossChainInitiatedDepositSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"}],\"name\":\"CrossChainInitiatedWithdrawMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"superformIds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"}],\"name\":\"CrossChainInitiatedWithdrawSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RouterDustForwardedToPaymaster\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"forwardDustToPaymaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[][]\",\"name\":\"ambIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[]\",\"name\":\"dstChainIds\",\"type\":\"uint64[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData[]\",\"name\":\"superformsData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MultiDstMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"multiDstMultiVaultDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[][]\",\"name\":\"ambIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[]\",\"name\":\"dstChainIds\",\"type\":\"uint64[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData[]\",\"name\":\"superformsData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MultiDstMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"multiDstMultiVaultWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[][]\",\"name\":\"ambIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[]\",\"name\":\"dstChainIds\",\"type\":\"uint64[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData[]\",\"name\":\"superformsData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MultiDstSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"multiDstSingleVaultDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[][]\",\"name\":\"ambIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[]\",\"name\":\"dstChainIds\",\"type\":\"uint64[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData[]\",\"name\":\"superformsData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MultiDstSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"multiDstSingleVaultWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payloadIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleDirectMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"singleDirectMultiVaultDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleDirectMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"singleDirectMultiVaultWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleDirectSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"singleDirectSingleVaultDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleDirectSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"singleDirectSingleVaultWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData\",\"name\":\"superformsData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleXChainMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"singleXChainMultiVaultDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData\",\"name\":\"superformsData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleXChainMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"singleXChainMultiVaultWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleXChainSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"singleXChainSingleVaultDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleXChainSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"}],\"name\":\"singleXChainSingleVaultWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superRegistry\",\"outputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SuperformRouter", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b97612a25491e34f5fd11d521c14a042eca039fa", "EVMVersion": "paris", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://13516b7356376fb71ecc5a6c2cc8344ab151d0aff914ebdb474aab9fcb961873"}