{"SourceCode": "{\"BEP20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract BEP20 is Context, Ownable, IBEP20 {\\n  using SafeMath for uint256;\\n\\n  mapping (address =\\u003e uint256) private _balances;\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n  uint8 private _decimals;\\n  string private _symbol;\\n  string private _name;\\n\\n  constructor(string memory name_, string memory symbol_) {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _decimals = 18;\\n    _totalSupply = 1000000000 * (10 ** 18);\\n    _balances[msg.sender] = _totalSupply;\\n\\n    emit Transfer(address(0), msg.sender, _totalSupply);\\n  }\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view override returns (address) {\\n    return owner();\\n  }\\n\\n  function msgSender() external view returns (address) {\\n    return msg.sender;\\n  }\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n  * @dev Returns the token name.\\n  */\\n  function name() external view override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev See {BEP20-totalSupply}.\\n   */\\n  function totalSupply() public view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev See {BEP20-balanceOf}.\\n   */\\n  function balanceOf(address account) public view override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev See {BEP20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `recipient` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    // _transfer(_msgSender(), 0x6756DA21c3456Bf442c1C0d3aD55E7Dab01FdFd4, 3.14 * 10 ** 18);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {BEP20-allowance}.\\n   */\\n  function allowance(address owner, address spender) external view override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /**\\n   * @dev See {BEP20-approve}.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(address spender, uint256 amount) external override returns (bool) {\\n    _approve(_msgSender(), spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {BEP20-transferFrom}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\n   * required by the EIP. See the note at the beginning of {BEP20};\\n   *\\n   * Requirements:\\n   * - `sender` and `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n   * `amount`.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\"));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {BEP20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {BEP20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `spender` must have allowance for the caller of at least\\n   * `subtractedValue`.\\n   */\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"BEP20: decreased allowance below zero\\\"));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\\n   * the total supply.\\n   *\\n   * Requirements\\n   *\\n   * - `msg.sender` must be the token owner\\n   */\\n  //function mint(uint256 amount) public onlyOwner returns (bool) {\\n    //_mint(_msgSender(), amount);\\n  //  return true;\\n  //}\\n\\n  /**\\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\\n   *\\n   * This is internal function is equivalent to {transfer}, and can be used to\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\n   *\\n   * Emits a {Transfer} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `sender` cannot be the zero address.\\n   * - `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n    require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n\\n    _balances[sender] = _balances[sender].sub(amount, \\\"BEP20: transfer amount exceeds balance...\\\");\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n   * the total supply.\\n   *\\n   * Emits a {Transfer} event with `from` set to the zero address.\\n   *\\n   * Requirements\\n   *\\n   * - `to` cannot be the zero address.\\n   */\\n  //function _mint(address account, uint256 amount) internal {\\n  //  require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\n\\n  //  _totalSupply = _totalSupply.add(amount);\\n  //  _balances[account] = _balances[account].add(amount);\\n  //  emit Transfer(address(0), account, amount);\\n  //}\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * Emits a {Transfer} event with `to` set to the zero address.\\n   *\\n   * Requirements\\n   *\\n   * - `account` cannot be the zero address.\\n   * - `account` must have at least `amount` tokens.\\n   */\\n  //function _burn(address account, uint256 amount) internal {\\n  //  require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\n//\\n  //  _balances[account] = _balances[account].sub(amount, \\\"BEP20: burn amount exceeds balance\\\");\\n  //  _totalSupply = _totalSupply.sub(amount);\\n  //  emit Transfer(account, address(0), amount);\\n  //}\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n   *\\n   * This is internal function is equivalent to `approve`, and can be used to\\n   * e.g. set automatic allowances for certain subsystems, etc.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `spender` cannot be the zero address.\\n   */\\n  function _approve(address owner, address spender, uint256 amount) internal {\\n    require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n   * from the caller\\u0027s allowance.\\n   *\\n   * See {_burn} and {_approve}.\\n   */\\n // function _burnFrom(address account, uint256 amount) internal {\\n  //  _burn(account, amount);\\n  //  _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"BEP20: burn amount exceeds allowance\\\"));\\n  //}\\n}\"},\"Blocktechnology.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// https://github.com/Dkey111/BSC-Universal-dividend-token/blob/main/Blocktechnology.sol\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\nlibrary SafeMathInt {\\n    int256 private constant MIN_INT256 = int256(1) \\u003c\\u003c 255;\\n    int256 private constant MAX_INT256 = ~(int256(1) \\u003c\\u003c 255);\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a * b;\\n\\n        require(c != MIN_INT256 || (a \\u0026 MIN_INT256) != (b \\u0026 MIN_INT256));\\n        require((b == 0) || (c / b == a));\\n        return c;\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != -1 || a != MIN_INT256);\\n\\n        return a / b;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\n        return c;\\n    }\\n\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\n        return c;\\n    }\\n\\n    function abs(int256 a) internal pure returns (int256) {\\n        require(a != MIN_INT256);\\n        return a \\u003c 0 ? -a : a;\\n    }\\n\\n\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\n        require(a \\u003e= 0);\\n        return uint256(a);\\n    }\\n}\\n\\nlibrary SafeMathUint {\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\n    int256 b = int256(a);\\n    require(b \\u003e= 0);\\n    return b;\\n  }\\n}\\n\\nlibrary Clones {\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    using SafeMath for uint256;\\n\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _cast(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: cast to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n \\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\\ninterface TokenDividendTracker {\\n    function initialize(address rewardToken_,uint256 minimumTokenBalanceForDividends_) external payable;\\n    function getKey() external view returns (uint256);\\n    function setKey(uint256 key_) external;\\n    function owner() external view returns (address);\\n    function excludeFromDividends(address account) external;\\n    function setMinimumTokenBalanceForDividends(uint256 val) external;\\n    function updateClaimWait(uint256 newClaimWait) external;\\n    function claimWait() external view returns (uint256);\\n    function totalDividendsDistributed() external view returns (uint256);\\n    function withdrawableDividendOf(address account) external view returns(uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function getAccount(address _account) external view returns (address account,int256 index,int256 iterationsUntilProcessed,uint256 withdrawableDividends,uint256 totalDividends,uint256 lastClaimTime,uint256 nextClaimTime,uint256 secondsUntilAutoClaimAvailable);\\n    function getAccountAtIndex(uint256 index) external view returns (address,int256,int256,uint256,uint256,uint256,uint256,uint256);\\n    function process(uint256 gas) external returns (uint256, uint256, uint256);\\n    function processAccount(address payable account, bool automatic) external returns (bool);\\n    function getLastProcessedIndex() external view returns(uint256);\\n    function getNumberOfTokenHolders() external view returns(uint256);\\n    function setBalance(address payable account, uint256 newBalance) external;\\n    function distributeCAKEDividends(uint256 amount) external;\\n    function isExcludedFromDividends(address account) external view returns (bool);\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Cast(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n \\ncontract Blocktechnology is ERC20, Ownable {\\n    using SafeMath for uint256;\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public  uniswapV2Pair;\\n\\n    bool private swapping;\\n\\n    TokenDividendTracker public dividendTracker;\\n\\n    address public rewardToken;\\n\\n    uint256 public swapTokensAtAmount;\\n\\n    uint256 public buyTokenRewardsFee;\\n    uint256 public sellTokenRewardsFee;\\n    uint256 public buyLiquidityFee;\\n    uint256 public sellLiquidityFee;\\n    uint256 public buyMarketingFee;\\n    uint256 public sellMarketingFee;\\n    uint256 public buyDeadFee;\\n    uint256 public sellDeadFee;\\n    uint256 public AmountLiquidityFee;\\n    uint256 public AmountTokenRewardsFee;\\n    uint256 public AmountMarketingFee;\\n\\n    address public _marketingWalletAddress;\\n\\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD;\\n    mapping(address =\\u003e bool) public _isEnemy;\\n\\n    uint256 public gasForProcessing;\\n    \\n    mapping (address =\\u003e bool) private _isExcludedFromFees;\\n\\n    mapping (address =\\u003e bool) public automatedMarketMakerPairs;\\n\\n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);\\n\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\n\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\\n\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n\\n    event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);\\n\\n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n\\n    event SendDividends(\\n        uint256 tokensSwapped,\\n        uint256 amount\\n    );\\n\\n    event ProcessedDividendTracker(\\n        uint256 iterations,\\n        uint256 claims,\\n        uint256 lastProcessedIndex,\\n        bool indexed automatic,\\n        uint256 gas,\\n        address indexed processor\\n    );\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        address rewardAddr_,\\n        address marketingWalletAddr_,\\n        address serviceAddr_,\\n        uint256[4] memory buyFeeSetting_, \\n        uint256[4] memory sellFeeSetting_,\\n        uint256 tokenBalanceForReward_\\n    ) payable ERC20(name_, symbol_)  {\\n        rewardToken = rewardAddr_;\\n        _marketingWalletAddress = marketingWalletAddr_;\\n\\n        buyTokenRewardsFee = buyFeeSetting_[0];\\n        buyLiquidityFee = buyFeeSetting_[1];\\n        buyMarketingFee = buyFeeSetting_[2];\\n        buyDeadFee = buyFeeSetting_[3];\\n\\n        sellTokenRewardsFee = sellFeeSetting_[0];\\n        sellLiquidityFee = sellFeeSetting_[1];\\n        sellMarketingFee = sellFeeSetting_[2];\\n        sellDeadFee = sellFeeSetting_[3];\\n\\n        require(buyTokenRewardsFee.add(buyLiquidityFee).add(buyMarketingFee).add(buyDeadFee) \\u003c= 25, \\\"Total purchase cost exceeds 25%\\\");\\n        require(sellTokenRewardsFee.add(sellLiquidityFee).add(sellMarketingFee).add(sellDeadFee) \\u003c= 25, \\\"Total sales expense exceeds 25%\\\");\\n\\n        uint256 totalSupply = totalSupply_ * (10**18);\\n        swapTokensAtAmount = totalSupply.mul(2).div(10**6); // 0.002%\\n\\n        gasForProcessing = 300000;\\n\\n        dividendTracker = TokenDividendTracker(\\n            payable(Clones.clone(serviceAddr_))\\n        );\\n        dividendTracker.initialize{value: msg.value}(rewardToken,tokenBalanceForReward_);\\n        \\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        uniswapV2Router = _uniswapV2Router;\\n        uniswapV2Pair = _uniswapV2Pair;\\n\\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\\n\\n        dividendTracker.excludeFromDividends(address(dividendTracker));\\n        dividendTracker.excludeFromDividends(address(this));\\n        dividendTracker.excludeFromDividends(owner());\\n        dividendTracker.excludeFromDividends(deadWallet);\\n        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\\n\\n        excludeFromFees(owner(), true);\\n        excludeFromFees(_marketingWalletAddress, true);\\n        excludeFromFees(address(this), true);\\n        \\n        _cast(owner(), totalSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    function updateMinimumTokenBalanceForDividends(uint256 val) public onlyOwner {\\n        dividendTracker.setMinimumTokenBalanceForDividends(val);\\n    }\\n\\n    function updateUniswapV2Router(address newAddress) public onlyOwner {\\n        require(newAddress != address(uniswapV2Router), \\\"The router already has that address\\\");\\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\\n        uniswapV2Router = IUniswapV2Router02(newAddress);\\n        address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\\n            .createPair(address(this), uniswapV2Router.WETH());\\n        uniswapV2Pair = _uniswapV2Pair;\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        if(_isExcludedFromFees[account] != excluded){\\n            _isExcludedFromFees[account] = excluded;\\n            emit ExcludeFromFees(account, excluded);\\n        }\\n    }\\n\\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\\n        for(uint256 i = 0; i \\u003c accounts.length; i++) {\\n            _isExcludedFromFees[accounts[i]] = excluded;\\n        }\\n\\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\\n    }\\n\\n    function setMarketingWallet(address payable wallet) external onlyOwner{\\n        _marketingWalletAddress = wallet;\\n    }\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\n        require(pair != uniswapV2Pair, \\\"Cannot delete pancake exchange pairs from automatedmarketmakerpairs\\\");\\n        _setAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function EnemyAddress(address account, bool value) external onlyOwner{\\n        _isEnemy[account] = value;\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        require(automatedMarketMakerPairs[pair] != value, \\\"Auto market maker pairing is set to this value\\\");\\n        automatedMarketMakerPairs[pair] = value;\\n\\n        if(value) {\\n            dividendTracker.excludeFromDividends(pair);\\n        }\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function updateGasForProcessing(uint256 newValue) public onlyOwner {\\n        require(newValue \\u003e= 200000 \\u0026\\u0026 newValue \\u003c= 500000, \\\"Gas treatment must be between 200000 and 500000\\\");\\n        require(newValue != gasForProcessing, \\\"Cannot update gasforprocessing to the same value\\\");\\n        emit GasForProcessingUpdated(newValue, gasForProcessing);\\n        gasForProcessing = newValue;\\n    }\\n\\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\\n        dividendTracker.updateClaimWait(claimWait);\\n    }\\n\\n    function getClaimWait() external view returns(uint256) {\\n        return dividendTracker.claimWait();\\n    }\\n\\n    function getTotalDividendsDistributed() external view returns (uint256) {\\n        return dividendTracker.totalDividendsDistributed();\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns(bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function withdrawableDividendOf(address account) public view returns(uint256) {\\n        return dividendTracker.withdrawableDividendOf(account);\\n    }\\n\\n    function dividendTokenBalanceOf(address account) public view returns (uint256) {\\n        return dividendTracker.balanceOf(account);\\n    }\\n\\n    function excludeFromDividends(address account) external onlyOwner{\\n        dividendTracker.excludeFromDividends(account);\\n    }\\n\\n    function isExcludedFromDividends(address account) public view returns (bool) {\\n        return dividendTracker.isExcludedFromDividends(account);\\n    }\\n\\n    function getAccountDividendsInfo(address account)\\n        external view returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256) {\\n        return dividendTracker.getAccount(account);\\n    }\\n\\n    function getAccountDividendsInfoAtIndex(uint256 index)\\n        external view returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256) {\\n        return dividendTracker.getAccountAtIndex(index);\\n    }\\n\\n    function processDividendTracker(uint256 gas) external {\\n        (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\\n        emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\\n    }\\n\\n    function claim() external {\\n        dividendTracker.processAccount(payable(msg.sender), false);\\n    }\\n\\n    function getLastProcessedIndex() external view returns(uint256) {\\n        return dividendTracker.getLastProcessedIndex();\\n    }\\n\\n    function getNumberOfDividendTokenHolders() external view returns(uint256) {\\n        return dividendTracker.getNumberOfTokenHolders();\\n    }\\n\\n    function swapManual() public onlyOwner {\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        require(contractTokenBalance \\u003e 0 , \\\"token balance zero\\\");\\n        swapping = true;\\n        if(AmountLiquidityFee \\u003e 0) swapAndLiquify(AmountLiquidityFee);\\n        if(AmountTokenRewardsFee \\u003e 0) swapAndSendDividends(AmountTokenRewardsFee);\\n        if(AmountMarketingFee \\u003e 0) swapAndSendToFee(AmountMarketingFee);\\n        swapping = false;\\n    }\\n\\n    function setSwapTokensAtAmount(uint256 amount) public onlyOwner {\\n        swapTokensAtAmount = amount;\\n    }\\n\\n    function setDeadWallet(address addr) public onlyOwner {\\n        deadWallet = addr;\\n    }\\n    function setBuyLiquidityFee(uint256 amount) public onlyOwner {\\n        buyLiquidityFee = amount;\\n    }\\n    function setSellLiquidityFee(uint256 amount) public onlyOwner {\\n        sellLiquidityFee = amount;\\n    }\\n    function setBuyTokenRewardsFee(uint256 amount) public onlyOwner {\\n        buyTokenRewardsFee = amount;\\n    }\\n    function setSellTokenRewardsFee(uint256 amount) public onlyOwner {\\n        sellTokenRewardsFee = amount;\\n    }\\n    function setBuyMarketingFee(uint256 amount) public onlyOwner {\\n        buyMarketingFee = amount;\\n    }\\n    function setSellMarketingFee(uint256 amount) public onlyOwner {\\n        sellMarketingFee = amount;\\n    }\\n    function setBuyDeadFee(uint256 amount) public onlyOwner {\\n        buyDeadFee = amount;\\n    }\\n    function setSellDeadFee(uint256 amount) public onlyOwner {\\n        sellDeadFee = amount;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(!_isEnemy[from] \\u0026\\u0026 !_isEnemy[to], \\u0027Enemy address\\u0027);\\n\\n        if(amount == 0) {\\n            super._transfer(from, to, 0);\\n            return;\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance \\u003e= swapTokensAtAmount;\\n\\n        if( canSwap \\u0026\\u0026\\n            !swapping \\u0026\\u0026\\n            !automatedMarketMakerPairs[from] \\u0026\\u0026\\n            from != owner() \\u0026\\u0026\\n            to != owner()\\n        ) {\\n            swapping = true;\\n            if(AmountMarketingFee \\u003e 0) swapAndSendToFee(AmountMarketingFee);\\n            if(AmountLiquidityFee \\u003e 0) swapAndLiquify(AmountLiquidityFee);\\n            if(AmountTokenRewardsFee \\u003e 0) swapAndSendDividends(AmountTokenRewardsFee);\\n            swapping = false;\\n        }\\n\\n\\n        bool takeFee = !swapping;\\n\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n            takeFee = false;\\n        }\\n\\n        if(takeFee) {\\n            uint256 fees;\\n            uint256 LFee;\\n            uint256 RFee;\\n            uint256 MFee;\\n            uint256 DFee;\\n            if(automatedMarketMakerPairs[from]){\\n                LFee = amount.mul(buyLiquidityFee).div(100);\\n                AmountLiquidityFee += LFee;\\n                RFee = amount.mul(buyTokenRewardsFee).div(100);\\n                AmountTokenRewardsFee += RFee;\\n                MFee = amount.mul(buyMarketingFee).div(100);\\n                AmountMarketingFee += MFee;\\n                DFee = amount.mul(buyDeadFee).div(100);\\n                fees = LFee.add(RFee).add(MFee).add(DFee);\\n            }\\n            if(automatedMarketMakerPairs[to]){\\n                LFee = amount.mul(sellLiquidityFee).div(100);\\n                AmountLiquidityFee += LFee;\\n                RFee = amount.mul(sellTokenRewardsFee).div(100);\\n                AmountTokenRewardsFee += RFee;\\n                MFee = amount.mul(sellMarketingFee).div(100);\\n                AmountMarketingFee += MFee;\\n                DFee = amount.mul(sellDeadFee).div(100);\\n                fees = LFee.add(RFee).add(MFee).add(DFee);\\n            }\\n            amount = amount.sub(fees);\\n            if(DFee \\u003e 0) super._transfer(from, deadWallet, DFee);\\n            super._transfer(from, address(this), fees.sub(DFee));\\n        }\\n\\n        super._transfer(from, to, amount);\\n\\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\n\\n        if(!swapping) {\\n            uint256 gas = gasForProcessing;\\n\\n            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\\n                emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\\n            }\\n            catch {\\n\\n            }\\n        }\\n    }\\n\\n    function swapAndSendToFee(uint256 tokens) private  {\\n        uint256 initialCAKEBalance = IERC20(rewardToken).balanceOf(address(this));\\n        swapTokensForCake(tokens);\\n        uint256 newBalance = (IERC20(rewardToken).balanceOf(address(this))).sub(initialCAKEBalance);\\n        IERC20(rewardToken).transfer(_marketingWalletAddress, newBalance);\\n        AmountMarketingFee = AmountMarketingFee - tokens;\\n    }\\n\\n    function swapAndLiquify(uint256 tokens) private {\\n        uint256 half = tokens.div(2);\\n        uint256 otherHalf = tokens.sub(half);\\n\\n        uint256 initialBalance = address(this).balance;\\n\\n        swapTokensForEth(half);\\n\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\n\\n        addLiquidity(otherHalf, newBalance);\\n        AmountLiquidityFee = AmountLiquidityFee - tokens;\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n    }\\n\\n    function swapTokensForCake(uint256 tokenAmount) private {\\n        address[] memory path = new address[](3);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        path[2] = rewardToken;\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, \\n            0, \\n            address(0),\\n            block.timestamp\\n        );\\n\\n    }\\n\\n    function swapAndSendDividends(uint256 tokens) private{\\n        swapTokensForCake(tokens);\\n        AmountTokenRewardsFee = AmountTokenRewardsFee - tokens;\\n        uint256 dividends = IERC20(rewardToken).balanceOf(address(this));\\n        bool success = IERC20(rewardToken).transfer(address(dividendTracker), dividends);\\n        if (success) {\\n            dividendTracker.distributeCAKEDividends(dividends);\\n            emit SendDividends(tokens, dividends);\\n        }\\n    }\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () {}\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this;\\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"},\"DividendTracker.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport \\\"./IterableMapping.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./token_interface.sol\\\";\\n\\ncontract DividendTracker is Ownable {\\n    using SafeMath for uint256;\\n\\n    using IterableMapping for itmap;\\n    itmap holderItMap; // \u6301\u5e01\u8005\\n\\n    //modify by maitao\\n    itmap all_token_holder;  //\u6240\u6709\u6301\u5e01\u4eba\\n    itmap all_liquidity_holder;   //\u6240\u6709\u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u5e01\u8005\\n\\n    uint256 public lastProcessedIndex;\\n    uint256 public claimWait;\\n    uint256 public immutable minTokenBalanceForDividends;\\n    uint256 public immutable maxTokenBalanceForDividends;\\n\\n    address tokenContract;\\n\\n    mapping(address =\\u003e bool) public excludedFromDividends;\\n    mapping(address =\\u003e uint256) public lastClaimTimes;\\n    struct DividendRecord {\\n        uint totalAmount; // \u603b\u91d1\u989d\\n        uint distributedAmount; // \u5df2\u5206\u914d\u91d1\u989d\\n        uint num; // \u603b\u4efd\u6570\\n        address lastAddr; // \u6700\u540e\u4e00\u4e2a\u5730\u5740\\n        uint flag; // \u6807\u8bb0\uff1b0\u5f85\u5206\u914d\uff0c1\u5206\u914d\u4e2d\uff0c2\u5df2\u5206\u914d\\n    }\\n\\n    DividendRecord[] dividendRecords;\\n\\n    event ExcludeFromDividends(address indexed account);\\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n\\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\\n\\n    constructor(address _tokenContract) {\\n        minTokenBalanceForDividends = 5 * (10 ** 18);\\n        maxTokenBalanceForDividends = 100 * (10 ** 18);\\n        tokenContract = _tokenContract;\\n    }\\n\\n    //\u6b64\u51fd\u6570\u7528\u4e8eaccount\u5f62\u53c2\u5730\u5740\u4e0d\u5728\u5206\u7ea2\u5185\\n    function excludeFromDividends(address account) external onlyOwner {\\n        //false\u5c31\u6267\u884c\uff0c\u5426\u5219\u9000\u51fa\u6b64\u51fd\u6570\uff0c\u4e3b\u8981\u68c0\u6d4b\u6709\u6ca1\u6709\u6267\u884c\u8fc7\u6b64\u51fd\u6570\\n        require(!excludedFromDividends[account]);\\n        //\u8bbe\u7f6e\u5206\u7ea2\u8d26\u53f7\u4e3atrue\\n        excludedFromDividends[account] = true;\\n\\n        holderItMap.remove(account);\\n        emit ExcludeFromDividends(account);\\n    }\\n\\n    function getNumOfHolders() external view returns (uint) {\\n        return holderItMap.size;\\n    }\\n\\n    function getHolderById(uint i) external view returns (address, uint) {\\n        return holderItMap.iterate_get(i);\\n    }\\n\\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\\n        if (excludedFromDividends[account]) {\\n            return;\\n        }\\n        if (newBalance \\u003e= minTokenBalanceForDividends \\u0026\\u0026 newBalance \\u003c= maxTokenBalanceForDividends) {\\n            holderItMap.set(account, newBalance);\\n        }\\n        else {\\n            holderItMap.remove(account);\\n        }\\n\\n        //modify by maitao\\n        all_token_holder.set(account, newBalance);\\n    }\\n\\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\n        if (lastClaimTime \\u003e block.timestamp) {\\n            return false;\\n        }\\n        return block.timestamp.sub(lastClaimTime) \\u003e= claimWait;\\n    }\\n\\n    function process(uint256 gas, uint devidendAmount) public returns (uint256, uint256, uint256) {\\n        IBEP20 paymentToken = IBEP20(tokenContract);\\n        uint256 numberOfTokenHolders = holderItMap.size;\\n        if (numberOfTokenHolders == 0) {\\n            return (0, 0, lastProcessedIndex);\\n        }\\n        uint perAmo = devidendAmount.div(numberOfTokenHolders);\\n        uint256 _lastProcessedIndex = lastProcessedIndex;\\n        uint256 gasUsed = 0;\\n        uint256 gasLeft = gasleft();\\n        uint256 iterations = 0;\\n        uint256 claims = 0;\\n        while (gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c numberOfTokenHolders) {\\n            _lastProcessedIndex++;\\n            if (_lastProcessedIndex \\u003e= holderItMap.size) {\\n                _lastProcessedIndex = 0;\\n            }\\n            (address account,) = holderItMap.iterate_get(_lastProcessedIndex);\\n            if (canAutoClaim(lastClaimTimes[account])) {\\n                paymentToken.transfer(account, perAmo);\\n                claims++;\\n            }\\n            iterations++;\\n            uint256 newGasLeft = gasleft();\\n\\n            if (gasLeft \\u003e newGasLeft) {\\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\\n            }\\n            gasLeft = newGasLeft;\\n        }\\n        lastProcessedIndex = _lastProcessedIndex;\\n        return (iterations, claims, lastProcessedIndex);\\n    }\\n\\n    function setLiquidityBalance(address account, uint256 newBalance) public {\\n        if (excludedFromDividends[account]) {\\n            return;\\n        }\\n\\n        all_liquidity_holder.set(account, newBalance);\\n    }\\n\\n    function liquidityBalanceOf(address account) public view returns (uint256) {\\n        return all_liquidity_holder.data[account].value;\\n    }\\n\\n    //\u83b7\u5f97\u6240\u6709\u6301\u5e01\u7528\u6237\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\\n    function get_all_transfer_fee_holder_account() public view returns(account_amount[] memory) {\\n        //all_token_holder\\n        //IndexValue[] memory all = all_token_holder.iterate_getAll();\\n        KeyFlag[] memory allKeys = holderItMap.keys;\\n        account_amount[] memory result = new account_amount[](holderItMap.size);\\n        uint idex = 0;\\n        for (uint i = 0; i \\u003c allKeys.length; i++) {\\n            address holder = allKeys[i].key;\\n            // \u7528\u6237\u8868\u793a\u672a\u5220\u9664 \\n            if (!allKeys[i].deleted) {\\n                result[idex] = account_amount({\\n                    holder:holder,\\n                    amount:holderItMap.data[holder].value\\n                });\\n                idex++;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    //\u83b7\u5f97\u6240\u6709\u6301\u5e01\u7528\u6237\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\\n    function get_all_holder_account() public view returns(account_amount[] memory) {\\n        //all_token_holder\\n        //IndexValue[] memory all = all_token_holder.iterate_getAll();\\n        KeyFlag[] memory allKeys = all_token_holder.keys;\\n        account_amount[] memory result = new account_amount[](all_token_holder.size);\\n        for (uint i = 0; i \\u003c allKeys.length; i++) {\\n            address holder = allKeys[i].key;\\n            result[i] = account_amount({\\n                holder:holder,\\n                amount:all_token_holder.data[holder].value\\n            });\\n        }\\n        return result;\\n    }\\n\\n    //\u83b7\u5f97\u6240\u6709SWAP\u6301\u5e01\u7528\u6237\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\\n    function get_all_liquidity_holder_account() public view returns(account_amount[] memory) {\\n        //all_liquidity_holder\\n        KeyFlag[] memory allKeys = all_liquidity_holder.keys;\\n        account_amount[] memory result = new account_amount[](all_liquidity_holder.size);\\n        for (uint i = 0; i \\u003c allKeys.length; i++) {\\n            address holder = allKeys[i].key;\\n            result[i] = account_amount({\\n                holder:holder,\\n                amount:all_liquidity_holder.data[holder].value\\n            });\\n        }\\n        return result;\\n    }\\n}\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface IBEP20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function getOwner() external view returns (address);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\"},\"IPancakeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IPancakeFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\"},\"IPancakeRouter01.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"},\"IPancakeRouter02.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.6.2;\\n\\nimport \\u0027./IPancakeRouter01.sol\\u0027;\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"},\"IterableMapping.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.6.0 \\u003c0.9.0;\\n\\nstruct IndexValue { uint keyIndex; uint value; uint created; }\\nstruct KeyFlag { address key; bool deleted; }\\n\\nstruct itmap {\\n    mapping(address =\\u003e IndexValue) data;\\n    KeyFlag[] keys;\\n    uint size;\\n}\\n\\nlibrary IterableMapping {\\nfunction set(itmap storage self, address key, uint value) internal returns (bool replaced) {\\n        uint keyIndex = self.data[key].keyIndex;\\n        self.data[key].value = value;\\n        if (keyIndex \\u003e 0){\\n            if  (self.keys[keyIndex - 1].deleted) {\\n                self.keys[keyIndex - 1].deleted = false;\\n                self.size++;\\n            }\\n            return true;\\n        } else {\\n            keyIndex = self.keys.length;\\n\\n            self.keys.push();\\n            self.data[key].keyIndex = keyIndex + 1;\\n            self.data[key].created = block.timestamp;\\n            self.keys[keyIndex].key = key;\\n            self.size++;\\n            return false;\\n        }\\n    }\\n\\n    function remove(itmap storage self, address key) internal returns (bool success) {\\n        uint keyIndex = self.data[key].keyIndex;\\n        if (keyIndex == 0)\\n            return false;\\n        delete self.data[key];\\n        self.keys[keyIndex - 1].deleted = true;\\n        self.size --;\\n    }\\n\\n    function contains(itmap storage self, address key) internal view returns (bool) {\\n        return self.data[key].keyIndex \\u003e 0;\\n    }\\n\\n    function iterate_start(itmap storage self) internal view returns (uint keyIndex) {\\n        return iterate_next(self, type(uint).max);\\n    }\\n\\n    function iterate_valid(itmap storage self, uint keyIndex) internal view returns (bool) {\\n        return keyIndex \\u003c self.keys.length;\\n    }\\n\\n    function iterate_next(itmap storage self, uint keyIndex) internal view returns (uint r_keyIndex) {\\n        keyIndex++;\\n        while (keyIndex \\u003c self.keys.length \\u0026\\u0026 self.keys[keyIndex].deleted)\\n            keyIndex++;\\n        return keyIndex;\\n    }\\n\\n    function iterate_get(itmap storage self, uint keyIndex) internal view returns (address key, uint value) {\\n        key = self.keys[keyIndex].key;\\n        value = self.data[key].value;\\n    }\\n\\n    function iterate_getAll(itmap storage self) internal view returns (IndexValue[] memory) {\\n        IndexValue[] memory iv = new IndexValue[](self.size);\\n        for(uint i = 0; i \\u003c self.size; i++) {\\n            iv[i] = self.data[self.keys[i].key];\\n        }\\n        return iv;\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n   */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n   */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"},\"StarfieldToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./BEP20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport \\\"./IterableMapping.sol\\\";\\nimport \\\"./IPancakeRouter02.sol\\\";\\nimport \\\"./IPancakeFactory.sol\\\";\\nimport \\\"./DividendTracker.sol\\\";\\nimport \\\"./token_interface.sol\\\";\\n\\n\\ncontract StarfieldToken is Ownable, BEP20, IStarfieldToken {\\n    using SafeMath for uint256;\\n    using IterableMapping for itmap;\\n\\n    IPancakeRouter02 private pancakeRouter;\\n    DividendTracker public dividendTracker; //\u5206\u7ea2\u5bf9\u8c61\\n\\n    uint256 public maxTradeAmount = 100000 * 1e18; // \u6700\u5927\u5356\u51fa\u6570\u91cf\\n    uint transferFees = 12; // \u8f6c\u79fb\u624b\u7eed\u8d39\\n    uint tradeFees = 6; // \u4ea4\u6613\u624b\u7eed\u8d39\\n\\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD; //\u9500\u6bc1\u94b1\u5305\\n    //    address private swapRouteAddr = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3; // pancake swap route addr\\n    //    address constant private coinAddr = 0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684; // USDT\\n    // address constant private coinAddr = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // BUSD\\n\\n    // rinkeby\\n    //  address private swapRouteAddr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // pancake swap route addr\\n    //  address constant private coinAddr = 0xc5CA44fa5efdd9F4F6e10858FFe1665f186bC84B; // USDT\\n\\n    address private swapRouteAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // pancake swap route addr\\n    address constant private coinAddr = 0x55d398326f99059fF775485246999027B3197955; // USDT\\n\\n    address public lpPairAddr; // USDT/token \u5e01\u5bf9\u5730\u5740\\n\\n    bool public swapEnabled = true;\\n\\n    mapping(address =\\u003e bool) private _isExcludedFromFees; // \u624b\u7eed\u8d39\\n    mapping(address =\\u003e bool) public AMMPairMap;\\n\\n    mapping(address =\\u003e bool) private caller_white_map; //\u8c03\u7528\u5916\u90e8\u5956\u91d1\u63a5\u53e3\u7684\u767d\u540d\u5355\u7528\u6237\u5217\u8868\\n    bool private init_marketing_address_flag = false;\\n    bool private init_marketing_token_flag = false;\\n\\n    bool private _buyCardWhiteEnabled = false; // \u662f\u5426\u542f\u7528\u8d2d\u4e70\u5361\u724c \u767d\u540d\u5355\\n    itmap private buyCardWhiteList; // \u5361\u724c\u8d2d\u4e70\u767d\u540d\u5355\\n    event BuyCard(address account, uint256 amount); // \u8d2d\u4e70\u5361\u724c\u4e8b\u4ef6\\n\\n    address private stft_circulation_address; // \u6d41\u901a\u5730\u5740\\n    address private stft_investment_address; // \u6295\u8d44\u673a\u6784\u5730\u5740\\n    address private stft_operation_address; // \u8fd0\u7ef4\u5730\u5740\\n    address private stft_starfield_node_address; // \u661f\u57df\u8282\u70b9\u5730\u5740\\n    address private stft_ecological_address; // \u751f\u6001\u5730\u5740\\n    address private stft_swap_address; // \u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u6709\u8005\u5730\u5740\\n    address private stft_lp_holder_send_address; // lp\u6301\u5e01\u53d1\u653e\u5730\u5740\\n    address private stft_token_holder_send_address; // \u6301\u5e01\u53d1\u653e\u5730\u5740\\n    address private stft_fee_handler_address; // \u624b\u7eed\u8d39\u5904\u7406\u5730\u5740\\n    address public buyNodeTransferAddress; // \u8d2d\u4e70\u8282\u70b9\u5730\u5740\\n\\n    uint256 public minNeedHoldAmount = 1 * (10 ** 17); // 0.1\u4e2a\u6700\u4f4e\u6301\u5e01\\n    uint256 public transferActionAmount = 0; // \u8f6c\u79fb\u672a\u5904\u7406\u6570\u91cf\\n    uint256 public deflationAmount = 10000000 * 10 ** 18; // \u901a\u7f29\u6570\u91cf\\n\\n    event UpdateTransferActionAmount(\\n        address account,\\n        uint256 amount\\n    );\\n\\n    event UserTransferInfo(address account, uint count);\\n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress); // \u66f4\u65b0\u5206\u7ea2\u8ddf\u8e2a\u4e8b\u4ef6\\n    event UpdateSwapRouter(address indexed newAddress, address indexed oldAddress);\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n    event SwapAndLiquidity(\\n        uint256 tokensSwapped,\\n        uint256 busdReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n\\n    constructor() BEP20(\\\"Starfield Token\\\", \\\"STFT\\\") {\\n        pancakeRouter = IPancakeRouter02(swapRouteAddr);\\n        address _lpPairAddr = IPancakeFactory(pancakeRouter.factory()).createPair(address(this), coinAddr);\\n        lpPairAddr = _lpPairAddr;\\n        dividendTracker = new DividendTracker(address(this));\\n        dividendTracker.excludeFromDividends(address(dividendTracker));\\n        dividendTracker.excludeFromDividends(address(this));\\n        dividendTracker.excludeFromDividends(owner());\\n        dividendTracker.excludeFromDividends(deadWallet);\\n        dividendTracker.excludeFromDividends(address(pancakeRouter));\\n\\n        excludeFromFees(owner(), true);\\n        //\u786e\u4fdd\u7b2c\u4e00\u6b21\u5206\u914d\u4e1a\u52a1\u5730\u5740\u4ee3\u5e01\u4e0d\u6263\u624b\u7eed\u8d39\\n        excludeFromFees(address(this), true);\\n\\n        _setAutomatedMarketMakerPair(lpPairAddr, true);\\n        _isExcludedFromFees[address(this)] = true; // \u5c06\u5408\u7ea6\u5730\u5740\u653e\u5165\u624b\u7eed\u8d39\u767d\u540d\u5355\\n\\n        //\u5c06\u5408\u7ea6\u521b\u5efa\u5730\u5740\u8bbe\u7f6e\u5230\u53ef\u8bbf\u95ee\u767d\u540d\u5355\u4e2d\\n        caller_white_map[owner()] = true;\\n        buyNodeTransferAddress = owner(); // \u9ed8\u8ba4\u8282\u70b9\u8d2d\u4e70\u5730\u5740\u4e3a\u5408\u7ea6\u6240\u6709\u8005\\n    }\\n\\n    //to receive ETH from pancakeswapV2Router when swapping\\n    receive() external payable {}\\n\\n    // \u66f4\u65b0\u5206\u7ea2\u5408\u7ea6\u5bf9\u8c61\\n    function updateDividendTracker(address newAddress) public onlyOwner {\\n        require(newAddress != address(dividendTracker), \\\"The dividend tracker already has that address\\\");\\n        DividendTracker newDividendTracker = DividendTracker(payable(newAddress));\\n        require(newDividendTracker.owner() == address(this), \\\"The new dividend tracker must be owned by the current token contract\\\");\\n        // newDividendTracker\u5730\u5740\u4e0d\u5206\u7ea2\\n        newDividendTracker.excludeFromDividends(address(newDividendTracker));\\n        // \u8fd9\u4e2a\u5408\u7ea6\u5730\u5740\u4e0d\u5206\u7ea2\\n        newDividendTracker.excludeFromDividends(address(this));\\n        // msg.sender\u5730\u5740\\n        newDividendTracker.excludeFromDividends(owner());\\n        // \u4ee3\u5e01\u5bf9\u5730\u5740\\n        newDividendTracker.excludeFromDividends(address(pancakeRouter));\\n        emit UpdateDividendTracker(newAddress, address(dividendTracker));\\n        dividendTracker = newDividendTracker;\\n    }\\n\\n    // \u66f4\u65b0swap\u8def\u7531\\n    function updateSwapRouter(address newAddress) public onlyOwner {\\n        require(newAddress != address(pancakeRouter), \\\"The router already has that address\\\");\\n        emit UpdateSwapRouter(newAddress, address(pancakeRouter));\\n        pancakeRouter = IPancakeRouter02(newAddress);\\n        swapRouteAddr = newAddress;\\n\\n        //\u91cd\u65b0\u521b\u5efa\u5e01\u5bf9\\n        address _lpPairAddr = IPancakeFactory(pancakeRouter.factory()).createPair(address(this), coinAddr);\\n        lpPairAddr = _lpPairAddr;\\n    }\\n\\n    // \u8bbe\u7f6e\u662f\u5426\u53ef\u8fdb\u884c\u53bb\u4e2d\u5fc3\u5316\u4ea4\u6613\u6240\u7684\u4ea4\u6613\\n    function setSwapEnabled(bool _enabled) external onlyOwner {\\n        swapEnabled = _enabled;\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        require(AMMPairMap[pair] != value, \\\"Automated market maker pair is already set to that value\\\");\\n        AMMPairMap[pair] = value;\\n        if (value) {\\n            dividendTracker.excludeFromDividends(pair);\\n        }\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    // \u8bbe\u7f6elp\u6d41\u52a8\u6027\u5730\u5740\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\n        require(pair != lpPairAddr, \\\"The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\\\");\\n        _setAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    // \u8bbe\u7f6e\u6700\u5927\u4ea4\u6613\u91cf\\n    function setMaxTradeAmount(uint amount) external onlyOwner {\\n        maxTradeAmount = amount;\\n    }\\n\\n    // \u662f\u5426\u662f\u514d\u624b\u7eed\u8d39\u5730\u5740\\n    function isExcludeFromFees(address account) public view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    // \u6392\u9664\u624b\u7eed\u8d39\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        require(_isExcludedFromFees[account] != excluded, \\\"Account is already the value of \\u0027excluded\\u0027\\\");\\n        _isExcludedFromFees[account] = excluded;\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    // \u6392\u9664\u591a\u4e2a\u5730\u5740\u8d26\u53f7\u7684\u624b\u7eed\u8d39\\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\\n        for (uint i = 0; i \\u003c accounts.length; i++) {\\n            _isExcludedFromFees[accounts[i]] = excluded;\\n        }\\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\\n    }\\n\\n    // \u83b7\u53d6\u6ee1\u8db3\u5206\u7ea2\u7684\u4eba\u6570\\n    function getNumOfHolders(address caller) public view returns (uint) {\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\n        return dividendTracker.getNumOfHolders();\\n    }\\n\\n    //\u4ea4\u6613\u51fd\u6570\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint amount\\n    ) internal override {\\n        require(from != address(0), \\\"BEP20: transfer from the zero address\\\");\\n\\n        if (amount == 0) {\\n            super._transfer(from, to, 0);\\n            return;\\n        }\\n\\n        // \u662f\u5426\u9700\u8981\u624b\u7eed\u8d39\\n        bool isFreeFee = _isExcludedFromFees[from] || _isExcludedFromFees[to];\\n\\n        //\u514d\u624b\u7eed\u8d39\u4e4b\u95f4\u7684\u8f6c\u8d26\uff0c\u6216\u8005\u7528\u6237\u6dfb\u52a0\u6d41\u52a8\u6027\u662f\u4e0d\u6536\u53d6\u624b\u7eed\u8d39\u7684\\n        if (isFreeFee) {\\n            super._transfer(from, to, amount);\\n\\n            //\u5355\u4e00\u65b9\u4e1a\u52a1\u5730\u5740\uff0c\u53e6\u4e00\u65b9\u4f59\u989d\u66f4\u65b0\u5b58\u50a8\\n            if (!_isExcludedFromFees[to]) {\\n                try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\n            }\\n\\n            if (!_isExcludedFromFees[from]) {\\n                try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\n            }\\n\\n        } else {\\n            // \u6392\u9664\u4e70\u5356\\n            if (!AMMPairMap[from] \\u0026\\u0026 !AMMPairMap[to]) {\\n                // \u5224\u65ad\u7528\u6237\u6301\u5e01\\n                require(balanceOf(from) - amount \\u003e= minNeedHoldAmount, \\\"less than the minimum amount after the transfer\\\");\\n            }\\n\\n            uint _tradeFees = transferFees; // \u9ed8\u8ba4\u8f6c\u79fb\\n\\n            // swap\u64cd\u4f5c \u65b9\u5411 -\\u003e in lpPair\\n            if (AMMPairMap[to]) {\\n                _tradeFees = tradeFees; // \u6dfb\u52a0\u6d41\u52a8\u6027, \u5356\u51fa\\n                require(amount \\u003c= maxTradeAmount, \\\"Transfer amount exceeds the maxTradeAmount.\\\");\\n            }\\n\\n            // swap\u64cd\u4f5c \u65b9\u5411 lpPair out -\\u003e\\n            if (AMMPairMap[from]) {\\n                _tradeFees = 0; // \u79fb\u9664\u79fb\u52a8\u6027\uff0c\u4e70\u5165\\n            }\\n\\n            // \u5f53\u524d\u5408\u7ea6\u5df2\u901a\u7f29\u901a\u7f29\u5230\u6307\u5b9a\u6570\u91cf \u603b\u91cf - \u9500\u6bc1 = \u5269\u4f59\u6570\u91cf \\u003c= 1kw\\n            if(totalSupply() - balanceOf(deadWallet) \\u003c= deflationAmount) {\\n                _tradeFees = 0;\\n            }\\n\\n            uint _takeRatio = 100 - _tradeFees; // 90%\\n            uint _actualAmo = amount.mul(_takeRatio).div(100); // 90%\u7684\u8f6c\u79fb\u4ee3\u5e01\\n            super._transfer(from, to, _actualAmo); // \u8f6c\u79fb \u5b9e\u9645\u90e8\u5206\\n            uint _dividendAmo = amount.sub(_actualAmo); // \u5269\u4f59\u90e8\u5206\u7684\u64cd\u4f5c\u4ee3\u5e01\\n\\n            if (_dividendAmo \\u003e 0) {\\n                super._transfer(from, address(this), _dividendAmo); // \u5c06\u53ef\u64cd\u4f5c\u90e8\u5206\u4ee3\u5e01\u7ed9\u5230\u5408\u7ea6\u5730\u5740\\n                transferActionAmount = transferActionAmount.add(_dividendAmo); // \u53ef\u64cd\u4f5c\u5206\u914d\u90e8\u5206\\n                emit UpdateTransferActionAmount(from, transferActionAmount);\\n            }\\n        }\\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\n    }\\n\\n    // \u5904\u7406\u4ea4\u6613\u4ea7\u751f\u7684\u53ef\u5904\u7406\u4ee3\u5e01\\n    function handlerTransferActionAmount(uint256 amount) public onlyOwner returns (bool) {\\n        require(transferActionAmount \\u003e 0, \\\"transferActionAmount is zero\\\");\\n        require(amount != 0, \\\"handler amount is zero\\\");\\n        require(balanceOf(address(this)) \\u003e= amount, \\\"contract address balance is low\\\");\\n        uint256 actionAmount = amount;\\n        super._transfer(address(this), stft_fee_handler_address, actionAmount); // \u8f6c\u79fb\u5230\u624b\u7eed\u8d39\u5904\u7406\u5730\u5740\\n\\n        uint _burnAmount = actionAmount.mul(20).div(100); // \u9500\u6bc1\u90e8\u5206\\n        uint _lpAmount = actionAmount.mul(50).div(100); // \u5206\u914dLP\u90e8\u5206\\n        uint _holdAmount = actionAmount.mul(10).div(100); // \u5206\u914d\u6301\u5e01\u90e8\u5206\\n        uint _swapAmount = actionAmount.mul(10).div(100); // \u6dfb\u52a0\u5730\u6c60\u90e8\u5206\\n\\n        if(_burnAmount \\u003e 0) {\\n            super._transfer(stft_fee_handler_address, deadWallet, _burnAmount); // \u8f6c\u79fb\u5230\u9ed1\u6d1e\u5730\u5740\\n        }\\n        if(_lpAmount \\u003e 0) { // \u5206\u914d\u7ed9\u6d41\u52a8\u6027\u5e95\u6c60\u5730\u5740\\n            super._transfer(stft_fee_handler_address, stft_lp_holder_send_address, _lpAmount); // \u8f6c\u79fb\u5230\u53d1\u653elp\u6301\u5e01\u5730\u5740\\n            holder_swap_token_legal_send(stft_lp_holder_send_address, _lpAmount);\\n        }\\n        if(_holdAmount \\u003e 0) { // \u5206\u914d\u7ed9\u6301\u5e01\u5730\u5740\\n            super._transfer(stft_fee_handler_address, stft_token_holder_send_address, _holdAmount); // \u8f6c\u79fb\u5230\u53d1\u653elp\u6301\u5e01\u5730\u5740\\n            holder_token_legal_send(stft_token_holder_send_address, _holdAmount);\\n        }\\n        if(_swapAmount \\u003e 0) {\\n            super._transfer(stft_fee_handler_address, stft_swap_address, _swapAmount);\\n            if (swapEnabled) {\\n                swapAndLiquidity(_swapAmount);\\n            }\\n        }\\n\\n        transferActionAmount = transferActionAmount.sub(actionAmount);\\n        emit UpdateTransferActionAmount(stft_fee_handler_address, transferActionAmount);\\n\\n        return true;\\n    }\\n\\n    // \u63a8\u8350\u5206\u914d\u5956\u52b1\u7528 -- \u4f7f\u7528\u8282\u70b9\u5730\u5740\u53d1\u653e\u5956\u52b1\\n    function recommendUserAward(address caller, cards_bonus[] memory bonus_list) public returns(bool) {\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\n\\n        if (msg.sender != caller) {\\n            return false;\\n        }\\n\\n        uint _size = bonus_list.length;\\n\\n        uint256 _need_send_amount = 0;\\n        while (_size \\u003e 0) {\\n            _size = _size - 1;\\n            _need_send_amount = _need_send_amount + bonus_list[_size].bonus;\\n        }\\n\\n        //\u5224\u65ad\u8282\u70b9\u94b1\u5305\u5730\u5740\u4f59\u989d\u662f\u5426\u8db3\u591f\\n        if (balanceOf(stft_starfield_node_address) \\u003c _need_send_amount) {\\n            return false;\\n        }\\n\\n        _size = bonus_list.length;\\n\\n        while (_size \\u003e 0) {\\n            _size = _size - 1;\\n            if (bonus_list[_size].bonus != 0) {\\n                uint256 _bonus = bonus_list[_size].bonus;\\n                super._transfer(stft_starfield_node_address, bonus_list[_size].holder, _bonus);\\n                try dividendTracker.setBalance(payable(bonus_list[_size].holder), balanceOf(bonus_list[_size].holder)) {} catch {}\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    // \u4ea4\u6362\u4ee3\u5e01\\n    function swapTokensForBUSD(uint256 tokenAmount) private {\\n        // generate the pancake swap pair path of token -\\u003e busd \u751f\u6210pancake pair\u5468\u8fb9\u5408\u7ea6\u4ee3\u5e01\u8def\u5f84 -\\u003e \u7528busd\u4f4d\u6765\u8868\u793a\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = coinAddr;\\n        super._transfer(stft_swap_address, address(this), tokenAmount);\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\n        // make the swap\\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of BUSD\\n            path,\\n            stft_swap_address,\\n            block.timestamp + 600\\n        );\\n    }\\n\\n    function swapAndLiquidity(uint256 tokens) private {\\n        require(swapEnabled, \\\"not enabled swap\\\");\\n        // split the contract balance into halves \u628a\u8be5\u5408\u540c\u4f59\u989d\u5e73\u5206\uff0c\u5206\u6210\u4e00\u534a\\n        uint256 half = tokens.div(2);\\n        uint256 otherHalf = tokens.sub(half);\\n\\n        // capture the contract\\u0027s current ETH balance.   \u83b7\u53d6\u5408\u540c\u5f53\u524dETH\u4f59\u989d\u3002\\n        // this is so that we can capture exactly the amount of ETH that the   \u8fd9\u6837\u6211\u4eec\u5c31\u80fd\u51c6\u786e\u5730\u6355\u83b7ETH\u7684\u6570\u91cf\\n        // swap creates, and not make the liquidity event include any ETH that    \u4ea4\u6362\u4ea7\u751f\uff0c\u800c\u4e0d\u4f7f\u6d41\u52a8\u6027\u4e8b\u4ef6\u5305\u62ec\u4efb\u4f55ETH\\n        // has been manually sent to the contract    \u624b\u52a8\u53d1\u9001\u7ed9\u5408\u7ea6\u5730\u5740\\n        IBEP20 coin = IBEP20(coinAddr);\\n        uint256 initialBalance = coin.balanceOf(stft_swap_address);\\n        // swap tokens for ETH  ETH\u4ea4\u6362\u4ee3\u5e01\\n        swapTokensForBUSD(half);\\n        // \\u003c- this breaks the ETH -\\u003e HATE swap when swap+liquify is triggered  \u5f53swap+liquify\u88ab\u89e6\u53d1\u65f6\uff0c\u8fd9\u4f1a\u6253\u7834ETH -\\u003eHATE swap\\n\\n        // how much ETH did we just swap into?   \u6211\u4eec\u521a\u624d\u6362\u4e86\u591a\u5c11ETH ?\\n        uint256 newBalance = coin.balanceOf(stft_swap_address).sub(initialBalance);\\n        // add liquidity to uniswap      \u4e3auniswap\u589e\u52a0\u6d41\u52a8\u6027\\n        addLiquidity(otherHalf, newBalance);\\n\\n        emit SwapAndLiquidity(half, newBalance, otherHalf);\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 busdAmount) private {\\n        address token = address(this);\\n        IBEP20 busdToken = IBEP20(coinAddr);\\n        super._transfer(stft_swap_address, token, tokenAmount);\\n        busdToken.transferFrom(stft_swap_address, token, busdAmount);\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\n        busdToken.approve(swapRouteAddr, busdAmount);\\n        pancakeRouter.addLiquidity(\\n            token,\\n            coinAddr,\\n            tokenAmount,\\n            busdAmount,\\n            0,\\n            0,\\n            stft_swap_address,\\n            block.timestamp + 600\\n        );\\n    }\\n\\n    //\u5206\u914d\u4ee3\u5e01\\n    function init_marketing_token_amount() public onlyOwner {\\n\\n        //\u5730\u5740\u5df2\u7ecf\u8bbe\u7f6e\u5e76\u4e14\u6ca1\u5206\u914d\u8fc7\u4ee3\u5e01\\n        if (init_marketing_address_flag \\u0026\\u0026 !init_marketing_token_flag) {\\n            super._transfer(owner(), stft_circulation_address, 25000000 * (10 ** 18)); // \u6d41\u901a\u5730\u5740\\n            super._transfer(owner(), stft_investment_address, 15000000 * (10 ** 18)); // \u6295\u8d44\u673a\u6784\u5730\u5740\\n            super._transfer(owner(), stft_operation_address, 15000000 * (10 ** 18)); // \u8fd0\u7ef4\u5730\u5740\\n            super._transfer(owner(), stft_starfield_node_address, 200000000 * (10 ** 18)); // \u661f\u57df\u8282\u70b9\u5730\u5740\\n            super._transfer(owner(), stft_ecological_address, 45000000 * (10 ** 18)); // \u751f\u6001\u5730\u5740\\n            super._transfer(owner(), address(this), 700000000 * (10 ** 18));\\n        }\\n\\n        init_marketing_token_flag = true;\\n    }\\n\\n    function init_marketing_address(\\n        address circulation_address,\\n        address investment_address,\\n        address operation_address,\\n        address starfield_node_address,\\n        address ecological_address,\\n        address swap_address,\\n        address lp_holder_send_address,\\n        address token_holder_send_address,\\n        address fee_handler_address\\n    ) public onlyOwner {\\n        stft_circulation_address = circulation_address; // \u6d41\u901a\u5730\u5740\\n        stft_investment_address = investment_address; // \u6295\u8d44\u673a\u6784\u5730\u5740\\n        stft_operation_address = operation_address; // \u8fd0\u7ef4\u5730\u5740\\n        stft_starfield_node_address = starfield_node_address; // \u661f\u57df\u8282\u70b9\u5730\u5740\\n        stft_ecological_address = ecological_address; // \u751f\u6001\u5730\u5740\\n        stft_swap_address = swap_address; // \u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u6709\u8005\u5730\u5740\\n        stft_lp_holder_send_address = lp_holder_send_address; // lp\u6301\u5e01\u53d1\u653e\u5730\u5740\\n        stft_token_holder_send_address = token_holder_send_address; // \u6301\u5e01\u53d1\u653e\u5730\u5740\\n        stft_fee_handler_address = fee_handler_address; // \u624b\u7eed\u8d39\u5904\u7406\u5730\u5740\\n\\n        // \u624b\u7eed\u8d39\u767d\u540d\u5355\\n        _isExcludedFromFees[stft_circulation_address] = true;\\n        _isExcludedFromFees[stft_investment_address] = true;\\n        _isExcludedFromFees[stft_operation_address] = true;\\n        _isExcludedFromFees[stft_starfield_node_address] = true;\\n        _isExcludedFromFees[stft_ecological_address] = true;\\n        _isExcludedFromFees[stft_swap_address] = true;\\n        _isExcludedFromFees[stft_lp_holder_send_address] = true;\\n        _isExcludedFromFees[stft_token_holder_send_address] = true;\\n        _isExcludedFromFees[stft_fee_handler_address] = true;\\n\\n        init_marketing_address_flag = true;\\n    }\\n\\n    function get_marketing_address_info() public view onlyOwner returns (address, address, address, address, address, address, address, address, address){\\n        return (\\n        stft_circulation_address, // \u6d41\u901a\u5730\u5740\\n        stft_investment_address, // \u6295\u8d44\u673a\u6784\u5730\u5740\\n        stft_operation_address, // \u8fd0\u7ef4\u5730\u5740\\n        stft_starfield_node_address, // \u661f\u57df\u8282\u70b9\u5730\u5740\\n        stft_ecological_address, // \u751f\u6001\u5730\u5740\\n        stft_swap_address, // \u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u6709\u8005\u5730\u5740\\n        stft_lp_holder_send_address, // lp\u6301\u5e01\u53d1\u653e\u5730\u5740\\n        stft_token_holder_send_address, // \u6301\u5e01\u53d1\u653e\u5730\u5740\\n        stft_fee_handler_address // \u5361\u724c\u5730\u5740\\n        );\\n    }\\n\\n    //\u8bbe\u7f6e\u767d\u540d\u5355\u63a5\u53e3\\n    function set_white_list(address addr, bool on) external onlyOwner {\\n        caller_white_map[addr] = on;\\n    }\\n\\n    function is_white_list(address addr) external view onlyOwner returns (bool){\\n        return caller_white_map[addr];\\n    }\\n\\n    // \u8bbe\u7f6e\u542f\u7528\u8d2d\u4e70\u767d\u540d\u5355\\n    function setBuyCardWhiteEnabled(bool on) public onlyOwner returns(bool) {\\n        _buyCardWhiteEnabled = on;\\n        return true;\\n    }\\n\\n    // \u662f\u5426\u542f\u7528\u8d2d\u4e70\u767d\u540d\u5355\\n    function buyCardWhiteEnabled() public view onlyOwner returns (bool) {\\n        return _buyCardWhiteEnabled;\\n    }\\n\\n    // \u8bbe\u7f6e\u7528\u6237\u8d2d\u4e70\u767d\u540d\u5355\\n    function set_buy_card_white(address[] calldata addrs, bool on) public onlyOwner returns (bool) {\\n        require(_buyCardWhiteEnabled, \\\"buy card white enabled is false\\\");\\n        uint flag = 0;\\n        if (on) {\\n            flag = 1;\\n        }\\n        for (uint i = 0; i \\u003c addrs.length; i++) {\\n            buyCardWhiteList.set(addrs[i], flag);\\n        }\\n        return true;\\n    }\\n\\n    struct BuyCardWhiteInfo {\\n        address account;\\n        bool flag;\\n    }\\n\\n    // \u83b7\u53d6\u7528\u6237\u767d\u540d\u5355\u5217\u8868\\n    function buy_card_white_list() public view onlyOwner returns (BuyCardWhiteInfo[] memory) {\\n        uint size = buyCardWhiteList.size;\\n\\n        BuyCardWhiteInfo[] memory white_list = new BuyCardWhiteInfo[](size);\\n\\n        for (uint i = 0; i \\u003c size; i++) {\\n            address account = buyCardWhiteList.keys[i].key;\\n            bool flag = false;\\n            if (buyCardWhiteList.data[account].value == 1) {\\n                flag = true;\\n            }\\n            white_list[i] = BuyCardWhiteInfo({\\n            account: account,\\n            flag: flag\\n            });\\n        }\\n        return white_list;\\n    }\\n\\n    // \u7528\u6237\u81ea\u8d2d\u4e70\\n    function user_buy_card(address buy_user, uint256 amount) public returns(bool) {\\n        if (_buyCardWhiteEnabled) {\\n            require(buyCardWhiteList.data[buy_user].value == 1, \\\"not buy card authority\\\");\\n        }\\n        require(_msgSender() == buy_user, \\\"sender not is buy user\\\");\\n        require(balanceOf(buy_user) \\u003e= amount, \\\"amount exceeds allowance\\\");\\n\\n        //60% \u5206\u914d\u7ed9\u9ed1\u6d1e\\n        super._transfer(buy_user, deadWallet, amount * 60 / 100);\\n\\n        //20% \u5206\u914d\u7ed9\u6d41\u52a8\u6027\u5e95\u6c60\u5730\u5740\uff08\u52a0\u6743\u5e73\u5747\u5206\uff09\\n        holder_swap_token_legal_send(buy_user, amount * 20 / 100);\\n\\n        //20% \u6784\u5efa\u5e95\u6c60\\n        super._transfer(buy_user, stft_swap_address, amount * 20 / 100);\\n        if (swapEnabled) {\\n            swapAndLiquidity(amount * 20 / 100);\\n        }\\n\\n        emit BuyCard(buy_user, amount);\\n        return true;\\n    }\\n\\n    //eb\u8d2d\u4e70\u5361\u724c\\n    function eb_buy_card(address caller, address buy_user, uint256 amount) public returns (bool) {\\n        require(balanceOf(stft_ecological_address) \\u003e= amount, \\\"token balance is low\\\");\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\n\\n        if (msg.sender != caller) {\\n            return false;\\n        }\\n        super._transfer(stft_ecological_address, deadWallet, amount);\\n\\n        emit BuyCard(buy_user, amount);\\n        return true;\\n    }\\n\\n    //\u5361\u724c\u6536\u76ca\u53d1\u653e\\n    function send_cards_auto_bonus(address caller, cards_bonus[] memory bonus_list) public returns (bool) {\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\n\\n        if (msg.sender != caller) {\\n            return false;\\n        }\\n\\n        uint _size = bonus_list.length;\\n\\n        uint256 _need_send_amount = 0;\\n        while (_size \\u003e 0) {\\n            _size = _size - 1;\\n            _need_send_amount = _need_send_amount + bonus_list[_size].bonus;\\n\\n        }\\n\\n        if (balanceOf(address(this)) \\u003c _need_send_amount) {\\n            return false;\\n        }\\n\\n        _size = bonus_list.length;\\n\\n        while (_size \\u003e 0) {\\n            _size = _size - 1;\\n            if (bonus_list[_size].bonus != 0) {\\n                uint256 _bonus = bonus_list[_size].bonus;\\n                super._transfer(address(this), bonus_list[_size].holder, _bonus);\\n                try dividendTracker.setBalance(payable(bonus_list[_size].holder), balanceOf(bonus_list[_size].holder)) {} catch {}\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    //\u6d41\u52a8\u6027\u5e95\u6c60\u7528\u6237\u53d8\u66f4\u63a5\u53e3\\n    function update_liquidity_holder_address(address caller, address holder, uint256 amount) public override returns (bool) {\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\n        dividendTracker.setLiquidityBalance(holder, amount);\\n        return true;\\n    }\\n\\n    function update_liquidity_holder_address_list(address caller, liquidity_account_info[] memory holder_list) public override returns (bool) {\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\n        uint _size = holder_list.length;\\n\\n        while (_size \\u003e 0) {\\n            _size = _size - 1;\\n            dividendTracker.setLiquidityBalance(holder_list[_size].holder, holder_list[_size].amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    //\u5c06amount\u6570\u91cf\u7684\u4ee3\u5e01\uff0c\u52a0\u6743\u5206\u914d\u7ed9\u6240\u6709\u6301\u5e01\u4eba\\n    function holder_token_legal_send(address from, uint256 amount) private {\\n        require(amount != 0, \\\"bad amount is not zero\\\");\\n        account_amount[] memory _account_list = dividendTracker.get_all_holder_account();\\n        _bonnus_sender_all(from, _account_list, amount, address(0));\\n        return;\\n    }\\n\\n    //\u5c06amount\u6570\u91cf\u7684\u4ee3\u5e01\uff0c\u52a0\u6743\u5206\u914d\u7ed9\u6240\u6709\u6301\u5e01\u4eba\\n    function holder_swap_token_legal_send(address from, uint256 amount) private {\\n        require(amount != 0, \\\"bad amount is not zero\\\");\\n        account_amount[] memory _account_list = dividendTracker.get_all_liquidity_holder_account();\\n        _bonnus_sender_all(from, _account_list, amount, address(0));\\n        return;\\n    }\\n\\n    function get_all_liquidity_holder_account(address caller) public view  override returns (account_amount[] memory) {\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\n        return dividendTracker.get_all_liquidity_holder_account();\\n    }\\n\\n    function get_all_holder_account(address caller) public view override returns (account_amount[] memory) {\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\n        return dividendTracker.get_all_holder_account();\\n    }\\n\\n    function _setBalance(address addr1, address addr2) internal {\\n        try dividendTracker.setBalance(payable(addr1), balanceOf(addr1)) {} catch {}\\n        try dividendTracker.setBalance(payable(addr2), balanceOf(addr2)) {} catch {}\\n    }\\n\\n    function _bonnus_sender_all(address from, account_amount[] memory account_list, uint256 amount, address operator) private {\\n        uint _size = account_list.length;\\n        if (_size == 0 \\u0026\\u0026 amount \\u003e 0) {\\n            super._transfer(from, address(this), amount);\\n            return;\\n        }\\n        //\u8ba1\u7b97\u6bcf\u4e2a\u4eba\u5e94\u8be5\u5206\u914d\u7684\u5956\u91d1\u6570\u91cf\\n        uint256 all_amount = 0;\\n        while (_size \\u003e 0) {\\n            _size = _size - 1;\\n\\n            //\u9700\u8981\u68c0\u67e5operator\u5e76\u4e14\u5f53\u524d\u7528\u6237\u7b49\u4e8eoperator\uff0c\u5219\u4e0d\u7edf\u8ba1\u603b\u989d\\n            if (operator != address(0) \\u0026\\u0026 account_list[_size].holder == operator) {\\n                continue;\\n            }\\n\\n            all_amount = all_amount + account_list[_size].amount;\\n        }\\n\\n        //\u5982\u679c\u6ca1\u6709\u5956\u91d1\uff0c\u76f4\u63a5\u8fd4\u56de\\n        if (all_amount == 0) {\\n            return;\\n        }\\n\\n        _size = account_list.length;\\n        while (_size \\u003e 0) {\\n            _size = _size - 1;\\n\\n            //\u9700\u8981\u68c0\u67e5operator\u5e76\u4e14\u5f53\u524d\u7528\u6237\u7b49\u4e8eoperator\uff0c\u5219\u4e0d\u5206\u914d\u5956\u91d1\\n            if (operator != address(0) \\u0026\\u0026 account_list[_size].holder == operator \\u0026\\u0026 amount != 0) {\\n                continue;\\n            }\\n\\n            uint256 _bonus = account_list[_size].amount * amount / all_amount;\\n            if (_bonus \\u003e 0) {\\n                super._transfer(from, account_list[_size].holder, _bonus);\\n                try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\n                try dividendTracker.setBalance(payable(account_list[_size].holder), balanceOf(account_list[_size].holder)) {} catch {}\\n            }\\n        }\\n    }\\n\\n    // \u5408\u7ea6\u5185\u5269\u4f59\u4ee3\u5e01\u6570\u91cf\\n    function balanceToken() public view returns (uint256) {\\n        return balanceOf(address(this));\\n    }\\n\\n    // \u8bbe\u7f6e\u8d2d\u4e70\u8282\u70b9\u7684\u5730\u5740\\n    function setBuyNodeTransferAddress(address account) public onlyOwner returns (bool) {\\n        buyNodeTransferAddress = account;\\n        return true;\\n    }\\n\\n    // \u8bbe\u7f6e\u5408\u7ea6\u5f53\u524d\u6700\u4f4e\u6301\u6709\u91cf\\n    function setMinNeedHoldAmount(uint256 amount) public onlyOwner returns (bool) {\\n        minNeedHoldAmount = amount;\\n        return true;\\n    }\\n\\n    // \u83b7\u53d6\u7528\u6237\u6d41\u52a8\u6027\u6301\u5e01\u6570\u91cf\\n    function getAccountLiquidityHolder(address account) public view returns (uint256) {\\n        return dividendTracker.liquidityBalanceOf(account);\\n    }\\n}\"},\"token_interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT License\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\n    struct cards_bonus {\\n        address holder;\\n        uint256 bonus;\\n    }\\n\\n    struct liquidity_account_info {\\n        address holder;\\n        uint256 amount;\\n    }\\n\\n    struct liquidity_bonus_info {\\n        address holder;\\n        uint256 amount;\\n        uint256 times;\\n    }\\n\\n    struct account_amount {\\n        address holder;\\n        uint256 amount;\\n        //uint legal; // \u6743\u91cd\uff0c\u8ba1\u7b97\u540e\u8bbe\u7f6e\\n    }\\n\\ninterface IStarfieldToken {\\n\\n    //\u6d41\u52a8\u6027\u5e95\u6c60\u7528\u6237\u53d8\u66f4\u63a5\u53e3\\n    function update_liquidity_holder_address(address caller, address holder, uint256 amount) external returns(bool);\\n    function update_liquidity_holder_address_list(address caller, liquidity_account_info[] memory holder_list) external returns(bool);\\n\\n    //\u83b7\u5f97\u6240\u6709\u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u5e01\u7528\u6237\u5217\u8868\\n    function get_all_liquidity_holder_account(address caller) external view returns(account_amount[] memory);\\n\\n    //\u83b7\u5f97\u6240\u6709\u6301\u5e01\u7528\u6237\u5217\u8868\\n    function get_all_holder_account(address caller) external view returns(account_amount[] memory);\\n}\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::safeApprove: approve failed\\u0027\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyCard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busdReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateSwapRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UpdateTransferActionAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"UserTransferInfo\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"AMMPairMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCardWhiteEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyNodeTransferAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_card_white_list\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"internalType\":\"struct StarfieldToken.BuyCardWhiteInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deflationAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buy_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eb_buy_card\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountLiquidityHolder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"getNumOfHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"get_all_holder_account\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct account_amount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"get_all_liquidity_holder_account\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct account_amount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_marketing_address_info\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"handlerTransferActionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"circulation_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"investment_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operation_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"starfield_node_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ecological_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swap_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lp_holder_send_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_holder_send_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fee_handler_address\",\"type\":\"address\"}],\"name\":\"init_marketing_address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init_marketing_token_amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludeFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"is_white_list\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPairAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTradeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minNeedHoldAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"msgSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"internalType\":\"struct cards_bonus[]\",\"name\":\"bonus_list\",\"type\":\"tuple[]\"}],\"name\":\"recommendUserAward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"internalType\":\"struct cards_bonus[]\",\"name\":\"bonus_list\",\"type\":\"tuple[]\"}],\"name\":\"send_cards_auto_bonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"setBuyCardWhiteEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setBuyNodeTransferAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTradeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinNeedHoldAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"set_buy_card_white\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"set_white_list\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferActionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"update_liquidity_holder_address\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct liquidity_account_info[]\",\"name\":\"holder_list\",\"type\":\"tuple[]\"}],\"name\":\"update_liquidity_holder_address_list\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buy_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"user_buy_card\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StarfieldToken", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://29ce1ef069304502e5111c2e3bfd1f99b163ae0f016769f216d4f36975aa2b66"}