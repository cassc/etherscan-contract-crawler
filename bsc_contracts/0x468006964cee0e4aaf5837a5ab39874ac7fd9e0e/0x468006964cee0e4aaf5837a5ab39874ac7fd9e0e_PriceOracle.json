{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/koloale/orion-projects/orion-exchange-bsc/contracts/PriceOracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./libs/EIP712Interface.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @title PriceOracle\\n * @dev Contract for storing and providing price data for the Orion Protocol\\n * @author @EmelyanenkoK\\n */\\ncontract PriceOracle is /* EIP712Interface, */ Ownable {\\n\\n    struct Prices {\\n        address[] assetAddresses;\\n        uint64[] prices;\\n        uint64 timestamp;\\n        bytes signature;\\n    }\\n\\n    struct PriceDataOut {\\n        uint64 price;\\n        uint64 timestamp;\\n    }\\n\\n    /*bytes32 public constant PRICES_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"Prices(address[] assetAddresses,uint64[] prices,uint64 timestamp)\\\"\\n        )\\n    );*/\\n\\n    address public oraclePublicKey;\\n    address public baseAsset;\\n    mapping(address => PriceDataOut) public assetPrices;\\n    mapping(address => address) public chainLinkETHAggregator;\\n    mapping(address => bool) public priceProviderAuthorization;\\n\\n    constructor(address publicKey, address _baseAsset) public {\\n        oraclePublicKey = publicKey;\\n        baseAsset = _baseAsset;\\n    }\\n    /*\\n    function checkPriceFeedSignature(Prices memory priceFeed) public view returns (bool) {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                getPricesHash(priceFeed)\\n            )\\n        );\\n\\n        if (priceFeed.signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        bytes memory signature = priceFeed.signature;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        if (\\n            uint256(s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n\\n        return ecrecover(digest, v, r, s) == oraclePublicKey;\\n    \\n    }\\n\\n    function provideData(Prices memory priceFeed) public {\\n       require(checkPriceFeedSignature(priceFeed), \\\"Wrong signature\\\");\\n       require(priceFeed.timestamp<block.timestamp+60, \\\"Price data timestamp too far in the future\\\");\\n       for(uint8 i=0; i<priceFeed.assetAddresses.length; i++) {\\n         PriceDataOut storage assetData = assetPrices[priceFeed.assetAddresses[i]];\\n         if(assetData.timestamp<priceFeed.timestamp) {\\n           assetData.price = priceFeed.prices[i];\\n           assetData.timestamp = priceFeed.timestamp;\\n         }\\n       }\\n    }\\n    */\\n    function provideDataAddressAuthorization(Prices memory priceFeed) public {\\n       require(priceProviderAuthorization[msg.sender], \\\"Unauthorized dataprovider\\\");\\n       require(priceFeed.timestamp<block.timestamp+60, \\\"Price data timestamp too far in the future\\\");\\n       for(uint8 i=0; i<priceFeed.assetAddresses.length; i++) {\\n         PriceDataOut storage assetData = assetPrices[priceFeed.assetAddresses[i]];\\n         if(assetData.timestamp<priceFeed.timestamp) {\\n           assetData.price = priceFeed.prices[i];\\n           assetData.timestamp = priceFeed.timestamp;\\n         }\\n       }\\n    }\\n\\n    function givePrices(address[] calldata assetAddresses) external view returns (PriceDataOut[] memory) {\\n      PriceDataOut[] memory result = new PriceDataOut[](assetAddresses.length);\\n      for(uint8 i=0; i<assetAddresses.length; i++) {\\n        result[i] = assetPrices[assetAddresses[i]];\\n      }\\n      return result;\\n    }\\n    /*\\n    function getPricesHash(Prices memory priceVector)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    PRICES_TYPEHASH,\\n                    keccak256(abi.encodePacked(priceVector.assetAddresses)),\\n                    keccak256(abi.encodePacked(priceVector.prices)),\\n                    priceVector.timestamp\\n                )\\n            );\\n    }\\n    */\\n    function getChainLinkPriceData(address[] memory assets) public {\\n      address baseAggregator = chainLinkETHAggregator[baseAsset];\\n      if(baseAggregator == address(0))\\n        return;\\n      (\\n          uint80 roundID,\\n          int _basePrice,\\n          uint startedAt,\\n          uint timestamp,\\n          uint80 answeredInRound\\n      ) = AggregatorV3Interface(baseAggregator).latestRoundData();\\n      uint now = block.timestamp;\\n      if(now - timestamp < 24 hours) {\\n        timestamp = now;\\n      }\\n      require(_basePrice>=0, \\\"Negative base price is not allowed\\\");\\n      uint basePrice = uint(_basePrice);\\n      \\n      //ETH/ORN  \\n      PriceDataOut storage baseAssetData = assetPrices[address(0)];\\n      if(baseAssetData.timestamp<timestamp) {\\n          uint price = ( (10**AggregatorV3Interface(baseAggregator).decimals()) *1e8)/basePrice;\\n          require(price<2**64-1, \\\"Too big price\\\");\\n          baseAssetData.price = uint64(price);\\n          baseAssetData.timestamp = uint64(timestamp);\\n      }\\n        \\n      for(uint8 i=0; i<assets.length; i++) {\\n        address currentAsset = assets[i];\\n        address currentAggregator = chainLinkETHAggregator[currentAsset];\\n        if( currentAggregator == address(0))\\n          continue;\\n        (\\n            uint80 aRoundID,\\n            int _aPrice,\\n            uint aStartedAt,\\n            uint aTimestamp,\\n            uint80 aAnsweredInRound\\n        ) = AggregatorV3Interface(currentAggregator).latestRoundData();\\n        require(_aPrice>=0, \\\"Negative price is not allowed\\\");\\n        if(now - timestamp < 24 hours) {\\n          aTimestamp = now;\\n        }\\n        uint aPrice = uint(_aPrice);\\n        uint newTimestamp = timestamp > aTimestamp? aTimestamp : timestamp;\\n\\n        PriceDataOut storage assetData = assetPrices[currentAsset];\\n        if(assetData.timestamp<newTimestamp) {\\n          uint price = (aPrice *1e8)/basePrice;\\n          require(price<2**64-1, \\\"Too big price\\\");\\n          assetData.price = uint64(price);\\n          assetData.timestamp = uint64(newTimestamp);\\n        }\\n\\n      }\\n    }    \\n    function setChainLinkAggregators(address[] memory assets, address[] memory aggregatorAddresses) public onlyOwner {\\n      for(uint8 i=0; i<assets.length; i++) {\\n        chainLinkETHAggregator[assets[i]] = aggregatorAddresses[i];\\n      }\\n    }\\n    \\n    function changePriceProviderAuthorization(address[] memory added, address[] memory removed) public onlyOwner {\\n      for(uint8 i=0; i<added.length; i++) {\\n        priceProviderAuthorization[added[i]] = true;\\n      }\\n      for(uint8 i=0; i<removed.length; i++) {\\n        priceProviderAuthorization[removed[i]] = false;\\n      }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/koloale/orion-projects/orion-exchange-bsc/contracts/libs/EIP712Interface.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\ncontract EIP712Interface {\\n    string public constant DOMAIN_NAME = \\\"Orion Exchange\\\";\\n    string public constant DOMAIN_VERSION = \\\"1\\\";\\n    uint256 public constant CHAIN_ID = 56;\\n    bytes32\\n        public constant DOMAIN_SALT = 0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a557;\\n\\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,bytes32 salt)\\\"\\n        )\\n    );\\n    bytes32 public constant DOMAIN_SEPARATOR = keccak256(\\n        abi.encode(\\n            EIP712_DOMAIN_TYPEHASH,\\n            keccak256(bytes(DOMAIN_NAME)),\\n            keccak256(bytes(DOMAIN_VERSION)),\\n            CHAIN_ID,\\n            DOMAIN_SALT\\n        )\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"publicKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_baseAsset\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetPrices\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chainLinkETHAggregator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"added\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"removed\",\"type\":\"address[]\"}],\"name\":\"changePriceProviderAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"name\":\"getChainLinkPriceData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetAddresses\",\"type\":\"address[]\"}],\"name\":\"givePrices\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"internalType\":\"struct PriceOracle.PriceDataOut[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oraclePublicKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceProviderAuthorization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"assetAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint64[]\",\"name\":\"prices\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PriceOracle.Prices\",\"name\":\"priceFeed\",\"type\":\"tuple\"}],\"name\":\"provideDataAddressAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"aggregatorAddresses\",\"type\":\"address[]\"}],\"name\":\"setChainLinkAggregators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PriceOracle", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003b9e04c53b45a9386de378ab9c27dddd4e15725f000000000000000000000000e4ca1f75eca6214393fce1c1b316c237664eaa8e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}