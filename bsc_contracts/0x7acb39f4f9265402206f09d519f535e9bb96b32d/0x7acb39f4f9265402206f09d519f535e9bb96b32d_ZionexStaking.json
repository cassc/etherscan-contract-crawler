{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IToken {\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract ZionexStaking {\r\n    struct Stake {\r\n        uint256 amount;\r\n        uint256 startTime;\r\n    }\r\n\r\n    struct CurrentStake {\r\n        uint256 amount;\r\n        uint256 totalDays;\r\n    }\r\n\r\n    IToken public token;\r\n    mapping(address => Stake[]) private stakers;\r\n\r\n    uint256 public totalStaked = 0;\r\n    uint256 public totalClaimed = 0;\r\n    uint256 public constant MONTHLY_INTEREST_RATE = 5; // 5% monthly = 60% yearly\r\n    uint256 private constant INTEREST = 60; // 5% monthly = 60% yearly\r\n    uint256 private constant INTEREST_DIVISOR = 100; // This is used for percentage calculation.\r\n    uint256 public constant PERIOD = 365 days; // 1 year\r\n\r\n    address public owner;\r\n    bool public stakingPaused = false;\r\n\r\n    constructor() {\r\n        token = IToken(0x926d397a5983ba587a92Ad5D2386e0370DaE43c8);\r\n        token.approve(address(this), type(uint256).max);\r\n        owner = 0x12C1B4404B4F41dCd80D4De34dbDF61033e1B3A5;\r\n    }\r\n\r\n    function stake(uint256 amount) external {\r\n        require(!stakingPaused, \"Staking is paused\");\r\n        require(\r\n            token.transferFrom(msg.sender, address(this), amount),\r\n            \"Transfer failed\"\r\n        );\r\n\r\n        Stake memory newStake = Stake({\r\n            amount: amount,\r\n            startTime: block.timestamp\r\n        });\r\n        totalStaked += amount;\r\n\r\n        stakers[msg.sender].push(newStake);\r\n    }\r\n\r\n    function claim() external {\r\n        uint256 totalAmount = 0;\r\n        uint256 validStakesCount = 0;\r\n\r\n        for (uint256 i = 0; i < stakers[msg.sender].length; i++) {\r\n            uint256 endTime = stakers[msg.sender][i].startTime + PERIOD;\r\n            if (block.timestamp > endTime) {\r\n                uint256 stakeAmount = stakers[msg.sender][i].amount;\r\n                totalAmount +=\r\n                    stakeAmount +\r\n                    calculateInterest(\r\n                        stakeAmount,\r\n                        stakers[msg.sender][i].startTime\r\n                    );\r\n            } else {\r\n                // Move non-mature stakes to the front\r\n                stakers[msg.sender][validStakesCount] = stakers[msg.sender][i];\r\n                validStakesCount++;\r\n            }\r\n        }\r\n\r\n        // Pop off processed stakes\r\n        while (stakers[msg.sender].length > validStakesCount) {\r\n            stakers[msg.sender].pop();\r\n        }\r\n\r\n        require(totalAmount > 0, \"No mature stakes found\");\r\n        require(token.transfer(msg.sender, totalAmount), \"Transfer failed\");\r\n        totalClaimed += totalAmount;\r\n    }\r\n\r\n    function calculateInterest(\r\n        uint256 _amount,\r\n        uint256 _startTime\r\n    ) private view returns (uint256) {\r\n        uint256 totalSeconds = block.timestamp - _startTime;\r\n        return\r\n            (_amount * totalSeconds * INTEREST) / (PERIOD * INTEREST_DIVISOR);\r\n    }\r\n\r\n    function viewCurrentBalance(\r\n        address _address\r\n    ) public view returns (uint256) {\r\n        uint256 totalAmount = 0;\r\n        for (uint256 i = 0; i < stakers[_address].length; i++) {\r\n            uint256 stakeAmount = stakers[_address][i].amount;\r\n            totalAmount +=\r\n                stakeAmount +\r\n                calculateInterest(stakeAmount, stakers[_address][i].startTime);\r\n        }\r\n        return totalAmount;\r\n    }\r\n\r\n    function viewStakeAmountAndDays(\r\n        address _address\r\n    ) public view returns (CurrentStake[] memory) {\r\n        Stake[] memory userStakes = stakers[_address];\r\n        CurrentStake[] memory transformedStakes = new CurrentStake[](\r\n            userStakes.length\r\n        );\r\n\r\n        for (uint256 i = 0; i < userStakes.length; i++) {\r\n            transformedStakes[i] = CurrentStake({\r\n                amount: userStakes[i].amount,\r\n                totalDays: (block.timestamp - userStakes[i].startTime) / 1 days\r\n            });\r\n        }\r\n\r\n        return transformedStakes;\r\n    }\r\n\r\n    function pauseStaking() external {\r\n        require(msg.sender == owner, \"Only owner can pause staking\");\r\n        stakingPaused = true;\r\n    }\r\n\r\n    function unpauseStaking() external {\r\n        require(msg.sender == owner, \"Only owner can unpause staking\");\r\n        stakingPaused = false;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MONTHLY_INTEREST_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"viewCurrentBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"viewStakeAmountAndDays\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDays\",\"type\":\"uint256\"}],\"internalType\":\"struct ZionexStaking.CurrentStake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZionexStaking", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://efbdf1cea6ecbc92484f9590ba8d494a1cf52a1c3932f068000ab0477a025862"}