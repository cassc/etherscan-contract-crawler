{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity 0.8.18;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address public _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _msgSender());\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require (_msgSender() == _owner);\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IW3swapRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IW3swapRouter02 is IW3swapRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n\r\nlibrary calSome{\r\n    using SafeMath for uint256;\r\n    function getFee(uint amount, uint per) internal pure returns(uint){\r\n        return amount.mul(per).div(10000);\r\n    }\r\n\r\n    function rand(uint256 _length) internal view returns(uint256) {\r\n        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));\r\n        return random%_length;\r\n    }\r\n\r\n    function getBackPer(uint minNum, uint maxNum, uint nowNum, uint _addOnce, uint changeDay) \r\n    internal pure returns (uint){\r\n        uint getDay = nowNum.add(changeDay.mul(_addOnce));\r\n        uint backPer = 0;\r\n        if (changeDay == 0){\r\n            return 0;\r\n        } else {\r\n            if (getDay > maxNum){\r\n                uint days1 = maxNum.sub(nowNum).div(_addOnce).add(1);\r\n                uint addScore1 = days1.mul(days1.sub(1).mul(_addOnce)).div(2);\r\n                backPer = days1.mul(nowNum).add(addScore1);\r\n                uint days2 = changeDay.sub(days1);\r\n                if (days2 > 0){\r\n                    uint addScore2 = days2.mul(days2.sub(1).mul(_addOnce)).div(2);\r\n                    backPer = backPer.add(days2.mul(minNum).add(addScore2));\r\n                }\r\n            } else {\r\n                uint addScore = changeDay.mul(changeDay.sub(1).mul(_addOnce)).div(2);\r\n                backPer = changeDay.mul(nowNum).add(addScore);\r\n            }\r\n            if (backPer >= 10000){\r\n                backPer = 10000;\r\n            }\r\n            return backPer;\r\n        }\r\n    }\r\n\r\n    function getTruePer(uint minNum, uint maxNum, uint nowNum, uint _addOnce, uint changeDay) \r\n    internal pure returns (uint){\r\n        uint getDay = nowNum.add(changeDay.mul(_addOnce));\r\n        if (getDay > maxNum){\r\n            uint days1 = maxNum.sub(nowNum).add(1).div(_addOnce);\r\n            uint needDay = maxNum.sub(minNum).add(1).div(_addOnce);\r\n            uint days2 = changeDay.sub(days1).mod(needDay);\r\n            getDay = minNum.add(days2.mul(_addOnce));\r\n        }\r\n        return getDay;\r\n    }\r\n}\r\n\r\ninterface levelDo {\r\n    function getUserTrueLevel(address userAddress) external view returns(uint);\r\n    function getUserLevel(address searchAddress) external view returns (uint);\r\n    function getLevelBack(uint level) external view returns(uint);\r\n    function getLevelPer(uint level) external view returns(uint);\r\n    function getLevelNum(uint level) external view returns(uint);\r\n    function getHaveBuy(address userAddress) external view returns(uint);\r\n    function updateTeamScore(address _yourAddress, uint _amount) external;\r\n    function getParent(address userAddress) external view returns(address);\r\n}\r\n\r\ncontract zhou is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint8;\r\n\r\n    uint coinMin = 100;\r\n    uint coinMax = 200;\r\n    uint coinAddOnce = 1;\r\n\r\n    mapping (address => uint) userStore;\r\n\r\n    mapping (address => StoreCell) storeRelase;\r\n    mapping (address => StoreCell) coinRealse;\r\n\r\n\r\n    mapping (address => uint) userCanGet;\r\n\r\n    mapping (address => uint) userLevelCanGet; \r\n\r\n    mapping (address => bool) hasSafe;\r\n\r\n    mapping (address => uint) breakTime;\r\n\r\n    mapping (address => mapping(uint => uint[])) userBuyList1;\r\n    mapping (address => mapping(uint => uint[])) userBuyList2;\r\n    mapping (address => mapping(uint => uint)) userBuyNum;\r\n\r\n    mapping (uint => StoreLog) storeInfo;\r\n\r\n    mapping (address => uint) myScore;\r\n\r\n    mapping (address => uint) teamScore;\r\n\r\n    mapping(uint => uint) levelAmount;\r\n\r\n    uint relaseTime = 0;\r\n \r\n    mapping (address => mapping(uint => uint)) userHasGet;\r\n\r\n    uint[2] randomNum = [382, 1000];\r\n\r\n    address pairAddress = 0xcE53bEdACbD5c221EcB16862E98Fe56c9fa55591;\r\n\r\n    address contract1 = 0x5568E93c30717315A6F02634D52F7fE313bB270E;\r\n\r\n    address leaderAddress = 0x3b911fBd76dA4b01D2ff75B0610d45Ff14182697;\r\n\r\n    address public usdtContract = address(0x55d398326f99059fF775485246999027B3197955);\r\n\r\n    IW3swapRouter02 public router1 = IW3swapRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    address public LevelAddress = address(0x10549D7CB4ff4CC641bc357268bF8890975970b4);\r\n\r\n    levelDo public levelContract = levelDo(LevelAddress);\r\n\r\n    uint _buyId = 0;\r\n\r\n    uint256 public maxLength = 50;\r\n\r\n    uint dayOnce = 82;\r\n\r\n    uint[2] chooseInfo3 = [50, 80];\r\n\r\n    mapping (address => uint) userAcitive;\r\n\r\n    uint staticuserAcitive = 1000e18;\r\n\r\n    mapping (address => uint) useruseActive;\r\n\r\n    mapping (address => uint) usercangActive;\r\n\r\n    mapping (address => uint) usersafeActive;\r\n\r\n    mapping (address => uint) hasBack;\r\n\r\n    mapping (address => uint) bindNum;\r\n\r\n    uint[] maxCoin = [500e18, 800e18, 1300e18, 2100e18, 3400e18, 5500e18, 8900e18, 14400e18, 23300e18];\r\n\r\n    mapping (uint => mapping(uint => uint[])) lastLog;\r\n\r\n    uint safeBack = 100;\r\n\r\n    uint addOnce = 1;\r\n\r\n    struct StoreLog{\r\n        uint _id;\r\n        address myAddress;\r\n        uint amount;\r\n        uint needDay;\r\n        uint belongType;\r\n        uint backPer;\r\n        uint storeAmount;\r\n        uint useAmount;\r\n        uint status;\r\n        uint safeAmount;\r\n        uint storeTime;\r\n        uint belongTimes;\r\n    }\r\n\r\n    struct StoreCell{\r\n        uint amount;\r\n        uint lastLog;\r\n        uint lastPercent;\r\n        uint hasRealse;\r\n        uint canRealse;\r\n    }\r\n\r\n    uint minCoin = 10e18;\r\n\r\n    struct TypeInfo{\r\n        uint amount;\r\n        uint256 nowDay;\r\n        uint256 nowBuy;\r\n        uint256 minCoin;\r\n        uint256 maxCoin;\r\n        uint256 startDay;\r\n        uint256 willBack;\r\n        uint startTime;\r\n        uint dayCanBuy;\r\n        uint8[2] chooseDay;\r\n        uint nowTimes;\r\n        uint nowGroup;\r\n        uint status;\r\n    }\r\n\r\n    event buyOrderEvent(\r\n        address indexed userAddress,\r\n        uint getDays,\r\n        uint percent\r\n    );\r\n\r\n    uint[4] startMin = [13e22, 5e22, 3e22, 0];\r\n\r\n    uint[6] shareAll = [6180, 3000, 300, 240, 150, 130];\r\n\r\n    uint[3] safeNeed = [50, 130, 340];\r\n\r\n    uint timeIncr = 61200;\r\n    // uint timeIncr = 0;\r\n    uint systemDays = 1 days;\r\n    uint needAddTime = 1 hours;\r\n\r\n    uint mustPer = 3820;\r\n    uint otherPer = 6180;\r\n\r\n    modifier onlyLevel() {\r\n        require (_msgSender() == LevelAddress);\r\n        _;\r\n    }\r\n\r\n    mapping (uint => TypeInfo) allRealse;\r\n\r\n    function getLevelCan(address userAddress, uint level) public view returns(uint, uint){\r\n        return (levelAmount[level], userHasGet[userAddress][level]);\r\n    }\r\n\r\n    function getStoreInfo (address searchAddress) public view returns (uint, uint, uint, uint, uint, uint){\r\n        return (storeRelase[searchAddress].amount, storeRelase[searchAddress].lastLog, storeRelase[searchAddress].lastPercent, storeRelase[searchAddress].hasRealse, userStore[searchAddress], storeRelase[searchAddress].canRealse);\r\n    }\r\n\r\n    function getCoinInfo (address searchAddress) public view returns (uint, uint, uint, uint, bool[8] memory, uint){\r\n        return (coinRealse[searchAddress].amount, coinRealse[searchAddress].lastLog, coinRealse[searchAddress].lastPercent, coinRealse[searchAddress].hasRealse, myHasRelase[searchAddress], coinRealse[searchAddress].canRealse);\r\n    }\r\n\r\n    function getUserActive(address userAddress) public view returns(uint, uint, uint, uint, uint, uint){\r\n        return (userAcitive[userAddress], usercangActive[userAddress], staticuserAcitive, useruseActive[userAddress], usersafeActive[userAddress], userCanGet[userAddress]);\r\n    }\r\n\r\n    constructor ()  {\r\n        relaseTime = block.timestamp;\r\n        uint nowDay = relaseTime.div(systemDays);\r\n        allRealse[0] = TypeInfo(0, nowDay, 0, minCoin, maxCoin[0], 3,  0, relaseTime, 0, [3, 5], 1,  0, 0);\r\n        allRealse[1] = TypeInfo(0, nowDay, 0, minCoin, maxCoin[0], 8,  0, relaseTime, 0, [8, 13], 1, 0, 0);\r\n        allRealse[2] = TypeInfo(0, nowDay, 0, minCoin, maxCoin[0], 21, 0, relaseTime, 0, [21, 34], 1,0,0);\r\n        allRealse[3] = TypeInfo(0, nowDay, 0, minCoin, maxCoin[0], 1,  0, relaseTime, 0, [2, 1], 1, 0, 0);\r\n    }\r\n\r\n    function getInfo(uint8 searchType) public view returns(uint, uint, uint, uint, uint, uint, uint, uint){\r\n        TypeInfo memory yourType = allRealse[searchType];\r\n        uint thisAmount = 0;\r\n        if (searchCan && msg.sender == owner()){\r\n            thisAmount = yourType.amount;\r\n        }\r\n        return (yourType.nowBuy, yourType.minCoin, yourType.maxCoin, yourType.dayCanBuy, yourType.status, yourType.nowTimes, yourType.nowGroup, thisAmount);\r\n    }\r\n\r\n    function buyOrder(uint chooseType, bool useStore, uint amount, bool buySafe) public{\r\n        address userAddress = msg.sender;\r\n        uint userneedStore = 0;\r\n        uint needAmount = amount;\r\n        bool canBuyOrder = canBuy(chooseType, amount, userAddress, buySafe);\r\n        require(canBuyOrder, \"c1\");\r\n        uint[2] memory nowBack= getNowBackPer(false, 0, chooseType);\r\n\r\n        if (chooseType == 3){\r\n            require(!hasSafe[userAddress], \"c2\");\r\n            userneedStore = amount.div(10);\r\n            require(userStore[userAddress] >= userneedStore, \"c3\");\r\n            userStore[userAddress] = userStore[userAddress].sub(userneedStore);\r\n            insertLog(1, userAddress, 10, userneedStore, true, userAddress);\r\n\r\n            calStore(chooseType, amount, userAddress, buySafe, userneedStore, needAmount, nowBack);\r\n        } else {\r\n            if (useStore){\r\n                needAmount = calSome.getFee(amount, mustPer);\r\n                userneedStore = amount.sub(needAmount);\r\n                require(userStore[userAddress] >= userneedStore, \"c3\");\r\n                userStore[userAddress] = userStore[userAddress].sub(userneedStore);\r\n                insertLog(1, userAddress, 11, userneedStore, true, userAddress);\r\n            }\r\n\r\n            uint pairAmount = calSome.getFee(amount, shareAll[5]);\r\n            transferToThis(userAddress, needAmount.sub(pairAmount));\r\n\r\n            allRealse[chooseType].nowBuy = allRealse[chooseType].nowBuy.add(amount);\r\n            calStore(chooseType, amount, userAddress, buySafe, userneedStore, needAmount, nowBack);\r\n\r\n            takeShare(chooseType, msg.sender, amount);\r\n            takeAll(chooseType, msg.sender, amount);\r\n               \r\n            sendToPair(pairAmount);\r\n            sendToType(3, calSome.getFee(amount, shareAll[4]));\r\n            sendToType(chooseType, calSome.getFee(amount, shareAll[1]));\r\n            \r\n            levelContract.updateTeamScore(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function calStore(uint chooseType, uint amount, address userAddress, bool buySafe, uint userneedStore, uint needAmount, uint[2] memory nowBack) private {\r\n        uint thisBuyId = ++_buyId;\r\n        uint nowTime = block.timestamp;\r\n        uint times = allRealse[chooseType].nowTimes;\r\n        uint giveAmount = 0;\r\n        \r\n        if (chooseType == 3){\r\n            allRealse[chooseType].nowBuy = allRealse[chooseType].nowBuy.add(amount);\r\n            uint thisGive = calSome.getFee(amount, nowBack[0].mul(nowBack[1]));\r\n            allRealse[chooseType].willBack = allRealse[chooseType].willBack.add(thisGive);\r\n        \r\n            hasSafe[userAddress] = true;\r\n        } else {\r\n            if (buySafe){\r\n                uint needSafeAmount = safeNeed[chooseType];\r\n                giveAmount = calSome.getFee(amount, needSafeAmount);\r\n                transferToThis(userAddress, giveAmount);\r\n                sendToType(3, giveAmount);\r\n            }\r\n        }\r\n\r\n        StoreLog memory yourStore = StoreLog(thisBuyId, userAddress, amount, nowBack[0], chooseType, nowBack[1], userneedStore, needAmount, 0, giveAmount, nowTime, times);\r\n        storeInfo[thisBuyId] = yourStore;\r\n        userBuyList1[userAddress][chooseType].push(thisBuyId);\r\n\r\n        userBuyNum[userAddress][chooseType] = userBuyNum[userAddress][chooseType].add(1);\r\n\r\n        emit buyOrderEvent(userAddress, nowBack[0], nowBack[1]);\r\n    }\r\n\r\n    function transferToThis(address userAddress, uint amount) private{\r\n        require(IERC20(usdtContract).transferFrom(userAddress, address(this), amount) == true, \"c4\");\r\n    }\r\n    \r\n    uint[] needIncr = [0, 51, 51];\r\n    uint[] indexNum = [51, 102, 123];\r\n    uint[] indexPer = [50, 80, 80];\r\n\r\n    function getFirst(uint nowDay, uint _addOnce) private view returns (uint){\r\n        uint leftDay = nowDay.mod(dayOnce);\r\n        uint backPer = 50;\r\n        for (uint i=0 ; i< indexNum.length; i++){\r\n            if (leftDay < indexNum[i]){\r\n                uint needAdd = leftDay.sub(needIncr[i]);\r\n                backPer = indexPer[i].add(_addOnce.mul(needAdd));\r\n                break;\r\n            } else {\r\n                leftDay = leftDay.sub(needIncr[i]);\r\n            }\r\n        }\r\n        return backPer;\r\n    }\r\n    \r\n    function takeShare(uint chooseType, address shareAddress, uint amount) private{\r\n        address parentAddress = levelContract.getParent(shareAddress);\r\n        uint leftAmount = 240;\r\n        uint cengBack = 20;\r\n        uint nowI = 1;\r\n        uint reBack = 0;\r\n        for (uint i=0; i < maxLength; i++){\r\n            if (leftAmount == 0 || parentAddress == address(0)){\r\n                break;\r\n            }\r\n            uint level = levelContract.getUserTrueLevel(parentAddress);\r\n            if (level >= 6 || (level >= 5 && nowI<= 7) || (level >= 4 && nowI<= 6) || (level >= 3 && nowI<= 5) || (level >= 2 && nowI<= 4) || (level >= 1 && nowI<= 3)){\r\n                uint getAmount = calSome.getFee(amount, cengBack);\r\n\r\n                uint addback = giveActive(getAmount, parentAddress, 201, shareAddress);\r\n                reBack = reBack.add(addback);\r\n                nowI = nowI.add(1);\r\n                leftAmount = leftAmount.sub(cengBack);\r\n            }\r\n            parentAddress = levelContract.getParent(parentAddress);\r\n        }\r\n        if (leftAmount > 0 || reBack > 0){\r\n            sendToType(chooseType, calSome.getFee(amount, leftAmount).add(reBack));\r\n        }\r\n    }\r\n\r\n    function takeAll(uint chooseType, address shareAddress, uint amount) private{\r\n        uint lastBack = 0;\r\n        uint reBack = 0;\r\n        uint lingAll = 300;\r\n        address parentAddress = levelContract.getParent(shareAddress);\r\n        \r\n        for (uint i=0; i < maxLength; i++){\r\n            if (lastBack >= lingAll || parentAddress == address(0)){\r\n                break;\r\n            }\r\n            uint level = levelContract.getUserLevel(parentAddress);\r\n            if (level > 0){\r\n                uint backYour = levelContract.getLevelBack(level);\r\n                if (backYour > lastBack){\r\n                    uint getAmount = calSome.getFee(amount, backYour.sub(lastBack));\r\n                    lastBack = backYour;\r\n                    uint addback = giveActive(getAmount, parentAddress, 202, shareAddress);\r\n                    reBack = reBack.add(addback);\r\n                }\r\n            }\r\n            parentAddress = levelContract.getParent(parentAddress);\r\n        }\r\n        if (lastBack < lingAll || reBack > 0){\r\n            sendToType(chooseType, calSome.getFee(amount, lingAll.sub(lastBack)).add(reBack));\r\n        }\r\n    }\r\n\r\n    function giveActive(uint getAmount, address userAddress, uint backType, address shareAddress) private returns (uint reback){\r\n        uint userActivitNumber = userAcitive[userAddress].add(staticuserAcitive);\r\n        uint useruseActiveNumber = useruseActive[userAddress];\r\n        require (useruseActiveNumber < userActivitNumber, \"c\");\r\n        if (useruseActiveNumber.add(getAmount) >= userActivitNumber){\r\n            uint reBackAmount = userActivitNumber.sub(useruseActiveNumber);\r\n            reback = getAmount.sub(reBackAmount);\r\n            getAmount = reBackAmount;\r\n        }\r\n\r\n        insertLog(2, userAddress, backType, getAmount, true, shareAddress);\r\n        userCanGet[userAddress] = userCanGet[userAddress].add(getAmount);\r\n        useruseActive[userAddress] = useruseActive[userAddress].add(getAmount);\r\n    }\r\n\r\n    function getTrueDay(uint nowTime,uint endTime,uint needDay) private view returns(uint){\r\n        (,uint afterDay) = getSubTime(nowTime, endTime);\r\n        return needDay > afterDay? needDay.sub(afterDay): 0;\r\n    }\r\n\r\n    function rebackOrder(uint orderId, bool chooseCoin) public {\r\n        StoreLog memory store = storeInfo[orderId];\r\n        address userAddress = msg.sender;\r\n        require(userAddress == store.myAddress, \"c5\");\r\n        uint needDay = store.storeTime.add(store.needDay.mul(systemDays));\r\n        uint nowTime = block.timestamp;\r\n        uint belongType = store.belongType;\r\n        uint nowTimes = allRealse[belongType].nowTimes;\r\n\r\n        require(nowTime >= needDay && store.status == 0, \"c6\");\r\n        uint trueDay = getTrueDay(nowTime, needDay, store.needDay);\r\n        storeInfo[orderId].status = 1;\r\n\r\n        if (belongType == 3){\r\n            uint backAmount = calSome.getFee(store.amount, store.backPer.mul(store.needDay));\r\n            allRealse[belongType].willBack = allRealse[belongType].willBack.sub(backAmount);\r\n            hasBack[userAddress] = hasBack[userAddress].add(backAmount);\r\n            hasSafe[userAddress] = false;\r\n            if (chooseCoin){\r\n                addFunction(true, 1, userAddress, backAmount);\r\n                addFunction(false, 1, userAddress, backAmount.mul(5));\r\n                allRealse[belongType].amount = allRealse[belongType].amount.sub(calSome.getFee(backAmount, mustPer));\r\n                cSendToPair(backAmount);\r\n            } else {\r\n                allRealse[belongType].amount = allRealse[belongType].amount.sub(backAmount);\r\n                transferFromContract(101, backAmount, userAddress);\r\n            }\r\n        } else {\r\n            if (nowTimes > store.belongTimes) {\r\n                if (belongType != 3){\r\n                    uint storeAmount = store.storeAmount;\r\n                    breakTime[userAddress] = breakTime[userAddress].add(1);\r\n                    if (storeAmount == 0){\r\n                        uint trueAmount = calSome.getFee(store.amount, otherPer);\r\n                        transferFromContract(102, trueAmount, userAddress);\r\n                        if (store.safeAmount > 0){\r\n                            usercangActive[userAddress] = usercangActive[userAddress].add(store.amount);\r\n                            usersafeActive[userAddress] = usersafeActive[userAddress].add(store.safeAmount);\r\n                        }\r\n                    }\r\n                    addFunction(false, 4, userAddress, store.amount.mul(5));\r\n                }\r\n            } else {\r\n                bool hasBreak = false;\r\n                if (belongType != 3){\r\n                    uint useAmount = store.useAmount;\r\n                    if (store.storeAmount > 0){\r\n                        if (allRealse[belongType].amount <= useAmount){\r\n                            hasBreak = true;\r\n                            checkBack(useAmount, allRealse[belongType].amount, userAddress, store.safeAmount);\r\n                            addFunction(false, 4, userAddress, store.amount.mul(5));\r\n                            breakType(belongType);\r\n                        } else {\r\n                            allRealse[belongType].amount = allRealse[belongType].amount.sub(useAmount);\r\n                            transferFromContract(102, useAmount, userAddress);\r\n                        }\r\n                    } else {\r\n                        uint trueAmount = calSome.getFee(store.amount, mustPer);\r\n                        if (allRealse[belongType].amount <= trueAmount){\r\n                            hasBreak = true;\r\n                            checkBack(trueAmount, allRealse[belongType].amount, userAddress, store.safeAmount);\r\n                            transferFromContract(102, calSome.getFee(store.amount, otherPer), userAddress);\r\n\r\n                            addFunction(false, 4, userAddress, store.amount.mul(5));\r\n                            breakType(belongType);\r\n                        } else {\r\n                            allRealse[belongType].amount = allRealse[belongType].amount.sub(trueAmount);\r\n                            transferFromContract(102, useAmount, userAddress);\r\n                        }\r\n                    }\r\n                }\r\n                uint backAmount = calSome.getFee(store.amount, store.backPer.mul(trueDay));\r\n                if (!hasBreak){\r\n                    if (chooseCoin){\r\n                        addFunction(true, 1, userAddress, backAmount);\r\n                        addFunction(false, 1, userAddress, backAmount.mul(5));\r\n                        allRealse[belongType].amount = allRealse[belongType].amount.sub(calSome.getFee(backAmount, mustPer));\r\n                        cSendToPair(backAmount);\r\n                    } else {\r\n                        if (allRealse[belongType].amount <= backAmount){\r\n                            transferFromContract(103, allRealse[belongType].amount, userAddress);\r\n                            breakType(belongType);\r\n                        } else {\r\n                            allRealse[belongType].amount = allRealse[belongType].amount.sub(backAmount);\r\n                            transferFromContract(103, backAmount, userAddress);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        userBuyList2[userAddress][belongType].push(orderId);\r\n        deleteOne(userAddress, orderId, belongType);\r\n    }\r\n\r\n    function deleteOne(address searchAddress, uint orderId, uint chooseType) private {\r\n        uint length = userBuyList1[searchAddress][chooseType].length;\r\n        for(uint i = 0; i < length; i++){\r\n            if (userBuyList1[searchAddress][chooseType][i] == orderId){\r\n                delete userBuyList1[searchAddress][chooseType][i];\r\n                userBuyNum[searchAddress][chooseType] = userBuyNum[searchAddress][chooseType].sub(1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getSubTime(uint nowTime, uint logTime) private view returns(uint, uint){\r\n        uint nowDay = nowTime.div(systemDays);\r\n        uint logDay = logTime.div(systemDays);\r\n        if (nowDay <= logDay){\r\n            return (nowDay, 0);\r\n        } else {\r\n            return (nowDay, nowDay.sub(logDay));\r\n        }\r\n    }\r\n\r\n    function getMyRealse(bool coin) public view returns (uint, uint, uint){\r\n        StoreCell memory myStore = coinRealse[msg.sender];\r\n        if (!coin){\r\n            myStore = storeRelase[msg.sender];\r\n        }\r\n        uint amount = myStore.amount;\r\n\r\n        uint nowTime = block.timestamp;\r\n        uint logTime = myStore.lastLog;\r\n        (,uint changeDay2) = getSubTime(nowTime, logTime);\r\n        uint lastPercent = myStore.lastPercent;\r\n        uint backPer = calSome.getBackPer(coinMin, coinMax, lastPercent, coinAddOnce, changeDay2);\r\n        uint addBack = calSome.getFee(amount, backPer);\r\n\r\n        uint backAmount = addBack.add(myStore.canRealse);\r\n        if (backAmount > 0){\r\n            if (backAmount >= amount){\r\n                backAmount = amount;\r\n            }\r\n        }\r\n        uint backCoin = 0;\r\n        if (coin){\r\n            uint giveRelease = getTokenPrice(1e18)[1];\r\n            backCoin = backAmount.mul(1e18).div(giveRelease);\r\n        }\r\n        return (backAmount, addBack, backCoin);\r\n    }\r\n\r\n    function getCoin(bool coin) public {\r\n        uint nowTime = block.timestamp;\r\n        (uint backAmount, uint addBack, uint backCoin) = getMyRealse(coin);\r\n        uint nowBack = getCoinBack();\r\n\r\n        if (backAmount > 0){\r\n            if (!coin){\r\n                storeRelase[msg.sender].canRealse = 0;\r\n                storeRelase[msg.sender].amount = storeRelase[msg.sender].amount.sub(addBack);\r\n                storeRelase[msg.sender].lastPercent = nowBack;\r\n                storeRelase[msg.sender].lastLog = nowTime;\r\n                storeRelase[msg.sender].hasRealse = storeRelase[msg.sender].hasRealse.add(backAmount);\r\n                userStore[msg.sender] = userStore[msg.sender].add(backAmount);\r\n            } else {\r\n                coinRealse[msg.sender].canRealse = 0;\r\n                coinRealse[msg.sender].amount = coinRealse[msg.sender].amount.sub(addBack);\r\n                coinRealse[msg.sender].lastPercent = nowBack;\r\n                coinRealse[msg.sender].lastLog = nowTime;\r\n                coinRealse[msg.sender].hasRealse = coinRealse[msg.sender].hasRealse.add(backAmount);\r\n                tranferCoin(backCoin, msg.sender);\r\n            }\r\n            insertLog(coin?0:1, msg.sender, 7, backAmount, true, msg.sender);\r\n        }\r\n    }\r\n\r\n    function checkBack(uint amount, uint leftAmount, address yourAddress, uint safeAmount) private{\r\n        if (amount >= leftAmount){\r\n            uint breakAmount = amount.sub(leftAmount);\r\n            breakTime[yourAddress] = breakTime[yourAddress].add(1);\r\n            transferFromContract(102, leftAmount, yourAddress);\r\n            if (safeAmount > 0){\r\n                usercangActive[yourAddress] = usercangActive[yourAddress].add(breakAmount.mul(10000).div(mustPer));\r\n                usersafeActive[msg.sender] = usersafeActive[msg.sender].add(safeAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function breakType(uint belongType) private {\r\n        allRealse[belongType].status = 1;\r\n        allRealse[belongType].amount = 0;\r\n    }\r\n\r\n    function buyAcitve(uint amount) public {\r\n        uint leftAmount = 100;\r\n        for (uint i = 6; i <= 10; i++){\r\n            uint thisNum = levelContract.getLevelNum(i);\r\n            if (thisNum > 0){\r\n                leftAmount = leftAmount.sub(10);\r\n                levelAmount[i] = levelAmount[i].add(amount.div(10).div(thisNum));\r\n            }\r\n        }\r\n        require(IERC20(usdtContract).transferFrom(msg.sender, address(leaderAddress), amount.mul(leftAmount).div(100)) == true, \"c4\");\r\n\r\n        uint yourLevel = levelContract.getUserLevel(msg.sender);\r\n        \r\n        uint getS = amount.mul(levelContract.getLevelPer(yourLevel));\r\n        userAcitive[msg.sender] = userAcitive[msg.sender].add(getS);\r\n        addFunction(false, 6, msg.sender, amount.mul(5));\r\n    }\r\n\r\n    function resetType(uint chooseType) private {\r\n        allRealse[chooseType].startTime = block.timestamp;\r\n        allRealse[chooseType].nowTimes = allRealse[chooseType].nowTimes.add(1);\r\n        allRealse[chooseType].status = 0;\r\n        allRealse[chooseType].maxCoin = maxCoin[0];\r\n    }\r\n\r\n    function canBuy(uint chooseType, uint amount, address userAddress, bool buySafe) private returns (bool){\r\n        TypeInfo memory chooseInfo = allRealse[chooseType];\r\n        (uint nowDay,) = getDayCal(chooseInfo.startTime, block.timestamp);\r\n        uint thisDay = chooseInfo.nowDay;\r\n        uint dayBuy = chooseInfo.nowBuy;\r\n        uint dayCanBuy = chooseInfo.dayCanBuy;\r\n\r\n        require(block.timestamp >= 1688806800 && amount >= chooseInfo.minCoin && amount <= chooseInfo.maxCoin, \"c7\");\r\n        //require(amount >= chooseInfo.minCoin && amount <= chooseInfo.maxCoin, \"c7\");\r\n\r\n        if (chooseType == 3){\r\n            require(amount <= usercangActive[userAddress].sub(hasBack[userAddress]), \"c8\");\r\n            uint feeAmount = calSome.getFee(usercangActive[userAddress], mustPer);\r\n            uint canback = feeAmount.add(usersafeActive[userAddress]);\r\n\r\n            if (nowDay > thisDay || chooseInfo.dayCanBuy == 0){\r\n                dayBuy = 0;\r\n                allRealse[chooseType].nowDay = nowDay;\r\n                allRealse[chooseType].nowBuy = 0;\r\n                dayCanBuy = calSome.getFee(chooseInfo.amount, mustPer);\r\n            }\r\n            require (canback > hasBack[userAddress], \"c9\");\r\n            uint maxGet = getMax(amount, chooseInfo.chooseDay[0]);\r\n            require (chooseInfo.willBack.add(maxGet) <= dayCanBuy, \"c1\");\r\n            return true;\r\n        } else {\r\n            require (allRealse[chooseType].status != 1 || nowDay > thisDay, \"c10\");\r\n\r\n            if (nowDay > thisDay || chooseInfo.dayCanBuy == 0){\r\n                uint lastNum = 0;\r\n                bool newS = false;\r\n                if (chooseInfo.status == 1){\r\n                    resetType(chooseType);\r\n                    newS = true;\r\n                    chooseInfo.nowGroup = 0;\r\n                    chooseInfo.nowTimes = chooseInfo.nowTimes.add(1);\r\n                }\r\n                \r\n                allRealse[chooseType].nowGroup = chooseInfo.nowGroup.add(1);\r\n                dayCanBuy = getDaysBack(chooseInfo.nowGroup, chooseType);\r\n\r\n                lastLog[chooseType][chooseInfo.nowTimes].push(dayCanBuy);\r\n\r\n                if (chooseInfo.dayCanBuy > chooseInfo.nowBuy && !newS){\r\n                    lastNum = chooseInfo.dayCanBuy.sub(chooseInfo.nowBuy);\r\n                }\r\n                allRealse[chooseType].dayCanBuy = dayCanBuy.add(lastNum);\r\n                dayBuy = 0;\r\n                allRealse[chooseType].nowDay = nowDay;\r\n                allRealse[chooseType].nowBuy = 0;\r\n            }\r\n\r\n            uint month = chooseInfo.nowGroup.div(30);\r\n            if (month >= maxCoin.length) {\r\n                allRealse[chooseType].maxCoin = maxCoin[maxCoin.length.sub(1)];\r\n            } else {\r\n                allRealse[chooseType].maxCoin = maxCoin[month];\r\n            }\r\n\r\n            require (buySafe || nowDay.mul(systemDays).add(timeIncr).add(needAddTime) < block.timestamp, \"c11\");\r\n\r\n            return dayBuy.add(amount) <= dayCanBuy;\r\n        }\r\n    }\r\n\r\n    function getMax(uint amount, uint maxBack) private view returns (uint maxGet){\r\n        maxGet = calSome.getFee(amount, safeBack.mul(maxBack));\r\n    }\r\n\r\n    function getNowBackPer(bool giveDay, uint chooseDay, uint chooseType) private view returns (uint[2] memory ){\r\n        TypeInfo memory chooseInfo = allRealse[chooseType];\r\n        uint backDay = chooseInfo.chooseDay[0];\r\n        uint randomM = calSome.rand(randomNum[1]);\r\n        if (randomM > randomNum[0]){\r\n            backDay = chooseInfo.chooseDay[1];\r\n        }\r\n        uint backPer = 50;\r\n        if (chooseType == 3){\r\n            backPer = safeBack;\r\n        } else {\r\n            uint calDays = 0;\r\n            if (giveDay){\r\n                calDays = chooseDay;\r\n            } else {\r\n                calDays = chooseInfo.nowGroup.sub(1);\r\n            }\r\n            if (chooseType == 1 || chooseType == 0){\r\n                backPer = getFirst(calDays, addOnce);\r\n            } else {\r\n                backPer = calSome.getTruePer(chooseInfo3[0], chooseInfo3[1], chooseInfo3[0], addOnce, calDays);\r\n            }\r\n        }\r\n        return [backDay, backPer];\r\n    }\r\n\r\n\r\n    function getCoinBack() private view returns(uint){\r\n        uint nowTime = block.timestamp;\r\n        (,uint changeDay) = getSubTime(nowTime, relaseTime);\r\n        uint backPer = calSome.getTruePer(coinMin, coinMax, coinMin, coinAddOnce, changeDay);\r\n        return backPer;\r\n    }\r\n\r\n    function addFunction(bool coin, uint addType, address addAddress, uint addAmount) private {\r\n        StoreCell memory myStore = coinRealse[addAddress];\r\n        if (!coin){\r\n            myStore = storeRelase[addAddress];\r\n        }\r\n\r\n        uint amount = myStore.amount;\r\n        uint nowTime = block.timestamp;\r\n        uint nowPer = getCoinBack();\r\n        if (amount > 0){\r\n            uint logTime = myStore.lastLog;\r\n            (,uint changeDay) = getSubTime(nowTime, logTime);\r\n            uint lastPercent = myStore.lastPercent;\r\n\r\n            uint nowBack = nowPer;\r\n            uint backPer = calSome.getBackPer(coinMin, coinMax, lastPercent, coinAddOnce, changeDay);\r\n            uint addBack = calSome.getFee(amount, backPer);\r\n\r\n            if (addBack.add(myStore.canRealse) >= amount){\r\n                myStore.canRealse = amount;\r\n            } else {\r\n                myStore.canRealse = myStore.canRealse.add(addBack);\r\n            }\r\n            myStore.amount = myStore.amount.sub(addBack).add(addAmount);\r\n            myStore.lastPercent = nowBack;\r\n        } else {\r\n            myStore.amount = addAmount;\r\n            myStore.lastPercent = nowPer;\r\n        }\r\n        myStore.lastLog = nowTime;\r\n        \r\n        if (coin){\r\n            coinRealse[addAddress] = myStore;\r\n        } else {\r\n            storeRelase[addAddress] = myStore;\r\n        }\r\n        insertLog(coin?0:1, addAddress, addType, addAmount, false, addAddress);\r\n    }\r\n\r\n    struct AddCell {\r\n        uint id;\r\n        uint doType;\r\n        uint changeAmount;\r\n        bool incr;\r\n        address fromAddress;\r\n        uint logTime;\r\n    }\r\n\r\n    mapping(address => AddCell[]) StoreChangeLog;\r\n    mapping(address => AddCell[]) CoinChangeLog;\r\n    mapping(address => AddCell[]) activeChangeLog;\r\n\r\n    function insertLog(uint coin, address userAddress, uint doType, uint amount, bool incr, address fromAddress) private{\r\n        uint orderId = ++_buyId;\r\n        if (coin == 0){\r\n            CoinChangeLog[userAddress].push(AddCell(orderId, doType, amount, incr, fromAddress, block.timestamp));\r\n        } else if (coin == 1){\r\n            StoreChangeLog[userAddress].push(AddCell(orderId, doType, amount, incr, fromAddress, block.timestamp));\r\n        } else if (coin == 2){\r\n            activeChangeLog[userAddress].push(AddCell(orderId, doType, amount, incr, fromAddress, block.timestamp));\r\n        }\r\n    }\r\n\r\n    function getAllLog(uint searchType, address _myAddress, uint page) public view returns(uint length, uint[] memory _idReturn, uint[] memory _doTypeReturn, uint[] memory _amountReturn, bool[] memory _incrReturn, address[] memory _addressReturn, uint[] memory _logTimeReturn){\r\n        AddCell[] memory myOrderList = StoreChangeLog[_myAddress];\r\n        if (searchType == 1) {\r\n            myOrderList = CoinChangeLog[_myAddress];\r\n        } else if (searchType == 2) {\r\n            myOrderList = activeChangeLog[_myAddress];\r\n        }\r\n        length = myOrderList.length;\r\n        uint pageIndex = page.sub(1).mul(10);\r\n\r\n        uint calLength = length>0?length.sub(1): 0;\r\n        uint resultLength = getPageLength(pageIndex, length);\r\n\r\n        _idReturn = new uint[](resultLength);\r\n        _logTimeReturn  = new uint[](resultLength);\r\n        _doTypeReturn = new uint[](resultLength);\r\n        _amountReturn = new uint[](resultLength);\r\n        _incrReturn = new bool[](resultLength);\r\n        _addressReturn = new address[](resultLength);\r\n\r\n        for (uint i = 0; i < resultLength; i ++) {\r\n            uint index = i.add(pageIndex);\r\n            if (index < length) {\r\n                AddCell memory obj = myOrderList[calLength.sub(index)];\r\n                _idReturn[i] = obj.id;\r\n                _logTimeReturn[i] = obj.logTime;\r\n                _doTypeReturn[i] = obj.doType;\r\n                _amountReturn[i] = obj.changeAmount;\r\n                _incrReturn[i] = obj.incr;\r\n                _addressReturn[i] = obj.fromAddress;\r\n            }\r\n        }\r\n    }\r\n\r\n    function drawActive(uint chooseType) public{\r\n        address userAddress = msg.sender;\r\n        uint backAmount = userCanGet[userAddress];\r\n\r\n        require(backAmount > 0, \"c17\");\r\n        userCanGet[userAddress] = 0;\r\n        choose(103, chooseType, userAddress, backAmount);\r\n    }\r\n\r\n    function choose(uint doType, uint chooseType, address userAddress,uint backAmount) private {\r\n        if (chooseType == 1){\r\n            addFunction(true, 2, userAddress, backAmount);\r\n            addFunction(false, 2, userAddress, backAmount.mul(5));\r\n            allRealse[3].amount = allRealse[3].amount.add(calSome.getFee(backAmount, otherPer));\r\n            cSendToPair(backAmount);\r\n        } else {\r\n            transferFromContract(doType, backAmount, userAddress);\r\n        }\r\n    }\r\n\r\n    function cSendToPair(uint amount) private {\r\n        IERC20(usdtContract).transfer(pairAddress, calSome.getFee(amount, mustPer));\r\n        IPancakePair(pairAddress).sync();\r\n    }\r\n\r\n    function drawLevel(uint chooseType) public{\r\n        address userAddress = msg.sender;\r\n        (uint backAmount, uint yourLevel, uint levelGive) = getMyCan(userAddress);\r\n        require(yourLevel > 5, \"c17\");\r\n        userHasGet[userAddress][yourLevel] = levelGive;\r\n        uint userActivitNumber = userAcitive[userAddress].add(staticuserAcitive);\r\n        uint useruseActiveNumber = useruseActive[userAddress];\r\n\r\n        require(backAmount > 0, \"not have active\");\r\n        require (useruseActiveNumber.add(backAmount) <= userActivitNumber, \"c16\");\r\n\r\n        useruseActive[userAddress] = useruseActive[userAddress].add(backAmount);\r\n        userLevelCanGet[userAddress] = 0;\r\n\r\n        choose(104, chooseType, userAddress, backAmount);\r\n    }\r\n\r\n    function getMyCan(address userAddress) public view returns (uint, uint, uint){\r\n        uint backAmount = userLevelCanGet[userAddress];\r\n        uint yourLevel = levelContract.getUserTrueLevel(userAddress);\r\n        \r\n        uint levelHas = userHasGet[userAddress][yourLevel];\r\n        uint levelGive = levelAmount[yourLevel];\r\n        backAmount = backAmount.add(levelGive.sub(levelHas));\r\n       return (backAmount, yourLevel, levelGive);\r\n    }\r\n\r\n    uint[8] rPer = [2, 3, 5, 8, 13, 21, 34, 14];\r\n    mapping(address => bool[8]) myHasRelase; \r\n\r\n    function releaseSome(address userAddress, uint beforeLevel, uint level) public onlyLevel{\r\n        if (level < 9 && level > 0){\r\n            uint Relase = rPer[level.sub(1)];\r\n            uint hasGive = levelContract.getHaveBuy(userAddress);\r\n            if (hasGive > 0){\r\n                uint giveRelease = getTokenPrice(1e18)[1];\r\n                bool[8] memory myRealse = myHasRelase[userAddress];\r\n                for (uint i=1; i<level; i++){\r\n                    uint one = i.sub(1);\r\n                    if (!myRealse[one]){\r\n                        Relase = Relase.add(rPer[one]);\r\n                        myHasRelase[userAddress][one] = true;\r\n                    }\r\n                }\r\n\r\n                uint backCoin = hasGive.mul(1e18).div(giveRelease).mul(Relase).div(100);\r\n                tranferCoin(backCoin, userAddress);\r\n                insertLog(0, userAddress, 8, backCoin, false, userAddress);\r\n            }\r\n        }\r\n\r\n        beforeUpdate(userAddress, beforeLevel, level);\r\n    }\r\n\r\n    function sendStore(uint amount, address senderAddress) public {\r\n        require(userStore[msg.sender] >= amount, \"c4\");\r\n        userStore[msg.sender] = userStore[msg.sender].sub(amount);\r\n        userStore[senderAddress] = userStore[senderAddress].add(amount);\r\n        insertLog(1, msg.sender, 9, amount, true, senderAddress);\r\n        insertLog(1, senderAddress, 9, amount, false, msg.sender);\r\n    }\r\n\r\n    function beforeUpdate(address yourAddress, uint beforeLevel, uint afterLevel) private {\r\n        if (beforeLevel > 0){\r\n            uint levelGive = levelAmount[beforeLevel];\r\n            uint hasGet = userHasGet[yourAddress][beforeLevel];\r\n            if (levelGive >= hasGet){\r\n                userLevelCanGet[yourAddress] = userLevelCanGet[yourAddress].add(levelGive.sub(hasGet));\r\n            }\r\n        }\r\n        userHasGet[yourAddress][afterLevel] = levelAmount[afterLevel];\r\n    }\r\n\r\n    bool searchCan = false;\r\n\r\n    function transferFromContract(uint doType, uint amount, address myAddress) private {\r\n        if (amount > 0){\r\n            insertLog(0, myAddress, doType, amount, false, myAddress);\r\n            IERC20(usdtContract).transfer(myAddress, amount);\r\n        }\r\n    }\r\n\r\n    function tranferCoin(uint amount, address myAddress) private {\r\n        if (amount > 0){\r\n            IERC20(contract1).transfer(myAddress, amount);\r\n        }\r\n    }\r\n\r\n    function getPageLength(uint pageIndex, uint length) private pure returns (uint){\r\n        uint resultLength = 10;\r\n        if (pageIndex.add(10) > length){\r\n            resultLength = length.sub(pageIndex);\r\n        }\r\n        return resultLength;\r\n    }\r\n\r\n    function getTrueList(uint page, uint chooseType, address _myAddress) private view returns(uint[] memory trueIdList, uint endLength, uint backlength){\r\n        uint[] memory myOrderList = userBuyList1[_myAddress][chooseType.div(10)];\r\n        if (chooseType.mod(10) == 1){\r\n            myOrderList = userBuyList2[_myAddress][chooseType.div(10)];\r\n        }\r\n        uint length = myOrderList.length;\r\n\r\n        uint pageIndex = page.sub(1).mul(10);\r\n        uint resultLength = getPageLength(pageIndex,length);\r\n        trueIdList = new uint[](resultLength);\r\n\r\n        uint calLength = length>0?length.sub(1): 0;\r\n        for (uint i = 0; i < resultLength; ) {\r\n            uint index = i.add(pageIndex);\r\n            if (index < length) {\r\n                uint orderId = myOrderList[calLength.sub(index)];\r\n                if (orderId > 0){\r\n                    trueIdList[i] = orderId;\r\n                    i = i.add(1);\r\n                    endLength = i;\r\n                } else {\r\n                    pageIndex = pageIndex.add(1);\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        if (chooseType.mod(10) == 0){\r\n            backlength = userBuyNum[_myAddress][chooseType.div(10)];\r\n        } else {\r\n            backlength = length;\r\n        }\r\n    }\r\n\r\n    function getMyOrderList(address _myAddress, uint page, uint chooseType) public view returns (uint length, uint[] memory _idReturn, uint[] memory _amountReturn, uint[] memory _needDayReturn, uint[] memory _belongTypeReturn, uint[] memory _backPerReturn, uint[] memory _statusReturn, uint[] memory _storeTimeReturn){\r\n       uint[] memory trueIdList;\r\n       uint endLength;\r\n        (trueIdList, endLength, length) = getTrueList(page, chooseType, _myAddress);\r\n\r\n        _idReturn = new uint[](endLength);\r\n        _amountReturn = new uint[](endLength);\r\n        _needDayReturn = new uint[](endLength);\r\n        _belongTypeReturn = new uint[](endLength);\r\n        _backPerReturn = new uint[](endLength);\r\n        _statusReturn = new uint[](endLength);\r\n        _storeTimeReturn = new uint[](endLength);\r\n        for (uint i = 0; i < endLength; i++) {\r\n                StoreLog memory obj = storeInfo[trueIdList[i]];\r\n                _idReturn[i] = trueIdList[i];\r\n                _amountReturn[i] = obj.amount;\r\n                _needDayReturn[i] = obj.needDay;\r\n                _belongTypeReturn[i] = obj.belongType;\r\n                _backPerReturn[i] = obj.backPer;\r\n                _statusReturn[i] = obj.status == 0? (obj.belongTimes < allRealse[obj.belongType].nowTimes? 2:0): 1;\r\n                _storeTimeReturn[i] = obj.storeTime;\r\n        }\r\n    }\r\n\r\n    function getDayCal(uint startTime, uint calTime) private view returns (uint nowDay, uint changeDay) {\r\n        uint startTimeTr = startTime.sub(timeIncr);\r\n        uint calTimeTr = calTime.sub(timeIncr);\r\n        (nowDay, changeDay) = getSubTime(calTimeTr, startTimeTr);\r\n    }\r\n\r\n    function getDaysBack(uint selectDays, uint chooseType) public view returns (uint){\r\n        TypeInfo memory chooseInfo = allRealse[chooseType];\r\n        uint calDay = chooseInfo.startDay;\r\n        uint8[2] memory daysMin = chooseInfo.chooseDay;\r\n        uint[] memory oneList = lastLog[chooseType][chooseInfo.nowTimes];\r\n        uint length = oneList.length;\r\n\r\n        if (selectDays < calDay) {\r\n            return startMin[chooseType];\r\n        } else {\r\n            if (selectDays < length){\r\n                return oneList[selectDays];\r\n            } else if (selectDays > length){\r\n                return startMin[chooseType];\r\n            }\r\n\r\n            uint day3 = 0;\r\n            uint day5 = 0;\r\n\r\n            if (selectDays >= daysMin[0]){\r\n                uint[2] memory dayBack = getNowBackPer(true, selectDays.sub(daysMin[0]), chooseType);\r\n                day3 = calSome.getFee(oneList[selectDays.sub(daysMin[0])], daysMin[0].mul(dayBack[1]).add(820));\r\n            }\r\n\r\n            if (selectDays >= daysMin[1]){\r\n                uint[2] memory  dayBack = getNowBackPer(true, selectDays.sub(daysMin[1]), chooseType);\r\n                day5 = calSome.getFee(oneList[selectDays.sub(daysMin[1])], daysMin[1].mul(dayBack[1]).add(820));\r\n            }\r\n            return day3.add(day5).div(2).add(startMin[chooseType]);\r\n        }\r\n    }\r\n\r\n    function getTokenPrice(uint total) public view returns (uint[] memory amount1){\r\n        address[] memory path = new address[](2);\r\n\t    path[0] = contract1;\r\n\t    path[1] = usdtContract;\r\n        amount1 = router1.getAmountsOut(total,path);\r\n        return amount1;\r\n    }\r\n\r\n    function SellNeed (address userAddress, uint amount) public {\r\n        require(msg.sender == contract1, \"c15\");\r\n        uint coinAmount = amount.div(5);\r\n        uint shareAmount = coinAmount.div(2);\r\n       \r\n        addFunction(true, 5, userAddress, coinAmount);\r\n        uint getOne = shareAmount.div(10);\r\n        for (uint i=6; i <= 10; i++){\r\n            uint levelNum = levelContract.getLevelNum(i);\r\n            if (levelNum > 0){\r\n                levelAmount[i] = levelAmount[i].add(getOne.div(levelNum));\r\n            }\r\n        }\r\n    }\r\n\r\n    function getLevelAmount(uint level) public view returns (uint){\r\n        return levelAmount[level];\r\n    }\r\n\r\n    function getErc20With(address con, address addr, uint256 amount) public onlyOwner {\r\n        IERC20(con).transfer(addr, amount);\r\n    }\r\n\r\n    function getCalArk(address userAddress) public view returns (uint, uint){\r\n        (,uint changeDay) = getSubTime(block.timestamp, relaseTime);\r\n        return (breakTime[userAddress], changeDay);\r\n    }\r\n\r\n    function sendToPair(uint amount) private{\r\n        require(IERC20(usdtContract).transferFrom(msg.sender, pairAddress, amount) == true, \"c4\");\r\n        IPancakePair(pairAddress).sync();\r\n    }\r\n\r\n    function sendToType(uint typeId, uint amount) private{\r\n        allRealse[typeId].amount = allRealse[typeId].amount.add(amount);\r\n    }\r\n\r\n    function sendToTypeEx(uint typeId, uint amount) public onlyLevel{\r\n        allRealse[typeId].amount = allRealse[typeId].amount.add(amount);\r\n    }\r\n\r\n    function setContract1(address _setLeader, address _contract1, address _pairAddress, uint _timeIncr, bool _searchCan) public onlyOwner{\r\n        contract1 = _contract1;\r\n        leaderAddress = _setLeader;\r\n        pairAddress = _pairAddress;\r\n        timeIncr = _timeIncr;\r\n        searchCan = _searchCan;\r\n    }\r\n\r\n    function addStore(uint addType, address addAddress, uint addAmount) public onlyLevel {\r\n        StoreCell memory myStore = storeRelase[addAddress];\r\n        uint amount = myStore.amount;\r\n        uint nowTime = block.timestamp;\r\n        uint nowPer = getCoinBack();\r\n        if (amount > 0){\r\n            uint logTime = myStore.lastLog;\r\n            (,uint changeDay) = getSubTime(nowTime, logTime);\r\n            uint lastPercent = myStore.lastPercent;\r\n\r\n            uint nowBack = nowPer;\r\n            uint backPer = calSome.getBackPer(coinMin, coinMax, lastPercent, coinAddOnce, changeDay);\r\n            uint addBack = calSome.getFee(amount, backPer);\r\n\r\n            if (addBack.add(myStore.canRealse) >= amount){\r\n                myStore.canRealse = amount;\r\n            } else {\r\n                myStore.canRealse = myStore.canRealse.add(addBack);\r\n            }\r\n            myStore.amount = myStore.amount.sub(addBack).add(addAmount);\r\n            myStore.lastPercent = nowBack;\r\n        } else {\r\n            myStore.amount = addAmount;\r\n            myStore.lastPercent = nowPer;\r\n        }\r\n        myStore.lastLog = nowTime;\r\n        storeRelase[addAddress] = myStore;       \r\n        insertLog(1, addAddress, addType, addAmount, false, addAddress);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"buyOrderEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LevelAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SellNeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"addType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"}],\"name\":\"addStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyAcitve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chooseType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useStore\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buySafe\",\"type\":\"bool\"}],\"name\":\"buyOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chooseType\",\"type\":\"uint256\"}],\"name\":\"drawActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chooseType\",\"type\":\"uint256\"}],\"name\":\"drawLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"searchType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_myAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"getAllLog\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_idReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_doTypeReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amountReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"_incrReturn\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"_addressReturn\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_logTimeReturn\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getCalArk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"coin\",\"type\":\"bool\"}],\"name\":\"getCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searchAddress\",\"type\":\"address\"}],\"name\":\"getCoinInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool[8]\",\"name\":\"\",\"type\":\"bool[8]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"selectDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chooseType\",\"type\":\"uint256\"}],\"name\":\"getDaysBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"con\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getErc20With\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"searchType\",\"type\":\"uint8\"}],\"name\":\"getInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getLevelAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getLevelCan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getMyCan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_myAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chooseType\",\"type\":\"uint256\"}],\"name\":\"getMyOrderList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_idReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amountReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_needDayReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_belongTypeReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_backPerReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_statusReturn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_storeTimeReturn\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"coin\",\"type\":\"bool\"}],\"name\":\"getMyRealse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"searchAddress\",\"type\":\"address\"}],\"name\":\"getStoreInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amount1\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserActive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"levelContract\",\"outputs\":[{\"internalType\":\"contract levelDo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"chooseCoin\",\"type\":\"bool\"}],\"name\":\"rebackOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"beforeLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"releaseSome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router1\",\"outputs\":[{\"internalType\":\"contract IW3swapRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"}],\"name\":\"sendStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendToTypeEx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_setLeader\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contract1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pairAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timeIncr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_searchCan\",\"type\":\"bool\"}],\"name\":\"setContract1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "zhou", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cd1ed8956d96e573b3a5e9b2f97dac227ce827e012d86cddddf676517627e95b"}