{"SourceCode": "{\"AltynICO.sol\":{\"content\":\"// AltynICO.sol 2023.06.22 started\\n\\n/* Token sale for Altyn\\n\\nWorks with AltynToken.sol as the contract for the Altyn Token\\n\\nThe contract is intended to handle both presale and full ICO, though, if necessary a new contract could be used for the full ICO, with the token contract unchanged apart from its owner.\\n\\nMin purchase Ether 0.1\\nNo end date - just cap or pause\\n\\n*/\\n\\npragma solidity ^0.4.15;\\n\\nimport \\\"./AltynToken.sol\\\"; // which imports Owned.sol, DSMath.sol, ERC20Token.sol\\n\\ncontract AltynICO is Owned, DSMath {\\n  string public name;         // Contract name\\n  uint public  startTime;     // start time of the sale\\n  uint public  aicosCap;      // Cap for the sale\\n  uint public  aicosSold;     // Cumulative Picos sold which should == AIOE.pTokensIssued\\n  uint public  aicosPerEther; // 3,000,000,000,000,000 for ETH = $300 and target AltyenTEph price = $0.10\\n  uint public  weiRaised;     // cumulative wei raised\\n  AltynToken public AIOE;     // the Altyn token contract\\n  address private pPCwalletA; // address of the Altyn Core wallet to receive funds raised\\n\\n  // Constructor not payable\\n  // -----------\\n  //\\n  function AltynICO() {\\n    pausedB = true; // start paused\\n  }\\n\\n  // Events\\n  // ------\\n  event LogPrepareToStart(string Name, uint StartTime, uint AicosCap, AltynToken TokenContract, address PCwallet);\\n  event LogSetAicosPerEther(uint AicosPerEther);\\n  event LogChangePCWallet(address PCwallet);\\n  event LogSale(address indexed Purchaser, uint SaleWei, uint Aicos);\\n  event LogAllocate(address indexed Supplier, uint SuppliedWei, uint Aicos);\\n  event LogSaleCapReached(uint WeiRaised, uint PicosSold);\\n\\n  // PrepareToStart()\\n  // --------------\\n  // To be called manually by owner just prior to the start of the presale or the full ICO\\n  // Can also be called by owner to adjust settings. With care!!\\n  function PrepareToStart(string vNameS, uint vStartTime, uint vAicosCap, uint vAicosPerEther, AltynToken vTokenA, address vPCwalletA) IsOwner {\\n    require(vTokenA != address(0)\\n         \\u0026\\u0026 vPCwalletA != address(0));\\n    name       = vNameS;     // Altyn Presale | Altyn Token Sale\\n    startTime  = vStartTime;\\n    aicosCap   = vAicosCap;  // Cap for the sale, 20 Million AIOEs = 20,000,000,000,000,000,000 = 20**19 Picos for the Presale\\n    AIOE       = vTokenA;    // The token contract\\n    pPCwalletA = vPCwalletA; // Altyn Code wallet to receive funds\\n    pausedB    = false;\\n    AIOE.PrepareForSale();   // stops transfers\\n    LogPrepareToStart(vNameS, vStartTime, vAicosCap, vTokenA, vPCwalletA);\\n    SetAicosPerEther(vAicosPerEther);\\n  }\\n\\n  // Public Constant Methods\\n  // -----------------------\\n  // None. Used public variables instead which result in getter functions\\n\\n  // State changing public method made pause-able\\n  // ----------------------------\\n\\n  // Buy()\\n  // Fn to be called to buy AIOEs\\n  function Buy() payable IsActive {\\n    require(now \\u003e= startTime);       // sale is running (in conjunction with the IsActive test)\\n    require(msg.value \\u003e= 0.1 ether); // sent \\u003e= the min\\n    uint aicos = mul(aicosPerEther, msg.value) / 10**18; // aicos = aicos per ETH * Wei / 10^18 \\u003c=== calc for integer arithmetic as in Solidity\\n    weiRaised = add(weiRaised, msg.value);\\n    pPCwalletA.transfer(this.balance); // throws on failure\\n    AIOE.Issue(msg.sender, aicos);\\n    LogSale(msg.sender, msg.value, aicos);\\n    aicosSold += aicos; // ok wo overflow protection as AIOE.Issue() would have thrown on overflow\\n    if (aicosSold \\u003e= aicosCap) {\\n      // Cap reached so end the sale\\n      pausedB = true;\\n      AIOE.SaleCapReached(); // Allows transfers\\n      LogSaleCapReached(weiRaised, aicosSold);\\n    }\\n  }\\n\\n  // Functions to be called Manually\\n  // ===============================\\n  // SetAicosPerEther()\\n  // Fn to be called daily (hourly?) or on significant Ether price movement to set the Altyn price\\n  function SetAicosPerEther(uint vAicosPerEther) IsOwner {\\n    aicosPerEther = vAicosPerEther; // 3,000,000,000,000,000 for ETH = $300 and target AIOE price = $0.10\\n    LogSetAicosPerEther(aicosPerEther);\\n  }\\n\\n  // ChangePCWallet()\\n  // Fn to be called to change the PC Wallet to receive funds raised. This is set initially via PrepareToStart()\\n  function ChangePCWallet(address vPCwalletA) IsOwner {\\n    require(vPCwalletA != address(0));\\n    pPCwalletA = vPCwalletA;\\n    LogChangePCWallet(vPCwalletA);\\n  }\\n\\n  // Allocate()\\n  // Allocate in lieu for goods or services or fiat supplied valued at wad wei in return for picos issued. Not payable\\n  // no picosCap check\\n  // wad is only for logging\\n  function Allocate(address vSupplierA, uint wad, uint aicos) IsOwner IsActive {\\n     AIOE.Issue(vSupplierA, aicos);\\n    LogAllocate(vSupplierA, wad, aicos);\\n    aicosSold += aicos; // ok wo overflow protection as AIOE.Issue() would have thrown on overflow\\n  }\\n\\n  // Token Contract Functions to be called Manually via Owner calls to ICO Contract\\n  // ==============================================================================\\n  // ChangeTokenContractOwner()\\n  // To be called manually if a new sale contract is deployed to change the owner of the PacioToken contract to it.\\n  // Expects the sale contract to have been paused\\n  // Calling ChangeTokenContractOwner() will stop calls from the old sale contract to token contract IsOwner functions from working\\n  function ChangeTokenContractOwner(address vNewOwnerA) IsOwner {\\n    require(pausedB);\\n    AIOE.ChangeOwner(vNewOwnerA);\\n  }\\n\\n  // PauseTokenContract()\\n  // To be called manually to pause the token contract\\n  function PauseTokenContract() IsOwner {\\n    AIOE.Pause();\\n  }\\n\\n  // ResumeTokenContract()\\n  // To be called manually to resume the token contract\\n  function ResumeTokenContract() IsOwner {\\n    AIOE.Resume();\\n  }\\n\\n  // Mint()\\n  // To be called manually if necessary e.g. re full ICO going over the cap\\n  // Expects the sale contract to have been paused\\n  function Mint(uint aicos) IsOwner {\\n    require(pausedB);\\n    AIOE.Mint(aicos);\\n  }\\n\\n  // IcoCompleted()\\n  // To be be called manually after full ICO ends. Could be called before cap is reached if ....\\n  // Expects the sale contract to have been paused\\n  function IcoCompleted() IsOwner {\\n    require(pausedB);\\n    AIOE.IcoCompleted();\\n  }\\n\\n  // SetFFSettings()\\n  // Allows setting Founder and Foundation addresses (or changing them if an appropriate transfer has been done)\\n  //  plus optionally changing the allocations which are set by the PacioToken constructor, so that they can be varied post deployment if required re a change of plan\\n  // All values are optional - zeros can be passed\\n  // Must have been called with non-zero Founder and Foundation addresses before Founder and Foundation vesting can be done\\n  function SetFFSettings(address vFounderTokensA, address vFoundationTokensA, uint vFounderTokensAllocation, uint vFoundationTokensAllocation) IsOwner {\\n    AIOE.SetFFSettings(vFounderTokensA, vFoundationTokensA, vFounderTokensAllocation, vFoundationTokensAllocation);\\n  }\\n\\n  // VestFFTokens()\\n  // To vest Founder and/or Foundation tokens\\n  // 0 can be passed meaning skip that one\\n  // SetFFSettings() must have been called with non-zero Founder and Foundation addresses before this fn can be used\\n  function VestFFTokens(uint vFounderTokensVesting, uint vFoundationTokensVesting) IsOwner {\\n    AIOE.VestFFTokens(vFounderTokensVesting, vFoundationTokensVesting);\\n  }\\n\\n  // Burn()\\n  // For use when transferring issued AIOEs to PIOs\\n  // To be replaced by a new transfer contract to be written which is set to own the PacioToken contract\\n  function Burn(address src, uint aicos) IsOwner {\\n    AIOE.Burn(src, aicos);\\n  }\\n\\n  // Destroy()\\n  // For use when transferring unissued AIOEs to PIOs\\n  // To be replaced by a new transfer contract to be written which is set to own the PacioToken contract\\n  function Destroy(uint aicos) IsOwner {\\n    AIOE.Destroy(aicos);\\n  }\\n\\n  // Fallback function\\n  // =================\\n  // No sending ether to this contract!\\n  // Not payable so trying to send ether will throw\\n  function() {\\n    revert(); // reject any attempt to access the token contract other than via the defined methods with their testing for valid access\\n  }\\n\\n} // End AltynICO contract\\n\\n\"},\"AltynToken.sol\":{\"content\":\"// AltynToken.sol 2023.06.22 started\\n\\n/* The Altyn Token named ALTYN for the Ethereum version\\n\\nFollows the EIP20 standard: https://github.com/frozeman/EIPs/blob/94bc4311e889c2c58c561c074be1483f48ac9374/EIPS/eip-20-token-standard.md\\n\\n2023.06.22\\n\\n\\n*/\\n\\npragma solidity ^0.4.15;\\n\\nimport \\\"./ERC20Token.sol\\\";\\n\\ncontract AltynToken is ERC20Token {\\n  // enum NFF {  // Founders/Foundation enum\\n  //   Founders, // 0 Altyn Founders\\n  //   Foundatn} // 1 Altyn Foundation\\n  string public constant name   = \\\"Altyn Token\\\";\\n  string public constant symbol = \\\"ALTYN\\\";\\n  uint8  public constant decimals = 12;\\n  uint   public tokensIssued;           // Tokens issued - tokens in circulation\\n  uint   public tokensAvailable;        // Tokens available = total supply less allocated and issued tokens\\n  uint   public contributors;           // Number of contributors\\n  uint   public founderTokensAllocated; // Founder tokens allocated\\n  uint   public founderTokensVested;    // Founder tokens vested. Same as iTokensOwnedM[pFounderToksA] until tokens transferred. Unvested tokens = founderTokensAllocated - founderTokensVested\\n  uint   public foundationTokensAllocated; // Foundation tokens allocated\\n  uint   public foundationTokensVested;    // Foundation tokens vested. Same as iTokensOwnedM[pFoundationToksA] until tokens transferred. Unvested tokens = foundationTokensAllocated - foundationTokensVested\\n  bool   public icoCompleteB;           // Is set to true when both presale and full ICO are complete. Required for vesting of founder and foundation tokens and transfers of ALTYNs to PIOs\\n  address private pFounderToksA;        // Address for Founder tokens issued\\n  address private pFoundationToksA;     // Address for Foundation tokens issued\\n\\n  // Events\\n  // ------\\n  event LogIssue(address indexed Dst, uint Aicos);\\n  event LogSaleCapReached(uint TokensIssued); // not tokensIssued just to avoid compiler Warning: This declaration shadows an existing declaration\\n  event LogIcoCompleted();\\n  event LogBurn(address Src, uint Aicos);\\n  event LogDestroy(uint Aicos);\\n\\n  // No Constructor\\n  // --------------\\n\\n  // Initialisation/Settings Methods IsOwner but not IsActive\\n  // -------------------------------\\n\\n  // Initialise()\\n  // To be called by deployment owner to change ownership to the sale contract, and do the initial allocations and minting.\\n  // Can only be called once. If the sale contract changes but the token contract stays the same then ChangeOwner() can be called via AltynICO.ChangeTokenContractOwner() to change the owner to the new contract\\n  function Initialise(address vNewOwnerA) { // IsOwner c/o the super.ChangeOwner() call\\n    require(totalSupply == 0);          // can only be called once\\n    super.ChangeOwner(vNewOwnerA);      // includes an IsOwner check so don\\u0027t need to repeat it here\\n    founderTokensAllocated    = 10**20; // 10% or 100 million = 1e20 Aicos\\n    foundationTokensAllocated = 10**20; // 10% or 100 million = 1e20 Aicos This call sets tokensAvailable\\n    // Equivalent of Mint(10**21) which can\\u0027t be used here as msg.sender is the old (deployment) owner // 1 Billion PIOEs    = 1e21 Aicos, all minted)\\n    totalSupply           = 10**21; // 1 Billion PIOEs    = 1e21 Aicos, all minted)\\n    iTokensOwnedM[ownerA] = 10**21;\\n    tokensAvailable       = 8*(10**20); // 800 million [String: \\u0027800000000000000000000\\u0027] s: 1, e: 20, c: [ 8000000 ] }\\n    // From the EIP20 Standard: A token contract which creates new tokens SHOULD trigger a Transfer event with the _from address set to 0x0 when tokens are created.\\n    Transfer(0x0, ownerA, 10**21); // log event 0x0 from == minting\\n  }\\n\\n  // Mint()\\n  // AltynICO() includes a Mint() fn to allow manual calling of this if necessary e.g. re full ICO going over the cap\\n  function Mint(uint Aicos) IsOwner {\\n    totalSupply           = add(totalSupply,           Aicos);\\n    iTokensOwnedM[ownerA] = add(iTokensOwnedM[ownerA], Aicos);\\n    tokensAvailable = subMaxZero(totalSupply, tokensIssued + founderTokensAllocated + foundationTokensAllocated);\\n    // From the EIP20 Standard: A token contract which creates new tokens SHOULD trigger a Transfer event with the _from address set to 0x0 when tokens are created.\\n    Transfer(0x0, ownerA, Aicos); // log event 0x0 from == minting\\n  }\\n\\n  // PrepareForSale()\\n  // stops transfers and allows purchases\\n  function PrepareForSale() IsOwner {\\n    require(!icoCompleteB); // Cannot start selling again once ICO has been set to completed\\n    saleInProgressB = true; // stops transfers\\n  }\\n\\n  // ChangeOwner()\\n  // To be called by owner to change the token contract owner, expected to be to a sale contract\\n  // Transfers any minted tokens from old to new sale contract\\n  function ChangeOwner(address vNewOwnerA) { // IsOwner c/o the super.ChangeOwner() call\\n    transfer(vNewOwnerA, iTokensOwnedM[ownerA]); // includes checks\\n    super.ChangeOwner(vNewOwnerA); // includes an IsOwner check so don\\u0027t need to repeat it here\\n  }\\n\\n  // Public Constant Methods\\n  // -----------------------\\n  // None. Used public variables instead which result in getter functions\\n\\n  // State changing public methods made pause-able and with call logging\\n  // -----------------------------\\n  // Issue()\\n  // Transfers Aicos tokens to dst to issue them. IsOwner because this is expected to be called from the token sale contract\\n  function Issue(address dst, uint Aicos) IsOwner IsActive returns (bool) {\\n    require(saleInProgressB      // Sale is in progress\\n         \\u0026\\u0026 iTokensOwnedM[ownerA] \\u003e= Aicos // Owner has the tokens available\\n      // \\u0026\\u0026 Aicos \\u003e 0            // Non-zero issue No need to check for this\\n         \\u0026\\u0026 dst != address(this) // Not issuing to this token contract\\n         \\u0026\\u0026 dst != ownerA);      // Not issuing to the owner of this contract - the token sale contract\\n    if (iTokensOwnedM[dst] == 0)\\n      contributors++;\\n    iTokensOwnedM[ownerA] -= Aicos; // There is no need to check this for underflow via a sub() call given the iTokensOwnedM[ownerA] \\u003e= Aicos check\\n    iTokensOwnedM[dst]     = add(iTokensOwnedM[dst], Aicos);\\n    tokensIssued           = add(tokensIssued,       Aicos);\\n    tokensAvailable    = subMaxZero(tokensAvailable, Aicos); // subMaxZero() in case a sale goes over, only possible for full ICO, when cap is for all available tokens.\\n    LogIssue(dst, Aicos);                                    // If that should happen,may need to mint some more PIOEs to allow founder and foundation vesting to complete.\\n    return true;\\n  }\\n\\n  // SaleCapReached()\\n  // To be be called from the token sale contract when a cap (pre or full) is reached\\n  // Allows transfers\\n  function SaleCapReached() IsOwner IsActive {\\n    saleInProgressB = false; // allows transfers\\n    LogSaleCapReached(tokensIssued);\\n  }\\n\\n  // Functions for manual calling via same name function in AltynICO()\\n  // =================================================================\\n  // IcoCompleted()\\n  // To be be called manually via AltynICO after full ICO ends. Could be called before cap is reached if ....\\n  function IcoCompleted() IsOwner IsActive {\\n    require(!icoCompleteB);\\n    saleInProgressB = false; // allows transfers\\n    icoCompleteB    = true;\\n    LogIcoCompleted();\\n  }\\n\\n  // SetFFSettings(address vFounderTokensA, address vFoundationTokensA, uint vFounderTokensAllocation, uint vFoundationTokensAllocation)\\n  // Allows setting Founder and Foundation addresses (or changing them if an appropriate transfer has been done)\\n  //  plus optionally changing the allocations which are set by the constructor, so that they can be varied post deployment if required re a change of plan\\n  // All values are optional - zeros can be passed\\n  // Must have been called with non-zero Founder and Foundation addresses before Founder and Foundation vesting can be done\\n  function SetFFSettings(address vFounderTokensA, address vFoundationTokensA, uint vFounderTokensAllocation, uint vFoundationTokensAllocation) IsOwner {\\n    if (vFounderTokensA    != address(0)) pFounderToksA    = vFounderTokensA;\\n    if (vFoundationTokensA != address(0)) pFoundationToksA = vFoundationTokensA;\\n    if (vFounderTokensAllocation \\u003e 0)    assert((founderTokensAllocated    = vFounderTokensAllocation)    \\u003e= founderTokensVested);\\n    if (vFoundationTokensAllocation \\u003e 0) assert((foundationTokensAllocated = vFoundationTokensAllocation) \\u003e= foundationTokensVested);\\n    tokensAvailable = totalSupply - founderTokensAllocated - foundationTokensAllocated - tokensIssued;\\n  }\\n\\n  // VestFFTokens()\\n  // To vest Founder and/or Foundation tokens\\n  // 0 can be passed meaning skip that one\\n  // No separate event as the LogIssue event can be used to trace vesting transfers\\n  // To be be called manually via AltynICO\\n  function VestFFTokens(uint vFounderTokensVesting, uint vFoundationTokensVesting) IsOwner IsActive {\\n    require(icoCompleteB); // ICO must be completed before vesting can occur. djh?? Add other time restriction?\\n    if (vFounderTokensVesting \\u003e 0) {\\n      assert(pFounderToksA != address(0)); // Founders token address must have been set\\n      assert((founderTokensVested  = add(founderTokensVested,          vFounderTokensVesting)) \\u003c= founderTokensAllocated);\\n      iTokensOwnedM[ownerA]        = sub(iTokensOwnedM[ownerA],        vFounderTokensVesting);\\n      iTokensOwnedM[pFounderToksA] = add(iTokensOwnedM[pFounderToksA], vFounderTokensVesting);\\n      LogIssue(pFounderToksA,          vFounderTokensVesting);\\n      tokensIssued = add(tokensIssued, vFounderTokensVesting);\\n    }\\n    if (vFoundationTokensVesting \\u003e 0) {\\n      assert(pFoundationToksA != address(0)); // Foundation token address must have been set\\n      assert((foundationTokensVested  = add(foundationTokensVested,          vFoundationTokensVesting)) \\u003c= foundationTokensAllocated);\\n      iTokensOwnedM[ownerA]           = sub(iTokensOwnedM[ownerA],           vFoundationTokensVesting);\\n      iTokensOwnedM[pFoundationToksA] = add(iTokensOwnedM[pFoundationToksA], vFoundationTokensVesting);\\n      LogIssue(pFoundationToksA,       vFoundationTokensVesting);\\n      tokensIssued = add(tokensIssued, vFoundationTokensVesting);\\n    }\\n    // Does not affect tokensAvailable as these tokens had already been allowed for in tokensAvailable when allocated\\n  }\\n\\n  // Burn()\\n  // For use when transferring issued PIOEs to PIOs\\n  // To be be called manually via AltynICO or from a new transfer contract to be written which is set to own this one\\n  function Burn(address src, uint Aicos) IsOwner IsActive {\\n    require(icoCompleteB);\\n    iTokensOwnedM[src] = subMaxZero(iTokensOwnedM[src], Aicos);\\n    tokensIssued       = subMaxZero(tokensIssued, Aicos);\\n    totalSupply        = subMaxZero(totalSupply,  Aicos);\\n    LogBurn(src, Aicos);\\n    // Does not affect tokensAvailable as these are issued tokens that are being burnt\\n  }\\n\\n  // Destroy()\\n  // For use when transferring unissued PIOEs to PIOs\\n  // To be be called manually via AltynICO or from a new transfer contract to be written which is set to own this one\\n  function Destroy(uint Aicos) IsOwner IsActive {\\n    require(icoCompleteB);\\n    totalSupply     = subMaxZero(totalSupply,     Aicos);\\n    tokensAvailable = subMaxZero(tokensAvailable, Aicos);\\n    LogDestroy(Aicos);\\n  }\\n\\n  // Fallback function\\n  // =================\\n  // No sending ether to this contract!\\n  // Not payable so trying to send ether will throw\\n  function() {\\n    revert(); // reject any attempt to access the token contract other than via the defined methods with their testing for valid access\\n  }\\n} // End AltynToken contract\\n\"},\"DSMath.sol\":{\"content\":\"// DSMath.sol\\n// From https://dappsys.readthedocs.io/en/latest/ds_math.html\\n\\n// Reduced version - just the fns used by Pacio\\n\\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\\n\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n// You may not use this file except in compliance with the License.\\n\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\\n\\npragma solidity ^0.4.15;\\n\\ncontract DSMath {\\n  /*\\n  standard uint256 functions\\n  */\\n\\n  function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\\n    assert((z = x + y) \\u003e= x);\\n  }\\n\\n  function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\\n    assert((z = x - y) \\u003c= x);\\n  }\\n\\n  function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\\n    z = x * y;\\n    assert(x == 0 || z / x == y);\\n  }\\n\\n  // div isn\\u0027t needed. Only error case is div by zero and Solidity throws on that\\n  // function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\\n  //   z = x / y;\\n  // }\\n\\n  // subMaxZero(x, y)\\n  // Pacio addition to avoid throwing if a subtraction goes below zero and return 0 in that case.\\n  function subMaxZero(uint256 x, uint256 y) constant internal returns (uint256 z) {\\n    if (y \\u003e x)\\n      z = 0;\\n    else\\n      z = x - y;\\n  }\\n}\\n\"},\"ERC20Token.sol\":{\"content\":\"// ERC20Token.sol 2017.08.16 started\\n\\n// 2017.10.07 isERC20Token changed to isEIP20Token\\n\\npragma solidity ^0.4.15;\\n\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./DSMath.sol\\\";\\n\\n/*\\nERC Token Standard #20 Interface\\nhttps://github.com/ethereum/EIPs/issues/20\\nhttps://github.com/frozeman/EIPs/blob/94bc4311e889c2c58c561c074be1483f48ac9374/EIPS/eip-20-token-standard.md\\nUsing Dappsys naming style of 3 letter names: src, dst, guy, wad\\n*/\\n\\ncontract ERC20Token is Owned, DSMath {\\n  // Data\\n  bool public constant isEIP20Token = true; // Interface declaration\\n  uint public totalSupply;     // Total tokens minted\\n  bool public saleInProgressB; // when true stops transfers\\n\\n  mapping(address =\\u003e uint) internal iTokensOwnedM;                 // Tokens owned by an account\\n  mapping(address =\\u003e mapping (address =\\u003e uint)) private pAllowedM; // Owner of account approves the transfer of an amount to another account\\n\\n  // ERC20 Events\\n  // ============\\n  // Transfer\\n  // Triggered when tokens are transferred.\\n  event Transfer(address indexed src, address indexed dst, uint wad);\\n\\n  // Approval\\n  // Triggered whenever approve(address spender, uint wad) is called.\\n  event Approval(address indexed Sender, address indexed Spender, uint Wad);\\n\\n  // ERC20 Methods\\n  // =============\\n  // Public Constant Methods\\n  // -----------------------\\n  // balanceOf()\\n  // Returns the token balance of account with address guy\\n  function balanceOf(address guy) public constant returns (uint) {\\n    return iTokensOwnedM[guy];\\n  }\\n\\n  // allowance()\\n  // Returns the number of tokens approved by guy that can be transferred (\\\"spent\\\") by spender\\n  function allowance(address guy, address spender) public constant returns (uint) {\\n    return pAllowedM[guy][spender];\\n  }\\n\\n  // Modifier functions\\n  // ------------------\\n  modifier IsTransferOK(address src, address dst, uint wad) {\\n    require(!saleInProgressB          // Sale not in progress\\n         \\u0026\\u0026 !pausedB                  // IsActive\\n         \\u0026\\u0026 iTokensOwnedM[src] \\u003e= wad // Source has the tokens available\\n      // \\u0026\\u0026 wad \\u003e 0                   // Non-zero transfer No! The std says: Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event\\n         \\u0026\\u0026 dst != src                // Destination is different from source\\n         \\u0026\\u0026 dst != address(this)      // Not transferring to this token contract\\n         \\u0026\\u0026 dst != ownerA);           // Not transferring to the owner of this contract - the token sale contract\\n    _;\\n  }\\n\\n  // State changing public methods made pause-able and with call logging\\n  // -----------------------------\\n  // transfer()\\n  // Transfers wad of sender\\u0027s tokens to another account, address dst\\n  // No need for overflow check given that totalSupply is always far smaller than max uint\\n  function transfer(address dst, uint wad) IsTransferOK(msg.sender, dst, wad) returns (bool) {\\n    iTokensOwnedM[msg.sender] -= wad; // There is no need to check this for underflow via a sub() call given the IsTransferOK iTokensOwnedM[src] \\u003e= wad check\\n    iTokensOwnedM[dst] = add(iTokensOwnedM[dst], wad);\\n    Transfer(msg.sender, dst, wad);\\n    return true;\\n  }\\n\\n  // transferFrom()\\n  // Sender transfers wad tokens from src account src to dst account, if\\n  // sender had been approved by src for a transfer of \\u003e= wad tokens from src\\u0027s account\\n  // by a prior call to approve() with that call\\u0027s sender being this calls src,\\n  //  and its spender being this call\\u0027s sender.\\n  function transferFrom(address src, address dst, uint wad) IsTransferOK(src, dst, wad) returns (bool) {\\n    require(pAllowedM[src][msg.sender] \\u003e= wad); // Transfer is approved\\n    iTokensOwnedM[src]         -= wad; // There is no need to check this for underflow given the require above\\n    pAllowedM[src][msg.sender] -= wad; // There is no need to check this for underflow given the require above\\n    iTokensOwnedM[dst] = add(iTokensOwnedM[dst], wad);\\n    Transfer(src, dst, wad);\\n    return true;\\n  }\\n\\n  // approve()\\n  // Approves the passed address (of spender) to spend up to wad tokens on behalf of msg.sender,\\n  //  in one or more transferFrom() calls\\n  // If this function is called again it overwrites the current allowance with wad.\\n  function approve(address spender, uint wad) IsActive returns (bool) {\\n    // To change the approve amount you first have to reduce the addresses`\\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\\n    //  already 0 to mitigate the race condition described here:\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    // djh: This appears to be of doubtful value, and is not used in the Dappsys library though it is in the Zeppelin one. Removed.\\n    // require((wad == 0) || (pAllowedM[msg.sender][spender] == 0));\\n    pAllowedM[msg.sender][spender] = wad;\\n    Approval(msg.sender, spender, wad);\\n    return true;\\n  }\\n} // End ERC20Token contracts\\n\"},\"Migrations.sol\":{\"content\":\"pragma solidity ^0.4.2;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  function Migrations() {\\n    owner = msg.sender;\\n  }\\n\\n  function setCompleted(uint completed) restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"},\"Owned.sol\":{\"content\":\"/* Owned.sol\\n\\n2017.03.04 Originally created\\n2017.08.16 Brought into use for Pacio token sale use\\n2017.08.22 Logging revised\\n\\nOwned is a Base Contract for contracts that are:\\n\u2022 \\\"owned\\\"\\n\u2022 can have their owner changed by a call to ChangeOwner() by the owner\\n\u2022 can be paused  from an active state by a call to Pause() by the owner\\n\u2022 can be resumed from a paused state by a call to Resume() by the owner\\n\\nModifier functions available for use here and in child contracts are:\\n\u2022 IsOwner()  which throws if called by other than the current owner\\n\u2022 IsActive() which throws if called when the contract is paused\\n\\nChanges of owner are logged via event LogOwnerChange(address indexed previousOwner, address newOwner)\\n\\n*/\\n\\npragma solidity ^0.4.15;\\n\\ncontract Owned {\\n  address public ownerA; // Contract owner\\n  bool    public pausedB;\\n\\n  // Constructor NOT payable\\n  // -----------\\n  function Owned() {\\n    ownerA = msg.sender;\\n  }\\n\\n  // Modifier functions\\n  // ------------------\\n  modifier IsOwner {\\n    require(msg.sender == ownerA);\\n    _;\\n  }\\n\\n  modifier IsActive {\\n    require(!pausedB);\\n    _;\\n  }\\n\\n  // Events\\n  // ------\\n  event LogOwnerChange(address indexed PreviousOwner, address NewOwner);\\n  event LogPaused();\\n  event LogResumed();\\n\\n  // State changing public methods\\n  // -----------------------------\\n  // Change owner\\n  function ChangeOwner(address vNewOwnerA) IsOwner {\\n    require(vNewOwnerA != address(0)\\n         \\u0026\\u0026 vNewOwnerA != ownerA);\\n    LogOwnerChange(ownerA, vNewOwnerA);\\n    ownerA = vNewOwnerA;\\n  }\\n\\n  // Pause\\n  function Pause() IsOwner {\\n    pausedB = true; // contract has been paused\\n    LogPaused();\\n  }\\n\\n  // Resume\\n  function Resume() IsOwner {\\n    pausedB = false; // contract has been resumed\\n    LogResumed();\\n  }\\n} // End Owned contract\\n\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"saleInProgressB\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"PrepareForSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Aicos\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"SaleCapReached\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoCompleteB\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Resume\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEIP20Token\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vFounderTokensA\",\"type\":\"address\"},{\"name\":\"vFoundationTokensA\",\"type\":\"address\"},{\"name\":\"vFounderTokensAllocation\",\"type\":\"uint256\"},{\"name\":\"vFoundationTokensAllocation\",\"type\":\"uint256\"}],\"name\":\"SetFFSettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"founderTokensVested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vNewOwnerA\",\"type\":\"address\"}],\"name\":\"Initialise\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundationTokensVested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"Aicos\",\"type\":\"uint256\"}],\"name\":\"Issue\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"Aicos\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"IcoCompleted\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Aicos\",\"type\":\"uint256\"}],\"name\":\"Destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundationTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerA\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vFounderTokensVesting\",\"type\":\"uint256\"},{\"name\":\"vFoundationTokensVesting\",\"type\":\"uint256\"}],\"name\":\"VestFFTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vNewOwnerA\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"founderTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pausedB\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"Dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Aicos\",\"type\":\"uint256\"}],\"name\":\"LogIssue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"TokensIssued\",\"type\":\"uint256\"}],\"name\":\"LogSaleCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogIcoCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Aicos\",\"type\":\"uint256\"}],\"name\":\"LogBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Aicos\",\"type\":\"uint256\"}],\"name\":\"LogDestroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"Sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"Spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"PreviousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewOwner\",\"type\":\"address\"}],\"name\":\"LogOwnerChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogResumed\",\"type\":\"event\"}]", "ContractName": "AltynToken", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://d0656fbae06d06e514354478ed6623b2e8c41bc84b5df25769c235f66dfe6538"}