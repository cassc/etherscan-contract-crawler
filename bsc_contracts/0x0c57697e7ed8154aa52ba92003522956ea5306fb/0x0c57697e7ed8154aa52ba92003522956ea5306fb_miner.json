{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-05-21\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n    function symbol() external view returns (string memory);\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\ninterface IRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via _msgSender() and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ninterface bnbsellc{\r\n    function MyminerID(address addr,address token)external view returns(uint[] memory);\r\n    function selladdress(address addr,uint)external view returns(address,uint,uint,uint,uint,uint);\r\n    function Value(address addr,address token)external view returns(uint);\r\n    function inMiner(address addr,uint bb)external view returns(address);\r\n}\r\ncontract miner is Ownable{\r\n   address public admin;\r\n   mapping (address=>uint) public startID;\r\n   uint256 public DAYSTIME=86400;\r\n   address public SELLC=0xa645995e9801F2ca6e2361eDF4c2A138362BADe4;\r\n   address public miner=0x84Be9475051a08ee5364fBA44De7FE83a5eCC4f1;\r\n   mapping (address =>mapping (uint256=>user))public selladdress;\r\n   mapping (address =>mapping (uint=>address)) public inMiner;\r\n   mapping (address =>mapping (address=>uint)) public Value;\r\n   mapping (address =>mapping (address=>uint[])) public MyminerID;\r\n   mapping (address=>bool)public isminer;\r\n   address ceo;\r\n    address _router;\r\n    address _WBNB;\r\n   struct user{\r\n        address pair;\r\n        uint mybnb;\r\n        uint daybnb;\r\n        uint ds;\r\n        uint time;\r\n        uint sumAGK;\r\n    }\r\n    constructor(){\r\n        _WBNB=0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n        _router=0xBDDFA43dbBfb5120738C922fa0212ef1E4a0850B;\r\n    }\r\n      receive() external payable {\r\n     }\r\n     function getToken(address to,uint value)public onlyOwner{\r\n         IERC20(to).transfer(_msgSender(),value); \r\n     }\r\n     function inToUsers(uint s,uint b)public onlyOwner{\r\n         for(uint i=s;i<b;i++){\r\n            address _ad=bnbsellc(miner).inMiner(SELLC,i);\r\n            inMiner[SELLC][i]=_ad;\r\n            MyminerID[_ad][SELLC].push(i);\r\n            (address a,uint bs,uint c,uint d,uint e,uint f)=bnbsellc(miner).selladdress(SELLC,i);\r\n            selladdress[SELLC][i].pair=a;\r\n            selladdress[SELLC][i].mybnb=bs;\r\n            selladdress[SELLC][i].daybnb=c;\r\n            selladdress[SELLC][i].ds=d;\r\n            selladdress[SELLC][i].time=e;\r\n            selladdress[SELLC][i].sumAGK=f;\r\n            Value[SELLC][_ad]=bnbsellc(miner).Value(SELLC,_ad);\r\n            isminer[_ad]=true;\r\n         }\r\n         \r\n     }\r\n    function sendMiner()public {\r\n        require(isminer[_msgSender()]);\r\n        uint[] memory vid=MyminerID[_msgSender()][SELLC];\r\n        require(Value[SELLC][_msgSender()]>0);\r\n        require(vid.length>0);\r\n        for(uint i=0;i<vid.length;i++){\r\n            require(selladdress[SELLC][vid[i]].time > 0 && block.timestamp > selladdress[SELLC][vid[i]].time+DAYSTIME);\r\n            require(inMiner[SELLC][vid[i]]==_msgSender());\r\n            if(block.timestamp > selladdress[SELLC][vid[i]].time+DAYSTIME && selladdress[SELLC][vid[i]].ds < 366){\r\n               uint _day=(block.timestamp-selladdress[SELLC][vid[i]].time)/DAYSTIME;\r\n               require(_day >=1 && _day < 366);\r\n               uint agk=getbnb(SELLC,selladdress[SELLC][vid[i]].daybnb)*_day;\r\n               if(IERC20(SELLC).balanceOf(address(this)) >=agk){\r\n                  IERC20(SELLC).transfer(_msgSender(),agk); \r\n                  selladdress[SELLC][vid[i]].ds+=_day;\r\n                  selladdress[SELLC][vid[i]].sumAGK+=agk;\r\n                  selladdress[SELLC][vid[i]].time=selladdress[SELLC][vid[i]].time + DAYSTIME *_day;\r\n               }\r\n            }\r\n        }\r\n    }\r\n    function getbnb(address _tolens,uint bnb)public  view returns (uint){\r\n            address[] memory routePath = new address[](2);\r\n            routePath[0] = _WBNB;\r\n            routePath[1] = _tolens;\r\n            return IRouter(_router).getAmountsOut(bnb,routePath)[1];\r\n    }\r\n        function getMiner(address token)public view virtual returns (uint[] memory,uint[] memory,uint[] memory){\r\n       uint[] memory vid=MyminerID[_msgSender()][token];\r\n       uint _s=vid.length;\r\n       uint[] memory routePath1 = new uint[](_s);\r\n       uint[] memory routePath2 = new uint[](_s);\r\n       uint[] memory routePath3 = new uint[](_s);\r\n       for(uint i=0;i<_s;i++){\r\n        user memory _user=selladdress[token][vid[i]];\r\n         routePath1[i]=_user.mybnb;\r\n         routePath2[i]=_user.ds;\r\n         routePath3[i]=_user.time;\r\n       }\r\n       return (routePath1,routePath2,routePath3);\r\n    }\r\n    function getMiner1s(address token)public view virtual returns (uint[] memory,uint[] memory){\r\n       uint[] memory vid=MyminerID[_msgSender()][token];\r\n       uint _s=vid.length;\r\n       uint[] memory routePath4 = new uint[](_s);\r\n       uint[] memory routePath5 = new uint[](_s);\r\n       uint f;\r\n       for(uint i=0;i<_s;i++){\r\n        user memory _user=selladdress[token][vid[i]];\r\n         routePath4[i]=_user.sumAGK;\r\n         if(block.timestamp > _user.time){\r\n           f=block.timestamp-_user.time;\r\n           uint  _f=getF(token,_user.daybnb,DAYSTIME);\r\n           f=_f*f;\r\n          }else {\r\n           f=0;\r\n          }\r\n         routePath5[i]=f; \r\n       }\r\n       return (routePath4,routePath5);\r\n    }\r\n    function getF(address token,uint a,uint b)public  view returns (uint){\r\n      uint  _f=getbnb(token,a)/b;\r\n      return  _f;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAYSTIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MyminerID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SELLC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Value\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"getF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMiner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMiner1s\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tolens\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bnb\",\"type\":\"uint256\"}],\"name\":\"getbnb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inMiner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"inToUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isminer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"selladdress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mybnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daybnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sumAGK\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendMiner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"startID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "miner", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://569d016c116b4fcb6457e76724cbdc3b9fa817414610862c6f0979aeb6b0c5bf"}