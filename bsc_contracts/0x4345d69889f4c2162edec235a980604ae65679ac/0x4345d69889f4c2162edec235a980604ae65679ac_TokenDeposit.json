{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/TokenDeposit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @title TokenDeposit\\n * @dev This contract allows users to deposit a specific token (CERT) and administrators to withdraw any token.\\n * Administrators can also set prices for tokens that users can sell in exchange for CERT tokens.\\n */\\ncontract TokenDeposit is ReentrancyGuard {\\n    // Admin address who has the rights to withdraw tokens and update admin\\n    address public admin;\\n\\n    // Address of the new admin candidate, needs to accept admin role\\n    address public newAdminCandidate;\\n\\n    // The time lock for withdrawals by the admin in seconds\\n    uint256 public withdrawTimelock;\\n\\n    // The timestamp of the last withdrawal made by the admin\\n    uint256 public lastWithdrawTimestamp;\\n\\n    // Address of the CERT token which users can deposit\\n    address public certTokenAddress;\\n\\n    // Boolean flag to toggle the sell functionality on or off\\n    bool public isBuyActive = true;\\n\\n    // Address of the wallet from which CERT tokens will be transferred during a sell\\n    address public certWallet;\\n\\n    // Native token\\n    address public constant BNB_ADDRESS =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // Minimum amount of CERT tokens that can be purchased\\n    uint256 public minPurchaseAmount = 1;\\n\\n    /**\\n     * @dev Structure to hold the details of each transaction.\\n     */\\n    struct Transaction {\\n        address user; // Address of the user who made the transaction\\n        uint256 amount; // Amount involved in the transaction\\n        uint256 timestamp; // Timestamp when the transaction was made\\n        bool isBuy; // True if the transaction is a sell transaction, false if it is a deposit transaction\\n    }\\n\\n    // Mapping to store the array of transactions for each user address\\n    mapping(address => Transaction[]) private userTransactions;\\n\\n    // Mapping to store the sell prices for tokens that can be sold for CERT\\n    mapping(address => uint256) public buyPrices;\\n\\n    // Mapping to keep track of allowed tokens for selling\\n    mapping(address => bool) public allowedTokens;\\n\\n    // Event emitted when a user deposits CERT tokens\\n    event Deposit(address indexed user, uint256 amount, uint256 timestamp);\\n\\n    // Event emitted when the admin withdraws any token from the contract\\n    event Withdrawal(\\n        address indexed admin,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    // Event emitted when the admin role is updated\\n    event AdminUpdated(address indexed previousAdmin, address indexed newAdmin);\\n\\n    // Event emitted when the sell price of a token is updated\\n    event BuyPriceUpdated(address indexed token, uint256 price);\\n\\n    event Bought(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 certAmount,\\n        uint256 timestamp\\n    );\\n\\n    // Event emitted when the sell functionality is toggled on or off\\n    event BuyToggled(bool isSellActive);\\n\\n    // Event emitted when a token is allowed or disallowed for selling\\n    event AllowToken(address token, bool status);\\n\\n    /**\\n     * @dev Constructor to initialize the contract with initial values.\\n     * @param _withdrawTimelock The time lock for withdrawals by the admin.\\n     * @param _certTokenAddress The address of the CERT token.\\n     * @param _certWallet The address of the wallet from which CERT tokens will be transferred during a sell.\\n     */\\n    constructor(\\n        uint256 _withdrawTimelock,\\n        address _certTokenAddress,\\n        address _certWallet\\n    ) {\\n        admin = msg.sender;\\n        withdrawTimelock = _withdrawTimelock;\\n        certTokenAddress = _certTokenAddress;\\n        certWallet = _certWallet;\\n    }\\n\\n    // Modifier to restrict function access to only the admin\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Only admin can call this function\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the admin to toggle the sell functionality on or off.\\n     */\\n    function toggleBuyActive() external onlyAdmin {\\n        isBuyActive = !isBuyActive;\\n        emit BuyToggled(isBuyActive);\\n    }\\n\\n    /**\\n     * @dev Allows the admin to update the address of the certWallet.\\n     * @param _newCertWallet The new address of the certWallet.\\n     */\\n    function updateCertWallet(address _newCertWallet) external onlyAdmin {\\n        require(_newCertWallet != address(0), \\\"Invalid address\\\");\\n        certWallet = _newCertWallet;\\n    }\\n\\n    // Allows the admin to update the minimum purchase amount\\n    function updateMinPurchaseAmount(\\n        uint256 _newMinPurchaseAmount\\n    ) external onlyAdmin {\\n        minPurchaseAmount = _newMinPurchaseAmount;\\n    }\\n\\n    /**\\n     * @dev Allows users to deposit CERT tokens.\\n     * @param amount The amount of CERT tokens to deposit.\\n     */\\n    function depositToken(uint256 amount) external nonReentrant {\\n        IERC20 certToken = IERC20(certTokenAddress);\\n        require(\\n            certToken.balanceOf(msg.sender) >= amount,\\n            \\\"Insufficient balance\\\"\\n        );\\n        require(\\n            certToken.allowance(msg.sender, address(this)) >= amount,\\n            \\\"Not enough balance approved\\\"\\n        );\\n\\n        // Transfer the tokens from user to the contract\\n        require(\\n            certToken.transferFrom(msg.sender, address(this), amount),\\n            \\\"Token transfer failed\\\"\\n        );\\n\\n        // Store the deposit details\\n        userTransactions[msg.sender].push(\\n            Transaction(msg.sender, amount, block.timestamp, false)\\n        );\\n\\n        // Emit the event to record the deposit\\n        emit Deposit(msg.sender, amount, block.timestamp);\\n    }\\n\\n    /**\\n     * @dev Allows the admin to withdraw any token from the contract.\\n     * @param tokenAddress The address of the token to withdraw.\\n     * @param user The address to send the withdrawn tokens to.\\n     * @param amount The amount of tokens to withdraw.\\n     */\\n    function withdrawToken(\\n        address tokenAddress,\\n        address user,\\n        uint256 amount\\n    ) external onlyAdmin {\\n        require(\\n            block.timestamp >= lastWithdrawTimestamp + withdrawTimelock,\\n            \\\"Admin withdraw timelock in progress\\\"\\n        );\\n        IERC20 token = IERC20(tokenAddress);\\n        require(\\n            token.balanceOf(address(this)) >= amount,\\n            \\\"Insufficient contract balance\\\"\\n        );\\n\\n        // Transfer the tokens from contract to the user\\n        require(token.transfer(user, amount), \\\"Token transfer failed\\\");\\n\\n        // Update the last withdrawal timestamp\\n        lastWithdrawTimestamp = block.timestamp;\\n\\n        // Emit the event to record the withdrawal\\n        emit Withdrawal(user, tokenAddress, amount, block.timestamp);\\n    }\\n\\n    /**\\n     * @dev Allows the admin to withdraw BNB from the contract.\\n     * @param user The address to send the withdrawn BNB to.\\n     * @param amount The amount of BNB to withdraw in wei.\\n     */\\n    function withdrawBNB(\\n        address payable user,\\n        uint256 amount\\n    ) external onlyAdmin {\\n        require(\\n            block.timestamp >= lastWithdrawTimestamp + withdrawTimelock,\\n            \\\"Admin withdraw timelock in progress\\\"\\n        );\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Insufficient contract balance\\\"\\n        );\\n\\n        // Transfer the specified amount of BNB from contract to the user\\n        user.transfer(amount);\\n\\n        // Update the last withdrawal timestamp\\n        lastWithdrawTimestamp = block.timestamp;\\n\\n        // Emit the event to record the withdrawal\\n        emit Withdrawal(user, BNB_ADDRESS, amount, block.timestamp);\\n    }\\n\\n    /**\\n     * @dev Allows anyone to check the balance of a token in the contract.\\n     * @param tokenAddress The address of the token to check the balance of.\\n     * @return The balance of the specified token in the contract.\\n     */\\n    function contractTokensBalance(\\n        address tokenAddress\\n    ) external view returns (uint256) {\\n        IERC20 token = IERC20(tokenAddress);\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Allows anyone to view the transactions of a user.\\n     * @param user The address of the user whose transactions to view.\\n     * @return An array of the user's transactions.\\n     */\\n    function getUserTransactions(\\n        address user\\n    ) external view returns (Transaction[] memory) {\\n        return userTransactions[user];\\n    }\\n\\n    /**\\n     * @dev Allows the admin to update the withdraw time lock.\\n     * @param _newWithdrawTimelock The new withdraw time lock.\\n     */\\n    function updateWithdrawTimelock(\\n        uint256 _newWithdrawTimelock\\n    ) external onlyAdmin {\\n        withdrawTimelock = _newWithdrawTimelock;\\n    }\\n\\n    /**\\n     * @dev Allows the admin to nominate a new admin.\\n     * @param _newAdminCandidate The address of the new admin candidate.\\n     */\\n    function updateAdmin(address _newAdminCandidate) external onlyAdmin {\\n        require(_newAdminCandidate != address(0), \\\"Invalid address\\\");\\n        newAdminCandidate = _newAdminCandidate;\\n    }\\n\\n    /**\\n     * @dev Allows the new admin candidate to accept the admin role.\\n     */\\n    function acceptAdminRole() external {\\n        require(\\n            msg.sender == newAdminCandidate,\\n            \\\"Only new admin candidate can accept admin role\\\"\\n        );\\n        emit AdminUpdated(admin, newAdminCandidate);\\n        admin = newAdminCandidate;\\n        newAdminCandidate = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the admin to update the address of the CERT token.\\n     * @param _newCertTokenAddress The new address of the CERT token.\\n     */\\n    function updateCertTokenAddress(\\n        address _newCertTokenAddress\\n    ) external onlyAdmin {\\n        require(_newCertTokenAddress != address(0), \\\"Invalid address\\\");\\n        certTokenAddress = _newCertTokenAddress;\\n    }\\n\\n    /**\\n     * @dev Allows the admin to update the sell price of a token.\\n     * @param tokenAddress The address of the token to update the sell price for.\\n     * @param price The new sell price of the token.\\n     */\\n    function updateBuyPrice(\\n        address tokenAddress,\\n        uint256 price\\n    ) external onlyAdmin {\\n        require(tokenAddress != address(0), \\\"Invalid address\\\");\\n        require(price > 0, \\\"Price must be greater than 0\\\");\\n\\n        if (!allowedTokens[tokenAddress]) {\\n            allowedTokens[tokenAddress] = true;\\n            emit AllowToken(tokenAddress, true);\\n        }\\n\\n        buyPrices[tokenAddress] = price;\\n        emit BuyPriceUpdated(tokenAddress, price);\\n    }\\n\\n    /**\\n     * @dev Allows the admin to remove a token from the list of allowed tokens.\\n     * @param tokenAddress The address of the token to disallow.\\n     */\\n    function disallowToken(address tokenAddress) external onlyAdmin {\\n        require(tokenAddress != address(0), \\\"Invalid address\\\");\\n        allowedTokens[tokenAddress] = false;\\n        emit AllowToken(tokenAddress, false);\\n    }\\n\\n    /**\\n     * @dev Allows users to purchase CERT in exhange of specified tokens.\\n     * @param tokenAddress The address of the token to sell.\\n     * @param certAmount The amount of tokens to sell.\\n     */\\n    function buyCERT(\\n        address tokenAddress,\\n        uint256 certAmount\\n    ) external nonReentrant {\\n        require(\\n            certAmount >= minPurchaseAmount,\\n            \\\"Purchase amount below minimum limit\\\"\\n        );\\n        require(allowedTokens[tokenAddress], \\\"This token is not allowed\\\");\\n        require(\\n            buyPrices[tokenAddress] > 0,\\n            \\\"Token not available for buying or price not set\\\"\\n        );\\n        require(isBuyActive, \\\"Buying is currently disabled\\\");\\n        uint256 amount = calculateCertPrice(tokenAddress, certAmount);\\n\\n        IERC20 token = IERC20(tokenAddress);\\n        require(\\n            token.balanceOf(msg.sender) >= amount,\\n            \\\"Insufficient balance of Token A\\\"\\n        );\\n        require(\\n            token.allowance(msg.sender, address(this)) >= amount,\\n            \\\"Not enough Token A approved\\\"\\n        );\\n\\n        IERC20 certToken = IERC20(certTokenAddress);\\n        require(\\n            certToken.balanceOf(certWallet) >= certAmount,\\n            \\\"Insufficient CERT balance in admin wallet\\\"\\n        );\\n\\n        // Transfer the calculated amount of Token A from user to the contract\\n        require(\\n            token.transferFrom(msg.sender, address(this), amount),\\n            \\\"Token A transfer failed\\\"\\n        );\\n\\n        IERC20Metadata cert = IERC20Metadata(certTokenAddress);\\n        uint256 certAmountInDecimal = certAmount * 10 ** cert.decimals();\\n\\n        // Transfer the specified certAmount of CERT tokens from certWallet to the user\\n        require(\\n            certToken.transferFrom(certWallet, msg.sender, certAmountInDecimal),\\n            \\\"CERT Token transfer failed\\\"\\n        );\\n\\n        // Store the transaction details\\n        userTransactions[msg.sender].push(\\n            Transaction(msg.sender, certAmount, block.timestamp, true)\\n        );\\n\\n        // Emit the event to record the transaction\\n        emit Bought(\\n            msg.sender,\\n            tokenAddress,\\n            amount,\\n            certAmount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows users to purchase CERT in exhange of native tokens.\\n     * @param certAmount The amount of tokens to sell.\\n     */\\n\\n    function buyCERTwithBNB(uint256 certAmount) external payable nonReentrant {\\n        require(\\n            certAmount >= minPurchaseAmount,\\n            \\\"Purchase amount below minimum limit\\\"\\n        );\\n\\n        require(isBuyActive, \\\"Buying is currently disabled\\\");\\n        require(buyPrices[BNB_ADDRESS] > 0, \\\"BNB price not set\\\");\\n        uint256 amount = calculateCertPrice(BNB_ADDRESS, certAmount);\\n\\n        require(amount <= msg.value, \\\"Insufficient BNB sent\\\");\\n\\n        IERC20 certToken = IERC20(certTokenAddress);\\n        require(\\n            certToken.balanceOf(certWallet) >= certAmount,\\n            \\\"Insufficient CERT balance in admin wallet\\\"\\n        );\\n\\n        // Transfer the excess BNB back to the user if any\\n        if (msg.value > amount) {\\n            payable(msg.sender).transfer(msg.value - amount);\\n        }\\n\\n        IERC20Metadata cert = IERC20Metadata(certTokenAddress);\\n        uint256 certAmountInDecimal = certAmount * 10 ** cert.decimals();\\n\\n        // Transfer the specified certAmount of CERT tokens from certWallet to the user\\n        require(\\n            certToken.transferFrom(certWallet, msg.sender, certAmountInDecimal),\\n            \\\"CERT Token transfer failed\\\"\\n        );\\n\\n        // Store the transaction details\\n        userTransactions[msg.sender].push(\\n            Transaction(msg.sender, certAmount, block.timestamp, true)\\n        );\\n\\n        // Emit the event to record the transaction\\n        emit Bought(\\n            msg.sender,\\n            BNB_ADDRESS,\\n            amount,\\n            certAmount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows anyone to calculate the equivalent amount of a token for a specified amount of CERT tokens.\\n     * @param tokenAddress The address of the token to calculate the equivalent amount for.\\n     * @param certAmount The amount of CERT tokens.\\n     * @return The equivalent amount of the specified token.\\n     */\\n    function calculateCertPrice(\\n        address tokenAddress,\\n        uint256 certAmount\\n    ) public view returns (uint256) {\\n        require(buyPrices[tokenAddress] > 0, \\\"Price for the token is not set\\\");\\n        uint256 equivalentAmountForCert;\\n        if (tokenAddress == BNB_ADDRESS) {\\n            equivalentAmountForCert =\\n                (certAmount * 100 * (10 ** 18)) /\\n                buyPrices[tokenAddress];\\n        } else {\\n            // Calculate the equivalent amount of the specified token for the given certAmount\\n            IERC20Metadata token = IERC20Metadata(tokenAddress);\\n            equivalentAmountForCert =\\n                (certAmount * 100 * (10 ** uint256(token.decimals()))) /\\n                buyPrices[tokenAddress];\\n        }\\n\\n        return equivalentAmountForCert;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawTimelock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_certTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_certWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"AllowToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"certAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BuyPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSellActive\",\"type\":\"bool\"}],\"name\":\"BuyToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BNB_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptAdminRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"certAmount\",\"type\":\"uint256\"}],\"name\":\"buyCERT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"certAmount\",\"type\":\"uint256\"}],\"name\":\"buyCERTwithBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"certAmount\",\"type\":\"uint256\"}],\"name\":\"calculateCertPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"certTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"certWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"contractTokensBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"disallowToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"}],\"internalType\":\"struct TokenDeposit.Transaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBuyActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWithdrawTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPurchaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newAdminCandidate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleBuyActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdminCandidate\",\"type\":\"address\"}],\"name\":\"updateAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updateBuyPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCertTokenAddress\",\"type\":\"address\"}],\"name\":\"updateCertTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCertWallet\",\"type\":\"address\"}],\"name\":\"updateCertWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMinPurchaseAmount\",\"type\":\"uint256\"}],\"name\":\"updateMinPurchaseAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newWithdrawTimelock\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenDeposit", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000e100000000000000000000000003e675b7937e57b9826c361ab7d9c721df6f066e400000000000000000000000020fd1931bc2bf982bf889578cc45a89aaa544f6c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}