{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/base/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\nabstract contract Staking\\n{\\n    uint256 constant internal RATE_PRECISION=1e40;\\n\\n    uint256 public rewardRate;//\u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043d\u0430\u0433\u0440\u0430\u0434, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 1 ORN \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u0443 \u043d\u0430 \u0432\u0441\u0435\u0445 (\u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c 10**48)\\n\\n    struct UserState\\n    {\\n        uint256 stake;\\n        uint256 rateCumulative;\\n        uint256 reward;\\n        uint256 rewardWithdraw;\\n    }\\n\\n    uint256 public allStake; //\u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u0441\u0442\u0435\u0439\u043a\u043e\u0432\\n    mapping(address => UserState) public poolStake;//\u0441\u0442\u0435\u0439\u043a\u0438 \u043f\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\\n\\n    uint256 public rateCumulative;\\n    uint256 public rateTime;\\n    uint256 private rewardCumulativeTotal;//\u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u043d\u0430\u0433\u0440\u0430\u0434\\n\\n    event SetRewards(uint64 rewards, uint64 duration, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 timestamp);\\n    event Stake(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    event Unstake(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    event ClaimReward(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    \\n\\n    //  Set the overall reward\\n    function _setRewards(uint64 rewards, uint64 duration) internal\\n    {\\n        require(duration > 0, \\\"_setRewards: zero duration\\\");\\n\\n        _writeCumulative();\\n\\n        //  ORN / sec\\n        rewardRate = RATE_PRECISION * rewards / duration;\\n\\n        emit SetRewards(rewards, duration, rewardCumulativeTotal, rateCumulative, block.timestamp);\\n    }\\n\\n    //\u0420\u0430\u0441\u0447\u0435\u0442 \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u0443\u0440\u0441\u0430 \u043d\u0430\u0433\u0440\u0430\u0434\u044b\\n    function calcNewRate() public virtual view returns (uint256)\\n    {\\n        uint256 Rate=0;\\n        if(allStake>0)\\n        {\\n            Rate=rewardRate/allStake;\\n        }\\n\\n        return Rate*(block.timestamp-rateTime);\\n    }\\n\\n    function _writeCumulative() virtual internal\\n    {\\n        uint256 newRate = calcNewRate();\\n\\n        rewardCumulativeTotal += newRate*allStake/RATE_PRECISION;\\n        rateCumulative += newRate;\\n        rateTime=block.timestamp;\\n    }\\n\\n    function _stake(address account, uint256 amount) internal\\n    {\\n        require(amount>0,\\\"_stake: zero stake amount\\\");\\n\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n        item.reward=_calcReward(item, rateCumulative);\\n        item.stake += amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        allStake += amount;\\n\\n        emit Stake(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n    function _claimReward(address account, uint256 amount) internal\\n    {\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n\\n        item.reward=_calcReward(item, rateCumulative);\\n        require(item.reward - item.rewardWithdraw >= amount,\\\"Error claim amount\\\");\\n        item.rewardWithdraw += amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        emit ClaimReward(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n    function _unstake(address account, uint256 amount) internal\\n    {\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n        require(item.stake >= amount,\\\"Error unstake amount\\\");\\n        \\n        item.reward=_calcReward(item, rateCumulative);\\n        item.stake -= amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        allStake -= amount;\\n\\n        emit Unstake(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n\\n    function _calcReward(UserState memory item, uint256 _rateCumulative) internal pure returns (uint256)\\n    {\\n        return item.reward + (_rateCumulative-item.rateCumulative)*item.stake/RATE_PRECISION;\\n    }\\n\\n    function getReward(address account) public virtual view returns (uint256)\\n    {\\n        UserState memory item=poolStake[account];\\n        uint256 _rateCumulative = rateCumulative + calcNewRate();\\n        return _calcReward(item, _rateCumulative) - item.rewardWithdraw;\\n    }\\n\\n    function getStake(address account) public view returns (uint256)\\n    {\\n        return poolStake[account].stake;\\n    }\\n\\n    function getRewardWithdraw(address account) external view returns (uint256)\\n    {\\n        return poolStake[account].rewardWithdraw;\\n    }\\n\\n    function getRewardCumulative(address account) external view returns (uint256)\\n    {\\n        return getReward(account) + poolStake[account].rewardWithdraw;\\n    }\\n\\n    function getRewardCumulativeAll() public view returns (uint256)\\n    {\\n        uint256 newRate = calcNewRate();\\n        return rewardCumulativeTotal + newRate*allStake/RATE_PRECISION;\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/base/TWBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"../interfaces/ITWBalance.sol\\\";\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\n\\nabstract contract TWBalance is ITWBalance\\n{\\n\\n    mapping(address => TWItem) private twapUserMap;\\n    TWItem private twapTotalSupply;\\n\\n\\n\\n    //view\\n    function balanceOfTW(address user) public view returns (TWItem memory)\\n    {\\n        uint256 currentAmount=balanceOf0(user);\\n        return calcNewTW(twapUserMap[user], uint160(currentAmount));\\n    }\\n    function balanceOfAvg(address user, TWItem memory itemStart) view public returns (uint256)\\n    {\\n        TWItem memory itemNew=balanceOfTW(user);\\n        return avgAmount(itemStart,itemNew);\\n    }\\n\\n    function totalSupplyTW() public view returns (TWItem memory)\\n    {\\n        uint256 currentAmount=totalSupply0();\\n        return calcNewTW(twapTotalSupply, uint160(currentAmount));\\n    }\\n    function totalSupplyAvg(TWItem memory itemStart) view public returns (uint256)\\n    {\\n        TWItem memory itemNew=totalSupplyTW();\\n        return avgAmount(itemStart,itemNew);\\n    }\\n\\n\\n\\n    //internal\\n    function writeTWBalances(address user) internal\\n    {\\n        twapUserMap[user]=balanceOfTW(user);\\n        twapTotalSupply=totalSupplyTW();\\n    }\\n\\n    function calcNewTW(TWItem memory itemOld, uint160 amount)internal view returns (TWItem memory itemNew)\\n    {\\n        uint48 blockTimestamp = uint48(block.timestamp);\\n        uint48 timeElapsed = blockTimestamp - itemOld.timestamp;\\n        itemNew.amountTW = itemOld.amountTW + uint208(timeElapsed)*uint208(amount);\\n        itemNew.timestamp = blockTimestamp;\\n    }\\n\\n    function avgAmount(TWItem memory itemStart,TWItem memory itemNew) pure internal returns (uint256)\\n    {\\n        uint256 timeElapsed = uint256(itemNew.timestamp) - uint256(itemStart.timestamp);\\n        if(timeElapsed>0)\\n        {\\n            uint256 deltaTW=itemNew.amountTW-itemStart.amountTW;\\n            //return deltaTW/timeElapsed;//balance0\\n            return amountAt(deltaTW/timeElapsed, itemStart.timestamp+timeElapsed/2);//\u0431\u0430\u043b\u0430\u043d\u0441 \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u0441\u0435\u0440\u0435\u0434\u0438\u043d\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0430\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n\\n\\n    //virtual\\n    function balanceOf(address account) public view virtual returns (uint256);\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf0(address account) public view virtual returns (uint256);\\n    function totalSupply0() public view virtual returns (uint256);\\n    function amountAt(uint256 amount,uint256 time) public pure virtual returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Minimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Minimal ERC20 interface for Uniswap\\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\\ninterface IERC20Minimal {\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\\n    /// @param recipient The account that will receive the amount transferred\\n    /// @param amount The number of tokens to send from the sender to the recipient\\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the current allowance given to a spender by an owner\\n    /// @param owner The account of the token owner\\n    /// @param spender The account of the token spender\\n    /// @return The current allowance granted by `owner` to `spender`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\\n    /// @param amount The amount of tokens allowed to be used by `spender`\\n    /// @return Returns true for a successful approval, false for unsuccessful\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\\n    /// @param sender The account from which the transfer will be initiated\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\\n    /// @param value The amount of tokens that were transferred\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\\n    /// @param owner The account that approved spending of its tokens\\n    /// @param spender The account for which the spending allowance was modified\\n    /// @param value The new allowance from the owner to the spender\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrionVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IOrionVoting is IStaking\\n{\\n\\n    //admin\\n    function setSmart(address addr, bool bUse) external;\\n    function setRewards(uint64 rewards, uint64 duration) external;\\n    function addPool(address pool) external;\\n    function deletePool(address pool) external;\\n\\n\\n    //user\\n    function vote(address pool, uint256 amount) external;\\n    function voteArr(address[] calldata pools, uint256[] calldata amounts) external;\\n    function unvote(address pool, uint256 amount) external;\\n    function unvoteAll(address account) external;\\n\\n    //smart\\n    function claimReward(address pool, address to, uint256 amount) external;\\n\\n    //vew\\n    function countPool() external view returns (uint256);//number of pools\\n    function poolList(uint256) external view returns (address);//list of pools\\n    function poolIndex(address pool) external view returns (uint256);//whether there is a pool in the list (index numbers starting from 1)\\n    function users(address user) external view returns (uint256);//user votes across all pools\\n    function usersPool(address user,address pool) external view returns (uint256);//user votes by pool\\n    function smarts(address smart) external view returns (bool);//white list of trusted farm contracts\\n\\n    function veORN() external view returns (address);\\n    function ORN() external view returns (address);\\n\\n    function havePool(address account) external view returns (bool);\\n\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\ninterface IStaking\\n{\\n    //staking\\n    function getReward(address account) external view returns (uint256);\\n    function getStake(address account) external view returns (uint256);\\n    function allStake() external view returns (uint256);\\n    function rewardRate() external view returns (uint256);\\n    function rateCumulative() external view returns (uint256);\\n    function rateTime() external view returns (uint256);\\n\\n\\n    function getRewardWithdraw(address account) external view returns (uint256);\\n    function getRewardCumulative(address account) external view returns (uint256);\\n    function getRewardCumulativeAll() external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITWBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface ITWBalance\\n{\\n    struct TWItem\\n    {\\n        // the block timestamp\\n        uint48  timestamp;        \\n        // the amount accumulator, i.e. amount * time elapsed\\n        uint208 amountTW;\\n    }\\n\\n    /// @notice Returns the time weight (TW) amount of tokens in existence.\\n    function totalSupplyTW() external view returns (TWItem memory);\\n\\n    /// @notice Calculates the average aamount of tokens in existence from the specified TW period\\n    function totalSupplyAvg(TWItem memory itemStart) view external returns (uint256);\\n\\n    /// @notice Returns the time weight (TW) balance of a token\\n    /// @param user The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOfTW(address user) external view returns (TWItem memory);\\n    \\n    /// @notice Calculates the average address balance from the specified TW period\\n    function balanceOfAvg(address user, TWItem memory itemStart) view external returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IveORN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ITWBalance.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IveORN is ITWBalance,IStaking\\n{\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n    function totalSupply(uint256 ts) external view returns (uint256);\\n    function totalSupply0() external view returns (uint256);//balance on start timestamp\\n\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n    function balanceOf(address account, uint256 ts) external view returns (uint256);\\n    function balanceOf0(address account) external view returns (uint256);//balance on start timestamp\\n\\n    function balanceTokenOf(address account) external view  returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n    \\n    function name() pure external returns(string memory);\\n    function symbol() pure external returns(string memory);\\n \\n\\n    function ORN() external view returns (address);\\n\\n    function lockTime(address account) external view returns (uint48);\\n\\n    \\n    //staking ORN\\n    function create_lock(uint256 _value, uint256 _unlock_time) external;\\n    //function deposit_for(address _addr, uint256 _value) external;\\n    function increase_amount(uint256 _value) external;\\n    function increase_unlock_time(uint256 _unlock_time) external;\\n    function increase_unlock_period(uint256 unlock_period) external;\\n    function create_lock_period(uint256 _value, uint256 unlock_period) external;\\n\\n    function withdraw() external;\\n    function claimReward() external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.7;\\n\\nlibrary Math\\n{\\n    uint128 private constant MAX_64x64  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint128 private constant MAX_U64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    /// @notice Cast a int128 to a uint128, revert on overflow\\n    /// @param y The int128 to be casted\\n    /// @return z The casted integer, now type uint128\\n    function toUint128(int128 y) internal pure returns (uint128 z) {\\n        unchecked\\n        {\\n            require(y >= 0);\\n            z = uint128(y);\\n        }\\n    }\\n\\n    /// @notice Cast a uint128 to a int128, revert on overflow\\n    /// @param y The uint128 to be casted\\n    /// @return z The casted integer, now type int128\\n    function toInt128(uint128 y) internal pure returns (int128 z) {\\n        unchecked\\n        {\\n            require (y <= MAX_U64x64);\\n            z = int128(y);\\n        }\\n    }\\n\\n    //precision 64.0 -> 64.64\\n    function from_uint(uint256 x) internal pure returns (uint128) \\n    {\\n        unchecked \\n        {\\n            require (x <= 0x7FFFFFFFFFFFFFFF);\\n            return uint128(x << 64);\\n        }\\n    }\\n     \\n    function div18(uint128 x, uint128 y) internal pure returns (uint128) {\\n        unchecked {\\n        require (y != 0);\\n        uint256 result = (uint256 (x) * 10**18) / y;\\n        require (result <= MAX_64x64);\\n        return uint128 (result);\\n        }\\n    }\\n\\n\\n    /**\\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n     * zero.\\n     *\\n     * @param x unsigned 64.64-bit fixed point number\\n     * @param y unsigned 64.64-bit fixed point number\\n     * @return unsigned 64.64-bit fixed point number\\n     */\\n    function div256(uint256 x, uint128 y) internal pure returns (uint128) {\\n        unchecked {\\n        require (y != 0);\\n        uint256 result = ( (x) << 64) / y;\\n        require (result <= MAX_64x64);\\n        return uint128 (result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x * y rounding down.  Revert on overflow.\\n     *\\n     * @param x unsigned 64.64-bit fixed point number\\n     * @param y unsigned 64.64-bit fixed point number\\n     * @return unsigned 64.64-bit fixed point number\\n     */\\n    function mul256(uint256 x, uint128 y) internal pure returns (uint128) {\\n        unchecked {\\n        uint256 result = (x) * y >> 64;\\n        require (result <= MAX_64x64);\\n        return uint128 (result);\\n        }\\n    }\\n\\n\\n    /**\\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n     * zero.\\n     *\\n     * @param x unsigned 64.64-bit fixed point number\\n     * @param y unsigned 64.64-bit fixed point number\\n     * @return unsigned 64.64-bit fixed point number\\n     */\\n    function div(uint128 x, uint128 y) internal pure returns (uint128) {\\n        unchecked {\\n        require (y != 0);\\n        uint256 result = (uint256 (x) << 64) / y;\\n        require (result <= MAX_64x64);\\n        return uint128 (result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x * y rounding down.  Revert on overflow.\\n     *\\n     * @param x unsigned 64.64-bit fixed point number\\n     * @param y unsigned 64.64-bit fixed point number\\n     * @return unsigned 64.64-bit fixed point number\\n     */\\n    function mul(uint128 x, uint128 y) internal pure returns (uint128) {\\n        unchecked {\\n        uint256 result = uint256(x) * y >> 64;\\n        require (result <= MAX_64x64);\\n        return uint128 (result);\\n        }\\n    }\\n\\n\\n    function exp_2(uint128 x) internal pure returns (uint128) \\n    {\\n        return toUint128(exp_2(toInt128(x)));\\n    }\\n\\n    function sqrt(uint128 x) internal pure returns (uint128) \\n    {\\n       return sqrtu (uint256(x) << 64);\\n    }\\n\\n\\n    //lib\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    //  src from https://github.com/PaulRBerg/prb-math\\n    /// @param x0 The exponent as an unsigned 64.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 64.64-bit  fixed-point number.\\n    /// @custom:smtchecker abstract-function-nondet\\n    function exp_2(int128 x0) internal pure returns (int128) \\n    {\\n        unchecked {\\n            require (x0 < 0x400000000000000000); // Overflow\\n            require (x0 >= 0);\\n            uint256 x=uint128(x0);\\n\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            uint256 result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // The following logic multiplies the result by $\\\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\\n            //\\n            // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\\n            // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\\n            // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\\n            // we know that `x & 0xFF` is also 1.\\n            if (x & 0xFF00000000000000 > 0) {\\n                if (x & 0x8000000000000000 > 0) {\\n                    result = (result * 0x16A09E667F3BCC909) >> 64;\\n                }\\n                if (x & 0x4000000000000000 > 0) {\\n                    result = (result * 0x1306FE0A31B7152DF) >> 64;\\n                }\\n                if (x & 0x2000000000000000 > 0) {\\n                    result = (result * 0x1172B83C7D517ADCE) >> 64;\\n                }\\n                if (x & 0x1000000000000000 > 0) {\\n                    result = (result * 0x10B5586CF9890F62A) >> 64;\\n                }\\n                if (x & 0x800000000000000 > 0) {\\n                    result = (result * 0x1059B0D31585743AE) >> 64;\\n                }\\n                if (x & 0x400000000000000 > 0) {\\n                    result = (result * 0x102C9A3E778060EE7) >> 64;\\n                }\\n                if (x & 0x200000000000000 > 0) {\\n                    result = (result * 0x10163DA9FB33356D8) >> 64;\\n                }\\n                if (x & 0x100000000000000 > 0) {\\n                    result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n                }\\n            }\\n\\n            if (x & 0xFF000000000000 > 0) {\\n                if (x & 0x80000000000000 > 0) {\\n                    result = (result * 0x10058C86DA1C09EA2) >> 64;\\n                }\\n                if (x & 0x40000000000000 > 0) {\\n                    result = (result * 0x1002C605E2E8CEC50) >> 64;\\n                }\\n                if (x & 0x20000000000000 > 0) {\\n                    result = (result * 0x100162F3904051FA1) >> 64;\\n                }\\n                if (x & 0x10000000000000 > 0) {\\n                    result = (result * 0x1000B175EFFDC76BA) >> 64;\\n                }\\n                if (x & 0x8000000000000 > 0) {\\n                    result = (result * 0x100058BA01FB9F96D) >> 64;\\n                }\\n                if (x & 0x4000000000000 > 0) {\\n                    result = (result * 0x10002C5CC37DA9492) >> 64;\\n                }\\n                if (x & 0x2000000000000 > 0) {\\n                    result = (result * 0x1000162E525EE0547) >> 64;\\n                }\\n                if (x & 0x1000000000000 > 0) {\\n                    result = (result * 0x10000B17255775C04) >> 64;\\n                }\\n            }\\n\\n            if (x & 0xFF0000000000 > 0) {\\n                if (x & 0x800000000000 > 0) {\\n                    result = (result * 0x1000058B91B5BC9AE) >> 64;\\n                }\\n                if (x & 0x400000000000 > 0) {\\n                    result = (result * 0x100002C5C89D5EC6D) >> 64;\\n                }\\n                if (x & 0x200000000000 > 0) {\\n                    result = (result * 0x10000162E43F4F831) >> 64;\\n                }\\n                if (x & 0x100000000000 > 0) {\\n                    result = (result * 0x100000B1721BCFC9A) >> 64;\\n                }\\n                if (x & 0x80000000000 > 0) {\\n                    result = (result * 0x10000058B90CF1E6E) >> 64;\\n                }\\n                if (x & 0x40000000000 > 0) {\\n                    result = (result * 0x1000002C5C863B73F) >> 64;\\n                }\\n                if (x & 0x20000000000 > 0) {\\n                    result = (result * 0x100000162E430E5A2) >> 64;\\n                }\\n                if (x & 0x10000000000 > 0) {\\n                    result = (result * 0x1000000B172183551) >> 64;\\n                }\\n            }\\n\\n            if (x & 0xFF00000000 > 0) {\\n                if (x & 0x8000000000 > 0) {\\n                    result = (result * 0x100000058B90C0B49) >> 64;\\n                }\\n                if (x & 0x4000000000 > 0) {\\n                    result = (result * 0x10000002C5C8601CC) >> 64;\\n                }\\n                if (x & 0x2000000000 > 0) {\\n                    result = (result * 0x1000000162E42FFF0) >> 64;\\n                }\\n                if (x & 0x1000000000 > 0) {\\n                    result = (result * 0x10000000B17217FBB) >> 64;\\n                }\\n                if (x & 0x800000000 > 0) {\\n                    result = (result * 0x1000000058B90BFCE) >> 64;\\n                }\\n                if (x & 0x400000000 > 0) {\\n                    result = (result * 0x100000002C5C85FE3) >> 64;\\n                }\\n                if (x & 0x200000000 > 0) {\\n                    result = (result * 0x10000000162E42FF1) >> 64;\\n                }\\n                if (x & 0x100000000 > 0) {\\n                    result = (result * 0x100000000B17217F8) >> 64;\\n                }\\n            }\\n\\n            if (x & 0xFF000000 > 0) {\\n                if (x & 0x80000000 > 0) {\\n                    result = (result * 0x10000000058B90BFC) >> 64;\\n                }\\n                if (x & 0x40000000 > 0) {\\n                    result = (result * 0x1000000002C5C85FE) >> 64;\\n                }\\n                if (x & 0x20000000 > 0) {\\n                    result = (result * 0x100000000162E42FF) >> 64;\\n                }\\n                if (x & 0x10000000 > 0) {\\n                    result = (result * 0x1000000000B17217F) >> 64;\\n                }\\n                if (x & 0x8000000 > 0) {\\n                    result = (result * 0x100000000058B90C0) >> 64;\\n                }\\n                if (x & 0x4000000 > 0) {\\n                    result = (result * 0x10000000002C5C860) >> 64;\\n                }\\n                if (x & 0x2000000 > 0) {\\n                    result = (result * 0x1000000000162E430) >> 64;\\n                }\\n                if (x & 0x1000000 > 0) {\\n                    result = (result * 0x10000000000B17218) >> 64;\\n                }\\n            }\\n\\n            if (x & 0xFF0000 > 0) {\\n                if (x & 0x800000 > 0) {\\n                    result = (result * 0x1000000000058B90C) >> 64;\\n                }\\n                if (x & 0x400000 > 0) {\\n                    result = (result * 0x100000000002C5C86) >> 64;\\n                }\\n                if (x & 0x200000 > 0) {\\n                    result = (result * 0x10000000000162E43) >> 64;\\n                }\\n                if (x & 0x100000 > 0) {\\n                    result = (result * 0x100000000000B1721) >> 64;\\n                }\\n                if (x & 0x80000 > 0) {\\n                    result = (result * 0x10000000000058B91) >> 64;\\n                }\\n                if (x & 0x40000 > 0) {\\n                    result = (result * 0x1000000000002C5C8) >> 64;\\n                }\\n                if (x & 0x20000 > 0) {\\n                    result = (result * 0x100000000000162E4) >> 64;\\n                }\\n                if (x & 0x10000 > 0) {\\n                    result = (result * 0x1000000000000B172) >> 64;\\n                }\\n            }\\n\\n            if (x & 0xFF00 > 0) {\\n                if (x & 0x8000 > 0) {\\n                    result = (result * 0x100000000000058B9) >> 64;\\n                }\\n                if (x & 0x4000 > 0) {\\n                    result = (result * 0x10000000000002C5D) >> 64;\\n                }\\n                if (x & 0x2000 > 0) {\\n                    result = (result * 0x1000000000000162E) >> 64;\\n                }\\n                if (x & 0x1000 > 0) {\\n                    result = (result * 0x10000000000000B17) >> 64;\\n                }\\n                if (x & 0x800 > 0) {\\n                    result = (result * 0x1000000000000058C) >> 64;\\n                }\\n                if (x & 0x400 > 0) {\\n                    result = (result * 0x100000000000002C6) >> 64;\\n                }\\n                if (x & 0x200 > 0) {\\n                    result = (result * 0x10000000000000163) >> 64;\\n                }\\n                if (x & 0x100 > 0) {\\n                    result = (result * 0x100000000000000B1) >> 64;\\n                }\\n            }\\n\\n            if (x & 0xFF > 0) {\\n                if (x & 0x80 > 0) {\\n                    result = (result * 0x10000000000000059) >> 64;\\n                }\\n                if (x & 0x40 > 0) {\\n                    result = (result * 0x1000000000000002C) >> 64;\\n                }\\n                if (x & 0x20 > 0) {\\n                    result = (result * 0x10000000000000016) >> 64;\\n                }\\n                if (x & 0x10 > 0) {\\n                    result = (result * 0x1000000000000000B) >> 64;\\n                }\\n                if (x & 0x8 > 0) {\\n                    result = (result * 0x10000000000000006) >> 64;\\n                }\\n                if (x & 0x4 > 0) {\\n                    result = (result * 0x10000000000000003) >> 64;\\n                }\\n                if (x & 0x2 > 0) {\\n                    result = (result * 0x10000000000000001) >> 64;\\n                }\\n                if (x & 0x1 > 0) {\\n                    result = (result * 0x10000000000000001) >> 64;\\n                }\\n            }\\n\\n            result >>= 127 - (x >> 64);\\n\\n            require (result <= uint256 (int256 (0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\\n\\n            return int128 (int256 (result));\\n\\n        }\\n    }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt0 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= 0);\\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    unchecked {\\n      if (x == 0) return 0;\\n      else {\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n        if (xx >= 0x4) { r <<= 1; }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return uint128 (r < r1 ? r : r1);\\n      }\\n    }\\n  }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.7;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/veORN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\nimport \\\"./base/Staking.sol\\\";\\nimport \\\"./base/TWBalance.sol\\\";\\n\\nimport \\\"./interfaces/IERC20Minimal.sol\\\";\\n\\nimport \\\"./interfaces/IveORN.sol\\\";\\nimport \\\"./interfaces/IOrionVoting.sol\\\";\\n\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\n\\ncontract veORN is TWBalance, Staking\\n{\\n    using Math for uint128;\\n    using Math for uint256;\\n\\n    uint256 public constant  START_TIME = 1690848000;//Aug 01 2023 00:00:00 UTC\\n    uint128 constant DAY = 86400;\\n    uint128 constant WEEK = 7 * 86400;\\n    uint128 constant YEAR = 365 * 86400;\\n    uint256 constant MAXTIME = 2 * YEAR;\\n\\n    uint128 constant public ALPHA7 = 0x268e511cc4915e0000;//ALPHA=730/(30-Math.sqrt(730/7))**(1/3)/7;\\n\\n\\n\\n    uint256 private totalSupplyT0;\\n    address public smartVote;\\n    \\n    uint8 public immutable decimals;\\n\\n\\n    address public immutable ORN;\\n    address public immutable smartOwner;\\n\\n    struct UserInfo\\n    {\\n        uint48  time_lock;\\n        uint128 balance;\\n        uint128 amount_token;\\n    }\\n\\n    mapping(address => UserInfo) private tokenMap;\\n\\n    event Deposit(address indexed provider, uint256 value, uint256 indexed locktime, int128 mode, uint256 ts);//old\\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\\n    event UpdateDeposit(address indexed provider, uint48  time_lock, uint128 balance, uint128 amount_token, uint256 value, uint256 totalSupplyT0, uint256 ts);\\n\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == smartOwner, \\\"Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    constructor(address ORN_)\\n    {\\n        ORN=ORN_;\\n        decimals=IERC20Minimal(ORN).decimals();\\n        smartOwner=msg.sender;\\n    }\\n\\n    //erc20\\n    function name() pure external returns(string memory)\\n    {\\n        return \\\"veORN\\\";\\n    }\\n    function symbol() pure external returns(string memory)\\n    {\\n        return \\\"veORN\\\";\\n    }\\n\\n\\n    function setSmartVote(address addrVote) onlyOwner external\\n    {\\n        smartVote=addrVote;\\n    }\\n    \\n\\n    //--------------------------------------Staking support\\n\\n    function setRewards(uint64 rewards, uint64 duration) onlyOwner external\\n    {\\n        _setRewards(rewards,duration);\\n    }\\n\\n    function claimReward() public\\n    {\\n        uint256 amount=getReward(msg.sender);\\n        if(amount>0)\\n        {\\n            _claimReward(msg.sender,amount);\\n\\n            TransferHelper.safeTransfer(ORN,msg.sender,amount);            \\n        }\\n    }\\n\\n    //internal\\n    function unstake(uint256 amount) internal\\n    {\\n        claimReward();\\n        _unstake(msg.sender, amount);\\n    }\\n\\n\\n\\n    //--------------------------------------Exp Balance support\\n\\n    //util\\n\\n    function getK(uint256 time) public pure returns (uint128) \\n    {\\n        if(time<START_TIME)\\n            time=START_TIME;\\n        uint128 deltaYears=(time-START_TIME).from_uint()/YEAR;\\n        return Math.exp_2(deltaYears*2);\\n    }\\n    \\n    function amountAt(uint256 amount,uint256 time) public pure override returns (uint256) \\n    {\\n        return amount.div256(getK(time));\\n    }\\n    \\n    function amountByTokenAt(uint128 amount_token,uint256 time_lock) public view returns (uint128 balance) \\n    {\\n        uint128 K1=getK(block.timestamp);\\n\\n        uint128 deltaWeeks=(time_lock-block.timestamp).from_uint()/WEEK;\\n        //balance=amount_token.mul(Math.sqrt(deltaWeeks)).mul(K1);\\n\\n        uint128 MultiplicatorSQRT=Math.sqrt(deltaWeeks);\\n        uint128 Multiplicator1=deltaWeeks.div(ALPHA7);\\n        uint128 Multiplicator2=Multiplicator1.mul(Multiplicator1);\\n        uint128 Multiplicator3=Multiplicator2.mul(Multiplicator1);\\n\\n        balance=amount_token.mul(MultiplicatorSQRT + Multiplicator3).mul(K1);\\n    }\\n\\n\\n\\n    //view\\n\\n    function totalSupply0() public view override returns (uint256) {\\n        return totalSupplyT0;\\n    }\\n    function balanceOf0(address account) public view override returns (uint256) {\\n        return tokenMap[account].balance;\\n    }\\n    function balanceTokenOf(address account) public view  returns (uint256) {\\n        return tokenMap[account].amount_token ;\\n    }\\n    \\n    function totalSupply() public view override returns (uint256) {\\n        return amountAt(totalSupply0(),block.timestamp);\\n    }\\n    function balanceOf(address account) public view override  returns (uint256) {\\n        return amountAt(balanceOf0(account),block.timestamp);\\n    }\\n    function totalSupply(uint256 time) external view returns (uint256) {\\n        return amountAt(totalSupply0(),time);\\n    }\\n    function balanceOf(address account,uint256 time) external view returns (uint256) {\\n        return amountAt(balanceOf0(account),time);\\n    }\\n\\n    function lockTime(address account) external view returns (uint48) {\\n        return tokenMap[account].time_lock;\\n    }\\n\\n    //external\\n    \\n    function create_lock(uint256 _value, uint256 unlock_time) public\\n    {\\n        UserInfo memory item=tokenMap[msg.sender];\\n\\n        require(_value > 0,\\\"need non-zero value\\\");\\n        require(item.amount_token == 0, \\\"Withdraw old tokens first\\\");\\n        require(unlock_time > block.timestamp, \\\"Can only lock until time in the future\\\");\\n        require(unlock_time <= block.timestamp + MAXTIME, \\\"Voting lock can be 2 years max\\\");\\n        require(unlock_time >= block.timestamp + WEEK, \\\"Voting lock can be 1 week min\\\");\\n\\n        _deposit_for(msg.sender, _value, unlock_time);\\n    }\\n\\n\\n    function increase_amount(uint256 _value) external\\n    {\\n        UserInfo memory item=tokenMap[msg.sender];\\n\\n        require(_value > 0,\\\"need non-zero value\\\");\\n        require(item.amount_token > 0, \\\"No existing lock found\\\");\\n        require(item.time_lock > block.timestamp, \\\"Cannot add to expired lock\\\");\\n\\n        _deposit_for(msg.sender, _value, 0);\\n    }\\n\\n    function increase_unlock_time(uint256 unlock_time) public\\n    {\\n        UserInfo memory item=tokenMap[msg.sender];\\n        //require(item.time_lock > block.timestamp, \\\"Lock expired\\\"); - \u0443\u0431\u0440\u0430\u043d\u043e \u0447\u0442\u043e\u0431\u044b \u0443\u043c\u0435\u043d\u044c\u0448\u0438\u0442\u044c \u0447\u0438\u0441\u043b\u043e \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439 \u0434\u043b\u044f \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0433\u043e \u0441\u0442\u0435\u0439\u043a\u0438\u043d\u0433\u0430\\n        require(item.amount_token > 0, \\\"No existing lock found\\\");\\n\\n        require(unlock_time > item.time_lock, \\\"Can only increase lock duration\\\");\\n        require(unlock_time <= block.timestamp + MAXTIME, \\\"Voting lock can be 2 years max\\\");\\n        require(unlock_time >= block.timestamp + WEEK, \\\"Voting lock can be 1 week min\\\");\\n\\n        _deposit_for(msg.sender, 0, unlock_time);\\n    }\\n    function increase_unlock_period(uint256 unlock_period) external\\n    {\\n        increase_unlock_time(block.timestamp + unlock_period);\\n    }\\n    function create_lock_period(uint256 _value, uint256 unlock_period) external\\n    {\\n        create_lock(_value, block.timestamp + unlock_period);\\n    }\\n\\n\\n    function withdraw() external\\n    {\\n        writeTWBalances(msg.sender);\\n\\n        UserInfo memory item=tokenMap[msg.sender];\\n        require(block.timestamp >= item.time_lock, \\\"The lock didn't expire\\\");\\n\\n        //automatic removal of all votes\\n        if(smartVote != address(0))\\n            IOrionVoting(smartVote).unvoteAll(msg.sender);\\n\\n        //staking\\n        unstake(item.balance);\\n\\n        uint256 balance=item.amount_token;\\n        totalSupplyT0 -= item.balance;\\n        delete tokenMap[msg.sender];\\n\\n        TransferHelper.safeTransfer(ORN,msg.sender,balance);\\n\\n        emit Withdraw(msg.sender, balance, block.timestamp);\\n    }\\n\\n    //internal\\n    function _deposit_for(address account, uint256 value, uint256 unlock_time) internal\\n    {\\n        writeTWBalances(account);\\n\\n\\n        UserInfo storage item=tokenMap[account];\\n\\n\\n        uint128 delta;\\n\\n        if(unlock_time>0)\\n        {\\n            item.time_lock=uint48(unlock_time);\\n            item.amount_token += uint128(value);\\n            uint128 balance=amountByTokenAt(item.amount_token, item.time_lock);\\n\\n            require(balance > item.balance,\\\"_deposit_for: Only increase amount\\\");\\n\\n            delta = balance-item.balance;\\n        }\\n        else\\n        {\\n            item.amount_token += uint128(value);\\n            delta=amountByTokenAt(uint128(value), item.time_lock);\\n        }\\n\\n        //staking\\n        _stake(account, delta);\\n\\n        item.balance += delta;\\n        totalSupplyT0 += delta;\\n\\n        if(value>0)\\n        {\\n            TransferHelper.safeTransferFrom(ORN,msg.sender,address(this),value);\\n        }\\n\\n        //emit Deposit(account, value, item.time_lock, mode, block.timestamp);//old\\n        emit UpdateDeposit(account, item.time_lock, item.balance, item.amount_token, value, totalSupplyT0, block.timestamp);\\n        \\n    }\\n\\n\\n \\n}\\n\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ORN_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"locktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"mode\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"rewards\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SetRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"time_lock\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"balance\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount_token\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupplyT0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"UpdateDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ALPHA7\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"START_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"amountAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount_token\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"time_lock\",\"type\":\"uint256\"}],\"name\":\"amountByTokenAt\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"balance\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"timestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint208\",\"name\":\"amountTW\",\"type\":\"uint208\"}],\"internalType\":\"struct ITWBalance.TWItem\",\"name\":\"itemStart\",\"type\":\"tuple\"}],\"name\":\"balanceOfAvg\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOfTW\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"timestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint208\",\"name\":\"amountTW\",\"type\":\"uint208\"}],\"internalType\":\"struct ITWBalance.TWItem\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceTokenOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcNewRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlock_time\",\"type\":\"uint256\"}],\"name\":\"create_lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlock_period\",\"type\":\"uint256\"}],\"name\":\"create_lock_period\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getK\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardCumulativeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"increase_amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unlock_period\",\"type\":\"uint256\"}],\"name\":\"increase_unlock_period\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unlock_time\",\"type\":\"uint256\"}],\"name\":\"increase_unlock_time\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rewards\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"}],\"name\":\"setRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addrVote\",\"type\":\"address\"}],\"name\":\"setSmartVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"timestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint208\",\"name\":\"amountTW\",\"type\":\"uint208\"}],\"internalType\":\"struct ITWBalance.TWItem\",\"name\":\"itemStart\",\"type\":\"tuple\"}],\"name\":\"totalSupplyAvg\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyTW\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"timestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint208\",\"name\":\"amountTW\",\"type\":\"uint208\"}],\"internalType\":\"struct ITWBalance.TWItem\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "veORN", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e4ca1f75eca6214393fce1c1b316c237664eaa8e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}