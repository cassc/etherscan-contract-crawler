{"SourceCode": "pragma solidity ^0.8.6;\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\n/*    \r\n\r\n  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\r\n  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\r\n  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\r\n  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\r\n  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\r\n  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\r\n\r\n  Blubber Coin - A reflection heavy token that rewards recent buyers\r\n  Website: Blubber.info\r\n\r\n  \u2b50RSP\u2b50\r\n*/\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"Sub error\"); return a - b;}\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size > 0;}\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");(bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {return functionCall(target, data, \"Address: low-level call failed\");}\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {return functionCallWithValue(target, data, 0, errorMessage);}\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");}\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) { return returndata; } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {revert(errorMessage);}\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    function getUnlockTime() public view returns (uint256) {\r\n        return _lockTime;\r\n    }\r\n    function lock(uint256 time) public virtual onlyOwner {\r\n        _previousOwner = _owner;\r\n        _owner = address(0);\r\n        _lockTime = block.timestamp + time;\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n    function unlock() public virtual {\r\n        require(_previousOwner == msg.sender, \"Only the previous owner can unlock onwership\");\r\n        require(block.timestamp > _lockTime , \"The contract is still locked\");\r\n        emit OwnershipTransferred(_owner, _previousOwner);\r\n        _owner = _previousOwner;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\tfunction feeTo() external view returns (address);\r\n\tfunction feeToSetter() external view returns (address);\r\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\tfunction allPairs(uint) external view returns (address pair);\r\n\tfunction allPairsLength() external view returns (uint);\r\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n\tfunction setFeeTo(address) external;\r\n\tfunction setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tfunction name() external pure returns (string memory);\r\n\tfunction symbol() external pure returns (string memory);\r\n\tfunction decimals() external pure returns (uint8);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\tevent Mint(address indexed sender, uint amount0, uint amount1);\r\n\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n\tevent Swap(address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to);\r\n\tevent Sync(uint112 reserve0, uint112 reserve1);\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\tfunction factory() external view returns (address);\r\n\tfunction token0() external view returns (address);\r\n\tfunction token1() external view returns (address);\r\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\tfunction price0CumulativeLast() external view returns (uint);\r\n\tfunction price1CumulativeLast() external view returns (uint);\r\n\tfunction kLast() external view returns (uint);\r\n\tfunction mint(address to) external returns (uint liquidity);\r\n\tfunction burn(address to) external returns (uint amount0, uint amount1);\r\n\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\tfunction initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n\tfunction factory() external pure returns (address);\r\n\tfunction WETH() external pure returns (address);\r\n\tfunction addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline\r\n\t) external returns (uint amountA, uint amountB, uint liquidity);\r\n\tfunction addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline\r\n\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\tfunction removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline\r\n\t) external returns (uint amountA, uint amountB);\r\n\tfunction removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline\r\n\t) external returns (uint amountToken, uint amountETH);\r\n\tfunction removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t) external returns (uint amountA, uint amountB);\r\n\tfunction removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t) external returns (uint amountToken, uint amountETH);\r\n\tfunction swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline\r\n\t) external returns (uint[] memory amounts);\r\n\tfunction swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline\r\n\t) external returns (uint[] memory amounts);\r\n\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n\tfunction removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline\r\n\t) external returns (uint amountETH);\r\n\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t) external returns (uint amountETH);\r\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline\r\n\t) external;\r\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline\r\n\t) external payable;\r\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline\r\n\t) external;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n  * The main contract\r\n  */\r\ncontract BlubberCoin is IERC20, IERC20Metadata, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _walletBalance;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    string private _name = 'BlubberCoin';\r\n    string private _symbol = 'BLUB';\r\n    uint8 private _decimals = 0;\r\n\r\n    // TEST\r\n    //address public _routerAddress = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\r\n\r\n    // MAIN\r\n    address public _routerAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    address private _burnAddress = 0x000000000000000000000000000000000000dEaD;\r\n    address payable public _taxWallet = payable(0x1caE6803f3312CC17ddB8A75a8b75071f44746BD);\r\n    address payable public _liqWallet = payable(0x1caE6803f3312CC17ddB8A75a8b75071f44746BD);\r\n\r\n    uint256 public constant _supplyTotal = 100000000000000;\r\n    uint256 public _maxTxPercent = 3;\r\n\r\n    // Set number of tokens to trigger swap at\r\n    uint256 public tokensToLiquifyAt     = 1000000000000;\r\n    uint256 public tokensToMarketAt      = 1000000000000;\r\n\r\n    uint256 public _taxTaxS     = 15;\r\n    uint256 public _refTaxS     = 10;\r\n    uint256 public _liqTaxS     = 0;\r\n    uint256 public _burnTaxS    = 5;\r\n    uint256 public _taxTaxB     = 5;\r\n    uint256 public _refTaxB     = 10;\r\n    uint256 public _liqTaxB     = 0;\r\n    uint256 public _burnTaxB    = 0;\r\n    uint256 public _taxTaxT     = 5;\r\n    uint256 public _refTaxT     = 10;\r\n    uint256 public _liqTaxT     = 0;\r\n    uint256 public _burnTaxT    = 5;\r\n\r\n    uint256 public _minRefBuy   = 1000000000000;\r\n    uint256 public _maxRefLen   = 50;\r\n    uint256 public _curRefLen   = 0;\r\n\r\n    uint256 public liqCount   = 0;\r\n    uint256 public taxCount   = 0;\r\n\r\n    bool public swapOnSell = false;\r\n    bool public inSwap = false;\r\n\r\n    bool public _taxSellEnabled = true;\r\n    bool public _taxBuyEnabled = true;\r\n    bool public _taxTranEnabled = true;\r\n    bool private doTaxes = true;\r\n\r\n    address[] private isReflection;\r\n    mapping (address => bool) private _isTaxExempt;\r\n\r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    address public immutable uniswapV2Pair;\r\n\r\n    event SwapTokensForETH(\r\n        uint256 amountIn,\r\n        address[] path\r\n    );\r\n    event RouterSet(address indexed router);\r\n\r\n    constructor() {\r\n        _walletBalance[_msgSender()] = _supplyTotal;\r\n        emit Transfer(address(0), _msgSender(), _supplyTotal);\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(_routerAddress);\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), _uniswapV2Router.WETH());\r\n\r\n        uniswapV2Router = _uniswapV2Router;\r\n\r\n        _isTaxExempt[_msgSender()] = true;\r\n        _isTaxExempt[_burnAddress] = true;\r\n        _isTaxExempt[_taxWallet] = true;\r\n        _isTaxExempt[_liqWallet] = true;\r\n        _isTaxExempt[_routerAddress] = true;\r\n    }\r\n\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _walletBalance[account];\r\n    }\r\n\r\n    function totalSupply() public pure override returns (uint256) {\r\n        return _supplyTotal;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }   \r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function changeRouterAddress(address newRouterAddress) public virtual onlyOwner {\r\n        _routerAddress = newRouterAddress;\r\n    }\r\n    function changeTaxTaxS(uint256 newTax) public virtual onlyOwner {\r\n        _taxTaxS = newTax;\r\n    }\r\n    function changeRefTaxS(uint256 newTax) public virtual onlyOwner {\r\n        _refTaxS = newTax;\r\n    }\r\n    function changeLiqTaxS(uint256 newTax) public virtual onlyOwner {\r\n        _liqTaxS = newTax;\r\n    }\r\n    function changeBurnTaxS(uint256 newTax) public virtual onlyOwner {\r\n        _burnTaxS = newTax;\r\n    }\r\n    function changTaxTaxB(uint256 newTax) public virtual onlyOwner {\r\n        _taxTaxB = newTax;\r\n    }\r\n    function changeRefTaxB(uint256 newTax) public virtual onlyOwner {\r\n        _refTaxB = newTax;\r\n    }\r\n    function changeLiqTaxB(uint256 newTax) public virtual onlyOwner {\r\n        _liqTaxB = newTax;\r\n    }\r\n    function changeBurnTaxB(uint256 newTax) public virtual onlyOwner {\r\n        _burnTaxB = newTax;\r\n    }\r\n    function changeTaxTaxT(uint256 newTax) public virtual onlyOwner {\r\n        _taxTaxT = newTax;\r\n    }\r\n    function changeRefTaxT(uint256 newTax) public virtual onlyOwner {\r\n        _refTaxT = newTax;\r\n    }\r\n    function changeLiqTaxT(uint256 newTax) public virtual onlyOwner {\r\n        _liqTaxT = newTax;\r\n    }\r\n    function changeBurnTaxT(uint256 newTax) public virtual onlyOwner {\r\n        _burnTaxT = newTax;\r\n    }\r\n    function changeMaxRefLen(uint256 newLen) public virtual onlyOwner {\r\n        _maxRefLen = newLen;\r\n    }\r\n    function changeMinRefBuy(uint256 newMinTokensForRef) public virtual onlyOwner {\r\n        _minRefBuy = newMinTokensForRef;\r\n    }\r\n    function changeTaxSellEnabled(bool newTaxStat) public virtual onlyOwner {\r\n        _taxSellEnabled = newTaxStat;\r\n    }\r\n    function changeTaxBuyEnabled(bool newTaxStat) public virtual onlyOwner {\r\n        _taxBuyEnabled = newTaxStat;\r\n    }\r\n    function changeSwapOnSell(bool newSwapOnSell) public virtual onlyOwner {\r\n        swapOnSell = newSwapOnSell;\r\n    }\r\n    function changeTaxTranEnabled(bool newTaxStat) public virtual onlyOwner {\r\n        _taxTranEnabled = newTaxStat;\r\n    }\r\n    function changeLiqTokens(uint256 newtokensToLiquifyAt) public virtual onlyOwner {\r\n        tokensToLiquifyAt = newtokensToLiquifyAt;\r\n    }\r\n    function changeMarketTokens(uint256 newtokensToMarketAt) public virtual onlyOwner {\r\n        tokensToMarketAt = newtokensToMarketAt;\r\n    }\r\n    function changeMaxTxPercent(uint256 newMaxTxPercent) public virtual onlyOwner {\r\n        _maxTxPercent = newMaxTxPercent;\r\n    }\r\n    function getIsReflection() public view returns (address  [] memory) {\r\n        return isReflection;\r\n    }\r\n\r\n    function isTaxExempt(address account) public view returns (bool) {\r\n        return _isTaxExempt[account];\r\n    }\r\n\r\n    function changeTaxWallet(address payable newTaxWallet) public virtual onlyOwner {\r\n        _taxWallet = newTaxWallet;\r\n    }\r\n\r\n    function changeLiqWallet(address payable newTaxWallet) public virtual onlyOwner {\r\n        _liqWallet = newTaxWallet;\r\n    }\r\n\r\n    function addTaxExempt(address account) external onlyOwner() {\r\n        require(!_isTaxExempt[account], \"Account is already tax exempt\");\r\n        _isTaxExempt[account] = true; \r\n    }\r\n\r\n    function removeTaxExempt(address account) external onlyOwner() {\r\n        require(_isTaxExempt[account], \"Account is not tax exempt\");\r\n        _isTaxExempt[account] = false;\r\n    }\r\n\r\n    function emptyContractWallet(address account, uint256 tokenAmount) external onlyOwner() {\r\n        _walletBalance[account] = _walletBalance[account].add(tokenAmount);  \r\n        _walletBalance[address(this)] = _walletBalance[address(this)].sub(tokenAmount);     \r\n        emit Transfer(address(this), account, tokenAmount);\r\n    }\r\n\r\n    function resetReflectors() external onlyOwner() {\r\n        _curRefLen = 0;\r\n        delete isReflection;\r\n    }\r\n\r\n    function addReflectors(address newReflec) external onlyOwner() {\r\n        _curRefLen = _curRefLen + 1;\r\n        isReflection.push(newReflec);\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount, address sendTo) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        _approve(sendTo, address(uniswapV2Router), tokenAmount);\r\n\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            sendTo,\r\n            block.timestamp\r\n        );\r\n\r\n        emit SwapTokensForETH(tokenAmount, path);\r\n\r\n        inSwap = false;\r\n    }\r\n\r\n    function isRef(address checkAd) public view returns (bool) {\r\n        uint256 refLen = isReflection.length;\r\n        for (uint256 i=0; i<refLen; i++) {\r\n            if(isReflection[i] == checkAd) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(sender != address(_burnAddress), \"BaseRfiToken: transfer from the burn address\");\r\n\r\n        if(sender != owner()){\r\n            require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        }\r\n        \r\n        uint256 newAmount = amount;\r\n        uint256 _refTax = 0;\r\n        uint256 _liqTax = 0;\r\n        uint256 _burnTax = 0;\r\n        uint256 _taxTax = 0;   \r\n        \r\n        doTaxes = true;\r\n\r\n        if (inSwap){\r\n            doTaxes = false;\r\n        }\r\n\r\n        // Calculate max TX amount\r\n        uint256 totalTxAmount = _supplyTotal.div(100).mul(_maxTxPercent);\r\n        if(recipient != owner() && sender != owner() && !isTaxExempt(sender) && !isTaxExempt(recipient) && doTaxes) { \r\n            if(amount > totalTxAmount) {\r\n                revert(\"Transfer amount exceeds the maxTxPercent.\");\r\n            }\r\n        }\r\n\r\n        // BUY on PancakeSwap\r\n        if(sender == uniswapV2Pair) {\r\n            if (isTaxExempt(recipient) || !_taxBuyEnabled){\r\n                doTaxes = false;\r\n            }\r\n\r\n            _refTax = _refTaxB;\r\n            _liqTax = _liqTaxB;\r\n            _burnTax = _burnTaxB;\r\n            _taxTax = _taxTaxB;\r\n\r\n            // Add buyer to list of reflectors\r\n            uint256 refLen = isReflection.length;\r\n            if (_minRefBuy <= amount) {\r\n                if (!isRef(recipient)){\r\n                    if (refLen >= _maxRefLen){\r\n                        if (_curRefLen >= _maxRefLen) {\r\n                            _curRefLen = 0;\r\n                        }\r\n                        // Overwrite old reflector on list with new one\r\n                        isReflection[_curRefLen] = recipient;\r\n                        _curRefLen = _curRefLen + 1;\r\n                    } else {\r\n                        // Array isn't full - just add them\r\n                        isReflection.push(recipient);\r\n                    }\r\n                } \r\n            }\r\n        }\r\n\r\n        // SELL on PancakeSwap\r\n        if(recipient == uniswapV2Pair) {\r\n            if (isTaxExempt(sender) || !_taxSellEnabled){\r\n                doTaxes = false;\r\n            }\r\n\r\n            _refTax = _refTaxS;\r\n            _liqTax = _liqTaxS;\r\n            _burnTax = _burnTaxS;\r\n            _taxTax = _taxTaxS; \r\n            \r\n            if (swapOnSell && !inSwap){\r\n                // Run liquidity adder\r\n                if (balanceOf(address(this)) >= tokensToLiquifyAt && liqCount >= tokensToLiquifyAt) {\r\n                    inSwap = true;\r\n                    swapTokensForEth(tokensToLiquifyAt, _liqWallet);\r\n                    liqCount = 0;\r\n                }\r\n\r\n                // Run marketing swapper\r\n                if (balanceOf(address(this)) >= tokensToMarketAt && taxCount >= tokensToMarketAt) {\r\n                    inSwap = true;\r\n                    swapTokensForEth(tokensToMarketAt, _taxWallet);\r\n                    taxCount = 0;\r\n                }\r\n            }\r\n\r\n            // Remove seller from list of reflectors\r\n            if (isRef(sender)){\r\n                for (uint256 i=0; i<isReflection.length; i++) {\r\n                    if(isReflection[i] == sender) {\r\n                        isReflection[i] = address(this);\r\n                    }\r\n                }\r\n            } \r\n        }\r\n\r\n        // TRANSFER tokens\r\n        if (sender != uniswapV2Pair && recipient != uniswapV2Pair){\r\n            if (isTaxExempt(sender) || isTaxExempt(recipient) || !_taxTranEnabled){\r\n                doTaxes = false;\r\n            }\r\n\r\n            _refTax = _refTaxT;\r\n            _liqTax = _liqTaxT;\r\n            _burnTax = _burnTaxT;\r\n            _taxTax = _taxTaxT; \r\n        }\r\n\r\n        // ALL TAXES\r\n        if (doTaxes){\r\n \r\n            // REFLECTION\r\n            if (_refTax > 0){\r\n                uint256 reflectAmount = amount.div(100).mul(_refTax);\r\n\r\n                if (_walletBalance[sender] >= reflectAmount){\r\n                    uint256 refLen = isReflection.length;\r\n\r\n                    if (refLen > 0){\r\n                        uint256 reflectAmountPer = reflectAmount.div(refLen);\r\n\r\n                        for (uint256 i=0; i<refLen; i++) {\r\n                            if (address(isReflection[i]) != address(sender) && address(isReflection[i]) != address(recipient)) {\r\n                                _walletBalance[isReflection[i]] = _walletBalance[isReflection[i]].add(reflectAmountPer);\r\n                                emit Transfer(sender, isReflection[i], reflectAmountPer);\r\n                            }\r\n                        }\r\n\r\n                        newAmount = newAmount.sub(reflectAmount);\r\n                    }\r\n                }\r\n            }\r\n\r\n         \r\n\r\n            // BURN\r\n            if (_burnTax > 0){\r\n                uint256 burnAmount = amount.div(100).mul(_burnTax);\r\n            \r\n                _walletBalance[_burnAddress] = _walletBalance[_burnAddress].add(burnAmount);\r\n\r\n                emit Transfer(sender, _burnAddress, burnAmount);\r\n                newAmount = newAmount.sub(burnAmount);\r\n            }\r\n\r\n            // TAX\r\n            if (_taxTax > 0){\r\n                uint256 taxAmount = amount.div(100).mul(_taxTax);\r\n                \r\n                _walletBalance[address(this)] = _walletBalance[address(this)].add(taxAmount);\r\n                taxCount = taxCount.add(taxAmount);\r\n\r\n                emit Transfer(sender, address(this), taxAmount);\r\n                newAmount = newAmount.sub(taxAmount);\r\n            }\r\n\r\n            // LIQ\r\n            if (_liqTax > 0){\r\n                uint256 liquidityAmount = amount.div(100).mul(_liqTax);\r\n                \r\n                _walletBalance[address(this)] = _walletBalance[address(this)].add(liquidityAmount);\r\n                liqCount = liqCount.add(liquidityAmount);\r\n\r\n                emit Transfer(sender, address(this), liquidityAmount);\r\n                newAmount = newAmount.sub(liquidityAmount);\r\n            }\r\n        }\r\n\r\n        // MAIN TRANSACTIION\r\n        _walletBalance[recipient] = _walletBalance[recipient].add(newAmount);  \r\n        _walletBalance[sender] = _walletBalance[sender].sub(amount);     \r\n        emit Transfer(sender, recipient, newAmount);\r\n\r\n        // SELL on PancakeSwap\r\n        if(recipient == uniswapV2Pair) {          \r\n\r\n            if (_walletBalance[sender] <= 0){\r\n                _walletBalance[sender] = 3;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"RouterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapTokensForETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_burnTaxB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnTaxS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnTaxT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_curRefLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liqTaxB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liqTaxS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liqTaxT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liqWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxRefLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minRefBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_refTaxB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_refTaxS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_refTaxT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_routerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_supplyTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxBuyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxSellEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxTaxB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxTaxS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxTaxT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxTranEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReflec\",\"type\":\"address\"}],\"name\":\"addReflectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addTaxExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changTaxTaxB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeBurnTaxB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeBurnTaxS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeBurnTaxT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeLiqTaxB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeLiqTaxS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeLiqTaxT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newtokensToLiquifyAt\",\"type\":\"uint256\"}],\"name\":\"changeLiqTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newTaxWallet\",\"type\":\"address\"}],\"name\":\"changeLiqWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newtokensToMarketAt\",\"type\":\"uint256\"}],\"name\":\"changeMarketTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLen\",\"type\":\"uint256\"}],\"name\":\"changeMaxRefLen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxTxPercent\",\"type\":\"uint256\"}],\"name\":\"changeMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinTokensForRef\",\"type\":\"uint256\"}],\"name\":\"changeMinRefBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeRefTaxB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeRefTaxS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeRefTaxT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouterAddress\",\"type\":\"address\"}],\"name\":\"changeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newSwapOnSell\",\"type\":\"bool\"}],\"name\":\"changeSwapOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newTaxStat\",\"type\":\"bool\"}],\"name\":\"changeTaxBuyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newTaxStat\",\"type\":\"bool\"}],\"name\":\"changeTaxSellEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeTaxTaxS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"changeTaxTaxT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newTaxStat\",\"type\":\"bool\"}],\"name\":\"changeTaxTranEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newTaxWallet\",\"type\":\"address\"}],\"name\":\"changeTaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"emptyContractWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIsReflection\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"checkAd\",\"type\":\"address\"}],\"name\":\"isRef\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isTaxExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liqCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeTaxExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetReflectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapOnSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensToLiquifyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensToMarketAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BlubberCoin", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://517d5db418db06e616b40dffe4cc91c04d72d10f1dbbb060a6d5a019b7b773de"}