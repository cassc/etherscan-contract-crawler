{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC20Token {\r\n    function transferFrom(address _from,address _to, uint _value) external returns (bool success);\r\n    function balanceOf(address _owner) external returns (uint balance);\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Deskillz is Ownable {\r\n    address busdAddress;\r\n    uint256 BUSDToLP;\r\n    uint256 public AdminShare;\r\n    constructor(address _busd, uint256 _BUSDToLP) {\r\n        busdAddress = _busd;\r\n        BUSDToLP = _BUSDToLP;\r\n    }\r\n    struct MatchScoreData {\r\n        uint256 winningPrize;\r\n        address player;\r\n        uint256 developerPrize;\r\n        address developer;\r\n        uint256 matchFees;\r\n        uint256 adminShare;\r\n        address[] players;\r\n        uint256[] loyaltyPoints;\r\n    }\r\n    using SafeMath for uint256;\r\n    mapping(address => uint256) loyaltyPoints;\r\n    mapping(address => uint256) developersBalances;\r\n    mapping(address => uint256) playersBalances;\r\n    \r\n    function depositFunds(uint256 _amount) external payable {\r\n        transferFromERC20(msg.sender, address(this), _amount, busdAddress);\r\n        uint256 playerBalance = playersBalances[msg.sender];\r\n        playersBalances[msg.sender] = playerBalance + _amount;\r\n    }\r\n    function withdrawPlayerFunds(uint256 _amount) external payable {\r\n        uint256 playerBalance = playersBalances[msg.sender];\r\n        require(playerBalance  >= _amount, \"Insufficient balance\");\r\n        transferERC20(msg.sender, _amount, busdAddress);\r\n        playersBalances[msg.sender] = playerBalance - _amount;\r\n    }\r\n    function withdrawDeveloperFunds(uint256 _amount) external payable {\r\n        uint256 developerBalance = developersBalances[msg.sender];\r\n        require(developerBalance  >= _amount, \"Insufficient balance\");\r\n        transferERC20(msg.sender, _amount, busdAddress);\r\n        developersBalances[msg.sender] = developerBalance - _amount;\r\n    }\r\n    function loyaltyPointsConversion(uint256 _amount) external {\r\n        require(loyaltyPoints[msg.sender] >= _amount, \"Not enough loyalty points\");\r\n        uint256 busd = calculateBUSD(_amount);\r\n        uint256 playerBalance = playersBalances[msg.sender] + busd;\r\n        playersBalances[msg.sender] = playerBalance;\r\n    }\r\n    function checkPlayerBalance (address player) view public returns(uint256) {\r\n        return playersBalances[player];\r\n    }\r\n    function checkDeveloperBalance (address developer) view public returns(uint256) {\r\n        return developersBalances[developer];\r\n    }\r\n    function calculatePercentValue(uint256 total, uint256 percent) pure private returns(uint256) {\r\n        uint256 division = total.mul(percent);\r\n        uint256 percentValue = division.div(100);\r\n        return percentValue;\r\n    }\r\n    function updateMatchScores(MatchScoreData memory _matchScoreData) external onlyOwner() {\r\n        address[] memory players = _matchScoreData.players;\r\n        uint256[] memory lps = _matchScoreData.loyaltyPoints; \r\n        for(uint8 i=0; i<players.length; i++) {\r\n            uint256 playerIBalance = playersBalances[players[i]];\r\n            if(playerIBalance >= _matchScoreData.matchFees) {\r\n                playersBalances[players[i]] = playerIBalance - _matchScoreData.matchFees;\r\n            }\r\n            loyaltyPoints[players[i]] = lps[i];\r\n        }\r\n        uint256 playerBalance = playersBalances[_matchScoreData.player];\r\n        playersBalances[_matchScoreData.player] = playerBalance + _matchScoreData.winningPrize;\r\n\r\n        uint256 developerBalance = developersBalances[_matchScoreData.developer];\r\n        developersBalances[_matchScoreData.developer] = developerBalance + _matchScoreData.developerPrize;\r\n\r\n        AdminShare = AdminShare + _matchScoreData.adminShare;\r\n    }\r\n    fallback () payable external {}\r\n    receive () payable external {}\r\n    function transferFromERC20(address from, address to, uint256 amount, address tokenAddress) private {\r\n        IERC20Token token = IERC20Token(tokenAddress);\r\n        uint256 balance = token.balanceOf(from);\r\n        require(balance >= amount, \"insufficient balance\" );\r\n        token.transferFrom(from, to, amount);\r\n    }\r\n    function transferERC20(address to, uint256 amount, address tokenAddress) private {\r\n        IERC20Token token = IERC20Token(tokenAddress);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance >= amount, \"insufficient balance\" );\r\n        token.transfer(to, amount);\r\n    }\r\n    function withdrawBNB() public onlyOwner {\r\n        payable(owner()).transfer(address(this).balance);\r\n    }\r\n    function withdrawBUSD() public onlyOwner {\r\n        IERC20Token busd = IERC20Token(busdAddress);\r\n        uint256 balance = busd.balanceOf(address(this));\r\n        require(balance >= 0, \"insufficient balance\" );\r\n        busd.transfer(owner(), balance);\r\n    }\r\n    function withdrawAdminShare() public onlyOwner {\r\n        IERC20Token busd = IERC20Token(busdAddress);\r\n        busd.transfer(owner(), AdminShare);\r\n    }\r\n    function updateLPToBUSD(uint256 _BUSDToLP) public onlyOwner {\r\n        BUSDToLP = _BUSDToLP;\r\n    }\r\n    function calculateBUSD(uint256 lpValue) view public returns(uint256) {\r\n        return lpValue.div(BUSDToLP);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_busd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_BUSDToLP\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"AdminShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpValue\",\"type\":\"uint256\"}],\"name\":\"calculateBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"}],\"name\":\"checkDeveloperBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"checkPlayerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"loyaltyPointsConversion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_BUSDToLP\",\"type\":\"uint256\"}],\"name\":\"updateLPToBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"winningPrize\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"developerPrize\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"matchFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminShare\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"players\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"loyaltyPoints\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Deskillz.MatchScoreData\",\"name\":\"_matchScoreData\",\"type\":\"tuple\"}],\"name\":\"updateMatchScores\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAdminShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDeveloperFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPlayerFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Deskillz", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000000000000000000000000000000000000000003e8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a17a4eaeafb27b3b93f5f36e73b7c734e0376d413eda92d743d0145a501bba8e"}