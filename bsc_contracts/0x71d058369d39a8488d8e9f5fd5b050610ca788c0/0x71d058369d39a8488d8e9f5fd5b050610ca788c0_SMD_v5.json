{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.9;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity 0.8.9;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\npragma solidity 0.8.9;\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(token.approve(spender, value));\r\n    }\r\n}\r\n\r\npragma solidity 0.8.9;\r\n\r\ncontract SMD_v5 is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public tokenAddress;\r\n    address public rewardTokenAddress;\r\n    uint256 public stakedTotal;\r\n    uint256 public stakedBalance;\r\n    uint256 public rewardBalance;\r\n    uint256 public totalReward;\r\n    uint256 public startingBlock;\r\n    uint256 public endingBlock;\r\n    uint256 public period;\r\n    uint256 public accShare;\r\n    uint256 public lastRewardBlock;\r\n    uint256 public totalParticipants;\r\n    uint256 public lockDuration;\r\n    bool public isPaused;\r\n    uint256 public constant blocksPerHour = 1200;\r\n\r\n    IERC20 public ERC20Interface;\r\n\r\n    struct Deposits {\r\n        uint256 amount;\r\n        uint256 initialStake;\r\n        uint256 latestClaim;\r\n        uint256 userAccShare;\r\n        uint256 currentPeriod;\r\n    }\r\n\r\n    struct periodDetails {\r\n        uint256 period;\r\n        uint256 accShare;\r\n        uint256 rewPerBlock;\r\n        uint256 startingBlock;\r\n        uint256 endingBlock;\r\n        uint256 rewards;\r\n    }\r\n\r\n    mapping(address => Deposits) private deposits;\r\n    mapping(address => bool) public isPaid;\r\n    mapping(address => bool) public hasStaked;\r\n    mapping(uint256 => periodDetails) public endAccShare;\r\n\r\n    event NewPeriodSet(\r\n        uint256 period,\r\n        uint256 startBlock,\r\n        uint256 endBlock,\r\n        uint256 lockDuration,\r\n        uint256 rewardAmount\r\n    );\r\n    event PeriodExtended(uint256 period, uint256 endBlock, uint256 rewards);\r\n    event Staked(\r\n        address indexed token,\r\n        address indexed staker_,\r\n        uint256 stakedAmount_\r\n    );\r\n    event PaidOut(\r\n        address indexed token,\r\n        address indexed rewardToken,\r\n        address indexed staker_,\r\n        uint256 amount_,\r\n        uint256 reward_\r\n    );\r\n\r\n    constructor(address _tokenAddress, address _rewardTokenAddress) Ownable() {\r\n        require(_tokenAddress != address(0), \"Zero token address\");\r\n        tokenAddress = _tokenAddress;\r\n        require(_rewardTokenAddress != address(0), \"Zero reward token address\");\r\n        rewardTokenAddress = _rewardTokenAddress;\r\n        isPaused = true;\r\n    }\r\n\r\n    /*\r\n        -   To set the start and end blocks for each period\r\n    */\r\n\r\n    function setStartEnd(uint256 _start, uint256 _end) private {\r\n        require(totalReward > 0, \"Add rewards for this period\");\r\n        startingBlock = _start;\r\n        endingBlock = _end;\r\n        period++;\r\n        isPaused = false;\r\n        lastRewardBlock = _start;\r\n    }\r\n\r\n    function addReward(uint256 _rewardAmount)\r\n        private\r\n        _hasAllowance(msg.sender, _rewardAmount, rewardTokenAddress)\r\n        returns (bool)\r\n    {\r\n        totalReward = totalReward.add(_rewardAmount);\r\n        rewardBalance = rewardBalance.add(_rewardAmount);\r\n        if (!_payMe(msg.sender, _rewardAmount, rewardTokenAddress)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /*\r\n        -   To reset the contract at the end of each period.\r\n    */\r\n\r\n    function reset() private {\r\n        require(block.number > endingBlock, \"Wait till end of this period\");\r\n        updateShare();\r\n        endAccShare[period] = periodDetails(\r\n            period,\r\n            accShare,\r\n            rewPerBlock(),\r\n            startingBlock,\r\n            endingBlock,\r\n            rewardBalance\r\n        );\r\n        totalReward = 0;\r\n        stakedBalance = 0;\r\n        isPaused = true;\r\n    }\r\n\r\n    function resetAndsetStartEndBlock(\r\n        uint256 _rewardAmount,\r\n        uint256 _start,\r\n        uint256 _end,\r\n        uint256 _lockDuration\r\n    ) external onlyOwner returns (bool) {\r\n        require(\r\n            _start > currentBlock(),\r\n            \"Start should be more than current block\"\r\n        );\r\n        require(_end > _start, \"End block should be greater than start\");\r\n        require(_rewardAmount > 0, \"Reward must be positive\");\r\n        reset();\r\n        bool rewardAdded = addReward(_rewardAmount);\r\n        require(rewardAdded, \"Rewards error\");\r\n        setStartEnd(_start, _end);\r\n        lockDuration = _lockDuration;\r\n        totalParticipants = 0;\r\n        emit NewPeriodSet(period, _start, _end, _lockDuration, _rewardAmount);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n        -   Function to update rewards and state parameters\r\n    */\r\n\r\n    function updateShare() private {\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n        if (stakedBalance == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n\r\n        uint256 noOfBlocks;\r\n\r\n        if (block.number >= endingBlock) {\r\n            noOfBlocks = endingBlock.sub(lastRewardBlock);\r\n        } else {\r\n            noOfBlocks = block.number.sub(lastRewardBlock);\r\n        }\r\n\r\n        uint256 rewards = noOfBlocks.mul(rewPerBlock());\r\n\r\n        accShare = accShare.add((rewards.mul(1e6).div(stakedBalance)));\r\n        if (block.number >= endingBlock) {\r\n            lastRewardBlock = endingBlock;\r\n        } else {\r\n            lastRewardBlock = block.number;\r\n        }\r\n    }\r\n\r\n    function rewPerBlock() public view returns (uint256) {\r\n        if (totalReward == 0 || rewardBalance == 0) return 0;\r\n        uint256 rewardperBlock = totalReward.div(\r\n            (endingBlock.sub(startingBlock))\r\n        );\r\n        return (rewardperBlock);\r\n    }\r\n\r\n    function stake(uint256 amount)\r\n        external\r\n        _hasAllowance(msg.sender, amount, tokenAddress)\r\n        returns (bool)\r\n    {\r\n        require(!isPaused, \"Contract is paused\");\r\n        require(\r\n            block.number >= startingBlock && block.number < endingBlock,\r\n            \"Invalid period\"\r\n        );\r\n        require(amount > 0, \"Can't stake 0 amount\");\r\n        return (_stake(msg.sender, amount));\r\n    }\r\n\r\n    function _stake(address from, uint256 amount) private returns (bool) {\r\n        updateShare();\r\n\r\n        if (!hasStaked[from]) {\r\n            deposits[from] = Deposits(\r\n                amount,\r\n                block.number,\r\n                block.number,\r\n                accShare,\r\n                period\r\n            );\r\n            totalParticipants = totalParticipants.add(1);\r\n            hasStaked[from] = true;\r\n        } else {\r\n            if (deposits[from].currentPeriod != period) {\r\n                bool renew_ = _renew(from);\r\n                require(renew_, \"Error renewing\");\r\n            } else {\r\n                bool claim = _claimRewards(from);\r\n                require(claim, \"Error paying rewards\");\r\n            }\r\n\r\n            uint256 userAmount = deposits[from].amount;\r\n\r\n            deposits[from] = Deposits(\r\n                userAmount.add(amount),\r\n                block.number,\r\n                block.number,\r\n                accShare,\r\n                period\r\n            );\r\n        }\r\n        stakedBalance = stakedBalance.add(amount);\r\n        stakedTotal = stakedTotal.add(amount);\r\n        if (!_payMe(from, amount, tokenAddress)) {\r\n            return false;\r\n        }\r\n        emit Staked(tokenAddress, from, amount);\r\n        return true;\r\n    }\r\n\r\n    function userDeposits(address from)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        if (hasStaked[from]) {\r\n            return (\r\n                deposits[from].amount,\r\n                deposits[from].initialStake,\r\n                deposits[from].latestClaim,\r\n                deposits[from].currentPeriod\r\n            );\r\n        } else {\r\n            return (0, 0, 0, 0);\r\n        }\r\n    }\r\n\r\n    function fetchUserShare(address from) public view returns (uint256) {\r\n        require(hasStaked[from], \"No stakes found for user\");\r\n        if (stakedBalance == 0) {\r\n            return 0;\r\n        }\r\n        require(\r\n            deposits[from].currentPeriod == period,\r\n            \"Please renew in the active valid period\"\r\n        );\r\n        uint256 userAmount = deposits[from].amount;\r\n        require(userAmount > 0, \"No stakes available for user\"); //extra check\r\n        return 1;\r\n    }\r\n\r\n    function claimRewards() public returns (bool) {\r\n        require(fetchUserShare(msg.sender) > 0, \"No stakes found for user\");\r\n        return (_claimRewards(msg.sender));\r\n    }\r\n\r\n    function _claimRewards(address from) private returns (bool) {\r\n        uint256 userAccShare = deposits[from].userAccShare;\r\n        updateShare();\r\n        uint256 amount = deposits[from].amount;\r\n        uint256 rewDebt = amount.mul(userAccShare).div(1e6);\r\n        uint256 rew = (amount.mul(accShare).div(1e6)).sub(rewDebt);\r\n        require(rew > 0, \"No rewards generated\");\r\n        require(rew <= rewardBalance, \"Not enough rewards in the contract\");\r\n        deposits[from].userAccShare = accShare;\r\n        deposits[from].latestClaim = block.number;\r\n        rewardBalance = rewardBalance.sub(rew);\r\n        bool payRewards = _payDirect(from, rew, rewardTokenAddress);\r\n        require(payRewards, \"Rewards transfer failed\");\r\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, rew);\r\n        return true;\r\n    }\r\n\r\n    function renew() public returns (bool) {\r\n        require(!isPaused, \"Contract paused\");\r\n        require(hasStaked[msg.sender], \"No stakings found, please stake\");\r\n        require(\r\n            deposits[msg.sender].currentPeriod != period,\r\n            \"Already renewed\"\r\n        );\r\n        require(\r\n            block.number > startingBlock && block.number < endingBlock,\r\n            \"Wrong time\"\r\n        );\r\n        return (_renew(msg.sender));\r\n    }\r\n\r\n    function _renew(address from) private returns (bool) {\r\n        updateShare();\r\n        if (viewOldRewards(from) > 0) {\r\n            bool claimed = claimOldRewards();\r\n            require(claimed, \"Error paying old rewards\");\r\n        }\r\n        deposits[from].currentPeriod = period;\r\n        deposits[from].initialStake = block.number;\r\n        deposits[from].latestClaim = block.number;\r\n        deposits[from].userAccShare = accShare;\r\n        stakedBalance = stakedBalance.add(deposits[from].amount);\r\n        totalParticipants = totalParticipants.add(1);\r\n        return true;\r\n    }\r\n\r\n    function viewOldRewards(address from) public view returns (uint256) {\r\n        require(!isPaused, \"Contract paused\");\r\n        require(hasStaked[from], \"No stakings found, please stake\");\r\n\r\n        if (deposits[from].currentPeriod == period) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 userPeriod = deposits[from].currentPeriod;\r\n\r\n        uint256 accShare1 = endAccShare[userPeriod].accShare;\r\n        uint256 userAccShare = deposits[from].userAccShare;\r\n\r\n        if (deposits[from].latestClaim >= endAccShare[userPeriod].endingBlock)\r\n            return 0;\r\n        uint256 amount = deposits[from].amount;\r\n        uint256 rewDebt = amount.mul(userAccShare).div(1e6);\r\n        uint256 rew = (amount.mul(accShare1).div(1e6)).sub(rewDebt);\r\n\r\n        require(rew <= rewardBalance, \"Not enough rewards\");\r\n\r\n        return (rew);\r\n    }\r\n\r\n    function claimOldRewards() public returns (bool) {\r\n        require(!isPaused, \"Contract paused\");\r\n        require(hasStaked[msg.sender], \"No stakings found, please stake\");\r\n        require(\r\n            deposits[msg.sender].currentPeriod != period,\r\n            \"Already renewed\"\r\n        );\r\n\r\n        uint256 userPeriod = deposits[msg.sender].currentPeriod;\r\n\r\n        uint256 accShare1 = endAccShare[userPeriod].accShare;\r\n        uint256 userAccShare = deposits[msg.sender].userAccShare;\r\n\r\n        require(\r\n            deposits[msg.sender].latestClaim <\r\n                endAccShare[userPeriod].endingBlock,\r\n            \"Already claimed old rewards\"\r\n        );\r\n        uint256 amount = deposits[msg.sender].amount;\r\n        uint256 rewDebt = amount.mul(userAccShare).div(1e6);\r\n        uint256 rew = (amount.mul(accShare1).div(1e6)).sub(rewDebt);\r\n\r\n        require(rew <= rewardBalance, \"Not enough rewards\");\r\n        deposits[msg.sender].latestClaim = endAccShare[userPeriod].endingBlock;\r\n        rewardBalance = rewardBalance.sub(rew);\r\n        bool paidOldRewards = _payDirect(msg.sender, rew, rewardTokenAddress);\r\n        require(paidOldRewards, \"Error paying\");\r\n        emit PaidOut(tokenAddress, rewardTokenAddress, msg.sender, amount, rew);\r\n        return true;\r\n    }\r\n\r\n    function calculate(address from) public view returns (uint256) {\r\n        if (fetchUserShare(from) == 0) return 0;\r\n        return (_calculate(from));\r\n    }\r\n\r\n    function _calculate(address from) private view returns (uint256) {\r\n        uint256 userAccShare = deposits[from].userAccShare;\r\n        uint256 currentAccShare = accShare;\r\n        //Simulating updateShare() to calculate rewards\r\n        if (block.number <= lastRewardBlock) {\r\n            return 0;\r\n        }\r\n        if (stakedBalance == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 noOfBlocks;\r\n\r\n        if (block.number >= endingBlock) {\r\n            noOfBlocks = endingBlock.sub(lastRewardBlock);\r\n        } else {\r\n            noOfBlocks = block.number.sub(lastRewardBlock);\r\n        }\r\n\r\n        uint256 rewards = noOfBlocks.mul(rewPerBlock());\r\n\r\n        uint256 newAccShare = currentAccShare.add(\r\n            (rewards.mul(1e6).div(stakedBalance))\r\n        );\r\n        uint256 amount = deposits[from].amount;\r\n        uint256 rewDebt = amount.mul(userAccShare).div(1e6);\r\n        uint256 rew = (amount.mul(newAccShare).div(1e6)).sub(rewDebt);\r\n        return (rew);\r\n    }\r\n\r\n    function emergencyWithdraw() external returns (bool) {\r\n        require(\r\n            currentBlock() >\r\n                deposits[msg.sender].initialStake.add(\r\n                    lockDuration.mul(blocksPerHour)\r\n                ),\r\n            \"Can't withdraw before lock duration\"\r\n        );\r\n        require(hasStaked[msg.sender], \"No stakes available for user\");\r\n        require(!isPaid[msg.sender], \"Already Paid\");\r\n        return (_withdraw(msg.sender, deposits[msg.sender].amount));\r\n    }\r\n\r\n    function _withdraw(address from, uint256 amount) private returns (bool) {\r\n        updateShare();\r\n        deposits[from].amount = deposits[from].amount.sub(amount);\r\n        if (!isPaused && deposits[from].currentPeriod == period) {\r\n            stakedBalance = stakedBalance.sub(amount);\r\n        }\r\n        bool paid = _payDirect(from, amount, tokenAddress);\r\n        require(paid, \"Error during withdraw\");\r\n        if (deposits[from].amount == 0) {\r\n            isPaid[from] = true;\r\n            hasStaked[from] = false;\r\n            if (deposits[from].currentPeriod == period) {\r\n                totalParticipants = totalParticipants.sub(1);\r\n            }\r\n            delete deposits[from];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function withdraw(uint256 amount) external returns (bool) {\r\n        require(\r\n            currentBlock() >\r\n                deposits[msg.sender].initialStake.add(\r\n                    lockDuration.mul(blocksPerHour)\r\n                ),\r\n            \"Can't withdraw before lock duration\"\r\n        );\r\n        require(amount <= deposits[msg.sender].amount, \"Wrong value\");\r\n        if (deposits[msg.sender].currentPeriod == period) {\r\n            if (calculate(msg.sender) > 0) {\r\n                bool rewardsPaid = claimRewards();\r\n                require(rewardsPaid, \"Error paying rewards\");\r\n            }\r\n        }\r\n\r\n        if (viewOldRewards(msg.sender) > 0) {\r\n            bool oldRewardsPaid = claimOldRewards();\r\n            require(oldRewardsPaid, \"Error paying old rewards\");\r\n        }\r\n        return (_withdraw(msg.sender, amount));\r\n    }\r\n\r\n    function extendPeriod(uint256 rewardsToBeAdded)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            currentBlock() > startingBlock && currentBlock() < endingBlock,\r\n            \"Invalid period\"\r\n        );\r\n        require(rewardsToBeAdded > 0, \"Zero rewards\");\r\n        bool addedRewards = _payMe(\r\n            msg.sender,\r\n            rewardsToBeAdded,\r\n            rewardTokenAddress\r\n        );\r\n        require(addedRewards, \"Error adding rewards\");\r\n        endingBlock = endingBlock.add(rewardsToBeAdded.div(rewPerBlock()));\r\n        totalReward = totalReward.add(rewardsToBeAdded);\r\n        rewardBalance = rewardBalance.add(rewardsToBeAdded);\r\n        emit PeriodExtended(period, endingBlock, rewardsToBeAdded);\r\n        return true;\r\n    }\r\n\r\n    function currentBlock() public view returns (uint256) {\r\n        return (block.number);\r\n    }\r\n\r\n    function _payMe(\r\n        address payer,\r\n        uint256 amount,\r\n        address token\r\n    ) private returns (bool) {\r\n        return _payTo(payer, address(this), amount, token);\r\n    }\r\n\r\n    function _payTo(\r\n        address allower,\r\n        address receiver,\r\n        uint256 amount,\r\n        address token\r\n    ) private returns (bool) {\r\n        // Request to transfer amount from the contract to receiver.\r\n        // contract does not own the funds, so the allower must have added allowance to the contract\r\n        // Allower is the original owner.\r\n        ERC20Interface = IERC20(token);\r\n        ERC20Interface.safeTransferFrom(allower, receiver, amount);\r\n        return true;\r\n    }\r\n\r\n    function _payDirect(\r\n        address to,\r\n        uint256 amount,\r\n        address token\r\n    ) private returns (bool) {\r\n        require(\r\n            token == tokenAddress || token == rewardTokenAddress,\r\n            \"Invalid token address\"\r\n        );\r\n        ERC20Interface = IERC20(token);\r\n        ERC20Interface.safeTransfer(to, amount);\r\n        return true;\r\n    }\r\n\r\n    modifier _hasAllowance(\r\n        address allower,\r\n        uint256 amount,\r\n        address token\r\n    ) {\r\n        // Make sure the allower has provided the right allowance.\r\n        require(\r\n            token == tokenAddress || token == rewardTokenAddress,\r\n            \"Invalid token address\"\r\n        );\r\n        ERC20Interface = IERC20(token);\r\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\r\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"NewPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"}],\"name\":\"PaidOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"PeriodExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount_\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ERC20Interface\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksPerHour\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"calculate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOldRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"endAccShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endingBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsToBeAdded\",\"type\":\"uint256\"}],\"name\":\"extendPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"fetchUserShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renew\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"name\":\"resetAndsetStartEndBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalParticipants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"userDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"viewOldRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SMD_v5", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000074fa517715c4ec65ef01d55ad5335f90dce7cc87000000000000000000000000477bc8d23c634c154061869478bce96be6045d12", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://395bd154f7f68395eaef5ae9660cd9352251ee31ce94fb9b36d62f0393f29b90"}