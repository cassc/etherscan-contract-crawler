{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.23;\r\n\r\n/// @title ISuperformFactory\r\n/// @dev Interface for SuperformFactory\r\n/// @author ZeroPoint Labs\r\ninterface ISuperformFactory {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                         CONSTANTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    enum PauseStatus {\r\n        NON_PAUSED,\r\n        PAUSED\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev emitted when a new formImplementation is entered into the factory\r\n    /// @param formImplementation is the address of the new form implementation\r\n    /// @param formImplementationId is the id of the formImplementation\r\n    /// @param formStateRegistryId is any additional state registry id of the formImplementation\r\n    event FormImplementationAdded(\r\n        address indexed formImplementation, uint256 indexed formImplementationId, uint8 indexed formStateRegistryId\r\n    );\r\n\r\n    /// @dev emitted when a new Superform is created\r\n    /// @param formImplementationId is the id of the form implementation\r\n    /// @param vault is the address of the vault\r\n    /// @param superformId is the id of the superform\r\n    /// @param superform is the address of the superform\r\n    event SuperformCreated(\r\n        uint256 indexed formImplementationId, address indexed vault, uint256 indexed superformId, address superform\r\n    );\r\n\r\n    /// @dev emitted when a new SuperRegistry is set\r\n    /// @param superRegistry is the address of the super registry\r\n    event SuperRegistrySet(address indexed superRegistry);\r\n\r\n    /// @dev emitted when a form implementation is paused\r\n    /// @param formImplementationId is the id of the form implementation\r\n    /// @param paused is the new paused status\r\n    event FormImplementationPaused(uint256 indexed formImplementationId, PauseStatus indexed paused);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the number of forms\r\n    /// @return forms_ is the number of forms\r\n    function getFormCount() external view returns (uint256 forms_);\r\n\r\n    /// @dev returns the number of superforms\r\n    /// @return superforms_ is the number of superforms\r\n    function getSuperformCount() external view returns (uint256 superforms_);\r\n\r\n    /// @dev returns the address of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return formImplementation_ is the address of the form implementation\r\n    function getFormImplementation(uint32 formImplementationId_) external view returns (address formImplementation_);\r\n\r\n    /// @dev returns the form state registry id of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return stateRegistryId_ is the additional state registry id of the form\r\n    function getFormStateRegistryId(uint32 formImplementationId_) external view returns (uint8 stateRegistryId_);\r\n\r\n    /// @dev returns the paused status of form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return paused_ is the current paused status of the form formImplementationId_\r\n    function isFormImplementationPaused(uint32 formImplementationId_) external view returns (bool paused_);\r\n\r\n    /// @dev returns the address of a superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return superform_ is the address of the superform\r\n    /// @return formImplementationId_ is the id of the form implementation\r\n    /// @return chainId_ is the chain id\r\n    function getSuperform(uint256 superformId_)\r\n        external\r\n        pure\r\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_);\r\n\r\n    /// @dev returns if an address has been added to a Form\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return isSuperform_ bool if it exists\r\n    function isSuperform(uint256 superformId_) external view returns (bool isSuperform_);\r\n\r\n    /// @dev Reverse query of getSuperform, returns all superforms for a given vault\r\n    /// @param vault_ is the address of a vault\r\n    /// @return superformIds_ is the id of the superform\r\n    /// @return superforms_ is the address of the superform\r\n    function getAllSuperformsFromVault(address vault_)\r\n        external\r\n        view\r\n        returns (uint256[] memory superformIds_, address[] memory superforms_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows an admin to add a Form implementation to the factory\r\n    /// @param formImplementation_ is the address of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation (generated off-chain and equal in all chains)\r\n    /// @param formStateRegistryId_ is the id of any additional state registry for that form\r\n    /// @dev formStateRegistryId_ 1 is default for all form implementations, pass in formStateRegistryId_ only if an\r\n    /// additional state registry is required\r\n    function addFormImplementation(\r\n        address formImplementation_,\r\n        uint32 formImplementationId_,\r\n        uint8 formStateRegistryId_\r\n    )\r\n        external;\r\n\r\n    /// @dev To add new vaults to Form implementations, fusing them together into Superforms\r\n    /// @param formImplementationId_ is the form implementation we want to attach the vault to\r\n    /// @param vault_ is the address of the vault\r\n    /// @return superformId_ is the id of the created superform\r\n    /// @return superform_ is the address of the created superform\r\n    function createSuperform(\r\n        uint32 formImplementationId_,\r\n        address vault_\r\n    )\r\n        external\r\n        returns (uint256 superformId_, address superform_);\r\n\r\n    /// @dev to synchronize superforms added to different chains using broadcast registry\r\n    /// @param data_ is the cross-chain superform id\r\n    function stateSyncBroadcast(bytes memory data_) external payable;\r\n\r\n    /// @dev allows an admin to change the status of a form\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @param status_ is the new status\r\n    /// @param extraData_ is optional & passed when broadcasting of status is needed\r\n    function changeFormImplementationPauseStatus(\r\n        uint32 formImplementationId_,\r\n        PauseStatus status_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable;\r\n}\r\n\r\n/// @dev contains all the common struct and enums used for data communication between chains.\r\n\r\n/// @dev There are two transaction types in Superform Protocol\r\nenum TransactionType {\r\n    DEPOSIT,\r\n    WITHDRAW\r\n}\r\n\r\n/// @dev Message types can be INIT, RETURN (for successful Deposits) and FAIL (for failed withdraws)\r\nenum CallbackType {\r\n    INIT,\r\n    RETURN,\r\n    FAIL\r\n}\r\n\r\n/// @dev Payloads are stored, updated (deposits) or processed (finalized)\r\nenum PayloadState {\r\n    STORED,\r\n    UPDATED,\r\n    PROCESSED\r\n}\r\n\r\n/// @dev contains all the common struct used for interchain token transfers.\r\nstruct LiqRequest {\r\n    /// @dev generated data\r\n    bytes txData;\r\n    /// @dev input token for deposits, desired output token on target liqDstChainId for withdraws. Must be set for\r\n    /// txData to be updated on destination for withdraws\r\n    address token;\r\n    /// @dev intermediary token on destination. Relevant for xChain deposits where a destination swap is needed for\r\n    /// validation purposes\r\n    address interimToken;\r\n    /// @dev what bridge to use to move tokens\r\n    uint8 bridgeId;\r\n    /// @dev dstChainId = liqDstchainId for deposits. For withdraws it is the target chain id for where the underlying\r\n    /// is to be delivered\r\n    uint64 liqDstChainId;\r\n    /// @dev currently this amount is used as msg.value in the txData call.\r\n    uint256 nativeAmount;\r\n}\r\n\r\n/// @dev main struct that holds required multi vault data for an action\r\nstruct MultiVaultSFData {\r\n    // superformids must have same destination. Can have different underlyings\r\n    uint256[] superformIds;\r\n    uint256[] amounts; // on deposits, amount of token to deposit on dst, on withdrawals, superpositions to burn\r\n    uint256[] outputAmounts; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\r\n    uint256[] maxSlippages;\r\n    LiqRequest[] liqRequests; // if length = 1; amount = sum(amounts) | else  amounts must match the amounts being sent\r\n    bytes permit2data;\r\n    bool[] hasDstSwaps;\r\n    bool[] retain4626s; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\r\n    address receiverAddress;\r\n    /// this address must always be an EOA otherwise funds may be lost\r\n    address receiverAddressSP;\r\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\r\n    bytes extraFormData; // extraFormData\r\n}\r\n\r\n/// @dev main struct that holds required single vault data for an action\r\nstruct SingleVaultSFData {\r\n    // superformids must have same destination. Can have different underlyings\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 outputAmount; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\r\n    uint256 maxSlippage;\r\n    LiqRequest liqRequest; // if length = 1; amount = sum(amounts)| else  amounts must match the amounts being sent\r\n    bytes permit2data;\r\n    bool hasDstSwap;\r\n    bool retain4626; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\r\n    address receiverAddress;\r\n    /// this address must always be an EOA otherwise funds may be lost\r\n    address receiverAddressSP;\r\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\r\n    bytes extraFormData; // extraFormData\r\n}\r\n\r\n/// @dev overarching struct for multiDst requests with multi vaults\r\nstruct MultiDstMultiVaultStateReq {\r\n    uint8[][] ambIds;\r\n    uint64[] dstChainIds;\r\n    MultiVaultSFData[] superformsData;\r\n}\r\n\r\n/// @dev overarching struct for single cross chain requests with multi vaults\r\nstruct SingleXChainMultiVaultStateReq {\r\n    uint8[] ambIds;\r\n    uint64 dstChainId;\r\n    MultiVaultSFData superformsData;\r\n}\r\n\r\n/// @dev overarching struct for multiDst requests with single vaults\r\nstruct MultiDstSingleVaultStateReq {\r\n    uint8[][] ambIds;\r\n    uint64[] dstChainIds;\r\n    SingleVaultSFData[] superformsData;\r\n}\r\n\r\n/// @dev overarching struct for single cross chain requests with single vaults\r\nstruct SingleXChainSingleVaultStateReq {\r\n    uint8[] ambIds;\r\n    uint64 dstChainId;\r\n    SingleVaultSFData superformData;\r\n}\r\n\r\n/// @dev overarching struct for single direct chain requests with single vaults\r\nstruct SingleDirectSingleVaultStateReq {\r\n    SingleVaultSFData superformData;\r\n}\r\n\r\n/// @dev overarching struct for single direct chain requests with multi vaults\r\nstruct SingleDirectMultiVaultStateReq {\r\n    MultiVaultSFData superformData;\r\n}\r\n\r\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\r\n/// @dev realize that receiverAddressSP is not passed, only needed on source chain to mint\r\nstruct InitMultiVaultData {\r\n    uint256 payloadId;\r\n    uint256[] superformIds;\r\n    uint256[] amounts;\r\n    uint256[] outputAmounts;\r\n    uint256[] maxSlippages;\r\n    LiqRequest[] liqData;\r\n    bool[] hasDstSwaps;\r\n    bool[] retain4626s;\r\n    address receiverAddress;\r\n    bytes extraFormData;\r\n}\r\n\r\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\r\nstruct InitSingleVaultData {\r\n    uint256 payloadId;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 outputAmount;\r\n    uint256 maxSlippage;\r\n    LiqRequest liqData;\r\n    bool hasDstSwap;\r\n    bool retain4626;\r\n    address receiverAddress;\r\n    bytes extraFormData;\r\n}\r\n\r\n/// @dev struct for Emergency Queue\r\nstruct QueuedWithdrawal {\r\n    address receiverAddress;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 srcPayloadId;\r\n    bool isProcessed;\r\n}\r\n\r\n/// @dev all statuses of the timelock payload\r\nenum TimelockStatus {\r\n    UNAVAILABLE,\r\n    PENDING,\r\n    PROCESSED\r\n}\r\n\r\n/// @dev holds information about the timelock payload\r\nstruct TimelockPayload {\r\n    uint8 isXChain;\r\n    uint64 srcChainId;\r\n    uint256 lockedTill;\r\n    InitSingleVaultData data;\r\n    TimelockStatus status;\r\n}\r\n\r\n/// @dev struct that contains the type of transaction, callback flags and other identification, as well as the vaults\r\n/// data in params\r\nstruct AMBMessage {\r\n    uint256 txInfo; // tight packing of  TransactionType txType,  CallbackType flag  if multi/single vault, registry id,\r\n        // srcSender and srcChainId\r\n    bytes params; // decoding txInfo will point to the right datatype of params. Refer PayloadHelper.sol\r\n}\r\n\r\n/// @dev struct that contains the information required for broadcasting changes\r\nstruct BroadcastMessage {\r\n    bytes target;\r\n    bytes32 messageType;\r\n    bytes message;\r\n}\r\n\r\n/// @dev struct that contains info on returned data from destination\r\nstruct ReturnMultiData {\r\n    uint256 payloadId;\r\n    uint256[] superformIds;\r\n    uint256[] amounts;\r\n}\r\n\r\n/// @dev struct that contains info on returned data from destination\r\nstruct ReturnSingleData {\r\n    uint256 payloadId;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n}\r\n\r\n/// @dev struct that contains the data on the fees to pay to the AMBs\r\nstruct AMBExtraData {\r\n    uint256[] gasPerAMB;\r\n    bytes[] extraDataPerAMB;\r\n}\r\n\r\n/// @dev struct that contains the data on the fees to pay to the AMBs on broadcasts\r\nstruct BroadCastAMBExtraData {\r\n    uint256[] gasPerDst;\r\n    bytes[] extraDataPerDst;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC-165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC-20 standard as defined in the ERC.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\r\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\r\n */\r\ninterface IERC4626 is IERC20, IERC20Metadata {\r\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\r\n}\r\n\r\n/// @title IBaseForm\r\n/// @dev Interface for BaseForm\r\n/// @author ZeroPoint Labs\r\ninterface IBaseForm is IERC165 {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                           //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a new vault is added by the admin.\r\n    event VaultAdded(uint256 indexed id, IERC4626 indexed vault);\r\n\r\n    /// @dev is emitted when a payload is processed by the destination contract.\r\n    event Processed(\r\n        uint64 indexed srcChainID,\r\n        uint64 indexed dstChainId,\r\n        uint256 indexed srcPayloadId,\r\n        uint256 amount,\r\n        address vault\r\n    );\r\n\r\n    /// @dev is emitted when an emergency withdrawal is processed\r\n    event EmergencyWithdrawalProcessed(address indexed refundAddress, uint256 indexed amount);\r\n\r\n    /// @dev is emitted when dust is forwarded to the paymaster\r\n    event FormDustForwardedToPaymaster(address indexed token, uint256 indexed amount);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @notice get Superform name of the ERC20 vault representation\r\n    /// @return The ERC20 name\r\n    function superformYieldTokenName() external view returns (string memory);\r\n\r\n    /// @notice get Superform symbol of the ERC20 vault representation\r\n    /// @return The ERC20 symbol\r\n    function superformYieldTokenSymbol() external view returns (string memory);\r\n\r\n    /// @notice get the state registry id associated with the vault\r\n    function getStateRegistryId() external view returns (uint8);\r\n\r\n    /// @notice Returns the vault address\r\n    /// @return The address of the vault\r\n    function getVaultAddress() external view returns (address);\r\n\r\n    /// @notice Returns the vault address\r\n    /// @return The address of the vault asset\r\n    function getVaultAsset() external view returns (address);\r\n\r\n    /// @notice Returns the name of the vault.\r\n    /// @return The name of the vault\r\n    function getVaultName() external view returns (string memory);\r\n\r\n    /// @notice Returns the symbol of a vault.\r\n    /// @return The symbol associated with a vault\r\n    function getVaultSymbol() external view returns (string memory);\r\n\r\n    /// @notice Returns the number of decimals in a vault for accounting purposes\r\n    /// @return The number of decimals in the vault balance\r\n    function getVaultDecimals() external view returns (uint256);\r\n\r\n    /// @notice Returns the amount of underlying tokens each share of a vault is worth.\r\n    /// @return The pricePerVaultShare value\r\n    function getPricePerVaultShare() external view returns (uint256);\r\n\r\n    /// @notice Returns the amount of vault shares owned by the form.\r\n    /// @return The form's vault share balance\r\n    function getVaultShareBalance() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of underlying managed in the ERC4626 vault\r\n    function getTotalAssets() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of unredeemed vault shares in circulation\r\n    function getTotalSupply() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of assets received if shares are actually redeemed\r\n    /// @notice https://eips.ethereum.org/EIPS/eip-4626\r\n    function getPreviewPricePerVaultShare() external view returns (uint256);\r\n\r\n    /// @dev API may need to know state of funds deployed\r\n    function previewDepositTo(uint256 assets_) external view returns (uint256);\r\n\r\n    /// @notice positionBalance() -> .vaultIds&destAmounts\r\n    /// @return how much of an asset + interest (accrued) is to withdraw from the Vault\r\n    function previewWithdrawFrom(uint256 assets_) external view returns (uint256);\r\n\r\n    /// @dev API may need to know state of funds deployed\r\n    function previewRedeemFrom(uint256 shares_) external view returns (uint256);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev process same chain id deposits\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @return shares  The amount of vault shares received\r\n    function directDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 shares);\r\n\r\n    /// @dev process same chain id deposits\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @param srcChainId_ The chain id of the source chain\r\n    /// @return shares  The amount of vault shares received\r\n    /// @dev is shares is `0` then no further action/acknowledgement needs to be sent\r\n    function xChainDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        external\r\n        returns (uint256 shares);\r\n\r\n    /// @dev process withdrawal of asset from a vault\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @return assets  The amount of assets received\r\n    function directWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        external\r\n        returns (uint256 assets);\r\n\r\n    /// @dev process withdrawal of asset from a vault\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @param srcChainId_ The chain id of the source chain\r\n    /// @return assets The amount of assets received\r\n    function xChainWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        external\r\n        returns (uint256 assets);\r\n\r\n    /// @dev process withdrawal of shares if form is paused\r\n    /// @param receiverAddress_ The address to refund the shares to\r\n    /// @param amount_ The amount of vault shares to refund\r\n    function emergencyWithdraw(address receiverAddress_, uint256 amount_) external;\r\n\r\n    /// @dev moves all dust in the contract to Paymaster contract\r\n    /// @param token_ The address of the token to forward\r\n    function forwardDustToPaymaster(address token_) external;\r\n}\r\n\r\n/// @title ISuperRegistry\r\n/// @dev Interface for SuperRegistry\r\n/// @author Zeropoint Labs\r\ninterface ISuperRegistry {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev emitted when permit2 is set.\r\n    event SetPermit2(address indexed permit2);\r\n\r\n    /// @dev is emitted when an address is set.\r\n    event AddressUpdated(\r\n        bytes32 indexed protocolAddressId, uint64 indexed chainId, address indexed oldAddress, address newAddress\r\n    );\r\n\r\n    /// @dev is emitted when a new token bridge is configured.\r\n    event SetBridgeAddress(uint256 indexed bridgeId, address indexed bridgeAddress);\r\n\r\n    /// @dev is emitted when a new bridge validator is configured.\r\n    event SetBridgeValidator(uint256 indexed bridgeId, address indexed bridgeValidator);\r\n\r\n    /// @dev is emitted when a new amb is configured.\r\n    event SetAmbAddress(uint8 indexed ambId_, address indexed ambAddress_, bool indexed isBroadcastAMB_);\r\n\r\n    /// @dev is emitted when a new state registry is configured.\r\n    event SetStateRegistryAddress(uint8 indexed registryId_, address indexed registryAddress_);\r\n\r\n    /// @dev is emitted when a new delay is configured.\r\n    event SetDelay(uint256 indexed oldDelay_, uint256 indexed newDelay_);\r\n\r\n    /// @dev is emitted when a new vault limit is configured\r\n    event SetVaultLimitPerDestination(uint64 indexed chainId_, uint256 indexed vaultLimit_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev gets the deposit rescue delay\r\n    function delay() external view returns (uint256);\r\n\r\n    /// @dev returns the permit2 address\r\n    function PERMIT2() external view returns (address);\r\n\r\n    /// @dev returns the id of the superform router module\r\n    function SUPERFORM_ROUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform factory module\r\n    function SUPERFORM_FACTORY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform transmuter\r\n    function SUPER_TRANSMUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform paymaster contract\r\n    function PAYMASTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform payload helper contract\r\n    function PAYMENT_HELPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry module\r\n    function CORE_STATE_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the timelock form state registry module\r\n    function TIMELOCK_STATE_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcast state registry module\r\n    function BROADCAST_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the super positions module\r\n    function SUPER_POSITIONS() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the super rbac module\r\n    function SUPER_RBAC() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the payload helper module\r\n    function PAYLOAD_HELPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the dst swapper keeper\r\n    function DST_SWAPPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the emergency queue\r\n    function EMERGENCY_QUEUE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform receiver\r\n    function SUPERFORM_RECEIVER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the payment admin keeper\r\n    function PAYMENT_ADMIN() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry processor keeper\r\n    function CORE_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcast registry processor keeper\r\n    function BROADCAST_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the timelock form state registry processor keeper\r\n    function TIMELOCK_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_UPDATER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_RESCUER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_DISPUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function DST_SWAPPER_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev gets the address of a contract on current chain\r\n    /// @param id_ is the id of the contract\r\n    function getAddress(bytes32 id_) external view returns (address);\r\n\r\n    /// @dev gets the address of a contract on a target chain\r\n    /// @param id_ is the id of the contract\r\n    /// @param chainId_ is the chain id of that chain\r\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view returns (address);\r\n\r\n    /// @dev gets the address of a bridge\r\n    /// @param bridgeId_ is the id of a bridge\r\n    /// @return bridgeAddress_ is the address of the form\r\n    function getBridgeAddress(uint8 bridgeId_) external view returns (address bridgeAddress_);\r\n\r\n    /// @dev gets the address of a bridge validator\r\n    /// @param bridgeId_ is the id of a bridge\r\n    /// @return bridgeValidator_ is the address of the form\r\n    function getBridgeValidator(uint8 bridgeId_) external view returns (address bridgeValidator_);\r\n\r\n    /// @dev gets the address of a amb\r\n    /// @param ambId_ is the id of a bridge\r\n    /// @return ambAddress_ is the address of the form\r\n    function getAmbAddress(uint8 ambId_) external view returns (address ambAddress_);\r\n\r\n    /// @dev gets the id of the amb\r\n    /// @param ambAddress_ is the address of an amb\r\n    /// @return ambId_ is the identifier of an amb\r\n    function getAmbId(address ambAddress_) external view returns (uint8 ambId_);\r\n\r\n    /// @dev gets the address of the registry\r\n    /// @param registryId_ is the id of the state registry\r\n    /// @return registryAddress_ is the address of the state registry\r\n    function getStateRegistry(uint8 registryId_) external view returns (address registryAddress_);\r\n\r\n    /// @dev gets the id of the registry\r\n    /// @notice reverts if the id is not found\r\n    /// @param registryAddress_ is the address of the state registry\r\n    /// @return registryId_ is the id of the state registry\r\n    function getStateRegistryId(address registryAddress_) external view returns (uint8 registryId_);\r\n\r\n    /// @dev gets the safe vault limit\r\n    /// @param chainId_ is the id of the remote chain\r\n    /// @return vaultLimitPerDestination_ is the safe number of vaults to deposit\r\n    /// without hitting out of gas error\r\n    function getVaultLimitPerDestination(uint64 chainId_) external view returns (uint256 vaultLimitPerDestination_);\r\n\r\n    /// @dev helps validate if an address is a valid state registry\r\n    /// @param registryAddress_ is the address of the state registry\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidStateRegistry(address registryAddress_) external view returns (bool valid_);\r\n\r\n    /// @dev helps validate if an address is a valid amb implementation\r\n    /// @param ambAddress_ is the address of the amb implementation\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidAmbImpl(address ambAddress_) external view returns (bool valid_);\r\n\r\n    /// @dev helps validate if an address is a valid broadcast amb implementation\r\n    /// @param ambAddress_ is the address of the broadcast amb implementation\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidBroadcastAmbImpl(address ambAddress_) external view returns (bool valid_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev sets the deposit rescue delay\r\n    /// @param delay_ the delay in seconds before the deposit rescue can be finalized\r\n    function setDelay(uint256 delay_) external;\r\n\r\n    /// @dev sets the permit2 address\r\n    /// @param permit2_ the address of the permit2 contract\r\n    function setPermit2(address permit2_) external;\r\n\r\n    /// @dev sets the safe vault limit\r\n    /// @param chainId_ is the remote chain identifier\r\n    /// @param vaultLimit_ is the max limit of vaults per transaction\r\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external;\r\n\r\n    /// @dev sets a new address on a specific chain.\r\n    /// @param id_ the identifier of the address on that chain\r\n    /// @param newAddress_ the new address on that chain\r\n    /// @param chainId_ the chain id of that chain\r\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) external;\r\n\r\n    /// @dev allows admin to set the bridge address for an bridge id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param bridgeId_         represents the bridge unique identifier.\r\n    /// @param bridgeAddress_    represents the bridge address.\r\n    /// @param bridgeValidator_  represents the bridge validator address.\r\n    function setBridgeAddresses(\r\n        uint8[] memory bridgeId_,\r\n        address[] memory bridgeAddress_,\r\n        address[] memory bridgeValidator_\r\n    )\r\n        external;\r\n\r\n    /// @dev allows admin to set the amb address for an amb id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param ambId_         represents the bridge unique identifier.\r\n    /// @param ambAddress_    represents the bridge address.\r\n    /// @param isBroadcastAMB_ represents whether the amb implementation supports broadcasting\r\n    function setAmbAddress(\r\n        uint8[] memory ambId_,\r\n        address[] memory ambAddress_,\r\n        bool[] memory isBroadcastAMB_\r\n    )\r\n        external;\r\n\r\n    /// @dev allows admin to set the state registry address for an state registry id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param registryId_    represents the state registry's unique identifier.\r\n    /// @param registryAddress_    represents the state registry's address.\r\n    function setStateRegistryAddress(uint8[] memory registryId_, address[] memory registryAddress_) external;\r\n}\r\n\r\n/// @title IEmergencyQueue\r\n/// @dev Interface for EmergencyQueue\r\n/// @author ZeroPoint Labs\r\ninterface IEmergencyQueue {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    event WithdrawalQueued(\r\n        address indexed receiverAddress,\r\n        uint256 indexed id,\r\n        uint256 indexed superformId,\r\n        uint256 amount,\r\n        uint256 srcPayloadId\r\n    );\r\n\r\n    event WithdrawalProcessed(\r\n        address indexed refundAddress, uint256 indexed id, uint256 indexed superformId, uint256 amount\r\n    );\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the execution status of an id in the emergency queue\r\n    /// @param id is the identifier of the queued action\r\n    /// @return boolean representing the execution status\r\n    function queuedWithdrawalStatus(uint256 id) external view returns (bool);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev called by paused forms to queue up withdrawals for exit\r\n    /// @param data_ is the single vault data passed by the user\r\n    function queueWithdrawal(InitSingleVaultData memory data_) external;\r\n\r\n    /// @dev called by emergency admin to processed queued withdrawal\r\n    /// @param id_ is the identifier of the queued action\r\n    function executeQueuedWithdrawal(uint256 id_) external;\r\n\r\n    /// @dev called by emergency admin to batch process queued withdrawals\r\n    /// @param ids_ is the array of identifiers of the queued actions\r\n    function batchExecuteQueuedWithdrawal(uint256[] memory ids_) external;\r\n}\r\n\r\nlibrary Error {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  CONFIGURATION ERRORS                    //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown in protocol setup\r\n\r\n    /// @dev thrown if chain id exceeds max(uint64)\r\n    error BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\r\n\r\n    /// @dev thrown if not possible to revoke a role in broadcasting\r\n    error CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\r\n\r\n    /// @dev thrown if not possible to revoke last admin\r\n    error CANNOT_REVOKE_LAST_ADMIN();\r\n\r\n    /// @dev thrown if trying to set again pseudo immutables in super registry\r\n    error DISABLED();\r\n\r\n    /// @dev thrown if rescue delay is not yet set for a chain\r\n    error DELAY_NOT_SET();\r\n\r\n    /// @dev thrown if get native token price estimate in paymentHelper is 0\r\n    error INVALID_NATIVE_TOKEN_PRICE();\r\n\r\n    /// @dev thrown if wormhole refund chain id is not set\r\n    error REFUND_CHAIN_ID_NOT_SET();\r\n\r\n    /// @dev thrown if wormhole relayer is not set\r\n    error RELAYER_NOT_SET();\r\n\r\n    /// @dev thrown if a role to be revoked is not assigned\r\n    error ROLE_NOT_ASSIGNED();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  AUTHORIZATION ERRORS                    //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown if functions cannot be called\r\n\r\n    /// COMMON AUTHORIZATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if caller is not address(this), internal call\r\n    error INVALID_INTERNAL_CALL();\r\n\r\n    /// @dev thrown if msg.sender is not a valid amb implementation\r\n    error NOT_AMB_IMPLEMENTATION();\r\n\r\n    /// @dev thrown if msg.sender is not an allowed broadcaster\r\n    error NOT_ALLOWED_BROADCASTER();\r\n\r\n    /// @dev thrown if msg.sender is not broadcast amb implementation\r\n    error NOT_BROADCAST_AMB_IMPLEMENTATION();\r\n\r\n    /// @dev thrown if msg.sender is not broadcast state registry\r\n    error NOT_BROADCAST_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not core state registry\r\n    error NOT_CORE_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not emergency admin\r\n    error NOT_EMERGENCY_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not emergency queue\r\n    error NOT_EMERGENCY_QUEUE();\r\n\r\n    /// @dev thrown if msg.sender is not minter\r\n    error NOT_MINTER();\r\n\r\n    /// @dev thrown if msg.sender is not minter state registry\r\n    error NOT_MINTER_STATE_REGISTRY_ROLE();\r\n\r\n    /// @dev thrown if msg.sender is not paymaster\r\n    error NOT_PAYMASTER();\r\n\r\n    /// @dev thrown if msg.sender is not payment admin\r\n    error NOT_PAYMENT_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not protocol admin\r\n    error NOT_PROTOCOL_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not state registry\r\n    error NOT_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not super registry\r\n    error NOT_SUPER_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not superform router\r\n    error NOT_SUPERFORM_ROUTER();\r\n\r\n    /// @dev thrown if msg.sender is not a superform\r\n    error NOT_SUPERFORM();\r\n\r\n    /// @dev thrown if msg.sender is not superform factory\r\n    error NOT_SUPERFORM_FACTORY();\r\n\r\n    /// @dev thrown if msg.sender is not timelock form\r\n    error NOT_TIMELOCK_SUPERFORM();\r\n\r\n    /// @dev thrown if msg.sender is not timelock state registry\r\n    error NOT_TIMELOCK_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not user or disputer\r\n    error NOT_VALID_DISPUTER();\r\n\r\n    /// @dev thrown if the msg.sender is not privileged caller\r\n    error NOT_PRIVILEGED_CALLER(bytes32 role);\r\n\r\n    /// STATE REGISTRY AUTHORIZATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev layerzero adapter specific error, thrown if caller not layerzero endpoint\r\n    error CALLER_NOT_ENDPOINT();\r\n\r\n    /// @dev hyperlane adapter specific error, thrown if caller not hyperlane mailbox\r\n    error CALLER_NOT_MAILBOX();\r\n\r\n    /// @dev wormhole relayer specific error, thrown if caller not wormhole relayer\r\n    error CALLER_NOT_RELAYER();\r\n\r\n    /// @dev thrown if src chain sender is not valid\r\n    error INVALID_SRC_SENDER();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  INPUT VALIDATION ERRORS                 //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown if input variables are not valid\r\n\r\n    /// COMMON INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if there is an array length mismatch\r\n    error ARRAY_LENGTH_MISMATCH();\r\n\r\n    /// @dev thrown if payload id does not exist\r\n    error INVALID_PAYLOAD_ID();\r\n\r\n    /// @dev error thrown when msg value should be zero in certain payable functions\r\n    error MSG_VALUE_NOT_ZERO();\r\n\r\n    /// @dev thrown if amb ids length is 0\r\n    error ZERO_AMB_ID_LENGTH();\r\n\r\n    /// @dev thrown if address input is address 0\r\n    error ZERO_ADDRESS();\r\n\r\n    /// @dev thrown if amount input is 0\r\n    error ZERO_AMOUNT();\r\n\r\n    /// @dev thrown if value input is 0\r\n    error ZERO_INPUT_VALUE();\r\n\r\n    /// SUPERFORM ROUTER INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if the vaults data is invalid\r\n    error INVALID_SUPERFORMS_DATA();\r\n\r\n    /// @dev thrown if receiver address is not set\r\n    error RECEIVER_ADDRESS_NOT_SET();\r\n\r\n    /// SUPERFORM FACTORY INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if a form is not ERC165 compatible\r\n    error ERC165_UNSUPPORTED();\r\n\r\n    /// @dev thrown if a form is not form interface compatible\r\n    error FORM_INTERFACE_UNSUPPORTED();\r\n\r\n    /// @dev error thrown if form implementation address already exists\r\n    error FORM_IMPLEMENTATION_ALREADY_EXISTS();\r\n\r\n    /// @dev error thrown if form implementation id already exists\r\n    error FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\r\n\r\n    /// @dev thrown if a form does not exist\r\n    error FORM_DOES_NOT_EXIST();\r\n\r\n    /// @dev thrown if form id is larger than max uint16\r\n    error INVALID_FORM_ID();\r\n\r\n    /// @dev thrown if superform not on factory\r\n    error SUPERFORM_ID_NONEXISTENT();\r\n\r\n    /// @dev thrown if same vault and form implementation is used to create new superform\r\n    error VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\r\n\r\n    /// FORM INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if in case of no txData, if liqData.token != vault.asset()\r\n    /// in case of txData, if token output of swap != vault.asset()\r\n    error DIFFERENT_TOKENS();\r\n\r\n    /// @dev thrown if the amount in direct withdraw is not correct\r\n    error DIRECT_WITHDRAW_INVALID_LIQ_REQUEST();\r\n\r\n    /// @dev thrown if the amount in xchain withdraw is not correct\r\n    error XCHAIN_WITHDRAW_INVALID_LIQ_REQUEST();\r\n\r\n    /// LIQUIDITY BRIDGE INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev error thrown when txData selector of lifi bridged is a blacklisted selector\r\n    error BLACKLISTED_SELECTOR();\r\n\r\n    /// @dev thrown if a certain action of the user is not allowed given the txData provided\r\n    error INVALID_ACTION();\r\n\r\n    /// @dev thrown if in deposits, the liqDstChainId doesn't match the stateReq dstChainId\r\n    error INVALID_DEPOSIT_LIQ_DST_CHAIN_ID();\r\n\r\n    /// @dev thrown if index is invalid\r\n    error INVALID_INDEX();\r\n\r\n    /// @dev thrown if the chain id in the txdata is invalid\r\n    error INVALID_TXDATA_CHAIN_ID();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to a destination call present\r\n    error INVALID_TXDATA_NO_DESTINATIONCALL_ALLOWED();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to wrong receiver\r\n    error INVALID_TXDATA_RECEIVER();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to wrong token\r\n    error INVALID_TXDATA_TOKEN();\r\n\r\n    /// @dev thrown if txData is not present (in case of xChain actions)\r\n    error NO_TXDATA_PRESENT();\r\n\r\n    /// STATE REGISTRY INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if payload is being updated with final amounts length different than amounts length\r\n    error DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\r\n\r\n    /// @dev thrown if payload is being updated with tx data length different than liq data length\r\n    error DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\r\n\r\n    /// @dev thrown if keeper update final token is different than the vault underlying\r\n    error INVALID_UPDATE_FINAL_TOKEN();\r\n\r\n    /// @dev thrown if broadcast finality for wormhole is invalid\r\n    error INVALID_BROADCAST_FINALITY();\r\n\r\n    /// @dev thrown if amb id is not valid leading to an address 0 of the implementation\r\n    error INVALID_BRIDGE_ID();\r\n\r\n    /// @dev thrown if chain id involved in xchain message is invalid\r\n    error INVALID_CHAIN_ID();\r\n\r\n    /// @dev thrown if payload update amount isn't equal to dst swapper amount\r\n    error INVALID_DST_SWAP_AMOUNT();\r\n\r\n    /// @dev thrown if message amb and proof amb are the same\r\n    error INVALID_PROOF_BRIDGE_ID();\r\n\r\n    /// @dev thrown if order of proof AMBs is incorrect, either duplicated or not incrementing\r\n    error INVALID_PROOF_BRIDGE_IDS();\r\n\r\n    /// @dev thrown if rescue data lengths are invalid\r\n    error INVALID_RESCUE_DATA();\r\n\r\n    /// @dev thrown if delay is invalid\r\n    error INVALID_TIMELOCK_DELAY();\r\n\r\n    /// @dev thrown if amounts being sent in update payload mean a negative slippage\r\n    error NEGATIVE_SLIPPAGE();\r\n\r\n    /// @dev thrown if slippage is outside of bounds\r\n    error SLIPPAGE_OUT_OF_BOUNDS();\r\n\r\n    /// SUPERPOSITION INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if src senders mismatch in state sync\r\n    error SRC_SENDER_MISMATCH();\r\n\r\n    /// @dev thrown if src tx types mismatch in state sync\r\n    error SRC_TX_TYPE_MISMATCH();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  EXECUTION ERRORS                        //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown due to function execution logic\r\n\r\n    /// COMMON EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if the swap in a direct deposit resulted in insufficient tokens\r\n    error DIRECT_DEPOSIT_SWAP_FAILED();\r\n\r\n    /// @dev thrown if payload is not unique\r\n    error DUPLICATE_PAYLOAD();\r\n\r\n    /// @dev thrown if native tokens fail to be sent to superform contracts\r\n    error FAILED_TO_SEND_NATIVE();\r\n\r\n    /// @dev thrown if allowance is not correct to deposit\r\n    error INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\r\n\r\n    /// @dev thrown if contract has insufficient balance for operations\r\n    error INSUFFICIENT_BALANCE();\r\n\r\n    /// @dev thrown if native amount is not at least equal to the amount in the request\r\n    error INSUFFICIENT_NATIVE_AMOUNT();\r\n\r\n    /// @dev thrown if payload cannot be decoded\r\n    error INVALID_PAYLOAD();\r\n\r\n    /// @dev thrown if payload status is invalid\r\n    error INVALID_PAYLOAD_STATUS();\r\n\r\n    /// @dev thrown if payload type is invalid\r\n    error INVALID_PAYLOAD_TYPE();\r\n\r\n    /// LIQUIDITY BRIDGE EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if we try to decode the final swap output token in a xChain liquidity bridging action\r\n    error CANNOT_DECODE_FINAL_SWAP_OUTPUT_TOKEN();\r\n\r\n    /// @dev thrown if liquidity bridge fails for erc20 or native tokens\r\n    error FAILED_TO_EXECUTE_TXDATA(address token);\r\n\r\n    /// @dev thrown if asset being used for deposit mismatches in multivault deposits\r\n    error INVALID_DEPOSIT_TOKEN();\r\n\r\n    /// STATE REGISTRY EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if bridge tokens haven't arrived to destination\r\n    error BRIDGE_TOKENS_PENDING();\r\n\r\n    /// @dev thrown if withdrawal tx data cannot be updated\r\n    error CANNOT_UPDATE_WITHDRAW_TX_DATA();\r\n\r\n    /// @dev thrown if rescue passed dispute deadline\r\n    error DISPUTE_TIME_ELAPSED();\r\n\r\n    /// @dev thrown if message failed to reach the specified level of quorum needed\r\n    error INSUFFICIENT_QUORUM();\r\n\r\n    /// @dev thrown if broadcast payload is invalid\r\n    error INVALID_BROADCAST_PAYLOAD();\r\n\r\n    /// @dev thrown if broadcast fee is invalid\r\n    error INVALID_BROADCAST_FEE();\r\n\r\n    /// @dev thrown if retry fees is less than required\r\n    error INVALID_RETRY_FEE();\r\n\r\n    /// @dev thrown if broadcast message type is wrong\r\n    error INVALID_MESSAGE_TYPE();\r\n\r\n    /// @dev thrown if payload hash is invalid during `retryMessage` on Layezero implementation\r\n    error INVALID_PAYLOAD_HASH();\r\n\r\n    /// @dev thrown if update payload function was called on a wrong payload\r\n    error INVALID_PAYLOAD_UPDATE_REQUEST();\r\n\r\n    /// @dev thrown if a state registry id is 0\r\n    error INVALID_REGISTRY_ID();\r\n\r\n    /// @dev thrown if a form state registry id is 0\r\n    error INVALID_FORM_REGISTRY_ID();\r\n\r\n    /// @dev thrown if trying to finalize the payload but the withdraw is still locked\r\n    error LOCKED();\r\n\r\n    /// @dev thrown if payload is already updated (during xChain deposits)\r\n    error PAYLOAD_ALREADY_UPDATED();\r\n\r\n    /// @dev thrown if payload is already processed\r\n    error PAYLOAD_ALREADY_PROCESSED();\r\n\r\n    /// @dev thrown if payload is not in UPDATED state\r\n    error PAYLOAD_NOT_UPDATED();\r\n\r\n    /// @dev thrown if rescue is still in timelocked state\r\n    error RESCUE_LOCKED();\r\n\r\n    /// @dev thrown if rescue is already proposed\r\n    error RESCUE_ALREADY_PROPOSED();\r\n\r\n    /// @dev thrown if payload hash is zero during `retryMessage` on Layezero implementation\r\n    error ZERO_PAYLOAD_HASH();\r\n\r\n    /// DST SWAPPER EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if process dst swap is tried for processed payload id\r\n    error DST_SWAP_ALREADY_PROCESSED();\r\n\r\n    /// @dev thrown if indices have duplicates\r\n    error DUPLICATE_INDEX();\r\n\r\n    /// @dev thrown if failed dst swap is already updated\r\n    error FAILED_DST_SWAP_ALREADY_UPDATED();\r\n\r\n    /// @dev thrown if indices are out of bounds\r\n    error INDEX_OUT_OF_BOUNDS();\r\n\r\n    /// @dev thrown if failed swap token amount is 0\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP();\r\n\r\n    /// @dev thrown if failed swap token amount is not 0 and if token balance is less than amount (non zero)\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_TOKEN_BALANCE();\r\n\r\n    /// @dev thrown if failed swap token amount is not 0 and if native amount is less than amount (non zero)\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_NATIVE_BALANCE();\r\n\r\n    /// @dev forbid xChain deposits with destination swaps without interim token set (for user protection)\r\n    error INVALID_INTERIM_TOKEN();\r\n\r\n    /// @dev thrown if dst swap output is less than minimum expected\r\n    error INVALID_SWAP_OUTPUT();\r\n\r\n    /// FORM EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if try to forward 4626 share from the superform\r\n    error CANNOT_FORWARD_4646_TOKEN();\r\n\r\n    /// @dev thrown in KYCDAO form if no KYC token is present\r\n    error NO_VALID_KYC_TOKEN();\r\n\r\n    /// @dev thrown in forms where a certain functionality is not allowed or implemented\r\n    error NOT_IMPLEMENTED();\r\n\r\n    /// @dev thrown if form implementation is PAUSED, users cannot perform any action\r\n    error PAUSED();\r\n\r\n    /// @dev thrown if shares != deposit output or assets != redeem output when minting SuperPositions\r\n    error VAULT_IMPLEMENTATION_FAILED();\r\n\r\n    /// @dev thrown if withdrawal tx data is not updated\r\n    error WITHDRAW_TOKEN_NOT_UPDATED();\r\n\r\n    /// @dev thrown if withdrawal tx data is not updated\r\n    error WITHDRAW_TX_DATA_NOT_UPDATED();\r\n\r\n    /// @dev thrown when redeeming from vault yields zero collateral\r\n    error WITHDRAW_ZERO_COLLATERAL();\r\n\r\n    /// PAYMENT HELPER EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if chainlink is reporting an improper price\r\n    error CHAINLINK_MALFUNCTION();\r\n\r\n    /// @dev thrown if chainlink is reporting an incomplete round\r\n    error CHAINLINK_INCOMPLETE_ROUND();\r\n\r\n    /// @dev thrown if feed decimals is not 8\r\n    error CHAINLINK_UNSUPPORTED_DECIMAL();\r\n\r\n    /// EMERGENCY QUEUE EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if emergency withdraw is not queued\r\n    error EMERGENCY_WITHDRAW_NOT_QUEUED();\r\n\r\n    /// @dev thrown if emergency withdraw is already processed\r\n    error EMERGENCY_WITHDRAW_PROCESSED_ALREADY();\r\n\r\n    /// SUPERPOSITION EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if uri cannot be updated\r\n    error DYNAMIC_URI_FROZEN();\r\n\r\n    /// @dev thrown if tx history is not found while state sync\r\n    error TX_HISTORY_NOT_FOUND();\r\n}\r\n\r\nlibrary DataLib {\r\n    function packTxInfo(\r\n        uint8 txType_,\r\n        uint8 callbackType_,\r\n        uint8 multi_,\r\n        uint8 registryId_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 txInfo)\r\n    {\r\n        txInfo = uint256(txType_);\r\n        txInfo |= uint256(callbackType_) << 8;\r\n        txInfo |= uint256(multi_) << 16;\r\n        txInfo |= uint256(registryId_) << 24;\r\n        txInfo |= uint256(uint160(srcSender_)) << 32;\r\n        txInfo |= uint256(srcChainId_) << 192;\r\n    }\r\n\r\n    function decodeTxInfo(uint256 txInfo_)\r\n        internal\r\n        pure\r\n        returns (uint8 txType, uint8 callbackType, uint8 multi, uint8 registryId, address srcSender, uint64 srcChainId)\r\n    {\r\n        txType = uint8(txInfo_);\r\n        callbackType = uint8(txInfo_ >> 8);\r\n        multi = uint8(txInfo_ >> 16);\r\n        registryId = uint8(txInfo_ >> 24);\r\n        srcSender = address(uint160(txInfo_ >> 32));\r\n        srcChainId = uint64(txInfo_ >> 192);\r\n    }\r\n\r\n    /// @dev returns the vault-form-chain pair of a superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return superform_ is the address of the superform\r\n    /// @return formImplementationId_ is the form id\r\n    /// @return chainId_ is the chain id\r\n    function getSuperform(uint256 superformId_)\r\n        internal\r\n        pure\r\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_)\r\n    {\r\n        superform_ = address(uint160(superformId_));\r\n        formImplementationId_ = uint32(superformId_ >> 160);\r\n        chainId_ = uint64(superformId_ >> 192);\r\n\r\n        if (chainId_ == 0) {\r\n            revert Error.INVALID_CHAIN_ID();\r\n        }\r\n    }\r\n\r\n    /// @dev returns the vault-form-chain pair of an array of superforms\r\n    /// @param superformIds_  array of superforms\r\n    /// @return superforms_ are the address of the vaults\r\n    function getSuperforms(uint256[] memory superformIds_) internal pure returns (address[] memory superforms_) {\r\n        uint256 len = superformIds_.length;\r\n        superforms_ = new address[](len);\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            (superforms_[i],,) = getSuperform(superformIds_[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev returns the destination chain of a given superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return chainId_ is the chain id\r\n    function getDestinationChain(uint256 superformId_) internal pure returns (uint64 chainId_) {\r\n        chainId_ = uint64(superformId_ >> 192);\r\n\r\n        if (chainId_ == 0) {\r\n            revert Error.INVALID_CHAIN_ID();\r\n        }\r\n    }\r\n\r\n    /// @dev generates the superformId\r\n    /// @param superform_ is the address of the superform\r\n    /// @param formImplementationId_ is the type of the form\r\n    /// @param chainId_ is the chain id on which the superform is deployed\r\n    function packSuperform(\r\n        address superform_,\r\n        uint32 formImplementationId_,\r\n        uint64 chainId_\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 superformId_)\r\n    {\r\n        superformId_ = uint256(uint160(superform_));\r\n        superformId_ |= uint256(formImplementationId_) << 160;\r\n        superformId_ |= uint256(chainId_) << 192;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Storage of the initializable contract.\r\n     *\r\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\r\n     * when using with upgradeable contracts.\r\n     *\r\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\r\n     */\r\n    struct InitializableStorage {\r\n        /**\r\n         * @dev Indicates that the contract has been initialized.\r\n         */\r\n        uint64 _initialized;\r\n        /**\r\n         * @dev Indicates that the contract is in the process of being initialized.\r\n         */\r\n        bool _initializing;\r\n    }\r\n\r\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\r\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\r\n\r\n    /**\r\n     * @dev The contract is already initialized.\r\n     */\r\n    error InvalidInitialization();\r\n\r\n    /**\r\n     * @dev The contract is not initializing.\r\n     */\r\n    error NotInitializing();\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint64 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\r\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\r\n     * production.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        // Cache values to avoid duplicated sloads\r\n        bool isTopLevelCall = !$._initializing;\r\n        uint64 initialized = $._initialized;\r\n\r\n        // Allowed calls:\r\n        // - initialSetup: the contract is not in the initializing state and no previous version was\r\n        //                 initialized\r\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\r\n        //                 current contract is just being deployed\r\n        bool initialSetup = initialized == 0 && isTopLevelCall;\r\n        bool construction = initialized == 1 && address(this).code.length == 0;\r\n\r\n        if (!initialSetup && !construction) {\r\n            revert InvalidInitialization();\r\n        }\r\n        $._initialized = 1;\r\n        if (isTopLevelCall) {\r\n            $._initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            $._initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint64 version) {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        if ($._initializing || $._initialized >= version) {\r\n            revert InvalidInitialization();\r\n        }\r\n        $._initialized = version;\r\n        $._initializing = true;\r\n        _;\r\n        $._initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        _checkInitializing();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\r\n     */\r\n    function _checkInitializing() internal view virtual {\r\n        if (!_isInitializing()) {\r\n            revert NotInitializing();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        InitializableStorage storage $ = _getInitializableStorage();\r\n\r\n        if ($._initializing) {\r\n            revert InvalidInitialization();\r\n        }\r\n        if ($._initialized != type(uint64).max) {\r\n            $._initialized = type(uint64).max;\r\n            emit Initialized(type(uint64).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint64) {\r\n        return _getInitializableStorage()._initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _getInitializableStorage()._initializing;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a pointer to the storage namespace.\r\n     */\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\r\n        assembly {\r\n            $.slot := INITIALIZABLE_STORAGE\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n/// @title BaseForm\r\n/// @dev Abstract contract to be inherited by different Form implementations\r\n/// @author Zeropoint Labs\r\nabstract contract BaseForm is IBaseForm, Initializable, ERC165 {\r\n\r\n    using DataLib for uint256;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                         CONSTANTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    ISuperRegistry public immutable superRegistry;\r\n    uint64 public immutable CHAIN_ID;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                     STATE VARIABLES                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev the address of the vault that was added\r\n    address public vault;\r\n\r\n    /// @dev underlying asset of vault this form pertains to\r\n    address public asset;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                       MODIFIERS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    modifier notPaused(InitSingleVaultData memory singleVaultData_) {\r\n        if (\r\n            !ISuperformFactory(superRegistry.getAddress(keccak256(\"SUPERFORM_FACTORY\"))).isSuperform(\r\n                singleVaultData_.superformId\r\n            )\r\n        ) {\r\n            revert Error.SUPERFORM_ID_NONEXISTENT();\r\n        }\r\n\r\n        (, uint32 formImplementationId_,) = singleVaultData_.superformId.getSuperform();\r\n\r\n        if (\r\n            ISuperformFactory(superRegistry.getAddress(keccak256(\"SUPERFORM_FACTORY\"))).isFormImplementationPaused(\r\n                formImplementationId_\r\n            )\r\n        ) revert Error.PAUSED();\r\n        _;\r\n    }\r\n\r\n    modifier onlySuperRouter() {\r\n        if (superRegistry.getAddress(keccak256(\"SUPERFORM_ROUTER\")) != msg.sender) revert Error.NOT_SUPERFORM_ROUTER();\r\n        _;\r\n    }\r\n\r\n    modifier onlyCoreStateRegistry() {\r\n        if (superRegistry.getAddress(keccak256(\"CORE_STATE_REGISTRY\")) != msg.sender) {\r\n            revert Error.NOT_CORE_STATE_REGISTRY();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyEmergencyQueue() {\r\n        if (msg.sender != superRegistry.getAddress(keccak256(\"EMERGENCY_QUEUE\"))) {\r\n            revert Error.NOT_EMERGENCY_QUEUE();\r\n        }\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                      CONSTRUCTOR                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    constructor(address superRegistry_) {\r\n        if (superRegistry_ == address(0)) {\r\n            revert Error.ZERO_ADDRESS();\r\n        }\r\n\r\n        if (block.chainid > type(uint64).max) {\r\n            revert Error.BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\r\n        }\r\n\r\n        CHAIN_ID = uint64(block.chainid);\r\n        superRegistry = ISuperRegistry(superRegistry_);\r\n\r\n        _disableInitializers();\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function superformYieldTokenName() external view virtual override returns (string memory);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function superformYieldTokenSymbol() external view virtual override returns (string memory);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function getStateRegistryId() external view virtual override returns (uint8);\r\n\r\n    // @inheritdoc IBaseForm\r\n    function getVaultAddress() external view override returns (address) {\r\n        return vault;\r\n    }\r\n\r\n    // @inheritdoc IBaseForm\r\n    function getVaultAsset() public view override returns (address) {\r\n        return asset;\r\n    }\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function getVaultName() public view virtual override returns (string memory);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function getVaultSymbol() public view virtual override returns (string memory);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function getVaultDecimals() public view virtual override returns (uint256);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function getPricePerVaultShare() public view virtual override returns (uint256);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function getVaultShareBalance() public view virtual override returns (uint256);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function getTotalAssets() public view virtual override returns (uint256);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function getTotalSupply() public view virtual override returns (uint256);\r\n\r\n    // @inheritdoc IBaseForm\r\n    function getPreviewPricePerVaultShare() public view virtual override returns (uint256);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function previewDepositTo(uint256 assets_) public view virtual override returns (uint256);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function previewWithdrawFrom(uint256 assets_) public view virtual override returns (uint256);\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function previewRedeemFrom(uint256 shares_) public view virtual override returns (uint256);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @param superRegistry_  ISuperRegistry address deployed\r\n    /// @param vault_ The vault address this form pertains to\r\n    /// @param asset_ The underlying asset address of the vault this form pertains to\r\n    function initialize(address superRegistry_, address vault_, address asset_) external initializer {\r\n        if (ISuperRegistry(superRegistry_) != superRegistry) revert Error.NOT_SUPER_REGISTRY();\r\n        if (vault_ == address(0) || asset_ == address(0)) revert Error.ZERO_ADDRESS();\r\n        vault = vault_;\r\n        asset = asset_;\r\n    }\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function directDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        external\r\n        payable\r\n        override\r\n        onlySuperRouter\r\n        notPaused(singleVaultData_)\r\n        returns (uint256 shares)\r\n    {\r\n        shares = _directDepositIntoVault(singleVaultData_, srcSender_);\r\n    }\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function directWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        external\r\n        override\r\n        onlySuperRouter\r\n        returns (uint256 assets)\r\n    {\r\n        if (!_isPaused(singleVaultData_.superformId)) {\r\n            assets = _directWithdrawFromVault(singleVaultData_, srcSender_);\r\n        } else {\r\n            IEmergencyQueue(superRegistry.getAddress(keccak256(\"EMERGENCY_QUEUE\"))).queueWithdrawal(singleVaultData_);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function xChainDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        external\r\n        override\r\n        onlyCoreStateRegistry\r\n        notPaused(singleVaultData_)\r\n        returns (uint256 shares)\r\n    {\r\n        if (srcChainId_ != 0 && srcChainId_ != CHAIN_ID) {\r\n            shares = _xChainDepositIntoVault(singleVaultData_, srcSender_, srcChainId_);\r\n        } else {\r\n            revert Error.INVALID_CHAIN_ID();\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function xChainWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        external\r\n        override\r\n        onlyCoreStateRegistry\r\n        returns (uint256 assets)\r\n    {\r\n        if (srcChainId_ != 0 && srcChainId_ != CHAIN_ID) {\r\n            if (!_isPaused(singleVaultData_.superformId)) {\r\n                assets = _xChainWithdrawFromVault(singleVaultData_, srcSender_, srcChainId_);\r\n            } else {\r\n                IEmergencyQueue(superRegistry.getAddress(keccak256(\"EMERGENCY_QUEUE\"))).queueWithdrawal(\r\n                    singleVaultData_\r\n                );\r\n            }\r\n        } else {\r\n            revert Error.INVALID_CHAIN_ID();\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function emergencyWithdraw(address receiverAddress_, uint256 amount_) external override onlyEmergencyQueue {\r\n        _emergencyWithdraw(receiverAddress_, amount_);\r\n    }\r\n\r\n    /// @inheritdoc IBaseForm\r\n    function forwardDustToPaymaster(address token_) external override {\r\n        if (token_ == vault) revert Error.CANNOT_FORWARD_4646_TOKEN();\r\n        _forwardDustToPaymaster(token_);\r\n    }\r\n\r\n    /// @dev Checks if the Form implementation has the appropriate interface support\r\n    /// @param interfaceId_ is the interfaceId to check  \r\n    function supportsInterface(bytes4 interfaceId_) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId_ == type(IBaseForm).interfaceId || super.supportsInterface(interfaceId_);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  INTERNAL FUNCTIONS                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev Deposits underlying tokens into a vault\r\n    function _directDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        internal\r\n        virtual\r\n        returns (uint256 shares);\r\n\r\n    /// @dev Deposits underlying tokens into a vault\r\n    function _xChainDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        virtual\r\n        returns (uint256 shares);\r\n\r\n    /// @dev Withdraws underlying tokens from a vault\r\n    function _directWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        internal\r\n        virtual\r\n        returns (uint256 assets);\r\n\r\n    /// @dev Withdraws underlying tokens from a vault\r\n    function _xChainWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        virtual\r\n        returns (uint256 assets);\r\n\r\n    /// @dev withdraws vault shares from form during emergency\r\n    function _emergencyWithdraw(address receiverAddress_, uint256 amount_) internal virtual;\r\n\r\n    /// @dev forwards dust to paymaster\r\n    function _forwardDustToPaymaster(address token_) internal virtual;\r\n\r\n    /// @dev returns if a form id is paused\r\n    function _isPaused(uint256 superformId) internal view returns (bool) {\r\n        address factory = superRegistry.getAddress(keccak256(\"SUPERFORM_FACTORY\"));\r\n        if (!ISuperformFactory(factory).isSuperform(superformId)) {\r\n            revert Error.SUPERFORM_ID_NONEXISTENT();\r\n        }\r\n\r\n        (, uint32 formImplementationId_,) = superformId.getSuperform();\r\n\r\n        return ISuperformFactory(factory).isFormImplementationPaused(formImplementationId_);\r\n    }\r\n}\r\n\r\n/// @title IBroadcastRegistry\r\n/// @dev Interface for BroadcastRegistry\r\n/// @author ZeroPoint Labs\r\ninterface IBroadcastRegistry {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows core contracts to send payload to all configured destination chain.\r\n    /// @param srcSender_ is the caller of the function (used for gas refunds).\r\n    /// @param ambId_ is the identifier of the arbitrary message bridge to be used\r\n    /// @param gasFee_ is the gas fee to be used for broadcasting\r\n    /// @param message_ is the crosschain payload to be broadcasted\r\n    /// @param extraData_ defines all the message bridge related overrides\r\n    function broadcastPayload(\r\n        address srcSender_,\r\n        uint8 ambId_,\r\n        uint256 gasFee_,\r\n        bytes memory message_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable;\r\n\r\n    /// @dev allows ambs to write broadcasted payloads\r\n    function receiveBroadcastPayload(uint64 srcChainId_, bytes memory message_) external;\r\n\r\n    /// @dev allows privileged actors to process broadcasted payloads\r\n    /// @param payloadId_ is the identifier of the cross-chain payload\r\n    function processPayload(uint256 payloadId_) external;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC-165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev The `account` is missing a role.\r\n     */\r\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\r\n\r\n    /**\r\n     * @dev The caller of a function is not the expected one.\r\n     *\r\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\r\n     */\r\n    error AccessControlBadConfirmation();\r\n\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `callerConfirmation`.\r\n     */\r\n    function renounceRole(bytes32 role, address callerConfirmation) external;\r\n}\r\n\r\n/// @title ISuperRBAC\r\n/// @dev Interface for SuperRBAC\r\n/// @author Zeropoint Labs\r\ninterface ISuperRBAC is IAccessControl {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    struct InitialRoleSetup {\r\n        address admin;\r\n        address emergencyAdmin;\r\n        address paymentAdmin;\r\n        address csrProcessor;\r\n        address tlProcessor;\r\n        address brProcessor;\r\n        address csrUpdater;\r\n        address srcVaaRelayer;\r\n        address dstSwapper;\r\n        address csrRescuer;\r\n        address csrDisputer;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when superRegistry is set\r\n    event SuperRegistrySet(address indexed superRegistry);\r\n\r\n    /// @dev is emitted when an admin is set for a role\r\n    event RoleAdminSet(bytes32 role, bytes32 adminRole);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the id of the protocol admin role\r\n    function PROTOCOL_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the emergency admin role\r\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the payment admin role\r\n    function PAYMENT_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcaster role\r\n    function BROADCASTER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry processor role\r\n    function CORE_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the timelock state registry processor role\r\n    function TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcast state registry processor role\r\n    function BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater role\r\n    function CORE_STATE_REGISTRY_UPDATER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the dst swapper role\r\n    function DST_SWAPPER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry rescuer role\r\n    function CORE_STATE_REGISTRY_RESCUER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry rescue disputer role\r\n    function CORE_STATE_REGISTRY_DISPUTER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of wormhole vaa relayer role\r\n    function WORMHOLE_VAA_RELAYER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns whether the given address has the protocol admin role\r\n    /// @param admin_ the address to check\r\n    function hasProtocolAdminRole(address admin_) external view returns (bool);\r\n\r\n    /// @dev returns whether the given address has the emergency admin role\r\n    /// @param admin_ the address to check\r\n    function hasEmergencyAdminRole(address admin_) external view returns (bool);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev updates the super registry address\r\n    function setSuperRegistry(address superRegistry_) external;\r\n\r\n    /// @dev configures a new role in superForm\r\n    /// @param role_ the role to set\r\n    /// @param adminRole_ the admin role to set as admin\r\n    function setRoleAdmin(bytes32 role_, bytes32 adminRole_) external;\r\n\r\n    /// @dev revokes the role_ from superRegistryAddressId_ on all chains\r\n    /// @param role_ the role to revoke\r\n    /// @param extraData_ amb config if broadcasting is required\r\n    /// @param superRegistryAddressId_ the super registry address id\r\n    function revokeRoleSuperBroadcast(\r\n        bytes32 role_,\r\n        bytes memory extraData_,\r\n        bytes32 superRegistryAddressId_\r\n    )\r\n        external\r\n        payable;\r\n\r\n    /// @dev allows sync of global roles from different chains using broadcast registry\r\n    /// @notice may not work for all roles\r\n    function stateSyncBroadcast(bytes memory data_) external;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\r\n\r\n/**\r\n * @dev Library used to query support of an interface declared via {IERC165}.\r\n *\r\n * Note that these functions return the actual result of the query: they do not\r\n * `revert` if an interface is not supported. It is up to the caller to decide\r\n * what to do in these cases.\r\n */\r\nlibrary ERC165Checker {\r\n    // As per the ERC-165 spec, no interface should ever match 0xffffffff\r\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the {IERC165} interface.\r\n     */\r\n    function supportsERC165(address account) internal view returns (bool) {\r\n        // Any contract that implements ERC-165 must explicitly indicate support of\r\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\r\n        return\r\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\r\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the interface defined by\r\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // query support of both ERC-165 as per the spec and support of _interfaceId\r\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a boolean array where each value corresponds to the\r\n     * interfaces passed in and whether they're supported or not. This allows\r\n     * you to batch check interfaces for a contract where your expectation\r\n     * is that some interfaces may not be supported.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function getSupportedInterfaces(\r\n        address account,\r\n        bytes4[] memory interfaceIds\r\n    ) internal view returns (bool[] memory) {\r\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\r\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\r\n\r\n        // query support of ERC-165 itself\r\n        if (supportsERC165(account)) {\r\n            // query support of each interface in interfaceIds\r\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\r\n            }\r\n        }\r\n\r\n        return interfaceIdsSupported;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports all the interfaces defined in\r\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * Batch-querying can lead to gas savings by skipping repeated checks for\r\n     * {IERC165} support.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\r\n        // query support of ERC-165 itself\r\n        if (!supportsERC165(account)) {\r\n            return false;\r\n        }\r\n\r\n        // query support of each interface in interfaceIds\r\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // all interfaces supported\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, does not check ERC-165 support\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Assumes that account contains a contract that supports ERC-165, otherwise\r\n     * the behavior of this method is undefined. This precondition can be checked\r\n     * with {supportsERC165}.\r\n     *\r\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\r\n     * should be exercised when using this function.\r\n     *\r\n     * Interface identification is specified in ERC-165.\r\n     */\r\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // prepare call\r\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\r\n\r\n        // perform static call\r\n        bool success;\r\n        uint256 returnSize;\r\n        uint256 returnValue;\r\n        assembly {\r\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\r\n            returnSize := returndatasize()\r\n            returnValue := mload(0x00)\r\n        }\r\n\r\n        return success && returnSize >= 0x20 && returnValue > 0;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev A clone instance deployment failed.\r\n     */\r\n    error ERC1167FailedCreateClone();\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create(0, 0x09, 0x37)\r\n        }\r\n        if (instance == address(0)) {\r\n            revert ERC1167FailedCreateClone();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create2(0, 0x09, 0x37, salt)\r\n        }\r\n        if (instance == address(0)) {\r\n            revert ERC1167FailedCreateClone();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(add(ptr, 0x38), deployer)\r\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\r\n            mstore(add(ptr, 0x14), implementation)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\r\n            mstore(add(ptr, 0x58), salt)\r\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\r\n            predicted := keccak256(add(ptr, 0x43), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt\r\n    ) internal view returns (address predicted) {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n/// @title SuperformFactory\r\n/// @dev Central point of read & write access for all Superforms on this chain\r\n/// @author Zeropoint Labs\r\ncontract SuperformFactory is ISuperformFactory {\r\n\r\n    using DataLib for uint256;\r\n    using Clones for address;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                         CONSTANTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    ISuperRegistry public immutable superRegistry;\r\n    uint64 public immutable CHAIN_ID;\r\n    bytes32 constant SYNC_IMPLEMENTATION_STATUS = keccak256(\"SYNC_IMPLEMENTATION_STATUS\");\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                     STATE VARIABLES                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    uint256 public xChainPayloadCounter;\r\n\r\n    /// @dev all form implementation addresses\r\n    address[] public formImplementations;\r\n\r\n    /// @dev all superform ids\r\n    uint256[] public superforms;\r\n    mapping(uint256 superformId => bool superformIdExists) public isSuperform;\r\n\r\n    /// @notice If formImplementationId is 0, formImplementation is not part of the protocol\r\n    mapping(uint32 formImplementationId => address formImplementationAddress) public formImplementation;\r\n\r\n    /// @dev each form implementation address can correspond only to a single formImplementationId\r\n    mapping(address formImplementationAddress => uint32 formImplementationId) public formImplementationIds;\r\n    /// @dev this mapping is used only for crosschain cases and should be same across all the chains\r\n    mapping(uint32 formImplementationId => uint8 formRegistryId) public formStateRegistryId;\r\n\r\n    mapping(uint32 formImplementationId => PauseStatus) public formImplementationPaused;\r\n\r\n    mapping(address vault => uint256[] superformIds) public vaultToSuperforms;\r\n\r\n    mapping(address vault => uint256[] formImplementationId) public vaultToFormImplementationId;\r\n\r\n    mapping(bytes32 vaultFormImplementationCombination => uint256 superformIds) public\r\n        vaultFormImplCombinationToSuperforms;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                       MODIFIERS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    modifier onlyEmergencyAdmin() {\r\n        if (!ISuperRBAC(superRegistry.getAddress(keccak256(\"SUPER_RBAC\"))).hasEmergencyAdminRole(msg.sender)) {\r\n            revert Error.NOT_EMERGENCY_ADMIN();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyProtocolAdmin() {\r\n        if (!ISuperRBAC(superRegistry.getAddress(keccak256(\"SUPER_RBAC\"))).hasProtocolAdminRole(msg.sender)) {\r\n            revert Error.NOT_PROTOCOL_ADMIN();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyBroadcastRegistry() {\r\n        /// @dev this function is only accessible through broadcast registry\r\n        if (msg.sender != superRegistry.getAddress(keccak256(\"BROADCAST_REGISTRY\"))) {\r\n            revert Error.NOT_BROADCAST_REGISTRY();\r\n        }\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                      CONSTRUCTOR                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @param superRegistry_ the superform registry contract\r\n    constructor(address superRegistry_) {\r\n        if (superRegistry_ == address(0)) {\r\n            revert Error.ZERO_ADDRESS();\r\n        }\r\n        \r\n        if (block.chainid > type(uint64).max) {\r\n            revert Error.BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\r\n        }\r\n\r\n        CHAIN_ID = uint64(block.chainid);\r\n        superRegistry = ISuperRegistry(superRegistry_);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function getFormCount() external view override returns (uint256 forms_) {\r\n        forms_ = formImplementations.length;\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function getSuperformCount() external view override returns (uint256 superforms_) {\r\n        superforms_ = superforms.length;\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function getFormImplementation(uint32 formImplementationId_) external view override returns (address) {\r\n        return formImplementation[formImplementationId_];\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function getFormStateRegistryId(uint32 formImplementationId_)\r\n        external\r\n        view\r\n        override\r\n        returns (uint8 formStateRegistryId_)\r\n    {\r\n        formStateRegistryId_ = formStateRegistryId[formImplementationId_];\r\n        if (formStateRegistryId_ == 0) revert Error.INVALID_FORM_REGISTRY_ID();\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function isFormImplementationPaused(uint32 formImplementationId_) external view override returns (bool) {\r\n        return formImplementationPaused[formImplementationId_] == PauseStatus.PAUSED;\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function getSuperform(uint256 superformId_)\r\n        external\r\n        pure\r\n        override\r\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_)\r\n    {\r\n        (superform_, formImplementationId_, chainId_) = superformId_.getSuperform();\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function getAllSuperformsFromVault(address vault_)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256[] memory superformIds_, address[] memory superforms_)\r\n    {\r\n        superformIds_ = vaultToSuperforms[vault_];\r\n        uint256 len = superformIds_.length;\r\n        superforms_ = new address[](len);\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            (superforms_[i],,) = superformIds_[i].getSuperform();\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function addFormImplementation(\r\n        address formImplementation_,\r\n        uint32 formImplementationId_,\r\n        uint8 formStateRegistryId_\r\n    )\r\n        public\r\n        override\r\n        onlyProtocolAdmin\r\n    {\r\n        if (formImplementation_ == address(0)) revert Error.ZERO_ADDRESS();\r\n\r\n        if (!ERC165Checker.supportsERC165(formImplementation_)) revert Error.ERC165_UNSUPPORTED();\r\n        if (formImplementation[formImplementationId_] != address(0)) {\r\n            revert Error.FORM_IMPLEMENTATION_ALREADY_EXISTS();\r\n        }\r\n        if (formImplementationIds[formImplementation_] != 0) {\r\n            revert Error.FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\r\n        }\r\n        if (!ERC165Checker.supportsInterface(formImplementation_, type(IBaseForm).interfaceId)) {\r\n            revert Error.FORM_INTERFACE_UNSUPPORTED();\r\n        }\r\n\r\n        /// @dev save the newly added address in the mapping and array registry\r\n        formImplementation[formImplementationId_] = formImplementation_;\r\n        formImplementationIds[formImplementation_] = formImplementationId_;\r\n\r\n        /// @dev set CoreStateRegistry if the form implementation needs no special state registry\r\n        /// @dev if the form needs any special state registry, set this value to the id of the special state registry\r\n        /// and core state registry can be used by default.\r\n        /// @dev if this value is != 1, then the form supports two state registries (CoreStateRegistry + its special\r\n        /// state registry)\r\n        if (formStateRegistryId_ == 0) {\r\n            revert Error.INVALID_FORM_REGISTRY_ID();\r\n        }\r\n\r\n        formStateRegistryId[formImplementationId_] = formStateRegistryId_;\r\n        formImplementations.push(formImplementation_);\r\n\r\n        emit FormImplementationAdded(formImplementation_, formImplementationId_, formStateRegistryId_);\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function createSuperform(\r\n        uint32 formImplementationId_,\r\n        address vault_\r\n    )\r\n        public\r\n        override\r\n        returns (uint256 superformId_, address superform_)\r\n    {\r\n        if (vault_ == address(0)) revert Error.ZERO_ADDRESS();\r\n\r\n        address tFormImplementation = formImplementation[formImplementationId_];\r\n        if (tFormImplementation == address(0)) revert Error.FORM_DOES_NOT_EXIST();\r\n\r\n        /// @dev Same vault and implementation can be used only once to create superform\r\n        bytes32 vaultFormImplementationCombination = keccak256(abi.encode(tFormImplementation, vault_));\r\n        if (vaultFormImplCombinationToSuperforms[vaultFormImplementationCombination] != 0) {\r\n            revert Error.VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\r\n        }\r\n\r\n        /// @dev instantiate the superform\r\n        superform_ = tFormImplementation.cloneDeterministic(\r\n            keccak256(abi.encode(uint256(CHAIN_ID), formImplementationId_, vault_)));\r\n\r\n        BaseForm(payable(superform_)).initialize(address(superRegistry), vault_, address(IERC4626(vault_).asset()));\r\n\r\n        /// @dev this will always be unique because all chainIds are unique\r\n        superformId_ = DataLib.packSuperform(superform_, formImplementationId_, CHAIN_ID);\r\n\r\n        vaultToSuperforms[vault_].push(superformId_);\r\n\r\n        /// @dev map vaults to formImplementationId\r\n        vaultToFormImplementationId[vault_].push(formImplementationId_);\r\n\r\n        vaultFormImplCombinationToSuperforms[vaultFormImplementationCombination] = superformId_;\r\n\r\n        superforms.push(superformId_);\r\n        isSuperform[superformId_] = true;\r\n\r\n        emit SuperformCreated(formImplementationId_, vault_, superformId_, superform_);\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function changeFormImplementationPauseStatus(\r\n        uint32 formImplementationId_,\r\n        PauseStatus status_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable\r\n        override\r\n        onlyEmergencyAdmin\r\n    {\r\n        if (formImplementation[formImplementationId_] == address(0)) revert Error.INVALID_FORM_ID();\r\n        formImplementationPaused[formImplementationId_] = status_;\r\n\r\n        /// @dev broadcast the change in status to the other destination chains\r\n        if (extraData_.length != 0) {\r\n            BroadcastMessage memory factoryPayload = BroadcastMessage(\r\n                \"SUPERFORM_FACTORY\",\r\n                SYNC_IMPLEMENTATION_STATUS,\r\n                abi.encode(CHAIN_ID, ++xChainPayloadCounter, formImplementationId_, status_)\r\n            );\r\n\r\n            _broadcast(abi.encode(factoryPayload), extraData_);\r\n        } else if (msg.value != 0) {\r\n            revert Error.MSG_VALUE_NOT_ZERO();\r\n        }\r\n\r\n        emit FormImplementationPaused(formImplementationId_, status_);\r\n    }\r\n\r\n    /// @inheritdoc ISuperformFactory\r\n    function stateSyncBroadcast(bytes memory data_) external payable override onlyBroadcastRegistry {\r\n        BroadcastMessage memory factoryPayload = abi.decode(data_, (BroadcastMessage));\r\n\r\n        if (factoryPayload.messageType == SYNC_IMPLEMENTATION_STATUS) {\r\n            _syncFormPausedStatus(factoryPayload.message);\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  INTERNAL FUNCTIONS                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev interacts with broadcast state registry to broadcasting state changes to all connected remote chains\r\n    /// @param message_ is the crosschain message to be sent.\r\n    /// @param extraData_ is the amb override information.\r\n    function _broadcast(bytes memory message_, bytes memory extraData_) internal {\r\n        (uint8 ambId, bytes memory broadcastParams) = abi.decode(extraData_, (uint8, bytes));\r\n\r\n        /// @dev if the broadcastParams are wrong this will revert\r\n        (uint256 gasFee, bytes memory extraData) = abi.decode(broadcastParams, (uint256, bytes));\r\n\r\n        if (msg.value < gasFee) {\r\n            revert Error.INVALID_BROADCAST_FEE();\r\n        }\r\n\r\n        /// @dev ambIds are validated inside the broadcast state registry\r\n        IBroadcastRegistry(superRegistry.getAddress(keccak256(\"BROADCAST_REGISTRY\"))).broadcastPayload{ value: gasFee }(\r\n            msg.sender, ambId, gasFee, message_, extraData\r\n        );\r\n\r\n        if (msg.value > gasFee) {\r\n            /// @dev forwards the rest to msg.sender\r\n            (bool success,) = payable(msg.sender).call{ value: msg.value - gasFee }(\"\");\r\n\r\n            if (!success) {\r\n                revert Error.FAILED_TO_SEND_NATIVE();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev synchronize paused status update message from remote chain\r\n    /// @notice is a part of broadcasting / dispatching through factory state registry\r\n    /// @param message_ is the crosschain message received.\r\n    function _syncFormPausedStatus(bytes memory message_) internal {\r\n        (,, uint32 formImplementationId, PauseStatus paused) =\r\n            abi.decode(message_, (uint64, uint256, uint32, PauseStatus));\r\n\r\n        if (formImplementation[formImplementationId] == address(0)) revert Error.INVALID_FORM_ID();\r\n        formImplementationPaused[formImplementationId] = paused;\r\n\r\n        emit FormImplementationPaused(formImplementationId, paused);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BLOCK_CHAIN_ID_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC165_UNSUPPORTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FAILED_TO_SEND_NATIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FORM_DOES_NOT_EXIST\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FORM_IMPLEMENTATION_ALREADY_EXISTS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FORM_IMPLEMENTATION_ID_ALREADY_EXISTS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FORM_INTERFACE_UNSUPPORTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_BROADCAST_FEE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_CHAIN_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_FORM_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_FORM_REGISTRY_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MSG_VALUE_NOT_ZERO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_BROADCAST_REGISTRY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_EMERGENCY_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_PROTOCOL_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"formImplementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"formImplementationId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"formStateRegistryId\",\"type\":\"uint8\"}],\"name\":\"FormImplementationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"formImplementationId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum ISuperformFactory.PauseStatus\",\"name\":\"paused\",\"type\":\"uint8\"}],\"name\":\"FormImplementationPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"superRegistry\",\"type\":\"address\"}],\"name\":\"SuperRegistrySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"formImplementationId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"superform\",\"type\":\"address\"}],\"name\":\"SuperformCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"formImplementation_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"formImplementationId_\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"formStateRegistryId_\",\"type\":\"uint8\"}],\"name\":\"addFormImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId_\",\"type\":\"uint32\"},{\"internalType\":\"enum ISuperformFactory.PauseStatus\",\"name\":\"status_\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"extraData_\",\"type\":\"bytes\"}],\"name\":\"changeFormImplementationPauseStatus\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId_\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"createSuperform\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"superformId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"superform_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId\",\"type\":\"uint32\"}],\"name\":\"formImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"formImplementationAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"formImplementationAddress\",\"type\":\"address\"}],\"name\":\"formImplementationIds\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId\",\"type\":\"uint32\"}],\"name\":\"formImplementationPaused\",\"outputs\":[{\"internalType\":\"enum ISuperformFactory.PauseStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"formImplementations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId\",\"type\":\"uint32\"}],\"name\":\"formStateRegistryId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"formRegistryId\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getAllSuperformsFromVault\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"superforms_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFormCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"forms_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId_\",\"type\":\"uint32\"}],\"name\":\"getFormImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId_\",\"type\":\"uint32\"}],\"name\":\"getFormStateRegistryId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"formStateRegistryId_\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"superformId_\",\"type\":\"uint256\"}],\"name\":\"getSuperform\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"superform_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"formImplementationId_\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSuperformCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"superforms_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"formImplementationId_\",\"type\":\"uint32\"}],\"name\":\"isFormImplementationPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"}],\"name\":\"isSuperform\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"superformIdExists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"stateSyncBroadcast\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superRegistry\",\"outputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"superforms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vaultFormImplementationCombination\",\"type\":\"bytes32\"}],\"name\":\"vaultFormImplCombinationToSuperforms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"superformIds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaultToFormImplementationId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"formImplementationId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaultToSuperforms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"superformIds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xChainPayloadCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SuperformFactory", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b97612a25491e34f5fd11d521c14a042eca039fa", "EVMVersion": "paris", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://27497471ea95732bb813ee0ed91127bc39f201394eb6fbb1c421a07d00df25ee"}