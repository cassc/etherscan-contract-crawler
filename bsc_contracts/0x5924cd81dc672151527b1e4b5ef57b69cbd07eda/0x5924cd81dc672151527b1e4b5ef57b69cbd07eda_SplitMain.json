{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SplitMain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\nimport {ISplitMain} from 'contracts/interfaces/ISplitMain.sol';\\nimport {SplitWallet} from 'contracts/SplitWallet.sol';\\nimport {Clones} from 'contracts/libraries/Clones.sol';\\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\\nimport {SafeTransferLib} from '@rari-capital/solmate/src/utils/SafeTransferLib.sol';\\n\\n/**\\n\\n                                             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n\\n                             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n\\n           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588            \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588            \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588            \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588            \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n      \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n\\n                             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n\\n                                             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                         \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588               \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n                                             \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n\\n */\\n\\n/**\\n * ERRORS\\n */\\n\\n/// @notice Unauthorized sender `sender`\\n/// @param sender Transaction sender\\nerror Unauthorized(address sender);\\n/// @notice Invalid number of accounts `accountsLength`, must have at least 2\\n/// @param accountsLength Length of accounts array\\nerror InvalidSplit__TooFewAccounts(uint256 accountsLength);\\n/// @notice Array lengths of accounts & percentAllocations don't match (`accountsLength` != `allocationsLength`)\\n/// @param accountsLength Length of accounts array\\n/// @param allocationsLength Length of percentAllocations array\\nerror InvalidSplit__AccountsAndAllocationsMismatch(\\n  uint256 accountsLength,\\n  uint256 allocationsLength\\n);\\n/// @notice Invalid percentAllocations sum `allocationsSum` must equal `PERCENTAGE_SCALE`\\n/// @param allocationsSum Sum of percentAllocations array\\nerror InvalidSplit__InvalidAllocationsSum(uint32 allocationsSum);\\n/// @notice Invalid accounts ordering at `index`\\n/// @param index Index of out-of-order account\\nerror InvalidSplit__AccountsOutOfOrder(uint256 index);\\n/// @notice Invalid percentAllocation of zero at `index`\\n/// @param index Index of zero percentAllocation\\nerror InvalidSplit__AllocationMustBePositive(uint256 index);\\n/// @notice Invalid distributorFee `distributorFee` cannot be greater than 10% (1e5)\\n/// @param distributorFee Invalid distributorFee amount\\nerror InvalidSplit__InvalidDistributorFee(uint32 distributorFee);\\n/// @notice Invalid hash `hash` from split data (accounts, percentAllocations, distributorFee)\\n/// @param hash Invalid hash\\nerror InvalidSplit__InvalidHash(bytes32 hash);\\n/// @notice Invalid new controlling address `newController` for mutable split\\n/// @param newController Invalid new controller\\nerror InvalidNewController(address newController);\\n\\n/**\\n * @title SplitMain\\n * @author 0xSplits <will@0xSplits.xyz>\\n * @notice A composable and gas-efficient protocol for deploying splitter contracts.\\n * @dev Split recipients, ownerships, and keeper fees are stored onchain as calldata & re-passed as args / validated\\n * via hashing when needed. Each split gets its own address & proxy for maximum composability with other contracts onchain.\\n * For these proxies, we extended EIP-1167 Minimal Proxy Contract to avoid `DELEGATECALL` inside `receive()` to accept\\n * hard gas-capped `sends` & `transfers`.\\n */\\ncontract SplitMain is ISplitMain {\\n  using SafeTransferLib for address;\\n  using SafeTransferLib for ERC20;\\n\\n  /**\\n   * STRUCTS\\n   */\\n\\n  /// @notice holds Split metadata\\n  struct Split {\\n    bytes32 hash;\\n    address controller;\\n    address newPotentialController;\\n  }\\n\\n  /**\\n   * STORAGE\\n   */\\n\\n  /**\\n   * STORAGE - CONSTANTS & IMMUTABLES\\n   */\\n\\n  /// @notice constant to scale uints into percentages (1e6 == 100%)\\n  uint256 public constant PERCENTAGE_SCALE = 1e6;\\n  /// @notice maximum distributor fee; 1e5 = 10% * PERCENTAGE_SCALE\\n  uint256 internal constant MAX_DISTRIBUTOR_FEE = 1e5;\\n  /// @notice address of wallet implementation for split proxies\\n  address public immutable override walletImplementation;\\n\\n  /**\\n   * STORAGE - VARIABLES - PRIVATE & INTERNAL\\n   */\\n\\n  /// @notice mapping to account ETH balances\\n  mapping(address => uint256) internal ethBalances;\\n  /// @notice mapping to account ERC20 balances\\n  mapping(ERC20 => mapping(address => uint256)) internal erc20Balances;\\n  /// @notice mapping to Split metadata\\n  mapping(address => Split) internal splits;\\n\\n  /**\\n   * MODIFIERS\\n   */\\n\\n  /** @notice Reverts if the sender doesn't own the split `split`\\n   *  @param split Address to check for control\\n   */\\n  modifier onlySplitController(address split) {\\n    if (msg.sender != splits[split].controller) revert Unauthorized(msg.sender);\\n    _;\\n  }\\n\\n  /** @notice Reverts if the sender isn't the new potential controller of split `split`\\n   *  @param split Address to check for new potential control\\n   */\\n  modifier onlySplitNewPotentialController(address split) {\\n    if (msg.sender != splits[split].newPotentialController)\\n      revert Unauthorized(msg.sender);\\n    _;\\n  }\\n\\n  /** @notice Reverts if the split with recipients represented by `accounts` and `percentAllocations` is malformed\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   */\\n  modifier validSplit(\\n    address[] memory accounts,\\n    uint32[] memory percentAllocations,\\n    uint32 distributorFee\\n  ) {\\n    if (accounts.length < 2)\\n      revert InvalidSplit__TooFewAccounts(accounts.length);\\n    if (accounts.length != percentAllocations.length)\\n      revert InvalidSplit__AccountsAndAllocationsMismatch(\\n        accounts.length,\\n        percentAllocations.length\\n      );\\n    // _getSum should overflow if any percentAllocation[i] < 0\\n    if (_getSum(percentAllocations) != PERCENTAGE_SCALE)\\n      revert InvalidSplit__InvalidAllocationsSum(_getSum(percentAllocations));\\n    unchecked {\\n      // overflow should be impossible in for-loop index\\n      // cache accounts length to save gas\\n      uint256 loopLength = accounts.length - 1;\\n      for (uint256 i = 0; i < loopLength; ++i) {\\n        // overflow should be impossible in array access math\\n        if (accounts[i] >= accounts[i + 1])\\n          revert InvalidSplit__AccountsOutOfOrder(i);\\n        if (percentAllocations[i] == uint32(0))\\n          revert InvalidSplit__AllocationMustBePositive(i);\\n      }\\n      // overflow should be impossible in array access math with validated equal array lengths\\n      if (percentAllocations[loopLength] == uint32(0))\\n        revert InvalidSplit__AllocationMustBePositive(loopLength);\\n    }\\n    if (distributorFee > MAX_DISTRIBUTOR_FEE)\\n      revert InvalidSplit__InvalidDistributorFee(distributorFee);\\n    _;\\n  }\\n\\n  /** @notice Reverts if `newController` is the zero address\\n   *  @param newController Proposed new controlling address\\n   */\\n  modifier validNewController(address newController) {\\n    if (newController == address(0)) revert InvalidNewController(newController);\\n    _;\\n  }\\n\\n  /**\\n   * CONSTRUCTOR\\n   */\\n\\n  constructor() {\\n    walletImplementation = address(new SplitWallet());\\n  }\\n\\n  /**\\n   * FUNCTIONS\\n   */\\n\\n  /**\\n   * FUNCTIONS - PUBLIC & EXTERNAL\\n   */\\n\\n  /** @notice Receive ETH\\n   *  @dev Used by split proxies in `distributeETH` to transfer ETH to `SplitMain`\\n   *  Funds sent outside of `distributeETH` will be unrecoverable\\n   */\\n  receive() external payable {}\\n\\n  /** @notice Creates a new split with recipients `accounts` with ownerships `percentAllocations`, a keeper fee for splitting of `distributorFee` and the controlling address `controller`\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @param controller Controlling address (0x0 if immutable)\\n   *  @return split Address of newly created split\\n   */\\n  function createSplit(\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address controller\\n  )\\n    external\\n    override\\n    validSplit(accounts, percentAllocations, distributorFee)\\n    returns (address split)\\n  {\\n    bytes32 splitHash = _hashSplit(\\n      accounts,\\n      percentAllocations,\\n      distributorFee\\n    );\\n    if (controller == address(0)) {\\n      // create immutable split\\n      split = Clones.cloneDeterministic(walletImplementation, splitHash);\\n    } else {\\n      // create mutable split\\n      split = Clones.clone(walletImplementation);\\n      splits[split].controller = controller;\\n    }\\n    // store split's hash in storage for future verification\\n    splits[split].hash = splitHash;\\n    emit CreateSplit(\\n      split,\\n      accounts,\\n      percentAllocations,\\n      distributorFee,\\n      controller\\n    );\\n  }\\n\\n  /** @notice Predicts the address for an immutable split created with recipients `accounts` with ownerships `percentAllocations` and a keeper fee for splitting of `distributorFee`\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @return split Predicted address of such an immutable split\\n   */\\n  function predictImmutableSplitAddress(\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee\\n  )\\n    external\\n    view\\n    override\\n    validSplit(accounts, percentAllocations, distributorFee)\\n    returns (address split)\\n  {\\n    bytes32 splitHash = _hashSplit(\\n      accounts,\\n      percentAllocations,\\n      distributorFee\\n    );\\n    split = Clones.predictDeterministicAddress(walletImplementation, splitHash);\\n  }\\n\\n  /** @notice Updates an existing split with recipients `accounts` with ownerships `percentAllocations` and a keeper fee for splitting of `distributorFee`\\n   *  @param split Address of mutable split to update\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   */\\n  function updateSplit(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee\\n  )\\n    external\\n    override\\n    onlySplitController(split)\\n    validSplit(accounts, percentAllocations, distributorFee)\\n  {\\n    _updateSplit(split, accounts, percentAllocations, distributorFee);\\n  }\\n\\n  /** @notice Begins transfer of the controlling address of mutable split `split` to `newController`\\n   *  @dev Two-step control transfer inspired by [dharma](https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/helpers/TwoStepOwnable.sol)\\n   *  @param split Address of mutable split to transfer control for\\n   *  @param newController Address to begin transferring control to\\n   */\\n  function transferControl(address split, address newController)\\n    external\\n    override\\n    onlySplitController(split)\\n    validNewController(newController)\\n  {\\n    splits[split].newPotentialController = newController;\\n    emit InitiateControlTransfer(split, newController);\\n  }\\n\\n  /** @notice Cancels transfer of the controlling address of mutable split `split`\\n   *  @param split Address of mutable split to cancel control transfer for\\n   */\\n  function cancelControlTransfer(address split)\\n    external\\n    override\\n    onlySplitController(split)\\n  {\\n    delete splits[split].newPotentialController;\\n    emit CancelControlTransfer(split);\\n  }\\n\\n  /** @notice Accepts transfer of the controlling address of mutable split `split`\\n   *  @param split Address of mutable split to accept control transfer for\\n   */\\n  function acceptControl(address split)\\n    external\\n    override\\n    onlySplitNewPotentialController(split)\\n  {\\n    delete splits[split].newPotentialController;\\n    emit ControlTransfer(split, splits[split].controller, msg.sender);\\n    splits[split].controller = msg.sender;\\n  }\\n\\n  /** @notice Turns mutable split `split` immutable\\n   *  @param split Address of mutable split to turn immutable\\n   */\\n  function makeSplitImmutable(address split)\\n    external\\n    override\\n    onlySplitController(split)\\n  {\\n    delete splits[split].newPotentialController;\\n    emit ControlTransfer(split, splits[split].controller, address(0));\\n    splits[split].controller = address(0);\\n  }\\n\\n  /** @notice Distributes the ETH balance for split `split`\\n   *  @dev `accounts`, `percentAllocations`, and `distributorFee` are verified by hashing\\n   *  & comparing to the hash in storage associated with split `split`\\n   *  @param split Address of split to distribute balance for\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @param distributorAddress Address to pay `distributorFee` to\\n   */\\n  function distributeETH(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external override validSplit(accounts, percentAllocations, distributorFee) {\\n    // use internal fn instead of modifier to avoid stack depth compiler errors\\n    _validSplitHash(split, accounts, percentAllocations, distributorFee);\\n    _distributeETH(\\n      split,\\n      accounts,\\n      percentAllocations,\\n      distributorFee,\\n      distributorAddress\\n    );\\n  }\\n\\n  /** @notice Updates & distributes the ETH balance for split `split`\\n   *  @dev only callable by SplitController\\n   *  @param split Address of split to distribute balance for\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @param distributorAddress Address to pay `distributorFee` to\\n   */\\n  function updateAndDistributeETH(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  )\\n    external\\n    override\\n    onlySplitController(split)\\n    validSplit(accounts, percentAllocations, distributorFee)\\n  {\\n    _updateSplit(split, accounts, percentAllocations, distributorFee);\\n    // know splitHash is valid immediately after updating; only accessible via controller\\n    _distributeETH(\\n      split,\\n      accounts,\\n      percentAllocations,\\n      distributorFee,\\n      distributorAddress\\n    );\\n  }\\n\\n  /** @notice Distributes the ERC20 `token` balance for split `split`\\n   *  @dev `accounts`, `percentAllocations`, and `distributorFee` are verified by hashing\\n   *  & comparing to the hash in storage associated with split `split`\\n   *  @dev pernicious ERC20s may cause overflow in this function inside\\n   *  _scaleAmountByPercentage, but results do not affect ETH & other ERC20 balances\\n   *  @param split Address of split to distribute balance for\\n   *  @param token Address of ERC20 to distribute balance for\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @param distributorAddress Address to pay `distributorFee` to\\n   */\\n  function distributeERC20(\\n    address split,\\n    ERC20 token,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external override validSplit(accounts, percentAllocations, distributorFee) {\\n    // use internal fn instead of modifier to avoid stack depth compiler errors\\n    _validSplitHash(split, accounts, percentAllocations, distributorFee);\\n    _distributeERC20(\\n      split,\\n      token,\\n      accounts,\\n      percentAllocations,\\n      distributorFee,\\n      distributorAddress\\n    );\\n  }\\n\\n  /** @notice Updates & distributes the ERC20 `token` balance for split `split`\\n   *  @dev only callable by SplitController\\n   *  @dev pernicious ERC20s may cause overflow in this function inside\\n   *  _scaleAmountByPercentage, but results do not affect ETH & other ERC20 balances\\n   *  @param split Address of split to distribute balance for\\n   *  @param token Address of ERC20 to distribute balance for\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @param distributorAddress Address to pay `distributorFee` to\\n   */\\n  function updateAndDistributeERC20(\\n    address split,\\n    ERC20 token,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  )\\n    external\\n    override\\n    onlySplitController(split)\\n    validSplit(accounts, percentAllocations, distributorFee)\\n  {\\n    _updateSplit(split, accounts, percentAllocations, distributorFee);\\n    // know splitHash is valid immediately after updating; only accessible via controller\\n    _distributeERC20(\\n      split,\\n      token,\\n      accounts,\\n      percentAllocations,\\n      distributorFee,\\n      distributorAddress\\n    );\\n  }\\n\\n  /** @notice Withdraw ETH &/ ERC20 balances for account `account`\\n   *  @param account Address to withdraw on behalf of\\n   *  @param withdrawETH Withdraw all ETH if nonzero\\n   *  @param tokens Addresses of ERC20s to withdraw\\n   */\\n  function withdraw(\\n    address account,\\n    uint256 withdrawETH,\\n    ERC20[] calldata tokens\\n  ) external override {\\n    uint256[] memory tokenAmounts = new uint256[](tokens.length);\\n    uint256 ethAmount;\\n    if (withdrawETH != 0) {\\n      ethAmount = _withdraw(account);\\n    }\\n    unchecked {\\n      // overflow should be impossible in for-loop index\\n      for (uint256 i = 0; i < tokens.length; ++i) {\\n        // overflow should be impossible in array length math\\n        tokenAmounts[i] = _withdrawERC20(account, tokens[i]);\\n      }\\n      emit Withdrawal(account, ethAmount, tokens, tokenAmounts);\\n    }\\n  }\\n\\n  /**\\n   * FUNCTIONS - VIEWS\\n   */\\n\\n  /** @notice Returns the current hash of split `split`\\n   *  @param split Split to return hash for\\n   *  @return Split's hash\\n   */\\n  function getHash(address split) external view returns (bytes32) {\\n    return splits[split].hash;\\n  }\\n\\n  /** @notice Returns the current controller of split `split`\\n   *  @param split Split to return controller for\\n   *  @return Split's controller\\n   */\\n  function getController(address split) external view returns (address) {\\n    return splits[split].controller;\\n  }\\n\\n  /** @notice Returns the current newPotentialController of split `split`\\n   *  @param split Split to return newPotentialController for\\n   *  @return Split's newPotentialController\\n   */\\n  function getNewPotentialController(address split)\\n    external\\n    view\\n    returns (address)\\n  {\\n    return splits[split].newPotentialController;\\n  }\\n\\n  /** @notice Returns the current ETH balance of account `account`\\n   *  @param account Account to return ETH balance for\\n   *  @return Account's balance of ETH\\n   */\\n  function getETHBalance(address account) external view returns (uint256) {\\n    return\\n      ethBalances[account] + (splits[account].hash != 0 ? account.balance : 0);\\n  }\\n\\n  /** @notice Returns the ERC20 balance of token `token` for account `account`\\n   *  @param account Account to return ERC20 `token` balance for\\n   *  @param token Token to return balance for\\n   *  @return Account's balance of `token`\\n   */\\n  function getERC20Balance(address account, ERC20 token)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return\\n      erc20Balances[token][account] +\\n      (splits[account].hash != 0 ? token.balanceOf(account) : 0);\\n  }\\n\\n  /**\\n   * FUNCTIONS - PRIVATE & INTERNAL\\n   */\\n\\n  /** @notice Sums array of uint32s\\n   *  @param numbers Array of uint32s to sum\\n   *  @return sum Sum of `numbers`.\\n   */\\n  function _getSum(uint32[] memory numbers) internal pure returns (uint32 sum) {\\n    // overflow should be impossible in for-loop index\\n    uint256 numbersLength = numbers.length;\\n    for (uint256 i = 0; i < numbersLength; ) {\\n      sum += numbers[i];\\n      unchecked {\\n        // overflow should be impossible in for-loop index\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /** @notice Hashes a split\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @return computedHash Hash of the split.\\n   */\\n  function _hashSplit(\\n    address[] memory accounts,\\n    uint32[] memory percentAllocations,\\n    uint32 distributorFee\\n  ) internal pure returns (bytes32) {\\n    return\\n      keccak256(abi.encodePacked(accounts, percentAllocations, distributorFee));\\n  }\\n\\n  /** @notice Updates an existing split with recipients `accounts` with ownerships `percentAllocations` and a keeper fee for splitting of `distributorFee`\\n   *  @param split Address of mutable split to update\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   */\\n  function _updateSplit(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee\\n  ) internal {\\n    bytes32 splitHash = _hashSplit(\\n      accounts,\\n      percentAllocations,\\n      distributorFee\\n    );\\n    // store new hash in storage for future verification\\n    splits[split].hash = splitHash;\\n    emit UpdateSplit(split, accounts, percentAllocations, distributorFee);\\n  }\\n\\n  /** @notice Checks hash from `accounts`, `percentAllocations`, and `distributorFee` against the hash stored for `split`\\n   *  @param split Address of hash to check\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   */\\n  function _validSplitHash(\\n    address split,\\n    address[] memory accounts,\\n    uint32[] memory percentAllocations,\\n    uint32 distributorFee\\n  ) internal view {\\n    bytes32 hash = _hashSplit(accounts, percentAllocations, distributorFee);\\n    if (splits[split].hash != hash) revert InvalidSplit__InvalidHash(hash);\\n  }\\n\\n  /** @notice Distributes the ETH balance for split `split`\\n   *  @dev `accounts`, `percentAllocations`, and `distributorFee` must be verified before calling\\n   *  @param split Address of split to distribute balance for\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @param distributorAddress Address to pay `distributorFee` to\\n   */\\n  function _distributeETH(\\n    address split,\\n    address[] memory accounts,\\n    uint32[] memory percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) internal {\\n    uint256 mainBalance = ethBalances[split];\\n    uint256 proxyBalance = split.balance;\\n    // if mainBalance is positive, leave 1 in SplitMain for gas efficiency\\n    uint256 amountToSplit;\\n    unchecked {\\n      // underflow should be impossible\\n      if (mainBalance > 0) mainBalance -= 1;\\n      // overflow should be impossible\\n      amountToSplit = mainBalance + proxyBalance;\\n    }\\n    if (mainBalance > 0) ethBalances[split] = 1;\\n    // use msg.sender if distributorAddress == address(0)\\n    distributorAddress = distributorAddress != address(0)\\n      ? distributorAddress\\n      : msg.sender;\\n    // emit event with gross amountToSplit (before deducting distributorFee)\\n    emit DistributeETH(split, amountToSplit, distributorAddress);\\n    if (distributorFee != 0) {\\n      // given `amountToSplit`, calculate keeper fee\\n      uint256 distributorFeeAmount = _scaleAmountByPercentage(\\n        amountToSplit,\\n        distributorFee\\n      );\\n      unchecked {\\n        // credit keeper with fee\\n        // overflow should be impossible with validated distributorFee\\n        ethBalances[distributorAddress] += distributorFeeAmount;\\n        // given keeper fee, calculate how much to distribute to split recipients\\n        // underflow should be impossible with validated distributorFee\\n        amountToSplit -= distributorFeeAmount;\\n      }\\n    }\\n    unchecked {\\n      // distribute remaining balance\\n      // overflow should be impossible in for-loop index\\n      // cache accounts length to save gas\\n      uint256 accountsLength = accounts.length;\\n      for (uint256 i = 0; i < accountsLength; ++i) {\\n        // overflow should be impossible with validated allocations\\n        ethBalances[accounts[i]] += _scaleAmountByPercentage(\\n          amountToSplit,\\n          percentAllocations[i]\\n        );\\n      }\\n    }\\n    // flush proxy ETH balance to SplitMain\\n    // split proxy should be guaranteed to exist at this address after validating splitHash\\n    // (attacker can't deploy own contract to address with high balance & empty sendETHToMain\\n    // to drain ETH from SplitMain)\\n    // could technically check if (change in proxy balance == change in SplitMain balance)\\n    // before/after external call, but seems like extra gas for no practical benefit\\n    if (proxyBalance > 0) SplitWallet(split).sendETHToMain(proxyBalance);\\n  }\\n\\n  /** @notice Distributes the ERC20 `token` balance for split `split`\\n   *  @dev `accounts`, `percentAllocations`, and `distributorFee` must be verified before calling\\n   *  @dev pernicious ERC20s may cause overflow in this function inside\\n   *  _scaleAmountByPercentage, but results do not affect ETH & other ERC20 balances\\n   *  @param split Address of split to distribute balance for\\n   *  @param token Address of ERC20 to distribute balance for\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @param distributorAddress Address to pay `distributorFee` to\\n   */\\n  function _distributeERC20(\\n    address split,\\n    ERC20 token,\\n    address[] memory accounts,\\n    uint32[] memory percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) internal {\\n    uint256 amountToSplit;\\n    uint256 mainBalance = erc20Balances[token][split];\\n    uint256 proxyBalance = token.balanceOf(split);\\n    unchecked {\\n      // if mainBalance &/ proxyBalance are positive, leave 1 for gas efficiency\\n      // underflow should be impossible\\n      if (proxyBalance > 0) proxyBalance -= 1;\\n      // underflow should be impossible\\n      if (mainBalance > 0) {\\n        mainBalance -= 1;\\n      }\\n      // overflow should be impossible\\n      amountToSplit = mainBalance + proxyBalance;\\n    }\\n    if (mainBalance > 0) erc20Balances[token][split] = 1;\\n    // use msg.sender if distributorAddress == address(0)\\n    distributorAddress = distributorAddress != address(0)\\n      ? distributorAddress\\n      : msg.sender;\\n    // emit event with gross amountToSplit (before deducting distributorFee)\\n    emit DistributeERC20(split, token, amountToSplit, distributorAddress);\\n    if (distributorFee != 0) {\\n      // given `amountToSplit`, calculate keeper fee\\n      uint256 distributorFeeAmount = _scaleAmountByPercentage(\\n        amountToSplit,\\n        distributorFee\\n      );\\n      // overflow should be impossible with validated distributorFee\\n      unchecked {\\n        // credit keeper with fee\\n        erc20Balances[token][distributorAddress] += distributorFeeAmount;\\n        // given keeper fee, calculate how much to distribute to split recipients\\n        amountToSplit -= distributorFeeAmount;\\n      }\\n    }\\n    // distribute remaining balance\\n    // overflows should be impossible in for-loop with validated allocations\\n    unchecked {\\n      // cache accounts length to save gas\\n      uint256 accountsLength = accounts.length;\\n      for (uint256 i = 0; i < accountsLength; ++i) {\\n        erc20Balances[token][accounts[i]] += _scaleAmountByPercentage(\\n          amountToSplit,\\n          percentAllocations[i]\\n        );\\n      }\\n    }\\n    // split proxy should be guaranteed to exist at this address after validating splitHash\\n    // (attacker can't deploy own contract to address with high ERC20 balance & empty\\n    // sendERC20ToMain to drain ERC20 from SplitMain)\\n    // doesn't support rebasing or fee-on-transfer tokens\\n    // flush extra proxy ERC20 balance to SplitMain\\n    if (proxyBalance > 0)\\n      SplitWallet(split).sendERC20ToMain(token, proxyBalance);\\n  }\\n\\n  /** @notice Multiplies an amount by a scaled percentage\\n   *  @param amount Amount to get `scaledPercentage` of\\n   *  @param scaledPercent Percent scaled by PERCENTAGE_SCALE\\n   *  @return scaledAmount Percent of `amount`.\\n   */\\n  function _scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\\n    internal\\n    pure\\n    returns (uint256 scaledAmount)\\n  {\\n    // use assembly to bypass checking for overflow & division by 0\\n    // scaledPercent has been validated to be < PERCENTAGE_SCALE)\\n    // & PERCENTAGE_SCALE will never be 0\\n    // pernicious ERC20s may cause overflow, but results do not affect ETH & other ERC20 balances\\n    assembly {\\n      /* eg (100 * 2*1e4) / (1e6) */\\n      scaledAmount := div(mul(amount, scaledPercent), PERCENTAGE_SCALE)\\n    }\\n  }\\n\\n  /** @notice Withdraw ETH for account `account`\\n   *  @param account Account to withdrawn ETH for\\n   *  @return withdrawn Amount of ETH withdrawn\\n   */\\n  function _withdraw(address account) internal returns (uint256 withdrawn) {\\n    // leave balance of 1 for gas efficiency\\n    // underflow if ethBalance is 0\\n    withdrawn = ethBalances[account] - 1;\\n    ethBalances[account] = 1;\\n    account.safeTransferETH(withdrawn);\\n  }\\n\\n  /** @notice Withdraw ERC20 `token` for account `account`\\n   *  @param account Account to withdrawn ERC20 `token` for\\n   *  @return withdrawn Amount of ERC20 `token` withdrawn\\n   */\\n  function _withdrawERC20(address account, ERC20 token)\\n    internal\\n    returns (uint256 withdrawn)\\n  {\\n    // leave balance of 1 for gas efficiency\\n    // underflow if erc20Balance is 0\\n    withdrawn = erc20Balances[token][account] - 1;\\n    erc20Balances[token][account] = 1;\\n    token.safeTransfer(account, withdrawn);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/SplitWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\nimport {ISplitMain} from './interfaces/ISplitMain.sol';\\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\\nimport {SafeTransferLib} from '@rari-capital/solmate/src/utils/SafeTransferLib.sol';\\n\\n/**\\n * ERRORS\\n */\\n\\n/// @notice Unauthorized sender\\nerror Unauthorized();\\n\\n/**\\n * @title SplitWallet\\n * @author 0xSplits <will@0xSplits.xyz>\\n * @notice The implementation logic for `SplitProxy`.\\n * @dev `SplitProxy` handles `receive()` itself to avoid the gas cost with `DELEGATECALL`.\\n */\\ncontract SplitWallet {\\n  using SafeTransferLib for address;\\n  using SafeTransferLib for ERC20;\\n\\n  /**\\n   * EVENTS\\n   */\\n\\n  /** @notice emitted after each successful ETH transfer to proxy\\n   *  @param split Address of the split that received ETH\\n   *  @param amount Amount of ETH received\\n   */\\n  event ReceiveETH(address indexed split, uint256 amount);\\n\\n  /**\\n   * STORAGE\\n   */\\n\\n  /**\\n   * STORAGE - CONSTANTS & IMMUTABLES\\n   */\\n\\n  /// @notice address of SplitMain for split distributions & EOA/SC withdrawals\\n  ISplitMain public immutable splitMain;\\n\\n  /**\\n   * MODIFIERS\\n   */\\n\\n  /// @notice Reverts if the sender isn't SplitMain\\n  modifier onlySplitMain() {\\n    if (msg.sender != address(splitMain)) revert Unauthorized();\\n    _;\\n  }\\n\\n  /**\\n   * CONSTRUCTOR\\n   */\\n\\n  constructor() {\\n    splitMain = ISplitMain(msg.sender);\\n  }\\n\\n  /**\\n   * FUNCTIONS - PUBLIC & EXTERNAL\\n   */\\n\\n  /** @notice Sends amount `amount` of ETH in proxy to SplitMain\\n   *  @dev payable reduces gas cost; no vulnerability to accidentally lock\\n   *  ETH introduced since fn call is restricted to SplitMain\\n   *  @param amount Amount to send\\n   */\\n  function sendETHToMain(uint256 amount) external payable onlySplitMain {\\n    address(splitMain).safeTransferETH(amount);\\n  }\\n\\n  /** @notice Sends amount `amount` of ERC20 `token` in proxy to SplitMain\\n   *  @dev payable reduces gas cost; no vulnerability to accidentally lock\\n   *  ETH introduced since fn call is restricted to SplitMain\\n   *  @param token Token to send\\n   *  @param amount Amount to send\\n   */\\n  function sendERC20ToMain(ERC20 token, uint256 amount)\\n    external\\n    payable\\n    onlySplitMain\\n  {\\n    token.safeTransfer(address(splitMain), amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISplitMain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\\n\\n/**\\n * @title ISplitMain\\n * @author 0xSplits <will@0xSplits.xyz>\\n */\\ninterface ISplitMain {\\n  /**\\n   * FUNCTIONS\\n   */\\n\\n  function walletImplementation() external returns (address);\\n\\n  function createSplit(\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address controller\\n  ) external returns (address);\\n\\n  function predictImmutableSplitAddress(\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee\\n  ) external view returns (address);\\n\\n  function updateSplit(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee\\n  ) external;\\n\\n  function transferControl(address split, address newController) external;\\n\\n  function cancelControlTransfer(address split) external;\\n\\n  function acceptControl(address split) external;\\n\\n  function makeSplitImmutable(address split) external;\\n\\n  function distributeETH(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external;\\n\\n  function updateAndDistributeETH(\\n    address split,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external;\\n\\n  function distributeERC20(\\n    address split,\\n    ERC20 token,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external;\\n\\n  function updateAndDistributeERC20(\\n    address split,\\n    ERC20 token,\\n    address[] calldata accounts,\\n    uint32[] calldata percentAllocations,\\n    uint32 distributorFee,\\n    address distributorAddress\\n  ) external;\\n\\n  function withdraw(\\n    address account,\\n    uint256 withdrawETH,\\n    ERC20[] calldata tokens\\n  ) external;\\n\\n  /**\\n   * EVENTS\\n   */\\n\\n  /** @notice emitted after each successful split creation\\n   *  @param split Address of the created split\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   *  @param controller Controlling address (0x0 if immutable)\\n   */\\n  event CreateSplit(\\n    address indexed split,\\n    address[] accounts,\\n    uint32[] percentAllocations,\\n    uint32 distributorFee,\\n    address controller\\n  );\\n\\n  /** @notice emitted after each successful split update\\n   *  @param split Address of the updated split\\n   *  @param accounts Ordered, unique list of addresses with ownership in the split\\n   *  @param percentAllocations Percent allocations associated with each address\\n   *  @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n   */\\n  event UpdateSplit(\\n    address indexed split,\\n    address[] accounts,\\n    uint32[] percentAllocations,\\n    uint32 distributorFee\\n  );\\n\\n  /** @notice emitted after each initiated split control transfer\\n   *  @param split Address of the split control transfer was initiated for\\n   *  @param newPotentialController Address of the split's new potential controller\\n   */\\n  event InitiateControlTransfer(\\n    address indexed split,\\n    address indexed newPotentialController\\n  );\\n\\n  /** @notice emitted after each canceled split control transfer\\n   *  @param split Address of the split control transfer was canceled for\\n   */\\n  event CancelControlTransfer(address indexed split);\\n\\n  /** @notice emitted after each successful split control transfer\\n   *  @param split Address of the split control was transferred for\\n   *  @param previousController Address of the split's previous controller\\n   *  @param newController Address of the split's new controller\\n   */\\n  event ControlTransfer(\\n    address indexed split,\\n    address indexed previousController,\\n    address indexed newController\\n  );\\n\\n  /** @notice emitted after each successful ETH balance split\\n   *  @param split Address of the split that distributed its balance\\n   *  @param amount Amount of ETH distributed\\n   *  @param distributorAddress Address to credit distributor fee to\\n   */\\n  event DistributeETH(\\n    address indexed split,\\n    uint256 amount,\\n    address indexed distributorAddress\\n  );\\n\\n  /** @notice emitted after each successful ERC20 balance split\\n   *  @param split Address of the split that distributed its balance\\n   *  @param token Address of ERC20 distributed\\n   *  @param amount Amount of ERC20 distributed\\n   *  @param distributorAddress Address to credit distributor fee to\\n   */\\n  event DistributeERC20(\\n    address indexed split,\\n    ERC20 indexed token,\\n    uint256 amount,\\n    address indexed distributorAddress\\n  );\\n\\n  /** @notice emitted after each successful withdrawal\\n   *  @param account Address that funds were withdrawn to\\n   *  @param ethAmount Amount of ETH withdrawn\\n   *  @param tokens Addresses of ERC20s withdrawn\\n   *  @param tokenAmounts Amounts of corresponding ERC20s withdrawn\\n   */\\n  event Withdrawal(\\n    address indexed account,\\n    uint256 ethAmount,\\n    ERC20[] tokens,\\n    uint256[] tokenAmounts\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\n/// @notice create opcode failed\\nerror CreateError();\\n/// @notice create2 opcode failed\\nerror Create2Error();\\n\\nlibrary Clones {\\n  /**\\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`\\n   * except when someone calls `receive()` and then it emits an event matching\\n   * `SplitWallet.ReceiveETH(indexed address, amount)`\\n   * Inspired by OZ & 0age's minimal clone implementations based on eip 1167 found at\\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.0/contracts/proxy/Clones.sol\\n   * and https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\\n   *\\n   * This function uses the create2 opcode and a `salt` to deterministically deploy\\n   * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n   * the clones cannot be deployed twice at the same address.\\n   *\\n   * init: 0x3d605d80600a3d3981f3\\n   * 3d   returndatasize  0\\n   * 605d push1 0x5d      0x5d 0\\n   * 80   dup1            0x5d 0x5d 0\\n   * 600a push1 0x0a      0x0a 0x5d 0x5d 0\\n   * 3d   returndatasize  0 0x0a 0x5d 0x5d 0\\n   * 39   codecopy        0x5d 0                      destOffset offset length     memory[destOffset:destOffset+length] = address(this).code[offset:offset+length]       copy executing contracts bytecode\\n   * 81   dup2            0 0x5d 0\\n   * f3   return          0                           offset length                return memory[offset:offset+length]                                                   returns from this contract call\\n   *\\n   * contract: 0x36603057343d52307f830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b160203da23d3df35b3d3d3d3d363d3d37363d73bebebebebebebebebebebebebebebebebebebebe5af43d3d93803e605b57fd5bf3\\n   *     0x000     36       calldatasize      cds\\n   *     0x001     6030     push1 0x30        0x30 cds\\n   * ,=< 0x003     57       jumpi\\n   * |   0x004     34       callvalue         cv\\n   * |   0x005     3d       returndatasize    0 cv\\n   * |   0x006     52       mstore\\n   * |   0x007     30       address           addr\\n   * |   0x008     7f830d.. push32 0x830d..   id addr\\n   * |   0x029     6020     push1 0x20        0x20 id addr\\n   * |   0x02b     3d       returndatasize    0 0x20 id addr\\n   * |   0x02c     a2       log2\\n   * |   0x02d     3d       returndatasize    0\\n   * |   0x02e     3d       returndatasize    0 0\\n   * |   0x02f     f3       return\\n   * `-> 0x030     5b       jumpdest\\n   *     0x031     3d       returndatasize    0\\n   *     0x032     3d       returndatasize    0 0\\n   *     0x033     3d       returndatasize    0 0 0\\n   *     0x034     3d       returndatasize    0 0 0 0\\n   *     0x035     36       calldatasize      cds 0 0 0 0\\n   *     0x036     3d       returndatasize    0 cds 0 0 0 0\\n   *     0x037     3d       returndatasize    0 0 cds 0 0 0 0\\n   *     0x038     37       calldatacopy      0 0 0 0\\n   *     0x039     36       calldatasize      cds 0 0 0 0\\n   *     0x03a     3d       returndatasize    0 cds 0 0 0 0\\n   *     0x03b     73bebe.. push20 0xbebe..   0xbebe 0 cds 0 0 0 0\\n   *     0x050     5a       gas               gas 0xbebe 0 cds 0 0 0 0\\n   *     0x051     f4       delegatecall      suc 0 0\\n   *     0x052     3d       returndatasize    rds suc 0 0\\n   *     0x053     3d       returndatasize    rds rds suc 0 0\\n   *     0x054     93       swap4             0 rds suc 0 rds\\n   *     0x055     80       dup1              0 0 rds suc 0 rds\\n   *     0x056     3e       returndatacopy    suc 0 rds\\n   *     0x057     605b     push1 0x5b        0x5b suc 0 rds\\n   * ,=< 0x059     57       jumpi             0 rds\\n   * |   0x05a     fd       revert\\n   * `-> 0x05b     5b       jumpdest          0 rds\\n   *     0x05c     f3       return\\n   *\\n   */\\n  function clone(address implementation) internal returns (address instance) {\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(\\n        ptr,\\n        0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\\n      )\\n      mstore(\\n        add(ptr, 0x13),\\n        0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\\n      )\\n      mstore(\\n        add(ptr, 0x33),\\n        0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\\n      )\\n      mstore(add(ptr, 0x46), shl(0x60, implementation))\\n      mstore(\\n        add(ptr, 0x5a),\\n        0x5af43d3d93803e605b57fd5bf300000000000000000000000000000000000000\\n      )\\n      instance := create(0, ptr, 0x67)\\n    }\\n    if (instance == address(0)) revert CreateError();\\n  }\\n\\n  function cloneDeterministic(address implementation, bytes32 salt)\\n    internal\\n    returns (address instance)\\n  {\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(\\n        ptr,\\n        0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\\n      )\\n      mstore(\\n        add(ptr, 0x13),\\n        0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\\n      )\\n      mstore(\\n        add(ptr, 0x33),\\n        0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\\n      )\\n      mstore(add(ptr, 0x46), shl(0x60, implementation))\\n      mstore(\\n        add(ptr, 0x5a),\\n        0x5af43d3d93803e605b57fd5bf300000000000000000000000000000000000000\\n      )\\n      instance := create2(0, ptr, 0x67, salt)\\n    }\\n    if (instance == address(0)) revert Create2Error();\\n  }\\n\\n  /**\\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n   */\\n  function predictDeterministicAddress(\\n    address implementation,\\n    bytes32 salt,\\n    address deployer\\n  ) internal pure returns (address predicted) {\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(\\n        ptr,\\n        0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\\n      )\\n      mstore(\\n        add(ptr, 0x13),\\n        0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\\n      )\\n      mstore(\\n        add(ptr, 0x33),\\n        0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\\n      )\\n      mstore(add(ptr, 0x46), shl(0x60, implementation))\\n      mstore(\\n        add(ptr, 0x5a),\\n        0x5af43d3d93803e605b57fd5bf3ff000000000000000000000000000000000000\\n      )\\n      mstore(add(ptr, 0x68), shl(0x60, deployer))\\n      mstore(add(ptr, 0x7c), salt)\\n      mstore(add(ptr, 0x9c), keccak256(ptr, 0x67))\\n      predicted := keccak256(add(ptr, 0x67), 0x55)\\n    }\\n  }\\n\\n  /**\\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n   */\\n  function predictDeterministicAddress(address implementation, bytes32 salt)\\n    internal\\n    view\\n    returns (address predicted)\\n  {\\n    return predictDeterministicAddress(implementation, salt, address(this));\\n  }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Create2Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CreateError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"InvalidNewController\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocationsLength\",\"type\":\"uint256\"}],\"name\":\"InvalidSplit__AccountsAndAllocationsMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"InvalidSplit__AccountsOutOfOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"InvalidSplit__AllocationMustBePositive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"allocationsSum\",\"type\":\"uint32\"}],\"name\":\"InvalidSplit__InvalidAllocationsSum\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"}],\"name\":\"InvalidSplit__InvalidDistributorFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"InvalidSplit__InvalidHash\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountsLength\",\"type\":\"uint256\"}],\"name\":\"InvalidSplit__TooFewAccounts\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"name\":\"CancelControlTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousController\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"ControlTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"CreateSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"}],\"name\":\"DistributeERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"}],\"name\":\"DistributeETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPotentialController\",\"type\":\"address\"}],\"name\":\"InitiateControlTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"}],\"name\":\"UpdateSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract ERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PERCENTAGE_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"name\":\"acceptControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"name\":\"cancelControlTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"createSplit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"}],\"name\":\"distributeERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"}],\"name\":\"distributeETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getERC20Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getETHBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"name\":\"getNewPotentialController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"name\":\"makeSplitImmutable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"}],\"name\":\"predictImmutableSplitAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"transferControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"}],\"name\":\"updateAndDistributeERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"}],\"name\":\"updateAndDistributeETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"}],\"name\":\"updateSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawETH\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SplitMain", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}