{"SourceCode": "{\"AppealStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\nimport \\\"./RecordInterface.sol\\\";\\nimport \\\"./UserStorage.sol\\\";\\ncontract AppealStorage {\\n    OrderInterface private _oSt;\\n    RecordInterface private _rSt;\\n    UserInterface private _uSt;\\n    address recAddr;\\n    struct Appeal {\\n        address user;\\n        uint256 appealNo;\\n        uint256 orderNo;\\n        address witness;\\n        address buyer;\\n        address seller;\\n        uint256 mortgage;\\n        uint256 status;\\n        uint256 appealTime;\\n        uint256 witTakeTime;\\n        uint256 obTakeTime;\\n        AppealDetail detail;\\n    }\\n    struct AppealDetail {\\n        address finalAppealAddr;\\n        uint256 updateTime;\\n        string witnessReason;\\n        uint256 witnessAppealStatus;\\n        string observerReason;\\n        uint256 witnessHandleTime;\\n        uint256 observerHandleTime;\\n        address observerAddr;\\n        uint256 witnessHandleReward;\\n        uint256 observerHandleReward;\\n        uint256 witnessHandleCredit;\\n        uint256 observerHandleCredit;\\n        uint256 witReward;\\n        uint256 witSub;\\n        uint256 witCreditR;\\n        uint256 witCreditS;\\n    }\\n    mapping(uint256 =\\u003e Appeal) public appeals;\\n    mapping(uint256 =\\u003e uint256) public appealIndex;\\n    Appeal[] public appealList;\\n    event addAppeal(uint256 _appealNo, uint256 _orderNo);\\n    constructor(\\n        address _r,\\n        address _o,\\n        address _u\\n    ) {\\n        _rSt = RecordInterface(_r);\\n        _oSt = OrderInterface(_o);\\n        _uSt = UserInterface(_u);\\n        recAddr = _r;\\n    }\\n    modifier onlyWit(uint256 _o) {\\n        Appeal memory _al = appeals[_o];\\n        require(_al.witness == msg.sender);\\n        require(_al.buyer != msg.sender \\u0026\\u0026 _al.seller != msg.sender);\\n        _;\\n    }\\n    modifier onlyOb(uint256 _o) {\\n        Appeal memory _al = appeals[_o];\\n        require(_al.detail.observerAddr == msg.sender);\\n        require(_al.buyer != msg.sender \\u0026\\u0026 _al.seller != msg.sender);\\n        _;\\n    }\\n    modifier onlyBOS(uint256 _o) {\\n        OrderStorage.Order memory _r = _oSt.searchOrder(_o);\\n        require(\\n            _r.orderDetail.sellerAddr == msg.sender ||\\n                _r.orderDetail.buyerAddr == msg.sender\\n        );\\n        _;\\n    }\\n    function _insert(uint256 _o, uint256 _count) internal {\\n        OrderStorage.Order memory _or = _oSt.searchOrder(_o);\\n        require(appeals[_o].appealNo == uint256(0));\\n        AppealDetail memory _detail = AppealDetail({\\n            finalAppealAddr: address(0),\\n            updateTime: uint256(0),\\n            witnessReason: \\\"\\\",\\n            observerReason: \\\"\\\",\\n            witnessAppealStatus: 0,\\n            witnessHandleTime: uint256(0),\\n            observerHandleTime: uint256(0),\\n            observerAddr: address(0),\\n            witnessHandleReward: 0,\\n            observerHandleReward: 0,\\n            witnessHandleCredit: 0,\\n            observerHandleCredit: 0,\\n            witReward: 0,\\n            witSub: 0,\\n            witCreditR: 0,\\n            witCreditS: 0\\n        });\\n        uint256 _appealNo = block.timestamp;\\n        Appeal memory _appeal = Appeal({\\n            user: msg.sender,\\n            appealNo: _appealNo,\\n            orderNo: _o,\\n            witness: address(0),\\n            buyer: _or.orderDetail.buyerAddr,\\n            seller: _or.orderDetail.sellerAddr,\\n            mortgage: _count,\\n            status: 1,\\n            appealTime: block.timestamp,\\n            witTakeTime: 0,\\n            obTakeTime: 0,\\n            detail: _detail\\n        });\\n        appeals[_o] = _appeal;\\n        appealList.push(_appeal);\\n        appealIndex[_o] = appealList.length - 1;\\n        chanT(_or.orderDetail.sellerAddr, _or.orderDetail.buyerAddr, 1, 0);\\n        emit addAppeal(_appealNo, _o);\\n    }\\n    function chanT(\\n        address _seller,\\n        address _buyer,\\n        uint256 _t,\\n        uint256 _r\\n    ) internal {\\n        uint256 _tc = _rSt.getTradeCredit();\\n        uint256 _rs = _rSt.getSubTCredit();\\n        UserStorage.User memory _user = _uSt.searchUser(_seller);\\n        UserStorage.TradeStats memory _tr = _user.tradeStats;\\n        UserStorage.User memory _user2 = _uSt.searchUser(_buyer);\\n        UserStorage.TradeStats memory _tr2 = _user2.tradeStats;\\n        uint256 _c2 = _user2.credit;\\n        uint256 _c = _user.credit;\\n        if (_t == 1) {\\n            _tr.tradeTotal = _tr.tradeTotal \\u003e 0 ? (_tr.tradeTotal - 1) : 0;\\n            _tr2.tradeTotal = _tr2.tradeTotal \\u003e 0 ? (_tr2.tradeTotal - 1) : 0;\\n            _c = (_c \\u003e= _tc) ? (_c - _tc) : 0;\\n            _c2 = (_c2 \\u003e= _tc) ? (_c2 - _tc) : 0;\\n        } else if (_t == 2) {\\n            _tr.tradeTotal += 1;\\n            _tr2.tradeTotal += 1;\\n            if (_r == 1) {\\n                _c += _tc;\\n                _c2 = (_c2 \\u003e= _rs) ? (_c2 - _rs) : 0;\\n            } else if (_r == 2) {\\n                _c2 += _tc;\\n                _c = (_c \\u003e= _rs) ? (_c - _rs) : 0;\\n            }\\n        }\\n        _uSt.updateTradeStats(_seller, _tr, _c);\\n        _uSt.updateTradeStats(_buyer, _tr2, _c2);\\n    }\\n    function applyAppeal(uint256 _o) external onlyBOS(_o) {\\n        uint256 _fee = _rSt.getAppealFee();\\n        _insert(_o, _fee);\\n        TokenTransfer _tokenTransfer = _rSt.getERC20Address(\\\"AIR\\\");\\n        _tokenTransfer.transferFrom(msg.sender, recAddr, _fee);\\n    }\\n    function takeWit(uint256 _o) external {\\n        Appeal memory _al = appeals[_o];\\n        require(_al.buyer != msg.sender \\u0026\\u0026 _al.seller != msg.sender);\\n        require(_al.witness == address(0));\\n        require(_al.status == 1);\\n        bool _f = witOrOb(1);\\n        require(_f);\\n        _al.witness = msg.sender;\\n        _al.witTakeTime = block.timestamp;\\n        appeals[_o] = _al;\\n        appealList[appealIndex[_o]] = _al;\\n    }\\n    function takeOb(uint256 _o) external {\\n        Appeal memory _al = appeals[_o];\\n        require(_al.buyer != msg.sender \\u0026\\u0026 _al.seller != msg.sender);\\n        require(_al.status == 4 || _al.status == 5);\\n        require(_al.detail.observerAddr == address(0));\\n        bool _f = witOrOb(2);\\n        require(_f);\\n        _al.detail.observerAddr = msg.sender;\\n        _al.obTakeTime = block.timestamp;\\n        appeals[_o] = _al;\\n        appealList[appealIndex[_o]] = _al;\\n    }\\n    function changeHandler(uint256 _o, uint256 _type) external onlyBOS(_o) {\\n        Appeal memory _al = appeals[_o];\\n        if (_type == 1) {\\n            require(_al.status == 1);\\n            require(_al.witness != address(0));\\n            require(block.timestamp - _al.witTakeTime \\u003e 24 hours);\\n            _al.witness = address(0);\\n            _al.witTakeTime = 0;\\n        } else if (_type == 2) {\\n            require(_al.status == 4 || _al.status == 5);\\n            require(_al.detail.observerAddr != address(0));\\n            require(block.timestamp - _al.obTakeTime \\u003e 24 hours);\\n            _al.detail.observerAddr = address(0);\\n            _al.obTakeTime = 0;\\n        }\\n        appeals[_o] = _al;\\n        appealList[appealIndex[_o]] = _al;\\n    }\\n    function witOrOb(uint256 _f) internal view returns (bool) {\\n        UserStorage.User memory _u = _uSt.searchUser(msg.sender);\\n        if (_u.userFlag == _f) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    function applyFinal(uint256 _o) external onlyBOS(_o) {\\n        Appeal memory _al = appeals[_o];\\n        require(_al.status == 2 || _al.status == 3);\\n        require(block.timestamp - _al.detail.witnessHandleTime \\u003c= 24 hours);\\n        chanT(_al.seller, _al.buyer, 1, 0);\\n        uint256 _fee = _rSt.getAppealFeeFinal();\\n        TokenTransfer _tokenTransfer = _rSt.getERC20Address(\\\"AIR\\\");\\n        _tokenTransfer.transferFrom(msg.sender, recAddr, _fee);\\n        if (_al.status == 2) {\\n            _al.status = 4;\\n        } else if (_al.status == 3) {\\n            _al.status = 5;\\n        }\\n        _al.detail.finalAppealAddr = msg.sender;\\n        _al.detail.updateTime = block.timestamp;\\n        appeals[_o] = _al;\\n        appealList[appealIndex[_o]] = _al;\\n    }\\n    function witnessOpt(\\n        uint256 _o,\\n        string memory _r,\\n        uint256 _s\\n    ) external onlyWit(_o) {\\n        require(_s == 2 || _s == 3);\\n        Appeal memory _al = appeals[_o];\\n        require(_al.status == 1);\\n        uint256 _fee = _rSt.getAppealFee();\\n        uint256 _rcedit = _rSt.getWitnessHandleCredit();\\n        _al.status = _s;\\n        _al.detail.witnessAppealStatus = _s;\\n        _al.detail.witnessReason = _r;\\n        _al.detail.witnessHandleTime = block.timestamp;\\n        _al.detail.witnessHandleReward = _fee;\\n        _al.detail.witnessHandleCredit = _rcedit;\\n        _al.detail.witReward = _fee;\\n        _al.detail.witCreditR = _rcedit;\\n        _al.detail.updateTime = block.timestamp;\\n        appeals[_o] = _al;\\n        appealList[appealIndex[_o]] = _al;\\n        if (_s == 2) {\\n            if (_al.user == _al.buyer) {\\n                _rSt.subAvaAppeal(_al.seller, _al.buyer, _al, _fee, 1, 0);\\n                chanT(_al.seller, _al.buyer, 2, 2);\\n            } else if (_al.user == _al.seller) {\\n                _rSt.subAvaAppeal(_al.buyer, _al.seller, _al, _fee, 1, 0);\\n                chanT(_al.seller, _al.buyer, 2, 1);\\n            }\\n        }\\n        if (_s == 3) {\\n            if (_al.user == _al.buyer) {\\n                _rSt.subAvaAppeal(_al.buyer, _al.seller, _al, _fee, 1, 1);\\n                chanT(_al.seller, _al.buyer, 2, 1);\\n            } else if (_al.user == _al.seller) {\\n                _rSt.subAvaAppeal(_al.seller, _al.buyer, _al, _fee, 1, 1);\\n                chanT(_al.seller, _al.buyer, 2, 2);\\n            }\\n        }\\n    }\\n    function observerOpt(\\n        uint256 _o,\\n        string memory _r,\\n        uint256 _s\\n    ) external onlyOb(_o) {\\n        require(_s == 6 || _s == 7);\\n        Appeal memory _appeal = appeals[_o];\\n        require(_appeal.status == 4 || _appeal.status == 5);\\n        uint256 _fee = _rSt.getAppealFeeFinal();\\n        uint256 _rcedit = _rSt.getObserverHandleCredit();\\n        _appeal.status = _s;\\n        _appeal.detail.observerReason = _r;\\n        _appeal.detail.observerHandleTime = block.timestamp;\\n        _appeal.detail.observerHandleReward = _fee;\\n        _appeal.detail.observerHandleCredit = _rcedit;\\n        uint256 _subWC = _rSt.getSubWitCredit();\\n        uint256 _subWF = _rSt.getSubWitFee();\\n        if (_s == 6) {\\n            if (_appeal.user == _appeal.buyer) {\\n                _rSt.subAvaAppeal(\\n                    _appeal.seller,\\n                    _appeal.buyer,\\n                    _appeal,\\n                    _fee,\\n                    2,\\n                    0\\n                );\\n                chanT(_appeal.seller, _appeal.buyer, 2, 2);\\n                _rSt.subFrozenTotal(_o, _appeal.buyer);\\n            } else if (_appeal.user == _appeal.seller) {\\n                _rSt.subAvaAppeal(\\n                    _appeal.buyer,\\n                    _appeal.seller,\\n                    _appeal,\\n                    _fee,\\n                    2,\\n                    0\\n                );\\n                chanT(_appeal.seller, _appeal.buyer, 2, 1);\\n                _rSt.subFrozenTotal(_o, _appeal.seller);\\n            }\\n            if (_appeal.detail.witnessAppealStatus == 3) {\\n                _appeal.detail.witSub = _subWF;\\n                _appeal.detail.witCreditS = _subWC;\\n                if (_appeal.detail.witnessHandleCredit \\u003e= _subWC) {\\n                    _appeal.detail.witnessHandleCredit = SafeMath.sub(\\n                        _appeal.detail.witnessHandleCredit,\\n                        _subWC\\n                    );\\n                } else {\\n                    _appeal.detail.witnessHandleCredit = 0;\\n                }\\n                _rSt.subWitnessAvailable(_appeal.witness);\\n            }\\n        }\\n        if (_s == 7) {\\n            if (_appeal.user == _appeal.buyer) {\\n                _rSt.subAvaAppeal(\\n                    _appeal.buyer,\\n                    _appeal.seller,\\n                    _appeal,\\n                    _fee,\\n                    2,\\n                    1\\n                );\\n                chanT(_appeal.seller, _appeal.buyer, 2, 1);\\n                _rSt.subFrozenTotal(_o, _appeal.seller);\\n            } else if (_appeal.user == _appeal.seller) {\\n                _rSt.subAvaAppeal(\\n                    _appeal.seller,\\n                    _appeal.buyer,\\n                    _appeal,\\n                    _fee,\\n                    2,\\n                    1\\n                );\\n                chanT(_appeal.seller, _appeal.buyer, 2, 2);\\n                _rSt.subFrozenTotal(_o, _appeal.buyer);\\n            }\\n            if (_appeal.detail.witnessAppealStatus == 2) {\\n                _appeal.detail.witSub = _subWF;\\n                _appeal.detail.witCreditS = _subWC;\\n                if (_appeal.detail.witnessHandleCredit \\u003e= _subWC) {\\n                    _appeal.detail.witnessHandleCredit = SafeMath.sub(\\n                        _appeal.detail.witnessHandleCredit,\\n                        _subWC\\n                    );\\n                } else {\\n                    _appeal.detail.witnessHandleCredit = 0;\\n                }\\n                _rSt.subWitnessAvailable(_appeal.witness);\\n            }\\n        }\\n        _appeal.detail.updateTime = block.timestamp;\\n        appeals[_o] = _appeal;\\n        appealList[appealIndex[_o]] = _appeal;\\n    }\\n    function searchAppeal(uint256 _o)\\n        external\\n        view\\n        returns (Appeal memory appeal)\\n    {\\n        return appeals[_o];\\n    }\\n    function searchAppealList() external view returns (Appeal[] memory) {\\n        return appealList;\\n    }\\n}\\n\"},\"OrderStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./RecordInterface.sol\\\";\\nimport \\\"./RestStorage.sol\\\";\\nimport \\\"./UserStorage.sol\\\";\\nimport \\\"./RecordStorage.sol\\\";\\nimport \\\"./AppealStorage.sol\\\";\\n\\nabstract contract ReentrancyGuardOrder {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\nlibrary CountersOrder {\\n    struct Counter {\\n        uint256 _value;\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        {\\n            if (counter._value == 0) {\\n                counter._value = 10000;\\n            }\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value \\u003e 0, \\\"Counter: decrement overflow\\\");\\n        {\\n            counter._value = value - 1;\\n        }\\n    }\\n}\\n\\ncontract OrderStorage is Ownable, ReentrancyGuardOrder {\\n    using CountersOrder for CountersOrder.Counter;\\n    RestStorage private _restStorage;\\n    RecordInterface private _recordStorage;\\n    UserInterface private _userStorage;\\n    AppealInterface private _appealS;\\n    address recordAddress;\\n\\n    struct Order {\\n        address userAddr;\\n        uint256 orderNo;\\n        uint256 restNo;\\n        uint256 coinCount;\\n        uint256 orderAmount;\\n        uint256 payType;\\n        string currencyType;\\n        uint256 orderType;\\n        uint256 orderStatus;\\n        OrderDetail orderDetail;\\n    }\\n    struct OrderDetail {\\n        address buyerAddr;\\n        address sellerAddr;\\n        string coinType;\\n        uint256 price;\\n        uint256 tradeTime;\\n        uint256 updateTime;\\n        string tradeHash;\\n        uint256 tradeFee;\\n    }\\n\\n    CountersOrder.Counter private _orderNoCounter;\\n    mapping(uint256 =\\u003e Order) private orders;\\n    mapping(uint256 =\\u003e uint256) private orderIndex;\\n\\n    Order[] private orderList;\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) orderFrozenTotal;\\n\\n    uint256 public cancelOrderTime = 30;\\n\\n    function setCancelOrderTime(uint256 _count) public onlyOwner {\\n        cancelOrderTime = _count;\\n    }\\n\\n    function getCancelOrderTime() public view returns (uint256) {\\n        return cancelOrderTime;\\n    }\\n\\n    uint256 public canWithdrawHours = 24;\\n\\n    function setCanWithdrawHours(uint256 _count) public onlyOwner {\\n        canWithdrawHours = _count;\\n    }\\n\\n    function getCanWithdrawHours() public view returns (uint256) {\\n        return canWithdrawHours;\\n    }\\n\\n    mapping(string =\\u003e address) public feeAddrSet;\\n    mapping(string =\\u003e uint256) public feeAmountSet;\\n\\n    function setFee(\\n        string calldata _method,\\n        address _addr,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        feeAddrSet[_method] = _addr;\\n        feeAmountSet[_method] = _amount;\\n    }\\n\\n    function _payFee(string memory _method) internal {\\n        uint256 _amt = feeAmountSet[_method];\\n        address _addr = feeAddrSet[_method];\\n\\n        if (_amt \\u003e 0) {\\n            require(_addr != address(0), \\\"recipient null is not allowed\\\");\\n            require(msg.value \\u003e= _amt, \\\"insufficient balance\\\");\\n            payable(_addr).transfer(_amt);\\n        }\\n    }\\n\\n    event OrderAdd(\\n        uint256 _orderNo,\\n        uint256 _restNo,\\n        uint256 _coinCount,\\n        uint256 _tradeFee,\\n        uint256 _orderAmount,\\n        uint256 _payType,\\n        uint256 _orderType,\\n        address _buyerAddr,\\n        address _sellerAddr\\n    );\\n\\n    event OrderPaidMoney(uint256 _orderNo);\\n    event OrderConfirmCollect(uint256 _orderNo);\\n    event OrderCancel(uint256 _orderNo);\\n    event OrderUpdateStatus(uint256 _orderNo, uint256 _orderStatus);\\n\\n    function authFromContract(\\n        address _recordAddr,\\n        address _restAddr,\\n        address _userAddr,\\n        address _appealAddr\\n    ) external onlyOwner {\\n        _recordStorage = RecordInterface(_recordAddr);\\n        _restStorage = RestStorage(_restAddr);\\n        _userStorage = UserInterface(_userAddr);\\n        recordAddress = _recordAddr;\\n        _appealS = AppealInterface(_appealAddr);\\n        _orderNoCounter.increment();\\n    }\\n\\n    modifier onlyBuyer(uint256 _orderNo) {\\n        require(_orderNo != uint256(0), \\\"orderNo null\\\");\\n        require(\\n            orders[_orderNo].orderDetail.buyerAddr == msg.sender,\\n            \\\"only buyer\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlySeller(uint256 _orderNo) {\\n        require(_orderNo != uint256(0), \\\"orderNo null\\\");\\n        require(\\n            orders[_orderNo].orderDetail.sellerAddr == msg.sender,\\n            \\\"only seller\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyBuyerOrSeller(uint256 _orderNo) {\\n        require(_orderNo != uint256(0), \\\"orderNo null\\\");\\n        require(\\n            orders[_orderNo].orderDetail.sellerAddr == msg.sender ||\\n                orders[_orderNo].orderDetail.buyerAddr == msg.sender,\\n            \\\"Only buyer or seller\\\"\\n        );\\n        _;\\n    }\\n\\n    function _checkParam(\\n        uint256 _restNo,\\n        uint256 _coinCount,\\n        uint256 _orderAmount,\\n        uint256 _payType\\n    ) internal pure {\\n        require(_restNo != uint256(0), \\\"restNo null\\\");\\n        require(_coinCount \\u003e 0, \\\"coinCount null\\\");\\n        require(_orderAmount \\u003e 0, \\\"orderAmount null\\\");\\n        require(_payType != uint256(0), \\\"payType null\\\");\\n    }\\n\\n    function _insert(\\n        uint256 _restNo,\\n        uint256 _coinCount,\\n        uint256 _tradeFee,\\n        uint256 _orderAmount,\\n        uint256 _payType,\\n        uint256 _orderType,\\n        address _buyerAddr,\\n        address _sellerAddr\\n    ) internal nonReentrant returns (uint256 restNo) {\\n        _checkParam(_restNo, _coinCount, _orderAmount, _payType);\\n\\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\\n        require(_rest.userAddr != address(0), \\\"rest not exist\\\");\\n        OrderDetail memory _orderDetail = OrderDetail({\\n            buyerAddr: _buyerAddr,\\n            sellerAddr: _sellerAddr,\\n            coinType: _rest.coinType,\\n            price: _rest.price,\\n            tradeTime: block.timestamp,\\n            updateTime: 0,\\n            tradeHash: \\\"\\\",\\n            tradeFee: _tradeFee\\n        });\\n\\n        uint256 _orderNo = _orderNoCounter.current();\\n        require(orders[_orderNo].orderNo == uint256(0), \\\"order exist\\\");\\n        Order memory order = Order({\\n            userAddr: msg.sender,\\n            orderNo: _orderNo,\\n            restNo: _restNo,\\n            coinCount: _coinCount,\\n            orderAmount: _orderAmount,\\n            payType: _payType,\\n            currencyType: _rest.currencyType,\\n            orderType: _orderType,\\n            orderStatus: 1,\\n            orderDetail: _orderDetail\\n        });\\n\\n        orders[_orderNo] = order;\\n\\n        orderList.push(order);\\n        orderIndex[_orderNo] = orderList.length - 1;\\n\\n        if (_orderType == 2) {\\n            orderFrozenTotal[msg.sender][_orderNo] = _coinCount;\\n        } else if (_orderType == 1) {\\n            orderFrozenTotal[_rest.userAddr][_orderNo] = _coinCount;\\n        }\\n        _orderNoCounter.increment();\\n        emit OrderAdd(\\n            _orderNo,\\n            _restNo,\\n            _coinCount,\\n            _tradeFee,\\n            _orderAmount,\\n            _payType,\\n            _orderType,\\n            _buyerAddr,\\n            _sellerAddr\\n        );\\n\\n        return _orderNo;\\n    }\\n\\n    function addBuyOrder(\\n        uint256 _restNo,\\n        uint256 _coinCount,\\n        uint256 _orderAmount,\\n        uint256 _payType\\n    ) external payable {\\n        _payFee(\\\"addBuyOrder\\\");\\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\\n        require(_rest.userAddr != msg.sender, \\\"rest not exist\\\");\\n        require(_rest.restType == 2, \\\"sell rest not exist\\\");\\n        require(_coinCount \\u003e 0 \\u0026\\u0026 _orderAmount \\u003e 0, \\\"coin count error\\\");\\n        require(_rest.restStatus == 1, \\\"rest status error\\\");\\n        UserStorage.User memory _currentUser = _userStorage.searchUser(\\n            msg.sender\\n        );\\n\\n        require(\\n            _currentUser.userFlag != 1 \\u0026\\u0026 _currentUser.userFlag != 2,\\n            \\\"invalid user\\\"\\n        );\\n\\n        uint256 _restFrozen = _restStorage.getRestFrozenTotal(\\n            _rest.userAddr,\\n            _restNo\\n        );\\n        require(_restFrozen \\u003e= _coinCount, \\\"coin not enough\\\");\\n\\n        uint256 _amo = SafeMath.mul(_rest.price, _coinCount);\\n        require(\\n            _amo \\u003e= _rest.restDetail.limitAmountFrom \\u0026\\u0026\\n                _amo \\u003c= _rest.restDetail.limitAmountTo,\\n            \\\"amount error\\\"\\n        );\\n        require(\\n            _currentUser.credit \\u003e= _rest.restDetail.limitMinCredit,\\n            \\\"credit error\\\"\\n        );\\n        require(\\n            _currentUser.morgageStats.mortgage \\u003e=\\n                _rest.restDetail.limitMinMortgage,\\n            \\\"mortgage error\\\"\\n        );\\n\\n        _restStorage.updateRestFinishCount(_restNo, _coinCount);\\n        _insert(\\n            _restNo,\\n            _coinCount,\\n            0,\\n            _orderAmount,\\n            _payType,\\n            1,\\n            msg.sender,\\n            _rest.userAddr\\n        );\\n    }\\n\\n    function addSellOrder(\\n        uint256 _restNo,\\n        uint256 _coinCount,\\n        uint256 _tradeFee,\\n        uint256 _orderAmount,\\n        uint256 _payType\\n    ) external payable {\\n        _payFee(\\\"addSellOrder\\\");\\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\\n        require(_rest.userAddr != msg.sender, \\\"rest not exist\\\");\\n        require(_rest.restType == 1, \\\"buy rest not exist\\\");\\n        require(_coinCount \\u003e 0, \\\"coin count error\\\");\\n        require(_orderAmount \\u003e 0, \\\"orderAmount error\\\");\\n        require(_rest.restStatus == 1, \\\"rest status error\\\");\\n\\n        uint256 _amo = SafeMath.mul(_rest.price, _coinCount);\\n        require(\\n            _amo \\u003e= _rest.restDetail.limitAmountFrom \\u0026\\u0026\\n                _amo \\u003c= _rest.restDetail.limitAmountTo,\\n            \\\"amount error\\\"\\n        );\\n\\n        UserStorage.User memory _currentUser = _userStorage.searchUser(\\n            msg.sender\\n        );\\n\\n        require(\\n            _currentUser.userFlag != 1 \\u0026\\u0026 _currentUser.userFlag != 2,\\n            \\\"invalid user\\\"\\n        );\\n        require(\\n            _currentUser.credit \\u003e= _rest.restDetail.limitMinCredit,\\n            \\\"credit error\\\"\\n        );\\n        require(\\n            _currentUser.morgageStats.mortgage \\u003e=\\n                _rest.restDetail.limitMinMortgage,\\n            \\\"mortgage error\\\"\\n        );\\n\\n        uint256 _needSub = SafeMath.add(_coinCount, _tradeFee);\\n\\n        _restStorage.updateRestFinishCount(_restNo, _coinCount);\\n        _insert(\\n            _restNo,\\n            _coinCount,\\n            _tradeFee,\\n            _orderAmount,\\n            _payType,\\n            2,\\n            _rest.userAddr,\\n            msg.sender\\n        );\\n\\n        TokenTransfer _tokenTransfer = _recordStorage.getERC20Address(\\n            _rest.coinType\\n        );\\n        _tokenTransfer.transferFrom(msg.sender, recordAddress, _needSub);\\n        _recordStorage.addRecord(\\n            msg.sender,\\n            \\\"\\\",\\n            _rest.coinType,\\n            _coinCount,\\n            2,\\n            1,\\n            2\\n        );\\n    }\\n\\n    function setPaidMoney(uint256 _orderNo)\\n        external\\n        payable\\n        onlyBuyer(_orderNo)\\n        returns (bool)\\n    {\\n        _payFee(\\\"setPaidMoney\\\");\\n\\n        _updateOrderStatus(_orderNo, 2);\\n        emit OrderPaidMoney(_orderNo);\\n        return true;\\n    }\\n\\n    function confirmCollect(uint256 _orderNo)\\n        external\\n        payable\\n        onlySeller(_orderNo)\\n    {\\n        _payFee(\\\"confirmCollect\\\");\\n        require(_orderNo != uint256(0), \\\"orderNo null\\\");\\n        Order memory _order = orders[_orderNo];\\n        require(_order.orderStatus == 2, \\\"Invalid order status\\\");\\n        require(\\n            _order.orderDetail.buyerAddr != address(0),\\n            \\\"Invalid buyer address\\\"\\n        );\\n        require(\\n            orderFrozenTotal[msg.sender][_orderNo] \\u003e= _order.coinCount,\\n            \\\"coin not enough\\\"\\n        );\\n\\n        _updateOrderStatus(_orderNo, 3);\\n\\n        orderFrozenTotal[msg.sender][_orderNo] = 0;\\n\\n        uint256 _rc = _recordStorage.getTradeCredit();\\n        UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\\n        uint256 _credit = _user.credit + _rc;\\n        UserStorage.TradeStats memory _tradeStats = _user.tradeStats;\\n        _tradeStats.tradeTotal += 1;\\n        _userStorage.updateTradeStats(msg.sender, _tradeStats, _credit);\\n\\n        UserStorage.User memory _user2 = _userStorage.searchUser(\\n            _order.orderDetail.buyerAddr\\n        );\\n        uint256 _credit2 = _user2.credit + _rc;\\n        UserStorage.TradeStats memory _tradeStats2 = _user2.tradeStats;\\n        _tradeStats2.tradeTotal += 1;\\n        _userStorage.updateTradeStats(\\n            _order.orderDetail.buyerAddr,\\n            _tradeStats2,\\n            _credit2\\n        );\\n\\n        _recordStorage.subFrozenTotal(_orderNo, _order.orderDetail.buyerAddr);\\n\\n        emit OrderConfirmCollect(_orderNo);\\n    }\\n\\n    function cancelOrder(uint256 _orderNo)\\n        external\\n        payable\\n        onlyBuyerOrSeller(_orderNo)\\n        returns (bool)\\n    {\\n        _payFee(\\\"cancelOrder\\\");\\n        Order memory _order = orders[_orderNo];\\n        require(_order.orderNo != uint256(0), \\\"current Order not exist\\\");\\n\\n        require(_order.orderStatus == 1, \\\"Can\\u0027t cancel order\\\");\\n\\n        if (_order.orderDetail.sellerAddr == msg.sender) {\\n            require(\\n                _order.orderDetail.tradeTime + cancelOrderTime * 1 minutes \\u003c\\n                    block.timestamp,\\n                \\\"limit\\\"\\n            );\\n        }\\n\\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_order.restNo);\\n\\n        if (_rest.restStatus == 4 || _rest.restStatus == 5) {\\n            orderFrozenTotal[_order.orderDetail.sellerAddr][_orderNo] = 0;\\n\\n            _recordStorage.addAvailableTotal(\\n                _order.orderDetail.sellerAddr,\\n                _order.orderDetail.coinType,\\n                _order.coinCount\\n            );\\n        } else {\\n            if (_order.orderType == 2) {\\n                orderFrozenTotal[_order.orderDetail.sellerAddr][_orderNo] = 0;\\n\\n                _recordStorage.addAvailableTotal(\\n                    _order.orderDetail.sellerAddr,\\n                    _order.orderDetail.coinType,\\n                    _order.coinCount\\n                );\\n            }\\n\\n            _restStorage.addRestRemainCount(_order.restNo, _order.coinCount);\\n        }\\n        _updateOrderStatus(_orderNo, 4);\\n        emit OrderCancel(_orderNo);\\n        return true;\\n    }\\n\\n    function takeCoin(uint256 _o) external onlyBuyerOrSeller(_o) {\\n        AppealStorage.Appeal memory _appeal = _appealS.searchAppeal(_o);\\n        require(\\n            block.timestamp - _appeal.detail.witnessHandleTime \\u003e\\n                canWithdrawHours * 1 hours,\\n            \\\"time error\\\"\\n        );\\n\\n        address _win;\\n\\n        if (_appeal.user == _appeal.buyer) {\\n            if (_appeal.status == 2) {\\n                _win = _appeal.buyer;\\n            } else if (_appeal.status == 3) {\\n                _win = _appeal.seller;\\n            }\\n        } else {\\n            if (_appeal.status == 2) {\\n                _win = _appeal.seller;\\n            } else if (_appeal.status == 3) {\\n                _win = _appeal.buyer;\\n            }\\n        }\\n        require(_win == msg.sender, \\\"opt error\\\");\\n\\n        _updateOrderStatus(_o, 5);\\n        orderFrozenTotal[_appeal.seller][_o] = 0;\\n        _recordStorage.subFrozenTotal(_o, msg.sender);\\n    }\\n\\n    function _updateOrderStatus(uint256 _orderNo, uint256 _orderStatus)\\n        internal\\n        onlyBuyerOrSeller(_orderNo)\\n    {\\n        Order memory order = orders[_orderNo];\\n        require(order.orderNo != uint256(0), \\\"current Order not exist\\\");\\n        require(_orderStatus \\u003e= 1 \\u0026\\u0026 _orderStatus \\u003c= 5, \\\"Invalid order status\\\");\\n\\n        if (_orderStatus == 2 \\u0026\\u0026 order.orderStatus != 1) {\\n            revert(\\\"Invalid order status 2\\\");\\n        }\\n        if (_orderStatus == 3 \\u0026\\u0026 order.orderStatus != 2) {\\n            revert(\\\"Invalid order status 3\\\");\\n        }\\n        if (_orderStatus == 4 \\u0026\\u0026 order.orderStatus != 1) {\\n            revert(\\\"Invalid order status 4\\\");\\n        }\\n        if (\\n            _orderStatus == 5 \\u0026\\u0026\\n            order.orderStatus != 1 \\u0026\\u0026\\n            order.orderStatus != 2\\n        ) {\\n            revert(\\\"Invalid order status 5\\\");\\n        }\\n\\n        if (_orderStatus == 2) {\\n            require(\\n                order.orderDetail.buyerAddr == msg.sender,\\n                \\\"only buyer call\\\"\\n            );\\n        }\\n        if (_orderStatus == 3) {\\n            require(\\n                order.orderDetail.sellerAddr == msg.sender,\\n                \\\"only seller call\\\"\\n            );\\n        }\\n        order.orderStatus = _orderStatus;\\n\\n        order.orderDetail.updateTime = block.timestamp;\\n        orders[_orderNo] = order;\\n        orderList[orderIndex[_orderNo]] = order;\\n        emit OrderUpdateStatus(_orderNo, _orderStatus);\\n    }\\n\\n    function searchOrder(uint256 _orderNo)\\n        external\\n        view\\n        returns (Order memory order)\\n    {\\n        require(_orderNo != uint256(0), \\\"orderNo null\\\");\\n        require(\\n            orders[_orderNo].orderNo != uint256(0),\\n            \\\"current Order not exist\\\"\\n        );\\n\\n        Order memory o = orders[_orderNo];\\n        return o;\\n    }\\n\\n    function searchOrderList() external view returns (Order[] memory) {\\n        return orderList;\\n    }\\n\\n    function searchListByRest(uint256 _restNo)\\n        external\\n        view\\n        returns (Order[] memory)\\n    {\\n        Order[] memory resultList = new Order[](orderList.length);\\n        for (uint256 i = 0; i \\u003c orderList.length; i++) {\\n            Order memory _order = orderList[i];\\n            if (_order.restNo == _restNo) {\\n                resultList[i] = _order;\\n            }\\n        }\\n        return resultList;\\n    }\\n}\\n\"},\"RecordInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./RestStorage.sol\\\";\\nimport \\\"./OrderStorage.sol\\\";\\nimport \\\"./UserStorage.sol\\\";\\nimport \\\"./RecordStorage.sol\\\";\\nimport \\\"./AppealStorage.sol\\\";\\ninterface RecordInterface {\\n    function getErcBalance(string memory _coinType, address _addr)\\n        external\\n        returns (uint256);\\n    function getAvailableTotal(address _addr, string memory _coinType)\\n        external\\n        returns (uint256);\\n    function getFrozenTotal(address _addr, string memory _coinType)\\n        external\\n        returns (uint256);\\n    function addAvailableTotal(\\n        address _addr,\\n        string memory _coinType,\\n        uint256 remainHoldCoin\\n    ) external;\\n    function subAvaAppeal(\\n        address _from,\\n        address _to,\\n        AppealStorage.Appeal memory _al,\\n        uint256 _amt,\\n        uint256 _type,\\n        uint256 _self\\n    ) external;\\n    function subWitnessAvailable(address _addr) external;\\n    function getERC20Address(string memory _coinType)\\n        external\\n        returns (TokenTransfer);\\n    function subFrozenTotal(uint256 _orderNo, address _addr) external;\\n    function addRecord(\\n        address _addr,\\n        string memory _tradeHash,\\n        string memory _coinType,\\n        uint256 _hostCount,\\n        uint256 _hostStatus,\\n        uint256 _hostType,\\n        uint256 _hostDirection\\n    ) external;\\n    function getAppealFee() external view returns (uint256);\\n    function getAppealFeeFinal() external view returns (uint256);\\n    function getWitnessHandleReward() external view returns (uint256);\\n    function getObserverHandleReward() external view returns (uint256);\\n    function getWitnessHandleCredit() external view returns (uint256);\\n    function getObserverHandleCredit() external view returns (uint256);\\n    function getSubWitCredit() external view returns (uint256);\\n    function getOpenTrade() external view returns (bool);\\n    function getTradeCredit() external view returns (uint256);\\n    function getSubTCredit() external view returns (uint256);\\n    function getSubWitFee() external view returns (uint256);\\n}\\ninterface RestInterface {\\n    function searchRest(uint256 _restNo)\\n        external\\n        returns (RestStorage.Rest memory rest);\\n    function getRestFrozenTotal(address _addr, uint256 _restNo)\\n        external\\n        returns (uint256);\\n    function updateRestFinishCount(uint256 _restNo, uint256 _coinCount)\\n        external\\n        returns (uint256);\\n    function addRestRemainCount(uint256 _restNo, uint256 _remainCount)\\n        external\\n        returns (uint256);\\n}\\ninterface OrderInterface {\\n    function searchOrder(uint256 _orderNo)\\n        external\\n        returns (OrderStorage.Order memory order);\\n}\\ninterface UserInterface {\\n    function searchUser(address _addr)\\n        external\\n        view\\n        returns (UserStorage.User memory user);\\n    function searchWitnessList(uint256 _userFlag)\\n        external\\n        returns (UserStorage.User[] memory userList);\\n    function updateTradeStats(\\n        address _addr,\\n        UserStorage.TradeStats memory _tradeStats,\\n        uint256 _credit\\n    ) external;\\n    function updateMorgageStats(\\n        address _addr,\\n        UserStorage.MorgageStats memory _morgageStats\\n    ) external;\\n    function updateUserRole(address _addr, uint256 _userFlag) external;\\n}\\ninterface AppealInterface {\\n    function searchAppeal(uint256 _o)\\n        external\\n        view\\n        returns (AppealStorage.Appeal memory appeal);\\n}\\n\"},\"RecordStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./RecordInterface.sol\\\";\\nimport \\\"./UserStorage.sol\\\";\\nimport \\\"./OrderStorage.sol\\\";\\n\\nabstract contract ReentrancyGuardRecord {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"reentrant call\\\");\\n\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\nlibrary CountersRecord {\\n    struct Counter {\\n        uint256 _value;\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        {\\n            if (counter._value == 0) {\\n                counter._value = 10000;\\n            }\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value \\u003e 0, \\\"decrement overflow\\\");\\n        {\\n            counter._value = value - 1;\\n        }\\n    }\\n}\\n\\ninterface TokenTransfer {\\n    function transfer(address recipient, uint256 amount) external;\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function allowance(address _owner, address _spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n}\\n\\ncontract RecordStorage is Ownable, ReentrancyGuardRecord {\\n    using CountersRecord for CountersRecord.Counter;\\n\\n    mapping(string =\\u003e address) coinTypeMaping;\\n    uint256 public merchantNeedCount = 100000000 * (10**18);\\n    uint256 public witnessNeedCount = 100000000 * (10**18);\\n    uint256 public congressNeedCount = 100000000 * (10**18);\\n    uint256 public appealFee = 1000000 * (10**18);\\n    uint256 public appealFeeFinal = 10000000 * (10**18);\\n    uint256 public canWithdrawToTime = 0;\\n    uint256 public subWitFee = 2000000 * (10**18);\\n    uint256 public subWitCredit = 10;\\n    uint256 public witnessHandleReward = 1000000 * (10**18);\\n    uint256 public observerHandleReward = 10000000 * (10**18);\\n    uint256 public witnessHandleCredit = 1;\\n    uint256 public observerHandleCredit = 1;\\n    bool public openTrade = false;\\n    uint256 public tradeCredit = 1;\\n    uint256 public subTCredit = 10;\\n\\n    mapping(address =\\u003e uint256) witnessFlag;\\n    mapping(address =\\u003e uint256) congressFlag;\\n\\n    function setWitnessFlag(address _addr, uint256 _flag) external onlyOwner {\\n        witnessFlag[_addr] = _flag;\\n        if (_flag == 1) {\\n            uint256 _amt = availableTotal[_addr][\\\"AIR\\\"];\\n            require(_amt \\u003e= witnessNeedCount, \\\"1\\\");\\n            _userStorage.updateUserRole(_addr, 1);\\n        } else {\\n            _userStorage.updateUserRole(_addr, 0);\\n        }\\n    }\\n\\n    function getWitnessFlag(address _addr) public view returns (uint256) {\\n        return witnessFlag[_addr];\\n    }\\n\\n    function setCongressFlag(address _addr, uint256 _flag) external onlyOwner {\\n        congressFlag[_addr] = _flag;\\n        if (_flag == 1) {\\n            uint256 _amt = availableTotal[_addr][\\\"AIR\\\"];\\n            require(_amt \\u003e= congressNeedCount, \\\"1\\\");\\n            _userStorage.updateUserRole(_addr, 2);\\n        } else {\\n            _userStorage.updateUserRole(_addr, 0);\\n        }\\n    }\\n\\n    function getCongressFlag(address _addr) public view returns (uint256) {\\n        return congressFlag[_addr];\\n    }\\n\\n    function setCoinTypeMapping(string memory _coinType, address _coinTypeAddr)\\n        external\\n        onlyOwner\\n    {\\n        coinTypeMaping[_coinType] = _coinTypeAddr;\\n    }\\n\\n    function getCoinTypeMapping(string memory _coinType)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return coinTypeMaping[_coinType];\\n    }\\n\\n    function setMerchantNeedCount(uint256 _count) external onlyOwner {\\n        merchantNeedCount = _count * (10**18);\\n    }\\n\\n    function getMerchantNeedCount() public view returns (uint256) {\\n        return merchantNeedCount;\\n    }\\n\\n    function setWitnessNeedCount(uint256 _count) external onlyOwner {\\n        witnessNeedCount = _count * (10**18);\\n    }\\n\\n    function getWitnessNeedCount() public view returns (uint256) {\\n        return witnessNeedCount;\\n    }\\n\\n    function setCongressNeedCount(uint256 _count) external onlyOwner {\\n        congressNeedCount = _count * (10**18);\\n    }\\n\\n    function getCongressNeedCount() public view returns (uint256) {\\n        return congressNeedCount;\\n    }\\n\\n    function setAppealFee(uint256 _count) external onlyOwner {\\n        appealFee = _count * (10**18);\\n    }\\n\\n    function getAppealFee() public view returns (uint256) {\\n        return appealFee;\\n    }\\n\\n    function setAppealFeeFinal(uint256 _count) external onlyOwner {\\n        appealFeeFinal = _count * (10**18);\\n    }\\n\\n    function getAppealFeeFinal() public view returns (uint256) {\\n        return appealFeeFinal;\\n    }\\n\\n    function setCanWithdrawToTime(uint256 _days) external onlyOwner {\\n        canWithdrawToTime = _days;\\n    }\\n\\n    function getCanWithdrawToTime() public view returns (uint256) {\\n        return canWithdrawToTime;\\n    }\\n\\n    function setSubWitFee(uint256 _c) external onlyOwner {\\n        subWitFee = _c * (10**18);\\n    }\\n\\n    function getSubWitFee() public view returns (uint256) {\\n        return subWitFee;\\n    }\\n\\n    function setSubWitCredit(uint256 _c) external onlyOwner {\\n        subWitCredit = _c;\\n    }\\n\\n    function getSubWitCredit() public view returns (uint256) {\\n        return subWitCredit;\\n    }\\n\\n    function setWitnessHandleReward(uint256 _c) external onlyOwner {\\n        witnessHandleReward = _c * (10**18);\\n    }\\n\\n    function getWitnessHandleReward() public view returns (uint256) {\\n        return witnessHandleReward;\\n    }\\n\\n    function setObserverHandleReward(uint256 _c) external onlyOwner {\\n        observerHandleReward = _c * (10**18);\\n    }\\n\\n    function getObserverHandleReward() public view returns (uint256) {\\n        return observerHandleReward;\\n    }\\n\\n    function setWitnessHandleCredit(uint256 _c) external onlyOwner {\\n        witnessHandleCredit = _c;\\n    }\\n\\n    function getWitnessHandleCredit() public view returns (uint256) {\\n        return witnessHandleCredit;\\n    }\\n\\n    function setObserverHandleCredit(uint256 _c) external onlyOwner {\\n        observerHandleCredit = _c;\\n    }\\n\\n    function getObserverHandleCredit() public view returns (uint256) {\\n        return observerHandleCredit;\\n    }\\n\\n    function setOpenTrade(bool _c) external onlyOwner {\\n        openTrade = _c;\\n    }\\n\\n    function getOpenTrade() public view returns (bool) {\\n        return openTrade;\\n    }\\n\\n    function setTradeCredit(uint256 _c) external onlyOwner {\\n        tradeCredit = _c;\\n    }\\n\\n    function getTradeCredit() public view returns (uint256) {\\n        return tradeCredit;\\n    }\\n\\n    function setSubTCredit(uint256 _c) external onlyOwner {\\n        subTCredit = _c;\\n    }\\n\\n    function getSubTCredit() public view returns (uint256) {\\n        return subTCredit;\\n    }\\n\\n    mapping(string =\\u003e address) public feeAddrSet;\\n    mapping(string =\\u003e uint256) public feeAmountSet;\\n\\n    function setFee(\\n        string calldata _method,\\n        address _addr,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        feeAddrSet[_method] = _addr;\\n        feeAmountSet[_method] = _amount;\\n    }\\n\\n    function _payFee(string memory _method) internal {\\n        uint256 _amt = feeAmountSet[_method];\\n        address _addr = feeAddrSet[_method];\\n\\n        if (_amt \\u003e 0) {\\n            require(_addr != address(0), \\\"1\\\");\\n            require(msg.value \\u003e= _amt, \\\"2\\\");\\n            payable(_addr).transfer(_amt);\\n        }\\n    }\\n\\n    function punishPerson(\\n        address _from,\\n        address _to,\\n        uint256 _count\\n    ) external onlyOwner {\\n        require(_from != address(0), \\\"1\\\");\\n        require(_to != address(0), \\\"2\\\");\\n        UserStorage.User memory _user = _userStorage.searchUser(_from);\\n        require(_user.userFlag == 1 || _user.userFlag == 2, \\\"3\\\");\\n\\n        uint256 _ava = availableTotal[_from][\\\"AIR\\\"];\\n        uint256 _toavailab = availableTotal[_to][\\\"AIR\\\"];\\n        if (_ava \\u003e= _count) {\\n            availableTotal[_from][\\\"AIR\\\"] = SafeMath.sub(_ava, _count);\\n            availableTotal[_to][\\\"AIR\\\"] = SafeMath.add(_toavailab, _count);\\n        } else {\\n            availableTotal[_from][\\\"AIR\\\"] = 0;\\n\\n            uint256 _draing = withdrawingTotal[_from][\\\"AIR\\\"];\\n            if (SafeMath.add(_ava, _draing) \\u003e= _count) {\\n                withdrawingTotal[_from][\\\"AIR\\\"] = SafeMath.sub(\\n                    _draing,\\n                    SafeMath.sub(_count, _ava)\\n                );\\n                availableTotal[_to][\\\"AIR\\\"] = SafeMath.add(_toavailab, _count);\\n            } else {\\n                withdrawingTotal[_from][\\\"AIR\\\"] = 0;\\n                availableTotal[_to][\\\"AIR\\\"] = SafeMath.add(\\n                    _toavailab,\\n                    SafeMath.add(_ava, _draing)\\n                );\\n            }\\n        }\\n        chanRole(_from);\\n        chanRole(_to);\\n    }\\n\\n    UserInterface private _userStorage;\\n    OrderInterface private _orderStorage;\\n    struct Record {\\n        uint256 recordNo;\\n        address userAddr;\\n        string tradeHash;\\n        string coinType;\\n        uint256 hostCount;\\n        uint256 hostStatus;\\n        uint256 hostType;\\n        uint256 hostDirection;\\n        uint256 hostTime;\\n        uint256 updateTime;\\n    }\\n\\n    CountersRecord.Counter private _recordNoCounter;\\n    mapping(uint256 =\\u003e Record) public records;\\n    mapping(uint256 =\\u003e uint256) public recordIndex;\\n\\n    Record[] public recordList;\\n\\n    mapping(address =\\u003e mapping(string =\\u003e uint256)) public availableTotal;\\n\\n    mapping(address =\\u003e mapping(string =\\u003e uint256)) public frozenTotal;\\n\\n    mapping(address =\\u003e mapping(string =\\u003e uint256)) public unfrozenTotal;\\n\\n    mapping(address =\\u003e uint256) lastWithdrawTime;\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) lastWithdrawAmount;\\n\\n    mapping(address =\\u003e mapping(string =\\u003e uint256)) public withdrawingTotal;\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) orderSubFrozenList;\\n\\n    constructor(\\n        address _usdtAddress,\\n        address _usdcAddress,\\n        address _busdAddress,\\n        address _airAddress\\n    ) {\\n        coinTypeMaping[\\\"USDT\\\"] = _usdtAddress;\\n        coinTypeMaping[\\\"USDC\\\"] = _usdcAddress;\\n        coinTypeMaping[\\\"BUSD\\\"] = _busdAddress;\\n        coinTypeMaping[\\\"AIR\\\"] = _airAddress;\\n        _recordNoCounter.increment();\\n    }\\n\\n    function getERC20Address(string memory _coinType)\\n        public\\n        view\\n        returns (TokenTransfer)\\n    {\\n        require(bytes(_coinType).length != 0, \\\"1\\\");\\n        address _remoteAddr = coinTypeMaping[_coinType];\\n\\n        require(_remoteAddr != address(0), \\\"2\\\");\\n\\n        TokenTransfer _tokenTransfer = TokenTransfer(_remoteAddr);\\n        return _tokenTransfer;\\n    }\\n\\n    event RecordAdd(\\n        uint256 _recordNo,\\n        address _addr,\\n        string _tradeHash,\\n        string _coinType,\\n        uint256 _hostCount,\\n        uint256 _hostStatus,\\n        uint256 _hostType,\\n        uint256 _hostDirection\\n    );\\n    event RecordApplyUnfrozen(address _addr, uint256 _amt);\\n    event UnfrozenTotalTransfer(\\n        address _addr,\\n        string _coinType,\\n        uint256 _lastAmount\\n    );\\n    event RecordUpdate(\\n        address _addr,\\n        uint256 _recordNo,\\n        string _hash,\\n        uint256 _hostStatus\\n    );\\n\\n    address _userAddr;\\n    address _restCAddr;\\n    address _orderCAddr;\\n    address _appealCAddr;\\n\\n    modifier onlyAuthFromAddr() {\\n        require(_userAddr != address(0), \\u0027Invalid user\\u0027);\\n        require(_restCAddr != address(0), \\u0027Invalid rest\\u0027);\\n        require(_orderCAddr != address(0), \\u0027Invalid order\\u0027);\\n        require(_appealCAddr != address(0), \\u0027Invalid appeal\\u0027);\\n        _;\\n    }\\n\\n    function authFromContract(\\n        address _fromUser,\\n        address _fromRest,\\n        address _fromOrder,\\n        address _fromAppeal\\n    ) external onlyOwner {\\n        _userAddr = _fromUser;\\n        _restCAddr = _fromRest;\\n        _orderCAddr = _fromOrder;\\n        _appealCAddr = _fromAppeal;\\n        _userStorage = UserInterface(_userAddr);\\n        _orderStorage = OrderInterface(_orderCAddr);\\n    }\\n\\n    function _insert(\\n        address _addr,\\n        string memory _tradeHash,\\n        string memory _coinType,\\n        uint256 _hostCount,\\n        uint256 _hostStatus,\\n        uint256 _hostType,\\n        uint256 _hostDirection\\n    ) internal nonReentrant returns (uint256 recordNo) {\\n        require(_addr != address(0), \\\"address null\\\");\\n        require(bytes(_coinType).length != 0, \\\"coinType null\\\");\\n        require(_hostCount != uint256(0), \\\"hostCount null\\\");\\n        require(_hostType != uint256(0), \\\"hostType null\\\");\\n        require(_hostDirection != uint256(0), \\\"hostDirection null\\\");\\n\\n        uint256 _recordNo = _recordNoCounter.current();\\n        require(records[_recordNo].recordNo == uint256(0), \\\"order exist\\\");\\n\\n        Record memory _record = Record({\\n            recordNo: _recordNo,\\n            userAddr: _addr,\\n            tradeHash: _tradeHash,\\n            coinType: _coinType,\\n            hostCount: _hostCount,\\n            hostStatus: _hostStatus,\\n            hostType: _hostType,\\n            hostDirection: _hostDirection,\\n            hostTime: block.timestamp,\\n            updateTime: 0\\n        });\\n\\n        records[_recordNo] = _record;\\n\\n        recordList.push(_record);\\n        recordIndex[_recordNo] = recordList.length - 1;\\n\\n        _recordNoCounter.increment();\\n        emit RecordAdd(\\n            _recordNo,\\n            _addr,\\n            _tradeHash,\\n            _coinType,\\n            _hostCount,\\n            _hostStatus,\\n            _hostType,\\n            _hostDirection\\n        );\\n        return _recordNo;\\n    }\\n\\n    function tokenEscrow(string memory _coinType, uint256 _amt)\\n        external\\n        payable\\n    {\\n        _payFee(\\\"tokenEscrow\\\");\\n        require(_amt \\u003e 0, \\\"1\\\");\\n        require(\\n            availableTotal[msg.sender][_coinType] + _amt \\u003e\\n                availableTotal[msg.sender][_coinType],\\n            \\\"2\\\"\\n        );\\n\\n        availableTotal[msg.sender][_coinType] = SafeMath.add(\\n            availableTotal[msg.sender][_coinType],\\n            _amt\\n        );\\n\\n        uint256 _hostType = 1;\\n        if (\\n            keccak256(abi.encodePacked(_coinType)) ==\\n            keccak256(abi.encodePacked(\\\"AIR\\\"))\\n        ) {\\n            _hostType = 2;\\n            UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\\n\\n            _changeUserMorgageStats(\\n                msg.sender,\\n                availableTotal[msg.sender][_coinType]\\n            );\\n\\n            if (\\n                _user.userFlag == 0 \\u0026\\u0026\\n                availableTotal[msg.sender][_coinType] \\u003e= merchantNeedCount\\n            ) {\\n                _userStorage.updateUserRole(msg.sender, 3);\\n            }\\n        }\\n        _insert(msg.sender, \\\"\\\", _coinType, _amt, 2, _hostType, 1);\\n\\n        TokenTransfer _tokenTransfer = getERC20Address(_coinType);\\n        _tokenTransfer.transferFrom(msg.sender, address(this), _amt);\\n    }\\n\\n    function addRecord(\\n        address _addr,\\n        string memory _tradeHash,\\n        string memory _coinType,\\n        uint256 _hostCount,\\n        uint256 _hostStatus,\\n        uint256 _hostType,\\n        uint256 _hostDirection\\n    ) public onlyAuthFromAddr {\\n        require(\\n            msg.sender == _restCAddr || msg.sender == _orderCAddr,\\n            \\\"1\\\"\\n        );\\n\\n        frozenTotal[_addr][_coinType] = SafeMath.add(\\n            frozenTotal[_addr][_coinType],\\n            _hostCount\\n        );\\n        _insert(\\n            _addr,\\n            _tradeHash,\\n            _coinType,\\n            _hostCount,\\n            _hostStatus,\\n            _hostType,\\n            _hostDirection\\n        );\\n    }\\n\\n    function addAvailableTotal(\\n        address _addr,\\n        string memory _coinType,\\n        uint256 _amt\\n    ) public onlyAuthFromAddr {\\n        require(\\n            msg.sender == _restCAddr || msg.sender == _orderCAddr,\\n            \\\"1\\\"\\n        );\\n        require(_amt \\u003e 0, \\\"2\\\");\\n        uint256 _aBalance = getErcBalance(_coinType, address(this));\\n        require(_aBalance \\u003e= _amt, \\\"3\\\");\\n        require(frozenTotal[_addr][_coinType] \\u003e= _amt, \\\"4\\\");\\n        require(\\n            SafeMath.sub(frozenTotal[_addr][_coinType], _amt) \\u003c=\\n                frozenTotal[_addr][_coinType],\\n            \\\"5\\\"\\n        );\\n        frozenTotal[_addr][_coinType] = SafeMath.sub(\\n            frozenTotal[_addr][_coinType],\\n            _amt\\n        );\\n\\n        TokenTransfer _tokenTransfer = getERC20Address(_coinType);\\n        _tokenTransfer.transfer(_addr, _amt);\\n    }\\n\\n    function getAvailableTotal(address _addr, string memory _coinType)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return availableTotal[_addr][_coinType];\\n    }\\n\\n    function subFrozenTotal(uint256 _orderNo, address _addr)\\n        public\\n        onlyAuthFromAddr\\n    {\\n        require(\\n            msg.sender == _orderCAddr || msg.sender == _appealCAddr,\\n            \\\"1\\\"\\n        );\\n        OrderStorage.Order memory _order = _orderStorage.searchOrder(_orderNo);\\n        require(_order.orderNo != uint256(0), \\\"1\\\");\\n        address _seller = _order.orderDetail.sellerAddr;\\n        string memory _coinType = _order.orderDetail.coinType;\\n\\n        uint256 _subAmount = orderSubFrozenList[_seller][_orderNo];\\n        require(_subAmount == 0, \\\"2\\\");\\n\\n        uint256 _frozen = frozenTotal[_seller][_coinType];\\n        uint256 _orderCount = _order.coinCount;\\n        require(_frozen \\u003e= _orderCount, \\\"3\\\");\\n        require(\\n            SafeMath.sub(_frozen, _orderCount) \\u003c= _frozen,\\n            \\\"4\\\"\\n        );\\n\\n        frozenTotal[_seller][_coinType] = SafeMath.sub(_frozen, _orderCount);\\n        orderSubFrozenList[_seller][_orderNo] = _orderCount;\\n\\n        TokenTransfer _tokenTransfer = getERC20Address(_coinType);\\n        _tokenTransfer.transfer(_addr, _orderCount);\\n    }\\n\\n    function subAvaAppeal(\\n        address _from,\\n        address _to,\\n        AppealStorage.Appeal memory _al,\\n        uint256 _amt,\\n        uint256 _t,\\n        uint256 _self\\n    ) public onlyAuthFromAddr {\\n        require(msg.sender == _appealCAddr, \\\"1\\\");\\n\\n        uint256 _available = getAvailableTotal(_from, \\\"AIR\\\");\\n        uint256 _need = 0;\\n        address _opt = _t == 1 ? _al.witness : _al.detail.observerAddr;\\n        if (_available \\u003e= _amt) {\\n            _need = _amt;\\n        } else {\\n            _need = _available;\\n        }\\n\\n        if (\\n            (_t == 1 \\u0026\\u0026 _self == 0) ||\\n            (_t == 2 \\u0026\\u0026 _al.detail.finalAppealAddr != _from)\\n        ) {\\n            availableTotal[_from][\\\"AIR\\\"] = SafeMath.sub(\\n                availableTotal[_from][\\\"AIR\\\"],\\n                _need\\n            );\\n            availableTotal[_to][\\\"AIR\\\"] = SafeMath.add(\\n                availableTotal[_to][\\\"AIR\\\"],\\n                _need\\n            );\\n            _changeUserMorgageStats(_from, availableTotal[_from][\\\"AIR\\\"]);\\n            _changeUserMorgageStats(_to, availableTotal[_to][\\\"AIR\\\"]);\\n        }\\n\\n        availableTotal[_opt][\\\"AIR\\\"] = SafeMath.add(\\n            availableTotal[_opt][\\\"AIR\\\"],\\n            _amt\\n        );\\n        _changeUserMorgageStats(_opt, availableTotal[_opt][\\\"AIR\\\"]);\\n        chanRole(_from);\\n        chanRole(_to);\\n        chanRole(_opt);\\n\\n        UserStorage.User memory _user = _userStorage.searchUser(_opt);\\n        if (_t == 1) {\\n            _user.credit = _user.credit + witnessHandleCredit;\\n        } else if (_t == 2) {\\n            _user.credit = _user.credit + observerHandleCredit;\\n        }\\n        UserStorage.TradeStats memory _tradeStats = _user.tradeStats;\\n        _userStorage.updateTradeStats(_opt, _tradeStats, _user.credit);\\n    }\\n\\n    function _changeUserMorgageStats(address _addr, uint256 _amt) internal {\\n        UserStorage.User memory _user = _userStorage.searchUser(_addr);\\n        UserStorage.MorgageStats memory _morgageStats = _user.morgageStats;\\n        _morgageStats.mortgage = _amt;\\n        _userStorage.updateMorgageStats(_addr, _morgageStats);\\n    }\\n\\n    function subWitnessAvailable(address _addr) public onlyAuthFromAddr {\\n        require(msg.sender == _appealCAddr, \\\"1\\\");\\n        require(_addr != address(0), \\\"2\\\");\\n        uint256 _availableTotal = availableTotal[_addr][\\\"AIR\\\"];\\n        uint256 _need = 0;\\n        uint256 subFromDraing = 0;\\n        if (_availableTotal \\u003e= subWitFee) {\\n            _need = subWitFee;\\n            availableTotal[_addr][\\\"AIR\\\"] = SafeMath.sub(_availableTotal, _need);\\n        } else {\\n            availableTotal[_addr][\\\"AIR\\\"] = 0;\\n\\n            uint256 _draing = withdrawingTotal[_addr][\\\"AIR\\\"];\\n            if (SafeMath.add(_availableTotal, _draing) \\u003e= subWitFee) {\\n                _need = subWitFee;\\n                subFromDraing = SafeMath.sub(subWitFee, _availableTotal);\\n                withdrawingTotal[_addr][\\\"AIR\\\"] = SafeMath.sub(\\n                    _draing,\\n                    subFromDraing\\n                );\\n            } else {\\n                _need = SafeMath.add(_draing, _availableTotal);\\n                withdrawingTotal[_addr][\\\"AIR\\\"] = 0;\\n            }\\n        }\\n        chanRole(_addr);\\n\\n        UserStorage.User memory _user = _userStorage.searchUser(_addr);\\n        _user.credit = _user.credit \\u003e= subWitCredit\\n            ? (_user.credit - subWitCredit)\\n            : 0;\\n        UserStorage.TradeStats memory _tradeStats = _user.tradeStats;\\n        _userStorage.updateTradeStats(_addr, _tradeStats, _user.credit);\\n\\n        TokenTransfer _tokenTransfer = getERC20Address(\\\"AIR\\\");\\n        _tokenTransfer.transfer(owner(), _need);\\n    }\\n\\n    function getFrozenTotal(address _addr, string memory _coinType)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return frozenTotal[_addr][_coinType];\\n    }\\n\\n    function applyUnfrozen(uint256 _amt) external payable returns (uint256) {\\n        _payFee(\\\"applyUnfrozen\\\");\\n        string memory _coinType = \\\"AIR\\\";\\n        require(_amt \\u003e 0, \\\"1\\\");\\n        require(\\n            availableTotal[msg.sender][_coinType] \\u003e= _amt,\\n            \\\"2\\\"\\n        );\\n        require(\\n            SafeMath.sub(availableTotal[msg.sender][_coinType], _amt) \\u003c\\n                availableTotal[msg.sender][_coinType],\\n            \\\"3\\\"\\n        );\\n\\n        lastWithdrawTime[msg.sender] = block.timestamp;\\n        lastWithdrawAmount[msg.sender][lastWithdrawTime[msg.sender]] = _amt;\\n        availableTotal[msg.sender][_coinType] = SafeMath.sub(\\n            availableTotal[msg.sender][_coinType],\\n            _amt\\n        );\\n        withdrawingTotal[msg.sender][_coinType] = SafeMath.add(\\n            withdrawingTotal[msg.sender][_coinType],\\n            _amt\\n        );\\n\\n        chanRole(msg.sender);\\n\\n        _insert(msg.sender, \\\"\\\", _coinType, _amt, 3, 3, 2);\\n\\n        emit RecordApplyUnfrozen(msg.sender, _amt);\\n\\n        return getAvailableTotal(msg.sender, _coinType);\\n    }\\n\\n    function chanRole(address _addr) internal {\\n        uint256 _avail = availableTotal[_addr][\\\"AIR\\\"];\\n\\n        UserStorage.User memory _user = _userStorage.searchUser(_addr);\\n\\n        _changeUserMorgageStats(_addr, _avail);\\n\\n        if (\\n            _user.userFlag == 2 \\u0026\\u0026\\n            _avail \\u003c congressNeedCount \\u0026\\u0026\\n            _avail \\u003e= merchantNeedCount\\n        ) {\\n            _userStorage.updateUserRole(_addr, 3);\\n        }\\n\\n        if (\\n            _user.userFlag == 1 \\u0026\\u0026\\n            _avail \\u003c witnessNeedCount \\u0026\\u0026\\n            _avail \\u003e= merchantNeedCount\\n        ) {\\n            _userStorage.updateUserRole(_addr, 3);\\n        }\\n\\n        if (_user.userFlag == 0 \\u0026\\u0026 _avail \\u003e= merchantNeedCount) {\\n            _userStorage.updateUserRole(_addr, 3);\\n        }\\n\\n        if (_avail \\u003c merchantNeedCount) {\\n            _userStorage.updateUserRole(_addr, 0);\\n        }\\n    }\\n\\n    function unApplyUnfrozen(address _addr) external onlyOwner {\\n        string memory _coinType = \\\"AIR\\\";\\n        uint256 _drawing = withdrawingTotal[_addr][_coinType];\\n        require(_drawing \\u003e 0, \\\"1\\\");\\n        withdrawingTotal[_addr][_coinType] = 0;\\n        availableTotal[_addr][_coinType] = SafeMath.add(\\n            availableTotal[_addr][_coinType],\\n            _drawing\\n        );\\n        chanRole(_addr);\\n    }\\n\\n    function applyWithdraw(uint256 _recordNo) external payable {\\n        _payFee(\\\"applyWithdraw\\\");\\n        Record memory _record = records[_recordNo];\\n\\n        require(_record.recordNo != uint256(0), \\\"1\\\");\\n        require(_record.userAddr == msg.sender, \\\"2\\\");\\n\\n        require(_record.hostStatus == 3, \\\"3\\\");\\n\\n        require(\\n            withdrawingTotal[msg.sender][\\\"AIR\\\"] \\u003e= _record.hostCount,\\n            \\\"4\\\"\\n        );\\n\\n        require(\\n            block.timestamp \\u003e= (_record.hostTime + canWithdrawToTime * 1 days),\\n            \\\"5\\\"\\n        );\\n\\n        withdrawingTotal[msg.sender][\\\"AIR\\\"] = SafeMath.sub(\\n            withdrawingTotal[msg.sender][\\\"AIR\\\"],\\n            _record.hostCount\\n        );\\n        unfrozenTotal[msg.sender][\\\"AIR\\\"] = SafeMath.add(\\n            unfrozenTotal[msg.sender][\\\"AIR\\\"],\\n            _record.hostCount\\n        );\\n\\n        _record.hostStatus = 4;\\n        _record.updateTime = block.timestamp;\\n        records[_recordNo] = _record;\\n        recordList[recordIndex[_recordNo]] = _record;\\n        emit RecordUpdate(msg.sender, _recordNo, _record.tradeHash, 4);\\n\\n        TokenTransfer _tokenTransfer = getERC20Address(\\\"AIR\\\");\\n        _tokenTransfer.transfer(msg.sender, _record.hostCount);\\n    }\\n\\n    function unfrozenTotalSearch(address _addr, string memory _coinType)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        require(_addr != address(0), \\\"1\\\");\\n\\n        return unfrozenTotal[_addr][_coinType];\\n    }\\n\\n    function getUnfrozenTotal(address _addr, string memory _coinType)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return unfrozenTotal[_addr][_coinType];\\n    }\\n\\n    function getWithdrawingTotal(address _addr, string memory _coinType)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return withdrawingTotal[_addr][_coinType];\\n    }\\n\\n    function getErcBalance(string memory _coinType, address _addr)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        TokenTransfer _tokenTransfer = getERC20Address(_coinType);\\n        return _tokenTransfer.balanceOf(_addr);\\n    }\\n\\n    function _updateInfo(\\n        address _addr,\\n        uint256 _recordNo,\\n        string memory _hash,\\n        uint256 _hostStatus\\n    ) internal returns (bool) {\\n        Record memory _record = records[_recordNo];\\n        require(_record.userAddr == _addr, \\\"1\\\");\\n        require(_hostStatus == 1 || _hostStatus == 2, \\\"2\\\");\\n\\n        if (_hostStatus != uint256(0)) {\\n            _record.hostStatus = _hostStatus;\\n        }\\n        if (bytes(_hash).length != 0) {\\n            _record.tradeHash = _hash;\\n        }\\n\\n        _record.updateTime = block.timestamp;\\n        records[_recordNo] = _record;\\n        recordList[recordIndex[_recordNo]] = _record;\\n        emit RecordUpdate(_addr, _recordNo, _hash, _hostStatus);\\n        return true;\\n    }\\n\\n    function updateInfo(\\n        address _addr,\\n        uint256 _recordNo,\\n        string memory _hash,\\n        uint256 _hostStatus\\n    ) external returns (bool) {\\n        return _updateInfo(_addr, _recordNo, _hash, _hostStatus);\\n    }\\n\\n    function searchRecord(uint256 _recordNo)\\n        external\\n        view\\n        returns (Record memory record)\\n    {\\n        return records[_recordNo];\\n    }\\n\\n    function searchRecordList() external view returns (Record[] memory) {\\n        return recordList;\\n    }\\n}\"},\"RestStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./RecordInterface.sol\\\";\\nimport \\\"./UserStorage.sol\\\";\\nimport \\\"./RecordStorage.sol\\\";\\n\\nabstract contract ReentrancyGuardRest {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\nlibrary CountersRest {\\n    struct Counter {\\n        uint256 _value;\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        {\\n            if (counter._value == 0) {\\n                counter._value = 10000;\\n            }\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value \\u003e 0, \\\"Counter: decrement overflow\\\");\\n        {\\n            counter._value = value - 1;\\n        }\\n    }\\n}\\n\\ncontract RestStorage is Ownable, ReentrancyGuardRest {\\n    using CountersRest for CountersRest.Counter;\\n    RecordInterface private _recordStorage;\\n    UserInterface private _userStorage;\\n    address recordAddress;\\n\\n    struct Rest {\\n        address userAddr;\\n        uint256 restNo;\\n        uint256 restType;\\n        string coinType;\\n        string currencyType;\\n        uint256 restCount;\\n        uint256 price;\\n        uint256[] payType;\\n        uint256 restStatus;\\n        RestDetail restDetail;\\n    }\\n    struct RestDetail {\\n        uint256 finishCount;\\n        uint256 remainderCount;\\n        uint256 limitAmountFrom;\\n        uint256 limitAmountTo;\\n        uint256 limitMinCredit;\\n        uint256 limitMinMortgage;\\n        string restRemark;\\n        uint256 restTime;\\n        uint256 updateTime;\\n        uint256 restFee;\\n        string restHash;\\n    }\\n\\n    CountersRest.Counter private _restNoCounter;\\n    mapping(uint256 =\\u003e Rest) private rests;\\n    mapping(uint256 =\\u003e uint256) private restIndex;\\n\\n    Rest[] private restList;\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) restFrozenTotal;\\n\\n    event RestAdd(\\n        uint256 _restNo,\\n        uint256 _restType,\\n        string _coinType,\\n        string _currencyType,\\n        uint256 _restCount,\\n        uint256 _price,\\n        uint256[] _payType,\\n        RestDetail _restDetail\\n    );\\n    event RestUpdate(\\n        uint256 _restNo,\\n        string _coinType,\\n        string _currencyType,\\n        uint256 _restCount,\\n        uint256 _price,\\n        uint256[] _payType,\\n        RestDetail _restDetail\\n    );\\n\\n    address _orderCAddr;\\n\\n    modifier onlyAuthFromAddr() {\\n        require(_orderCAddr == msg.sender, \\\"Invalid contract address\\\");\\n        _;\\n    }\\n\\n    mapping(string =\\u003e address) public feeAddrSet;\\n    mapping(string =\\u003e uint256) public feeAmountSet;\\n\\n    function _payFee(string memory _method) internal {\\n        uint256 _amt = feeAmountSet[_method];\\n        address _addr = feeAddrSet[_method];\\n\\n        if (_amt \\u003e 0) {\\n            require(_addr != address(0), \\\"recipient null is not allowed\\\");\\n            require(msg.value \\u003e= _amt, \\\"insufficient balance\\\");\\n            payable(_addr).transfer(_amt);\\n        }\\n    }\\n\\n    function setFee(\\n        string calldata _method,\\n        address _addr,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        feeAddrSet[_method] = _addr;\\n        feeAmountSet[_method] = _amount;\\n    }\\n\\n    function authFromContract(\\n        address _recordAddr,\\n        address _userAddr,\\n        address _orderAddr\\n    ) external onlyOwner {\\n        _orderCAddr = _orderAddr;\\n        _recordStorage = RecordInterface(_recordAddr);\\n        _userStorage = UserInterface(_userAddr);\\n        recordAddress = _recordAddr;\\n        _restNoCounter.increment();\\n    }\\n\\n    modifier onlyRestOwner(uint256 _restNo) {\\n        require(\\n            rests[_restNo].userAddr == msg.sender,\\n            \\\"rest address not exist\\\"\\n        );\\n        _;\\n    }\\n\\n    function _checkParam(\\n        uint256 _restType,\\n        string memory _coinType,\\n        string memory _currencyType,\\n        uint256 _restCount,\\n        uint256 _price,\\n        uint256[] memory _payType\\n    ) internal pure {\\n        require(\\n            _restType != uint256(0),\\n            \\\"RestStorage: restType null is not allowed\\\"\\n        );\\n        require(\\n            bytes(_coinType).length != 0,\\n            \\\"RestStorage: coinType null is not allowed\\\"\\n        );\\n        require(\\n            bytes(_currencyType).length != 0,\\n            \\\"RestStorage: currencyType null is not allowed\\\"\\n        );\\n        require(\\n            _restCount != uint256(0),\\n            \\\"RestStorage: restCount null is not allowed\\\"\\n        );\\n        require(_price != uint256(0), \\\"RestStorage: price null is not allowed\\\");\\n        require(\\n            _payType.length != 0,\\n            \\\"RestStorage: payType null is not allowed\\\"\\n        );\\n    }\\n\\n    function _insert(\\n        uint256 _restType,\\n        string memory _coinType,\\n        string memory _currencyType,\\n        uint256 _restCount,\\n        uint256 _price,\\n        uint256[] memory _payType,\\n        RestDetail memory _restDetail\\n    ) internal nonReentrant returns (uint256) {\\n        _checkParam(\\n            _restType,\\n            _coinType,\\n            _currencyType,\\n            _restCount,\\n            _price,\\n            _payType\\n        );\\n\\n        uint256 _restNo = _restNoCounter.current();\\n        require(rests[_restNo].restNo == uint256(0), \\\"rest exist\\\");\\n\\n        _restDetail.finishCount = 0;\\n        _restDetail.remainderCount = _restCount;\\n        _restDetail.restTime = block.timestamp;\\n        _restDetail.updateTime = 0;\\n\\n        if (\\n            _restDetail.limitAmountTo \\u003e SafeMath.mul(_restCount, _price) ||\\n            _restDetail.limitAmountTo == 0\\n        ) {\\n            _restDetail.limitAmountTo = SafeMath.mul(_restCount, _price);\\n        }\\n        Rest memory r = Rest({\\n            userAddr: msg.sender,\\n            restNo: _restNo,\\n            restType: _restType,\\n            coinType: _coinType,\\n            currencyType: _currencyType,\\n            restCount: _restCount,\\n            price: _price,\\n            payType: _payType,\\n            restStatus: 1,\\n            restDetail: _restDetail\\n        });\\n        rests[_restNo] = r;\\n\\n        restList.push(r);\\n        restIndex[_restNo] = restList.length - 1;\\n\\n        _restNoCounter.increment();\\n\\n        emit RestAdd(\\n            _restNo,\\n            _restType,\\n            _coinType,\\n            _currencyType,\\n            _restCount,\\n            _price,\\n            _payType,\\n            _restDetail\\n        );\\n        return _restNo;\\n    }\\n\\n    function _updateInfo(\\n        uint256 _restNo,\\n        string memory _coinType,\\n        string memory _currencyType,\\n        uint256 _addCount,\\n        uint256 _price,\\n        uint256[] memory _payType,\\n        RestDetail memory _restDetail\\n    ) internal {\\n        require(_restNo != uint256(0), \\\"Invalid restNo\\\");\\n        Rest memory r = rests[_restNo];\\n        r.restStatus = 1;\\n        if (bytes(_coinType).length != 0) {\\n            r.coinType = _coinType;\\n        }\\n        if (bytes(_currencyType).length != 0) {\\n            r.currencyType = _currencyType;\\n        }\\n\\n        if (_price != uint256(0)) {\\n            r.price = _price;\\n        }\\n        if (_addCount != uint256(0)) {\\n            r.restCount += _addCount;\\n            r.restDetail.remainderCount += _addCount;\\n            r.restDetail.limitAmountTo = SafeMath.mul(\\n                r.restDetail.remainderCount,\\n                r.price\\n            );\\n        }\\n        if (_payType.length != 0) {\\n            r.payType = _payType;\\n        }\\n        if (_restDetail.limitAmountFrom != uint256(0)) {\\n            if (_restDetail.limitAmountFrom \\u003e r.restDetail.limitAmountTo) {\\n                _restDetail.limitAmountFrom = r.restDetail.limitAmountTo;\\n            }\\n            r.restDetail.limitAmountFrom = _restDetail.limitAmountFrom;\\n        }\\n        if (_restDetail.limitMinCredit != uint256(0)) {\\n            r.restDetail.limitMinCredit = _restDetail.limitMinCredit;\\n        }\\n        if (_restDetail.limitMinMortgage != uint256(0)) {\\n            r.restDetail.limitMinMortgage = _restDetail.limitMinMortgage;\\n        }\\n        if (bytes(_restDetail.restRemark).length != 0) {\\n            r.restDetail.restRemark = _restDetail.restRemark;\\n        }\\n\\n        if (_restDetail.restFee != uint256(0)) {\\n            r.restDetail.restFee = _restDetail.restFee;\\n        }\\n\\n        r.restDetail.updateTime = block.timestamp;\\n        rests[_restNo] = r;\\n        restList[restIndex[_restNo]] = r;\\n        emit RestUpdate(\\n            _restNo,\\n            _coinType,\\n            _currencyType,\\n            r.restCount,\\n            _price,\\n            _payType,\\n            _restDetail\\n        );\\n    }\\n\\n    function addBuyRest(\\n        uint256 _restType,\\n        string memory _coinType,\\n        string memory _currencyType,\\n        uint256 _restCount,\\n        uint256 _price,\\n        uint256[] memory _payType,\\n        RestDetail memory _restDetail\\n    ) external payable {\\n        _payFee(\\\"addBuyRest\\\");\\n        require(_restType == 1, \\\"must buy rest\\\");\\n\\n        UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\\n\\n        bool _openTrade = _recordStorage.getOpenTrade();\\n        require(_openTrade || _user.userFlag == 3, \\\"invalid user\\\");\\n\\n        _insert(\\n            _restType,\\n            _coinType,\\n            _currencyType,\\n            _restCount,\\n            _price,\\n            _payType,\\n            _restDetail\\n        );\\n    }\\n\\n    function _addSell(\\n        uint256 _restType,\\n        string memory _coinType,\\n        string memory _currencyType,\\n        uint256 _restCount,\\n        uint256 _restFee,\\n        uint256 _price,\\n        uint256[] memory _payType,\\n        RestDetail memory _restDetail\\n    ) internal {\\n        require(_restType == 2, \\\"must sell rest\\\");\\n        require(_restCount \\u003e 0, \\\"restCount error\\\");\\n\\n        UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\\n        bool _openTrade = _recordStorage.getOpenTrade();\\n        require(_openTrade || _user.userFlag == 3, \\\"invalid user\\\");\\n\\n        _recordStorage.addRecord(\\n            msg.sender,\\n            \\\"\\\",\\n            _coinType,\\n            _restCount,\\n            2,\\n            1,\\n            2\\n        );\\n        uint256 _needSub = SafeMath.add(_restCount, _restFee);\\n        TokenTransfer _tokenTransfer = _recordStorage.getERC20Address(\\n            _coinType\\n        );\\n        _tokenTransfer.transferFrom(msg.sender, recordAddress, _needSub);\\n\\n        uint256 _newRestNo = _insert(\\n            _restType,\\n            _coinType,\\n            _currencyType,\\n            _restCount,\\n            _price,\\n            _payType,\\n            _restDetail\\n        );\\n\\n        restFrozenTotal[msg.sender][_newRestNo] = _restCount;\\n    }\\n\\n    function addSellRest(\\n        uint256 _restType,\\n        string memory _coinType,\\n        string memory _currencyType,\\n        uint256 _restCount,\\n        uint256 _restFee,\\n        uint256 _price,\\n        uint256[] memory _payType,\\n        RestDetail memory _restDetail\\n    ) external payable {\\n        _payFee(\\\"addSellRest\\\");\\n        _addSell(\\n            _restType,\\n            _coinType,\\n            _currencyType,\\n            _restCount,\\n            _restFee,\\n            _price,\\n            _payType,\\n            _restDetail\\n        );\\n    }\\n\\n    function getRestFrozenTotal(address _addr, uint256 _restNo)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return restFrozenTotal[_addr][_restNo];\\n    }\\n\\n    function cancelBuyRest(uint256 _restNo)\\n        external\\n        payable\\n        onlyRestOwner(_restNo)\\n    {\\n        _payFee(\\\"cancelBuyRest\\\");\\n        require(rests[_restNo].restStatus == 1, \\\"can\\u0027t change this rest\\\");\\n        require(rests[_restNo].restType == 1, \\\"Invalid rest type\\\");\\n        require(\\n            rests[_restNo].restDetail.finishCount \\u003c rests[_restNo].restCount,\\n            \\\"this rest has finished\\\"\\n        );\\n\\n        Rest memory r = rests[_restNo];\\n        r.restStatus = 4;\\n        r.restDetail.updateTime = block.timestamp;\\n        rests[_restNo] = r;\\n        restList[restIndex[_restNo]] = r;\\n    }\\n\\n    function _cancelSell(uint256 _restNo) internal onlyRestOwner(_restNo) {\\n        require(rests[_restNo].restStatus == 1, \\\"can\\u0027t cancel this rest\\\");\\n        require(rests[_restNo].restType == 2, \\\"Invalid rest type\\\");\\n        require(\\n            rests[_restNo].restDetail.finishCount \\u003c rests[_restNo].restCount,\\n            \\\"this rest has finished\\\"\\n        );\\n        require(restFrozenTotal[msg.sender][_restNo] \\u003e 0, \\\"rest has finished\\\");\\n        uint256 _frozenTotal = _recordStorage.getFrozenTotal(\\n            msg.sender,\\n            rests[_restNo].coinType\\n        );\\n        require(\\n            _frozenTotal \\u003e= restFrozenTotal[msg.sender][_restNo],\\n            \\\"can\\u0027t cancel this rest\\\"\\n        );\\n\\n        uint256 remainHoldCoin = restFrozenTotal[msg.sender][_restNo];\\n\\n        Rest memory r = rests[_restNo];\\n        r.restStatus = 4;\\n\\n        if (remainHoldCoin \\u003c rests[_restNo].restCount) {\\n            r.restStatus = 5;\\n        }\\n        r.restDetail.remainderCount = 0;\\n        r.restDetail.updateTime = block.timestamp;\\n        rests[_restNo] = r;\\n        restList[restIndex[_restNo]] = r;\\n\\n        restFrozenTotal[msg.sender][_restNo] = 0;\\n\\n        _recordStorage.addAvailableTotal(\\n            msg.sender,\\n            rests[_restNo].coinType,\\n            remainHoldCoin\\n        );\\n    }\\n\\n    function cancelSellRest(uint256 _restNo) external payable {\\n        _payFee(\\\"cancelSellRest\\\");\\n        _cancelSell(_restNo);\\n    }\\n\\n    function startOrStop(uint256 _restNo, uint256 _restStatus)\\n        external\\n        payable\\n        onlyRestOwner(_restNo)\\n    {\\n        _payFee(\\\"startOrStop\\\");\\n        require(_restStatus == 1 || _restStatus == 3, \\\"Invalid rest status\\\");\\n\\n        Rest memory r = rests[_restNo];\\n        require(\\n            r.restStatus == 1 || r.restStatus == 3,\\n            \\\"Invalid rest status,opt error\\\"\\n        );\\n        r.restStatus = _restStatus;\\n        r.restDetail.updateTime = block.timestamp;\\n        rests[_restNo] = r;\\n        restList[restIndex[_restNo]] = r;\\n    }\\n\\n    function updateInfo(\\n        uint256 _restNo,\\n        string memory _coinType,\\n        string memory _currencyType,\\n        uint256 _addCount,\\n        uint256 _restFee,\\n        uint256 _price,\\n        uint256[] memory _payType,\\n        RestDetail memory _restDetail\\n    ) external onlyRestOwner(_restNo) {\\n        require(_restNo != uint256(0), \\\"Invalid restNo\\\");\\n        Rest memory _rest = rests[_restNo];\\n        require(_rest.restNo != uint256(0), \\\"rest not exist\\\");\\n\\n        if (_rest.restType == 2) {\\n            _recordStorage.addRecord(\\n                msg.sender,\\n                \\\"\\\",\\n                _coinType,\\n                _addCount,\\n                2,\\n                1,\\n                2\\n            );\\n            uint256 _needSub = SafeMath.add(_addCount, _restFee);\\n            TokenTransfer _tokenTransfer = _recordStorage.getERC20Address(\\n                _coinType\\n            );\\n            _tokenTransfer.transferFrom(msg.sender, recordAddress, _needSub);\\n\\n            restFrozenTotal[msg.sender][_restNo] += _addCount;\\n        }\\n        _updateInfo(\\n            _restNo,\\n            _coinType,\\n            _currencyType,\\n            _addCount,\\n            _price,\\n            _payType,\\n            _restDetail\\n        );\\n    }\\n\\n    function updateRestFinishCount(uint256 _restNo, uint256 _finishCount)\\n        external\\n        onlyAuthFromAddr\\n    {\\n        Rest memory _rest = rests[_restNo];\\n\\n        require(\\n            _rest.restDetail.remainderCount \\u003e= _finishCount,\\n            \\\"RestStorage:finish count error\\\"\\n        );\\n\\n        if (_rest.restType == 2) {\\n            restFrozenTotal[_rest.userAddr][_restNo] = SafeMath.sub(\\n                restFrozenTotal[_rest.userAddr][_restNo],\\n                _finishCount\\n            );\\n        }\\n\\n        _rest.restDetail.finishCount = SafeMath.add(\\n            _rest.restDetail.finishCount,\\n            _finishCount\\n        );\\n        _rest.restDetail.remainderCount = SafeMath.sub(\\n            _rest.restDetail.remainderCount,\\n            _finishCount\\n        );\\n        _rest.restDetail.limitAmountTo = SafeMath.mul(\\n            _rest.price,\\n            _rest.restDetail.remainderCount\\n        );\\n        if (_rest.restDetail.remainderCount == 0) {\\n            _rest.restStatus = 2;\\n        }\\n\\n        _rest.restDetail.updateTime = block.timestamp;\\n        rests[_restNo] = _rest;\\n        restList[restIndex[_restNo]] = _rest;\\n    }\\n\\n    function addRestRemainCount(uint256 _restNo, uint256 _remainCount)\\n        public\\n        onlyAuthFromAddr\\n    {\\n        Rest memory _rest = rests[_restNo];\\n        require(\\n            _remainCount \\u003e 0 \\u0026\\u0026 _rest.restDetail.finishCount \\u003e= _remainCount,\\n            \\\"count error\\\"\\n        );\\n\\n        if (_rest.restType == 2) {\\n            restFrozenTotal[_rest.userAddr][_restNo] = SafeMath.add(\\n                restFrozenTotal[_rest.userAddr][_restNo],\\n                _remainCount\\n            );\\n        }\\n\\n        _rest.restDetail.finishCount = SafeMath.sub(\\n            _rest.restDetail.finishCount,\\n            _remainCount\\n        );\\n        _rest.restDetail.remainderCount = SafeMath.add(\\n            _rest.restDetail.remainderCount,\\n            _remainCount\\n        );\\n        _rest.restDetail.limitAmountTo = SafeMath.mul(\\n            _rest.price,\\n            _rest.restDetail.remainderCount\\n        );\\n        _rest.restDetail.limitAmountFrom = _rest.restDetail.limitAmountFrom \\u003e\\n            _rest.restDetail.limitAmountTo\\n            ? _rest.restDetail.limitAmountTo\\n            : _rest.restDetail.limitAmountFrom;\\n        _rest.restStatus = 1;\\n\\n        _rest.restDetail.updateTime = block.timestamp;\\n        rests[_restNo] = _rest;\\n        restList[restIndex[_restNo]] = _rest;\\n    }\\n\\n    function searchRest(uint256 _restNo)\\n        external\\n        view\\n        returns (Rest memory rest)\\n    {\\n        require(_restNo != uint256(0), \\\"restNo null is not allowed\\\");\\n        Rest memory r = rests[_restNo];\\n        return r;\\n    }\\n\\n    function searchRestList() external view returns (Rest[] memory) {\\n        return restList;\\n    }\\n}\\n\"},\"UserStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\npragma solidity ^0.8.0;\\ncontract UserStorage is Ownable {\\n    struct User {\\n        address userAddr;\\n        string avatar;\\n        string email;\\n        uint256 isOnline;\\n        uint256 userFlag;\\n        uint256 credit;\\n        uint256 regTime;\\n        TradeStats tradeStats;\\n        MorgageStats morgageStats;\\n    }\\n    struct TradeStats {\\n        uint256 tradeTotal;\\n        uint256 restTotal;\\n    }\\n    struct MorgageStats {\\n        uint256 mortgage;\\n        uint256 freezeMortgage;\\n        uint256 relieveMortgage;\\n        uint256 inviteUserCount;\\n        uint256 inviteUserReward;\\n        uint256 applyRelieveTime;\\n        uint256 handleRelieveTime;\\n    }\\n    mapping(address =\\u003e User) public users;\\n    mapping(address =\\u003e uint256) public userIndex;\\n\\n    User[] public userList;\\n\\n    address public recipient;\\n    uint256 public feeAmount;\\n\\n    event addUser(address _userAddr);\\n    event updateUser(string _avatar, string _email, uint256 _isOnline);\\n\\n    address _restCAddr;\\n    address _orderCAddr;\\n    address _recordCAddr;\\n    address _appealCAddr;\\n\\n    modifier onlyAuthFromAddr() {\\n        require(_restCAddr != address(0), \\\"Invalid address call rest\\\");\\n        require(_orderCAddr != address(0), \\\"Invalid address call order\\\");\\n        require(_recordCAddr != address(0), \\\"Invalid address call record\\\");\\n        require(_appealCAddr != address(0), \\\"Invalid address call appeal\\\");\\n        _;\\n    }\\n\\n    function setFee(address _addr, uint256 _amount) external onlyOwner {\\n        recipient = _addr;\\n        feeAmount = _amount;\\n    }\\n\\n    function authFromContract(\\n        address _fromRest,\\n        address _fromOrder,\\n        address _fromRecord,\\n        address _fromAppeal\\n    ) external onlyOwner {\\n        _restCAddr = _fromRest;\\n        _orderCAddr = _fromOrder;\\n        _recordCAddr = _fromRecord;\\n        _appealCAddr = _fromAppeal;\\n    }\\n\\n    modifier onlyMemberOf() {\\n        require(users[msg.sender].userAddr != address(0), \\\"has no permission\\\");\\n        _;\\n    }\\n\\n    function _insert(address _addr) internal {\\n        require(_addr != address(0), \\\"UserStorage: addr null is not allowed\\\");\\n        require(\\n            users[_addr].userAddr == address(0),\\n            \\\"UserStorage: current User exist\\\"\\n        );\\n\\n        TradeStats memory tradeStats = TradeStats({\\n            tradeTotal: 0,\\n            restTotal: 0\\n        });\\n        MorgageStats memory morgageStats = MorgageStats({\\n            mortgage: 0,\\n            freezeMortgage: 0,\\n            relieveMortgage: 0,\\n            inviteUserCount: 0,\\n            inviteUserReward: 0,\\n            applyRelieveTime: 0,\\n            handleRelieveTime: 0\\n        });\\n\\n        User memory u = User({\\n            userAddr: _addr,\\n            avatar: \\\"\\\",\\n            email: \\\"\\\",\\n            isOnline: 1,\\n            userFlag: 0,\\n            credit: 0,\\n            regTime: block.timestamp,\\n            tradeStats: tradeStats,\\n            morgageStats: morgageStats\\n        });\\n        users[_addr] = u;\\n\\n        userList.push(u);\\n        userIndex[_addr] = userList.length - 1;\\n        emit addUser(_addr);\\n    }\\n\\n    function _updateInfo(\\n        address _addr,\\n        string memory _avatar,\\n        string memory _email,\\n        uint256 _isOnline\\n    ) internal {\\n        require(_addr != address(0), \\\"UserStorage: _addr null is not allowed\\\");\\n        require(\\n            users[_addr].userAddr != address(0),\\n            \\\"UserStorage: current User not exist\\\"\\n        );\\n\\n        User memory u = users[_addr];\\n        if (bytes(_avatar).length != 0) {\\n            u.avatar = _avatar;\\n        }\\n        if (bytes(_email).length != 0) {\\n            u.email = _email;\\n        }\\n\\n        if (_isOnline != uint256(0)) {\\n            u.isOnline = _isOnline;\\n        }\\n\\n        users[_addr] = u;\\n        userList[userIndex[_addr]] = u;\\n    }\\n\\n    function _updateTradeStats(\\n        address _addr,\\n        TradeStats memory _tradeStats,\\n        uint256 _credit\\n    ) internal {\\n        require(_addr != address(0), \\\"UserStorage: _addr null is not allowed\\\");\\n        require(\\n            users[_addr].userAddr != address(0),\\n            \\\"UserStorage: current User not exist\\\"\\n        );\\n\\n        User memory u = users[_addr];\\n\\n        u.credit = _credit;\\n\\n        u.tradeStats.tradeTotal = _tradeStats.tradeTotal;\\n\\n        u.tradeStats.restTotal = _tradeStats.restTotal;\\n\\n        users[_addr] = u;\\n        userList[userIndex[_addr]] = u;\\n    }\\n\\n    function _updateMorgageStats(\\n        address _addr,\\n        MorgageStats memory _morgageStats\\n    ) internal {\\n        require(_addr != address(0), \\\"UserStorage: _addr null is not allowed\\\");\\n        require(\\n            users[_addr].userAddr != address(0),\\n            \\\"UserStorage: current User not exist\\\"\\n        );\\n\\n        User memory u = users[_addr];\\n\\n        u.morgageStats.mortgage = _morgageStats.mortgage;\\n        u.morgageStats.freezeMortgage = _morgageStats.freezeMortgage;\\n        u.morgageStats.relieveMortgage = _morgageStats.relieveMortgage;\\n        u.morgageStats.inviteUserCount = _morgageStats.inviteUserCount;\\n        u.morgageStats.inviteUserReward = _morgageStats.inviteUserReward;\\n        u.morgageStats.applyRelieveTime = _morgageStats.applyRelieveTime;\\n        u.morgageStats.handleRelieveTime = _morgageStats.handleRelieveTime;\\n\\n        users[_addr] = u;\\n        userList[userIndex[_addr]] = u;\\n    }\\n\\n    function _search(address _addr) internal view returns (User memory user) {\\n        require(_addr != address(0), \\\"UserStorage: _addr null is not allowed\\\");\\n        require(\\n            users[_addr].userAddr != address(0),\\n            \\\"UserStorage: current User not exist\\\"\\n        );\\n\\n        User memory a = users[_addr];\\n        return a;\\n    }\\n\\n    function register() external payable {\\n        require(!isMemberOf(), \\\"has registed\\\");\\n\\n        if (feeAmount \\u003e 0) {\\n            require(recipient != address(0), \\\"recipient null is not allowed\\\");\\n            require(msg.value \\u003e= feeAmount, \\\"insufficient balance\\\");\\n            payable(recipient).transfer(feeAmount);\\n        }\\n        _insert(msg.sender);\\n    }\\n\\n    function isMemberOf() public view returns (bool) {\\n        return (users[msg.sender].userAddr != address(0));\\n    }\\n\\n    function updateInfo(\\n        string memory _avatar,\\n        string memory _email,\\n        uint256 _isOnline\\n    ) external onlyMemberOf {\\n        _updateInfo(msg.sender, _avatar, _email, _isOnline);\\n        emit updateUser(_avatar, _email, _isOnline);\\n    }\\n\\n    function updateTradeStats(\\n        address _addr,\\n        TradeStats memory _tradeStats,\\n        uint256 _credit\\n    ) public onlyAuthFromAddr {\\n        require(\\n            msg.sender == _restCAddr ||\\n                msg.sender == _orderCAddr ||\\n                msg.sender == _appealCAddr ||\\n                msg.sender == _recordCAddr,\\n            \\\"UserStorage:Invalid from contract address\\\"\\n        );\\n        _updateTradeStats(_addr, _tradeStats, _credit);\\n    }\\n\\n    function updateMorgageStats(\\n        address _addr,\\n        MorgageStats memory _morgageStats\\n    ) public onlyAuthFromAddr {\\n        require(\\n            msg.sender == _recordCAddr,\\n            \\\"UserStorage:Invalid from contract address\\\"\\n        );\\n        _updateMorgageStats(_addr, _morgageStats);\\n    }\\n\\n    function updateUserRole(address _addr, uint256 _userFlag)\\n        public\\n        onlyAuthFromAddr\\n    {\\n        require(\\n            msg.sender == _recordCAddr,\\n            \\\"UserStorage:Invalid from contract address\\\"\\n        );\\n        require(_addr != address(0), \\\"UserStorage: _addr null is not allowed\\\");\\n        require(\\n            users[_addr].userAddr != address(0),\\n            \\\"UserStorage: current User not exist\\\"\\n        );\\n\\n        require(_userFlag \\u003c= 3, \\\"UserStorage: Invalid userFlag 3\\\");\\n\\n        User memory u = users[_addr];\\n        u.userFlag = _userFlag;\\n        users[_addr] = u;\\n        userList[userIndex[_addr]] = u;\\n    }\\n\\n    function searchUser(address _addr)\\n        external\\n        view\\n        returns (User memory user)\\n    {\\n        return _search(_addr);\\n    }\\n\\n    function searchUserList() external view returns (User[] memory) {\\n        return userList;\\n    }\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_restType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_coinType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_currencyType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_restCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_payType\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"finishCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainderCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinMortgage\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restRemark\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restHash\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct RestStorage.RestDetail\",\"name\":\"_restDetail\",\"type\":\"tuple\"}],\"name\":\"RestAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_coinType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_currencyType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_restCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_payType\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"finishCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainderCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinMortgage\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restRemark\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restHash\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct RestStorage.RestDetail\",\"name\":\"_restDetail\",\"type\":\"tuple\"}],\"name\":\"RestUpdate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_coinType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_currencyType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_restCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_payType\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"finishCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainderCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinMortgage\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restRemark\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restHash\",\"type\":\"string\"}],\"internalType\":\"struct RestStorage.RestDetail\",\"name\":\"_restDetail\",\"type\":\"tuple\"}],\"name\":\"addBuyRest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_remainCount\",\"type\":\"uint256\"}],\"name\":\"addRestRemainCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_coinType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_currencyType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_restCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_restFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_payType\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"finishCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainderCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinMortgage\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restRemark\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restHash\",\"type\":\"string\"}],\"internalType\":\"struct RestStorage.RestDetail\",\"name\":\"_restDetail\",\"type\":\"tuple\"}],\"name\":\"addSellRest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recordAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orderAddr\",\"type\":\"address\"}],\"name\":\"authFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"}],\"name\":\"cancelBuyRest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"}],\"name\":\"cancelSellRest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"feeAddrSet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"feeAmountSet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"}],\"name\":\"getRestFrozenTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"}],\"name\":\"searchRest\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"restNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"coinType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currencyType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"payType\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"restStatus\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"finishCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainderCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinMortgage\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restRemark\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restHash\",\"type\":\"string\"}],\"internalType\":\"struct RestStorage.RestDetail\",\"name\":\"restDetail\",\"type\":\"tuple\"}],\"internalType\":\"struct RestStorage.Rest\",\"name\":\"rest\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"searchRestList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"restNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"coinType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currencyType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"payType\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"restStatus\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"finishCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainderCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinMortgage\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restRemark\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restHash\",\"type\":\"string\"}],\"internalType\":\"struct RestStorage.RestDetail\",\"name\":\"restDetail\",\"type\":\"tuple\"}],\"internalType\":\"struct RestStorage.Rest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_method\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_restStatus\",\"type\":\"uint256\"}],\"name\":\"startOrStop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_coinType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_currencyType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_addCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_restFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_payType\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"finishCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainderCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitAmountTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitMinMortgage\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restRemark\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"restTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"restHash\",\"type\":\"string\"}],\"internalType\":\"struct RestStorage.RestDetail\",\"name\":\"_restDetail\",\"type\":\"tuple\"}],\"name\":\"updateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_restNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_finishCount\",\"type\":\"uint256\"}],\"name\":\"updateRestFinishCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RestStorage", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f57ce74f151eff866994058b1c195cdabe80cddf9a82952c7efea2a4cb7be713"}