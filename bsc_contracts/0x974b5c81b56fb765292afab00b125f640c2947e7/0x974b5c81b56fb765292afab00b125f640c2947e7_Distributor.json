{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/StakingDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/ITreasury.sol\\\";\\nimport \\\"./interfaces/IStaking.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\n\\nimport \\\"./types/OlympusAccessControlled.sol\\\";\\n\\n/// @notice Updated distributor adds the ability to mint and sync\\n///         into Uniswap V2-style liquidity pools, removing the\\n///         opportunity-cost dilemma of providing liquidity for\\n///         BOHM, as well as patches a small bug in the staking contract\\n///         that pulls forward an amount of the next epoch rewards. Note that\\n///         this implementation bases staking reward distributions on staked supply.\\ncontract Distributor is OlympusAccessControlled {\\n    error No_Rebase_Occurred();\\n    error Only_Staking();\\n    error Not_Unlocked();\\n    error Sanity_Check();\\n    error Adjustment_Limit();\\n    error Adjustment_Underflow();\\n    error Not_Permissioned();\\n\\n    struct Adjust {\\n        bool add; // whether to add or subtract from the reward rate\\n        uint256 rate; // the amount to add or subtract per epoch\\n        uint256 target; // the resulting reward rate\\n    }\\n\\n    /* ====== VARIABLES ====== */\\n\\n    /// The BOHM Token\\n    IERC20 private immutable bohm;\\n    /// The Olympus Treasury\\n    ITreasury private immutable treasury;\\n    /// The BOHM Staking Contract\\n    address private immutable staking;\\n\\n    /// The % to increase balances per epoch\\n    uint256 public rewardRate;\\n    /// Liquidity pools to receive rewards\\n    address[] public pools;\\n\\n    /// Information about adjusting reward rate\\n    Adjust public adjustment;\\n    /// A bounty for keepers to call the triggerRebase() function\\n    uint256 public bounty;\\n\\n    uint256 private constant DENOMINATOR = 1_000_000;\\n\\n    constructor(\\n        ITreasury _treasury,\\n        IERC20 _bohm,\\n        address _staking,\\n        IOlympusAuthority _authority,\\n        uint256 _initialRate\\n    ) OlympusAccessControlled(_authority) {\\n        treasury = _treasury;\\n        bohm = _bohm;\\n        staking = _staking;\\n        rewardRate = _initialRate;\\n    }\\n\\n    /* ====== PUBLIC FUNCTIONS ====== */\\n\\n    /// @notice Patch to trigger rebases via distributor. There is an error in Staking's\\n    ///         `stake` function which pulls forward part of the rebase for the next epoch.\\n    ///         This patch triggers a rebase by calling unstake (which does not have the issue).\\n    ///         The patch also restricts `distribute` to only be able to be called from a tx\\n    ///         originating this function.\\n\\n    bool private unlockRebase; // restricts distribute() to only this call\\n\\n    function triggerRebase() external {\\n        unlockRebase = true;\\n        IStaking(staking).unstake(msg.sender, 0, true, true); // Give the caller the bounty bohm.\\n        if (unlockRebase) revert No_Rebase_Occurred();\\n    }\\n\\n    /* ====== GUARDED FUNCTIONS ====== */\\n\\n    /// @notice send epoch reward to staking contract\\n    function distribute() external {\\n        if (msg.sender != staking) revert Only_Staking();\\n        if (!unlockRebase) revert Not_Unlocked();\\n\\n        treasury.mint(staking, nextRewardFor(staking));\\n\\n        // mint to pools and sync\\n        //\\n        // this removes opportunity cost for liquidity providers by\\n        // sending rebase rewards directly into the liquidity pool\\n        //\\n        // note that this does not add additional emissions (user could\\n        // be staked instead and get the same tokens)\\n\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            address pool = pools[i];\\n            if (pool != address(0)) {\\n                treasury.mint(pool, nextRewardFor(pool));\\n                IUniswapV2Pair(pool).sync();\\n            }\\n        }\\n\\n        if (adjustment.rate != 0) {\\n            adjust();\\n        }\\n\\n        unlockRebase = false;\\n    }\\n\\n    function retrieveBounty() external returns (uint256) {\\n        if (msg.sender != staking) revert Only_Staking();\\n        // If the distributor bounty is > 0, mint it for the staking contract.\\n        if (bounty > 0) {\\n            treasury.mint(staking, bounty);\\n        }\\n\\n        return bounty;\\n    }\\n\\n    /* ====== INTERNAL FUNCTIONS ====== */\\n\\n    /// @notice increment reward rate for collector\\n    function adjust() internal {\\n        if (adjustment.add) {\\n            // if rate should increase\\n            rewardRate += adjustment.rate; // raise rate\\n            if (rewardRate >= adjustment.target) {\\n                // if target met\\n                adjustment.rate = 0; // turn off adjustment\\n                rewardRate = adjustment.target; // set to target\\n            }\\n        } else {\\n            // if rate should decrease\\n            if (rewardRate > adjustment.rate) {\\n                // protect from underflow\\n                rewardRate -= adjustment.rate; // lower rate\\n            } else {\\n                rewardRate = 0;\\n            }\\n\\n            if (rewardRate <= adjustment.target) {\\n                // if target met\\n                adjustment.rate = 0; // turn off adjustment\\n                rewardRate = adjustment.target; // set to target\\n            }\\n        }\\n    }\\n\\n    /* ====== VIEW FUNCTIONS ====== */\\n\\n    /// @notice view function for next reward for an address\\n    function nextRewardFor(address who) public view returns (uint256) {\\n        return (bohm.balanceOf(who) * rewardRate) / DENOMINATOR;\\n    }\\n\\n    /* ====== POLICY FUNCTIONS ====== */\\n\\n    /// @notice set bounty to incentivize keepers\\n    function setBounty(uint256 _bounty) external onlyGovernor {\\n        bounty = _bounty;\\n    }\\n\\n    /// @notice sets the liquidity pools for mint and sync\\n    /// @dev    note that this overwrites the entire list (!!)\\n    function setPools(address[] calldata _pools) external onlyGovernor {\\n        pools = _pools;\\n    }\\n\\n    /// @notice removes a pool from the list\\n    function removePool(uint256 index, address pool) external onlyGovernor {\\n        if (pools[index] != pool) revert Sanity_Check();\\n        pools[index] = address(0);\\n    }\\n\\n    /// @notice adds a pool to the list\\n    /// @dev    note you should find an empty slot offchain before calling\\n    /// @dev    if there are no empty slots, pass in an occupied index to push\\n    function addPool(uint256 index, address pool) external onlyGovernor {\\n        // we want to overwrite slots where possible\\n        if (pools[index] == address(0)) {\\n            pools[index] = pool;\\n        } else {\\n            // if the passed in slot is not empty, push to the end\\n            pools.push(pool);\\n        }\\n    }\\n\\n    /// @notice set adjustment info for a collector's reward rate\\n    function setAdjustment(bool _add, uint256 _rate, uint256 _target) external {\\n        if (msg.sender != authority.governor() && msg.sender != authority.guardian()) revert Not_Permissioned();\\n        if (msg.sender == authority.guardian() && _rate > (rewardRate * 25) / 1000) revert Adjustment_Limit();\\n        if (!_add && _rate > rewardRate) revert Adjustment_Underflow();\\n\\n        adjustment = Adjust({add: _add, rate: _rate, target: _target});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IStaking {\\n    function stake(\\n        address _to,\\n        uint256 _amount,\\n        bool _rebasing,\\n        bool _claim\\n    ) external returns (uint256);\\n\\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\\n\\n    function forfeit() external returns (uint256);\\n\\n    function toggleLock() external;\\n\\n    function unstake(\\n        address _to,\\n        uint256 _amount,\\n        bool _trigger,\\n        bool _rebasing\\n    ) external returns (uint256);\\n\\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\\n\\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\\n\\n    function rebase() external;\\n\\n    function index() external view returns (uint256);\\n\\n    function contractBalance() external view returns (uint256);\\n\\n    function totalStaked() external view returns (uint256);\\n\\n    function supplyInWarmup() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IUniswapV2ERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./IUniswapV2ERC20.sol\\\";\\n\\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\\n    function token0() external pure returns (address);\\n\\n    function token1() external pure returns (address);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function sync() external;\\n}\\n\"\r\n    },\r\n    \"contracts/types/OlympusAccessControlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nabstract contract OlympusAccessControlled {\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\\n\\n    string UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyGovernor() {\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyGuardian() {\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyPolicy() {\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_bohm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_authority\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialRate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Adjustment_Limit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Adjustment_Underflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"No_Rebase_Occurred\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Not_Permissioned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Not_Unlocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Only_Staking\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Sanity_Check\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adjustment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bounty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"nextRewardFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"removePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieveBounty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_add\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"}],\"name\":\"setAdjustment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bounty\",\"type\":\"uint256\"}],\"name\":\"setBounty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"}],\"name\":\"setPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Distributor", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "0000000000000000000000006fc07db5aded89ccc01fd9452095763ee8d6fbc5000000000000000000000000ae6edd5151cfd8fb1a2bf8de29cc4b2d7f5b4a4f000000000000000000000000cfb7cebf71de3d55557fd23fd4298406efc1e4f700000000000000000000000026f0d4bf62306d36d67647d85dad4967f4bd725700000000000000000000000000000000000000000000000000000000000030d4", "EVMVersion": "london", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}