{"SourceCode": "// SPDX-License-Identifier: MIT OR Apache-2.0\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\r\n *\r\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\r\n * stuck.\r\n *\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File: contracts/LPStaking.sol\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n\r\n\r\ninterface IERC20Contract {\r\n    // External ERC20 contract\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function balanceOf(address tokenOwner) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n * LPStaking smart contract Liqidity Pool Token or LOA token staking\r\n * Initialization: call setRewardsPerSecond() function to set rewards for second\r\n * updateWithdrawalFee() to set withdrawal fees. It accepts values in days[] and fee[]. fee value provided in 1/10th of percentage.\r\n * stake() to stake Token\r\n * unstake() to unstake Token\r\n */\r\ncontract LPStaking is ReentrancyGuard {\r\n\r\n    IERC20Contract public _loaToken;\r\n    IERC20Contract public _stakeToken;\r\n    mapping(address=> uint8) private _admins;\r\n    address private _treasury;\r\n\r\n    constructor(address loaContract, address stakeContract) {\r\n        _admins[msg.sender] = 1;\r\n        _loaToken = IERC20Contract(loaContract);\r\n        if(loaContract == stakeContract)\r\n            _stakeToken = _loaToken;\r\n        else \r\n            _stakeToken = IERC20Contract(stakeContract);\r\n    }\r\n\r\n    address[] public _stakers;\r\n    uint256[] public _withdrawDays;\r\n    uint256[] public _withdrawFee;\r\n    mapping(address => uint256) public _tokenStaked;\r\n    mapping(address => uint256) public _tokenStakedAt;\r\n\r\n    mapping(address => uint256) public _rewardTallyBefore;\r\n    uint256 public _rewardPerTokenCumulative;\r\n\r\n    uint256 public _rewardDistributedLast;\r\n    uint256 public _rewardPerSec;\r\n    uint256 public _totalStakes;\r\n\r\n    uint256 private _lastMajorWithdrawReported;\r\n    uint256 private _lastAmountWithdrawn;\r\n    bool public _withdrawBlocked;\r\n    uint256 public _withdrawLimitPercent;\r\n    uint256  public MULTIPLIER = 1_000_000_000_000;\r\n\r\n\r\n    event Staked(\r\n        address owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event Withdrawn(\r\n        address owner,\r\n        uint256 amount,\r\n        uint256 fees\r\n    );\r\n\r\n    event RewardClaimed(\r\n        address owner,\r\n        uint256 amount\r\n    );\r\n\r\n    modifier validAdmin() {\r\n        require(_admins[msg.sender] == 1, \"You are not authorized.\");\r\n        _;\r\n    }\r\n\r\n    function addAdmin(address newAdmin) validAdmin public {\r\n        _admins[newAdmin] = 1;\r\n    }\r\n\r\n    function removeAdmin(address oldAdmin) validAdmin public {\r\n        delete _admins[oldAdmin];\r\n    }\r\n\r\n    function setTresury(address treasury) validAdmin public {\r\n        _treasury = treasury;\r\n    }\r\n\r\n    function setRewardsPerSecond(uint256 rewardPerSec) validAdmin public {\r\n        _rewardPerSec = rewardPerSec;\r\n    }\r\n\r\n    function setWithdrawConstraints(uint256 withdrawLimitPercent) validAdmin public {\r\n        _withdrawLimitPercent = withdrawLimitPercent;\r\n    }\r\n\r\n    function removeWithdrawRestriction() validAdmin public {\r\n        _withdrawBlocked = false;\r\n    }\r\n\r\n    function updateWithdrawalFee(uint256[] memory dayList, uint256[] memory fees) validAdmin public {\r\n        require(dayList.length + 1 == fees.length, \"Data length is incorrected.\");\r\n\r\n        for(uint256 i = 0; i < _withdrawDays.length; i++) {\r\n            _withdrawDays.pop();\r\n            _withdrawFee.pop();\r\n        }\r\n        for(uint256 i = 0; i < dayList.length; i++) {\r\n            if(i > 0) {\r\n                require(dayList[i] < dayList[i - 1], \"Data provided should be in descending order.\");\r\n            }\r\n            _withdrawDays.push(dayList[i]);\r\n            _withdrawFee.push(fees[i]);\r\n        }\r\n        _withdrawFee.push(fees[fees.length - 1]);\r\n    }\r\n\r\n    function claimRewards() public {\r\n        require(_tokenStaked[msg.sender] > 0, \"User has not staked.\");\r\n\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 secs = currentTime - _rewardDistributedLast;\r\n        uint256 rewards = _tokenStaked[msg.sender] * (_rewardPerTokenCumulative - _rewardTallyBefore[msg.sender]) / MULTIPLIER \r\n                +   (_rewardPerSec * secs * _tokenStaked[msg.sender] / _totalStakes);\r\n\r\n        _loaToken.transfer(msg.sender, rewards);\r\n\r\n        _rewardPerTokenCumulative = _rewardPerTokenCumulative + (_rewardPerSec * secs * MULTIPLIER / _totalStakes);\r\n        _rewardDistributedLast = currentTime;\r\n\r\n        _rewardTallyBefore[msg.sender] = _rewardPerTokenCumulative;\r\n        emit RewardClaimed(msg.sender, rewards);\r\n    }\r\n\r\n    function myRewards(address owner) public view returns(uint256, uint256, uint256) {\r\n        if(_tokenStaked[owner] == 0) {\r\n            return (0, _rewardDistributedLast, 0);\r\n        }\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 secs = currentTime - _rewardDistributedLast;\r\n        \r\n        uint256 rewards = (_tokenStaked[owner] * (_rewardPerTokenCumulative - _rewardTallyBefore[owner])) / MULTIPLIER\r\n                +   (_rewardPerSec * secs * _tokenStaked[owner] / _totalStakes);\r\n            \r\n        return (rewards, _rewardDistributedLast, ((_tokenStaked[owner]* _rewardPerSec)/ _totalStakes));\r\n    }\r\n\r\n    function stake(uint256 amount) public {\r\n        require(_rewardPerSec > 0, \"There is no rewards allocated\");\r\n        require(_stakeToken.balanceOf(msg.sender) >= amount, \"Unavailable balance.\");\r\n\r\n        uint256 currentTime = block.timestamp;\r\n\r\n        uint256 secs = _rewardDistributedLast == 0 ? 0 : (currentTime - _rewardDistributedLast);\r\n\r\n        if(_tokenStaked[msg.sender] > 0 ) {\r\n            uint256 rewards = (_tokenStaked[msg.sender] * (_rewardPerTokenCumulative - _rewardTallyBefore[msg.sender])) / MULTIPLIER\r\n                +   (_rewardPerSec * secs * _tokenStaked[msg.sender] / _totalStakes);\r\n            \r\n            require(_loaToken.transfer(msg.sender, rewards), \"Not enough LOA balance available to transfer rewards\");\r\n        }\r\n\r\n        require(_stakeToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\r\n\r\n        _tokenStakedAt[msg.sender] = currentTime;\r\n        _totalStakes = _totalStakes + amount;\r\n        _tokenStaked[msg.sender] = _tokenStaked[msg.sender] + amount;\r\n        _rewardPerTokenCumulative = _rewardPerTokenCumulative + (_rewardPerSec * secs * MULTIPLIER / _totalStakes);\r\n        _rewardDistributedLast = currentTime;\r\n        _rewardTallyBefore[msg.sender] = _rewardPerTokenCumulative;\r\n    }\r\n\r\n    function unstake(uint256 withdrawAmount) public {\r\n        require(_tokenStaked[msg.sender] >= withdrawAmount, \"Unavailable balance.\");\r\n\r\n        uint256 secs = block.timestamp - _rewardDistributedLast;\r\n        uint256 tokenStaked = _tokenStaked[msg.sender];\r\n        if(tokenStaked > 0 && _rewardPerSec > 0) {\r\n            uint256 rewards = (tokenStaked * (_rewardPerTokenCumulative- _rewardTallyBefore[msg.sender])) / MULTIPLIER\r\n                +   (_rewardPerSec * secs * tokenStaked/ _totalStakes);\r\n            \r\n            require(_loaToken.transfer(msg.sender, rewards), \"Not enough LOA balance available to transfer rewards\");\r\n        }\r\n\r\n        unstakeWithoutRewards(withdrawAmount);\r\n    }\r\n\r\n    function unstakeWithoutRewards(uint256 withdrawAmount) public {\r\n        require(_withdrawBlocked == false, \"Withdraw is blocked.\");\r\n        require(_tokenStaked[msg.sender] >= withdrawAmount, \"Unavailable balance.\");\r\n\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 secs = currentTime - _rewardDistributedLast;\r\n\r\n        uint256 daysElapsed = (currentTime - _tokenStakedAt[msg.sender]) / 86400;\r\n\r\n        uint256 deduction = _withdrawFee.length > 0 ? _withdrawFee[_withdrawFee.length - 1] : 0;\r\n        for(uint256 i = 0; i < _withdrawDays.length; i++) {\r\n            if(daysElapsed >= _withdrawDays[i]) {\r\n                deduction = _withdrawFee[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint256 amount = withdrawAmount;\r\n\r\n        if(deduction > 0) {\r\n            amount -= ((deduction* withdrawAmount)/ 1000);\r\n        }\r\n\r\n        require(_stakeToken.transfer(msg.sender, amount), \"Transfer failed\");\r\n        //transfer fees to treasury\r\n        if(withdrawAmount - amount > 0) {\r\n            _stakeToken.transfer(_treasury, withdrawAmount - amount);\r\n        }\r\n\r\n        _totalStakes = _totalStakes - withdrawAmount;\r\n        _tokenStaked[msg.sender] = _tokenStaked[msg.sender] - withdrawAmount;\r\n        _rewardPerTokenCumulative = _totalStakes > 0 ? (_rewardPerTokenCumulative + (_rewardPerSec * secs * MULTIPLIER / _totalStakes)) : 0;\r\n        _rewardDistributedLast = currentTime;\r\n\r\n        if(_tokenStaked[msg.sender] > 0) \r\n            _rewardTallyBefore[msg.sender] = _rewardPerTokenCumulative;\r\n        else {\r\n            delete _rewardTallyBefore[msg.sender];\r\n            delete _tokenStakedAt[msg.sender];\r\n        }\r\n\r\n        // If amount withdrawn in last 1 hr is more than allowed percentage of total stakes then withdraw is blocked.\r\n        if(_lastMajorWithdrawReported < currentTime - 3600) {\r\n            _lastMajorWithdrawReported = currentTime;\r\n            _lastAmountWithdrawn = withdrawAmount;\r\n        } else {\r\n            _lastAmountWithdrawn += withdrawAmount;\r\n        }\r\n        if(_totalStakes > 0 && _withdrawLimitPercent > 0 && (_lastAmountWithdrawn * 10000 / _totalStakes) > _withdrawLimitPercent) {\r\n            _withdrawBlocked = true;\r\n        }\r\n    }\r\n\r\n\r\n    function withdraw() validAdmin public {\r\n        uint256 balance = _stakeToken.balanceOf(address(this)) - _totalStakes;\r\n        _stakeToken.transfer(_treasury, balance);\r\n        if(_stakeToken != _loaToken)\r\n            _loaToken.transfer(_treasury, _loaToken.balanceOf(address(this)));\r\n    } \r\n\r\n    function extract(address tokenAddress) validAdmin public {\r\n        if (tokenAddress == address(0)) {\r\n            payable(_treasury).transfer(address(this).balance);\r\n            return;\r\n        }\r\n\r\n        IERC20Contract token = IERC20Contract(tokenAddress);\r\n        require(token != _stakeToken && token != _loaToken, \"Invalid token address\");\r\n        token.transfer(_treasury, token.balanceOf(address(this)));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loaContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakeContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_loaToken\",\"outputs\":[{\"internalType\":\"contract IERC20Contract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardDistributedLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardPerSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardPerTokenCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rewardTallyBefore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_stakeToken\",\"outputs\":[{\"internalType\":\"contract IERC20Contract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_tokenStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_tokenStakedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_withdrawBlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_withdrawDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_withdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_withdrawLimitPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"extract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"myRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeWithdrawRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardPerSec\",\"type\":\"uint256\"}],\"name\":\"setRewardsPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"setTresury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawLimitPercent\",\"type\":\"uint256\"}],\"name\":\"setWithdrawConstraints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"unstakeWithoutRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"dayList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"}],\"name\":\"updateWithdrawalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LPStaking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000094b69263fca20119ae817b6f783fc0f13b02ad5000000000000000000000000094b69263fca20119ae817b6f783fc0f13b02ad50", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0de37eacf72d3faf16d2af5cb918513e476571dc5acbf7925ada3a3367e1a676"}