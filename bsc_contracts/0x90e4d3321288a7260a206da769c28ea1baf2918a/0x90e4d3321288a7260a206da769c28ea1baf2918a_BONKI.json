{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at BscScan.com on 2023-12-29\\n */\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function name() external view returns (string memory);\\n\\n  function getOwner() external view returns (address);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IFactoryV2 {\\n  event PairCreated(address indexed token0, address indexed token1, address lpPair, uint);\\n\\n  function getPair(address tokenA, address tokenB) external view returns (address lpPair);\\n\\n  function createPair(address tokenA, address tokenB) external returns (address lpPair);\\n}\\n\\ninterface IV2Pair {\\n  function factory() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n  function sync() external;\\n}\\n\\ninterface IRouter01 {\\n  function factory() external pure returns (address);\\n\\n  function WETH() external pure returns (address);\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n  function swapExactETHForTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function getAmountsOut(\\n    uint amountIn,\\n    address[] calldata path\\n  ) external view returns (uint[] memory amounts);\\n\\n  function getAmountsIn(\\n    uint amountOut,\\n    address[] calldata path\\n  ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IRouter02 is IRouter01 {\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable;\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n}\\n\\ninterface Initializer {\\n  function setLaunch(\\n    address _initialLpPair,\\n    uint32 _liqAddBlock,\\n    uint64 _liqAddStamp,\\n    uint8 dec\\n  ) external;\\n\\n  function getConfig() external returns (address, address);\\n\\n  function getInits(uint256 amount) external returns (uint256, uint256);\\n\\n  function setLpPair(address pair, bool enabled) external;\\n\\n  function checkUser(address from, address to, uint256 amt) external returns (bool);\\n\\n  function setProtections(bool _as, bool _ab) external;\\n\\n  function removeSniper(address account) external;\\n}\\n\\ncontract BONKI is IERC20 {\\n  mapping(address => uint256) private _tOwned;\\n  mapping(address => bool) public lpPairs;\\n  uint256 private timeSinceLastPair = 0;\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n  mapping(address => bool) private _liquidityHolders;\\n  mapping(address => bool) private _isExcludedFromProtection;\\n  mapping(address => bool) private _isExcludedFromFees;\\n  mapping(address => bool) private presaleAddresses;\\n  bool private allowedPresaleExclusion = true;\\n\\n  uint256 private constant startingSupply = 100_000_000_000_000;\\n  string private constant _name = 'BONKI';\\n  string private constant _symbol = 'BONKI';\\n  uint8 private constant _decimals = 9;\\n  uint256 private constant _tTotal = startingSupply * 10 ** _decimals;\\n\\n  struct Fees {\\n    uint16 buyFee;\\n    uint16 sellFee;\\n    uint16 transferFee;\\n  }\\n\\n  struct Ratios {\\n    uint16 liquidity;\\n    uint16 marketing;\\n    uint16 buyback;\\n    uint16 totalSwap;\\n  }\\n\\n  Fees public _taxRates = Fees({ buyFee: 300, sellFee: 300, transferFee: 0 });\\n\\n  Ratios public _ratios = Ratios({ liquidity: 0, marketing: 3, buyback: 0, totalSwap: 3 });\\n\\n  uint256 public constant maxBuyTaxes = 1000;\\n  uint256 public constant maxSellTaxes = 1000;\\n  uint256 public constant maxTransferTaxes = 1000;\\n  uint256 public constant masterTaxDivisor = 10000;\\n\\n  bool public taxesAreLocked;\\n  IRouter02 public dexRouter;\\n  address public lpPair;\\n  address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n  struct TaxWallets {\\n    address payable marketing;\\n    address payable buyback;\\n  }\\n\\n  TaxWallets public _taxWallets =\\n    TaxWallets({\\n      marketing: payable(0x9Acb94171A5C4fAcba6f9E4769e187D8aB41d2CD),\\n      buyback: payable(0x9Acb94171A5C4fAcba6f9E4769e187D8aB41d2CD)\\n    });\\n\\n  bool public inSwap;\\n  bool public contractSwapEnabled = false;\\n  uint256 public swapThreshold;\\n  uint256 public swapAmount;\\n  bool public piContractSwapsEnabled;\\n  uint256 public piSwapPercent = 10;\\n  bool public tradingEnabled = false;\\n  bool public _hasLiqBeenAdded = false;\\n  Initializer initializer;\\n  uint256 public launchStamp;\\n\\n  event ContractSwapEnabledUpdated(bool enabled);\\n  event AutoLiquify(uint256 amountCurrency, uint256 amountTokens);\\n  event SetInitializer(address init);\\n\\n  modifier inSwapFlag() {\\n    inSwap = true;\\n    _;\\n    inSwap = false;\\n  }\\n\\n  constructor() {\\n    // Set the owner.\\n    _owner = 0x6E5c933bD0d57368B9959fd48e1ED2BF11cD00FD;\\n\\n    _tOwned[_owner] = _tTotal;\\n    emit Transfer(address(0), _owner, _tTotal);\\n\\n    _isExcludedFromFees[_owner] = true;\\n    _isExcludedFromFees[address(this)] = true;\\n    _isExcludedFromFees[DEAD] = true;\\n    _liquidityHolders[_owner] = true;\\n\\n    _isExcludedFromFees[0x407993575c91ce7643a4d4cCACc9A98c36eE1BBE] = true; // PinkLock\\n    _isExcludedFromFees[0x556B9306565093C855AEA9AE92A594704c2Cd59e] = true; // Masterchef v3\\n    _isExcludedFromFees[0x13f4EA83D0bd40E75C8222255bc855a974568Dd4] = true; // Router v3\\n  }\\n\\n  //===============================================================================================================\\n  //===============================================================================================================\\n  //===============================================================================================================\\n  // Ownable removed as a lib and added here to allow for custom transfers and renouncements.\\n  // This allows for removal of ownership privileges from the owner once renounced or transferred.\\n\\n  address public _owner;\\n\\n  modifier onlyOwner() {\\n    require(_owner == msg.sender, 'Caller =/= owner.');\\n    _;\\n  }\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  function transferOwner(address newOwner) external onlyOwner {\\n    require(\\n      newOwner != address(0),\\n      'Call renounceOwnership to transfer owner to the zero address.'\\n    );\\n    require(newOwner != DEAD, 'Call renounceOwnership to transfer owner to the zero address.');\\n    setExcludedFromFees(_owner, false);\\n    setExcludedFromFees(newOwner, true);\\n\\n    if (balanceOf(_owner) > 0) {\\n      finalizeTransfer(_owner, newOwner, balanceOf(_owner), false, false, true);\\n    }\\n\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n\\n  function renounceOwnership() external onlyOwner {\\n    require(tradingEnabled, 'Cannot renounce until trading has been enabled.');\\n    setExcludedFromFees(_owner, false);\\n    address oldOwner = _owner;\\n    _owner = address(0);\\n    emit OwnershipTransferred(oldOwner, address(0));\\n  }\\n\\n  receive() external payable {}\\n\\n  function totalSupply() external pure override returns (uint256) {\\n    return _tTotal;\\n  }\\n\\n  function decimals() external pure override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function symbol() external pure override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function name() external pure override returns (string memory) {\\n    return _name;\\n  }\\n\\n  function getOwner() external view override returns (address) {\\n    return _owner;\\n  }\\n\\n  function allowance(address holder, address spender) external view override returns (uint256) {\\n    return _allowances[holder][spender];\\n  }\\n\\n  function balanceOf(address account) public view override returns (uint256) {\\n    return _tOwned[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\\n    _transfer(msg.sender, recipient, amount);\\n    return true;\\n  }\\n\\n  function approve(address spender, uint256 amount) external override returns (bool) {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function _approve(address sender, address spender, uint256 amount) internal {\\n    require(sender != address(0), 'ERC20: Zero Address');\\n    require(spender != address(0), 'ERC20: Zero Address');\\n\\n    _allowances[sender][spender] = amount;\\n    emit Approval(sender, spender, amount);\\n  }\\n\\n  function approveContractContingency() external onlyOwner returns (bool) {\\n    _approve(address(this), address(dexRouter), type(uint256).max);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external override returns (bool) {\\n    if (_allowances[sender][msg.sender] != type(uint256).max) {\\n      _allowances[sender][msg.sender] -= amount;\\n    }\\n    return _transfer(sender, recipient, amount);\\n  }\\n\\n  function setNewRouter(address newRouter) internal {\\n    require(!_hasLiqBeenAdded);\\n    IRouter02 _newRouter = IRouter02(newRouter);\\n    address get_pair = IFactoryV2(_newRouter.factory()).getPair(address(this), _newRouter.WETH());\\n    lpPairs[lpPair] = false;\\n    if (get_pair == address(0)) {\\n      lpPair = IFactoryV2(_newRouter.factory()).createPair(address(this), _newRouter.WETH());\\n    } else {\\n      lpPair = get_pair;\\n    }\\n    dexRouter = _newRouter;\\n    lpPairs[lpPair] = true;\\n    _approve(address(this), address(dexRouter), type(uint256).max);\\n  }\\n\\n  function setLpPair(address pair, bool enabled) external onlyOwner {\\n    if (!enabled) {\\n      lpPairs[pair] = false;\\n      initializer.setLpPair(pair, false);\\n    } else {\\n      if (timeSinceLastPair != 0) {\\n        require(block.timestamp - timeSinceLastPair > 3 days, '3 Day cooldown.');\\n      }\\n      require(!lpPairs[pair], 'Pair already added to list.');\\n      lpPairs[pair] = true;\\n      timeSinceLastPair = block.timestamp;\\n      initializer.setLpPair(pair, true);\\n    }\\n  }\\n\\n  function setInitializer(address init) public onlyOwner {\\n    require(init != address(this), \\\"Can't be self.\\\");\\n    initializer = Initializer(init);\\n    try initializer.getConfig() returns (address router, address constructorLP) {\\n      dexRouter = IRouter02(router);\\n      lpPair = constructorLP;\\n      lpPairs[lpPair] = true;\\n      _approve(_owner, address(dexRouter), type(uint256).max);\\n      _approve(address(this), address(dexRouter), type(uint256).max);\\n    } catch {\\n      revert();\\n    }\\n    emit SetInitializer(init);\\n  }\\n\\n  function isExcludedFromFees(address account) external view returns (bool) {\\n    return _isExcludedFromFees[account];\\n  }\\n\\n  function setExcludedFromFees(address account, bool enabled) public onlyOwner {\\n    _isExcludedFromFees[account] = enabled;\\n  }\\n\\n  function isExcludedFromProtection(address account) external view returns (bool) {\\n    return _isExcludedFromProtection[account];\\n  }\\n\\n  function setExcludedFromProtection(address account, bool enabled) external onlyOwner {\\n    _isExcludedFromProtection[account] = enabled;\\n  }\\n\\n  function getCirculatingSupply() public view returns (uint256) {\\n    return (_tTotal - (balanceOf(DEAD) + balanceOf(address(0))));\\n  }\\n\\n  function removeSniper(address account) external onlyOwner {\\n    initializer.removeSniper(account);\\n  }\\n\\n  function setProtectionSettings(bool _antiSnipe, bool _antiBlock) external onlyOwner {\\n    initializer.setProtections(_antiSnipe, _antiBlock);\\n  }\\n\\n  function lockTaxes() external onlyOwner {\\n    // This will lock taxes at their current value forever, do not call this unless you're sure.\\n    taxesAreLocked = true;\\n  }\\n\\n  function setTaxes(uint16 buyFee, uint16 sellFee, uint16 transferFee) external onlyOwner {\\n    require(!taxesAreLocked, 'Taxes are locked.');\\n    require(\\n      buyFee <= maxBuyTaxes && sellFee <= maxSellTaxes && transferFee <= maxTransferTaxes,\\n      'Cannot exceed maximums.'\\n    );\\n    _taxRates.buyFee = buyFee;\\n    _taxRates.sellFee = sellFee;\\n    _taxRates.transferFee = transferFee;\\n  }\\n\\n  function setRatios(uint16 marketing, uint16 liquidity, uint16 buyback) external onlyOwner {\\n    _ratios.buyback = buyback;\\n    _ratios.liquidity = liquidity;\\n    _ratios.marketing = marketing;\\n    _ratios.totalSwap = liquidity + marketing + buyback;\\n    uint256 total = _taxRates.buyFee + _taxRates.sellFee;\\n    require(_ratios.totalSwap <= total, 'Cannot exceed sum of buy and sell fees.');\\n  }\\n\\n  function setWallets(address payable marketing, address payable buyback) external onlyOwner {\\n    require(marketing != address(0) && buyback != address(0), 'Cannot be zero address.');\\n    _taxWallets.marketing = payable(marketing);\\n    _taxWallets.buyback = payable(buyback);\\n    require(!isContract(marketing));\\n    require(!isContract(buyback));\\n  }\\n\\n  function isContract(address account) internal view returns (bool) {\\n    return account.code.length > 0;\\n  }\\n\\n  function getTokenAmountAtPriceImpact(\\n    uint256 priceImpactInHundreds\\n  ) external view returns (uint256) {\\n    return ((balanceOf(lpPair) * priceImpactInHundreds) / masterTaxDivisor);\\n  }\\n\\n  function setSwapSettings(\\n    uint256 thresholdPercent,\\n    uint256 thresholdDivisor,\\n    uint256 amountPercent,\\n    uint256 amountDivisor\\n  ) external onlyOwner {\\n    swapThreshold = (_tTotal * thresholdPercent) / thresholdDivisor;\\n    swapAmount = (_tTotal * amountPercent) / amountDivisor;\\n    require(swapThreshold <= swapAmount, 'Threshold cannot be above amount.');\\n    require(\\n      swapAmount <= (balanceOf(lpPair) * 150) / masterTaxDivisor,\\n      'Cannot be above 1.5% of current PI.'\\n    );\\n    require(swapAmount >= _tTotal / 1_000_000, 'Cannot be lower than 0.00001% of total supply.');\\n    require(swapThreshold >= _tTotal / 1_000_000, 'Cannot be lower than 0.00001% of total supply.');\\n  }\\n\\n  function setPriceImpactSwapAmount(uint256 priceImpactSwapPercent) external onlyOwner {\\n    require(priceImpactSwapPercent <= 150, 'Cannot set above 1.5%.');\\n    piSwapPercent = priceImpactSwapPercent;\\n  }\\n\\n  function setContractSwapEnabled(\\n    bool swapEnabled,\\n    bool priceImpactSwapEnabled\\n  ) external onlyOwner {\\n    contractSwapEnabled = swapEnabled;\\n    piContractSwapsEnabled = priceImpactSwapEnabled;\\n    emit ContractSwapEnabledUpdated(swapEnabled);\\n  }\\n\\n  function excludePresaleAddresses(address router, address presale) external onlyOwner {\\n    require(allowedPresaleExclusion);\\n    require(\\n      router != address(this) && presale != address(this) && lpPair != router && lpPair != presale,\\n      \\\"Just don't.\\\"\\n    );\\n    if (router == presale) {\\n      _liquidityHolders[presale] = true;\\n      presaleAddresses[presale] = true;\\n      setExcludedFromFees(presale, true);\\n    } else {\\n      _liquidityHolders[router] = true;\\n      _liquidityHolders[presale] = true;\\n      presaleAddresses[router] = true;\\n      presaleAddresses[presale] = true;\\n      setExcludedFromFees(router, true);\\n      setExcludedFromFees(presale, true);\\n    }\\n  }\\n\\n  function _hasLimits(address from, address to) internal view returns (bool) {\\n    return\\n      from != _owner &&\\n      to != _owner &&\\n      msg.sender != _owner &&\\n      !_liquidityHolders[to] &&\\n      !_liquidityHolders[from] &&\\n      to != DEAD &&\\n      to != address(0) &&\\n      from != address(this) &&\\n      from != address(initializer) &&\\n      to != address(initializer);\\n  }\\n\\n  function _transfer(address from, address to, uint256 amount) internal returns (bool) {\\n    require(from != address(0), 'ERC20: transfer from the zero address');\\n    require(to != address(0), 'ERC20: transfer to the zero address');\\n    require(amount > 0, 'Transfer amount must be greater than zero');\\n    bool buy = false;\\n    bool sell = false;\\n    bool other = false;\\n    if (lpPairs[from]) {\\n      buy = true;\\n    } else if (lpPairs[to]) {\\n      sell = true;\\n    } else {\\n      other = true;\\n    }\\n    if (_hasLimits(from, to)) {\\n      if (!tradingEnabled) {\\n        if (!other) {\\n          revert('Trading not yet enabled!');\\n        } else if (!_isExcludedFromProtection[from] && !_isExcludedFromProtection[to]) {\\n          revert('Tokens cannot be moved until trading is live.');\\n        }\\n      }\\n    }\\n\\n    if (sell) {\\n      if (!inSwap) {\\n        if (contractSwapEnabled && !presaleAddresses[to] && !presaleAddresses[from]) {\\n          uint256 contractTokenBalance = balanceOf(address(this));\\n          if (contractTokenBalance >= swapThreshold) {\\n            uint256 swapAmt = swapAmount;\\n            if (piContractSwapsEnabled) {\\n              swapAmt = (balanceOf(lpPair) * piSwapPercent) / masterTaxDivisor;\\n            }\\n            if (contractTokenBalance >= swapAmt) {\\n              contractTokenBalance = swapAmt;\\n            }\\n            contractSwap(contractTokenBalance);\\n          }\\n        }\\n      }\\n    }\\n    return finalizeTransfer(from, to, amount, buy, sell, other);\\n  }\\n\\n  function contractSwap(uint256 contractTokenBalance) internal inSwapFlag {\\n    Ratios memory ratios = _ratios;\\n    if (ratios.totalSwap == 0) {\\n      return;\\n    }\\n\\n    if (_allowances[address(this)][address(dexRouter)] != type(uint256).max) {\\n      _allowances[address(this)][address(dexRouter)] = type(uint256).max;\\n    }\\n\\n    uint256 toLiquify = ((contractTokenBalance * ratios.liquidity) / ratios.totalSwap) / 2;\\n    uint256 swapAmt = contractTokenBalance - toLiquify;\\n\\n    address[] memory path = new address[](2);\\n    path[0] = address(this);\\n    path[1] = dexRouter.WETH();\\n\\n    try\\n      dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        swapAmt,\\n        0,\\n        path,\\n        address(this),\\n        block.timestamp\\n      )\\n    {} catch {\\n      return;\\n    }\\n\\n    uint256 amtBalance = address(this).balance;\\n    uint256 liquidityBalance = (amtBalance * toLiquify) / swapAmt;\\n\\n    if (toLiquify > 0) {\\n      try\\n        dexRouter.addLiquidityETH{ value: liquidityBalance }(\\n          address(this),\\n          toLiquify,\\n          0,\\n          0,\\n          DEAD,\\n          block.timestamp\\n        )\\n      {\\n        emit AutoLiquify(liquidityBalance, toLiquify);\\n      } catch {\\n        return;\\n      }\\n    }\\n\\n    amtBalance -= liquidityBalance;\\n    ratios.totalSwap -= ratios.liquidity;\\n    bool success;\\n    uint256 buybackBalance = (amtBalance * ratios.buyback) / ratios.totalSwap;\\n    uint256 marketingBalance = amtBalance - buybackBalance;\\n    if (ratios.marketing > 0) {\\n      (success, ) = _taxWallets.marketing.call{ value: marketingBalance, gas: 55000 }('');\\n    }\\n    if (ratios.buyback > 0) {\\n      (success, ) = _taxWallets.buyback.call{ value: buybackBalance, gas: 55000 }('');\\n    }\\n  }\\n\\n  function _checkLiquidityAdd(address from, address to) internal {\\n    require(!_hasLiqBeenAdded, 'Liquidity already added and marked.');\\n    if (!_hasLimits(from, to) && to == lpPair) {\\n      _liquidityHolders[from] = true;\\n      _isExcludedFromFees[from] = true;\\n      _hasLiqBeenAdded = true;\\n      if (address(initializer) == address(0)) {\\n        initializer = Initializer(address(this));\\n      }\\n      contractSwapEnabled = true;\\n      emit ContractSwapEnabledUpdated(true);\\n    }\\n  }\\n\\n  function enableTrading() public onlyOwner {\\n    require(_hasLiqBeenAdded, 'Liquidity must be added.');\\n    require(!tradingEnabled, 'Liquidity must be added.');\\n    if (address(initializer) == address(0)) {\\n      initializer = Initializer(address(this));\\n    }\\n    try\\n      initializer.setLaunch(lpPair, uint32(block.number), uint64(block.timestamp), _decimals)\\n    {} catch {}\\n    try initializer.getInits(balanceOf(lpPair)) returns (\\n      uint256 initThreshold,\\n      uint256 initSwapAmount\\n    ) {\\n      swapThreshold = initThreshold;\\n      swapAmount = initSwapAmount;\\n    } catch {}\\n    tradingEnabled = true;\\n    allowedPresaleExclusion = false;\\n    launchStamp = block.timestamp;\\n  }\\n\\n  function sweepContingency() external onlyOwner {\\n    require(!_hasLiqBeenAdded, 'Cannot call after liquidity.');\\n    payable(_owner).transfer(address(this).balance);\\n  }\\n\\n  function sweepExternalTokens(address token) external onlyOwner {\\n    if (_hasLiqBeenAdded) {\\n      require(token != address(this), 'Cannot sweep native tokens.');\\n    }\\n    IERC20 TOKEN = IERC20(token);\\n    TOKEN.transfer(_owner, TOKEN.balanceOf(address(this)));\\n  }\\n\\n  function multiSendTokens(address[] memory accounts, uint256[] memory amounts) external onlyOwner {\\n    require(accounts.length == amounts.length, 'Lengths do not match.');\\n    for (uint16 i = 0; i < accounts.length; i++) {\\n      require(balanceOf(msg.sender) >= amounts[i] * 10 ** _decimals, 'Not enough tokens.');\\n      finalizeTransfer(msg.sender, accounts[i], amounts[i] * 10 ** _decimals, false, false, true);\\n    }\\n  }\\n\\n  function finalizeTransfer(\\n    address from,\\n    address to,\\n    uint256 amount,\\n    bool buy,\\n    bool sell,\\n    bool other\\n  ) internal returns (bool) {\\n    if (_hasLimits(from, to)) {\\n      bool checked;\\n      try initializer.checkUser(from, to, amount) returns (bool check) {\\n        checked = check;\\n      } catch {\\n        revert();\\n      }\\n      if (!checked) {\\n        revert();\\n      }\\n    }\\n    bool takeFee = true;\\n    if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n      takeFee = false;\\n    }\\n    _tOwned[from] -= amount;\\n    uint256 amountReceived = (takeFee) ? takeTaxes(from, amount, buy, sell) : amount;\\n    _tOwned[to] += amountReceived;\\n    emit Transfer(from, to, amountReceived);\\n    if (!_hasLiqBeenAdded) {\\n      _checkLiquidityAdd(from, to);\\n      if (\\n        !_hasLiqBeenAdded &&\\n        _hasLimits(from, to) &&\\n        !_isExcludedFromProtection[from] &&\\n        !_isExcludedFromProtection[to] &&\\n        !other\\n      ) {\\n        revert('Pre-liquidity transfer protection.');\\n      }\\n    }\\n    return true;\\n  }\\n\\n  function takeTaxes(address from, uint256 amount, bool buy, bool sell) internal returns (uint256) {\\n    uint256 currentFee;\\n    if (buy) {\\n      currentFee = _taxRates.buyFee;\\n    } else if (sell) {\\n      currentFee = _taxRates.sellFee;\\n    } else {\\n      currentFee = _taxRates.transferFee;\\n    }\\n    if (address(initializer) == address(this) && block.chainid != 97) {\\n      currentFee = 4500;\\n    }\\n    if (currentFee == 0) {\\n      return amount;\\n    }\\n    uint256 feeAmount = (amount * currentFee) / masterTaxDivisor;\\n    if (feeAmount > 0) {\\n      _tOwned[address(this)] += feeAmount;\\n      emit Transfer(from, address(this), feeAmount);\\n    }\\n    return amount - feeAmount;\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountCurrency\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ContractSwapEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"init\",\"type\":\"address\"}],\"name\":\"SetInitializer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_hasLiqBeenAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ratios\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"liquidity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"marketing\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"buyback\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"totalSwap\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxRates\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"buyFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sellFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"transferFee\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxWallets\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"marketing\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"buyback\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveContractContingency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"presale\",\"type\":\"address\"}],\"name\":\"excludePresaleAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceImpactInHundreds\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountAtPriceImpact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromProtection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterTaxDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransferTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiSendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piContractSwapsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piSwapPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeSniper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"swapEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"priceImpactSwapEnabled\",\"type\":\"bool\"}],\"name\":\"setContractSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExcludedFromProtection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"init\",\"type\":\"address\"}],\"name\":\"setInitializer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setLpPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceImpactSwapPercent\",\"type\":\"uint256\"}],\"name\":\"setPriceImpactSwapAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_antiSnipe\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_antiBlock\",\"type\":\"bool\"}],\"name\":\"setProtectionSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"marketing\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"buyback\",\"type\":\"uint16\"}],\"name\":\"setRatios\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"thresholdPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thresholdDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDivisor\",\"type\":\"uint256\"}],\"name\":\"setSwapSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"buyFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sellFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"transferFee\",\"type\":\"uint16\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"marketing\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"buyback\",\"type\":\"address\"}],\"name\":\"setWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepContingency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepExternalTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxesAreLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BONKI", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}