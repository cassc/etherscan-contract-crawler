{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/exchange/NftExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/math/SafeMath.sol\\\";\\nimport \\\"../lib/interface/IERC1155.sol\\\";\\nimport \\\"../lib/utils/StringLibrary.sol\\\";\\nimport \\\"../lib/utils/BytesLibrary.sol\\\";\\nimport \\\"../lib/contracts/ERC165.sol\\\";\\nimport \\\"./OwnableOperatorRole.sol\\\";\\nimport \\\"./ERC20TransferProxy.sol\\\";\\nimport \\\"./TransferProxy.sol\\\";\\nimport \\\"./ExchangeOrdersHolder.sol\\\";\\nimport \\\"./ExchangeDomain.sol\\\";\\nimport \\\"./ExchangeState.sol\\\";\\nimport \\\"./TransferProxyForDeprecated.sol\\\";\\n\\nimport \\\"../lib/contracts/HasSecondarySaleFees.sol\\\";\\nimport \\\"../lib/utils/Ownable.sol\\\";\\n\\ncontract NftExchange is Ownable, ExchangeDomain {\\n    using SafeMath for uint;\\n    using UintLibrary for uint;\\n    using StringLibrary for string;\\n    using BytesLibrary for bytes32;\\n\\n    enum FeeSide {NONE, SELL, BUY}\\n\\n    event Buy(\\n        address indexed sellToken, uint256 indexed sellTokenId, uint256 sellValue,\\n        address owner,\\n        address buyToken, uint256 buyTokenId, uint256 buyValue,\\n        address buyer,\\n        uint256 amount,\\n        uint256 salt\\n    );\\n\\n    event Cancel(\\n        address indexed sellToken, uint256 indexed sellTokenId,\\n        address owner,\\n        address buyToken, uint256 buyTokenId,\\n        uint256 salt\\n    );\\n\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n    uint256 private constant UINT256_MAX = 2 ** 256 - 1;\\n\\n    address payable public beneficiary;\\n    address public buyerFeeSigner;\\n\\n    TransferProxy public transferProxy;\\n    TransferProxyForDeprecated public transferProxyForDeprecated;\\n    ERC20TransferProxy public erc20TransferProxy;\\n    ExchangeState public state;\\n    ExchangeOrdersHolder public ordersHolder;\\n\\n    constructor(\\n        TransferProxy _transferProxy, TransferProxyForDeprecated _transferProxyForDeprecated, ERC20TransferProxy _erc20TransferProxy, ExchangeState _state,\\n        ExchangeOrdersHolder _ordersHolder, address payable _beneficiary, address _buyerFeeSigner\\n    ) {\\n        transferProxy = _transferProxy;\\n        transferProxyForDeprecated = _transferProxyForDeprecated;\\n        erc20TransferProxy = _erc20TransferProxy;\\n        state = _state;\\n        ordersHolder = _ordersHolder;\\n        beneficiary = _beneficiary;\\n        buyerFeeSigner = _buyerFeeSigner;\\n    }\\n\\n    function setBeneficiary(address payable newBeneficiary) external onlyOwner {\\n        beneficiary = newBeneficiary;\\n    }\\n\\n    function setBuyerFeeSigner(address newBuyerFeeSigner) external onlyOwner {\\n        buyerFeeSigner = newBuyerFeeSigner;\\n    }\\n\\n    function exchange(\\n        Order calldata order,\\n        Sig calldata sig,\\n        uint buyerFee,\\n        Sig calldata buyerFeeSig,\\n        uint amount,\\n        address buyer\\n    ) payable external {\\n        validateOrderSig(order, sig);\\n        validateBuyerFeeSig(order, buyerFee, buyerFeeSig);\\n        uint paying = order.buying.mul(amount).div(order.selling);\\n        verifyOpenAndModifyOrderState(order.key, order.selling, amount);\\n        require(order.key.sellAsset.assetType != AssetType.ETH, \\\"ETH is not supported on sell side\\\");\\n        if (order.key.buyAsset.assetType == AssetType.ETH) {\\n            validateEthTransfer(paying, buyerFee);\\n        }\\n        FeeSide feeSide = getFeeSide(order.key.sellAsset.assetType, order.key.buyAsset.assetType);\\n        if (buyer == address(0x0)) {\\n            buyer = msg.sender;\\n        }\\n        /* SELL = accept, BUY = buy */\\n        transferWithFeesPossibility(order.key.sellAsset, amount, order.key.owner, buyer, feeSide == FeeSide.SELL, buyerFee, order.sellerFee, order.key.buyAsset); \\n        transferWithFeesPossibility(order.key.buyAsset, paying, msg.sender, order.key.owner, feeSide == FeeSide.BUY, order.sellerFee, buyerFee, order.key.sellAsset);\\n        emitBuy(order, amount, buyer);\\n    }\\n\\n    function validateEthTransfer(uint value, uint buyerFee) internal view {\\n        uint256 buyerFeeValue = value.bp(buyerFee);\\n        require(msg.value == value + buyerFeeValue, \\\"msg.value is incorrect\\\");\\n    }\\n\\n    function cancel(OrderKey calldata key) external {\\n        require(key.owner == msg.sender, \\\"not an owner\\\");\\n        state.setCompleted(key, UINT256_MAX);\\n        emit Cancel(key.sellAsset.token, key.sellAsset.tokenId, msg.sender, key.buyAsset.token, key.buyAsset.tokenId, key.salt);\\n    }\\n\\n    function validateOrderSig(\\n        Order memory order,\\n        Sig memory sig\\n    ) internal view {\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\n            require(ordersHolder.exists(order), \\\"incorrect signature\\\");\\n        } else {\\n            require(prepareMessage(order).recover(sig.v, sig.r, sig.s) == order.key.owner, \\\"incorrect signature\\\");\\n        }\\n    }\\n\\n    function validateBuyerFeeSig(\\n        Order memory order,\\n        uint buyerFee,\\n        Sig memory sig\\n    ) internal view {\\n        require(prepareBuyerFeeMessage(order, buyerFee).recover(sig.v, sig.r, sig.s) == buyerFeeSigner, \\\"incorrect buyer fee signature\\\");\\n    }\\n\\n    function prepareBuyerFeeMessage(Order memory order, uint fee) public pure returns (string memory) {\\n        return keccak256(abi.encode(order, fee)).toString();\\n    }\\n\\n    function prepareMessage(Order memory order) public pure returns (string memory) {\\n        return keccak256(abi.encode(order)).toString();\\n    }\\n\\n    function transferWithFeesPossibility(Asset memory firstType, uint value, address from, address to, bool hasFee, uint256 sellerFee, uint256 buyerFee, Asset memory secondType) internal {\\n        if (!hasFee) {\\n            transfer(firstType, value, from, to);\\n        } else {\\n            transferWithFees(firstType, value, from, to, sellerFee, buyerFee, secondType);\\n        }\\n    }\\n\\n    function transfer(Asset memory asset, uint value, address from, address to) internal {\\n        if (asset.assetType == AssetType.ETH) {\\n            address payable toPayable = payable(to);\\n            toPayable.transfer(value);\\n        } else if (asset.assetType == AssetType.ERC20) {\\n            require(asset.tokenId == 0, \\\"tokenId  be 0\\\");\\n            erc20TransferProxy.erc20safeTransferFrom(IERC20(asset.token), from, to, value);\\n        } else if (asset.assetType == AssetType.ERC721) {\\n            require(value == 1, \\\"value  be 1 for ERC-721\\\");\\n            transferProxy.erc721safeTransferFrom(IERC721(asset.token), from, to, asset.tokenId);\\n        } else if (asset.assetType == AssetType.ERC721Deprecated) {\\n            require(value == 1, \\\"value  be 1 for ERC-721\\\");\\n            transferProxyForDeprecated.erc721TransferFrom(IERC721(asset.token), from, to, asset.tokenId);\\n        } else {\\n            transferProxy.erc1155safeTransferFrom(IERC1155(asset.token), from, to, asset.tokenId, value, \\\"\\\");\\n        }\\n    }\\n\\n    function transferWithFees(Asset memory firstType, uint value, address from, address to, uint256 sellerFee, uint256 buyerFee, Asset memory secondType) internal {\\n        uint restValue = transferFeeToBeneficiary(firstType, from, value, sellerFee, buyerFee);\\n        if (\\n            secondType.assetType == AssetType.ERC1155 && IERC1155(secondType.token).supportsInterface(_INTERFACE_ID_FEES) ||\\n            (secondType.assetType == AssetType.ERC721 || secondType.assetType == AssetType.ERC721Deprecated) && IERC721(secondType.token).supportsInterface(_INTERFACE_ID_FEES)\\n        ) {\\n            HasSecondarySaleFees withFees = HasSecondarySaleFees(secondType.token);\\n            address payable[] memory recipients = withFees.getFeeRecipients(secondType.tokenId);\\n            uint[] memory fees = withFees.getFeeBps(secondType.tokenId);\\n            require(fees.length == recipients.length);\\n            for (uint256 i = 0; i < fees.length; i++) {\\n                (uint newRestValue, uint current) = subFeeInBp(restValue, value, fees[i]);\\n                restValue = newRestValue;\\n                transfer(firstType, current, from, recipients[i]);\\n            }\\n        }\\n        address payable toPayable = payable(to);\\n        transfer(firstType, restValue, from, toPayable);\\n    }\\n\\n    function transferFeeToBeneficiary(Asset memory asset, address from, uint total, uint sellerFee, uint buyerFee) internal returns (uint) {\\n        (uint restValue, uint sellerFeeValue) = subFeeInBp(total, total, sellerFee);\\n        uint buyerFeeValue = total.bp(buyerFee);\\n        uint beneficiaryFee = buyerFeeValue.add(sellerFeeValue);\\n        if (beneficiaryFee > 0) {\\n            transfer(asset, beneficiaryFee, from, beneficiary);\\n        }\\n        return restValue;\\n    }\\n\\n    function emitBuy(Order memory order, uint amount, address buyer) internal {\\n        emit Buy(order.key.sellAsset.token, order.key.sellAsset.tokenId, order.selling,\\n            order.key.owner,\\n            order.key.buyAsset.token, order.key.buyAsset.tokenId, order.buying,\\n            buyer,\\n            amount,\\n            order.key.salt\\n        );\\n    }\\n\\n    function subFeeInBp(uint value, uint total, uint feeInBp) internal pure returns (uint newValue, uint realFee) {\\n        return subFee(value, total.bp(feeInBp));\\n    }\\n\\n    function subFee(uint value, uint fee) internal pure returns (uint newValue, uint realFee) {\\n        if (value > fee) {\\n            newValue = value - fee;\\n            realFee = fee;\\n        } else {\\n            newValue = 0;\\n            realFee = value;\\n        }\\n    }\\n\\n    function verifyOpenAndModifyOrderState(OrderKey memory key, uint selling, uint amount) internal {\\n        uint completed = state.getCompleted(key);\\n        uint newCompleted = completed.add(amount);\\n        require(newCompleted <= selling, \\\"not enough stock of order for buying\\\");\\n        state.setCompleted(key, newCompleted);\\n    }\\n\\n    function getFeeSide(AssetType sellType, AssetType buyType) internal pure returns (FeeSide) {\\n        if ((sellType == AssetType.ERC721 || sellType == AssetType.ERC721Deprecated) &&\\n            (buyType == AssetType.ERC721 || buyType == AssetType.ERC721Deprecated)) {\\n            return FeeSide.NONE;\\n        }\\n        if (uint(sellType) > uint(buyType)) {\\n            return FeeSide.BUY;\\n        }\\n        return FeeSide.SELL;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/utils/StringLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\nlibrary UintLibrary {\\n    using SafeMath for uint;\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n\\n        uint256 index = digits;\\n        temp = value;\\n        while (temp != 0) {\\n            index = index - 1;\\n            buffer[index] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function bp(uint value, uint bpValue) internal pure returns (uint) {\\n        return value.mul(bpValue).div(10000);\\n    }\\n}\\n\\nlibrary StringLibrary {\\n    using UintLibrary for uint256;\\n\\n    function append(string memory _a, string memory _b) internal pure returns (string memory) {\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        bytes memory bab = new bytes(_ba.length + _bb.length);\\n        uint k = 0;\\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\\n        for (uint i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\\n        return string(bab);\\n    }\\n\\n    function append(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        bytes memory _bc = bytes(_c);\\n        bytes memory bbb = new bytes(_ba.length + _bb.length + _bc.length);\\n        uint k = 0;\\n        for (uint i = 0; i < _ba.length; i++) bbb[k++] = _ba[i];\\n        for (uint i = 0; i < _bb.length; i++) bbb[k++] = _bb[i];\\n        for (uint i = 0; i < _bc.length; i++) bbb[k++] = _bc[i];\\n        return string(bbb);\\n    }\\n\\n    function recover(string memory message, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        bytes memory msgBytes = bytes(message);\\n        bytes memory fullMessage = concat(\\n            bytes(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\"),\\n            bytes(msgBytes.length.toString()),\\n            msgBytes,\\n            new bytes(0), new bytes(0), new bytes(0), new bytes(0)\\n        );\\n        return ecrecover(keccak256(fullMessage), v, r, s);\\n    }\\n\\n    function concat(bytes memory _ba, bytes memory _bb, bytes memory _bc, bytes memory _bd, bytes memory _be, bytes memory _bf, bytes memory _bg) internal pure returns (bytes memory) {\\n        bytes memory resultBytes = new bytes(_ba.length + _bb.length + _bc.length + _bd.length + _be.length + _bf.length + _bg.length);\\n        uint k = 0;\\n        for (uint i = 0; i < _ba.length; i++) resultBytes[k++] = _ba[i];\\n        for (uint i = 0; i < _bb.length; i++) resultBytes[k++] = _bb[i];\\n        for (uint i = 0; i < _bc.length; i++) resultBytes[k++] = _bc[i];\\n        for (uint i = 0; i < _bd.length; i++) resultBytes[k++] = _bd[i];\\n        for (uint i = 0; i < _be.length; i++) resultBytes[k++] = _be[i];\\n        for (uint i = 0; i < _bf.length; i++) resultBytes[k++] = _bf[i];\\n        for (uint i = 0; i < _bg.length; i++) resultBytes[k++] = _bg[i];\\n        return resultBytes;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/utils/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/utils/Ownable.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/utils/BytesLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nlibrary BytesLibrary {\\n    function toString(bytes32 value) internal pure returns (string memory) {\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n        bytes memory str = new bytes(64);\\n        for (uint256 i = 0; i < 32; i++) {\\n            str[i*2] = alphabet[uint8(value[i] >> 4)];\\n            str[1+i*2] = alphabet[uint8(value[i] & 0x0f)];\\n        }\\n        return string(str);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\nabstract contract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of NFTs in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual;\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either {approve} or {setApprovalForAll}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual;\\n    function approve(address to, uint256 tokenId) public virtual;\\n    function getApproved(uint256 tokenId) public view virtual returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public virtual;\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool);\\n\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual;\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/interface/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title ERC165\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface IERC165 {\\n\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas\\n     * @param _interfaceId The interface identifier, as specified in ERC-165\\n     */\\n    function supportsInterface(bytes4 _interfaceId)\\n    external\\n    view\\n    returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/interface/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\nabstract contract IERC1155 is IERC165 {\\n    /**\\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        The `_operator` argument MUST be msg.sender.\\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\\n        The `_id` argument MUST be the token type being transferred.\\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\\n    */\\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\\n\\n    /**\\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        The `_operator` argument MUST be msg.sender.\\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\\n        The `_ids` argument MUST be the list of tokens being transferred.\\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\\n    */\\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\\n\\n    /**\\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\\n    */\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /**\\n        @dev MUST emit when the URI is updated for a token ID.\\n        URIs are defined in RFC 3986.\\n        The URI MUST point a JSON file that conforms to the \\\"ERC-1155 Metadata URI JSON Schema\\\".\\n    */\\n    event URI(string _value, uint256 indexed _id);\\n\\n    /**\\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\\n        MUST revert on any other error.\\n        MUST emit the `TransferSingle` event to reflect the balance change (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _id      ID of the token type\\n        @param _value   Transfer amount\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\\n    */\\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external virtual;\\n\\n    /**\\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if length of `_ids` is not the same as length of `_values`.\\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\\n        MUST revert on any other error.\\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _ids     IDs of each token type (order and length must match _values array)\\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\\n    */\\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external virtual;\\n\\n    /**\\n        @notice Get the balance of an account's Tokens.\\n        @param _owner  The address of the token holder\\n        @param _id     ID of the Token\\n        @return        The _owner's balance of the Token type requested\\n     */\\n    function balanceOf(address _owner, uint256 _id) external view virtual returns (uint256);\\n\\n    /**\\n        @notice Get the balance of multiple account/token pairs\\n        @param _owners The addresses of the token holders\\n        @param _ids    ID of the Tokens\\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n     */\\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view virtual returns (uint256[] memory);\\n\\n    /**\\n        @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of the caller's tokens.\\n        @dev MUST emit the ApprovalForAll event on success.\\n        @param _operator  Address to add to the set of authorized operators\\n        @param _approved  True if the operator is approved, false to revoke approval\\n    */\\n    function setApprovalForAll(address _operator, bool _approved) external virtual;\\n\\n    /**\\n        @notice Queries the approval status of an operator for a given owner.\\n        @param _owner     The owner of the Tokens\\n        @param _operator  Address of authorized operator\\n        @return           True if the operator is approved, false if not\\n    */\\n    function isApprovedForAll(address _owner, address _operator) external view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/contracts/HasSecondarySaleFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\nabstract contract HasSecondarySaleFees is ERC165 {\\n\\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\\n\\n    /*\\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\\n     *\\n     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\\n     */\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n\\n    constructor() {\\n        _registerInterface(_INTERFACE_ID_FEES);\\n    }\\n\\n    function getFeeRecipients(uint256 id) public view virtual returns (address payable[] memory);\\n    function getFeeBps(uint256 id) public view virtual returns (uint[] memory);\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/contracts/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interface/IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/exchange/TransferProxyForDeprecated.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/interface/IERC721.sol\\\";\\nimport \\\"./OwnableOperatorRole.sol\\\";\\n\\ncontract TransferProxyForDeprecated is OwnableOperatorRole {\\n\\n    function erc721TransferFrom(IERC721 token, address from, address to, uint256 tokenId) external onlyOperator {\\n        token.transferFrom(from, to, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/exchange/TransferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/interface/IERC721.sol\\\";\\nimport \\\"../lib/interface/IERC1155.sol\\\";\\n\\nimport \\\"./OwnableOperatorRole.sol\\\";\\n\\ncontract TransferProxy is OwnableOperatorRole {\\n\\n    function erc721safeTransferFrom(IERC721 token, address from, address to, uint256 tokenId) external onlyOperator {\\n        token.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function erc1155safeTransferFrom(IERC1155 token, address from, address to, uint256 id, uint256 value, bytes calldata data) external onlyOperator {\\n        token.safeTransferFrom(from, to, id, value, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/exchange/OwnableOperatorRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/utils/Ownable.sol\\\";\\nimport \\\"./OperatorRole.sol\\\";\\n\\ncontract OwnableOperatorRole is Ownable, OperatorRole {\\n    function addOperator(address account) external onlyOwner {\\n        _addOperator(account);\\n    }\\n\\n    function removeOperator(address account) external onlyOwner {\\n        _removeOperator(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/exchange/OperatorRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/utils/Context.sol\\\";\\nimport \\\"../lib/utils/Roles.sol\\\";\\n\\ncontract OperatorRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event OperatorAdded(address indexed account);\\n    event OperatorRemoved(address indexed account);\\n\\n    Roles.Role private _operators;\\n\\n    constructor () {\\n    }\\n\\n    modifier onlyOperator() {\\n        require(isOperator(_msgSender()), \\\"OperatorRole: caller does not have the Operator role\\\");\\n        _;\\n    }\\n\\n    function isOperator(address account) public view returns (bool) {\\n        return _operators.has(account);\\n    }\\n\\n    function _addOperator(address account) internal {\\n        _operators.add(account);\\n        emit OperatorAdded(account);\\n    }\\n\\n    function _removeOperator(address account) internal {\\n        _operators.remove(account);\\n        emit OperatorRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/exchange/ExchangeState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ExchangeDomain.sol\\\";\\nimport \\\"./OwnableOperatorRole.sol\\\";\\n\\n\\ncontract ExchangeState is OwnableOperatorRole {\\n\\n    // keccak256(OrderKey) => completed\\n    mapping(bytes32 => uint256) public completed;\\n\\n    function getCompleted(ExchangeDomain.OrderKey calldata key) view external returns (uint256) {\\n        return completed[getCompletedKey(key)];\\n    }\\n\\n    function setCompleted(ExchangeDomain.OrderKey calldata key, uint256 newCompleted) external onlyOperator {\\n        completed[getCompletedKey(key)] = newCompleted;\\n    }\\n\\n    function getCompletedKey(ExchangeDomain.OrderKey memory key) pure public returns (bytes32) {\\n        return keccak256(abi.encodePacked(key.owner, key.sellAsset.token, key.sellAsset.tokenId, key.buyAsset.token, key.buyAsset.tokenId, key.salt));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/exchange/ExchangeOrdersHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n\\nimport \\\"./ExchangeDomain.sol\\\";\\n\\ncontract ExchangeOrdersHolder {\\n\\n    mapping(bytes32 => OrderParams) internal orders;\\n\\n    struct OrderParams {\\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\\n        uint selling;\\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\\n        uint buying;\\n\\n        /* fee for selling */\\n        uint sellerFee;\\n    }\\n\\n    function add(ExchangeDomain.Order calldata order) external {\\n        require(msg.sender == order.key.owner, \\\"order could be added by owner only\\\");\\n        bytes32 key = prepareKey(order);\\n        orders[key] = OrderParams(order.selling, order.buying, order.sellerFee);\\n    }\\n\\n    function exists(ExchangeDomain.Order calldata order) external view returns (bool) {\\n        bytes32 key = prepareKey(order);\\n        OrderParams memory params = orders[key];\\n        return params.buying == order.buying && params.selling == order.selling && params.sellerFee == order.sellerFee;\\n    }\\n\\n    function prepareKey(ExchangeDomain.Order memory order) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n                order.key.sellAsset.token,\\n                order.key.sellAsset.tokenId,\\n                order.key.owner,\\n                order.key.buyAsset.token,\\n                order.key.buyAsset.tokenId,\\n                order.key.salt\\n            ));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/exchange/ExchangeDomain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n\\ncontract ExchangeDomain {\\n\\n    enum AssetType {ETH, ERC20, ERC1155, ERC721, ERC721Deprecated}\\n\\n    struct Asset {\\n        address token;\\n        uint tokenId;\\n        AssetType assetType;\\n    }\\n\\n    struct OrderKey {\\n        /* who signed the order */\\n        address owner;\\n        /* random number */\\n        uint salt;\\n\\n        /* what has owner */\\n        Asset sellAsset;\\n\\n        /* what wants owner */\\n        Asset buyAsset;\\n    }\\n\\n    struct Order {\\n        OrderKey key;\\n\\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\\n        uint selling;\\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\\n        uint buying;\\n\\n        /* fee for selling */\\n        uint sellerFee;\\n    }\\n\\n    /* An ECDSA signature. */\\n    struct Sig {\\n        /* v parameter */\\n        uint8 v;\\n        /* r parameter */\\n        bytes32 r;\\n        /* s parameter */\\n        bytes32 s;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/exchange/ERC20TransferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\npragma experimental ABIEncoderV2;\\nimport \\\"../lib/interface/IERC20.sol\\\";\\n\\nimport \\\"./OwnableOperatorRole.sol\\\";\\n\\ncontract ERC20TransferProxy is OwnableOperatorRole {\\n\\n    function erc20safeTransferFrom(IERC20 token, address from, address to, uint256 value) external onlyOperator {\\n        require(token.transferFrom(from, to, value), \\\"failure while transferring\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract TransferProxy\",\"name\":\"_transferProxy\",\"type\":\"address\"},{\"internalType\":\"contract TransferProxyForDeprecated\",\"name\":\"_transferProxyForDeprecated\",\"type\":\"address\"},{\"internalType\":\"contract ERC20TransferProxy\",\"name\":\"_erc20TransferProxy\",\"type\":\"address\"},{\"internalType\":\"contract ExchangeState\",\"name\":\"_state\",\"type\":\"address\"},{\"internalType\":\"contract ExchangeOrdersHolder\",\"name\":\"_ordersHolder\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyerFeeSigner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sellTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sellTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyerFeeSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomain.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomain.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomain.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomain.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomain.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20TransferProxy\",\"outputs\":[{\"internalType\":\"contract ERC20TransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomain.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomain.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomain.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomain.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomain.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomain.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ExchangeDomain.Sig\",\"name\":\"sig\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"buyerFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ExchangeDomain.Sig\",\"name\":\"buyerFeeSig\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ordersHolder\",\"outputs\":[{\"internalType\":\"contract ExchangeOrdersHolder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomain.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomain.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomain.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomain.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomain.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomain.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"prepareBuyerFeeMessage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomain.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomain.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomain.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomain.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomain.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomain.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"prepareMessage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBuyerFeeSigner\",\"type\":\"address\"}],\"name\":\"setBuyerFeeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"contract ExchangeState\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferProxy\",\"outputs\":[{\"internalType\":\"contract TransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferProxyForDeprecated\",\"outputs\":[{\"internalType\":\"contract TransferProxyForDeprecated\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NftExchange", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000089c083afaeb6000ef07922c030295e154b3e26a6000000000000000000000000491882e4a74dd263ed355298eebd0e28131e3946000000000000000000000000e515d96b81b7397ef841e9b621b6a9b3ad8bb55800000000000000000000000034d3e5b7d6bc9bb7decfdadcb58172ca02a932a400000000000000000000000010ef44e07a20b0f992995041e8952a3d92a5a5650000000000000000000000009c30522b6c84412afae6cfc33d4c08b75ed05e360000000000000000000000003a09cd994fc79c1751e1e28abe4bcab16861bb60", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}