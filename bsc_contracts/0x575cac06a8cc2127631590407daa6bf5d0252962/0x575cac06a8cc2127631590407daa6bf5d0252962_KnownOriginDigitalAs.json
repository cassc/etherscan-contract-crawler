{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n * See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n  {\r\n    require(has(_role, _addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _role.bearer[_addr];\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Based on OpenZeppelin Whitelist & RBCA contracts\r\n * @dev The AccessControl contract provides different access for addresses, and provides basic authorization control functions.\r\n */\r\ncontract AccessControl {\r\n\r\n  using Roles for Roles.Role;\r\n\r\n  uint8 public constant ROLE_KNOWN_ORIGIN = 1;\r\n  uint8 public constant ROLE_MINTER = 2;\r\n  uint8 public constant ROLE_UNDER_MINTER = 3;\r\n\r\n  event RoleAdded(address indexed operator, uint8 role);\r\n  event RoleRemoved(address indexed operator, uint8 role);\r\n\r\n  address public owner;\r\n\r\n  mapping(uint8 => Roles.Role) private roles;\r\n\r\n  modifier onlyIfKnownOrigin() {\r\n    require(msg.sender == owner || hasRole(msg.sender, ROLE_KNOWN_ORIGIN));\r\n    _;\r\n  }\r\n\r\n  modifier onlyIfMinter() {\r\n    require(msg.sender == owner || hasRole(msg.sender, ROLE_KNOWN_ORIGIN) || hasRole(msg.sender, ROLE_MINTER));\r\n    _;\r\n  }\r\n\r\n  modifier onlyIfUnderMinter() {\r\n    require(msg.sender == owner || hasRole(msg.sender, ROLE_KNOWN_ORIGIN) || hasRole(msg.sender, ROLE_UNDER_MINTER));\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  ////////////////////////////////////\r\n  // Whitelist/RBCA Derived Methods //\r\n  ////////////////////////////////////\r\n\r\n  function addAddressToAccessControl(address _operator, uint8 _role)\r\n  public\r\n  onlyIfKnownOrigin\r\n  {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n  function removeAddressFromAccessControl(address _operator, uint8 _role)\r\n  public\r\n  onlyIfKnownOrigin\r\n  {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n  function checkRole(address _operator, uint8 _role)\r\n  public\r\n  view\r\n  {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  function hasRole(address _operator, uint8 _role)\r\n  public\r\n  view\r\n  returns (bool)\r\n  {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2\u03c0.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this Ether.\r\n * @notice Ether can still be sent to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n */\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  constructor() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by setting a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    owner.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() external view returns (string _name);\r\n  function symbol() external view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   * after a `safetransfer`. This function MAY throw to revert and reject the\r\n   * transfer. Return of other than the magic value MUST result in the\r\n   * transaction being reverted.\r\n   * Note: the contract address is always the message sender.\r\n   * @param _operator The address which called `safeTransferFrom` function\r\n   * @param _from The address which previously owned the token\r\n   * @param _tokenId The NFT identifier which is being transferred\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SupportsInterfaceWithLookup\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract SupportsInterfaceWithLookup is ERC165 {\r\n\r\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n  /**\r\n   * 0x01ffc9a7 ===\r\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n   */\r\n\r\n  /**\r\n   * @dev a mapping of interface id to whether or not it's supported\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev A contract implementing SupportsInterfaceWithLookup\r\n   * implement ERC165 itself\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    _registerInterface(InterfaceId_ERC165);\r\n  }\r\n\r\n  /**\r\n   * @dev implement supportsInterface(bytes4) using a lookup table\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceId];\r\n  }\r\n\r\n  /**\r\n   * @dev private method for registering an interface\r\n   */\r\n  function _registerInterface(bytes4 _interfaceId)\r\n    internal\r\n  {\r\n    require(_interfaceId != 0xffffffff);\r\n    supportedInterfaces[_interfaceId] = true;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\r\n\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) internal tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner to number of owned token\r\n  mapping (address => uint256) internal ownedTokensCount;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  constructor()\r\n    public\r\n  {\r\n    // register the supported interfaces to conform to ERC721 via ERC165\r\n    _registerInterface(InterfaceId_ERC721);\r\n    _registerInterface(InterfaceId_ERC721Exists);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokensCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param _tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param _tokenId uint256 ID of the token to query the existence of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address owner = tokenOwner[_tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * The zero address indicates there is no approved address.\r\n   * There can only be one approved address per token at a given time.\r\n   * Can only be called by the token owner or an approved operator.\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n    tokenApprovals[_tokenId] = _to;\r\n    emit Approval(owner, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param _to operator address to set the approval\r\n   * @param _approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address _to, bool _approved) public {\r\n    require(_to != msg.sender);\r\n    operatorApprovals[msg.sender][_to] = _approved;\r\n    emit ApprovalForAll(msg.sender, _to, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n  {\r\n    require(isApprovedOrOwner(msg.sender, _tokenId));\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeTokenFrom(_from, _tokenId);\r\n    addTokenTo(_to, _tokenId);\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * If the target address is a contract, it must implement `onERC721Received`,\r\n   * which is called upon a safe transfer, and return the magic value\r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n   * the transfer is reverted.\r\n   *\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * If the target address is a contract, it must implement `onERC721Received`,\r\n   * which is called upon a safe transfer, and return the magic value\r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n   * the transfer is reverted.\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes data to send along with a safe transfer check\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the given spender can transfer a given token ID\r\n   * @param _spender address of the spender to query\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @return bool whether the msg.sender is approved for the given token ID,\r\n   *  is an operator of the owner, or is the owner of the token\r\n   */\r\n  function isApprovedOrOwner(\r\n    address _spender,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    address owner = ownerOf(_tokenId);\r\n    // Disable solium check because of\r\n    // https://github.com/duaraghav8/Solium/issues/175\r\n    // solium-disable-next-line operator-whitespace\r\n    return (\r\n      _spender == owner ||\r\n      getApproved(_tokenId) == _spender ||\r\n      isApprovedForAll(owner, _spender)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * Reverts if the given token ID already exists\r\n   * @param _to The address that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addTokenTo(_to, _tokenId);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * Reverts if the token does not exist\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    clearApproval(_owner, _tokenId);\r\n    removeTokenFrom(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to clear current approval of a given token ID\r\n   * Reverts if the given address is not indeed the owner of the token\r\n   * @param _owner owner of the token\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    if (tokenApprovals[_tokenId] != address(0)) {\r\n      tokenApprovals[_tokenId] = address(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _from);\r\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n    tokenOwner[_tokenId] = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * The call is not executed if the target address is not a contract\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _to target address that will receive the tokens\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n      msg.sender, _from, _tokenId, _data);\r\n    return (retval == ERC721_RECEIVED);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\r\n\r\n  // Token name\r\n  string internal name_;\r\n\r\n  // Token symbol\r\n  string internal symbol_;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping(address => uint256[]) internal ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n  // Array with all token ids, used for enumeration\r\n  uint256[] internal allTokens;\r\n\r\n  // Mapping from token id to position in the allTokens array\r\n  mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n  // Optional mapping for token URIs\r\n  mapping(uint256 => string) internal tokenURIs;\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  constructor(string _name, string _symbol) public {\r\n    name_ = _name;\r\n    symbol_ = _symbol;\r\n\r\n    // register the supported interfaces to conform to ERC721 via ERC165\r\n    _registerInterface(InterfaceId_ERC721Enumerable);\r\n    _registerInterface(InterfaceId_ERC721Metadata);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token name\r\n   * @return string representing the token name\r\n   */\r\n  function name() external view returns (string) {\r\n    return name_;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token symbol\r\n   * @return string representing the token symbol\r\n   */\r\n  function symbol() external view returns (string) {\r\n    return symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an URI for a given token ID\r\n   * Throws if the token ID does not exist. May return an empty string.\r\n   * @param _tokenId uint256 ID of the token to query\r\n   */\r\n  function tokenURI(uint256 _tokenId) public view returns (string) {\r\n    require(exists(_tokenId));\r\n    return tokenURIs[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n   * @param _owner address owning the tokens list to be accessed\r\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < balanceOf(_owner));\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total amount of tokens stored by the contract\r\n   * @return uint256 representing the total amount of tokens\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of all the tokens in this contract\r\n   * Reverts if the index is greater or equal to the total number of tokens\r\n   * @param _index uint256 representing the index to be accessed of the tokens list\r\n   * @return uint256 token ID at the given index of the tokens list\r\n   */\r\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n    require(_index < totalSupply());\r\n    return allTokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to set the token URI for a given token\r\n   * Reverts if the token ID does not exist\r\n   * @param _tokenId uint256 ID of the token to set its URI\r\n   * @param _uri string URI to assign\r\n   */\r\n  function _setTokenURI(uint256 _tokenId, string _uri) internal {\r\n    require(exists(_tokenId));\r\n    tokenURIs[_tokenId] = _uri;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    super.addTokenTo(_to, _tokenId);\r\n    uint256 length = ownedTokens[_to].length;\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    super.removeTokenFrom(_from, _tokenId);\r\n\r\n    // To prevent a gap in the array, we store the last token in the index of the token to delete, and\r\n    // then delete the last slot.\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    // This also deletes the contents at the last position of the array\r\n    ownedTokens[_from].length--;\r\n\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * Reverts if the given token ID already exists\r\n   * @param _to address the beneficiary that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    super._mint(_to, _tokenId);\r\n\r\n    allTokensIndex[_tokenId] = allTokens.length;\r\n    allTokens.push(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * Reverts if the token does not exist\r\n   * @param _owner owner of the token to burn\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    super._burn(_owner, _tokenId);\r\n\r\n    // Clear metadata (if any)\r\n    if (bytes(tokenURIs[_tokenId]).length != 0) {\r\n      delete tokenURIs[_tokenId];\r\n    }\r\n\r\n    // Reorg all tokens array\r\n    uint256 tokenIndex = allTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = allTokens.length.sub(1);\r\n    uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n    allTokens[tokenIndex] = lastToken;\r\n    allTokens[lastTokenIndex] = 0;\r\n\r\n    allTokens.length--;\r\n    allTokensIndex[_tokenId] = 0;\r\n    allTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n}\r\n\r\nlibrary Strings {\r\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    bytes memory _be = bytes(_e);\r\n    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n    bytes memory babcde = bytes(abcde);\r\n    uint k = 0;\r\n    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n    for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n    for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n    for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n    for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n    return string(babcde);\r\n  }\r\n\r\n  function strConcat(string _a, string _b) internal pure returns (string) {\r\n    return strConcat(_a, _b, \"\", \"\", \"\");\r\n  }\r\n}\r\n\r\n\r\n\r\n// allows for multi-address access controls to different functions\r\n\r\n\r\n// Prevents stuck ether\r\n\r\n\r\n// For safe maths operations\r\n\r\n\r\n// Pause purchasing only in case of emergency/migration\r\n\r\n\r\n// ERC721\r\n\r\n\r\n// Utils only\r\n\r\n\r\n/**\r\n* @title KnownOriginDigitalAsset - V2\r\n*\r\n* http://www.knownorigin.io/\r\n*\r\n* ERC721 compliant digital assets for real-world artwork.\r\n*\r\n* Base NFT Issuance Contract\r\n*\r\n* BE ORIGINAL. BUY ORIGINAL.\r\n*\r\n*/\r\ncontract KnownOriginDigitalAssetV2 is\r\nERC721Token,\r\nAccessControl,\r\nHasNoEther,\r\nPausable\r\n{\r\n  using SafeMath for uint256;\r\n\r\n  ////////////\r\n  // Events //\r\n  ////////////\r\n\r\n  // Emitted on purchases from within this contract\r\n  event Purchase(\r\n    uint256 indexed _tokenId,\r\n    uint256 indexed _editionNumber,\r\n    address indexed _buyer,\r\n    uint256 _priceInWei\r\n  );\r\n\r\n  // Emitted on every mint\r\n  event Minted(\r\n    uint256 indexed _tokenId,\r\n    uint256 indexed _editionNumber,\r\n    address indexed _buyer\r\n  );\r\n\r\n  // Emitted on every edition created\r\n  event EditionCreated(\r\n    uint256 indexed _editionNumber,\r\n    bytes32 indexed _editionData,\r\n    uint256 indexed _editionType\r\n  );\r\n\r\n  ////////////////\r\n  // Properties //\r\n  ////////////////\r\n\r\n  uint256 constant internal MAX_UINT32 = ~uint32(0);\r\n\r\n  string public tokenBaseURI = \"https://ipfs.infura.io/ipfs/\";\r\n\r\n  // simple counter to keep track of the highest edition number used\r\n  uint256 public highestEditionNumber;\r\n\r\n  // total wei been processed through the contract\r\n  uint256 public totalPurchaseValueInWei;\r\n\r\n  // number of assets minted of any type\r\n  uint256 public totalNumberMinted;\r\n\r\n  // number of assets available of any type\r\n  uint256 public totalNumberAvailable;\r\n\r\n  // the KO account which can receive commission\r\n  address public koCommissionAccount;\r\n\r\n  // Optional commission split can be defined per edition\r\n  mapping(uint256 => CommissionSplit) editionNumberToOptionalCommissionSplit;\r\n\r\n  // Simple structure providing an optional commission split per edition purchase\r\n  struct CommissionSplit {\r\n    uint256 rate;\r\n    address recipient;\r\n  }\r\n\r\n  // Object for edition details\r\n  struct EditionDetails {\r\n    // Identifiers\r\n    uint256 editionNumber;    // the range e.g. 10000\r\n    bytes32 editionData;      // some data about the edition\r\n    uint256 editionType;      // e.g. 1 = KODA V1, 2 = KOTA, 3 = Bespoke partnership\r\n    // Config\r\n    uint256 startDate;        // date when the edition goes on sale\r\n    uint256 endDate;          // date when the edition is available until\r\n    address artistAccount;    // artists account\r\n    uint256 artistCommission; // base artists commission, could be overridden by external contracts\r\n    uint256 priceInWei;       // base price for edition, could be overridden by external contracts\r\n    string tokenURI;          // IPFS hash - see base URI\r\n    bool active;              // Root control - on/off for the edition\r\n    // Counters\r\n    uint256 totalSupply;      // Total purchases or mints\r\n    uint256 totalAvailable;   // Total number available to be purchased\r\n  }\r\n\r\n  // _editionNumber : EditionDetails\r\n  mapping(uint256 => EditionDetails) internal editionNumberToEditionDetails;\r\n\r\n  // _tokenId : _editionNumber\r\n  mapping(uint256 => uint256) internal tokenIdToEditionNumber;\r\n\r\n  // _editionNumber : [_tokenId, _tokenId]\r\n  mapping(uint256 => uint256[]) internal editionNumberToTokenIds;\r\n  mapping(uint256 => uint256) internal editionNumberToTokenIdIndex;\r\n\r\n  // _artistAccount : [_editionNumber, _editionNumber]\r\n  mapping(address => uint256[]) internal artistToEditionNumbers;\r\n  mapping(uint256 => uint256) internal editionNumberToArtistIndex;\r\n\r\n  // _editionType : [_editionNumber, _editionNumber]\r\n  mapping(uint256 => uint256[]) internal editionTypeToEditionNumber;\r\n  mapping(uint256 => uint256) internal editionNumberToTypeIndex;\r\n\r\n  ///////////////\r\n  // Modifiers // \r\n  ///////////////\r\n\r\n  modifier onlyAvailableEdition(uint256 _editionNumber) {\r\n    require(editionNumberToEditionDetails[_editionNumber].totalSupply < editionNumberToEditionDetails[_editionNumber].totalAvailable, \"No more editions left to purchase\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyActiveEdition(uint256 _editionNumber) {\r\n    require(editionNumberToEditionDetails[_editionNumber].active, \"Edition not active\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyRealEdition(uint256 _editionNumber) {\r\n    require(editionNumberToEditionDetails[_editionNumber].editionNumber > 0, \"Edition number invalid\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyValidTokenId(uint256 _tokenId) {\r\n    require(exists(_tokenId), \"Token ID does not exist\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyPurchaseDuringWindow(uint256 _editionNumber) {\r\n    require(editionNumberToEditionDetails[_editionNumber].startDate <= block.timestamp, \"Edition not available yet\");\r\n    require(editionNumberToEditionDetails[_editionNumber].endDate >= block.timestamp, \"Edition no longer available\");\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * Constructor\r\n   */\r\n  constructor () public payable ERC721Token(\"CryptoArtToken\", \"CART\") {\r\n    // set commission account to contract creator\r\n    koCommissionAccount = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates an active edition from the given configuration\r\n   * @dev Only callable from KO staff/addresses\r\n   */\r\n  function createActiveEdition(\r\n    uint256 _editionNumber,\r\n    bytes32 _editionData,\r\n    uint256 _editionType,\r\n    uint256 _startDate,\r\n    uint256 _endDate,\r\n    address _artistAccount,\r\n    uint256 _artistCommission,\r\n    uint256 _priceInWei,\r\n    string _tokenURI,\r\n    uint256 _totalAvailable\r\n  )\r\n  public\r\n  onlyIfKnownOrigin\r\n  returns (bool)\r\n  {\r\n    return _createEdition(_editionNumber, _editionData, _editionType, _startDate, _endDate, _artistAccount, _artistCommission, _priceInWei, _tokenURI, _totalAvailable, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Creates an inactive edition from the given configuration\r\n   * @dev Only callable from KO staff/addresses\r\n   */\r\n  function createInactiveEdition(\r\n    uint256 _editionNumber,\r\n    bytes32 _editionData,\r\n    uint256 _editionType,\r\n    uint256 _startDate,\r\n    uint256 _endDate,\r\n    address _artistAccount,\r\n    uint256 _artistCommission,\r\n    uint256 _priceInWei,\r\n    string _tokenURI,\r\n    uint256 _totalAvailable\r\n  )\r\n  public\r\n  onlyIfKnownOrigin\r\n  returns (bool)\r\n  {\r\n    return _createEdition(_editionNumber, _editionData, _editionType, _startDate, _endDate, _artistAccount, _artistCommission, _priceInWei, _tokenURI, _totalAvailable, false);\r\n  }\r\n\r\n  /**\r\n   * @dev Creates an active edition from the given configuration\r\n   * @dev The concept of pre0minted editions means we can 'undermint' token IDS, good for holding back editions from public sale\r\n   * @dev Only callable from KO staff/addresses\r\n   */\r\n  function createActivePreMintedEdition(\r\n    uint256 _editionNumber,\r\n    bytes32 _editionData,\r\n    uint256 _editionType,\r\n    uint256 _startDate,\r\n    uint256 _endDate,\r\n    address _artistAccount,\r\n    uint256 _artistCommission,\r\n    uint256 _priceInWei,\r\n    string _tokenURI,\r\n    uint256 _totalSupply,\r\n    uint256 _totalAvailable\r\n  )\r\n  public\r\n  onlyIfKnownOrigin\r\n  returns (bool)\r\n  {\r\n    _createEdition(_editionNumber, _editionData, _editionType, _startDate, _endDate, _artistAccount, _artistCommission, _priceInWei, _tokenURI, _totalAvailable, true);\r\n    updateTotalSupply(_editionNumber, _totalSupply);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates an inactive edition from the given configuration\r\n   * @dev The concept of pre0minted editions means we can 'undermint' token IDS, good for holding back editions from public sale\r\n   * @dev Only callable from KO staff/addresses\r\n   */\r\n  function createInactivePreMintedEdition(\r\n    uint256 _editionNumber,\r\n    bytes32 _editionData,\r\n    uint256 _editionType,\r\n    uint256 _startDate,\r\n    uint256 _endDate,\r\n    address _artistAccount,\r\n    uint256 _artistCommission,\r\n    uint256 _priceInWei,\r\n    string _tokenURI,\r\n    uint256 _totalSupply,\r\n    uint256 _totalAvailable\r\n  )\r\n  public\r\n  onlyIfKnownOrigin\r\n  returns (bool)\r\n  {\r\n    _createEdition(_editionNumber, _editionData, _editionType, _startDate, _endDate, _artistAccount, _artistCommission, _priceInWei, _tokenURI, _totalAvailable, false);\r\n    updateTotalSupply(_editionNumber, _totalSupply);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal factory method for building editions\r\n   */\r\n  function _createEdition(\r\n    uint256 _editionNumber,\r\n    bytes32 _editionData,\r\n    uint256 _editionType,\r\n    uint256 _startDate,\r\n    uint256 _endDate,\r\n    address _artistAccount,\r\n    uint256 _artistCommission,\r\n    uint256 _priceInWei,\r\n    string _tokenURI,\r\n    uint256 _totalAvailable,\r\n    bool _active\r\n  )\r\n  internal\r\n  returns (bool)\r\n  {\r\n    // Prevent missing edition number\r\n    require(_editionNumber != 0, \"Edition number not provided\");\r\n\r\n    // Prevent edition number lower than last one used\r\n    require(_editionNumber > highestEditionNumber, \"Edition number must be greater than previously used\");\r\n\r\n    // Check previously edition plus total available is less than new edition number\r\n    require(highestEditionNumber.add(editionNumberToEditionDetails[highestEditionNumber].totalAvailable) < _editionNumber, \"Edition number must be greater than previously used plus total available\");\r\n\r\n    // Prevent missing types\r\n    require(_editionType != 0, \"Edition type not provided\");\r\n\r\n    // Prevent missing token URI\r\n    require(bytes(_tokenURI).length != 0, \"Token URI is missing\");\r\n\r\n    // Prevent empty artists address\r\n    require(_artistAccount != address(0), \"Artist account not provided\");\r\n\r\n    // Prevent invalid commissions\r\n    require(_artistCommission <= 100 && _artistCommission >= 0, \"Artist commission cannot be greater than 100 or less than 0\");\r\n\r\n    // Prevent duplicate editions\r\n    require(editionNumberToEditionDetails[_editionNumber].editionNumber == 0, \"Edition already in existence\");\r\n\r\n    // Default end date to max uint256\r\n    uint256 endDate = _endDate;\r\n    if (_endDate == 0) {\r\n      endDate = MAX_UINT32;\r\n    }\r\n\r\n    editionNumberToEditionDetails[_editionNumber] = EditionDetails({\r\n      editionNumber : _editionNumber,\r\n      editionData : _editionData,\r\n      editionType : _editionType,\r\n      startDate : _startDate,\r\n      endDate : endDate,\r\n      artistAccount : _artistAccount,\r\n      artistCommission : _artistCommission,\r\n      priceInWei : _priceInWei,\r\n      tokenURI : _tokenURI,\r\n      totalSupply : 0, // default to all available\r\n      totalAvailable : _totalAvailable,\r\n      active : _active\r\n      });\r\n\r\n    // Add to total available count\r\n    totalNumberAvailable = totalNumberAvailable.add(_totalAvailable);\r\n\r\n    // Update mappings\r\n    _updateArtistLookupData(_artistAccount, _editionNumber);\r\n    _updateEditionTypeLookupData(_editionType, _editionNumber);\r\n\r\n    emit EditionCreated(_editionNumber, _editionData, _editionType);\r\n\r\n    // Update the edition pointer if needs be\r\n    highestEditionNumber = _editionNumber;\r\n\r\n    return true;\r\n  }\r\n\r\n  function _updateEditionTypeLookupData(uint256 _editionType, uint256 _editionNumber) internal {\r\n    uint256 typeEditionIndex = editionTypeToEditionNumber[_editionType].length;\r\n    editionTypeToEditionNumber[_editionType].push(_editionNumber);\r\n    editionNumberToTypeIndex[_editionNumber] = typeEditionIndex;\r\n  }\r\n\r\n  function _updateArtistLookupData(address _artistAccount, uint256 _editionNumber) internal {\r\n    uint256 artistEditionIndex = artistToEditionNumbers[_artistAccount].length;\r\n    artistToEditionNumbers[_artistAccount].push(_editionNumber);\r\n    editionNumberToArtistIndex[_editionNumber] = artistEditionIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Public entry point for purchasing an edition\r\n   * @dev Reverts if edition is invalid\r\n   * @dev Reverts if payment not provided in full\r\n   * @dev Reverts if edition is sold out\r\n   * @dev Reverts if edition is not active or available\r\n   */\r\n  function purchase(uint256 _editionNumber)\r\n  public\r\n  payable\r\n  returns (uint256) {\r\n    return purchaseTo(msg.sender, _editionNumber);\r\n  }\r\n\r\n  /**\r\n   * @dev Public entry point for purchasing an edition on behalf of someone else\r\n   * @dev Reverts if edition is invalid\r\n   * @dev Reverts if payment not provided in full\r\n   * @dev Reverts if edition is sold out\r\n   * @dev Reverts if edition is not active or available\r\n   */\r\n  function purchaseTo(address _to, uint256 _editionNumber)\r\n  public\r\n  payable\r\n  whenNotPaused\r\n  onlyRealEdition(_editionNumber)\r\n  onlyActiveEdition(_editionNumber)\r\n  onlyAvailableEdition(_editionNumber)\r\n  onlyPurchaseDuringWindow(_editionNumber)\r\n  returns (uint256) {\r\n\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    require(msg.value >= _editionDetails.priceInWei, \"Value must be greater than price of edition\");\r\n\r\n    // Construct next token ID e.g. 100000 + 1 = ID of 100001 (this first in the edition set)\r\n    uint256 _tokenId = _nextTokenId(_editionNumber);\r\n\r\n    // Create the token\r\n    _mintToken(_to, _tokenId, _editionNumber, _editionDetails.tokenURI);\r\n\r\n    // Splice funds and handle commissions\r\n    _handleFunds(_editionNumber, _editionDetails.priceInWei, _editionDetails.artistAccount, _editionDetails.artistCommission);\r\n\r\n    // Broadcast purchase\r\n    emit Purchase(_tokenId, _editionNumber, _to, msg.value);\r\n\r\n    return _tokenId;\r\n  }\r\n\r\n  /**\r\n   * @dev Private (KO only) method for minting editions\r\n   * @dev Payment not needed for this method\r\n   */\r\n  function mint(address _to, uint256 _editionNumber)\r\n  public\r\n  onlyIfMinter\r\n  onlyRealEdition(_editionNumber)\r\n  onlyAvailableEdition(_editionNumber)\r\n  returns (uint256) {\r\n    // Construct next token ID e.g. 100000 + 1 = ID of 100001 (this first in the edition set)\r\n    uint256 _tokenId = _nextTokenId(_editionNumber);\r\n\r\n    // Create the token\r\n    _mintToken(_to, _tokenId, _editionNumber, editionNumberToEditionDetails[_editionNumber].tokenURI);\r\n\r\n    // Create the token\r\n    return _tokenId;\r\n  }\r\n\r\n  /**\r\n   * @dev Private (KO only) method for under minting editions\r\n   * @dev Under minting allows for token IDs to be back filled if total supply is not set to zero by default\r\n   * @dev Payment not needed for this method\r\n   */\r\n  function underMint(address _to, uint256 _editionNumber)\r\n  public\r\n  onlyIfUnderMinter\r\n  onlyRealEdition(_editionNumber)\r\n  returns (uint256) {\r\n    // Under mint token, meaning it takes one from the already sold version\r\n    uint256 _tokenId = _underMintNextTokenId(_editionNumber);\r\n\r\n    // If the next tokenId generate is more than the available number, abort as we have reached maximum under mint\r\n    if (_tokenId > _editionNumber.add(editionNumberToEditionDetails[_editionNumber].totalAvailable)) {\r\n      revert(\"Reached max tokenId, cannot under mint anymore\");\r\n    }\r\n\r\n    // Create the token\r\n    _mintToken(_to, _tokenId, _editionNumber, editionNumberToEditionDetails[_editionNumber].tokenURI);\r\n\r\n    // Create the token\r\n    return _tokenId;\r\n  }\r\n\r\n  function _nextTokenId(uint256 _editionNumber) internal returns (uint256) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n\r\n    // Bump number totalSupply\r\n    _editionDetails.totalSupply = _editionDetails.totalSupply.add(1);\r\n\r\n    // Construct next token ID e.g. 100000 + 1 = ID of 100001 (this first in the edition set)\r\n    return _editionDetails.editionNumber.add(_editionDetails.totalSupply);\r\n  }\r\n\r\n  function _underMintNextTokenId(uint256 _editionNumber) internal returns (uint256) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n\r\n    // For old editions start the counter as edition + 1\r\n    uint256 _tokenId = _editionDetails.editionNumber.add(1);\r\n\r\n    // Work your way up until you find a free token based on the new _tokenIdd\r\n    while (exists(_tokenId)) {\r\n      _tokenId = _tokenId.add(1);\r\n    }\r\n\r\n    // Bump number totalSupply if we are now over minting new tokens\r\n    if (_tokenId > _editionDetails.editionNumber.add(_editionDetails.totalSupply)) {\r\n      _editionDetails.totalSupply = _editionDetails.totalSupply.add(1);\r\n    }\r\n\r\n    return _tokenId;\r\n  }\r\n\r\n  function _mintToken(address _to, uint256 _tokenId, uint256 _editionNumber, string _tokenURI) internal {\r\n\r\n    // Mint new base token\r\n    super._mint(_to, _tokenId);\r\n    super._setTokenURI(_tokenId, _tokenURI);\r\n\r\n    // Maintain mapping for tokenId to edition for lookup\r\n    tokenIdToEditionNumber[_tokenId] = _editionNumber;\r\n\r\n    // Get next insert position for edition to token Id mapping\r\n    uint256 currentIndexOfTokenId = editionNumberToTokenIds[_editionNumber].length;\r\n\r\n    // Maintain mapping of edition to token array for \"edition minted tokens\"\r\n    editionNumberToTokenIds[_editionNumber].push(_tokenId);\r\n\r\n    // Maintain a position index for the tokenId within the edition number mapping array, used for clean up token burn\r\n    editionNumberToTokenIdIndex[_tokenId] = currentIndexOfTokenId;\r\n\r\n    // Record sale volume\r\n    totalNumberMinted = totalNumberMinted.add(1);\r\n\r\n    // Emit minted event\r\n    emit Minted(_tokenId, _editionNumber, _to);\r\n  }\r\n\r\n  function _handleFunds(uint256 _editionNumber, uint256 _priceInWei, address _artistAccount, uint256 _artistCommission) internal {\r\n\r\n    // Extract the artists commission and send it\r\n    uint256 artistPayment = _priceInWei.div(100).mul(_artistCommission);\r\n    if (artistPayment > 0) {\r\n      _artistAccount.transfer(artistPayment);\r\n    }\r\n\r\n    // Load any commission overrides\r\n    CommissionSplit storage commission = editionNumberToOptionalCommissionSplit[_editionNumber];\r\n\r\n    // Apply optional commission structure\r\n    if (commission.rate > 0) {\r\n      uint256 rateSplit = _priceInWei.div(100).mul(commission.rate);\r\n      commission.recipient.transfer(rateSplit);\r\n    }\r\n\r\n    // Send remaining eth to KO\r\n    uint256 remainingCommission = msg.value.sub(artistPayment).sub(rateSplit);\r\n    koCommissionAccount.transfer(remainingCommission);\r\n\r\n    // Record wei sale value\r\n    totalPurchaseValueInWei = totalPurchaseValueInWei.add(msg.value);\r\n  }\r\n\r\n  /**\r\n   * @dev Private (KO only) method for burning tokens which have been created incorrectly\r\n   */\r\n  function burn(uint256 _tokenId) public onlyIfKnownOrigin {\r\n\r\n    // Clear from parents\r\n    super._burn(ownerOf(_tokenId), _tokenId);\r\n\r\n    // Get hold of the edition for cleanup\r\n    uint256 _editionNumber = tokenIdToEditionNumber[_tokenId];\r\n\r\n    // Delete token ID mapping\r\n    delete tokenIdToEditionNumber[_tokenId];\r\n\r\n    // Delete tokens associated to the edition - this will leave a gap in the array of zero\r\n    uint256[] storage tokenIdsForEdition = editionNumberToTokenIds[_editionNumber];\r\n    uint256 editionTokenIdIndex = editionNumberToTokenIdIndex[_tokenId];\r\n    delete tokenIdsForEdition[editionTokenIdIndex];\r\n  }\r\n\r\n  /**\r\n   * @dev An extension to the default ERC721 behaviour, derived from ERC-875.\r\n   * @dev Allowing for batch transfers from the sender, will fail if from does not own all the tokens\r\n   */\r\n  function batchTransfer(address _to, uint256[] _tokenIds) public {\r\n    for (uint i = 0; i < _tokenIds.length; i++) {\r\n      safeTransferFrom(ownerOf(_tokenIds[i]), _to, _tokenIds[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev An extension to the default ERC721 behaviour, derived from ERC-875.\r\n   * @dev Allowing for batch transfers from the provided address, will fail if from does not own all the tokens\r\n   */\r\n  function batchTransferFrom(address _from, address _to, uint256[] _tokenIds) public {\r\n    for (uint i = 0; i < _tokenIds.length; i++) {\r\n      transferFrom(_from, _to, _tokenIds[i]);\r\n    }\r\n  }\r\n\r\n  //////////////////\r\n  // Base Updates //\r\n  //////////////////\r\n\r\n  function updateTokenBaseURI(string _newBaseURI)\r\n  external\r\n  onlyIfKnownOrigin {\r\n    require(bytes(_newBaseURI).length != 0, \"Base URI invalid\");\r\n    tokenBaseURI = _newBaseURI;\r\n  }\r\n\r\n  function updateKoCommissionAccount(address _koCommissionAccount)\r\n  external\r\n  onlyIfKnownOrigin {\r\n    require(_koCommissionAccount != address(0), \"Invalid address\");\r\n    koCommissionAccount = _koCommissionAccount;\r\n  }\r\n\r\n  /////////////////////\r\n  // Edition Updates //\r\n  /////////////////////\r\n\r\n  function updateEditionTokenURI(uint256 _editionNumber, string _uri)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    editionNumberToEditionDetails[_editionNumber].tokenURI = _uri;\r\n  }\r\n\r\n  function updatePriceInWei(uint256 _editionNumber, uint256 _priceInWei)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    editionNumberToEditionDetails[_editionNumber].priceInWei = _priceInWei;\r\n  }\r\n\r\n  function updateArtistCommission(uint256 _editionNumber, uint256 _rate)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    editionNumberToEditionDetails[_editionNumber].artistCommission = _rate;\r\n  }\r\n\r\n  function updateArtistsAccount(uint256 _editionNumber, address _artistAccount)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n\r\n    EditionDetails storage _originalEditionDetails = editionNumberToEditionDetails[_editionNumber];\r\n\r\n    uint256 editionArtistIndex = editionNumberToArtistIndex[_editionNumber];\r\n\r\n    // Get list of editions old artist works with\r\n    uint256[] storage editionNumbersForArtist = artistToEditionNumbers[_originalEditionDetails.artistAccount];\r\n\r\n    // Remove edition from artists lists\r\n    delete editionNumbersForArtist[editionArtistIndex];\r\n\r\n    // Add new artists to the list\r\n    uint256 newArtistsEditionIndex = artistToEditionNumbers[_artistAccount].length;\r\n    artistToEditionNumbers[_artistAccount].push(_editionNumber);\r\n    editionNumberToArtistIndex[_editionNumber] = newArtistsEditionIndex;\r\n\r\n    // Update the edition\r\n    _originalEditionDetails.artistAccount = _artistAccount;\r\n  }\r\n\r\n  function updateEditionType(uint256 _editionNumber, uint256 _editionType)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n\r\n    EditionDetails storage _originalEditionDetails = editionNumberToEditionDetails[_editionNumber];\r\n\r\n    // Get list of editions for old type\r\n    uint256[] storage editionNumbersForType = editionTypeToEditionNumber[_originalEditionDetails.editionType];\r\n\r\n    // Remove edition from old type list\r\n    uint256 editionTypeIndex = editionNumberToTypeIndex[_editionNumber];\r\n    delete editionNumbersForType[editionTypeIndex];\r\n\r\n    // Add new type to the list\r\n    uint256 newTypeEditionIndex = editionTypeToEditionNumber[_editionType].length;\r\n    editionTypeToEditionNumber[_editionType].push(_editionNumber);\r\n    editionNumberToTypeIndex[_editionNumber] = newTypeEditionIndex;\r\n\r\n    // Update the edition\r\n    _originalEditionDetails.editionType = _editionType;\r\n  }\r\n\r\n  function updateActive(uint256 _editionNumber, bool _active)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    editionNumberToEditionDetails[_editionNumber].active = _active;\r\n  }\r\n\r\n  function updateTotalSupply(uint256 _editionNumber, uint256 _totalSupply)\r\n  public\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    require(tokensOfEdition(_editionNumber).length <= _totalSupply, \"Can not lower totalSupply to below the number of tokens already in existence\");\r\n    editionNumberToEditionDetails[_editionNumber].totalSupply = _totalSupply;\r\n  }\r\n\r\n  function updateTotalAvailable(uint256 _editionNumber, uint256 _totalAvailable)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n\r\n    require(_editionDetails.totalSupply <= _totalAvailable, \"Unable to reduce available amount to the below the number totalSupply\");\r\n\r\n    uint256 originalAvailability = _editionDetails.totalAvailable;\r\n    _editionDetails.totalAvailable = _totalAvailable;\r\n    totalNumberAvailable = totalNumberAvailable.sub(originalAvailability).add(_totalAvailable);\r\n  }\r\n\r\n  function updateStartDate(uint256 _editionNumber, uint256 _startDate)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    editionNumberToEditionDetails[_editionNumber].startDate = _startDate;\r\n  }\r\n\r\n  function updateEndDate(uint256 _editionNumber, uint256 _endDate)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    editionNumberToEditionDetails[_editionNumber].endDate = _endDate;\r\n  }\r\n\r\n  function updateOptionalCommission(uint256 _editionNumber, uint256 _rate, address _recipient)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyRealEdition(_editionNumber) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    uint256 artistCommission = _editionDetails.artistCommission;\r\n\r\n    if (_rate > 0) {\r\n      require(_recipient != address(0), \"Setting a rate must be accompanied by a valid address\");\r\n    }\r\n    require(artistCommission.add(_rate) <= 100, \"Cant set commission greater than 100%\");\r\n\r\n    editionNumberToOptionalCommissionSplit[_editionNumber] = CommissionSplit({rate : _rate, recipient : _recipient});\r\n  }\r\n\r\n  ///////////////////\r\n  // Token Updates //\r\n  ///////////////////\r\n\r\n  function setTokenURI(uint256 _tokenId, string _uri)\r\n  external\r\n  onlyIfKnownOrigin\r\n  onlyValidTokenId(_tokenId) {\r\n    _setTokenURI(_tokenId, _uri);\r\n  }\r\n\r\n  ///////////////////\r\n  // Query Methods //\r\n  ///////////////////\r\n\r\n  /**\r\n   * @dev Lookup the edition of the provided token ID\r\n   * @dev Returns 0 if not valid\r\n   */\r\n  function editionOfTokenId(uint256 _tokenId) public view returns (uint256 _editionNumber) {\r\n    return tokenIdToEditionNumber[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Lookup all editions added for the given edition type\r\n   * @dev Returns array of edition numbers, any zero edition ids can be ignore/stripped\r\n   */\r\n  function editionsOfType(uint256 _type) public view returns (uint256[] _editionNumbers) {\r\n    return editionTypeToEditionNumber[_type];\r\n  }\r\n\r\n  /**\r\n   * @dev Lookup all editions for the given artist account\r\n   * @dev Returns empty list if not valid\r\n   */\r\n  function artistsEditions(address _artistsAccount) public view returns (uint256[] _editionNumbers) {\r\n    return artistToEditionNumbers[_artistsAccount];\r\n  }\r\n\r\n  /**\r\n   * @dev Lookup all tokens minted for the given edition number\r\n   * @dev Returns array of token IDs, any zero edition ids can be ignore/stripped\r\n   */\r\n  function tokensOfEdition(uint256 _editionNumber) public view returns (uint256[] _tokenIds) {\r\n    return editionNumberToTokenIds[_editionNumber];\r\n  }\r\n\r\n  /**\r\n   * @dev Lookup all owned tokens for the provided address\r\n   * @dev Returns array of token IDs\r\n   */\r\n  function tokensOf(address _owner) public view returns (uint256[] _tokenIds) {\r\n    return ownedTokens[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks to see if the edition exists, assumes edition of zero is invalid\r\n   */\r\n  function editionExists(uint256 _editionNumber) public view returns (bool) {\r\n    if (_editionNumber == 0) {\r\n      return false;\r\n    }\r\n    EditionDetails storage editionNumber = editionNumberToEditionDetails[_editionNumber];\r\n    return editionNumber.editionNumber == _editionNumber;\r\n  }\r\n\r\n  /**\r\n   * @dev Lookup any optional commission split set for the edition\r\n   * @dev Both values will be zero if not present\r\n   */\r\n  function editionOptionalCommission(uint256 _editionNumber) public view returns (uint256 _rate, address _recipient) {\r\n    CommissionSplit storage commission = editionNumberToOptionalCommissionSplit[_editionNumber];\r\n    return (commission.rate, commission.recipient);\r\n  }\r\n\r\n  /**\r\n   * @dev Main entry point for looking up edition config/metadata\r\n   * @dev Reverts if invalid edition number provided\r\n   */\r\n  function detailsOfEdition(uint256 editionNumber)\r\n  public view\r\n  onlyRealEdition(editionNumber)\r\n  returns (\r\n    bytes32 _editionData,\r\n    uint256 _editionType,\r\n    uint256 _startDate,\r\n    uint256 _endDate,\r\n    address _artistAccount,\r\n    uint256 _artistCommission,\r\n    uint256 _priceInWei,\r\n    string _tokenURI,\r\n    uint256 _totalSupply,\r\n    uint256 _totalAvailable,\r\n    bool _active\r\n  ) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[editionNumber];\r\n    return (\r\n    _editionDetails.editionData,\r\n    _editionDetails.editionType,\r\n    _editionDetails.startDate,\r\n    _editionDetails.endDate,\r\n    _editionDetails.artistAccount,\r\n    _editionDetails.artistCommission,\r\n    _editionDetails.priceInWei,\r\n    Strings.strConcat(tokenBaseURI, _editionDetails.tokenURI),\r\n    _editionDetails.totalSupply,\r\n    _editionDetails.totalAvailable,\r\n    _editionDetails.active\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Lookup a tokens common identifying characteristics\r\n   * @dev Reverts if invalid token ID provided\r\n   */\r\n  function tokenData(uint256 _tokenId)\r\n  public view\r\n  onlyValidTokenId(_tokenId)\r\n  returns (\r\n    uint256 _editionNumber,\r\n    uint256 _editionType,\r\n    bytes32 _editionData,\r\n    string _tokenURI,\r\n    address _owner\r\n  ) {\r\n    uint256 editionNumber = tokenIdToEditionNumber[_tokenId];\r\n    EditionDetails storage editionDetails = editionNumberToEditionDetails[editionNumber];\r\n    return (\r\n    editionNumber,\r\n    editionDetails.editionType,\r\n    editionDetails.editionData,\r\n    tokenURI(_tokenId),\r\n    ownerOf(_tokenId)\r\n    );\r\n  }\r\n\r\n  function tokenURI(uint256 _tokenId) public view onlyValidTokenId(_tokenId) returns (string) {\r\n    return Strings.strConcat(tokenBaseURI, tokenURIs[_tokenId]);\r\n  }\r\n\r\n  function tokenURISafe(uint256 _tokenId) public view returns (string) {\r\n    return Strings.strConcat(tokenBaseURI, tokenURIs[_tokenId]);\r\n  }\r\n\r\n  function purchaseDatesToken(uint256 _tokenId) public view returns (uint256 _startDate, uint256 _endDate) {\r\n    uint256 _editionNumber = tokenIdToEditionNumber[_tokenId];\r\n    return purchaseDatesEdition(_editionNumber);\r\n  }\r\n\r\n  function priceInWeiToken(uint256 _tokenId) public view returns (uint256 _priceInWei) {\r\n    uint256 _editionNumber = tokenIdToEditionNumber[_tokenId];\r\n    return priceInWeiEdition(_editionNumber);\r\n  }\r\n\r\n  //////////////////////////\r\n  // Edition config query //\r\n  //////////////////////////\r\n\r\n  function editionData(uint256 _editionNumber) public view returns (bytes32) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return _editionDetails.editionData;\r\n  }\r\n\r\n  function editionType(uint256 _editionNumber) public view returns (uint256) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return _editionDetails.editionType;\r\n  }\r\n\r\n  function purchaseDatesEdition(uint256 _editionNumber) public view returns (uint256 _startDate, uint256 _endDate) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return (\r\n    _editionDetails.startDate,\r\n    _editionDetails.endDate\r\n    );\r\n  }\r\n\r\n  function artistCommission(uint256 _editionNumber) public view returns (address _artistAccount, uint256 _artistCommission) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return (\r\n    _editionDetails.artistAccount,\r\n    _editionDetails.artistCommission\r\n    );\r\n  }\r\n\r\n  function priceInWeiEdition(uint256 _editionNumber) public view returns (uint256 _priceInWei) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return _editionDetails.priceInWei;\r\n  }\r\n\r\n  function tokenURIEdition(uint256 _editionNumber) public view returns (string) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return Strings.strConcat(tokenBaseURI, _editionDetails.tokenURI);\r\n  }\r\n\r\n  function editionActive(uint256 _editionNumber) public view returns (bool) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return _editionDetails.active;\r\n  }\r\n\r\n  function totalRemaining(uint256 _editionNumber) public view returns (uint256) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return _editionDetails.totalAvailable.sub(_editionDetails.totalSupply);\r\n  }\r\n\r\n  function totalAvailableEdition(uint256 _editionNumber) public view returns (uint256) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return _editionDetails.totalAvailable;\r\n  }\r\n\r\n  function totalSupplyEdition(uint256 _editionNumber) public view returns (uint256) {\r\n    EditionDetails storage _editionDetails = editionNumberToEditionDetails[_editionNumber];\r\n    return _editionDetails.totalSupply;\r\n  }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"updateActive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"priceInWeiToken\",\"outputs\":[{\"name\":\"_priceInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_koCommissionAccount\",\"type\":\"address\"}],\"name\":\"updateKoCommissionAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"editionData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBaseURI\",\"type\":\"string\"}],\"name\":\"updateTokenBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"uint8\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPurchaseValueInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_startDate\",\"type\":\"uint256\"}],\"name\":\"updateStartDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"artistCommission\",\"outputs\":[{\"name\":\"_artistAccount\",\"type\":\"address\"},{\"name\":\"_artistCommission\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"tokenURIEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNumberAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"uint8\"}],\"name\":\"addAddressToAccessControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"priceInWeiEdition\",\"outputs\":[{\"name\":\"_priceInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBaseURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateArtistCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"editionType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"purchaseDatesEdition\",\"outputs\":[{\"name\":\"_startDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_artistsAccount\",\"type\":\"address\"}],\"name\":\"artistsEditions\",\"outputs\":[{\"name\":\"_editionNumbers\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"totalAvailableEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"koCommissionAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"editionNumber\",\"type\":\"uint256\"}],\"name\":\"detailsOfEdition\",\"outputs\":[{\"name\":\"_editionData\",\"type\":\"bytes32\"},{\"name\":\"_editionType\",\"type\":\"uint256\"},{\"name\":\"_startDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"},{\"name\":\"_artistAccount\",\"type\":\"address\"},{\"name\":\"_artistCommission\",\"type\":\"uint256\"},{\"name\":\"_priceInWei\",\"type\":\"uint256\"},{\"name\":\"_tokenURI\",\"type\":\"string\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_totalAvailable\",\"type\":\"uint256\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"updateEditionTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"tokensOfEdition\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"underMint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_priceInWei\",\"type\":\"uint256\"}],\"name\":\"updatePriceInWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"editionOfTokenId\",\"outputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_editionData\",\"type\":\"bytes32\"},{\"name\":\"_editionType\",\"type\":\"uint256\"},{\"name\":\"_startDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"},{\"name\":\"_artistAccount\",\"type\":\"address\"},{\"name\":\"_artistCommission\",\"type\":\"uint256\"},{\"name\":\"_priceInWei\",\"type\":\"uint256\"},{\"name\":\"_tokenURI\",\"type\":\"string\"},{\"name\":\"_totalAvailable\",\"type\":\"uint256\"}],\"name\":\"createActiveEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_MINTER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"uint8\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"uint8\"}],\"name\":\"removeAddressFromAccessControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"updateOptionalCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_UNDER_MINTER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_editionData\",\"type\":\"bytes32\"},{\"name\":\"_editionType\",\"type\":\"uint256\"},{\"name\":\"_startDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"},{\"name\":\"_artistAccount\",\"type\":\"address\"},{\"name\":\"_artistCommission\",\"type\":\"uint256\"},{\"name\":\"_priceInWei\",\"type\":\"uint256\"},{\"name\":\"_tokenURI\",\"type\":\"string\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_totalAvailable\",\"type\":\"uint256\"}],\"name\":\"createInactivePreMintedEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highestEditionNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_editionData\",\"type\":\"bytes32\"},{\"name\":\"_editionType\",\"type\":\"uint256\"},{\"name\":\"_startDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"},{\"name\":\"_artistAccount\",\"type\":\"address\"},{\"name\":\"_artistCommission\",\"type\":\"uint256\"},{\"name\":\"_priceInWei\",\"type\":\"uint256\"},{\"name\":\"_tokenURI\",\"type\":\"string\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_totalAvailable\",\"type\":\"uint256\"}],\"name\":\"createActivePreMintedEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_artistAccount\",\"type\":\"address\"}],\"name\":\"updateArtistsAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenData\",\"outputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_editionType\",\"type\":\"uint256\"},{\"name\":\"_editionData\",\"type\":\"bytes32\"},{\"name\":\"_tokenURI\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"totalSupplyEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"purchaseDatesToken\",\"outputs\":[{\"name\":\"_startDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"editionActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"totalRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_totalAvailable\",\"type\":\"uint256\"}],\"name\":\"updateTotalAvailable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_KNOWN_ORIGIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"editionExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_editionType\",\"type\":\"uint256\"}],\"name\":\"updateEditionType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"editionOptionalCommission\",\"outputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"}],\"name\":\"updateEndDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_editionData\",\"type\":\"bytes32\"},{\"name\":\"_editionType\",\"type\":\"uint256\"},{\"name\":\"_startDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"},{\"name\":\"_artistAccount\",\"type\":\"address\"},{\"name\":\"_artistCommission\",\"type\":\"uint256\"},{\"name\":\"_priceInWei\",\"type\":\"uint256\"},{\"name\":\"_tokenURI\",\"type\":\"string\"},{\"name\":\"_totalAvailable\",\"type\":\"uint256\"}],\"name\":\"createInactiveEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"editionsOfType\",\"outputs\":[{\"name\":\"_editionNumbers\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNumberMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"updateTotalSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURISafe\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_priceInWei\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_editionData\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_editionType\",\"type\":\"uint256\"}],\"name\":\"EditionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]", "ContractName": "KnownOriginDigitalAssetV2", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://9557310484a4901fa50436287b7369c43deec69f09addd0e62554d1d78987c56"}