{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUnionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\n// Uncomment this line to use console.log\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\n\\ninterface MixInterface {\\n    function transferToTemVault(uint usdtAmount) external;\\n}\\n\\ninterface IUnionFactory {\\n    function parameters()\\n        external\\n        view\\n        returns (\\n            string memory name,\\n            string memory symbol,\\n            string memory url,\\n            address factory,\\n            address unionAccount,\\n            IUniswapV2Router02 pancakeRouter,\\n            IERC20 usdt,\\n            MixInterface iMixInterface\\n        );\\n\\n    function initializeParameters()\\n        external\\n        view\\n        returns (\\n            address foundationAccount,\\n            address marketAccount,\\n            address communityAccount,\\n            address defaultBoundAccount,\\n            IERC20 APi,\\n            IERC20 unionCoin,\\n            address withdrawFeeReceiver\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FinancialMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary FinancialMath {\\r\\n    struct Financial {\\r\\n        uint no;\\r\\n        address owner;\\r\\n        uint status;\\r\\n        uint financialType;\\r\\n        uint financialAmount;\\r\\n        uint amountInterest;\\r\\n        uint withdrawAmount;\\r\\n        uint startTime;\\r\\n        uint startDays;\\r\\n        uint lastWithdrawTime;\\r\\n        uint cycle;\\r\\n    }\\r\\n\\r\\n    struct CalPendingAmountParmeter1 {\\r\\n        uint cycleTime;\\r\\n        uint maxCycle;\\r\\n        uint financialInterestRateBase;\\r\\n    }\\r\\n\\r\\n    struct CalPendingAmountParmeter2 {\\r\\n        uint lastWithdrawTime;\\r\\n        uint exitAmount;\\r\\n        uint withdrawAmount;\\r\\n        uint invitePendingAmount;\\r\\n    }\\r\\n\\r\\n    function getCurrentFinancialPendingReward(\\r\\n        Financial[] memory financials,\\r\\n        mapping(uint => uint) storage financialInterestRate,\\r\\n        CalPendingAmountParmeter1 memory parameter1,\\r\\n        CalPendingAmountParmeter2 memory parameter2\\r\\n    ) public view returns (uint, uint, uint) {\\r\\n        if (parameter2.lastWithdrawTime + 86400 > block.timestamp) {\\r\\n            return (\\r\\n                parameter2.invitePendingAmount,\\r\\n                parameter2.invitePendingAmount,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        if (\\r\\n            parameter2.withdrawAmount + parameter2.invitePendingAmount >=\\r\\n            parameter2.exitAmount\\r\\n        ) {\\r\\n            return (\\r\\n                parameter2.invitePendingAmount,\\r\\n                parameter2.invitePendingAmount,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        uint pendingReward;\\r\\n        for (uint i = 0; i < financials.length; i++) {\\r\\n            Financial memory financial = financials[i];\\r\\n            if (financial.status != 0) {\\r\\n                continue;\\r\\n            }\\r\\n            uint currentDays = (block.timestamp - financial.lastWithdrawTime) /\\r\\n                86400;\\r\\n            if (currentDays == 0) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            bool endCalculateReward;\\r\\n            uint singleFinancialPendingReward;\\r\\n            for (uint j = 1; j <= currentDays; j++) {\\r\\n                if (j == 1) {\\r\\n                    singleFinancialPendingReward = 0;\\r\\n                }\\r\\n                uint currentCycle = (financial.startDays + j) /\\r\\n                    parameter1.cycleTime;\\r\\n                if ((financial.startDays + j) % parameter1.cycleTime != 0) {\\r\\n                    currentCycle += 1;\\r\\n                }\\r\\n                if (currentCycle >= parameter1.maxCycle) {\\r\\n                    currentCycle = parameter1.maxCycle;\\r\\n                }\\r\\n                uint financialPendingReward = (financial.financialAmount *\\r\\n                    financialInterestRate[currentCycle]) /\\r\\n                    parameter1.financialInterestRateBase;\\r\\n                if (\\r\\n                    financialPendingReward +\\r\\n                        financial.withdrawAmount +\\r\\n                        singleFinancialPendingReward >=\\r\\n                    financial.amountInterest\\r\\n                ) {\\r\\n                    financialPendingReward =\\r\\n                        financial.amountInterest -\\r\\n                        financial.withdrawAmount -\\r\\n                        singleFinancialPendingReward;\\r\\n\\r\\n                    if (\\r\\n                        parameter2.withdrawAmount +\\r\\n                            parameter2.invitePendingAmount +\\r\\n                            financialPendingReward +\\r\\n                            pendingReward >=\\r\\n                        parameter2.exitAmount\\r\\n                    ) {\\r\\n                        financialPendingReward =\\r\\n                            parameter2.exitAmount -\\r\\n                            parameter2.withdrawAmount -\\r\\n                            parameter2.invitePendingAmount -\\r\\n                            pendingReward;\\r\\n                        pendingReward += financialPendingReward;\\r\\n                        endCalculateReward = true;\\r\\n                        break;\\r\\n                    }\\r\\n                    pendingReward += financialPendingReward;\\r\\n                    break;\\r\\n                }\\r\\n                if (\\r\\n                    parameter2.withdrawAmount +\\r\\n                        parameter2.invitePendingAmount +\\r\\n                        financialPendingReward +\\r\\n                        singleFinancialPendingReward >=\\r\\n                    parameter2.exitAmount\\r\\n                ) {\\r\\n                    financialPendingReward =\\r\\n                        parameter2.exitAmount -\\r\\n                        parameter2.withdrawAmount -\\r\\n                        parameter2.invitePendingAmount -\\r\\n                        singleFinancialPendingReward;\\r\\n                    pendingReward += financialPendingReward;\\r\\n                    endCalculateReward = true;\\r\\n                    break;\\r\\n                }\\r\\n                pendingReward += financialPendingReward;\\r\\n                singleFinancialPendingReward += financialPendingReward;\\r\\n                if (\\r\\n                    parameter2.withdrawAmount +\\r\\n                        parameter2.invitePendingAmount +\\r\\n                        pendingReward >=\\r\\n                    parameter2.exitAmount\\r\\n                ) {\\r\\n                    pendingReward =\\r\\n                        parameter2.exitAmount -\\r\\n                        parameter2.withdrawAmount -\\r\\n                        parameter2.invitePendingAmount;\\r\\n                    endCalculateReward = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            if (endCalculateReward) {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return (\\r\\n            parameter2.invitePendingAmount + pendingReward,\\r\\n            parameter2.invitePendingAmount,\\r\\n            pendingReward\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function withdrawCurrentFinancialReward(\\r\\n        Financial[] storage financials,\\r\\n        mapping(uint => uint) storage financialInterestRate,\\r\\n        CalPendingAmountParmeter1 memory parameter1,\\r\\n        CalPendingAmountParmeter2 memory parameter2\\r\\n    ) public returns (uint, uint, uint) {\\r\\n        if (parameter2.lastWithdrawTime + 86400 > block.timestamp) {\\r\\n            return (\\r\\n                parameter2.invitePendingAmount,\\r\\n                parameter2.invitePendingAmount,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        if (\\r\\n            parameter2.withdrawAmount + parameter2.invitePendingAmount >=\\r\\n            parameter2.exitAmount\\r\\n        ) {\\r\\n            endCurrentFinancial(financials);\\r\\n            return (\\r\\n                parameter2.invitePendingAmount,\\r\\n                parameter2.invitePendingAmount,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        uint pendingReward;\\r\\n        for (uint i = 0; i < financials.length; i++) {\\r\\n            Financial memory financial = financials[i];\\r\\n            if (financial.status != 0) {\\r\\n                continue;\\r\\n            }\\r\\n            uint currentDays = (block.timestamp - financial.lastWithdrawTime) /\\r\\n                86400;\\r\\n            if (currentDays == 0) {\\r\\n                continue;\\r\\n            }\\r\\n            bool endCalculateReward;\\r\\n            uint singleFinancialPendingReward;\\r\\n            for (uint j = 1; j <= currentDays; j++) {\\r\\n                if (j == 1) {\\r\\n                    singleFinancialPendingReward = 0;\\r\\n                }\\r\\n                uint currentCycle = (financial.startDays + j) /\\r\\n                    parameter1.cycleTime;\\r\\n                if ((financial.startDays + j) % parameter1.cycleTime != 0) {\\r\\n                    currentCycle += 1;\\r\\n                }\\r\\n                if (currentCycle >= parameter1.maxCycle) {\\r\\n                    currentCycle = parameter1.maxCycle;\\r\\n                }\\r\\n                uint financialPendingReward = (financial.financialAmount *\\r\\n                    financialInterestRate[currentCycle]) /\\r\\n                    parameter1.financialInterestRateBase;\\r\\n\\r\\n                if (\\r\\n                    financialPendingReward +\\r\\n                        financial.withdrawAmount +\\r\\n                        singleFinancialPendingReward >=\\r\\n                    financial.amountInterest\\r\\n                ) {\\r\\n                    financialPendingReward =\\r\\n                        financial.amountInterest -\\r\\n                        financial.withdrawAmount -\\r\\n                        singleFinancialPendingReward;\\r\\n\\r\\n                    if (\\r\\n                        parameter2.withdrawAmount +\\r\\n                            parameter2.invitePendingAmount +\\r\\n                            financialPendingReward +\\r\\n                            pendingReward >=\\r\\n                        parameter2.exitAmount\\r\\n                    ) {\\r\\n                        financialPendingReward =\\r\\n                            parameter2.exitAmount -\\r\\n                            parameter2.withdrawAmount -\\r\\n                            parameter2.invitePendingAmount -\\r\\n                            pendingReward;\\r\\n\\r\\n                        pendingReward += financialPendingReward;\\r\\n\\r\\n                        singleFinancialPendingReward += financialPendingReward;\\r\\n\\r\\n                        updateCurrentFinancial(\\r\\n                            financials[i],\\r\\n                            1,\\r\\n                            singleFinancialPendingReward,\\r\\n                            j,\\r\\n                            currentCycle\\r\\n                        );\\r\\n\\r\\n                        endCurrentFinancial(financials);\\r\\n                        endCalculateReward = true;\\r\\n                        break;\\r\\n                    }\\r\\n\\r\\n                    singleFinancialPendingReward += financialPendingReward;\\r\\n\\r\\n                    updateCurrentFinancial(\\r\\n                        financials[i],\\r\\n                        1,\\r\\n                        singleFinancialPendingReward,\\r\\n                        j,\\r\\n                        currentCycle\\r\\n                    );\\r\\n\\r\\n                    pendingReward += financialPendingReward;\\r\\n                    break;\\r\\n                }\\r\\n                if (\\r\\n                    parameter2.withdrawAmount +\\r\\n                        parameter2.invitePendingAmount +\\r\\n                        financialPendingReward +\\r\\n                        singleFinancialPendingReward >=\\r\\n                    parameter2.exitAmount\\r\\n                ) {\\r\\n                    financialPendingReward =\\r\\n                        parameter2.exitAmount -\\r\\n                        parameter2.withdrawAmount -\\r\\n                        parameter2.invitePendingAmount -\\r\\n                        singleFinancialPendingReward;\\r\\n\\r\\n                    pendingReward += financialPendingReward;\\r\\n\\r\\n                    singleFinancialPendingReward += financialPendingReward;\\r\\n\\r\\n                    updateCurrentFinancial(\\r\\n                        financials[i],\\r\\n                        1,\\r\\n                        singleFinancialPendingReward,\\r\\n                        j,\\r\\n                        currentCycle\\r\\n                    );\\r\\n\\r\\n                    endCurrentFinancial(financials);\\r\\n                    endCalculateReward = true;\\r\\n                    break;\\r\\n                }\\r\\n                pendingReward += financialPendingReward;\\r\\n                singleFinancialPendingReward += financialPendingReward;\\r\\n\\r\\n                if (\\r\\n                    parameter2.withdrawAmount +\\r\\n                        parameter2.invitePendingAmount +\\r\\n                        pendingReward >=\\r\\n                    parameter2.exitAmount\\r\\n                ) {\\r\\n                    pendingReward =\\r\\n                        parameter2.exitAmount -\\r\\n                        parameter2.withdrawAmount -\\r\\n                        parameter2.invitePendingAmount;\\r\\n\\r\\n                    updateCurrentFinancial(\\r\\n                        financials[i],\\r\\n                        1,\\r\\n                        singleFinancialPendingReward,\\r\\n                        j,\\r\\n                        currentCycle\\r\\n                    );\\r\\n\\r\\n                    endCurrentFinancial(financials);\\r\\n                    endCalculateReward = true;\\r\\n                    break;\\r\\n                }\\r\\n\\r\\n                if (j == currentDays) {\\r\\n                    updateCurrentFinancial(\\r\\n                        financials[i],\\r\\n                        0,\\r\\n                        singleFinancialPendingReward,\\r\\n                        j,\\r\\n                        currentCycle\\r\\n                    );\\r\\n                }\\r\\n            }\\r\\n            if (endCalculateReward) {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return (\\r\\n            parameter2.invitePendingAmount + pendingReward,\\r\\n            parameter2.invitePendingAmount,\\r\\n            pendingReward\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function endCurrentFinancial(Financial[] storage financials) public {\\r\\n        for (uint i = 0; i < financials.length; i++) {\\r\\n            if (financials[i].status == 0) {\\r\\n                financials[i].status = 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateCurrentFinancial(\\r\\n        Financial storage financial,\\r\\n        uint status,\\r\\n        uint singleFinancialPendingReward,\\r\\n        uint j,\\r\\n        uint currentCycle\\r\\n    ) public {\\r\\n        financial.status = status;\\r\\n        financial.withdrawAmount =\\r\\n            financial.withdrawAmount +\\r\\n            singleFinancialPendingReward;\\r\\n        financial.startDays = financial.startDays + j;\\r\\n        financial.lastWithdrawTime = block.timestamp;\\r\\n        financial.cycle = currentCycle;\\r\\n    }\\r\\n\\r\\n    function getContractFinancialPendingReward(\\r\\n        Financial[] memory financials,\\r\\n        uint financialInterestRate,\\r\\n        uint financialInterestRateBase,\\r\\n        CalPendingAmountParmeter2 memory parameter2\\r\\n    ) public view returns (uint, uint, uint) {\\r\\n        if (parameter2.lastWithdrawTime + 86400 > block.timestamp) {\\r\\n            return (\\r\\n                parameter2.invitePendingAmount,\\r\\n                parameter2.invitePendingAmount,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        if (\\r\\n            parameter2.withdrawAmount + parameter2.invitePendingAmount >=\\r\\n            parameter2.exitAmount\\r\\n        ) {\\r\\n            return (\\r\\n                parameter2.invitePendingAmount,\\r\\n                parameter2.invitePendingAmount,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        uint pendingReward;\\r\\n        for (uint i = 0; i < financials.length; i++) {\\r\\n            Financial memory financial = financials[i];\\r\\n            if (financial.status != 0) {\\r\\n                continue;\\r\\n            }\\r\\n            uint currentDays = (block.timestamp - financial.lastWithdrawTime) /\\r\\n                86400;\\r\\n            if (currentDays == 0) {\\r\\n                continue;\\r\\n            }\\r\\n            uint financialPendingReward = (financial.financialAmount *\\r\\n                currentDays *\\r\\n                financialInterestRate) / financialInterestRateBase;\\r\\n            if (\\r\\n                financialPendingReward + financial.withdrawAmount >=\\r\\n                financial.amountInterest\\r\\n            ) {\\r\\n                financialPendingReward =\\r\\n                    financial.amountInterest -\\r\\n                    financial.withdrawAmount;\\r\\n\\r\\n                if (\\r\\n                    parameter2.withdrawAmount +\\r\\n                        parameter2.invitePendingAmount +\\r\\n                        financialPendingReward +\\r\\n                        pendingReward >=\\r\\n                    parameter2.exitAmount\\r\\n                ) {\\r\\n                    financialPendingReward =\\r\\n                        parameter2.exitAmount -\\r\\n                        parameter2.withdrawAmount -\\r\\n                        parameter2.invitePendingAmount -\\r\\n                        pendingReward;\\r\\n                    pendingReward += financialPendingReward;\\r\\n                    break;\\r\\n                }\\r\\n\\r\\n                pendingReward += financialPendingReward;\\r\\n                continue;\\r\\n            }\\r\\n            if (\\r\\n                parameter2.withdrawAmount +\\r\\n                    parameter2.invitePendingAmount +\\r\\n                    financialPendingReward +\\r\\n                    pendingReward >=\\r\\n                parameter2.exitAmount\\r\\n            ) {\\r\\n                financialPendingReward =\\r\\n                    parameter2.exitAmount -\\r\\n                    parameter2.withdrawAmount -\\r\\n                    parameter2.invitePendingAmount -\\r\\n                    pendingReward;\\r\\n                pendingReward += financialPendingReward;\\r\\n                break;\\r\\n            }\\r\\n            pendingReward += financialPendingReward;\\r\\n            if (\\r\\n                parameter2.withdrawAmount +\\r\\n                    parameter2.invitePendingAmount +\\r\\n                    pendingReward >=\\r\\n                parameter2.exitAmount\\r\\n            ) {\\r\\n                pendingReward =\\r\\n                    parameter2.exitAmount -\\r\\n                    parameter2.withdrawAmount -\\r\\n                    parameter2.invitePendingAmount;\\r\\n\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return (\\r\\n            parameter2.invitePendingAmount + pendingReward,\\r\\n            parameter2.invitePendingAmount,\\r\\n            pendingReward\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function withdrawContractFinancialPendingReward(\\r\\n        Financial[] storage financials,\\r\\n        uint financialInterestRate,\\r\\n        uint financialInterestRateBase,\\r\\n        CalPendingAmountParmeter2 memory parameter2\\r\\n    ) public returns (uint, uint, uint) {\\r\\n        if (parameter2.lastWithdrawTime + 86400 > block.timestamp) {\\r\\n            return (\\r\\n                parameter2.invitePendingAmount,\\r\\n                parameter2.invitePendingAmount,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        if (\\r\\n            parameter2.withdrawAmount + parameter2.invitePendingAmount >=\\r\\n            parameter2.exitAmount\\r\\n        ) {\\r\\n            return (\\r\\n                parameter2.invitePendingAmount,\\r\\n                parameter2.invitePendingAmount,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        uint pendingReward;\\r\\n        for (uint i = 0; i < financials.length; i++) {\\r\\n            Financial memory financial = financials[i];\\r\\n            if (financial.status != 0) {\\r\\n                continue;\\r\\n            }\\r\\n            uint currentDays = (block.timestamp - financial.lastWithdrawTime) /\\r\\n                86400;\\r\\n            if (currentDays == 0) {\\r\\n                continue;\\r\\n            }\\r\\n            uint financialPendingReward = (financial.financialAmount *\\r\\n                currentDays *\\r\\n                financialInterestRate) / financialInterestRateBase;\\r\\n            if (\\r\\n                financialPendingReward + financial.withdrawAmount >=\\r\\n                financial.amountInterest\\r\\n            ) {\\r\\n                financialPendingReward =\\r\\n                    financial.amountInterest -\\r\\n                    financial.withdrawAmount;\\r\\n\\r\\n                if (\\r\\n                    parameter2.withdrawAmount +\\r\\n                        parameter2.invitePendingAmount +\\r\\n                        financialPendingReward +\\r\\n                        pendingReward >=\\r\\n                    parameter2.exitAmount\\r\\n                ) {\\r\\n                    financialPendingReward =\\r\\n                        parameter2.exitAmount -\\r\\n                        parameter2.withdrawAmount -\\r\\n                        parameter2.invitePendingAmount -\\r\\n                        pendingReward;\\r\\n\\r\\n                    pendingReward += financialPendingReward;\\r\\n\\r\\n                    currentDays =\\r\\n                        (financialPendingReward * financialInterestRateBase) /\\r\\n                        financialInterestRate /\\r\\n                        financial.financialAmount;\\r\\n\\r\\n                    updateCurrentFinancial(\\r\\n                        financials[i],\\r\\n                        1,\\r\\n                        financialPendingReward,\\r\\n                        currentDays,\\r\\n                        0\\r\\n                    );\\r\\n                    endCurrentFinancial(financials);\\r\\n                    break;\\r\\n                }\\r\\n\\r\\n                pendingReward += financialPendingReward;\\r\\n\\r\\n                currentDays =\\r\\n                    (financialPendingReward * financialInterestRateBase) /\\r\\n                    financialInterestRate /\\r\\n                    financial.financialAmount;\\r\\n\\r\\n                updateCurrentFinancial(\\r\\n                    financials[i],\\r\\n                    1,\\r\\n                    financialPendingReward,\\r\\n                    currentDays,\\r\\n                    0\\r\\n                );\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n            if (\\r\\n                parameter2.withdrawAmount +\\r\\n                    parameter2.invitePendingAmount +\\r\\n                    financialPendingReward +\\r\\n                    pendingReward >=\\r\\n                parameter2.exitAmount\\r\\n            ) {\\r\\n                financialPendingReward =\\r\\n                    parameter2.exitAmount -\\r\\n                    parameter2.withdrawAmount -\\r\\n                    parameter2.invitePendingAmount -\\r\\n                    pendingReward;\\r\\n\\r\\n                pendingReward += financialPendingReward;\\r\\n\\r\\n                currentDays =\\r\\n                    (financialPendingReward * financialInterestRateBase) /\\r\\n                    financialInterestRate /\\r\\n                    financial.financialAmount;\\r\\n\\r\\n                updateCurrentFinancial(\\r\\n                    financials[i],\\r\\n                    1,\\r\\n                    financialPendingReward,\\r\\n                    currentDays,\\r\\n                    0\\r\\n                );\\r\\n                endCurrentFinancial(financials);\\r\\n                break;\\r\\n            }\\r\\n            pendingReward += financialPendingReward;\\r\\n            if (\\r\\n                parameter2.withdrawAmount +\\r\\n                    parameter2.invitePendingAmount +\\r\\n                    pendingReward >=\\r\\n                parameter2.exitAmount\\r\\n            ) {\\r\\n                pendingReward =\\r\\n                    parameter2.exitAmount -\\r\\n                    parameter2.withdrawAmount -\\r\\n                    parameter2.invitePendingAmount;\\r\\n\\r\\n                updateCurrentFinancial(\\r\\n                    financials[i],\\r\\n                    1,\\r\\n                    financialPendingReward,\\r\\n                    currentDays,\\r\\n                    0\\r\\n                );\\r\\n                endCurrentFinancial(financials);\\r\\n\\r\\n                break;\\r\\n            }\\r\\n            updateCurrentFinancial(\\r\\n                financials[i],\\r\\n                0,\\r\\n                financialPendingReward,\\r\\n                currentDays,\\r\\n                0\\r\\n            );\\r\\n        }\\r\\n        return (\\r\\n            parameter2.invitePendingAmount + pendingReward,\\r\\n            parameter2.invitePendingAmount,\\r\\n            pendingReward\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Union.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/IUnionFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"./libraries/FinancialMath.sol\\\";\\n\\nstruct Referrer {\\n    address owner;\\n    address[] oneNextGenerations;\\n    address[] twoNextGenerations;\\n    address[] threeNextGenerations;\\n}\\n\\nstruct FinancialInterest {\\n    // 1-financial management;2-contract financial management\\n    uint financialType;\\n    uint investAmount;\\n    uint exitAmount;\\n    uint withdrawAmount;\\n    uint lastWithdrawTime;\\n}\\n\\nstruct InviteInterest {\\n    uint withdrawAmount;\\n    uint pendingAmount;\\n}\\n\\nstruct FinancialInfo {\\n    uint financialType;\\n    uint investAmount;\\n    uint exitAmount;\\n    uint withdrawAmount;\\n    uint pendingAmount;\\n    uint lastWithdrawTime;\\n    uint nextWithdrawTime;\\n    uint financialPendingAmount;\\n    uint invitePendingAmount;\\n}\\n\\ncontract Union is Ownable, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using FinancialMath for FinancialMath.Financial;\\n\\n    string public name;\\n    string public symbol;\\n    string public url;\\n    address public unionFactory;\\n    address public unionAccount;\\n\\n    uint public buyAmountBase = 100 * 1e18;\\n\\n    bool public isInitialize;\\n\\n    IERC20 public usdt;\\n    IUniswapV2Router02 public pancakeRouter;\\n\\n    uint public financialNo = 1;\\n\\n    address public defaultBoundAccount;\\n    mapping(address => bool) public bound;\\n    mapping(address => address) public referrer;\\n    mapping(address => Referrer) public referrers;\\n    mapping(address => mapping(uint => InviteInterest))\\n        public inviteInterestInfos;\\n\\n    mapping(address => mapping(uint => FinancialMath.Financial[]))\\n        public financialInfos;\\n    mapping(address => mapping(uint => FinancialInterest))\\n        public financialInterestInfos;\\n\\n    bool public buyBackSwitch = false;\\n\\n    uint public unionRatio = 95;\\n    uint public buyBackAPiCoinRatio = 2;\\n    uint public foundationRatio = 1;\\n    uint public marketRatio = 1;\\n    uint public communityRatio = 1;\\n    uint public ratioBase = 100;\\n\\n    address public foundationAccount;\\n    address public marketAccount;\\n    address public communityAccount;\\n\\n    IERC20 public APi;\\n    IERC20 public unionCoin;\\n\\n    uint public financialManagementCycle = 15;\\n\\n    mapping(uint => uint) public financialInterestRate;\\n    uint public financialInterestRateBase = 1000;\\n\\n    uint public withdrawFee = 5;\\n    address public withdrawFeeReceiver;\\n\\n    uint public lastGenerationQuali = 1000 * 1e18;\\n    uint public oneLastGenerationRation = 30;\\n    uint public twoLastGenerationRation = 30;\\n    uint public threeLastGenerationRation = 30;\\n\\n    mapping(uint => uint) public nextGenerationRatio;\\n\\n    uint public generationRatioBase = 1000;\\n\\n    uint public exitCycle = 2;\\n    uint public exitFee = 50;\\n    uint public exitFeeBase = 1000;\\n\\n    uint public exitInterestTimes = 3;\\n\\n    uint public contractfinancialInterestRate = 10;\\n\\n    mapping(address => bool) public blockUsers;\\n\\n    bool public funSwitch;\\n\\n    MixInterface public iMixInterface;\\n\\n    modifier onlyFactory() {\\n        require(msg.sender == unionFactory, \\\"n f\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        (\\n            name,\\n            symbol,\\n            url,\\n            unionFactory,\\n            unionAccount,\\n            pancakeRouter,\\n            usdt,\\n            iMixInterface\\n        ) = IUnionFactory(msg.sender).parameters();\\n        _transferOwnership(unionAccount);\\n\\n        financialInterestRate[1] = 6;\\n        financialInterestRate[2] = 7;\\n        financialInterestRate[3] = 8;\\n        financialInterestRate[4] = 9;\\n        financialInterestRate[5] = 10;\\n        financialInterestRate[6] = 11;\\n        financialInterestRate[7] = 12;\\n        financialInterestRate[8] = 13;\\n        financialInterestRate[9] = 14;\\n        financialInterestRate[10] = 15;\\n\\n        nextGenerationRatio[1] = 200;\\n        nextGenerationRatio[2] = 100;\\n        nextGenerationRatio[3] = 50;\\n        nextGenerationRatio[4] = 30;\\n        nextGenerationRatio[5] = 30;\\n        nextGenerationRatio[6] = 30;\\n    }\\n\\n    function initialize() external {\\n        require(tx.origin == unionFactory, \\\"n f\\\");\\n        require(!isInitialize, \\\"a i\\\");\\n        (\\n            foundationAccount,\\n            marketAccount,\\n            communityAccount,\\n            defaultBoundAccount,\\n            APi,\\n            unionCoin,\\n            withdrawFeeReceiver\\n        ) = IUnionFactory(msg.sender).initializeParameters();\\n        isInitialize = true;\\n    }\\n\\n    function balance(address token) public view returns (uint256) {\\n        if (token == address(0)) {\\n            return address(this).balance;\\n        }\\n        return IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function withdrawErc20(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) public onlyOwner {\\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\\n        require(tokenBalance >= amount, \\\"e\\\");\\n        IERC20(token).safeTransfer(to, amount);\\n    }\\n\\n    function setFunSwithc(bool _funSwitch) public onlyOwner {\\n        funSwitch = _funSwitch;\\n    }\\n\\n    function setExitTimes(uint _exitTimes) public onlyOwner {\\n        exitInterestTimes = _exitTimes;\\n    }\\n\\n    function setFinancialInterestRate(\\n        uint _cycle,\\n        uint _rate\\n    ) public onlyOwner {\\n        financialInterestRate[_cycle] = _rate;\\n    }\\n\\n    function setContractRate(uint _rate) public onlyOwner {\\n        contractfinancialInterestRate = _rate;\\n    }\\n\\n    function setFinancialManagementCycle(\\n        uint _financialManagementCycle\\n    ) public onlyOwner {\\n        financialManagementCycle = _financialManagementCycle;\\n    }\\n\\n    function setUnionCoin(IERC20 _uninoCoin) public onlyOwner {\\n        unionCoin = _uninoCoin;\\n    }\\n\\n    function setLastGenRatio(\\n        uint _oneGenRatio,\\n        uint _twoGenRatio,\\n        uint _threeGenRatio\\n    ) public onlyOwner {\\n        oneLastGenerationRation = _oneGenRatio;\\n        twoLastGenerationRation = _twoGenRatio;\\n        threeLastGenerationRation = _threeGenRatio;\\n    }\\n\\n    function setNextGenRatio(uint _nextGen, uint _ratio) public onlyOwner {\\n        nextGenerationRatio[_nextGen] = _ratio;\\n    }\\n\\n    function setBlockUser(address account, bool state) public onlyOwner {\\n        blockUsers[account] = state;\\n    }\\n\\n    function setFactoryAdds(\\n        address _add1,\\n        address _add2,\\n        address _add3\\n    ) public onlyFactory {\\n        foundationAccount = _add1;\\n        marketAccount = _add2;\\n        communityAccount = _add3;\\n    }\\n\\n    function transferFactory(address _newFactory) public onlyFactory {\\n        unionFactory = _newFactory;\\n    }\\n\\n    function setMix(MixInterface _mix) public onlyFactory {\\n        iMixInterface = _mix;\\n    }\\n\\n    function setBuyBackSwitch(bool _buyBackSwitch) public onlyFactory {\\n        buyBackSwitch = _buyBackSwitch;\\n    }\\n\\n    function getReferers(\\n        address account,\\n        uint financialType\\n    ) public view returns (address[] memory, uint[] memory) {\\n        address[] memory addresses = referrers[account].oneNextGenerations;\\n        uint[] memory investAmount = new uint[](addresses.length);\\n        for (uint i = 0; i < addresses.length; i++) {\\n            investAmount[i] = financialInterestInfos[addresses[i]][\\n                financialType\\n            ].investAmount;\\n        }\\n        return (addresses, investAmount);\\n    }\\n\\n    function getFinancialInfos(\\n        uint financialType\\n    ) public view returns (FinancialMath.Financial[] memory) {\\n        return financialInfos[msg.sender][financialType];\\n    }\\n\\n    function boundReferrer(address _referrer) external {\\n        require(!bound[msg.sender], \\\"a b\\\");\\n        if (_referrer == address(0)) {\\n            _referrer = defaultBoundAccount;\\n        } else {\\n            require(bound[_referrer], \\\"r b\\\");\\n        }\\n        bound[msg.sender] = true;\\n        referrer[msg.sender] = _referrer;\\n        address[] memory addresses;\\n        referrers[msg.sender] = Referrer({\\n            owner: msg.sender,\\n            oneNextGenerations: addresses,\\n            twoNextGenerations: addresses,\\n            threeNextGenerations: addresses\\n        });\\n        _boundLastGeneration(msg.sender, _referrer);\\n    }\\n\\n    function buyFinancialManagement(\\n        uint buyAmount,\\n        uint financialType\\n    ) public nonReentrant {\\n        require(bound[msg.sender], \\\"a n b\\\");\\n        require(\\n            buyAmount % buyAmountBase == 0 && buyAmount / buyAmountBase >= 1,\\n            \\\"100U\\\"\\n        );\\n        _transfer1(buyAmount);\\n        FinancialMath.Financial[] storage financials = financialInfos[\\n            msg.sender\\n        ][financialType];\\n        financials.push(\\n            FinancialMath.Financial({\\n                no: financialNo,\\n                owner: msg.sender,\\n                status: 0,\\n                financialType: financialType,\\n                financialAmount: buyAmount,\\n                amountInterest: buyAmount * exitInterestTimes,\\n                withdrawAmount: 0,\\n                startTime: block.timestamp,\\n                startDays: 0,\\n                lastWithdrawTime: block.timestamp,\\n                cycle: 1\\n            })\\n        );\\n        financialNo++;\\n        financialInfos[msg.sender][financialType] = financials;\\n        FinancialInterest storage financialInterest = financialInterestInfos[\\n            msg.sender\\n        ][financialType];\\n        financialInterest.financialType = financialType;\\n        financialInterest.investAmount =\\n            financialInterest.investAmount +\\n            buyAmount;\\n        financialInterest.exitAmount =\\n            financialInterest.exitAmount +\\n            buyAmount *\\n            exitInterestTimes;\\n        financialInterest.lastWithdrawTime = block.timestamp;\\n        financialInterestInfos[msg.sender][financialType] = financialInterest;\\n    }\\n\\n    function getFinancialInfo(\\n        uint financialType\\n    ) public view returns (FinancialInfo memory financialInfo) {\\n        FinancialInterest memory financialInterest = financialInterestInfos[\\n            msg.sender\\n        ][financialType];\\n        InviteInterest memory inviteInterest = inviteInterestInfos[msg.sender][\\n            financialType\\n        ];\\n        uint allPending;\\n        uint invitePending;\\n        uint financialPending;\\n        if (financialType == 1) {\\n            (allPending, invitePending, financialPending) = FinancialMath\\n                .getCurrentFinancialPendingReward(\\n                    financialInfos[msg.sender][financialType],\\n                    financialInterestRate,\\n                    FinancialMath.CalPendingAmountParmeter1({\\n                        cycleTime: financialManagementCycle,\\n                        maxCycle: 10,\\n                        financialInterestRateBase: financialInterestRateBase\\n                    }),\\n                    FinancialMath.CalPendingAmountParmeter2({\\n                        lastWithdrawTime: financialInterest.lastWithdrawTime,\\n                        exitAmount: financialInterest.exitAmount,\\n                        withdrawAmount: financialInterest.withdrawAmount,\\n                        invitePendingAmount: inviteInterest.pendingAmount\\n                    })\\n                );\\n        } else {\\n            (allPending, invitePending, financialPending) = FinancialMath\\n                .getContractFinancialPendingReward(\\n                    financialInfos[msg.sender][financialType],\\n                    contractfinancialInterestRate,\\n                    financialInterestRateBase,\\n                    FinancialMath.CalPendingAmountParmeter2({\\n                        lastWithdrawTime: financialInterest.lastWithdrawTime,\\n                        exitAmount: financialInterest.exitAmount,\\n                        withdrawAmount: financialInterest.withdrawAmount,\\n                        invitePendingAmount: inviteInterest.pendingAmount\\n                    })\\n                );\\n        }\\n\\n        financialInfo.financialType = financialType;\\n        financialInfo.investAmount = financialInterest.investAmount;\\n        financialInfo.exitAmount = financialInterest.exitAmount;\\n        financialInfo.withdrawAmount = financialInterest.withdrawAmount;\\n        financialInfo.pendingAmount = allPending;\\n        financialInfo.lastWithdrawTime = financialInterest.lastWithdrawTime;\\n        financialInfo.nextWithdrawTime = block.timestamp -\\n            financialInterest.lastWithdrawTime >=\\n            86400\\n            ? 0\\n            : 86400 - (block.timestamp - financialInterest.lastWithdrawTime);\\n        financialInfo.financialPendingAmount = financialPending;\\n        financialInfo.invitePendingAmount = invitePending;\\n    }\\n\\n    function withdrawFinancialInterest(uint financialType) public nonReentrant {\\n        require(!funSwitch, \\\"ERROR: NOT SERVICES\\\");\\n        require(!blockUsers[msg.sender], \\\"b u\\\");\\n        FinancialInterest memory financialInterest = financialInterestInfos[\\n            msg.sender\\n        ][financialType];\\n        InviteInterest memory inviteInterest = inviteInterestInfos[msg.sender][\\n            financialType\\n        ];\\n        uint pendingReward;\\n        if (financialType == 1) {\\n            (, , pendingReward) = FinancialMath.withdrawCurrentFinancialReward(\\n                financialInfos[msg.sender][financialType],\\n                financialInterestRate,\\n                FinancialMath.CalPendingAmountParmeter1({\\n                    cycleTime: financialManagementCycle,\\n                    maxCycle: 10,\\n                    financialInterestRateBase: financialInterestRateBase\\n                }),\\n                FinancialMath.CalPendingAmountParmeter2({\\n                    lastWithdrawTime: financialInterest.lastWithdrawTime,\\n                    exitAmount: financialInterest.exitAmount,\\n                    withdrawAmount: financialInterest.withdrawAmount,\\n                    invitePendingAmount: inviteInterest.pendingAmount\\n                })\\n            );\\n        } else {\\n            (, , pendingReward) = FinancialMath\\n                .withdrawContractFinancialPendingReward(\\n                    financialInfos[msg.sender][financialType],\\n                    contractfinancialInterestRate,\\n                    financialInterestRateBase,\\n                    FinancialMath.CalPendingAmountParmeter2({\\n                        lastWithdrawTime: financialInterest.lastWithdrawTime,\\n                        exitAmount: financialInterest.exitAmount,\\n                        withdrawAmount: financialInterest.withdrawAmount,\\n                        invitePendingAmount: inviteInterest.pendingAmount\\n                    })\\n                );\\n        }\\n        require(pendingReward > 0, \\\"lt 0\\\");\\n        financialInterestInfos[msg.sender][financialType]\\n            .withdrawAmount += pendingReward;\\n        financialInterestInfos[msg.sender][financialType]\\n            .lastWithdrawTime = block.timestamp;\\n\\n        _addInviteReward(pendingReward, financialType);\\n\\n        uint unionCoinAmount = pendingReward;\\n        if (address(usdt) != address(unionCoin)) {\\n            unionCoinAmount = getUnionCoinAmount(pendingReward);\\n        }\\n\\n        unionCoin.transfer(\\n            withdrawFeeReceiver,\\n            (unionCoinAmount * withdrawFee) / ratioBase\\n        );\\n        unionCoin.transfer(\\n            msg.sender,\\n            (unionCoinAmount * (ratioBase - withdrawFee)) / ratioBase\\n        );\\n    }\\n\\n    function withdrawInviteReward(uint financialType) public nonReentrant {\\n        require(!funSwitch, \\\"ERROR: NOT SERVICES\\\");\\n        require(!blockUsers[msg.sender], \\\"b u\\\");\\n        InviteInterest memory inviteInterest = inviteInterestInfos[msg.sender][\\n            financialType\\n        ];\\n        require(inviteInterest.pendingAmount > 0, \\\"lt 0\\\");\\n        financialInterestInfos[msg.sender][financialType]\\n            .withdrawAmount += inviteInterest.pendingAmount;\\n        inviteInterestInfos[msg.sender][financialType].pendingAmount = 0;\\n        inviteInterestInfos[msg.sender][financialType]\\n            .withdrawAmount += inviteInterest.pendingAmount;\\n\\n        uint unionCoinAmount = inviteInterest.pendingAmount;\\n        if (address(usdt) != address(unionCoin)) {\\n            unionCoinAmount = getUnionCoinAmount(inviteInterest.pendingAmount);\\n        }\\n\\n        unionCoin.transfer(\\n            withdrawFeeReceiver,\\n            (unionCoinAmount * withdrawFee) / ratioBase\\n        );\\n        unionCoin.transfer(\\n            msg.sender,\\n            (unionCoinAmount * (ratioBase - withdrawFee)) / ratioBase\\n        );\\n    }\\n\\n    function cancleFinancial(uint no) public nonReentrant {\\n        for (uint i = 0; i < financialInfos[msg.sender][1].length; i++) {\\n            FinancialMath.Financial memory financial = financialInfos[\\n                msg.sender\\n            ][1][i];\\n            if (financial.no == no) {\\n                require(financial.status == 0, \\\"s e\\\");\\n                FinancialInterest\\n                    memory financialInterest = financialInterestInfos[\\n                        msg.sender\\n                    ][1];\\n                require(\\n                    (financialInterest.exitAmount -\\n                        financialInterest.withdrawAmount) >=\\n                        (financial.amountInterest - financial.withdrawAmount),\\n                    \\\"c n c\\\"\\n                );\\n                uint returnAmount;\\n                if (financial.cycle <= exitCycle) {\\n                    returnAmount = financial.financialAmount >=\\n                        financial.withdrawAmount\\n                        ? financial.financialAmount -\\n                            ((financial.financialAmount -\\n                                financial.withdrawAmount) * withdrawFee) /\\n                            ratioBase\\n                        : 0;\\n                } else {\\n                    returnAmount = financial.financialAmount;\\n                }\\n                require(returnAmount > 0, \\\"le 0\\\");\\n                usdt.safeTransfer(msg.sender, returnAmount);\\n                financialInfos[msg.sender][1][i].status = 2;\\n                financialInterestInfos[msg.sender][1].investAmount -= financial\\n                    .financialAmount;\\n                financialInterestInfos[msg.sender][1].exitAmount -= (financial\\n                    .amountInterest - financial.withdrawAmount);\\n            }\\n        }\\n    }\\n\\n    function _boundLastGeneration(\\n        address _account,\\n        address _referrer\\n    ) internal {\\n        for (uint i = 1; i < 4; i++) {\\n            Referrer storage referer = referrers[_referrer];\\n            if (i == 1) {\\n                address[] storage oneNextGeneration = referer\\n                    .oneNextGenerations;\\n                oneNextGeneration.push(_account);\\n                referrers[_referrer].oneNextGenerations = oneNextGeneration;\\n            }\\n            if (i == 2) {\\n                address[] storage twoNextGeneration = referer\\n                    .twoNextGenerations;\\n                twoNextGeneration.push(_account);\\n                referrers[_referrer].twoNextGenerations = twoNextGeneration;\\n            }\\n            if (i == 3) {\\n                address[] storage threeNextGeneration = referer\\n                    .threeNextGenerations;\\n                threeNextGeneration.push(_account);\\n                referrers[_referrer].threeNextGenerations = threeNextGeneration;\\n            }\\n            _referrer = referrer[_referrer];\\n            if (_referrer == address(0)) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _transfer1(uint buyAmount) internal {\\n        usdt.safeTransferFrom(\\n            msg.sender,\\n            address(iMixInterface),\\n            (buyAmount * unionRatio) / ratioBase\\n        );\\n        iMixInterface.transferToTemVault((buyAmount * unionRatio) / ratioBase);\\n        usdt.safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            (buyAmount * buyBackAPiCoinRatio) / ratioBase\\n        );\\n        if (buyBackSwitch) {\\n            _buyBackAPi((buyAmount * buyBackAPiCoinRatio) / ratioBase);\\n        } else {\\n            usdt.safeTransfer(\\n                foundationAccount,\\n                (buyAmount * buyBackAPiCoinRatio) / ratioBase\\n            );\\n        }\\n        usdt.safeTransferFrom(\\n            msg.sender,\\n            foundationAccount,\\n            (buyAmount * foundationRatio) / ratioBase\\n        );\\n        usdt.safeTransferFrom(\\n            msg.sender,\\n            marketAccount,\\n            (buyAmount * marketRatio) / ratioBase\\n        );\\n        usdt.safeTransferFrom(\\n            msg.sender,\\n            communityAccount,\\n            (buyAmount * communityRatio) / ratioBase\\n        );\\n    }\\n\\n    function _buyBackAPi(uint usdtAmount) internal {\\n        address[] memory path = new address[](2);\\n        path[0] = address(usdt);\\n        path[1] = address(APi);\\n        usdt.approve(address(pancakeRouter), usdtAmount);\\n        uint APiAmountBefore = balance(address(APi));\\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            usdtAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp + 360\\n        );\\n        uint APiAmountAfter = balance(address(APi));\\n\\n        (bool success, bytes memory returnData) = address(APi).call(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"burn(uint256)\\\")),\\n                (APiAmountAfter - APiAmountBefore)\\n            )\\n        );\\n        require(\\n            success &&\\n                (returnData.length == 0 || abi.decode(returnData, (bool))),\\n            \\\"B F\\\"\\n        );\\n    }\\n\\n    function _addInviteReward(uint pendingReward, uint financialType) internal {\\n        address lastferrer = msg.sender;\\n        for (uint i = 0; i < 6; i++) {\\n            address lastGeneration = referrer[lastferrer];\\n            if (lastGeneration == address(0)) {\\n                break;\\n            }\\n            uint inviteReward = (pendingReward * nextGenerationRatio[i + 1]) /\\n                generationRatioBase;\\n            _updateInviteReward(lastGeneration, financialType, inviteReward);\\n            lastferrer = lastGeneration;\\n        }\\n        _updateNextGeneration(\\n            referrers[msg.sender].oneNextGenerations,\\n            financialType,\\n            pendingReward,\\n            oneLastGenerationRation\\n        );\\n        _updateNextGeneration(\\n            referrers[msg.sender].twoNextGenerations,\\n            financialType,\\n            pendingReward,\\n            twoLastGenerationRation\\n        );\\n        _updateNextGeneration(\\n            referrers[msg.sender].threeNextGenerations,\\n            financialType,\\n            pendingReward,\\n            twoLastGenerationRation\\n        );\\n    }\\n\\n    function _updateNextGeneration(\\n        address[] memory nextGenerations,\\n        uint financialType,\\n        uint pendingReward,\\n        uint ratio\\n    ) internal {\\n        for (uint i = 0; i < nextGenerations.length; i++) {\\n            address nextGeneration = nextGenerations[i];\\n            FinancialInterest memory financialInterest = financialInterestInfos[\\n                nextGeneration\\n            ][financialType];\\n            if (\\n                financialInterest.exitAmount -\\n                    financialInterest.withdrawAmount <\\n                lastGenerationQuali * exitInterestTimes\\n            ) {\\n                continue;\\n            }\\n            uint inviteReward = (pendingReward * ratio) / generationRatioBase;\\n            _updateInviteReward(nextGeneration, financialType, inviteReward);\\n        }\\n    }\\n\\n    function _updateInviteReward(\\n        address user,\\n        uint financialType,\\n        uint inviteReward\\n    ) internal {\\n        FinancialInterest memory financialInterest = financialInterestInfos[\\n            user\\n        ][financialType];\\n        if (\\n            financialInterest.withdrawAmount + inviteReward >=\\n            financialInterest.exitAmount\\n        ) {\\n            inviteReward =\\n                financialInterest.exitAmount -\\n                financialInterest.withdrawAmount;\\n        }\\n        inviteInterestInfos[user][financialType].pendingAmount += inviteReward;\\n    }\\n\\n    function getUnionCoinAmount(uint usdtAmount) public view returns (uint) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(usdt);\\n        path[1] = address(unionCoin);\\n        uint[] memory amounts = pancakeRouter.getAmountsOut(usdtAmount, path);\\n        require(amounts.length > 1, \\\"am\\\");\\n        return amounts[1];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/FinancialMath.sol\": {\r\n        \"FinancialMath\": \"0x8239d95273b35be2ead22e4d440b395a43bcd159\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APi\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockUsers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"boundReferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyAmountBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackAPiCoinRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackSwitch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"}],\"name\":\"buyFinancialManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"no\",\"type\":\"uint256\"}],\"name\":\"cancleFinancial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractfinancialInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultBoundAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitFeeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitInterestTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"financialInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"no\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"financialAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"financialInterestInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"financialInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"financialInterestRateBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"financialManagementCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"financialNo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foundationAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foundationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"funSwitch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generationRatioBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"}],\"name\":\"getFinancialInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"financialPendingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invitePendingAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct FinancialInfo\",\"name\":\"financialInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"}],\"name\":\"getFinancialInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"no\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"financialAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"}],\"internalType\":\"struct FinancialMath.Financial[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"}],\"name\":\"getReferers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"getUnionCoinAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iMixInterface\",\"outputs\":[{\"internalType\":\"contract MixInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inviteInterestInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastGenerationQuali\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextGenerationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneLastGenerationRation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ratioBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setBlockUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_buyBackSwitch\",\"type\":\"bool\"}],\"name\":\"setBuyBackSwitch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setContractRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exitTimes\",\"type\":\"uint256\"}],\"name\":\"setExitTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_add2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_add3\",\"type\":\"address\"}],\"name\":\"setFactoryAdds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setFinancialInterestRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_financialManagementCycle\",\"type\":\"uint256\"}],\"name\":\"setFinancialManagementCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_funSwitch\",\"type\":\"bool\"}],\"name\":\"setFunSwithc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_oneGenRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_twoGenRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_threeGenRatio\",\"type\":\"uint256\"}],\"name\":\"setLastGenRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MixInterface\",\"name\":\"_mix\",\"type\":\"address\"}],\"name\":\"setMix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextGen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"setNextGenRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_uninoCoin\",\"type\":\"address\"}],\"name\":\"setUnionCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threeLastGenerationRation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFactory\",\"type\":\"address\"}],\"name\":\"transferFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twoLastGenerationRation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unionAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unionCoin\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unionFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unionRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"url\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"}],\"name\":\"withdrawFinancialInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"financialType\",\"type\":\"uint256\"}],\"name\":\"withdrawInviteReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Union", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}