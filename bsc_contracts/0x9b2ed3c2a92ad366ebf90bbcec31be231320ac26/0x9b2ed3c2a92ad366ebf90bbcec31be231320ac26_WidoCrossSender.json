{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-v4/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-v4/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-v4/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWidoRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.7;\\n\\nimport \\\"../WidoTokenManager.sol\\\";\\n\\ninterface IWidoRouter {\\n    /// @notice OrderInput object describing the desired token inputs\\n    /// @param tokenAddress Address of the input token\\n    /// @param fromTokenAmount Amount of the input token to spend on the user's behalf\\n    /// @dev amount must == msg.value when token == address(0)\\n    struct OrderInput {\\n        address tokenAddress;\\n        uint256 amount;\\n    }\\n\\n    /// @notice OrderOutput object describing the desired token outputs\\n    /// @param tokenAddress Address of the output token\\n    /// @param minOutputAmount Minimum amount of the output token the user is willing to accept for this order\\n    struct OrderOutput {\\n        address tokenAddress;\\n        uint256 minOutputAmount;\\n    }\\n\\n    /// @notice Order object describing the requirements of the zap\\n    /// @param inputs Array of input objects, see OrderInput\\n    /// @param outputs Array of output objects, see OrderOutput\\n    /// @param user Address of user placing the order\\n    /// @param nonce Number used once to ensure an order requested by a signature only executes once\\n    /// @param expiration Timestamp until which the order is valid to execute\\n    struct Order {\\n        OrderInput[] inputs;\\n        OrderOutput[] outputs;\\n        address user;\\n        uint32 nonce;\\n        uint32 expiration;\\n    }\\n\\n    /// @notice Step object describing a single token transformation\\n    /// @param fromToken Address of the from token\\n    /// @param targetAddress Address of the contract performing the transformation\\n    /// @param data Data which the swap contract will be called with\\n    /// @param amountIndex Index for the from token amount that can be found in data and needs to be updated with the most recent value.\\n    struct Step {\\n        address fromToken;\\n        address targetAddress;\\n        bytes data;\\n        int32 amountIndex;\\n    }\\n\\n    function widoTokenManager() external view returns (WidoTokenManager);\\n\\n    function bank() external view returns (address);\\n\\n    function verifyOrder(Order calldata order, uint8 v, bytes32 r, bytes32 s) external view returns (bool);\\n\\n    function executeOrder(\\n        Order calldata order,\\n        Step[] calldata route,\\n        uint256 feeBps,\\n        address partner\\n    ) external payable;\\n\\n    function executeOrder(\\n        Order calldata order,\\n        Step[] calldata route,\\n        address recipient,\\n        uint256 feeBps,\\n        address partner\\n    ) external payable;\\n\\n    function executeOrderWithSignature(\\n        Order calldata order,\\n        Step[] calldata route,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        uint256 feeBps,\\n        address partner\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWidoTokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.7;\\nimport \\\"./IWidoRouter.sol\\\";\\n\\ninterface IWidoTokenManager {\\n    function pullTokens(address user, IWidoRouter.OrderInput[] calldata inputs) external;\\n}\\n\"\r\n    },\r\n    \"contracts/WidoCrossSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT.\\npragma solidity 0.8.7;\\n\\nimport \\\"./interfaces/IWidoRouter.sol\\\";\\nimport \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport \\\"@openzeppelin/contracts-v4/security/ReentrancyGuard.sol\\\";\\n\\ncontract WidoCrossSender is ReentrancyGuard {\\n    using SafeTransferLib for ERC20;\\n    using SafeTransferLib for address;\\n\\n    IWidoRouter public immutable widoRouter;\\n\\n    /// @notice Event emitted when the order is fulfilled\\n    /// @param order The order that was fulfilled\\n    /// @param sender The msg.sender\\n    /// @param recipient Recipient of the final tokens on destination chain\\n    /// @param feeBps Fee in basis points (bps)\\n    /// @param partner Partner address\\n    event CrossOrderInitiated(\\n        IWidoRouter.Order order,\\n        address sender,\\n        address indexed recipient,\\n        uint256 feeBps,\\n        address indexed partner\\n    );\\n\\n    error SingleTokenOutputExpected();\\n    error InsufficientFee(uint256 expected, uint256 actual);\\n    error FeeOutOfRange(uint256 feeBps);\\n    error InvalidBridgeAddress();\\n    error ZeroAddressWidoRouter();\\n    error BridgeFailSilently();\\n\\n    error BridgeFeeCannotBeZero();\\n    error InvalidBridgeStep();\\n    error SlippageTooHigh(uint256 expected, uint256 actual);\\n    error FailedToCallBridgeContract(string reason);\\n\\n    constructor(IWidoRouter _widoRouter) {\\n        if (address(_widoRouter) == address(0)) revert ZeroAddressWidoRouter();\\n\\n        widoRouter = _widoRouter;\\n    }\\n\\n    /// @notice Execute a cross order\\n    /// @param order Order object describing the requirements of the zap\\n    /// @param steps Array of pre-bridge steps\\n    /// @param bridgeStep Bridge step\\n    /// @param feeBps Fee in basis points (bps)\\n    /// @param partner Partner address\\n    /// @param bridgeFee Gas/Fee for the bridge call\\n    /// @param recipient Recipient of the final tokens on destination chain\\n    function executeCrossOrder(\\n        IWidoRouter.Order calldata order,\\n        IWidoRouter.Step[] calldata steps,\\n        IWidoRouter.Step calldata bridgeStep,\\n        uint256 feeBps,\\n        address partner,\\n        uint256 bridgeFee,\\n        address recipient\\n    ) external payable nonReentrant {\\n        if (order.outputs.length != 1) revert SingleTokenOutputExpected();\\n        if (bridgeStep.targetAddress == address(0)) revert InvalidBridgeAddress();\\n        if (bridgeStep.fromToken != order.outputs[0].tokenAddress) revert InvalidBridgeStep();\\n        if (feeBps > 100) revert FeeOutOfRange(feeBps);\\n        if (bridgeFee <= 0) revert BridgeFeeCannotBeZero();\\n        if (msg.value < bridgeFee) revert InsufficientFee(bridgeFee, msg.value);\\n\\n        if (steps.length > 0) {\\n            // Send the tokens directly to WidoRouter, escape the order.inputs.\\n            _sendTokens(order.inputs, address(widoRouter));\\n\\n            IWidoRouter.Order memory modifiedOrder = order;\\n            modifiedOrder.user = address(this);\\n            delete modifiedOrder.inputs;\\n\\n            // Run Execute Order for pre-bridge steps, no fee collection.\\n            widoRouter.executeOrder{value: msg.value - bridgeFee}(modifiedOrder, steps, 0, partner);\\n        } else {\\n            _sendTokens(order.inputs, address(this));\\n        }\\n\\n        // Collect fees\\n        uint256 amount = _collectFees(bridgeStep, feeBps, bridgeFee);\\n\\n        // Validate the amount to be bridged.\\n        if (amount < order.outputs[0].minOutputAmount) revert SlippageTooHigh(order.outputs[0].minOutputAmount, amount);\\n\\n        // Prepare payload for bridge call\\n        bytes memory editedBridgeData;\\n        if (bridgeStep.amountIndex >= 0) {\\n            uint256 idx = uint256(int256(bridgeStep.amountIndex));\\n            editedBridgeData = bytes.concat(bridgeStep.data[:idx], abi.encode(amount), bridgeStep.data[idx + 32:]);\\n        } else {\\n            editedBridgeData = bridgeStep.data;\\n        }\\n\\n        // Approve tokens to bridge contract\\n        _approveTokens(bridgeStep, amount);\\n\\n        // Calculate bridge value\\n        uint256 bridgeValue = bridgeFee;\\n        if (bridgeStep.fromToken == address(0)) {\\n            bridgeValue += amount;\\n        }\\n\\n        // Call bridge contract\\n        (bool success, bytes memory result) = bridgeStep.targetAddress.call{value: bridgeValue}(editedBridgeData);\\n        if (!success) {\\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n            if (result.length < 68) revert BridgeFailSilently();\\n            assembly {\\n                result := add(result, 0x04)\\n            }\\n            revert FailedToCallBridgeContract(abi.decode(result, (string)));\\n        }\\n\\n        emit CrossOrderInitiated(order, msg.sender, recipient, feeBps, partner);\\n    }\\n\\n    /// @notice Transfers tokens from the sender to the receiver\\n    /// @param inputs Array of input objects, see OrderInput and Order\\n    /// @param receiver Address to receive the tokens\\n    function _sendTokens(IWidoRouter.OrderInput[] calldata inputs, address receiver) private {\\n        for (uint256 i = 0; i < inputs.length; ) {\\n            IWidoRouter.OrderInput memory input = inputs[i];\\n            unchecked {\\n                i++;\\n            }\\n\\n            if (input.tokenAddress == address(0)) {\\n                continue;\\n            }\\n\\n            ERC20(input.tokenAddress).safeTransferFrom(msg.sender, receiver, input.amount);\\n        }\\n    }\\n\\n    function _approveTokens(IWidoRouter.Step calldata bridgeStep, uint256 amount) private {\\n        if (bridgeStep.fromToken != address(0)) {\\n            if (ERC20(bridgeStep.fromToken).allowance(address(this), bridgeStep.targetAddress) < amount) {\\n                ERC20(bridgeStep.fromToken).safeApprove(bridgeStep.targetAddress, amount);\\n            }\\n        }\\n    }\\n\\n    /// @notice Collects fees from the contract\\n    /// @param bridgeStep Bridge step\\n    /// @param feeBps Fee in basis points (bps)\\n    /// @param bridgeFee Gas/Fee for the bridge call\\n    /// @return amount Amount to be bridged\\n    function _collectFees(\\n        IWidoRouter.Step calldata bridgeStep,\\n        uint256 feeBps,\\n        uint256 bridgeFee\\n    ) private returns (uint256) {\\n        uint256 amount;\\n        if (bridgeStep.fromToken == address(0)) {\\n            amount = address(this).balance - bridgeFee;\\n        } else {\\n            amount = ERC20(bridgeStep.fromToken).balanceOf(address(this));\\n        }\\n\\n        if (feeBps != 0) {\\n            address bank = widoRouter.bank();\\n            uint256 fee = (amount * feeBps) / 10000;\\n            if (bridgeStep.fromToken == address(0)) {\\n                bank.safeTransferETH(fee);\\n            } else {\\n                ERC20(bridgeStep.fromToken).safeTransfer(bank, fee);\\n            }\\n            amount = amount - fee;\\n        }\\n\\n        return amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WidoTokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.7;\\n\\nimport \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport \\\"@openzeppelin/contracts-v4/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IWidoTokenManager.sol\\\";\\n\\ncontract WidoTokenManager is IWidoTokenManager, Ownable {\\n    using SafeTransferLib for ERC20;\\n\\n    /// @notice Transfers tokens or native tokens from the user\\n    /// @param user The address of the order user\\n    /// @param inputs Array of input objects, see OrderInput and Order\\n    function pullTokens(address user, IWidoRouter.OrderInput[] calldata inputs) external override onlyOwner {\\n        for (uint256 i = 0; i < inputs.length; i++) {\\n            IWidoRouter.OrderInput calldata input = inputs[i];\\n\\n            if (input.tokenAddress == address(0)) {\\n                continue;\\n            }\\n\\n            ERC20(input.tokenAddress).safeTransferFrom(user, owner(), input.amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {},\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ]\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IWidoRouter\",\"name\":\"_widoRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BridgeFailSilently\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BridgeFeeCannotBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"FailedToCallBridgeContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeBps\",\"type\":\"uint256\"}],\"name\":\"FeeOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBridgeAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBridgeStep\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SingleTokenOutputExpected\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"SlippageTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressWidoRouter\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IWidoRouter.OrderInput[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOutputAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IWidoRouter.OrderOutput[]\",\"name\":\"outputs\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiration\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct IWidoRouter.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBps\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"CrossOrderInitiated\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IWidoRouter.OrderInput[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOutputAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IWidoRouter.OrderOutput[]\",\"name\":\"outputs\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiration\",\"type\":\"uint32\"}],\"internalType\":\"struct IWidoRouter.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"int32\",\"name\":\"amountIndex\",\"type\":\"int32\"}],\"internalType\":\"struct IWidoRouter.Step[]\",\"name\":\"steps\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"int32\",\"name\":\"amountIndex\",\"type\":\"int32\"}],\"internalType\":\"struct IWidoRouter.Step\",\"name\":\"bridgeStep\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bridgeFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"executeCrossOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"widoRouter\",\"outputs\":[{\"internalType\":\"contract IWidoRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WidoCrossSender", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000919df3adbf5cfc9fcfd43198edfe5aa5561cb456", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}