{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\r\n  /**\r\n    * @dev Returns the amount of tokens owned by `account`.\r\n    */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n    * allowance mechanism. `amount` is then deducted from the caller's\r\n    * allowance.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 {\r\n\r\n  /**\r\n    * @dev Transfers `tokenId` token from `from` to `to`.\r\n    *\r\n    * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `from` cannot be the zero address.\r\n    * - `to` cannot be the zero address.\r\n    * - `tokenId` token must be owned by `from`.\r\n    * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n}\r\n\r\ninterface IVaultConfig {\r\n\r\n  function fee() external view returns (uint256);\r\n  function gasLimit() external view returns (uint256);\r\n  function ownerReward() external view returns (uint256);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n\r\n  function _msgValue() internal view returns (uint256) {\r\n    return msg.value;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n  address private _newOwner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor (address owner_) {\r\n    _owner = owner_;\r\n    emit OwnershipTransferred(address(0), owner_);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Accept the ownership transfer. This is to make sure that the contract is\r\n   * transferred to a working address\r\n   *\r\n   * Can only be called by the newly transfered owner.\r\n   */\r\n  function acceptOwnership() public {\r\n    require(_msgSender() == _newOwner, \"Ownable: only new owner can accept ownership\");\r\n    address oldOwner = _owner;\r\n    _owner = _newOwner;\r\n    _newOwner = address(0);\r\n    emit OwnershipTransferred(oldOwner, _owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   *\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    _newOwner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Enable contract to receive gas token\r\n */\r\nabstract contract Payable {\r\n\r\n  event Deposited(address indexed sender, uint256 value);\r\n\r\n  fallback() external payable {\r\n    if(msg.value > 0) {\r\n      emit Deposited(msg.sender, msg.value);\r\n    }\r\n  }\r\n\r\n  /// @dev enable wallet to receive ETH\r\n  receive() external payable {\r\n    if(msg.value > 0) {\r\n      emit Deposited(msg.sender, msg.value);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n  /**\r\n    * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n    * defined by `root`. For this, a `proof` must be provided, containing\r\n    * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n    * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n    */\r\n  function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n    bytes32 computedHash = leaf;\r\n\r\n    for (uint256 i = 0; i < proof.length; i++) {\r\n      bytes32 proofElement = proof[i];\r\n\r\n      if (computedHash <= proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == root;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Coin98Vault contract to enable vesting funds to investors\r\n */\r\ncontract Coin98Vault is Ownable, Payable {\r\n\r\n  address private _factory;\r\n  address[] private _admins;\r\n  mapping(address => bool) private _adminStatuses;\r\n  mapping(uint256 => EventData) private _eventDatas;\r\n  mapping(uint256 => mapping(uint256 => bool)) private _eventRedemptions;\r\n\r\n  /// @dev Initialize a new vault\r\n  /// @param factory_ Back reference to the factory initialized this vault for global configuration\r\n  /// @param owner_ Owner of this vault\r\n  constructor(address factory_, address owner_) Ownable(owner_) {\r\n    _factory = factory_;\r\n  }\r\n\r\n  struct EventData {\r\n    uint256 timestamp;\r\n    bytes32 merkleRoot;\r\n    address receivingToken;\r\n    address sendingToken;\r\n    uint8 isActive;\r\n  }\r\n\r\n  event AdminAdded(address indexed admin);\r\n  event AdminRemoved(address indexed admin);\r\n  event EventCreated(uint256 eventId, EventData eventData);\r\n  event EventUpdated(uint256 eventId, uint8 isActive);\r\n  event Redeemed(uint256 eventId, uint256 index, address indexed recipient, address indexed receivingToken, uint256 receivingTokenAmount, address indexed sendingToken, uint256 sendingTokenAmount);\r\n  event Withdrawn(address indexed owner, address indexed recipient, address indexed token, uint256 value);\r\n\r\n  function _setRedemption(uint256 eventId_, uint256 index_) private {\r\n    _eventRedemptions[eventId_][index_] = true;\r\n  }\r\n\r\n  /// @dev Access Control, only owner and admins are able to access the specified function\r\n  modifier onlyAdmin() {\r\n    require(owner() == _msgSender() || _adminStatuses[_msgSender()], \"Ownable: caller is not an admin\");\r\n    _;\r\n  }\r\n\r\n  /// @dev returns current admins who can manage the vault\r\n  function admins() public view returns (address[] memory) {\r\n    return _admins;\r\n  }\r\n\r\n  /// @dev returns info of an event\r\n  /// @param eventId_ ID of the event\r\n  function eventInfo(uint256 eventId_) public view returns (EventData memory) {\r\n    return _eventDatas[eventId_];\r\n  }\r\n\r\n  /// @dev address of the factory\r\n  function factory() public view returns (address) {\r\n    return _factory;\r\n  }\r\n\r\n  /// @dev check an index whether it's redeemed\r\n  /// @param eventId_ event ID\r\n  /// @param index_ index of redemption pre-assigned to user\r\n  function isRedeemed(uint256 eventId_, uint256 index_) public view returns (bool) {\r\n    return _eventRedemptions[eventId_][index_];\r\n  }\r\n\r\n  /// @dev claim the token which user is eligible from schedule\r\n  /// @param eventId_ event ID\r\n  /// @param index_ index of redemption pre-assigned to user\r\n  /// @param recipient_ index of redemption pre-assigned to user\r\n  /// @param receivingAmount_ amount of *receivingToken* user is eligible to redeem\r\n  /// @param sendingAmount_ amount of *sendingToken* user must send the contract to get *receivingToken*\r\n  /// @param proofs additional data to validate that the inputted information is valid\r\n  function redeem(uint256 eventId_, uint256 index_, address recipient_, uint256 receivingAmount_, uint256 sendingAmount_, bytes32[] calldata proofs) public payable {\r\n    uint256 fee = IVaultConfig(_factory).fee();\r\n    uint256 gasLimit = IVaultConfig(_factory).gasLimit();\r\n    if(fee > 0) {\r\n      require(_msgValue() == fee, \"C98Vault: Invalid fee\");\r\n    }\r\n\r\n    EventData storage eventData = _eventDatas[eventId_];\r\n    require(eventData.isActive > 0, \"C98Vault: Invalid event\");\r\n    require(eventData.timestamp <= block.timestamp, \"C98Vault: Schedule locked\");\r\n    require(recipient_ != address(0), \"C98Vault: Invalid schedule\");\r\n\r\n    bytes32 node = keccak256(abi.encodePacked(index_, recipient_, receivingAmount_, sendingAmount_));\r\n    require(MerkleProof.verify(proofs, eventData.merkleRoot, node), \"C98Vault: Invalid proof\");\r\n    require(!isRedeemed(eventId_, index_), \"C98Vault: Redeemed\");\r\n\r\n    uint256 availableAmount;\r\n    if(eventData.receivingToken == address(0)) {\r\n      availableAmount = address(this).balance;\r\n    } else {\r\n      availableAmount = IERC20(eventData.receivingToken).balanceOf(address(this));\r\n    }\r\n\r\n    require(receivingAmount_ <= availableAmount, \"C98Vault: Insufficient token\");\r\n\r\n    _setRedemption(eventId_, index_);\r\n    if(fee > 0) {\r\n      uint256 reward = IVaultConfig(_factory).ownerReward();\r\n      uint256 finalFee = fee - reward;\r\n      (bool success, bytes memory data) = _factory.call{value:finalFee, gas:gasLimit}(\"\");\r\n      require(success, \"C98Vault: Unable to charge fee\");\r\n    }\r\n    if(sendingAmount_ > 0) {\r\n      IERC20(eventData.sendingToken).transferFrom(_msgSender(), address(this), sendingAmount_);\r\n    }\r\n    if(eventData.receivingToken == address(0)) {\r\n      recipient_.call{value:receivingAmount_, gas:gasLimit}(\"\");\r\n    } else {\r\n      IERC20(eventData.receivingToken).transfer(recipient_, receivingAmount_);\r\n    }\r\n\r\n    emit Redeemed(eventId_, index_, recipient_, eventData.receivingToken, receivingAmount_, eventData.sendingToken, sendingAmount_);\r\n  }\r\n\r\n  /// @dev withdraw the token in the vault, no limit\r\n  /// @param token_ address of the token, use address(0) to withdraw gas token\r\n  /// @param destination_ recipient address to receive the fund\r\n  /// @param amount_ amount of fund to withdaw\r\n  function withdraw(address token_, address destination_, uint256 amount_) public onlyAdmin {\r\n    require(destination_ != address(0), \"C98Vault: Destination is zero address\");\r\n\r\n    uint256 availableAmount;\r\n    if(token_ == address(0)) {\r\n      availableAmount = address(this).balance;\r\n    } else {\r\n      availableAmount = IERC20(token_).balanceOf(address(this));\r\n    }\r\n\r\n    require(amount_ <= availableAmount, \"C98Vault: Not enough balance\");\r\n\r\n    uint256 gasLimit = IVaultConfig(_factory).gasLimit();\r\n    if(token_ == address(0)) {\r\n      destination_.call{value:amount_, gas:gasLimit}(\"\");\r\n    } else {\r\n      IERC20(token_).transfer(destination_, amount_);\r\n    }\r\n\r\n    emit Withdrawn(_msgSender(), destination_, token_, amount_);\r\n  }\r\n\r\n  /// @dev withdraw NFT from contract\r\n  /// @param token_ address of the token, use address(0) to withdraw gas token\r\n  /// @param destination_ recipient address to receive the fund\r\n  /// @param tokenId_ ID of NFT to withdraw\r\n  function withdrawNft(address token_, address destination_, uint256 tokenId_) public onlyAdmin {\r\n    require(destination_ != address(0), \"C98Vault: destination is zero address\");\r\n\r\n    IERC721(token_).transferFrom(address(this), destination_, tokenId_);\r\n\r\n    emit Withdrawn(_msgSender(), destination_, token_, 1);\r\n  }\r\n\r\n  /// @dev create an event to specify how user can claim their token\r\n  /// @param eventId_ event ID\r\n  /// @param timestamp_ when the token will be available for redemption\r\n  /// @param receivingToken_ token user will be receiving, mandatory\r\n  /// @param sendingToken_ token user need to send in order to receive *receivingToken_*\r\n  function createEvent(uint256 eventId_, uint256 timestamp_, bytes32 merkleRoot_, address receivingToken_, address sendingToken_) public onlyAdmin {\r\n    require(_eventDatas[eventId_].timestamp == 0, \"C98Vault: Event existed\");\r\n    require(timestamp_ != 0, \"C98Vault: Invalid timestamp\");\r\n    _eventDatas[eventId_].timestamp = timestamp_;\r\n    _eventDatas[eventId_].merkleRoot = merkleRoot_;\r\n    _eventDatas[eventId_].receivingToken = receivingToken_;\r\n    _eventDatas[eventId_].sendingToken = sendingToken_;\r\n    _eventDatas[eventId_].isActive = 1;\r\n\r\n    emit EventCreated(eventId_, _eventDatas[eventId_]);\r\n  }\r\n\r\n  /// @dev enable/disable a particular event\r\n  /// @param eventId_ event ID\r\n  /// @param isActive_ zero to inactive, any number to active\r\n  function setEventStatus(uint256 eventId_, uint8 isActive_) public onlyAdmin {\r\n    require(_eventDatas[eventId_].timestamp != 0, \"C98Vault: Invalid event\");\r\n    _eventDatas[eventId_].isActive = isActive_;\r\n\r\n    emit EventUpdated(eventId_, isActive_);\r\n  }\r\n\r\n  /// @dev add/remove admin of the vault.\r\n  /// @param nAdmins_ list to address to update\r\n  /// @param nStatuses_ address with same index will be added if true, or remove if false\r\n  /// admins will have access to all tokens in the vault, and can define vesting schedule\r\n  function setAdmins(address[] memory nAdmins_, bool[] memory nStatuses_) public onlyOwner {\r\n    require(nAdmins_.length != 0, \"C98Vault: Empty arguments\");\r\n    require(nStatuses_.length != 0, \"C98Vault: Empty arguments\");\r\n    require(nAdmins_.length == nStatuses_.length, \"C98Vault: Invalid arguments\");\r\n\r\n    uint256 i;\r\n    for(i = 0; i < nAdmins_.length; i++) {\r\n      address nAdmin = nAdmins_[i];\r\n      if(nStatuses_[i]) {\r\n        if(!_adminStatuses[nAdmin]) {\r\n          _admins.push(nAdmin);\r\n          _adminStatuses[nAdmin] = nStatuses_[i];\r\n          emit AdminAdded(nAdmin);\r\n        }\r\n      } else {\r\n        uint256 j;\r\n        for(j = 0; j < _admins.length; j++) {\r\n          if(_admins[j] == nAdmin) {\r\n            _admins[j] = _admins[_admins.length - 1];\r\n            _admins.pop();\r\n            delete _adminStatuses[nAdmin];\r\n            emit AdminRemoved(nAdmin);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ncontract Coin98VaultFactory is Ownable, Payable, IVaultConfig {\r\n\r\n  uint256 private _fee;\r\n  uint256 private _gasLimit;\r\n  uint256 private _ownerReward;\r\n  address[] private _vaults;\r\n\r\n  constructor () Ownable(_msgSender()) {\r\n    _gasLimit = 9000;\r\n  }\r\n\r\n  /// @dev Emit `FeeUpdated` when a new vault is created\r\n  event Created(address indexed vault);\r\n  /// @dev Emit `FeeUpdated` when fee of the protocol is updated\r\n  event FeeUpdated(uint256 fee);\r\n  /// @dev Emit `OwnerRewardUpdated` when reward for vault owner is updated\r\n  event OwnerRewardUpdated(uint256 fee);\r\n  /// @dev Emit `Withdrawn` when owner withdraw fund from the factory\r\n  event Withdrawn(address indexed owner, address indexed recipient, address indexed token, uint256 value);\r\n\r\n  /// @dev get current protocol fee in gas token\r\n  function fee() override external view returns (uint256) {\r\n    return _fee;\r\n  }\r\n\r\n  /// @dev limit gas to send native token\r\n  function gasLimit() override external view returns (uint256) {\r\n    return _gasLimit;\r\n  }\r\n\r\n  /// @dev get current owner reward in gas token\r\n  function ownerReward() override external view returns (uint256) {\r\n    return _ownerReward;\r\n  }\r\n\r\n  /// @dev get list of vaults initialized through this factory\r\n  function vaults() external view returns (address[] memory) {\r\n    return _vaults;\r\n  }\r\n\r\n  /// @dev create a new vault\r\n  /// @param owner_ Owner of newly created vault\r\n  function createVault(address owner_) external returns (Coin98Vault vault) {\r\n    vault = new Coin98Vault(address(this), owner_);\r\n    _vaults.push(address(vault));\r\n    emit Created(address(vault));\r\n  }\r\n\r\n  function setGasLimit(uint256 limit_) public onlyOwner {\r\n    _gasLimit = limit_;\r\n  }\r\n\r\n  /// @dev change protocol fee\r\n  /// @param fee_ amount of gas token to charge for every redeem. can be ZERO to disable protocol fee\r\n  /// @param reward_ amount of gas token to incentive vault owner. this reward will be deduce from protocol fee\r\n  function setFee(uint256 fee_, uint256 reward_) public onlyOwner {\r\n    require(fee_ >= reward_, \"C98Vault: Invalid reward amount\");\r\n\r\n    _fee = fee_;\r\n    _ownerReward = reward_;\r\n\r\n    emit FeeUpdated(fee_);\r\n    emit OwnerRewardUpdated(reward_);\r\n  }\r\n\r\n  /// @dev withdraw fee collected for protocol\r\n  /// @param token_ address of the token, use address(0) to withdraw gas token\r\n  /// @param destination_ recipient address to receive the fund\r\n  /// @param amount_ amount of fund to withdaw\r\n  function withdraw(address token_, address destination_, uint256 amount_) public onlyOwner {\r\n    require(destination_ != address(0), \"C98Vault: Destination is zero address\");\r\n\r\n    uint256 availableAmount;\r\n    if(token_ == address(0)) {\r\n      availableAmount = address(this).balance;\r\n    } else {\r\n      availableAmount = IERC20(token_).balanceOf(address(this));\r\n    }\r\n\r\n    require(amount_ <= availableAmount, \"C98Vault: Not enough balance\");\r\n\r\n    if(token_ == address(0)) {\r\n      destination_.call{value:amount_, gas:_gasLimit}(\"\");\r\n    } else {\r\n      IERC20(token_).transfer(destination_, amount_);\r\n    }\r\n\r\n    emit Withdrawn(_msgSender(), destination_, token_, amount_);\r\n  }\r\n\r\n  /// @dev withdraw NFT from contract\r\n  /// @param token_ address of the token, use address(0) to withdraw gas token\r\n  /// @param destination_ recipient address to receive the fund\r\n  /// @param tokenId_ ID of NFT to withdraw\r\n  function withdrawNft(address token_, address destination_, uint256 tokenId_) public onlyOwner {\r\n    require(destination_ != address(0), \"C98Vault: destination is zero address\");\r\n\r\n    IERC721(token_).transferFrom(address(this), destination_, tokenId_);\r\n\r\n    emit Withdrawn(_msgSender(), destination_, token_, 1);\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"OwnerRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"createVault\",\"outputs\":[{\"internalType\":\"contract Coin98Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit_\",\"type\":\"uint256\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"withdrawNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Coin98VaultFactory", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7bc29d156c722b0741f3c79f469ab7648a5aa18dec9097ead88f9b4b955739fc"}