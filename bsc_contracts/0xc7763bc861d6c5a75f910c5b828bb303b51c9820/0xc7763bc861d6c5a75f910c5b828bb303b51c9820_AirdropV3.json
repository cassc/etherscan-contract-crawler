{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value => uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AirdropV3/AirdropV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// TODO: REMOVE EDIT POOOL\\r\\n// TODO: ADD ADMIN SYSTEM FOR ESPECIAL RATE\\r\\n// todo: conntrato final is not with jho seed\\r\\n// TODO: ELIMINAR EL ACTUALIZABLE\\r\\n\\r\\npragma solidity 0.8.20;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\r\\n// import \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\n// import \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\r\\nimport \\\"../Resources/IContractsLibraryV3.sol\\\";\\r\\n// import \\\"../Resources/IVaultV3.sol\\\";\\r\\n// import \\\"./AirdropStateV3.sol\\\";\\r\\n// import \\\"./IAirdropV1.sol\\\";\\r\\nimport \\\"./IAirdropV3.sol\\\";\\r\\nimport \\\"./ISwapper.sol\\\";\\r\\nimport \\\"./IAirdropV2.sol\\\";\\r\\n\\r\\ncontract AirdropV3 is IAirdropV3, ReentrancyGuard\\r\\n    {\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n    address public operatorAddress;\\r\\n    address public operator2Address;\\r\\n    address public pWallet;\\r\\n    uint internal constant TIME_STEP = 1 days;\\r\\n    uint internal constant TIME_STEP_TOKEN = 1500 hours;\\r\\n    uint internal constant TIME_STEP_TOKENV2 = 1000 hours;\\r\\n    uint internal constant HARVEST_DELAY = 15 * TIME_STEP;\\r\\n    uint internal constant HARVEST_DELAYV2 = 7 * TIME_STEP;\\r\\n    uint internal constant BLOCK_TIME_STEP = 15 * TIME_STEP;\\r\\n    uint internal constant PERCENT_DIVIDER = 10_000;// 10k = 100%, 1k = 10%, 100 = 1%, 10 = 0.1%, 1 = 0.01%\\r\\n    // uint internal constant REFERRER_PERCENTS = 50;\\r\\n\\r\\n    uint public initDate;\\r\\n\\r\\n    uint public totalUsers;\\r\\n    uint public totalInvested;\\r\\n    // mapping(uint => uint) internal totalInvestors;\\r\\n    // mapping(uint => uint) internal totalInvested;\\r\\n    // mapping(uint => uint) internal totalWithdrawn;\\r\\n    // mapping(uint => uint) internal totalWithdrawnToken;\\r\\n    // mapping(uint => uint) internal totalReinvested;\\r\\n    // mapping(uint => uint) internal totalDeposits;\\r\\n    // mapping(uint => uint) internal totalReinvestCount;\\r\\n\\r\\n    struct PoolGlobal {\\r\\n        uint totalInvestors;\\r\\n        uint totalInvested;\\r\\n        uint totalWithdrawn;\\r\\n        uint totalWithdrawnToken;\\r\\n        uint totalReinvested;\\r\\n        uint totalDeposits;\\r\\n        uint totalReinvestCount;\\r\\n        uint currentInvested;\\r\\n        // uint poolTotalUsers;\\r\\n    }\\r\\n\\r\\n    uint public stopProductionDate;\\r\\n    bool public stopProductionVar;\\r\\n\\r\\n    // address public contractsLibrary;\\r\\n    // address public router;\\r\\n    // address public WBNB;\\r\\n    // address public TOKEN_MASTER;\\r\\n    // address public devWallet;\\r\\n    // address public oWallet;\\r\\n    // address public airdropV1;\\r\\n    // address public vault;\\r\\n    // address public swapper;\\r\\n\\r\\n    ExternalWallets internal externalWallets;\\r\\n    EnumerableSet.AddressSet internal tokensInvest;\\r\\n    // EnumerableSet.AddressSet internal tokensWithdraw;\\r\\n    mapping(address => RefData) public referrers;\\r\\n    uint public constant minPool = 1;\\r\\n    uint public poolsLength;\\r\\n    uint public flatFee;\\r\\n    uint public REFERRER_PERCENTS;\\r\\n    mapping(uint => mapping(address => UserInfo)) public users;\\r\\n    mapping(uint => mapping(address => UserInfo2)) public users2;\\r\\n    mapping(address => bool) public whiteList;\\r\\n    mapping(uint => address) public addressByIndex;\\r\\n    mapping(uint => mapping(uint => address)) public investors;\\r\\n\\r\\n    mapping(address => uint) public lastBlock;\\r\\n    mapping(uint => Pool) internal pools;\\r\\n    mapping(uint => PoolGlobal) internal poolGlobal;\\r\\n    // mapping(uint => uint) public currentInvested;\\r\\n    mapping(uint => mapping(address => uint)) public lastWihdrawToken;\\r\\n\\r\\n    event Newbie(address user);\\r\\n    event NewDeposit(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event FeePayed(address indexed user, uint256 totalAmount);\\r\\n    mapping(address => bool) public hasFirstDeposit;\\r\\n    mapping(address => uint) public specialConvertionRate;\\r\\n    mapping(uint => mapping(address => mapping(address => uint))) public userTotalWithdrawn;\\r\\n    // mapping(address => mapping(address => uint)) public userTotalWithdrawn;\\r\\n    // mapping(address => bool) public whiteListContract;\\r\\n\\r\\n    modifier hasStoppedProduction() {\\r\\n        require(stopProductionVar, \\\"Production is not stopped\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier hasNotStoppedProduction() {\\r\\n        require(!stopProductionVar, \\\"Production is stopped\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // function hasStoppedProductionView() public view returns (bool) {\\r\\n    //     return stopProductionVar;\\r\\n    // }\\r\\n\\r\\n    modifier onlyOperator() {\\r\\n        require(\\r\\n            operatorAddress == msg.sender || msg.sender == externalWallets.oWallet,\\r\\n            \\\"Ownable: caller is not the operator\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier whenNotPaused() {\\r\\n        require(initDate > 0, \\\"Pausable: paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier whenPaused() {\\r\\n        require(initDate == 0, \\\"Pausable: not paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function getPublicData(uint _pool)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            PoolGlobal memory _poolGlobal,\\r\\n            bool isPaused_\\r\\n        )\\r\\n    {\\r\\n        _poolGlobal = poolGlobal[_pool];\\r\\n        isPaused_ = isPaused();\\r\\n    }\\r\\n\\r\\n    function stopProduction() external onlyOperator {\\r\\n        stopProductionVar = true;\\r\\n        stopProductionDate = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function unpause() external whenPaused onlyOperator {\\r\\n        initDate = block.timestamp;\\r\\n        emit Unpaused(msg.sender);\\r\\n    }\\r\\n\\r\\n    function isPaused() public view returns (bool) {\\r\\n        return initDate == 0;\\r\\n    }\\r\\n\\r\\n    function getDAte() external view returns (uint) {\\r\\n        return block.timestamp;\\r\\n    }\\r\\n\\r\\n    // function changeOperator(\\r\\n    //     address _operatorAddress\\r\\n    // ) external onlyOperator {\\r\\n    //     operatorAddress = _operatorAddress;\\r\\n    // }\\r\\n\\r\\n    modifier tenBlocks() {\\r\\n        require(block.number - lastBlock[msg.sender] > 10, \\\"wait 10 blocks\\\");\\r\\n        _;\\r\\n        lastBlock[msg.sender] = block.number;\\r\\n    }\\r\\n\\r\\n    modifier enoughFee() {\\r\\n        require(msg.value >= flatFee, \\\"Flat fee\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // function setWallets(address _oWallet, address) external onlyOperator {\\r\\n    //     externalWallets.mWallet = _oWallet;\\r\\n    //     // externalWallets.devWallet = _devFeeWallet;\\r\\n    // }\\r\\n\\r\\n    function getExternalWallets() external view returns (ExternalWallets memory) {\\r\\n        return externalWallets;\\r\\n    }\\r\\n\\r\\n    // function isContract(address addr) internal view returns (bool) {\\r\\n    //     uint size;\\r\\n    //     assembly {\\r\\n    //         size := extcodesize(addr)\\r\\n    //     }\\r\\n    //     return size > 0;\\r\\n    // }\\r\\n\\r\\n    modifier isNotContract() {\\r\\n        // if(!whiteListContract[msg.sender]) {\\r\\n        //     require(!isContract(msg.sender), \\\"contract not allowed\\\");\\r\\n        //     require(msg.sender == tx.origin, \\\"Proxy contract not allowed\\\");\\r\\n        // }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function invest(\\r\\n        uint _pool,\\r\\n        uint amount,\\r\\n        address _ref,\\r\\n        address _token\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        nonReentrant\\r\\n        whenNotPaused\\r\\n        tenBlocks\\r\\n        isNotContract\\r\\n        hasNotStoppedProduction\\r\\n    {\\r\\n        uint msgValue = payFee();\\r\\n        require(isValidToken(_token, false), \\\"Invalid token\\\");\\r\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\r\\n        Pool memory pool = pools[_pool];\\r\\n        require(pool.isActived, \\\"Pool is not actived\\\");\\r\\n        require(amount > 0, \\\"zero amount\\\");\\r\\n        // require(msg.sender == address(0xf833FC31264CE78D44720593611CbC91A3d2da70)||\\r\\n        // msg.sender == address(0x2bbfB635171c0E1caABDACb69130fbdb197c39C1)||\\r\\n        // msg.sender == address(0x5Ea0f0B1Dd9CD58563E979E39f65724e6e4F29A0), \\\"Invalid sender\\\");\\r\\n        UserInfo storage user = users[_pool][msg.sender];\\r\\n        // uint toSwap = amount;\\r\\n        address tokenInvest = _token;\\r\\n        address _tokenMaster = externalWallets.TOKEN_MASTER;\\r\\n        if(tokenInvest == externalWallets.WBNB) {\\r\\n            require(msgValue >= amount, \\\"Invalid msgValue\\\");\\r\\n            amount = msgValue;\\r\\n            require(amount > 0, \\\"Invalid amount 2\\\");\\r\\n            // require(amount >= pool.minimumDeposit, \\\"Minimum deposit 2\\\");\\r\\n        } else {\\r\\n            require(msgValue == 0, \\\"Invalid amount 3\\\");\\r\\n            IERC20(tokenInvest).transferFrom(msg.sender, address(this), amount);\\r\\n        }\\r\\n        uint _investInMaster = amount;\\r\\n        // bool _isblockPool = pool.blockTimeStep > 0;\\r\\n        if(tokenInvest != _tokenMaster) {\\r\\n            if(specialConvertionRate[tokenInvest] > 0 && pool.blockTimeStep > 0) {\\r\\n                // uint internal constant PERCENT_DIVIDER = 10_000;// 10k = 100%, 1k = 10%, 100 = 1%, 10 = 0.1%, 1 = 0.01%\\r\\n                _investInMaster = (amount * specialConvertionRate[tokenInvest]) / PERCENT_DIVIDER;\\r\\n                transferHandler(tokenInvest, amount, pWallet);\\r\\n            } else {\\r\\n                if(tokenInvest != externalWallets.WBNB) {\\r\\n                    transferHandler(tokenInvest, amount, externalWallets.swapperNormal);\\r\\n                }\\r\\n                ISwapper swapper = ISwapper(externalWallets.swapperNormal);\\r\\n                _investInMaster = swapper.swapTokens{value: msgValue}(tokenInvest, _tokenMaster, amount, 1, address(this), address(this));\\r\\n\\r\\n            }\\r\\n            require(_investInMaster > 0, \\\"Invalid amount 4\\\");\\r\\n\\r\\n        }\\r\\n        require(_investInMaster >= pool.minimumDeposit, \\\"Minimum deposit\\\");\\r\\n        amount = 0;\\r\\n        if(hasFirstDeposit[msg.sender] == false && pool.blockTimeStep > 0) {\\r\\n            hasFirstDeposit[msg.sender] = true;\\r\\n            IAirdropV2 airdropV2 = IAirdropV2(externalWallets.airdropV1);\\r\\n            // IAirdropV2.UserInfo memory userInfo = airdropV2.users(1, msg.sender);\\r\\n        (,\\r\\n            ,\\r\\n            uint aridrop1Invest,\\r\\n            ,\\r\\n            ,\\r\\n            ,\\r\\n            ,\\r\\n            ,\\r\\n            ,\\r\\n            ,\\r\\n            \\r\\n\\r\\n        ) = airdropV2.users(1, msg.sender);\\r\\n        amount = aridrop1Invest;\\r\\n        _investInMaster += aridrop1Invest;\\r\\n        }\\r\\n\\r\\n        RefData storage refData = referrers[msg.sender];\\r\\n        bool newUser = false;\\r\\n        if (!refData.exists) {\\r\\n            user.user = msg.sender;\\r\\n            user.id = totalUsers;\\r\\n            refData.exists = true;\\r\\n            addressByIndex[totalUsers] = msg.sender;\\r\\n            totalUsers++;\\r\\n            emit Newbie(msg.sender);\\r\\n            newUser = true;\\r\\n            if(_ref != address(0) && _ref != msg.sender && referrers[_ref].referrer != msg.sender) {\\r\\n                refData.referrer = _ref;\\r\\n                referrers[_ref].refCount++;\\r\\n            } else if(msg.sender != externalWallets.oWallet) {\\r\\n                refData.referrer = externalWallets.oWallet;\\r\\n                referrers[externalWallets.oWallet].refCount++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (users[_pool][msg.sender].totalDeposit == 0) {\\r\\n            uint length = poolGlobal[_pool].totalInvestors;\\r\\n            investors[_pool][length] = msg.sender;\\r\\n            poolGlobal[_pool].totalInvestors++;\\r\\n        }\\r\\n\\r\\n        updateDeposit(msg.sender, _pool);\\r\\n        updateDepositToken(msg.sender, _pool);\\r\\n\\r\\n        users[_pool][msg.sender].investment += _investInMaster;\\r\\n        users[_pool][msg.sender].stakingValue += _investInMaster;\\r\\n        users[_pool][msg.sender].totalDeposit += _investInMaster;\\r\\n\\r\\n        poolGlobal[_pool].totalInvested += _investInMaster;\\r\\n        poolGlobal[_pool].currentInvested += _investInMaster;\\r\\n        poolGlobal[_pool].totalDeposits++;\\r\\n        totalInvested += _investInMaster;\\r\\n\\r\\n        if (user.nextWithdraw == 0) {\\r\\n            user.nextWithdraw = block.timestamp + pool.harvestDelay;\\r\\n        }\\r\\n\\r\\n        if(lastWihdrawToken[_pool][msg.sender] == 0) {\\r\\n            lastWihdrawToken[_pool][msg.sender] = block.timestamp;\\r\\n        }\\r\\n        user.lastDeposit = block.timestamp;\\r\\n\\r\\n        user.unlockDate = block.timestamp + pool.blockTimeStep;\\r\\n        // uint realInvest = _investInMaster - formOld;\\r\\n        payFeeHandle(_tokenMaster, _investInMaster - amount);\\r\\n        if(pool.blockTimeStep > 0 && refData.referrer != address(0)) {\\r\\n            uint _toRef = ((_investInMaster - amount) * pool.referrerPercent) / PERCENT_DIVIDER;\\r\\n            transferHandler(_tokenMaster, _toRef, refData.referrer);\\r\\n            referrers[refData.referrer].amount += _toRef;\\r\\n            referrers[refData.referrer].totalFefInvest += _investInMaster;\\r\\n        }\\r\\n\\r\\n        emit NewDeposit(msg.sender, _investInMaster);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint _pool, address _token) external payable\\r\\n        nonReentrant\\r\\n        whenNotPaused\\r\\n        tenBlocks\\r\\n        isNotContract\\r\\n        hasNotStoppedProduction {\\r\\n        require(isValidToken(_token, true), \\\"Invalid token\\\");\\r\\n        payFee();\\r\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\r\\n        require(pools[_pool].isActived, \\\"Pool is not actived\\\");\\r\\n        require(userCanwithdraw(msg.sender, _pool), \\\"User cannot withdraw\\\");\\r\\n        // address tokenPay = pools[_pool].token;\\r\\n        address _user = msg.sender;\\r\\n        updateDeposit(_user, _pool);\\r\\n        uint toTransfer = users[_pool][_user].rewardLockedUp;\\r\\n        delete users[_pool][_user].rewardLockedUp;\\r\\n        Pool memory pool = pools[_pool];\\r\\n        address _tokenMaster = externalWallets.TOKEN_MASTER;\\r\\n        uint _toUser = toTransfer;\\r\\n        if(_token != _tokenMaster) {\\r\\n            // uint tokenNeed = IContractsLibraryV3(externalWallets.contractsLibrary).getInForTokenToBnbToAltToken(_tokenMaster, _token, toTransfer);\\r\\n            require(getBalance(_tokenMaster) >= toTransfer, \\\"Not enough balance\\\");\\r\\n            transferHandler(_tokenMaster, toTransfer, externalWallets.swapperNormal);\\r\\n            // transferHandler(_token, tokenNeed, externalWallets.swapperNormal);\\r\\n            ISwapper swapper = ISwapper(externalWallets.swapperNormal);\\r\\n            _toUser = swapper.swapTokens(_tokenMaster, _token, toTransfer, 1, address(this), address(this));\\r\\n        }\\r\\n        require(getBalance(_token) >= _toUser, \\\"Not enough balance\\\");\\r\\n\\r\\n\\r\\n        // uint amount = toTransfer;\\r\\n        if (pool.fee > 0) {\\r\\n            uint fee = payFeeHandle(_token, _toUser);\\r\\n            _toUser -= fee;\\r\\n            emit FeePayed(_user, fee);\\r\\n        }\\r\\n\\r\\n\\r\\n        users[_pool][_user].totalWithdrawn += toTransfer;\\r\\n        transferHandler(_token, _toUser, _user);\\r\\n        poolGlobal[_pool].totalWithdrawn += toTransfer;\\r\\n        users[_pool][_user].nextWithdraw = block.timestamp + pool.harvestDelay;\\r\\n        userTotalWithdrawn[_pool][_user][_token] += _toUser;\\r\\n        emit Withdrawn(_user, toTransfer);\\r\\n    }\\r\\n\\r\\n    function withdrawToken(uint _pool, address _token) external payable nonReentrant\\r\\n        whenNotPaused\\r\\n        tenBlocks\\r\\n        isNotContract\\r\\n        hasNotStoppedProduction {\\r\\n        payFee();\\r\\n        require(isValidToken(_token, true), \\\"Invalid token\\\");\\r\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\r\\n        require(pools[_pool].isActived, \\\"Pool is not actived\\\");\\r\\n        require(userCanwithdrawToken(msg.sender, _pool), \\\"User cannot withdraw\\\");\\r\\n        // address tokenPay = pools[_pool].token;\\r\\n        address _user = msg.sender;\\r\\n        updateDepositToken(_user, _pool);\\r\\n        uint toTransfer = users2[_pool][_user].rewardLockedUpToken;\\r\\n        delete users2[_pool][_user].rewardLockedUpToken;\\r\\n        Pool memory pool = pools[_pool];\\r\\n        address _tokenMaster = externalWallets.TOKEN_MASTER;\\r\\n        uint _toUser = toTransfer;\\r\\n        if(_token != _tokenMaster) {\\r\\n            // uint tokenNeed = IContractsLibraryV3(externalWallets.contractsLibrary).getInForTokenToBnbToAltToken(_tokenMaster, _token, toTransfer);\\r\\n            require(getBalance(_tokenMaster) >= toTransfer, \\\"Not enough balance\\\");\\r\\n            transferHandler(_tokenMaster, toTransfer, externalWallets.swapperNormal);\\r\\n            // transferHandler(_token, tokenNeed, externalWallets.swapperNormal);\\r\\n            ISwapper swapper = ISwapper(externalWallets.swapperNormal);\\r\\n            _toUser = swapper.swapTokens(_tokenMaster, _token, toTransfer, 1, address(this), address(this));\\r\\n        }\\r\\n        require(getBalance(_token) >= _toUser, \\\"Not enough balance\\\");\\r\\n\\r\\n        // uint amount = toTransfer;\\r\\n        if (pool.fee > 0) {\\r\\n            uint fee = payFeeHandle(_token, _toUser);\\r\\n            _toUser -= fee;\\r\\n            emit FeePayed(_user, fee);\\r\\n        }\\r\\n\\r\\n        users2[_pool][_user].totalWithdrawnToken += toTransfer;\\r\\n        transferHandler(_token, _toUser, _user);\\r\\n        poolGlobal[_pool].totalWithdrawn += toTransfer;\\r\\n        users[_pool][_user].nextWithdraw = block.timestamp + pool.harvestDelay;\\r\\n        userTotalWithdrawn[_pool][_user][_token] += _toUser;\\r\\n        lastWihdrawToken[_pool][_user] = block.timestamp;\\r\\n        emit Withdrawn(_user, toTransfer);\\r\\n    }\\r\\n\\r\\n    function forceWithdraw(\\r\\n        uint _pool\\r\\n    ) external payable nonReentrant whenNotPaused tenBlocks isNotContract {\\r\\n        payFee();\\r\\n        // require(isValidToken(_token, true), \\\"Invalid token\\\");\\r\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\r\\n        require(users[_pool][msg.sender].unlockDate < block.timestamp, \\\"User cannot withdraw\\\");\\r\\n        address _user = msg.sender;\\r\\n        uint toTransfer = users[_pool][msg.sender].investment;\\r\\n        delete users[_pool][msg.sender].rewardLockedUp;\\r\\n        delete users2[_pool][msg.sender].rewardLockedUpToken;\\r\\n        delete users[_pool][msg.sender].investment;\\r\\n        delete users[_pool][msg.sender].stakingValue;\\r\\n        delete users[_pool][msg.sender].nextWithdraw;\\r\\n        delete users[_pool][msg.sender].unlockDate;\\r\\n        delete users[_pool][msg.sender].depositCheckpoint;\\r\\n        delete users2[_pool][msg.sender].depositCheckpointToken;\\r\\n        delete users[_pool][msg.sender].lastDeposit;\\r\\n        delete lastWihdrawToken[_pool][msg.sender];\\r\\n        if (poolGlobal[_pool].currentInvested < toTransfer) {\\r\\n            delete poolGlobal[_pool].currentInvested;\\r\\n        } else {\\r\\n            poolGlobal[_pool].currentInvested -= toTransfer;\\r\\n        }\\r\\n\\r\\n        address _tokenMaster = externalWallets.TOKEN_MASTER;\\r\\n        uint _toUser = toTransfer;\\r\\n        // if(_token != _tokenMaster) {\\r\\n        //     // uint tokenNeed = IContractsLibraryV3(externalWallets.contractsLibrary).getInForTokenToBnbToAltToken(_tokenMaster, _token, toTransfer);\\r\\n        //     require(getBalance(_tokenMaster) >= toTransfer, \\\"Not enough balance\\\");\\r\\n        //     transferHandler(_tokenMaster, toTransfer, externalWallets.swapperNormal);\\r\\n        //     // transferHandler(_token, tokenNeed, externalWallets.swapperNormal);\\r\\n        //     ISwapper swapper = ISwapper(externalWallets.swapperNormal);\\r\\n        //     _toUser = swapper.swapTokens(_tokenMaster, _token, toTransfer, 1, address(this), address(this));\\r\\n        // }\\r\\n        // require(getBalance(_token) >= _toUser, \\\"Not enough balance\\\");\\r\\n        transferHandler(_tokenMaster, _toUser, _user);\\r\\n    }\\r\\n\\r\\n    // function getReward(\\r\\n    //     uint _weis,\\r\\n    //     uint _seconds,\\r\\n    //     uint _pool\\r\\n    // ) public view returns (uint) {\\r\\n    //     Pool memory pool = pools[_pool];\\r\\n    //     return (_weis * _seconds * pool.roi) / (pool.roiStep * PERCENT_DIVIDER);\\r\\n    // }\\r\\n\\r\\n    // function getRewardToken(\\r\\n    //     uint _weis,\\r\\n    //     uint _seconds,\\r\\n    //     uint _pool\\r\\n    // ) public view returns (uint) {\\r\\n    //     Pool memory pool = pools[_pool];\\r\\n    //     return\\r\\n    //         (_weis * _seconds * pool.roiToken) /\\r\\n    //         (pool.roiStepToken * PERCENT_DIVIDER);\\r\\n    // }\\r\\n\\r\\n    function getReward(\\r\\n        uint _weis,\\r\\n        uint _seconds,\\r\\n        uint _roi,\\r\\n        uint _roiStep\\r\\n    ) public pure returns (uint) {\\r\\n        return (_weis * _seconds * _roi) / (_roiStep * PERCENT_DIVIDER);\\r\\n    }\\r\\n\\r\\n    function userCanwithdraw(\\r\\n        address user,\\r\\n        uint _pool\\r\\n    ) public view returns (bool) {\\r\\n        if (block.timestamp > users[_pool][user].nextWithdraw) {\\r\\n            if (users[_pool][user].stakingValue > 0) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function userCanwithdrawToken(\\r\\n        address _user,\\r\\n        uint _pool\\r\\n    ) public view returns (bool) {\\r\\n        uint _lastWihdrawToken = lastWihdrawToken[_pool][_user];\\r\\n        if(_lastWihdrawToken == 0 && users2[_pool][_user].depositCheckpointToken != 0) {\\r\\n            _lastWihdrawToken = users2[_pool][_user].depositCheckpointToken;\\r\\n        }\\r\\n        if(_lastWihdrawToken == 0) {\\r\\n            return false;\\r\\n        }\\r\\n        if (block.timestamp - _lastWihdrawToken >= pools[_pool].roiStepToken) {\\r\\n            if (users[_pool][_user].stakingValue > 0) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function getDeltaPendingRewards(\\r\\n        address _user,\\r\\n        uint _pool\\r\\n    ) public view returns (uint) {\\r\\n        uint depositCheckpoint = users[_pool][_user].depositCheckpoint;\\r\\n        if (depositCheckpoint == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint time = block.timestamp;\\r\\n        if (stopProductionDate > 0 && time > stopProductionDate) {\\r\\n            time = stopProductionDate;\\r\\n        }\\r\\n        // uint unlockDate = users[_pool][_user].unlockDate;\\r\\n        // if (unlockDate > 0 && time > unlockDate) {\\r\\n        //     time = unlockDate;\\r\\n        // }\\r\\n        if (time <= depositCheckpoint) {\\r\\n            return 0;\\r\\n        }\\r\\n        Pool memory pool = pools[_pool];\\r\\n        return\\r\\n            getReward(\\r\\n                users[_pool][_user].stakingValue,\\r\\n                time - depositCheckpoint,\\r\\n                pool.roi,\\r\\n                pool.roiStep\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getDeltaPendingRewardsToken(\\r\\n        address _user,\\r\\n        uint _pool\\r\\n    ) public view returns (uint) {\\r\\n        uint depositCheckpoint = users2[_pool][_user].depositCheckpointToken;\\r\\n        if (depositCheckpoint == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint time = block.timestamp;\\r\\n        if (stopProductionDate > 0 && time > stopProductionDate) {\\r\\n            time = stopProductionDate;\\r\\n        }\\r\\n        // uint unlockDate = users[_pool][_user].unlockDate;\\r\\n        // if (unlockDate > 0 && time > unlockDate) {\\r\\n        //     time = unlockDate;\\r\\n        // }\\r\\n        if (time <= depositCheckpoint) {\\r\\n            return 0;\\r\\n        }\\r\\n        Pool memory pool = pools[_pool];\\r\\n        return\\r\\n            getReward(\\r\\n                users[_pool][_user].stakingValue,\\r\\n                time - depositCheckpoint,\\r\\n                pool.roiToken,\\r\\n                pool.roiStepToken\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getUserTotalPendingRewards(\\r\\n        address _user,\\r\\n        uint _pool\\r\\n    ) public view returns (uint) {\\r\\n        uint _rewards = users[_pool][_user].rewardLockedUp +\\r\\n            getDeltaPendingRewards(_user, _pool);\\r\\n        return _rewards;\\r\\n    }\\r\\n\\r\\n    function getUserTotalPendingRewardsToken(\\r\\n        address _user,\\r\\n        uint _pool\\r\\n    ) public view returns (uint) {\\r\\n        uint _rewards = users[_pool][_user].rewardLockedUp +\\r\\n            getDeltaPendingRewardsToken(_user, _pool);\\r\\n        return _rewards;\\r\\n    }\\r\\n\\r\\n    function updateDeposit(address _user, uint _pool) internal {\\r\\n        users[_pool][_user].rewardLockedUp = getUserTotalPendingRewards(\\r\\n            _user,\\r\\n            _pool\\r\\n        );\\r\\n\\r\\n        users[_pool][_user].depositCheckpoint = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function updateDepositToken(address _user, uint _pool) internal {\\r\\n        users2[_pool][_user]\\r\\n            .rewardLockedUpToken = getUserTotalPendingRewardsToken(\\r\\n            _user,\\r\\n            _pool\\r\\n        );\\r\\n        users2[_pool][_user].depositCheckpointToken = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function getUser(\\r\\n        address _user,\\r\\n        uint _pool\\r\\n    ) external view returns (UserInfo memory userInfo_, uint pendingRewards) {\\r\\n        userInfo_ = users[_pool][_user];\\r\\n        pendingRewards = getUserTotalPendingRewards(_user, _pool);\\r\\n    }\\r\\n\\r\\n    function getAllUsers(uint _pool) external view returns (UserInfo[] memory) {\\r\\n        uint length = poolGlobal[_pool].totalInvestors;\\r\\n        UserInfo[] memory result = new UserInfo[](length);\\r\\n        for (uint i = 0; i < length; i++) {\\r\\n            result[i] = users[_pool][investors[_pool][i]];\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getRewardsInRange(\\r\\n        uint _pool,\\r\\n        uint _start,\\r\\n        uint _end\\r\\n    ) public view returns (uint) {\\r\\n        uint _rewards;\\r\\n        for (uint i = _start; i < _end; i++) {\\r\\n            _rewards += getUserTotalPendingRewards(investors[_pool][i], _pool);\\r\\n        }\\r\\n        return _rewards;\\r\\n    }\\r\\n\\r\\n    function getAllRefData() external view returns (RefData[] memory) {\\r\\n        uint length = totalUsers;\\r\\n        RefData[] memory result = new RefData[](length);\\r\\n        for (uint i = 0; i < length; i++) {\\r\\n            result[i] = referrers[addressByIndex[i]];\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n   function getRefDataByIndex(\\r\\n        uint _index\\r\\n    ) external view returns (RefData memory) {\\r\\n        require(_index < totalUsers, \\\"Index out of bounds\\\");\\r\\n        return referrers[addressByIndex[_index]];\\r\\n    }\\r\\n\\r\\n    function getUsersRange(\\r\\n        uint _pool,\\r\\n        uint _from,\\r\\n        uint _to\\r\\n    ) external view returns (UserInfo[] memory) {\\r\\n        uint length = poolGlobal[_pool].totalInvestors;\\r\\n        require(_from < length, \\\"Invalid start\\\");\\r\\n        require(_to <= length, \\\"Invalid end\\\");\\r\\n        require(_from < _to, \\\"Invalid range\\\");\\r\\n        UserInfo[] memory result = new UserInfo[](_to - _from);\\r\\n        for (uint i = _from; i < _to; i++) {\\r\\n            result[i - _from] = users[_pool][investors[_pool][i]];\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getAllInvestors(\\r\\n        uint _pool\\r\\n    ) external view returns (address[] memory) {\\r\\n        uint _totalInvestors = poolGlobal[_pool].totalInvestors;\\r\\n        address[] memory investorsList = new address[](_totalInvestors);\\r\\n        for (uint i = 0; i < _totalInvestors; i++) {\\r\\n            investorsList[i] = investors[_pool][i];\\r\\n        }\\r\\n        return investorsList;\\r\\n    }\\r\\n\\r\\n    function getInvestorByIndex(\\r\\n        uint _pool,\\r\\n        uint index\\r\\n    ) external view returns (address) {\\r\\n        require(index < totalUsers, \\\"Index out of range\\\");\\r\\n        return investors[_pool][index];\\r\\n    }\\r\\n\\r\\n    function getRefDataRange(\\r\\n        uint _pool,\\r\\n        uint _from,\\r\\n        uint _to\\r\\n    ) external view returns (RefData[] memory) {\\r\\n        uint length = poolGlobal[_pool].totalInvestors;\\r\\n        require(_from < length, \\\"Invalid start\\\");\\r\\n        require(_to <= length, \\\"Invalid end\\\");\\r\\n        require(_from < _to, \\\"Invalid range\\\");\\r\\n        RefData[] memory result = new RefData[](_to - _from);\\r\\n        for (uint i = _from; i < _to; i++) {\\r\\n            result[i - _from] = referrers[investors[_pool][i]];\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getUserByIndex(\\r\\n        uint _pool,\\r\\n        uint _index\\r\\n    ) external view returns (UserInfo memory) {\\r\\n        require(_index < totalUsers, \\\"Index out of bounds\\\");\\r\\n        return users[_pool][investors[_pool][_index]];\\r\\n    }\\r\\n\\r\\n    // function addPool(\\r\\n    //     // address _token,\\r\\n    //     uint _minimumDeposit,\\r\\n    //     uint roi,\\r\\n    //     uint roiToken,\\r\\n    //     uint _roiStep,\\r\\n    //     uint _roiStepToken,\\r\\n    //     uint _fee,\\r\\n    //     uint _referrerPercent,\\r\\n    //     // uint _requirePool,\\r\\n    //     // uint _requireAmount,\\r\\n    //     uint _blockDuration,\\r\\n    //     uint _harvestDelay\\r\\n    // ) external onlyOperator {\\r\\n    //     poolsLength++;\\r\\n    //     pools[poolsLength] = Pool({\\r\\n    //         // token: _token,\\r\\n    //         minimumDeposit: _minimumDeposit,\\r\\n    //         roi: roi,\\r\\n    //         roiToken: roiToken,\\r\\n    //         roiStep: _roiStep,\\r\\n    //         roiStepToken: _roiStepToken,\\r\\n    //         fee: _fee,\\r\\n    //         referrerPercent: _referrerPercent,\\r\\n    //         // rquirePool: _requirePool,\\r\\n    //         // requireAmount: _requireAmount,\\r\\n    //         blockTimeStep: _blockDuration,\\r\\n    //         harvestDelay: _harvestDelay,\\r\\n    //         isActived: true\\r\\n    //         // var1: 0\\r\\n    //     });\\r\\n    // }\\r\\n\\r\\n    // function changeFee(uint _pool, uint _fee) external onlyOperator {\\r\\n    //     require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\r\\n    //     require(_fee < PERCENT_DIVIDER, \\\"Invalid fee\\\");\\r\\n    //     pools[_pool].fee = _fee;\\r\\n    // }\\r\\n\\r\\n    // function setPoolStatus(uint _pool, bool _isActive) external onlyOperator {\\r\\n    //     require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\r\\n    //     pools[_pool].isActived = _isActive;\\r\\n    // }\\r\\n\\r\\n    // function changeRoi(\\r\\n    //     uint _pool,\\r\\n    //     uint _roi,\\r\\n    //     uint _roiStep\\r\\n    // ) external onlyOperator {\\r\\n    //     require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\r\\n    //     pools[_pool].roi = _roi;\\r\\n    //     pools[_pool].roiStep = _roiStep;\\r\\n    // }\\r\\n\\r\\n    fallback() external payable {}\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    // function initialize \\r\\n    constructor(\\r\\n        address _airdropV1,\\r\\n        address _library,\\r\\n        address _tokenMaster,\\r\\n        // address _tokenPool,\\r\\n        address _devFeeWallet,\\r\\n        address _oWallet,\\r\\n        address _mwallet,\\r\\n        // address _swapper,\\r\\n        address _swapperNormal\\r\\n    ) {\\r\\n        operator2Address = 0xF669970132D5e6A5E6A9Aec4393384ADBca58b4f;\\r\\n        pWallet = 0xde5a95573DD1e8526cc70958b089B5a58b77223E;\\r\\n        // externalWallets.airdropV1 = _airdropV1;\\r\\n        externalWallets.contractsLibrary = _library;\\r\\n        externalWallets.router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n            // uint internal constant PERCENT_DIVIDER = 10_000;// 10k = 100%, 1k = 10%, 100 = 1%, 10 = 0.1%, 1 = 0.01%\\r\\n        REFERRER_PERCENTS = 500;\\r\\n        IUniswapV2Router02 ROUTER = IUniswapV2Router02(externalWallets.router);\\r\\n        operatorAddress = msg.sender;\\r\\n        externalWallets.airdropV1 = _airdropV1;\\r\\n        externalWallets.devWallet = _devFeeWallet;\\r\\n        externalWallets.oWallet = _oWallet;\\r\\n        externalWallets.mWallet = _mwallet;\\r\\n        externalWallets.WBNB = ROUTER.WETH();\\r\\n        externalWallets.USDT = 0x55d398326f99059fF775485246999027B3197955;\\r\\n        // // btc 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c\\r\\n        externalWallets.btc = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\\r\\n        // beat 0x83d3C2D1A55687498Df6800c5F173EC6a7556089\\r\\n        externalWallets.beat = 0x83d3C2D1A55687498Df6800c5F173EC6a7556089;\\r\\n        // CryptoBeats:\\\"0xbB21c4A6257f3306d0458E92aD0FE583AD0cE858\\\"\\r\\n        externalWallets.cryptoBeat = 0xbB21c4A6257f3306d0458E92aD0FE583AD0cE858;\\r\\n        flatFee = 0.0035 ether;\\r\\n        externalWallets.TOKEN_MASTER = _tokenMaster;\\r\\n        // externalWallets.swapper = _swapper;\\r\\n        externalWallets.swapperNormal = _swapperNormal;\\r\\n        tokensInvest.add(_tokenMaster);\\r\\n        // tokensInvest.add(externalWallets.beat);\\r\\n        // // cryptobeat\\r\\n        // tokensInvest.add(externalWallets.cryptoBeat);\\r\\n        // wbnb\\r\\n        tokensInvest.add(externalWallets.WBNB);\\r\\n        // usdt\\r\\n        tokensInvest.add(externalWallets.USDT);\\r\\n        tokensInvest.add(externalWallets.btc);\\r\\n        specialConvertionRate[0x83d3C2D1A55687498Df6800c5F173EC6a7556089] = PERCENT_DIVIDER;\\r\\n        specialConvertionRate[0xbB21c4A6257f3306d0458E92aD0FE583AD0cE858] = PERCENT_DIVIDER;\\r\\n\\r\\n        // tokensWithdraw.add(_tokenMaster);\\r\\n        // tokensWithdraw.add(externalWallets.WBNB);\\r\\n        // tokensWithdraw.add(externalWallets.btc);\\r\\n\\r\\n        // uint internal constant PERCENT_DIVIDER = 10_000;// 10k = 100%, 1k = 10%, 100 = 1%, 10 = 0.1%, 1 = 0.01%\\r\\n        pools[1] = Pool({\\r\\n            // token: _tokenMaster,\\r\\n            minimumDeposit: 0.01 ether,\\r\\n            roi: 20,\\r\\n            roiToken: 500,\\r\\n            roiStep: TIME_STEP,\\r\\n            roiStepToken: TIME_STEP_TOKEN,\\r\\n            fee: 300,\\r\\n            referrerPercent: REFERRER_PERCENTS,\\r\\n            // rquirePool: 0,\\r\\n            // requireAmount: 0,\\r\\n            blockTimeStep: 0,\\r\\n            harvestDelay: HARVEST_DELAY,\\r\\n            isActived: true\\r\\n        });\\r\\n\\r\\n        pools[2] = Pool({\\r\\n            // token: _tokenMaster,\\r\\n            minimumDeposit: 0.01 ether,\\r\\n            roi: 30,\\r\\n            roiToken: 500,\\r\\n            roiStep: TIME_STEP,\\r\\n            roiStepToken: TIME_STEP_TOKENV2,\\r\\n            fee: 300,\\r\\n            referrerPercent: REFERRER_PERCENTS,\\r\\n            // rquirePool: 0,\\r\\n            // requireAmount: 0,\\r\\n            blockTimeStep: BLOCK_TIME_STEP * 12,\\r\\n            harvestDelay: HARVEST_DELAYV2,\\r\\n            isActived: true\\r\\n        });\\r\\n\\r\\n        poolsLength = 2;\\r\\n\\r\\n        // __ReentrancyGuard_init();\\r\\n        // __UUPSUpgradeable_init();\\r\\n    }\\r\\n\\r\\n    // function _authorizeUpgrade(\\r\\n    //     address newImplementation\\r\\n    // ) internal override onlyOperator {}\\r\\n\\r\\n    // function setMinInvest(uint _pool, uint _amount) external onlyOperator {\\r\\n    //     require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\r\\n    //     pools[_pool].minimumDeposit = _amount;\\r\\n    // }\\r\\n\\r\\n    function setFlatFee(uint256 _flatFee) external onlyOperator {\\r\\n        require(flatFee <= 0.005 ether, \\\"Invalid fee\\\");\\r\\n        flatFee = _flatFee;\\r\\n    }\\r\\n\\r\\n    function payFee() internal enoughFee returns (uint) {\\r\\n        if (flatFee > 0) {\\r\\n            uint devFeeAmount = (flatFee * 10) / 100;\\r\\n            uint mFeeAmount = (flatFee * 5) / 100;\\r\\n            uint feeAmount = flatFee - devFeeAmount - mFeeAmount;\\r\\n            payable(externalWallets.oWallet).transfer(feeAmount);\\r\\n            payable(externalWallets.devWallet).transfer(devFeeAmount);\\r\\n            payable(externalWallets.mWallet).transfer(mFeeAmount);\\r\\n        }\\r\\n        return msg.value - flatFee;\\r\\n    }\\r\\n\\r\\n    function getPool(uint _pool) external view returns (Pool memory) {\\r\\n        return pools[_pool];\\r\\n    }\\r\\n\\r\\n    function transferHandler(address _token, uint _amount, address _to) internal {\\r\\n        if(_token == externalWallets.WBNB){\\r\\n            payable(_to).transfer(_amount);\\r\\n        } else {\\r\\n            IERC20(_token).transfer(_to, _amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBalance(address _token) public view returns (uint) {\\r\\n        if(_token == externalWallets.WBNB){\\r\\n            return address(this).balance;\\r\\n        } else {\\r\\n            return IERC20(_token).balanceOf(address(this));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isValidToken(address _token, bool _forWithdraw) public view returns (bool) {\\r\\n        if(specialConvertionRate[_token] > 0) {\\r\\n            if(!_forWithdraw) {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        if(_forWithdraw && _token == externalWallets.USDT) {\\r\\n            return false;\\r\\n        }\\r\\n        return tokensInvest.contains(_token);\\r\\n    }\\r\\n\\r\\n    function getTokensToWithdraw() external view returns (address[] memory) {\\r\\n        return tokensInvest.values();\\r\\n    }\\r\\n\\r\\n    function tokensLength() external view returns (uint) {\\r\\n        return tokensInvest.length();\\r\\n    }\\r\\n\\r\\n    function tokensAt(uint _index) external view returns (address) {\\r\\n        return tokensInvest.at(_index);\\r\\n    }\\r\\n\\r\\n    // function addTokenToWithdraw(address _token) external onlyOperator {\\r\\n    //     tokensInvest.add(_token);\\r\\n    // }\\r\\n\\r\\n    // uint internal constant PERCENT_DIVIDER = 10_000;// 10k = 100%, 1k = 10%, 100 = 1%, 10 = 0.1%, 1 = 0.01%\\r\\n    function payFeeHandle(address _token, uint amount) internal returns(uint) {\\r\\n        uint devFee = (amount * 100) / PERCENT_DIVIDER;\\r\\n        uint mFee = (amount * 50) / PERCENT_DIVIDER;\\r\\n        uint oFee = (amount * 200) / PERCENT_DIVIDER;\\r\\n        transferHandler(_token, devFee, externalWallets.devWallet);\\r\\n        transferHandler(_token, mFee, externalWallets.mWallet);\\r\\n        transferHandler(_token, oFee, externalWallets.oWallet);\\r\\n        emit FeePayed(msg.sender, devFee + mFee + oFee);\\r\\n        return devFee + mFee + oFee;\\r\\n    }\\r\\n\\r\\n    function setSpecialConvertionRate(address _token, uint _rate) external {\\r\\n        require(msg.sender == operatorAddress || msg.sender == operator2Address, \\\"Invalid sender\\\");\\r\\n        require(_rate <= PERCENT_DIVIDER, \\\"Invalid rate\\\");\\r\\n        require(_token == externalWallets.beat || _token == externalWallets.cryptoBeat, \\\"Invalid token\\\");\\r\\n        specialConvertionRate[_token] = _rate;\\r\\n    }\\r\\n\\r\\n    function takeTokens(address _token, uint _bal) external onlyOperator {\\r\\n        // if(_token == address(0)) {\\r\\n        //     payable(msg.sender).transfer(_bal);\\r\\n        // } else {\\r\\n        //     IERC20(_token).transfer(msg.sender, _bal);\\r\\n        // }\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/AirdropV3/IAirdropV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\n\\r\\ninterface IAirdropV2 {\\r\\n        struct Pool {\\r\\n        address token;\\r\\n        uint minimumDeposit;\\r\\n        uint roi;\\r\\n        uint roiToken;\\r\\n        uint roiStep;\\r\\n        uint roiStepToken;\\r\\n        uint fee;\\r\\n        uint blockTimeStep;\\r\\n        bool isActived;\\r\\n    }\\r\\n\\r\\n    // Info of each user.\\r\\n    struct UserInfo {\\r\\n        address user;\\r\\n        uint id;\\r\\n        uint investment;\\r\\n        uint stakingValue;\\r\\n        uint rewardLockedUp;\\r\\n        uint totalDeposit;\\r\\n        uint totalWithdrawn;\\r\\n        uint nextWithdraw;\\r\\n        uint unlockDate;\\r\\n        uint depositCheckpoint;\\r\\n        uint lastDeposit;\\r\\n    }\\r\\n\\r\\n    struct UserInfo2 {\\r\\n        uint rewardLockedUpToken;\\r\\n        uint depositCheckpointToken;\\r\\n        uint totalWithdrawnToken;\\r\\n    }\\r\\n\\r\\n    struct RefData {\\r\\n        address referrer;\\r\\n        uint refCount;\\r\\n        uint amount;\\r\\n        bool exists;\\r\\n    }\\r\\n\\r\\n    struct ExternalWallets {\\r\\n        address contractsLibrary;\\r\\n        address router;\\r\\n        address WBNB;\\r\\n        address TOKEN_MASTER;\\r\\n        address devWallet;\\r\\n        address oWallet;\\r\\n        address airdropV1;\\r\\n        address vault;\\r\\n        address swapper;\\r\\n    }\\r\\n\\r\\n    event Paused(address account);\\r\\n    event Unpaused(address account);\\r\\n\\r\\n        // mapping(uint => mapping(address => UserInfo)) public users;\\r\\n\\r\\n    function users(uint _poolId, address _user) external view returns (address,\\r\\n            uint,\\r\\n            uint aridrop1Invest,\\r\\n            uint,\\r\\n            uint,\\r\\n            uint,\\r\\n            uint,\\r\\n            uint,\\r\\n            uint,\\r\\n            uint,\\r\\n            uint);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/AirdropV3/IAirdropV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\n\\r\\ninterface IAirdropV3 {\\r\\n    struct Pool {\\r\\n        // address token;\\r\\n        uint minimumDeposit;\\r\\n        uint roi;\\r\\n        uint roiToken;\\r\\n        uint roiStep;\\r\\n        uint roiStepToken;\\r\\n        uint fee;\\r\\n        uint referrerPercent;\\r\\n        uint blockTimeStep;\\r\\n        uint harvestDelay;\\r\\n        bool isActived;\\r\\n    }\\r\\n\\r\\n    // Info of each user.\\r\\n    struct UserInfo {\\r\\n        address user;\\r\\n        uint id;\\r\\n        uint investment;\\r\\n        uint stakingValue;\\r\\n        uint rewardLockedUp;\\r\\n        uint totalDeposit;\\r\\n        uint totalWithdrawn;\\r\\n        uint nextWithdraw;\\r\\n        uint unlockDate;\\r\\n        uint depositCheckpoint;\\r\\n        uint lastDeposit;\\r\\n    }\\r\\n\\r\\n    struct UserInfo2 {\\r\\n        uint rewardLockedUpToken;\\r\\n        uint depositCheckpointToken;\\r\\n        uint totalWithdrawnToken;\\r\\n    }\\r\\n\\r\\n    struct RefData {\\r\\n        address referrer;\\r\\n        uint refCount;\\r\\n        uint amount;\\r\\n        uint totalFefInvest;\\r\\n        bool exists;\\r\\n    }\\r\\n\\r\\n    struct ExternalWallets {\\r\\n        address contractsLibrary;\\r\\n        address router;\\r\\n        address WBNB;\\r\\n        address TOKEN_MASTER;\\r\\n        address devWallet;\\r\\n        address oWallet;\\r\\n        address mWallet;\\r\\n        // address vault;\\r\\n        address USDT;\\r\\n        address btc;\\r\\n        address beat;\\r\\n        address cryptoBeat;\\r\\n        address airdropV1;\\r\\n        // address swapper;\\r\\n        address swapperNormal;\\r\\n    }\\r\\n\\r\\n    event Paused(address account);\\r\\n    event Unpaused(address account);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/AirdropV3/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface ISwapper {\\n    function swapTokens(address token, address tokenPay, uint _spend, uint _need, address _to, address _sendRest) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Resources/IContractsLibraryV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\n\\r\\nabstract contract IContractsLibraryV3 {\\r\\n    function BUSD() external view virtual returns (address);\\r\\n\\r\\n    function WBNB() external view virtual returns (address);\\r\\n\\r\\n    function ROUTER() external view virtual returns (IUniswapV2Router02);\\r\\n\\r\\n    function getBusdToBNBToToken(\\r\\n        address token,\\r\\n        uint _amount\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    function getTokensToBNBtoBusd(\\r\\n        address token,\\r\\n        uint _amount\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    function getTokensToBnb(\\r\\n        address token,\\r\\n        uint _amount\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    function getBnbToTokens(\\r\\n        address token,\\r\\n        uint _amount\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    function getTokenToBnbToAltToken(\\r\\n        address token,\\r\\n        address altToken,\\r\\n        uint _amount\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    function getLpPrice(\\r\\n        address token,\\r\\n        uint _amount\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    function getUsdToBnB(uint amount) external view virtual returns (uint256);\\r\\n\\r\\n    function getBnbToUsd(uint amount) external view virtual returns (uint256);\\r\\n\\r\\n    function getInForTokenToBnbToAltToken(address token, address altToken, uint _amount) external view virtual returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Resources/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Resources/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_airdropV1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_library\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenMaster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devFeeWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mwallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapperNormal\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"REFERRER_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flatFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"forceWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getAllInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllRefData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFefInvest\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"internalType\":\"struct IAirdropV3.RefData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getAllUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IAirdropV3.UserInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDAte\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getDeltaPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getDeltaPendingRewardsToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExternalWallets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractsLibrary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WBNB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"TOKEN_MASTER\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"USDT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"btc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cryptoBeat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"airdropV1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapperNormal\",\"type\":\"address\"}],\"internalType\":\"struct IAirdropV3.ExternalWallets\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInvestorByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiStepToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"harvestDelay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActived\",\"type\":\"bool\"}],\"internalType\":\"struct IAirdropV3.Pool\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getPublicData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalInvestors\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvestCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentInvested\",\"type\":\"uint256\"}],\"internalType\":\"struct AirdropV3.PoolGlobal\",\"name\":\"_poolGlobal\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isPaused_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getRefDataByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFefInvest\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"internalType\":\"struct IAirdropV3.RefData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getRefDataRange\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFefInvest\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"internalType\":\"struct IAirdropV3.RefData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roiStep\",\"type\":\"uint256\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"getRewardsInRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensToWithdraw\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IAirdropV3.UserInfo\",\"name\":\"userInfo_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"pendingRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IAirdropV3.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUserTotalPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUserTotalPendingRewardsToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getUsersRange\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IAirdropV3.UserInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasFirstDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_forWithdraw\",\"type\":\"bool\"}],\"name\":\"isValidToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastWihdrawToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFefInvest\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_flatFee\",\"type\":\"uint256\"}],\"name\":\"setFlatFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setSpecialConvertionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"specialConvertionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProduction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProductionDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProductionVar\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"takeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokensAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"userCanwithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"userCanwithdrawToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDeposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardLockedUpToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpointToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AirdropV3", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000052199485c9f1fcb05a062172e2e00f3ffbdfb2fe00000000000000000000000033c053feb064773f2ecd438dc37c049528ea6d6d00000000000000000000000086333e34c8804532ae34207c46e741cbc3ff3fe30000000000000000000000007faa16cc999fbc45ae5ce4a6b5fe3f12fa54c5c8000000000000000000000000aafbfd47d7623da3eb6420aea095c4e11e6d9f16000000000000000000000000f556a2ef32ffcf95816cf1fbb79922a3607a4a39000000000000000000000000c063e9e6ba40903a97cbc2b7e661d2c8ae8bcd59", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}