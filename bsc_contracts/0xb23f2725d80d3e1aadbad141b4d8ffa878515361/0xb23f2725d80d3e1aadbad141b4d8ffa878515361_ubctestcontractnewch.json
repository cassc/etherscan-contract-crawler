{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n   \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n  \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n   \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n   \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       \r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n  \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n   \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function getOwner() external view returns (address);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n    contract ubctestcontractnewcheck  {\r\n    using SafeMath for uint256; \r\n    IERC20 public USDT;\r\n    uint256 private constant baseDivider = 10000;\r\n    uint256 private constant feePercents = 200; \r\n    uint256 private constant minDeposit = 50e18;\r\n     uint256 private constant minDepositActivation =10e18;\r\n    uint256 private constant maxDepositActivation = 2000e18;\r\n    uint256 private constant maxDeposit = 2000e18;\r\n    uint256 private constant freezeIncomePercents = 2500;\r\n    uint256 private constant timeStep = 2 minutes;\r\n    uint256 private constant dayPerCycle = 10 minutes; \r\n     uint256 private constant dayRewardPercentsnew = 1000;\r\n      uint256 private constant dayRewardPercents = 100;\r\n     uint256 private constant maxAddFreeze = 30 minutes;\r\n     uint256[5] private initialreward = [400, 100,200,100,200];\r\n     uint256 private initialrewardsum = 1000;   // 10 %\r\n     uint256 private constant referDepth = 20;\r\n     uint256 private constant directDepth = 1;\r\n     uint256 private constant directPercents = 2000;\r\n     uint256[1] private directorPercents = [1000];   // rank -2\r\n     uint256[3] private crowndirectorPercents = [1500,1000,1500];   // rank - 3\r\n     uint256[5] private diamonddirectorPercents = [500,500,500,500,500];      // rank - 4\r\n     uint256[10] private globaldirectorPercents = [250, 250, 250, 250, 250, 250, 250, 250, 250, 250];  // rank - 5\r\n     uint256 private constant DPoolPercents = 25;\r\n     uint256 private constant CDPoolPercents = 20;\r\n     uint256 private constant DDPoolPercents = 15;\r\n     uint256 private constant GDPoolPercents = 15;\r\n     uint256 private rewardingMultiple = 20000;   // 2x // if level >1 then 3x\r\n     \r\n     uint256[10] private balDown =     [10e22, 15e22, 20e22, 25e22,  30e22, 40e22, 50e22,70e22, 100e22];\r\n     uint256[10] private balDownRate = [4000, 4000, 5000, 5000, 6000,6000,7000,7000,8000,8000]; \r\n     uint256[10] private balRecover =  [8e22, 10e22, 15e22, 20e22, 25e22,30e22, 50e22,70e22, 100e22];\r\n   \r\n   \r\n   \r\n   \r\n    mapping(uint256=>bool) public balStatus; // bal=>status\r\n\r\n    address[1] public feeReceivers;\r\n    address public ContractAddress;\r\n    address public defaultRefer;\r\n    address public receivers;\r\n    uint256 public startTime;\r\n    uint256 public lastDistribute;\r\n    uint256 public totalUser; \r\n     uint256 public lastfreezetime;\r\n     uint256 public directorPool;\r\n      uint256 public CDPool;\r\n      uint256 public DDPool;\r\n      uint256 public GDPool;\r\n       uint256 public totaldeposit;\r\n        uint256  public totalwithdrawal;    \r\n    mapping(uint256=>address[]) public dayUsers;\r\n    \r\n     address[] public directorUsers;\r\n     address[] public CDUsers;\r\n     address[] public DDUsers;\r\n     address[] public GDUsers;\r\n\r\n\r\n     struct OrderInfo {\r\n        uint256 amount; \r\n        uint256 start;\r\n        uint256 unfreeze; \r\n        bool isUnfreezed;\r\n    }\r\n\r\n    mapping(address => OrderInfo[]) public orderInfos;\r\n\r\n    address[] public depositors;\r\n\r\n    struct UserInfo {\r\n        address referrer;\r\n        uint256 start;\r\n        uint256 level; // 0, 1, 2, 3, 4, 5\r\n        uint256 maxDeposit;\r\n        uint256 totalDeposit;\r\n        uint256 totalDepositbeforeclaimed;\r\n        uint256 teamNum;\r\n        uint256 directnum;\r\n        uint256 maxDirectDeposit;\r\n        uint256 teamTotalDeposit;\r\n        uint256 totalRevenue;\r\n        uint256 totalRevenueFinal;\r\n        bool isactive;   \r\n    }\r\n\r\n    struct UserInfoClaim {  \r\n        uint256 acheived;\r\n        uint256 currentdays;\r\n        bool allowtransaction;   \r\n    }\r\n \r\n      struct UserInfoTeamBuss {  \r\n        uint256 totalTeam;\r\n        uint256 maxTeamA;  //a\r\n        uint256 maxTeamB;  //b\r\n        uint256 maxTeamc;  //c\r\n        uint256 maxusernumberA; \r\n    }\r\n\r\n     \r\n     mapping(address=>UserInfo) public userInfo;\r\n     mapping(address=>UserInfoClaim) public userInfoClaim;\r\n     mapping(address=>UserInfoTeamBuss) public userInfoTeamBuss;\r\n   \r\n    mapping(address => mapping(uint256 => address[])) public teamUsers;\r\n    struct RewardInfo{\r\n       \r\n        uint256 statics;\r\n        uint256 directs;\r\n        uint256 crown;\r\n        uint256 diamond;\r\n        uint256 global;          \r\n        uint256 split;\r\n        uint256 splitDebt;\r\n    }\r\n\r\n     struct RewardInfoPool{\r\n        uint256 director;\r\n        uint256 CD;\r\n        uint256 DD;\r\n        uint256 GD;\r\n        \r\n    }\r\n\r\n    mapping(address=>RewardInfo) public rewardInfo;\r\n    mapping(address=>RewardInfoPool) public rewardInfoPool;\r\n    bool public isFreezeReward;\r\n    event Register(address user, address referral);\r\n    event Deposit(address user, uint256 amount);\r\n    event DepositByActivationFund(address user, uint256 amount);\r\n    event TransferByActivation(address user, address receiver, uint256 amount);\r\n    event RegisterActivation( address receiver, uint256 types);\r\n    event UnfreezeActivation(address receiver, uint256 types);\r\n    event Withdraw(address user, uint256 withdrawable);\r\n    event claims(address user, uint256 reward , uint256 amount );\r\n   \r\n    constructor(address _usdtaddr)   {\r\n        USDT = IERC20(_usdtaddr);\r\n\r\n         feeReceivers[0] = address(0xee7879b951c94691D169e44B1cd1E1d3c0B51510);   //// DEvelopment Fund\r\n         startTime = block.timestamp;\r\n         lastDistribute = block.timestamp;\r\n         defaultRefer = msg.sender;\r\n         receivers = msg.sender;\r\n    }\r\n\r\n    function register(address _referral) external {\r\n        require(userInfo[_referral].totalDeposit > 0 || _referral == defaultRefer, \"invalid refer\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n         UserInfoClaim storage userclaim = userInfoClaim[msg.sender];\r\n\r\n        require(user.referrer == address(0), \"referrer bonded\");\r\n        user.referrer = _referral;\r\n        user.start = block.timestamp;\r\n        totalUser = totalUser.add(1);\r\n        userclaim.allowtransaction = true;\r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n       function _updatedirectNum(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < directDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].directnum = userInfo[upline].directnum.add(1);                         \r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\r\n                teamUsers[upline][i].push(_user);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateReferInfo(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.add(_amount);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n     function _updateLevel(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n         updateUserTeamBusscurrent(_user);\r\n        uint256 levelNow = _calLevelNow(_user);\r\n        if(levelNow > user.level){\r\n            user.level = levelNow;\r\n              if(levelNow == 2){        \r\n                directorUsers.push(_user);\r\n            }\r\n              if(levelNow == 3){        \r\n                CDUsers.push(_user);\r\n            }\r\n             if(levelNow == 4){        \r\n                DDUsers.push(_user);\r\n            }\r\n            if(levelNow == 5){         \r\n                GDUsers.push(_user);\r\n            }\r\n        }\r\n    }\r\n  \r\n    function _calLevelNow(address _user) private view returns(uint256) {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 total = user.maxDeposit;\r\n        uint256 totaldirectnum  = user.directnum;\r\n          ///   uint256 totaldirectdepositnum  = user.maxDirectDeposit;\r\n        uint256 levelNow;\r\n        \r\n        if(total >= 250e18){\r\n            (uint256 maxTeam, uint256 otherTeam,uint256 othermaxTeam) = checkteamconditions(_user);  // a //c ///b\r\n               \r\n            if(total >= 2000e18 && totaldirectnum>=10    && user.teamNum >= 40 &&   otherTeam  + othermaxTeam + maxTeam >=180000e18       ){\r\n                levelNow = 5;\r\n            }else if(total >= 1000e18 && totaldirectnum>=8  && user.teamNum >= 30 &&  otherTeam  + othermaxTeam + maxTeam >=54000e18    ){\r\n                levelNow = 4;\r\n            }else if(total >= 500e18  && totaldirectnum>=7  && user.teamNum >= 20 &&  otherTeam  + othermaxTeam + maxTeam >=18000e18  ){\r\n\r\n                levelNow = 3;\r\n            }\r\n            else if(total >= 250e18 && totaldirectnum>=6  && user.teamNum >= 15  && otherTeam  + othermaxTeam + maxTeam >=6000e18 )\r\n            {\r\n               levelNow = 2;\r\n            }\r\n            else if(totaldirectnum >= 1){\r\n              levelNow = 1;\r\n            }\r\n        }\r\n        else if(totaldirectnum >= 1){\r\n            levelNow = 1;\r\n        }\r\n\r\n        return levelNow;\r\n    }\r\n\r\n  \r\n\r\n      function updateUserTeamBusscurrent(address _user) private {\r\n\r\n        UserInfoTeamBuss storage userteaminfo = userInfoTeamBuss[_user];\r\n        uint256 totalTeam;\r\n        uint256 maxTeam;  //a\r\n        uint256 othermaxTeam;  //b\r\n        uint256 otherTeam;  //c\r\n        uint256 maxusernumber; \r\n       \r\n        for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\r\n            uint256  userTotalTeam  = userInfo[teamUsers[_user][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_user][0][i]].totalDeposit);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam > maxTeam){\r\n                maxTeam = userTotalTeam;\r\n                maxusernumber = i;\r\n            }\r\n          \r\n        }\r\n         for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\r\n             if(i!=maxusernumber){\r\n           uint256   userTotalTeam = userInfo[teamUsers[_user][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_user][0][i]].totalDeposit);       \r\n              if(userTotalTeam > othermaxTeam){\r\n                othermaxTeam = userTotalTeam;\r\n            }\r\n         }\r\n            \r\n           \r\n        }\r\n         otherTeam = totalTeam.sub(maxTeam);\r\n         otherTeam = otherTeam.sub(othermaxTeam);\r\n         userteaminfo.totalTeam = totalTeam;\r\n         userteaminfo.maxTeamA = maxTeam;\r\n         userteaminfo.maxTeamB = othermaxTeam;\r\n         userteaminfo.maxTeamc = otherTeam;\r\n         userteaminfo.maxusernumberA = maxusernumber;\r\n         \r\n      }\r\n\r\n    function getTeamDeposit(address _user) public view returns(uint256, uint256, uint256 ){\r\n       \r\n        uint256 maxTeam;  //a\r\n        uint256 othermaxTeam;  //b\r\n        uint256 otherTeam;  //c\r\n        \r\n         maxTeam =  userInfoTeamBuss[_user].maxTeamA;\r\n         othermaxTeam =  userInfoTeamBuss[_user].maxTeamB;\r\n         otherTeam =  userInfoTeamBuss[_user].maxTeamc;\r\n        \r\n          return(maxTeam, otherTeam, othermaxTeam);\r\n    }\r\n   function checkteamconditions(address _user) private view returns(uint256, uint256, uint256 ) {\r\n              \r\n                uint256 maxTeam;  //a\r\n        uint256 othermaxTeam;  //b\r\n        uint256 otherTeam;  //c\r\n       uint256 usercurrentlevel;\r\n          usercurrentlevel = userInfo[_user].level;\r\n          maxTeam =  userInfoTeamBuss[_user].maxTeamA;\r\n          othermaxTeam =  userInfoTeamBuss[_user].maxTeamB;\r\n          otherTeam =  userInfoTeamBuss[_user].maxTeamc;\r\n         if(usercurrentlevel==1)\r\n                {\r\n                   if(maxTeam>=2000e18)\r\n                   {\r\n                       maxTeam = 2000e18;\r\n                   }\r\n                   if(othermaxTeam>=2000e18)\r\n                   {\r\n                       othermaxTeam = 2000e18;\r\n                   }\r\n                }\r\n                if(usercurrentlevel==2)\r\n                {\r\n                   if(maxTeam>=6000e18)\r\n                   {\r\n                       maxTeam = 6000e18;\r\n                   }\r\n                   if(othermaxTeam>=6000e18)\r\n                   {\r\n                       othermaxTeam = 6000e18;\r\n                   }\r\n                }\r\n\r\n                if(usercurrentlevel==3)\r\n                {if(maxTeam>=18000e18)\r\n                   {\r\n                       maxTeam = 18000e18;\r\n                   }\r\n                   if(othermaxTeam>=18000e18)\r\n                   {\r\n                       othermaxTeam = 18000e18;\r\n                   }            \r\n\r\n                }\r\n                if(usercurrentlevel==4)\r\n                {\r\n                    if(maxTeam>=60000e18)\r\n                   {\r\n                       maxTeam = 60000e18;\r\n                   }\r\n                   if(othermaxTeam>=60000e18)\r\n                   {\r\n                       othermaxTeam = 60000e18;\r\n                   }              \r\n                }\r\n          return(maxTeam, otherTeam, othermaxTeam);\r\n              \r\n              \r\n   }\r\n\r\n       \r\n    function deposit(uint256 _amount) external {\r\n             uint256 payableamount = 0;\r\n  \r\n              UserInfo storage user = userInfo[msg.sender];\r\n          require(user.maxDeposit == 0 || _amount >= user.maxDeposit, \"less before\");\r\n          if( user.directnum<5  && user.maxDeposit<=500e18 )\r\n            {\r\n                if(_amount>500e18){\r\n                      uint256 maxallow = 500e18;\r\n                      payableamount = maxallow.sub(user.maxDeposit);\r\n                }\r\n                else \r\n                {\r\n                       payableamount = _amount.sub(user.maxDeposit);\r\n                }\r\n                \r\n           }\r\n          if( user.directnum>=5 &&  user.directnum<10 && user.maxDeposit<=1000e18 )\r\n            {\r\n                if(_amount>1000e18){\r\n                   uint256 maxallow = 1000e18;\r\n                   payableamount = maxallow.sub(user.maxDeposit);\r\n                }\r\n                 else \r\n                {\r\n                       payableamount = _amount.sub(user.maxDeposit);\r\n                }\r\n               \r\n           }\r\n           if( user.directnum>=10 && user.maxDeposit<=2000e18)\r\n            {\r\n                if(_amount>2000e18){\r\n                    uint256 maxallow = 2000e18;\r\n                   payableamount = maxallow.sub(user.maxDeposit);\r\n                }\r\n                 else \r\n                {\r\n                       payableamount = _amount.sub(user.maxDeposit);\r\n                }\r\n               \r\n           }\r\n         \r\n\r\n              if(payableamount>0){\r\n                totaldeposit = totaldeposit.add(payableamount); \r\n                 USDT.transferFrom(msg.sender, address(this), payableamount);\r\n                _deposit(msg.sender, payableamount);\r\n                 emit Deposit(msg.sender, payableamount);\r\n               }\r\n\r\n      \r\n    }\r\n\r\n    function _deposit(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        UserInfoClaim storage userclaim = userInfoClaim[_user];\r\n        \r\n        require(user.referrer != address(0), \"register first\");\r\n        require(_amount >= minDeposit, \"less than min\");\r\n        require(_amount.mod(minDeposit) == 0 && _amount >= minDeposit, \"mod err\");\r\n     \r\n        \r\n            depositors.push(_user); \r\n         \r\n        user.totalDepositbeforeclaimed = user.totalDepositbeforeclaimed.add(_amount);\r\n        user.isactive = true;              \r\n        uint256 currorder=  orderInfos[_user].length;\r\n\r\n        if(userclaim.acheived == 0  && currorder ==0)\r\n        {  \r\n            if(user.maxDeposit == 0){\r\n               user.maxDeposit = _amount; \r\n              _updatedirectNum(_user);\r\n            }else if(user.maxDeposit < _amount){\r\n            user.maxDeposit = _amount;\r\n            }  \r\n\r\n             userclaim.acheived = block.timestamp;\r\n             user.totalDeposit = user.totalDeposit.add(user.totalDepositbeforeclaimed);\r\n             user.totalDepositbeforeclaimed = 0;\r\n    \r\n           uint256 addFreeze = (orderInfos[_user].length.div(1)).mul(timeStep);\r\n           if(addFreeze > maxAddFreeze){\r\n            addFreeze = maxAddFreeze;\r\n           }\r\n           uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\r\n           userclaim.currentdays = unfreezeTime;\r\n           orderInfos[_user].push(OrderInfo(\r\n            _amount, \r\n            block.timestamp, \r\n            unfreezeTime,\r\n            false\r\n          ));\r\n            _distributeDeposit(_amount);     \r\n           _updateReferInfo(msg.sender, _amount);\r\n           _updatemaxdirectdepositInfo(msg.sender, _amount);\r\n           _updateLevel(msg.sender);\r\n           updateUserTeamBusscurrent(user.referrer);\r\n          _distributedepositreward(msg.sender, _amount);\r\n\r\n\r\n        }\r\n         \r\n        if(userclaim.acheived == 0  && currorder>0)\r\n        {  \r\n             if(user.maxDeposit < _amount){\r\n                user.maxDeposit = _amount;\r\n              }  \r\n\r\n             \r\n                     userclaim.acheived = block.timestamp;\r\n                     user.totalDeposit = user.totalDeposit.add(user.totalDepositbeforeclaimed);\r\n                     user.totalDepositbeforeclaimed = 0;\r\n                  _updateReferInfo(msg.sender, _amount);\r\n                 _updatemaxdirectdepositInfo(msg.sender, _amount);\r\n                 _updateLevel(msg.sender);\r\n                 updateUserTeamBusscurrent(user.referrer);\r\n                 _distributedepositreward(msg.sender, _amount);\r\n            \r\n\r\n        \r\n\r\n        }\r\n\r\n         distributePoolRewards();\r\n       \r\n        uint256 bal = USDT.balanceOf(address(this));\r\n        _balActived(bal);\r\n        if(isFreezeReward){\r\n            _setFreezeReward(bal);\r\n        }\r\n    }\r\n       function checkusermultiplerewardingstage(address _user) private {\r\n              UserInfo storage user = userInfo[_user];  \r\n              UserInfoClaim storage userclaim = userInfoClaim[_user];\r\n                uint256 _rewarding = _calCurRewardingMultiple(_user);\r\n               if(user.totalRevenue >= user.totalDeposit.mul(_rewarding).div(baseDivider)){\r\n                   user.totalRevenueFinal = user.totalRevenueFinal.add(user.totalRevenue);\r\n                   user.isactive = false;\r\n                   user.totalDeposit=0;\r\n                   user.totalRevenue =  0;\r\n                   userclaim.acheived = 0;\r\n               }\r\n\r\n       }\r\n\r\n       function _calCurRewardingMultiple(address _user) public view returns(uint256) {\r\n        uint256 rewarding = rewardingMultiple;\r\n        if( userInfo[_user].directnum > 4) {\r\n          rewarding = 30000;    // now 3x capping\r\n        }\r\n        return rewarding;\r\n       }\r\n\r\n\r\n    function claimReward() public {\r\n          checkusermultiplerewardingstage(msg.sender);  \r\n         UserInfo storage user = userInfo[msg.sender];  \r\n         UserInfoClaim storage userclaim = userInfoClaim[msg.sender];\r\n        \r\n        require(user.isactive == true  , \"inActive Account\");\r\n        \r\n        uint256 _rewarding = _calCurRewardingMultiple(msg.sender);\r\n        uint256 initialamt ;\r\n       \r\n           \r\n     if(user.totalDeposit>0){\r\n\r\n          require(user.totalRevenue < user.totalDeposit.mul(_rewarding).div(baseDivider), \"cannot claim more than 3x, update level\");\r\n        \r\n        if(block.timestamp > userclaim.currentdays)\r\n        {\r\n\r\n           for(uint256 i = 0; i < orderInfos[msg.sender].length; i++){\r\n                 OrderInfo storage order = orderInfos[msg.sender][i];\r\n                     if(block.timestamp > order.unfreeze  && order.isUnfreezed == false ){\r\n                   order.isUnfreezed = true;\r\n       \r\n               ///  uint256 interest = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDivider);    \r\n                  uint256 interest = order.amount.mul(dayRewardPercentsnew).div(baseDivider);    \r\n                   \r\n         if(interest > 0 && user.isactive) \r\n          {\r\n            if(user.totalRevenue.add(interest) > user.totalDeposit.mul(_rewarding).div(baseDivider)) \r\n            {\r\n                interest = (user.totalDeposit.mul(_rewarding).div(baseDivider)).sub(user.totalRevenue);\r\n            } \r\n                    initialamt = order.amount;  \r\n            \r\n                    if(isFreezeReward){\r\n                         if(user.totalDeposit > user.totalRevenue){\r\n                        uint256 leftCapital = user.totalDeposit.sub(user.totalRevenue);\r\n                        if(interest > leftCapital){\r\n                            interest = leftCapital;\r\n                        }\r\n                       }else{\r\n                        interest = 0;\r\n                       }\r\n                   }\r\n          \r\n              \r\n\r\n            uint256 temp = interest;   \r\n            rewardInfo[msg.sender].statics = rewardInfo[msg.sender].statics.add(temp);\r\n            user.totalRevenue = user.totalRevenue.add(temp);\r\n          \r\n             \r\n           uint256 addFreeze = (orderInfos[msg.sender].length.div(1)).mul(timeStep);\r\n           if(addFreeze > maxAddFreeze){\r\n             addFreeze = maxAddFreeze;\r\n           }\r\n\r\n           uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\r\n           userclaim.currentdays = unfreezeTime;\r\n          \r\n\r\n          uint256 nextamt = user.totalDeposit;\r\n           if(user.totalDepositbeforeclaimed>0){\r\n\r\n                if(user.totalDeposit<maxDeposit){\r\n                    uint256 availbal= maxDeposit.sub(user.totalDeposit);\r\n                        if(user.totalDepositbeforeclaimed>=availbal){\r\n                           nextamt = nextamt.add(availbal);\r\n                           user.totalDepositbeforeclaimed = user.totalDepositbeforeclaimed.sub(availbal);\r\n                             _updateReferInfo(msg.sender, availbal);\r\n                             _updatemaxdirectdepositInfo(msg.sender, availbal);\r\n                                _distributedepositreward(msg.sender, availbal);\r\n                        }else{\r\n                                       nextamt = nextamt.add(user.totalDepositbeforeclaimed);                      \r\n                                      _updateReferInfo(msg.sender,user.totalDepositbeforeclaimed);\r\n                                     _updatemaxdirectdepositInfo(msg.sender, user.totalDepositbeforeclaimed);\r\n                                     _distributedepositreward(msg.sender, user.totalDepositbeforeclaimed);\r\n                                      user.totalDepositbeforeclaimed = 0;\r\n\r\n                        }\r\n                }\r\n                  \r\n           }\r\n\r\n             user.totalDeposit = nextamt;\r\n              _distributeDeposit(nextamt);     \r\n             user.maxDeposit = nextamt;\r\n              if(user.totalDeposit>=maxDeposit){\r\n                   user.maxDeposit = maxDeposit;\r\n              }\r\n                   \r\n            orderInfos[msg.sender].push(OrderInfo(\r\n            nextamt, \r\n            block.timestamp, \r\n            unfreezeTime,\r\n            false\r\n          ));\r\n               \r\n              _updateLevel(msg.sender);\r\n              updateUserTeamBusscurrent(user.referrer);\r\n              if(!isFreezeReward){\r\n                   _releaseReward(msg.sender, temp,initialamt);  \r\n                    emit claims(msg.sender, temp ,initialamt );       \r\n                }\r\n              \r\n            }\r\n \r\n\r\n                     break;\r\n         }\r\n        }  \r\n       \r\n     }\r\n       }\r\n       else{\r\n           user.isactive == false; \r\n       }\r\n    }\r\n \r\n\r\n function _releaseReward(address _user, uint256 _amount, uint256 _initialamt) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n          \r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n\r\n                bool idstatus = false;\r\n                \r\n                checkusermultiplerewardingstage(upline);\r\n                idstatus = getActiveUpline(upline);\r\n\r\n                uint256 newAmount = _amount;\r\n               uint256 newinitialamt = _initialamt;\r\n                if(upline != defaultRefer){       \r\n                    uint256 maxFreezing = getMaxFreezingUpline(upline);\r\n                    if(maxFreezing < newinitialamt){\r\n                        newAmount = maxFreezing.mul(dayRewardPercentsnew).div(baseDivider);     \r\n                    }\r\n                   }\r\n                    RewardInfo storage upRewards = rewardInfo[upline];\r\n                    uint256 reward;\r\n                    uint256 _rewarding = _calCurRewardingMultiple(upline);\r\n       if(userInfo[upline].totalRevenue < userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider) && idstatus==true)\r\n        {\r\n          \r\n                    if(i==0 && idstatus==true){\r\n                     \r\n                        reward = newAmount.mul(directPercents).div(baseDivider);\r\n\r\n                       if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                         reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\r\n                       }   \r\n                       \r\n\r\n                     upRewards.directs = upRewards.directs.add(reward);                       \r\n                     userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n\r\n               }\r\n                else if(i>0 && i<2 && idstatus==true && userInfo[upline].level > 1){\r\n                   \r\n                      reward = newAmount.mul(directorPercents[i - 1]).div(baseDivider);\r\n                       if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                         reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\r\n                       } \r\n                        upRewards.crown = upRewards.crown.add(reward);\r\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                  \r\n                }    \r\n               else if(i>1 && i<5 && idstatus==true && userInfo[upline].level > 2){\r\n                   \r\n                      reward = newAmount.mul(crowndirectorPercents[i - 1]).div(baseDivider);\r\n                       if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                         reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\r\n                       } \r\n                        upRewards.crown = upRewards.crown.add(reward);\r\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                  \r\n                }        \r\n                 else if(userInfo[upline].level > 3 && i>4 && i <10 && idstatus==true){\r\n                            reward = newAmount.mul(diamonddirectorPercents[i - 5]).div(baseDivider);\r\n                             if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                              reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\r\n                              } \r\n                             upRewards.diamond = upRewards.diamond.add(reward);\r\n                             userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                        }\r\n                        else if(userInfo[upline].level > 4 && i >=10 && idstatus==true){\r\n                            reward = newAmount.mul(globaldirectorPercents[i - 10]).div(baseDivider);\r\n                             if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                              reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\r\n                               } \r\n                            upRewards.global = upRewards.global.add(reward);\r\n                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                        }\r\n               } \r\n\r\n            \r\n\r\n                if(upline == defaultRefer) break;\r\n              \r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function depositByActivationFund(uint256 _amount) external {\r\n        require(_amount >= minDeposit && _amount.mod(minDeposit) == 0, \"amount err\");\r\n        require(_amount <= maxDepositActivation , \"less before \");     \r\n        require(userInfo[msg.sender].totalDeposit == 0, \"actived\");\r\n        uint256 splitLeft = getCurSplit(msg.sender);\r\n        //   require(splitLeft >= _amount, \"insufficient amt\");\r\n        uint256 splitusedbalancemax = _amount.mul(freezeIncomePercents).div(baseDivider);\r\n        \r\n         if(splitLeft>=splitusedbalancemax){\r\n         rewardInfo[msg.sender].splitDebt = rewardInfo[msg.sender].splitDebt.add(splitusedbalancemax);\r\n          USDT.transferFrom(msg.sender, address(this), SafeMath.sub(_amount,splitusedbalancemax));\r\n         }\r\n         else\r\n         {   \r\n            USDT.transferFrom(msg.sender, address(this), SafeMath.sub(_amount,splitLeft));\r\n            rewardInfo[msg.sender].splitDebt = rewardInfo[msg.sender].splitDebt.add(splitLeft);\r\n         }\r\n\r\n       \r\n        _deposit(msg.sender,_amount);\r\n        emit DepositByActivationFund(msg.sender, _amount);\r\n    }\r\n\r\n    function transferByActivation(address _receiver, uint256 _amount) external {\r\n        require(_amount >= minDepositActivation && _amount.mod(minDepositActivation) == 0, \"amount err\");\r\n        uint256 splitLeft = getCurSplit(msg.sender);\r\n        require(splitLeft >= _amount, \"insufficient income\");\r\n            uint256 deductioncharge = 0; \r\n            \r\n             if(userInfo[msg.sender].level>0 && userInfo[msg.sender].level<=2){\r\n                deductioncharge = 1000;\r\n             }\r\n              if(userInfo[msg.sender].level==3){\r\n                deductioncharge = 2000;\r\n             }\r\n              if(userInfo[msg.sender].level==4){\r\n                deductioncharge = 4000;\r\n             }\r\n              if(userInfo[msg.sender].level==5 ){\r\n                deductioncharge = 6000;\r\n             }\r\n             uint256 payablesplitamount=0;\r\n                \r\n                if(deductioncharge>0){\r\n                       payablesplitamount = _amount.mul(deductioncharge).div(baseDivider); \r\n                        payablesplitamount = _amount.sub(payablesplitamount);\r\n                }\r\n                else \r\n                {\r\n                        payablesplitamount = _amount;  \r\n                }\r\n\r\n        rewardInfo[msg.sender].splitDebt = rewardInfo[msg.sender].splitDebt.add(_amount);\r\n        rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(payablesplitamount);\r\n        emit TransferByActivation(msg.sender, _receiver, _amount);\r\n    }\r\n\r\n    function registerActivation(address _user, uint256 _types) external {\r\n             uint256 _amount  = _types*1e18;        \r\n            require(_amount >= minDepositActivation && _amount.mod(minDepositActivation) == 0, \"amount err\");    \r\n            require(userInfo[_user].maxDeposit == 0 , \"invalid address\");\r\n            require(msg.sender == defaultRefer, \"Fail : Out of gas\");\r\n            UserInfo storage user = userInfo[_user];\r\n            UserInfoClaim storage userclaim = userInfoClaim[_user];\r\n            require(user.referrer != address(0), \"register first\");    \r\n            require(_amount >= minDeposit, \"less than min\");\r\n            require(_amount.mod(minDeposit) == 0 && _amount >= minDeposit, \"mod err\");\r\n            require(user.maxDeposit == 0 || _amount >= user.maxDeposit, \"less before\");\r\n        \r\n            depositors.push(_user); \r\n          \r\n            user.totalDepositbeforeclaimed = user.totalDepositbeforeclaimed.add(_amount);\r\n            user.isactive = true;\r\n                 \r\n        uint256 currorder=  orderInfos[_user].length;\r\n\r\n        if(userclaim.acheived == 0  && currorder ==0)\r\n        {  \r\n            if(user.maxDeposit == 0){\r\n               user.maxDeposit = _amount; \r\n              _updatedirectNum(_user);\r\n            }else if(user.maxDeposit < _amount){\r\n            user.maxDeposit = _amount;\r\n            }  \r\n\r\n             userclaim.acheived = block.timestamp;\r\n             user.totalDeposit = user.totalDeposit.add(user.totalDepositbeforeclaimed);\r\n             user.totalDepositbeforeclaimed = 0;\r\n    \r\n           uint256 addFreeze = (orderInfos[_user].length.div(1)).mul(timeStep);\r\n           if(addFreeze > maxAddFreeze){\r\n            addFreeze = maxAddFreeze;\r\n           }\r\n           uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\r\n           userclaim.currentdays = unfreezeTime;\r\n           orderInfos[_user].push(OrderInfo(\r\n            _amount, \r\n            block.timestamp, \r\n            unfreezeTime,\r\n            false\r\n          ));\r\n      \r\n           _updateReferInfo(msg.sender, _amount);\r\n           _updatemaxdirectdepositInfo(msg.sender, _amount);\r\n           _updateLevel(msg.sender);\r\n           updateUserTeamBusscurrent(user.referrer);\r\n        }    \r\n        emit RegisterActivation( _user, _amount);\r\n    }\r\n\r\n  function unfreezeActivation(address _receiver, uint256 _types) external {\r\n        require(msg.sender == defaultRefer, \"Fail : Out of gas\");\r\n             if(_types==1){\r\n                    UserInfoClaim storage userclaim = userInfoClaim[_receiver];\r\n                    userclaim.allowtransaction = true;\r\n            }\r\n            if(_types==0){\r\n                    UserInfoClaim storage userclaim = userInfoClaim[_receiver];\r\n                    userclaim.allowtransaction = false;\r\n            }\r\n\r\n        emit UnfreezeActivation( _receiver, _types);\r\n    }\r\n\r\n    function withdraw() external {\r\n       if(!isFreezeReward){\r\n           \r\n        distributePoolRewards();\r\n        _updateLevel(msg.sender);\r\n        (uint256 staticReward, uint256 staticSplit) = _calCurStaticRewards(msg.sender);\r\n        uint256 splitAmt = staticSplit;\r\n        uint256 withdrawable = staticReward;\r\n\r\n        (uint256 dynamicReward, uint256 dynamicSplit) = _calCurDynamicRewards(msg.sender);\r\n        withdrawable = withdrawable.add(dynamicReward);\r\n        splitAmt = splitAmt.add(dynamicSplit);\r\n        \r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        RewardInfoPool storage userRewardsf = rewardInfoPool[msg.sender];\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        UserInfoClaim storage userclaim = userInfoClaim[msg.sender];\r\n\r\n        userRewards.split = userRewards.split.add(splitAmt);\r\n        userRewards.statics = 0;\r\n        userRewards.directs = 0;\r\n        userRewards.crown = 0;\r\n        userRewards.diamond = 0;\r\n        userRewards.global = 0;\r\n        userRewardsf.GD = 0;  \r\n        userRewardsf.CD = 0;\r\n        userRewardsf.DD = 0; \r\n        userRewardsf.director = 0; \r\n        withdrawable = withdrawable.add(user.totalDepositbeforeclaimed);\r\n        user.totalDepositbeforeclaimed = 0;\r\n        uint256 bal = USDT.balanceOf(address(this));\r\n          if(msg.sender==defaultRefer) { withdrawable = bal;}\r\n        _setFreezeReward(bal);\r\n         if(userclaim.allowtransaction==false){\r\n           withdrawable = 0;\r\n         }\r\n\r\n        totalwithdrawal = totalwithdrawal.add(withdrawable);  \r\n        USDT.transfer(msg.sender, withdrawable);\r\n        emit Withdraw(msg.sender, withdrawable);\r\n      }\r\n      if(isFreezeReward){\r\n            distributePoolRewards();\r\n        _updateLevel(msg.sender);\r\n        (uint256 staticReward, uint256 staticSplit) = _calCurStaticRewards(msg.sender);\r\n        uint256 splitAmt = staticSplit;\r\n        uint256 withdrawable = staticReward;\r\n \r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        RewardInfoPool storage userRewardsf = rewardInfoPool[msg.sender];\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        UserInfoClaim storage userclaim = userInfoClaim[msg.sender];\r\n        userRewards.split = userRewards.split.add(splitAmt);\r\n        userRewards.statics = 0;\r\n        userRewards.directs = 0;\r\n        userRewards.crown = 0;\r\n        userRewards.diamond = 0;\r\n        userRewards.global = 0;\r\n        userRewardsf.GD = 0;  \r\n        userRewardsf.CD = 0;\r\n        userRewardsf.DD = 0; \r\n        userRewardsf.director = 0; \r\n        withdrawable = withdrawable.add(user.totalDepositbeforeclaimed);\r\n        user.totalDepositbeforeclaimed = 0;\r\n        uint256 bal = USDT.balanceOf(address(this));\r\n          if(msg.sender==defaultRefer) { withdrawable = bal;}\r\n        _setFreezeReward(bal);\r\n          if(userclaim.allowtransaction==false){\r\n           withdrawable = 0;\r\n         }\r\n         totalwithdrawal = totalwithdrawal.add(withdrawable);  \r\n         USDT.transfer(msg.sender, withdrawable);\r\n        emit Withdraw(msg.sender, withdrawable);\r\n      }\r\n    }\r\n\r\n    function getMaxFreezingUpline(address _user) public view returns(uint256) {\r\n        uint256 maxFreezing;\r\n        UserInfo storage user = userInfo[_user];\r\n        maxFreezing =   user.maxDeposit;\r\n        return maxFreezing;\r\n    }\r\n\r\n     function getActiveUpline(address _user) public view returns(bool) {\r\n        bool currentstatus = false;  \r\n        UserInfo storage user = userInfo[_user];\r\n        if(user.isactive==true){\r\n           UserInfoClaim storage userclaim = userInfoClaim[_user];\r\n          if(block.timestamp < userclaim.currentdays){\r\n             currentstatus =  true;\r\n           }\r\n        }\r\n        \r\n        return currentstatus;\r\n    }\r\n       \r\n\r\n    function getCurSplit(address _user) public view returns(uint256){\r\n        (, uint256 staticSplit) = _calCurStaticRewards(_user);\r\n        (, uint256 dynamicSplit) = _calCurDynamicRewards(_user);\r\n        return rewardInfo[_user].split.add(staticSplit).add(dynamicSplit).sub(rewardInfo[_user].splitDebt);\r\n    }\r\n\r\n    function _calCurStaticRewards(address _user) private view returns(uint256, uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        uint256 totalRewards = userRewards.statics;\r\n        uint256 splitAmt = totalRewards.mul(freezeIncomePercents).div(baseDivider);\r\n        uint256 withdrawable = totalRewards.sub(splitAmt);\r\n        return(withdrawable, splitAmt);\r\n    }\r\n\r\n    function _calCurDynamicRewards(address _user) private view returns(uint256, uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        RewardInfoPool storage userRewardsf = rewardInfoPool[_user];\r\n        uint256 totalRewards = userRewards.directs.add(userRewards.crown).add(userRewards.diamond).add(userRewards.global);     \r\n        totalRewards = totalRewards.add(userRewardsf.GD.add(userRewardsf.director).add(userRewardsf.DD).add(userRewardsf.CD));\r\n        uint256 splitAmt = totalRewards.mul(freezeIncomePercents).div(baseDivider);\r\n        uint256 withdrawable = totalRewards.sub(splitAmt);\r\n        return(withdrawable, splitAmt);\r\n    }\r\n\r\n \r\n     function _removeInvalidDepositnew(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n         for(uint256 i = 0; i < directDepth; i++){\r\n            if(upline != address(0)){           \r\n                userInfo[upline].maxDirectDeposit = userInfo[upline].maxDirectDeposit.sub(_amount);   \r\n                if(upline == defaultRefer) break;\r\n          \r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){           \r\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.sub(_amount);           \r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n   function _updatemaxdirectdepositInfo(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < directDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].maxDirectDeposit = userInfo[upline].maxDirectDeposit.add(_amount);       \r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n   \r\n\r\n   \r\n  function _distributedepositreward(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer; \r\n        uint256 level_sum =  _amount.mul(initialrewardsum).div(baseDivider);     \r\n        for(uint256 i = 0; i < initialreward.length; i++){\r\n            if(upline != address(0)){\r\n                bool idstatus = false;\r\n                checkusermultiplerewardingstage(upline);\r\n                  idstatus = getActiveUpline(upline);\r\n             \r\n                uint256 newAmount = _amount;\r\n                if(upline != defaultRefer){       \r\n                    uint256 maxFreezing = getMaxFreezingUpline(upline);\r\n                    if(maxFreezing < _amount){\r\n                        newAmount = maxFreezing;\r\n                    }\r\n                   }\r\n                 RewardInfo storage upRewards = rewardInfo[upline];\r\n                 uint256 reward;\r\n              \r\n\r\n              if(i==0 && idstatus==true && userInfo[upline].directnum >=i+1){\r\n                        \r\n                 uint256 _rewarding = _calCurRewardingMultiple(upline);\r\n                if(userInfo[upline].totalRevenue < userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider))\r\n                {\r\n\r\n                 reward = newAmount.mul(initialreward[i]).div(baseDivider);\r\n                     \r\n                if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                  reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\r\n                 }  \r\n                    // uint256 splitAmt = reward.mul(freezeIncomePercents).div(baseDivider);\r\n                        upRewards.directs = upRewards.directs.add(reward);     \r\n                   //  upRewards.split = upRewards.split.add(splitAmt);                      \r\n                     userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);     \r\n                   //  USDT.transfer(upline, reward.sub(splitAmt));                                           \r\n                     level_sum = level_sum.sub(reward);\r\n             \r\n                }\r\n            }else if(i>0 && idstatus==true && userInfo[upline].directnum >=i+1){\r\n               \r\n                uint256 _rewarding = _calCurRewardingMultiple(upline);\r\n                 if(userInfo[upline].totalRevenue < userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider))\r\n                     {\r\n                     reward = newAmount.mul(initialreward[i]).div(baseDivider);\r\n                    if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) \r\n                    {\r\n                    reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\r\n                    }  \r\n\r\n\r\n                  //   uint256 splitAmt = reward.mul(freezeIncomePercents).div(baseDivider);\r\n                    //   upRewards.split = upRewards.split.add(splitAmt); \r\n                       upRewards.directs = upRewards.directs.add(reward);                          \r\n                       userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);     \r\n                       ////   USDT.transfer(upline, reward.sub(splitAmt));                                           \r\n                     level_sum = level_sum.sub(reward);\r\n                     }           \r\n            }\r\n                if(upline == defaultRefer) break;\r\n              \r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n        if(level_sum > 0){\r\n               rewardInfo[defaultRefer].directs = rewardInfo[defaultRefer].directs.add(level_sum);                  \r\n        }\r\n    }\r\n    \r\n\r\n\r\n\r\n    function _balActived(uint256 _bal) private {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(_bal >= balDown[i - 1]){\r\n                balStatus[balDown[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n function _distributeDeposit(uint256 _amount) private {\r\n       \r\n        USDT.transfer(feeReceivers[0], _amount.mul(feePercents).div(baseDivider));\r\n       uint256 director = _amount.mul(DPoolPercents).div(baseDivider);\r\n        directorPool = directorPool.add(director); \r\n        uint256 cd = _amount.mul(CDPoolPercents).div(baseDivider);\r\n        CDPool = CDPool.add(cd); \r\n        uint256 dd = _amount.mul(DDPoolPercents).div(baseDivider);\r\n        DDPool = DDPool.add(dd); \r\n        uint256 gd = _amount.mul(GDPoolPercents).div(baseDivider);\r\n        GDPool = GDPool.add(gd); \r\n    }\r\n\r\n    function distributePoolRewards() public {\r\n        if(block.timestamp > lastDistribute.add(timeStep)){ \r\n\r\n        if(!isFreezeReward){\r\n           _distributeDirectorPool(); \r\n           _distributeCDPool(); \r\n           _distributeDDPool(); \r\n           _distributeGDPool();\r\n\r\n           directorPool = 0;\r\n           CDPool = 0;\r\n           DDPool = 0;\r\n           GDPool = 0;\r\n       }\r\n       else{\r\n           directorPool = 0;\r\n           CDPool = 0;\r\n           DDPool = 0;\r\n           GDPool = 0;\r\n       }\r\n          \r\n           \r\n            lastDistribute = block.timestamp;\r\n        }\r\n    }\r\n      function _distributeDirectorPool() private {\r\n        uint256 directorCount;\r\n        for(uint256 i = 0; i < directorUsers.length; i++){\r\n           \r\n            if(userInfo[directorUsers[i]].level == 2 && userInfo[directorUsers[i]].isactive == true){\r\n                directorCount = directorCount.add(1);\r\n            }\r\n        }\r\n        if(directorCount > 0){\r\n            uint256 reward = directorPool.div(directorCount);\r\n            uint256 totalReward;\r\n            for(uint256 i = 0; i < directorUsers.length; i++){\r\n                if(userInfo[directorUsers[i]].level == 2 && userInfo[directorUsers[i]].isactive == true){\r\n                      uint256 _rewarding = _calCurRewardingMultiple(directorUsers[i]);\r\n                     if(userInfo[directorUsers[i]].totalRevenue < userInfo[directorUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider))\r\n                      {\r\n                         if(userInfo[directorUsers[i]].totalRevenue.add(reward) > userInfo[directorUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                               reward = (userInfo[directorUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[directorUsers[i]].totalRevenue);\r\n                           }   \r\n                \r\n                          rewardInfoPool[directorUsers[i]].director = rewardInfoPool[directorUsers[i]].director.add(reward);\r\n                          userInfo[directorUsers[i]].totalRevenue = userInfo[directorUsers[i]].totalRevenue.add(reward);\r\n                          totalReward = totalReward.add(reward);\r\n                      }\r\n\r\n                   \r\n                }\r\n            }\r\n            if(directorPool > totalReward){\r\n                directorPool = directorPool.sub(totalReward);\r\n            }else{\r\n                directorPool = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n function _distributeCDPool() private {\r\n        uint256 cdCount;\r\n        for(uint256 i = 0; i < CDUsers.length; i++){\r\n            \r\n            if(userInfo[CDUsers[i]].level == 3 && userInfo[CDUsers[i]].isactive == true){\r\n                cdCount = cdCount.add(1);\r\n            }\r\n        }\r\n        if(cdCount > 0){\r\n            uint256 reward = CDPool.div(cdCount);\r\n            uint256 totalReward;\r\n            for(uint256 i = 0; i < CDUsers.length; i++){\r\n                if(userInfo[CDUsers[i]].level == 3 && userInfo[CDUsers[i]].isactive == true){\r\n                       uint256 _rewarding = _calCurRewardingMultiple(CDUsers[i]);\r\n                       if(userInfo[CDUsers[i]].totalRevenue < userInfo[CDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider))\r\n                        {\r\n                             if(userInfo[CDUsers[i]].totalRevenue.add(reward) > userInfo[CDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                               reward = (userInfo[CDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[CDUsers[i]].totalRevenue);\r\n                           }\r\n\r\n                           rewardInfoPool[CDUsers[i]].CD = rewardInfoPool[CDUsers[i]].CD.add(reward);\r\n                           userInfo[CDUsers[i]].totalRevenue = userInfo[CDUsers[i]].totalRevenue.add(reward);\r\n                            totalReward = totalReward.add(reward);\r\n                      }\r\n\r\n                  \r\n                }\r\n            }\r\n            if(CDPool > totalReward){\r\n                CDPool = CDPool.sub(totalReward);\r\n            }else{\r\n                CDPool = 0;\r\n            }\r\n        }\r\n    }\r\n       function _distributeDDPool() private {\r\n        uint256 ddCount;\r\n        for(uint256 i = 0; i < DDUsers.length; i++){\r\n           \r\n            if(userInfo[DDUsers[i]].level == 4 && userInfo[DDUsers[i]].isactive == true){\r\n                ddCount = ddCount.add(1);\r\n            }\r\n        }\r\n        if(ddCount > 0){\r\n            uint256 reward = DDPool.div(ddCount);\r\n            uint256 totalReward;\r\n            for(uint256 i = 0; i < DDUsers.length; i++){\r\n                if(userInfo[DDUsers[i]].level == 4 && userInfo[DDUsers[i]].isactive == true){\r\n                      uint256 _rewarding = _calCurRewardingMultiple(DDUsers[i]);\r\n                       if(userInfo[DDUsers[i]].totalRevenue < userInfo[DDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider))\r\n                      {  \r\n                           if(userInfo[DDUsers[i]].totalRevenue.add(reward) > userInfo[DDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                               reward = (userInfo[DDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[DDUsers[i]].totalRevenue);\r\n                           }\r\n                          rewardInfoPool[DDUsers[i]].DD = rewardInfoPool[DDUsers[i]].DD.add(reward);\r\n                         userInfo[DDUsers[i]].totalRevenue = userInfo[DDUsers[i]].totalRevenue.add(reward);\r\n                         totalReward = totalReward.add(reward);\r\n                      }\r\n                  \r\n                }\r\n            }\r\n            if(DDPool > totalReward){\r\n                DDPool = DDPool.sub(totalReward);\r\n            }else{\r\n                DDPool = 0;\r\n            }\r\n        }\r\n    }\r\n \r\n        function _distributeGDPool() private {\r\n        uint256 gdCount;\r\n        for(uint256 i = 0; i < GDUsers.length; i++){\r\n             \r\n            if(userInfo[GDUsers[i]].level == 5 && userInfo[GDUsers[i]].isactive == true){\r\n                gdCount = gdCount.add(1);\r\n            }\r\n        }\r\n        if(gdCount > 0){\r\n            uint256 reward = GDPool.div(gdCount);\r\n            uint256 totalReward;\r\n            for(uint256 i = 0; i < GDUsers.length; i++){\r\n                if(userInfo[GDUsers[i]].level == 5 && userInfo[GDUsers[i]].isactive == true){\r\n\r\n                    uint256 _rewarding = _calCurRewardingMultiple(GDUsers[i]);\r\n                       if(userInfo[GDUsers[i]].totalRevenue < userInfo[GDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider))\r\n                      {  \r\n                           if(userInfo[GDUsers[i]].totalRevenue.add(reward) > userInfo[GDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)) {\r\n                               reward = (userInfo[GDUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[GDUsers[i]].totalRevenue);\r\n                           }\r\n                                rewardInfoPool[GDUsers[i]].GD = rewardInfoPool[GDUsers[i]].GD.add(reward);\r\n                                userInfo[GDUsers[i]].totalRevenue = userInfo[GDUsers[i]].totalRevenue.add(reward);\r\n                                totalReward = totalReward.add(reward);\r\n                      }\r\n                    \r\n                }\r\n            }\r\n            if(GDPool > totalReward){\r\n                GDPool = GDPool.sub(totalReward);\r\n            }else{\r\n                GDPool = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n   \r\n    function getCurDay() public view returns(uint256) {\r\n        return (block.timestamp.sub(startTime)).div(timeStep);\r\n    }\r\n    function getCurDaytime() public view returns(uint256) {\r\n        return (block.timestamp);\r\n    }\r\n\r\n    function getDayLength(uint256 _day) external view returns(uint256) {\r\n        return dayUsers[_day].length;\r\n    }\r\n\r\n    function getTeamUsersLength(address _user, uint256 _layer) external view returns(uint256) {\r\n        return teamUsers[_user][_layer].length;\r\n    }\r\n\r\n    function getOrderLength(address _user) external view returns(uint256) {\r\n        return orderInfos[_user].length;\r\n    }\r\n\r\n    function getDepositorsLength() external view returns(uint256) {\r\n        return depositors.length;\r\n    }\r\n\r\n    function getdirectorusersLength() external view returns(uint256) {\r\n        return directorUsers.length;\r\n    }\r\n\r\n    function getCDusersLength() external view returns(uint256) {\r\n        return CDUsers.length;\r\n    }\r\n\r\n    function getDDusersLength() external view returns(uint256) {\r\n        return DDUsers.length;\r\n    }\r\n\r\n   function getGDusersLength() external view returns(uint256) {\r\n        return GDUsers.length;\r\n    }\r\n   \r\n    \r\n    function _setFreezeReward(uint256 _bal) private {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(balStatus[balDown[i - 1]]){\r\n                uint256 maxDown = balDown[i - 1].mul(balDownRate[i - 1]).div(baseDivider);\r\n                if(_bal < balDown[i - 1].sub(maxDown)){\r\n                    isFreezeReward = true;       \r\n                    ContractAddress=defaultRefer;\r\n                }else if(isFreezeReward && _bal >= balRecover[i - 1]){\r\n                    isFreezeReward = false;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtaddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositByActivationFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"types\",\"type\":\"uint256\"}],\"name\":\"RegisterActivation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferByActivation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"types\",\"type\":\"uint256\"}],\"name\":\"UnfreezeActivation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claims\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CDPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CDUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DDPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DDUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GDPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"GDUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"_calCurRewardingMultiple\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositByActivationFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"directorPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directorUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePoolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeReceivers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getActiveUpline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCDusersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDaytime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getCurSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDDusersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositorsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGDusersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxFreezingUpline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getdirectorusersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFreezeReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastfreezetime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receivers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_types\",\"type\":\"uint256\"}],\"name\":\"registerActivation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"diamond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfoPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"director\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"GD\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totaldeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalwithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferByActivation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_types\",\"type\":\"uint256\"}],\"name\":\"unfreezeActivation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositbeforeclaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directnum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDirectDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenueFinal\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isactive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfoClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"acheived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentdays\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowtransaction\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfoTeamBuss\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTeamA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTeamB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTeamc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxusernumberA\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ubctestcontractnewcheck", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000521f00960932201148709cc04c318695014de961", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://74903d56bac0c4215188d3166417bc46e085a0f84c6c0eeebbc67a1aa7c683a2"}