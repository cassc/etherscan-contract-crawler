{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/GnosisSafe.sol\\\";\\nimport \\\"./interfaces/RainbowRouter.sol\\\";\\n\\n/// @title Rainbow fee collector\\n/// @author Ghilia Weldesselasie - <ghili@rainbow.me>\\n/// @dev Gnosis safe module that calls access controlled withdrawal functions on the Rainbow Router\\n/// @dev sweeper bot calls collectX()\\n///      -> safe.execTransactionFromModule()\\n///      -> RainbowRouter.withdrawX() (called by our Gnosis safe instance)\\ncontract FeeCollector {\\n\\n    /// the gnosis safe we execute withdrawals from\\n    GnosisSafe public immutable safe;\\n\\n    /// @dev we use a bot to call our collect functions, that bot is designed as our caller\\n    address public caller;\\n\\n    /// @dev address that receives the funds\\n    address public receiver;\\n\\n    /// @dev address of the swap aggregator aka RainbowRouter\\n    address public router;\\n\\n    /// @dev we don't want our caller's balance to go below this amount\\n    uint256 public minExpectedBalance;\\n\\n    /// @dev modifier that ensures only the safe contract is allowed to call a specific method\\n    modifier onlySafe() {\\n        require(msg.sender == address(safe), \\\"FC: CALLER_NOT_SAFE\\\");\\n        _;\\n    }\\n\\n    /// @dev modifier that ensures only the whitelisted caller is allowed to call a specific method\\n    modifier onlyCaller() {\\n        require(msg.sender == address(caller), \\\"FC: CALLER_NOT_ALLOWED\\\");\\n        _;\\n    }\\n\\n    /// @param _receiver Address that will receive the withdrawn fees\\n    /// @param _router Rainbow Router instance address\\n    /// @param _safe Gnosis safe instance address\\n    constructor(address _caller, address _receiver, address _router, address _safe, uint256 _threshold) {\\n        caller = _caller;\\n        receiver = _receiver;\\n        router = _router;\\n        safe = GnosisSafe(_safe);\\n        minExpectedBalance = _threshold;\\n    }\\n\\n    /// @dev Function for collecting ETH fees from the Rainbow Router, calling the RainbowRouter.withdrawETH function\\n    /// @dev only the caller addres is allowed to call this function\\n    /// @param amount Amount in wei we want to withdraw from the Rainbow Router\\n    function collectETHFees(uint256 amount) external onlyCaller {\\n\\n        // if our bot's ETH balance is below the threshold, we have to top it up again using funds from the safe\\n        uint256 initialCallerBalance = caller.balance;\\n\\n        // amount we top up the bot with, 0 unless minExpectedBalance > initialCallerBalance\\n        uint256 topUpAmount = 0;\\n\\n        if (minExpectedBalance > initialCallerBalance) {\\n            uint256 delta = minExpectedBalance - initialCallerBalance;\\n            topUpAmount = amount <= delta ? amount : delta;\\n\\n            require(\\n                safe.execTransactionFromModule(\\n                    router,\\n                    0,\\n                    abi.encodeWithSelector(\\n                        RainbowRouter.withdrawEth.selector,\\n                        caller,\\n                        topUpAmount\\n                    ),\\n                    GnosisSafe.Operation.CALL\\n                ),\\n                \\\"FC: EW_FAILED\\\"\\n            );\\n        }\\n\\n        // if topUpAmount == amount, then amount - topUpAmount == 0\\n        // a transfer of 0 tokens would just waste gas so let's avoid it\\n        uint256 amountLeftToWithdraw = amount - topUpAmount;\\n        if (amountLeftToWithdraw > 0) {\\n            require(\\n                safe.execTransactionFromModule(\\n                    router,\\n                    0,\\n                    abi.encodeWithSelector(\\n                        RainbowRouter.withdrawEth.selector,\\n                        receiver,\\n                        amountLeftToWithdraw\\n                    ),\\n                    GnosisSafe.Operation.CALL\\n                ),\\n                \\\"FC: EW_FAILED\\\"\\n            );\\n        }\\n\\n    }\\n\\n    /// @dev Function for collecting fees in any token from the Rainbow Router, calling the RainbowRouter.withdrawToken function\\n    /// @dev only the caller addres is allowed to call this function\\n    /// @param token Address of token contract we want to withdraw from the Rainbow Router\\n    /// @param amount Amount in wei we want to withdraw from the Rainbow Router\\n    function collectTokenFees(address token, uint256 amount) external onlyCaller {\\n        require(\\n            safe.execTransactionFromModule(\\n                router,\\n                0,\\n                abi.encodeWithSelector(\\n                    RainbowRouter.withdrawToken.selector,\\n                    token,\\n                    receiver,\\n                    amount\\n                ),\\n                GnosisSafe.Operation.CALL\\n            ),\\n            \\\"FC: TW_FAILED\\\"\\n        );\\n    }\\n\\n    /// @dev Function for updating the address we want to be able to call the collect functions\\n    ///      This update can only be performed by the safe, via a safe transaction\\n    /// @param newCaller Address of the new receiver\\n    function updateCaller(address newCaller) external onlySafe {\\n        caller = newCaller;\\n    }\\n\\n    /// @dev Function for updating the address we want to forward collected fees to\\n    ///      This update can only be performed by the safe, via a safe transaction\\n    /// @param newReceiver Address of the new receiver\\n    function updateReceiver(address newReceiver) external onlySafe {\\n        receiver = newReceiver;\\n    }\\n\\n    /// @dev Function for updating the Rainbow Router address\\n    ///      This update can only be performed by the safe, via a safe transaction\\n    /// @param newRouter Address of the new Rainbow Router contract\\n    function updateRouter(address newRouter) external onlySafe {\\n        router = newRouter;\\n    }\\n\\n    /// @dev Function for updating the minimum expected balance that we don't want to go below\\n    ///      This update can only be performed by the safe\\n    /// @param newMinBalance new minimum balance amount\\n    function updateMinBalance(uint256 newMinBalance) external onlySafe {\\n        minExpectedBalance = newMinBalance;\\n    }\\n\\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n    /// @param data The encoded function data for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via data\\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\\n        uint256 length = data.length;\\n        results = new bytes[](length);\\n        bytes calldata call;\\n        bytes memory result;\\n        for (uint256 i = 0; i < length;) {\\n            bool success;\\n            call = data[i];\\n            (success, results[i]) = address(this).delegatecall(data[i]);\\n            result = results[i];\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n            unchecked { ++i; }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/GnosisSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.13;\\n\\ninterface GnosisSafe {\\n    enum Operation {\\n        CALL,\\n        DELEGATECALL\\n    }\\n\\n    /// @dev Allows to add a module to the whitelist.\\n    ///      This can only be done via a Safe transaction.\\n    /// @notice Enables the module `module` for the Safe.\\n    /// @param module Module to be whitelisted.\\n    function enableModule(address module) external;\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Operation operation\\n    ) external returns (bool);\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Operation operation\\n    ) external returns (bool, bytes memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/RainbowRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.13;\\n\\n/// @title Rainbow swap aggregator contract\\ninterface RainbowRouter {\\n\\n    /// @dev method to withdraw ETH (from the fees)\\n    /// @param to address that's receiving the ETH\\n    /// @param amount amount of ETH to withdraw\\n    function withdrawEth(\\n        address to, \\n        uint256 amount\\n    ) external;\\n\\n    /// @dev method to withdraw ERC20 tokens (from the fees)\\n    /// @param token address of the token to withdraw\\n    /// @param to address that's receiving the tokens\\n    /// @param amount amount of tokens to withdraw\\n    function withdrawToken(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solenv/=lib/solenv/\",\r\n      \"solidity-stringutils/=lib/solenv/lib/solidity-stringutils/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_safe\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"caller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collectETHFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collectTokenFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minExpectedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safe\",\"outputs\":[{\"internalType\":\"contract GnosisSafe\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCaller\",\"type\":\"address\"}],\"name\":\"updateCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinBalance\",\"type\":\"uint256\"}],\"name\":\"updateMinBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"updateReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FeeCollector", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000da509ed1eb1c1c133727b2220f882ce20f2e20d90000000000000000000000009670271ec2e2937a2e9df536784344bbff2bbea600000000000000000000000000000000009726632680fb29d3f7a9734e3010e20000000000000000000000009670271ec2e2937a2e9df536784344bbff2bbea60000000000000000000000000000000000000000000000000de0b6b3a7640000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}