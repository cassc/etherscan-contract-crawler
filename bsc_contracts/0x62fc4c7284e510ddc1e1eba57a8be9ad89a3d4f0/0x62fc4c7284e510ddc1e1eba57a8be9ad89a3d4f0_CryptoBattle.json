{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n//NFT Contract interface\r\ninterface NftInterface {\r\n    // function definition of the method we want to interact with\r\n    function mint(uint256 _level, address _recipient) external payable;\r\n\r\n    //Get price of level\r\n    function price() external view returns (uint256);\r\n\r\n    // function check is Authorized Access to level\r\n    function walletisAuthorized(\r\n        address _wallet,\r\n        uint256 _level\r\n    ) external view returns (bool);\r\n}\r\n\r\n//Oracle interface\r\ninterface OracleInterface {\r\n    // function definition of the method we want to interact with\r\n    function getLatestPrice(\r\n        uint256 _tokenAmount,\r\n        bool _isBNB\r\n    ) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function WBNB() external pure returns (address);\r\n\r\n    function WAVAX() external pure returns (address);\r\n\r\n    function WHT() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function addLiquidityBNB(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function addLiquidityAVAX(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function addLiquidityHT(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactTokensForBNBSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactTokensForHTSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract CryptoBattle {\r\n    using SafeMath for uint256;\r\n\r\n    struct Tower {\r\n        uint256 crystals;\r\n        uint256 money;\r\n        uint256 money2;\r\n        uint256 yield;\r\n        uint256 timestamp;\r\n        uint256 hrs;\r\n        address ref;\r\n        uint256 refs;\r\n        uint256 refDeps;\r\n        uint8 treasury;\r\n        uint8[5] chefs;\r\n    }\r\n\r\n    struct KingUser {\r\n        uint256 investments;\r\n        uint256 profit;\r\n    }\r\n\r\n    mapping(address => Tower) public towers;\r\n    mapping(address => KingUser) public kinguser;\r\n\r\n    uint256 public startDate;\r\n    NftInterface public NFTContract =\r\n        NftInterface(0xB48CD2af963d5e2a211beBFf6D98d419b32Aa30C);\r\n    IERC20 public CBT = IERC20(0x695e8c4e49718EbF665E916e575b00330D49Ae00);\r\n    OracleInterface public Oracle =\r\n        OracleInterface(0x695e8c4e49718EbF665E916e575b00330D49Ae00);\r\n    IUniswapV2Router02 public swapV2Router =\r\n        IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    address public WRAPPED_NATIVE = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n\r\n    uint256 public BUY_PRICE = 5e14; // 0.0005 BNB\r\n    uint256 public SELL_PRICE = 5e12; // 0.000005 BNB\r\n\r\n    uint256 public constant PENALTY_CRYSTAL_SELL = 200; // 20% of penalty trade crystals direct\r\n    uint256 public constant PENALTY_COINS_BURN = 500; // 50% of penalty coins burn\r\n\r\n    address payable public WALLET_PROJECT;\r\n    address payable public WALLET_MARKETING;\r\n    address payable public WALLET_FUND;\r\n    address payable public WALLET_TREASURY;\r\n    address payable public WALLET_PARTNER;\r\n\r\n    uint256 public constant PROJECT_FEE = 30; // 3% of deposit\r\n    uint256 public constant MARKETING_FEE = 30; // 3% of deposit\r\n    uint256 public constant FUND_FEE = 15; // 1.5% of deposit\r\n    uint256 public constant TREASURY_FEE = 40; // 4% of deposit\r\n    uint256 public constant PARTNER_FEE = 5; // 0.5% of deposit\r\n\r\n    uint256 internal constant FEE_C = 15; // SUPPORT fee 1.5% of crystals\r\n\r\n    uint256 public constant PERCENTS_DIVIDER = 1000;\r\n\r\n    uint256 public constant TIME_STEP = 1 hours; // 3600 seconds\r\n\r\n    uint256 public totalChefs;\r\n    uint256 public totalTowers;\r\n    uint256 public totalInvested;\r\n\r\n    uint256 public immutable denominator = 10;\r\n    bool public init;\r\n\r\n    modifier initialized() {\r\n        require(init, \"Not initialized\");\r\n        _;\r\n    }\r\n\r\n    event FeePayed(address indexed user, uint256 totalAmount);\r\n\r\n    constructor(\r\n        address payable _walletMarketing,\r\n        address payable _walletFund,\r\n        address payable _walletTreasury,\r\n        address payable _walletPartner,\r\n        uint256 startTime\r\n    ) {\r\n        require(\r\n            _walletMarketing != address(0) &&\r\n                _walletFund != address(0) &&\r\n                _walletTreasury != address(0) &&\r\n                _walletPartner != address(0)\r\n        );\r\n\r\n        WALLET_PROJECT = payable(msg.sender);\r\n        WALLET_MARKETING = _walletMarketing;\r\n        WALLET_FUND = _walletFund;\r\n        WALLET_TREASURY = _walletTreasury;\r\n        WALLET_PARTNER = _walletPartner;\r\n\r\n        if (startTime > 0) {\r\n            startDate = startTime;\r\n        } else {\r\n            startDate = block.timestamp;\r\n        }\r\n    }\r\n\r\n    //to recieve ETH from uniswapV2Router when swaping\r\n    receive() external payable {}\r\n\r\n    function initializeAuto() internal {\r\n        require(!init);\r\n        init = true;\r\n    }\r\n\r\n    function UpdateStartDate(uint256 _startDate) public {\r\n        require(\r\n            msg.sender == WALLET_PROJECT,\r\n            \"Only developer can update start date\"\r\n        );\r\n        require(block.timestamp < startDate, \"Start date must be in future\");\r\n        require(!init);\r\n        startDate = _startDate;\r\n    }\r\n\r\n    function updateMarketingWallet(address newWallet) public {\r\n        require(\r\n            msg.sender == WALLET_PROJECT,\r\n            \"Only developer can update start date\"\r\n        );\r\n        require(!isContract(newWallet), \"New wallet is a contract\");\r\n        require(newWallet != address(0), \"Invalid address\");\r\n        WALLET_MARKETING = payable(newWallet);\r\n    }\r\n\r\n    function updateProjectWallet(address newWallet) public {\r\n        require(\r\n            msg.sender == WALLET_PROJECT,\r\n            \"Only developer can update start date\"\r\n        );\r\n        require(!isContract(newWallet), \"New wallet is a contract\");\r\n        require(newWallet != address(0), \"Invalid address\");\r\n        WALLET_PROJECT = payable(newWallet);\r\n    }\r\n\r\n    function updateFundWallet(address newWallet) public {\r\n        require(\r\n            msg.sender == WALLET_PROJECT || msg.sender == WALLET_FUND,\r\n            \"Only developer can update start date\"\r\n        );\r\n        require(!isContract(newWallet), \"New wallet is a contract\");\r\n        require(newWallet != address(0), \"Invalid address\");\r\n        WALLET_FUND = payable(newWallet);\r\n    }\r\n\r\n    function updatePartnerWallet(address newWallet) public {\r\n        require(\r\n            msg.sender == WALLET_PROJECT || msg.sender == WALLET_PARTNER,\r\n            \"Only developer can update start date\"\r\n        );\r\n        require(!isContract(newWallet), \"New wallet is a contract\");\r\n        require(newWallet != address(0), \"Invalid address\");\r\n        WALLET_PARTNER = payable(newWallet);\r\n    }\r\n\r\n    function updateTreasuryWallet(address newWallet) public {\r\n        require(\r\n            msg.sender == WALLET_PROJECT || msg.sender == WALLET_TREASURY,\r\n            \"Only developer can update start date\"\r\n        );\r\n        require(!isContract(newWallet), \"New wallet is a contract\");\r\n        require(newWallet != address(0), \"Invalid address\");\r\n        WALLET_TREASURY = payable(newWallet);\r\n    }\r\n\r\n    function FeePayout(uint256 msgValue, uint256 crystl) internal {\r\n        uint256 totalFee = PROJECT_FEE\r\n            .add(MARKETING_FEE)\r\n            .add(FUND_FEE)\r\n            .add(TREASURY_FEE)\r\n            .add(PARTNER_FEE);\r\n        uint256 tokensSwap = msgValue.mul(totalFee).div(PERCENTS_DIVIDER);\r\n\r\n        swapTokensForEth(tokensSwap);\r\n\r\n        uint256 nativeBalance = address(this).balance;\r\n        if (nativeBalance > 0) {\r\n            uint256 pFee = nativeBalance.mul(PROJECT_FEE).div(totalFee);\r\n            uint256 mFee = nativeBalance.mul(MARKETING_FEE).div(totalFee);\r\n            uint256 fFee = nativeBalance.mul(FUND_FEE).div(totalFee);\r\n            uint256 tFee = nativeBalance.mul(TREASURY_FEE).div(totalFee);\r\n            uint256 pAFee = nativeBalance.mul(PARTNER_FEE).div(totalFee);\r\n\r\n            WALLET_PROJECT.transfer(pFee);\r\n            WALLET_MARKETING.transfer(mFee);\r\n            WALLET_FUND.transfer(fFee);\r\n            WALLET_TREASURY.transfer(tFee);\r\n            WALLET_PARTNER.transfer(pAFee);\r\n        }\r\n\r\n        uint256 sCFee = crystl.mul(FEE_C).div(PERCENTS_DIVIDER);\r\n\r\n        towers[WALLET_PROJECT].crystals += sCFee;\r\n        towers[WALLET_FUND].crystals += sCFee;\r\n        towers[WALLET_MARKETING].crystals += sCFee;\r\n        towers[WALLET_TREASURY].crystals += sCFee;\r\n        towers[WALLET_PARTNER].crystals += sCFee;\r\n\r\n        emit FeePayed(msg.sender, tokensSwap);\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        // generate the uniswap pair path of token -> WHT\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(CBT);\r\n        path[1] = WRAPPED_NATIVE;\r\n\r\n        CBT.approve(address(swapV2Router), tokenAmount);\r\n\r\n        // make the swap\r\n        try\r\n            swapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                tokenAmount,\r\n                0, // accept any amount of ETH\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            )\r\n        {} catch (bytes memory) {\r\n            try\r\n                swapV2Router.swapExactTokensForBNBSupportingFeeOnTransferTokens(\r\n                    tokenAmount,\r\n                    0, // accept any amount of ETH\r\n                    path,\r\n                    address(this),\r\n                    block.timestamp\r\n                )\r\n            {} catch (bytes memory) {\r\n                try\r\n                    swapV2Router\r\n                        .swapExactTokensForAVAXSupportingFeeOnTransferTokens(\r\n                            tokenAmount,\r\n                            0, // accept any amount of ETH\r\n                            path,\r\n                            address(this),\r\n                            block.timestamp\r\n                        )\r\n                {} catch (bytes memory) {\r\n                    try\r\n                        swapV2Router\r\n                            .swapExactTokensForHTSupportingFeeOnTransferTokens(\r\n                                tokenAmount,\r\n                                0, // accept any amount of ETH\r\n                                path,\r\n                                address(this),\r\n                                block.timestamp\r\n                            )\r\n                    {} catch (bytes memory) {\r\n                        swapV2Router\r\n                            .swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                                tokenAmount,\r\n                                0, // accept any amount of ETH\r\n                                path,\r\n                                address(this),\r\n                                block.timestamp\r\n                            );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function addCrystals(address ref, uint256 tokenAmount) external {\r\n        require(block.timestamp > startDate, \"Contract does not launch yet\");\r\n\r\n        if (block.timestamp > startDate && !init) {\r\n            initializeAuto();\r\n        }\r\n        require(tokenAmount > 0, \"Zero amount\");\r\n\r\n        uint256 priceinBNB = Oracle.getLatestPrice(tokenAmount, true);\r\n        CBT.transferFrom(msg.sender, address(this), tokenAmount);\r\n        uint256 crystals = priceinBNB / BUY_PRICE;\r\n\r\n        require(crystals > 0, \"Zero crystals\");\r\n\r\n        address user = msg.sender;\r\n        require(!isContract(user), \"Sender is a contract\");\r\n        totalInvested += tokenAmount;\r\n        if (towers[user].timestamp == 0) {\r\n            totalTowers++;\r\n            ref = towers[ref].timestamp == 0 ? WALLET_PROJECT : ref;\r\n            towers[ref].refs++;\r\n            towers[user].ref = ref;\r\n            towers[user].timestamp = block.timestamp;\r\n            towers[user].treasury = 0;\r\n        }\r\n        ref = towers[user].ref;\r\n        towers[ref].crystals += (crystals * 8) / 100;\r\n        towers[ref].money += (crystals * 100 * 4) / 100;\r\n        towers[ref].refDeps += crystals;\r\n        towers[user].crystals += crystals;\r\n\r\n        kinguser[ref].investments += (((crystals * 8) / 100) * BUY_PRICE);\r\n        kinguser[ref].investments +=\r\n            (((crystals * 100 * 4) / 100) * SELL_PRICE) /\r\n            2;\r\n        kinguser[user].investments += (crystals * BUY_PRICE);\r\n\r\n        FeePayout(tokenAmount, crystals);\r\n    }\r\n\r\n    function withdrawMoney(uint256 gold) external initialized {\r\n        address user = msg.sender;\r\n        require(!isContract(user), \"Sender is a contract\");\r\n        require(gold <= towers[user].money && gold > 0);\r\n        towers[user].money -= gold;\r\n\r\n        uint256 amountBNB = gold * SELL_PRICE;\r\n\r\n        uint256 capProfit = kinguser[user].investments.mul(2);\r\n        uint256 profit = kinguser[user].profit;\r\n\r\n        if (amountBNB > capProfit.sub(profit)) {\r\n            uint256 profitExceded = amountBNB;\r\n            amountBNB = capProfit.sub(profit) > 0 ? capProfit.sub(profit) : 0;\r\n            profitExceded = amountBNB > 0\r\n                ? profitExceded.sub(amountBNB)\r\n                : profitExceded;\r\n            uint256 goldRemaing = profitExceded > SELL_PRICE\r\n                ? profitExceded / SELL_PRICE\r\n                : 0;\r\n            if (goldRemaing > 0) {\r\n                towers[user].money += goldRemaing;\r\n            }\r\n        }\r\n\r\n        if (amountBNB > 0) {\r\n            uint256 amount = Oracle.getLatestPrice(amountBNB, false);\r\n            kinguser[user].profit += amountBNB;\r\n\r\n            CBT.transfer(\r\n                user,\r\n                CBT.balanceOf(address(this)) < amount\r\n                    ? CBT.balanceOf(address(this))\r\n                    : amount\r\n            );\r\n        }\r\n    }\r\n\r\n    function tradeCrystals(uint256 _crystals) external initialized {\r\n        address user = msg.sender;\r\n        require(!isContract(user), \"Sender is a contract\");\r\n        require(_crystals <= towers[user].crystals && _crystals > 0);\r\n        towers[user].crystals -= _crystals;\r\n\r\n        uint256 capProfit = kinguser[user].investments;\r\n        uint256 profit = kinguser[user].profit.div(2);\r\n\r\n        uint256 amountInvested = _crystals * BUY_PRICE;\r\n        uint256 excededProfit = capProfit.sub(profit) > 0\r\n            ? capProfit.sub(profit)\r\n            : 0;\r\n\r\n        amountInvested = amountInvested > excededProfit\r\n            ? excededProfit\r\n            : amountInvested;\r\n        _crystals = amountInvested > 0 ? amountInvested / BUY_PRICE : 0;\r\n        if (amountInvested > 0) {\r\n            kinguser[user].investments -= amountInvested;\r\n        }\r\n\r\n        if (_crystals > 0) {\r\n            uint256 penalty = (_crystals * PENALTY_CRYSTAL_SELL) /\r\n                PERCENTS_DIVIDER;\r\n            uint256 amountBNB = (_crystals - penalty) * BUY_PRICE;\r\n            uint256 amount = Oracle.getLatestPrice(amountBNB, false);\r\n\r\n            CBT.transfer(\r\n                user,\r\n                CBT.balanceOf(address(this)) < amount\r\n                    ? CBT.balanceOf(address(this))\r\n                    : amount\r\n            );\r\n        }\r\n    }\r\n\r\n    function burnCoins(uint256 _gold) external initialized {\r\n        address user = msg.sender;\r\n        require(!isContract(user), \"Sender is a contract\");\r\n        require(_gold <= towers[user].money && _gold > 0);\r\n        require(towers[user].refs > 0, \"Only for users with refs\");\r\n        towers[user].money -= _gold;\r\n        uint256 amountBNB = _gold *\r\n            ((SELL_PRICE * PENALTY_COINS_BURN) / PERCENTS_DIVIDER);\r\n        uint256 amount = Oracle.getLatestPrice(amountBNB, false);\r\n\r\n        CBT.transfer(\r\n            address(0),\r\n            CBT.balanceOf(address(this)) < amount\r\n                ? CBT.balanceOf(address(this))\r\n                : amount\r\n        );\r\n    }\r\n\r\n    function collectMoney() public {\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        towers[user].hrs = 0;\r\n        towers[user].money += towers[user].money2;\r\n        towers[user].money2 = 0;\r\n    }\r\n\r\n    function upgradeTower(uint256 towerId) public {\r\n        require(towerId < 5, \"Max 5 towers\");\r\n        require(\r\n            NFTContract.walletisAuthorized(msg.sender, towerId),\r\n            \"Not authorized\"\r\n        );\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        towers[user].chefs[towerId]++;\r\n        totalChefs++;\r\n        uint256 chefs = towers[user].chefs[towerId];\r\n        towers[user].crystals -= getUpgradePrice(towerId, chefs) / denominator;\r\n        towers[user].yield += getYield(towerId, chefs);\r\n    }\r\n\r\n    function getNFTUpgrade(uint256 towerId) external payable {\r\n        require(towerId < 5, \"Max 5 towers\");\r\n        require(\r\n            NFTContract.walletisAuthorized(msg.sender, towerId) != true,\r\n            \"Already Authorized\"\r\n        );\r\n        require(msg.value >= NFTContract.price(), \"Not enough money\");\r\n\r\n        NFTContract.mint{value: msg.value}(towerId, msg.sender);\r\n\r\n        upgradeTower(towerId);\r\n    }\r\n\r\n    function upgradeTreasury() external {\r\n        address user = msg.sender;\r\n        uint8 treasuryId = towers[user].treasury + 1;\r\n        syncTower(user);\r\n        require(treasuryId < 5, \"Max 5 treasury\");\r\n        (uint256 price, ) = getTreasure(treasuryId);\r\n        towers[user].crystals -= price / denominator;\r\n        towers[user].treasury = treasuryId;\r\n    }\r\n\r\n    function sellTower() external {\r\n        collectMoney();\r\n        address user = msg.sender;\r\n        uint8[5] memory chefs = towers[user].chefs;\r\n        totalChefs -= chefs[0] + chefs[1] + chefs[2] + chefs[3] + chefs[4];\r\n        towers[user].money += towers[user].yield * 24 * 5;\r\n        towers[user].chefs = [0, 0, 0, 0, 0];\r\n        towers[user].yield = 0;\r\n        towers[user].treasury = 0;\r\n    }\r\n\r\n    function getChefs(address addr) external view returns (uint8[5] memory) {\r\n        return towers[addr].chefs;\r\n    }\r\n\r\n    function syncTower(address user) internal {\r\n        require(towers[user].timestamp > 0, \"User is not registered\");\r\n        if (towers[user].yield > 0) {\r\n            (, uint256 treasury) = getTreasure(towers[user].treasury);\r\n            uint256 hrs = block.timestamp /\r\n                TIME_STEP -\r\n                towers[user].timestamp /\r\n                TIME_STEP;\r\n            if (hrs + towers[user].hrs > treasury) {\r\n                hrs = treasury - towers[user].hrs;\r\n            }\r\n            towers[user].money2 += hrs * towers[user].yield;\r\n            towers[user].hrs += hrs;\r\n        }\r\n        towers[user].timestamp = block.timestamp;\r\n    }\r\n\r\n    function getUpgradePrice(\r\n        uint256 towerId,\r\n        uint256 chefId\r\n    ) internal pure returns (uint256) {\r\n        if (chefId == 1) return [500, 5000, 15000, 30000, 50000][towerId];\r\n        if (chefId == 2) return [750, 7500, 22500, 45000, 75000][towerId];\r\n        if (chefId == 3) return [1120, 11200, 33750, 67500, 112500][towerId];\r\n        if (chefId == 4) return [1700, 17000, 51000, 102000, 170000][towerId];\r\n        if (chefId == 5) return [2550, 25500, 76500, 153000, 255000][towerId];\r\n        if (chefId == 6) return [3820, 38200, 114700, 229500, 382500][towerId];\r\n        revert(\"Incorrect chefId\");\r\n    }\r\n\r\n    function getYield(\r\n        uint256 towerId,\r\n        uint256 chefId\r\n    ) internal pure returns (uint256) {\r\n        if (chefId == 1) return [4, 56, 179, 382, 678][towerId];\r\n        if (chefId == 2) return [8, 85, 272, 581, 1030][towerId];\r\n        if (chefId == 3) return [12, 128, 413, 882, 1564][towerId];\r\n        if (chefId == 4) return [18, 195, 628, 1340, 2379][towerId];\r\n        if (chefId == 5) return [28, 297, 954, 2035, 3620][towerId];\r\n        if (chefId == 6) return [42, 450, 1439, 3076, 5506][towerId];\r\n        revert(\"Incorrect chefId\");\r\n    }\r\n\r\n    function getTreasure(\r\n        uint256 treasureId\r\n    ) internal pure returns (uint256, uint256) {\r\n        if (treasureId == 0) return (0, 24); // price | value\r\n        if (treasureId == 1) return (2400, 30);\r\n        if (treasureId == 2) return (3000, 36);\r\n        if (treasureId == 3) return (3600, 42);\r\n        if (treasureId == 4) return (5000, 48);\r\n        revert(\"Incorrect treasureId\");\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n}\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_walletMarketing\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_walletFund\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_walletTreasury\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_walletPartner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUY_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CBT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUND_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARKETING_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFTContract\",\"outputs\":[{\"internalType\":\"contract NftInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Oracle\",\"outputs\":[{\"internalType\":\"contract OracleInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PARTNER_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PENALTY_COINS_BURN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PENALTY_CRYSTAL_SELL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROJECT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SELL_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREASURY_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"}],\"name\":\"UpdateStartDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET_FUND\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET_MARKETING\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET_PARTNER\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET_PROJECT\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET_TREASURY\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WRAPPED_NATIVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"addCrystals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gold\",\"type\":\"uint256\"}],\"name\":\"burnCoins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectMoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getChefs\",\"outputs\":[{\"internalType\":\"uint8[5]\",\"name\":\"\",\"type\":\"uint8[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"towerId\",\"type\":\"uint256\"}],\"name\":\"getNFTUpgrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"kinguser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"investments\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalChefs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTowers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"towers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"crystals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"money2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yield\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hrs\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refDeps\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"treasury\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_crystals\",\"type\":\"uint256\"}],\"name\":\"tradeCrystals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateFundWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updatePartnerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateProjectWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"towerId\",\"type\":\"uint256\"}],\"name\":\"upgradeTower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gold\",\"type\":\"uint256\"}],\"name\":\"withdrawMoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CryptoBattle", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ec539d4d790a1f6ca61f8226f1c38733b907b14100000000000000000000000074f0bc9634ce70bbb462671aadd9286ddbb2188d00000000000000000000000077512653c87496b4582c8770f2e1df0e2647d2a600000000000000000000000094871309a7973ef56d6aa540db1a4a6f2e93a1cf0000000000000000000000000000000000000000000000000000000065806578", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://32fc644dfa00c4f93d812230b82723b5b6595b6c18cd2d8209d02f4096a6f176"}