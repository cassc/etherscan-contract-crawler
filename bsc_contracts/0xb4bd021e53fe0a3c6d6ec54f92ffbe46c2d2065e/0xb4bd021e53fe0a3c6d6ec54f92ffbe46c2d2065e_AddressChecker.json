{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/AddressChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ncontract AddressChecker {\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    // Check the contract type: return 1 for ERC721, 2 for ERC1155, and 0 for others\\n    function checkContractType(address contractAddress) public view returns (uint8) {\\n        // Ensure the contract address is not the zero address, as it represents no contract\\n        if (contractAddress == address(0)) {\\n            return 0;\\n        }\\n\\n        // Cast the address to IERC165 to use the supportsInterface method\\n        IERC165 suspect = IERC165(contractAddress);\\n        bool supportsERC721 = suspect.supportsInterface(_INTERFACE_ID_ERC721);\\n        bool supportsERC1155 = suspect.supportsInterface(_INTERFACE_ID_ERC1155);\\n\\n        // Check for support of the ERC721 or ERC1155 interface\\n        if (supportsERC721) {\\n            return 1;\\n        } else if (supportsERC1155) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    // New function to filter addresses that are neither ERC721 nor ERC1155\\n    function filterNonCompliantAddresses(address[] memory addresses) public view returns (address[] memory) {\\n        address[] memory nonCompliantAddresses = new address[](addresses.length);\\n        uint count = 0;\\n\\n        // Iterate over the provided addresses\\n        for (uint i = 0; i < addresses.length; i++) {\\n            // Use checkContractType to filter addresses\\n            if (checkContractType(addresses[i]) == 0) {\\n                nonCompliantAddresses[count] = addresses[i];\\n                count++;\\n            }\\n        }\\n\\n        // Resize the array to exclude empty elements\\n        address[] memory filteredAddresses = new address[](count);\\n        for (uint i = 0; i < count; i++) {\\n            filteredAddresses[i] = nonCompliantAddresses[i];\\n        }\\n        return filteredAddresses;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"checkContractType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"filterNonCompliantAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AddressChecker", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}