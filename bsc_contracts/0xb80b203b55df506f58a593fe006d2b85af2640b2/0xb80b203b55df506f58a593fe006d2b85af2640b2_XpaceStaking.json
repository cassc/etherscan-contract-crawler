{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from,address to,uint256 tokenId) external;\r\n    function transferFrom(address from,address to,uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from,address to,uint256 tokenId,bytes calldata data) external;\r\n    function getWithdrawable(address _user) external view returns(uint256);\r\n    function setWithdraw(address _user) external;\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract Pausable is Context {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\ncontract XpaceStaking is Pausable, Ownable {\r\n    using SafeMath for uint256;\r\n    IERC721 public NFT;\r\n    IERC20 public Space;\r\n\r\n    uint256 referDepth = 8;\r\n    uint256 minutesPerMonth = 43200;\r\n    uint256 constant perNFT = 10e18;\r\n\r\n    uint256 public unstakeTime = 24 hours; // \r\n    uint256 public tokenPrice;\r\n    uint256 dollerPrice = 10 ether;\r\n    uint256 oneCoin = 1e18;\r\n\r\n    bool public canUnstake;\r\n\r\n    mapping(address => uint256) public unstakedROI;\r\n    mapping(address => uint256) public canWithdraw;\r\n\r\n    uint256[8] levels = \r\n    [\r\n        40000000000000000,42500000000000000,45000000000000000,47500000000000000,\r\n        50000000000000000,55000000000000000,60000000000000000,70000000000000000\r\n    ];\r\n\r\n    uint256[8] levelsPrice = [10e18,20e18,50e18,100e18,500e18,1000e18,2000e18,5000e18];\r\n\r\n\r\n    struct userData{\r\n        uint256 tokenId;\r\n        uint256 Tokens;\r\n        uint256 time;\r\n    }\r\n\r\n    mapping(address => uint256) public userReward;\r\n    // user = level = count\r\n    mapping(address => mapping(uint256 => uint256)) public userCount;\r\n    mapping(address => uint256) public userLockedTokens;\r\n    // user = level = struct\r\n    mapping(address => mapping(uint256 => userData[])) public userInfo;\r\n\r\n    mapping(address => uint256[]) private withdrawlHistory;\r\n\r\n    constructor(address _token, uint256 _tokenPrice) // 0.05 ether = 50000000000000000\r\n    {  \r\n        // Space = IERC20(_token);  /// 0x4a53d5A3Aad9Bd8Ed4E4C7eaf7a319F8f71ec896\r\n        Space = IERC20(_token);\r\n        setPrices(dollerPrice, _tokenPrice);\r\n    }\r\n\r\n    modifier onlySpaceNft()\r\n    {\r\n        require(address(NFT) != address(0), \"Calling null address\");\r\n        require(msg.sender == address(NFT)  , \"Caller is not from NFT\");\r\n        _;\r\n    }\r\n\r\n    function lockNFT(address user_, uint256 _level, uint256 _tokenId, uint256 _tokens) \r\n    external \r\n    onlySpaceNft\r\n    {\r\n        userCount[user_][_level] = userCount[user_][_level].add(1);\r\n        userInfo[user_][_level].push(\r\n            userData(\r\n                _tokenId,\r\n                _tokens,\r\n                block.timestamp\r\n            )\r\n        );\r\n        userLockedTokens[user_] = userLockedTokens[user_].add(_tokens);\r\n        canWithdraw[user_] = canWithdraw[user_].add(unstakeTime);\r\n    }\r\n\r\n    function getTime(address _user, uint256 _level, uint256 _index) public view returns (uint256){\r\n        uint256 _usertime = userInfo[_user][_level][_index].time;\r\n        uint256 _time = ((block.timestamp).sub(_usertime)).div(60);\r\n        return _time;\r\n    }\r\n\r\n    function getMinutReward(address _user, uint256 _level, uint256 _index) public view returns(uint256){\r\n        uint256 _levelAmount = userInfo[_user][_level][_index].Tokens;\r\n        uint256 per_token_reward = levels[_level-1];\r\n        uint256 _totalTokens = (_levelAmount.mul(per_token_reward)).div(1e18);\r\n        uint256 _perMinut = _totalTokens.div(minutesPerMonth);\r\n        return _perMinut;\r\n    }\r\n\r\n    function userROI(address _user) public view returns(uint256){\r\n        uint256 _totalReward;\r\n        uint256 _levelAmount;\r\n        uint256 _time;\r\n        uint256 _finalRew;\r\n        for(uint256 i = 1; i<= referDepth; i++){\r\n            for(uint256 j; j< userInfo[_user][i].length; j++){\r\n                _time = getTime(_user, i, j);\r\n                _levelAmount = getMinutReward(_user, i, j);\r\n                _totalReward += _levelAmount.mul(_time);\r\n            }\r\n        }\r\n        _finalRew = _totalReward.add(unstakedROI[_user]);\r\n        return _finalRew.sub(userReward[_user]);\r\n    }\r\n\r\n    function withdrawROI() public {\r\n        if((block.timestamp) >= canWithdraw[msg.sender])\r\n        {\r\n            uint256 _userReward = userROI(msg.sender);\r\n            address _user = msg.sender;\r\n            uint256 _reward = NFT.getWithdrawable(_user);\r\n            userReward[msg.sender] = userReward[msg.sender].add(_userReward);\r\n            uint256 _totalReward = _reward.add(_userReward);\r\n\r\n            NFT.setWithdraw(_user);            \r\n            withdrawlHistory[msg.sender].push(_totalReward);\r\n            canWithdraw[msg.sender] = block.timestamp.add(unstakeTime); // 24 hours\r\n\r\n            Space.transfer(msg.sender, _totalReward);\r\n        \r\n        }\r\n    }\r\n\r\n    function getPoints(uint256 _level) public view returns(uint256){\r\n        uint256 _price = levelsPrice[_level - 1];\r\n        uint256 totalCoins;\r\n        totalCoins = (_price.mul(perNFT)).div(1e18);\r\n        return totalCoins;\r\n    }\r\n \r\n    function setUnstakeROI(address _user, uint256 _level, uint256 _id) internal {\r\n        uint256 _total;\r\n        uint256 _time = getTime(_user, _level, _id);\r\n        uint256 _roi = getMinutReward(_user, _level, _id);\r\n        _total = _roi.mul(_time);\r\n        uint256 _coins = getPoints(_level);\r\n        unstakedROI[_user] = unstakedROI[_user].add(_total);\r\n        userLockedTokens[_user] = userLockedTokens[_user].sub(_coins);\r\n    }\r\n    \r\n    function unstakeNFTs(address _user, uint256 _level, uint256[] memory _tokenIds) public {\r\n        require(canUnstake, \"cannot unstake\");\r\n        withdrawROI();\r\n        uint256 _tokens;\r\n        \r\n        for(uint256 i; i< _tokenIds.length; i++){\r\n            (uint256 _index, bool isThere) = isExist(_user, _level, _tokenIds[i]);\r\n            if(isThere)\r\n            {\r\n                _tokens = userInfo[_user][_level][_index].Tokens;\r\n                setUnstakeROI(_user, _level, _index);\r\n                NFT.transferFrom(address(this), _user, _tokenIds[i]);\r\n                Space.transfer(msg.sender, _tokens);\r\n\r\n                userInfo[_user][_level][_index].tokenId = userInfo[_user][_level][(userInfo[_user][_level]).length -1].tokenId;\r\n                userInfo[_user][_level][_index].Tokens = userInfo[_user][_level][(userInfo[_user][_level]).length -1].Tokens;\r\n                userInfo[_user][_level][_index].time = userInfo[_user][_level][(userInfo[_user][_level]).length -1].time;\r\n\r\n                userInfo[_user][_level].pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    function isExist(address _user, uint256 _level, uint256 _tokenId) public view returns(uint256, bool){\r\n        for(uint256 i; i< userInfo[_user][_level].length; i++){\r\n            if(_tokenId == userInfo[_user][_level][i].tokenId){\r\n                return (i ,true);\r\n            }\r\n        }\r\n        return (0, false);\r\n    }\r\n\r\n    function getUserIds(address _user, uint256 _level) \r\n    public  \r\n    view \r\n    returns(uint256[] memory)\r\n    {\r\n        uint256[] memory ids = new uint256[](userInfo[_user][_level].length);\r\n        for (uint256 i; i< ids.length; i++){\r\n            ids[i] = userInfo[_user][_level][i].tokenId;\r\n        }\r\n        return ids;\r\n    }\r\n\r\n    function getWithdrawedHistory(address _user) public view returns(uint256[] memory)\r\n    {    return withdrawlHistory[_user];    }\r\n\r\n    function getUserLockedTokens(address _user) public view returns (uint256)\r\n    {    return userLockedTokens[_user];   }\r\n\r\n    function getTokenPrice(uint256 _value) public view returns(bool) // withdrawl amount from frontend\r\n    {   \r\n        uint256 _value_1;\r\n        uint256 _finalPrice;\r\n        _value_1 = (oneCoin.mul(1e18)).div(tokenPrice);\r\n        _finalPrice = ((_value_1).mul(dollerPrice)).div(1e18);\r\n\r\n        if(_finalPrice <= _value)\r\n        { return true; }\r\n        else{ return false; }\r\n    }\r\n\r\n    function setPrices(uint256 _dPrice, uint256 _tPrice) \r\n    public onlyOwner\r\n    { // 0.05 ether\r\n        dollerPrice = _dPrice;\r\n        tokenPrice = _tPrice;\r\n    }\r\n\r\n    function setUnstake() \r\n    external onlyOwner\r\n    {   canUnstake = !canUnstake;   }\r\n\r\n    function setNFTAddress(address _nft) \r\n    external onlyOwner\r\n    {    NFT = IERC721(_nft);   }\r\n\r\n    function setTokenAddress(address _token) external onlyOwner{\r\n        Space = IERC20(_token);\r\n    }\r\n\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure returns (bytes4) \r\n    {    return IERC721Receiver.onERC721Received.selector;  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Space\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canUnstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getMinutReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getUserIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getWithdrawedHistory\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isExist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"lockNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"}],\"name\":\"setNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstakeNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unstakedROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawROI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "XpaceStaking", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f4096fe2317a433b7e5995806cca3501874a01c400000000000000000000000000000000000000000000000000b1a2bc2ec50000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e5362f2f31035b57d37871e53b891a71d4e2671e97fd944f930ffb621cc336bb"}