{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n  /**\\r\\n   * @dev Returns true if `account` is a contract.\\r\\n   *\\r\\n   * [IMPORTANT]\\r\\n   * ====\\r\\n   * It is unsafe to assume that an address for which this function returns\\r\\n   * false is an externally-owned account (EOA) and not a contract.\\r\\n   *\\r\\n   * Among others, `isContract` will return false for the following\\r\\n   * types of addresses:\\r\\n   *\\r\\n   *  - an externally-owned account\\r\\n   *  - a contract in construction\\r\\n   *  - an address where a contract will be created\\r\\n   *  - an address where a contract lived, but was destroyed\\r\\n   * ====\\r\\n   */\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n    // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n    bytes32 codehash;\\r\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n    // solhint-disable-next-line no-inline-assembly\\r\\n    assembly {\\r\\n      codehash := extcodehash(account)\\r\\n    }\\r\\n    return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n   * `recipient`, forwarding all available gas and reverting on errors.\\r\\n   *\\r\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n   * imposed by `transfer`, making them unable to receive funds via\\r\\n   * `transfer`. {sendValue} removes this limitation.\\r\\n   *\\r\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n   *\\r\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n   * taken to not create reentrancy vulnerabilities. Consider using\\r\\n   * {ReentrancyGuard} or the\\r\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n   */\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance \\u003e= amount, \\u0027Address: insufficient balance\\u0027);\\r\\n\\r\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n    (bool success, ) = recipient.call{value: amount}(\\u0027\\u0027);\\r\\n    require(success, \\u0027Address: unable to send value, recipient may have reverted\\u0027);\\r\\n  }\\r\\n}\\r\\n\"},\"AdminUpgradeabilityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\u0027./BaseAdminUpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title AdminUpgradeabilityProxy\\r\\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\\r\\n * initializing the implementation, admin, and init data.\\r\\n */\\r\\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\\r\\n  /**\\r\\n   * Contract constructor.\\r\\n   * @param _logic address of the initial implementation.\\r\\n   * @param _admin Address of the proxy administrator.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  constructor(\\r\\n    address _logic,\\r\\n    address _admin,\\r\\n    bytes memory _data\\r\\n  ) public payable UpgradeabilityProxy(_logic, _data) {\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.admin\\u0027)) - 1));\\r\\n    _setAdmin(_admin);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\\r\\n    BaseAdminUpgradeabilityProxy._willFallback();\\r\\n  }\\r\\n}\\r\\n\"},\"BaseAdminUpgradeabilityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\u0027./UpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title BaseAdminUpgradeabilityProxy\\r\\n * @dev This contract combines an upgradeability proxy with an authorization\\r\\n * mechanism for administrative tasks.\\r\\n * All external functions in this contract must be guarded by the\\r\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\r\\n * feature proposal that would enable this to be done automatically.\\r\\n */\\r\\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Emitted when the administration has been transferred.\\r\\n   * @param previousAdmin Address of the previous admin.\\r\\n   * @param newAdmin Address of the new admin.\\r\\n   */\\r\\n  event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the admin of the contract.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n  bytes32 internal constant ADMIN_SLOT =\\r\\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\r\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\r\\n   * to the implementation.\\r\\n   */\\r\\n  modifier ifAdmin() {\\r\\n    if (msg.sender == _admin()) {\\r\\n      _;\\r\\n    } else {\\r\\n      _fallback();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the proxy admin.\\r\\n   */\\r\\n  function admin() external ifAdmin returns (address) {\\r\\n    return _admin();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the implementation.\\r\\n   */\\r\\n  function implementation() external ifAdmin returns (address) {\\r\\n    return _implementation();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Changes the admin of the proxy.\\r\\n   * Only the current admin can call this function.\\r\\n   * @param newAdmin Address to transfer proxy administration to.\\r\\n   */\\r\\n  function changeAdmin(address newAdmin) external ifAdmin {\\r\\n    require(newAdmin != address(0), \\u0027Cannot change the admin of a proxy to the zero address\\u0027);\\r\\n    emit AdminChanged(_admin(), newAdmin);\\r\\n    _setAdmin(newAdmin);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy.\\r\\n   * Only the admin can call this function.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function upgradeTo(address newImplementation) external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\r\\n   * on the new implementation.\\r\\n   * This is useful to initialize the proxied contract.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   * @param data Data to send as msg.data in the low level call.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   */\\r\\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\\r\\n    external\\r\\n    payable\\r\\n    ifAdmin\\r\\n  {\\r\\n    _upgradeTo(newImplementation);\\r\\n    (bool success, ) = newImplementation.delegatecall(data);\\r\\n    require(success, \\\"upgradeToAndCall failed\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return adm The admin slot.\\r\\n   */\\r\\n  function _admin() internal view returns (address adm) {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n    //solium-disable-next-line\\r\\n    assembly {\\r\\n      adm := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the address of the proxy admin.\\r\\n   * @param newAdmin Address of the new proxy admin.\\r\\n   */\\r\\n  function _setAdmin(address newAdmin) internal {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n    //solium-disable-next-line\\r\\n    assembly {\\r\\n      sstore(slot, newAdmin)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  function _willFallback() internal virtual override {\\r\\n    require(msg.sender != _admin(), \\u0027Cannot call fallback function from the proxy admin\\u0027);\\r\\n    super._willFallback();\\r\\n  }\\r\\n}\\r\\n\"},\"BaseImmutableAdminUpgradeabilityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\u0027./BaseUpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title BaseImmutableAdminUpgradeabilityProxy\\r\\n * @author Lever, inspired by the OpenZeppelin upgradeability proxy pattern\\r\\n * @dev This contract combines an upgradeability proxy with an authorization\\r\\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\\r\\n * helps saving transactions costs\\r\\n * All external functions in this contract must be guarded by the\\r\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\r\\n * feature proposal that would enable this to be done automatically.\\r\\n */\\r\\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  address immutable ADMIN;\\r\\n\\r\\n  constructor(address admin) public {\\r\\n    ADMIN = admin;\\r\\n  }\\r\\n\\r\\n  modifier ifAdmin() {\\r\\n    if (msg.sender == ADMIN) {\\r\\n      _;\\r\\n    } else {\\r\\n      _fallback();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the proxy admin.\\r\\n   */\\r\\n  function admin() external ifAdmin returns (address) {\\r\\n    return ADMIN;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the implementation.\\r\\n   */\\r\\n  function implementation() external ifAdmin returns (address) {\\r\\n    return _implementation();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy.\\r\\n   * Only the admin can call this function.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function upgradeTo(address newImplementation) external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\r\\n   * on the new implementation.\\r\\n   * This is useful to initialize the proxied contract.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   * @param data Data to send as msg.data in the low level call.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   */\\r\\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\\r\\n    external\\r\\n    payable\\r\\n    ifAdmin\\r\\n  {\\r\\n    _upgradeTo(newImplementation);\\r\\n    (bool success, ) = newImplementation.delegatecall(data);\\r\\n    require(success, \\\"upgradeToAndCall failed\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  function _willFallback() internal virtual override {\\r\\n    require(msg.sender != ADMIN, \\u0027Cannot call fallback function from the proxy admin\\u0027);\\r\\n    super._willFallback();\\r\\n  }\\r\\n}\\r\\n\"},\"BaseUpgradeabilityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\u0027./Proxy.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title BaseUpgradeabilityProxy\\r\\n * @dev This contract implements a proxy that allows to change the\\r\\n * implementation address to which it will delegate.\\r\\n * Such a change is called an implementation upgrade.\\r\\n */\\r\\ncontract BaseUpgradeabilityProxy is Proxy {\\r\\n  /**\\r\\n   * @dev Emitted when the implementation is upgraded.\\r\\n   * @param implementation Address of the new implementation.\\r\\n   */\\r\\n  event Upgraded(address indexed implementation);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the address of the current implementation.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n  bytes32 internal constant IMPLEMENTATION_SLOT =\\r\\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the current implementation.\\r\\n   * @return impl Address of the current implementation\\r\\n   */\\r\\n  function _implementation() internal view override returns (address impl) {\\r\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n    //solium-disable-next-line\\r\\n    assembly {\\r\\n      impl := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrades the proxy to a new implementation.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function _upgradeTo(address newImplementation) internal {\\r\\n    _setImplementation(newImplementation);\\r\\n    emit Upgraded(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the implementation address of the proxy.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function _setImplementation(address newImplementation) internal {\\r\\n    require(\\r\\n      Address.isContract(newImplementation),\\r\\n      \\u0027Cannot set a proxy implementation to a non-contract address\\u0027\\r\\n    );\\r\\n\\r\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n\\r\\n    //solium-disable-next-line\\r\\n    assembly {\\r\\n      sstore(slot, newImplementation)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n  function _msgSender() internal view virtual returns (address payable) {\\r\\n    return msg.sender;\\r\\n  }\\r\\n\\r\\n  function _msgData() internal view virtual returns (bytes memory) {\\r\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n    return msg.data;\\r\\n  }\\r\\n}\\r\\n\"},\"DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nlibrary DataTypes {\\r\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\r\\n  struct ReserveData {\\r\\n    //stores the reserve configuration\\r\\n    ReserveConfigurationMap configuration;\\r\\n    //the liquidity index. Expressed in ray\\r\\n    uint128 liquidityIndex;\\r\\n    //variable borrow index. Expressed in ray\\r\\n    uint128 variableBorrowIndex;\\r\\n    //the current supply rate. Expressed in ray\\r\\n    uint128 currentLiquidityRate;\\r\\n    //the current variable borrow rate. Expressed in ray\\r\\n    uint128 currentVariableBorrowRate;\\r\\n    uint40 lastUpdateTimestamp;\\r\\n    //tokens addresses\\r\\n    address xTokenAddress;\\r\\n    address variableDebtTokenAddress;\\r\\n    //address of the interest rate strategy\\r\\n    address interestRateStrategyAddress;\\r\\n    //the id of the reserve. Represents the position in the list of the active reserves\\r\\n    uint8 id;\\r\\n  }\\r\\n\\r\\n  struct ReserveConfigurationMap {\\r\\n    //bit 0-15: LTV\\r\\n    //bit 16-31: Liq. threshold\\r\\n    //bit 32-47: Liq. bonus\\r\\n    //bit 48-55: Decimals\\r\\n    //bit 56: Reserve is active\\r\\n    //bit 57: reserve is frozen\\r\\n    //bit 58: borrowing is enabled\\r\\n    //bit 60-63: reserved\\r\\n    //bit 64-79: reserve factor\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  struct UserConfigurationMap {\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n}\\r\\n\"},\"DebtTokenBase.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IMarginPool} from \\u0027./IMarginPool.sol\\u0027;\\r\\nimport {ICreditDelegationToken} from \\u0027./ICreditDelegationToken.sol\\u0027;\\r\\nimport {IncentivizedERC20} from \\u0027./IncentivizedERC20.sol\\u0027;\\r\\nimport {Errors} from \\u0027./Errors.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title DebtTokenBase\\r\\n * @author Lever\\r\\n */\\r\\n\\r\\nabstract contract DebtTokenBase is\\r\\n  IncentivizedERC20,\\r\\n  ICreditDelegationToken\\r\\n{\\r\\n  address public immutable UNDERLYING_ASSET_ADDRESS;\\r\\n  IMarginPool public immutable POOL;\\r\\n\\r\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) internal _borrowAllowances;\\r\\n\\r\\n  /**\\r\\n   * @dev Only margin pool can call functions marked by this modifier\\r\\n   **/\\r\\n  modifier onlyMarginPool {\\r\\n    require(_msgSender() == address(POOL), Errors.CT_CALLER_MUST_BE_MARGIN_POOL);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev The metadata of the token will be set on the proxy, that the reason of\\r\\n   * passing \\\"NULL\\\" and 0 as metadata\\r\\n   */\\r\\n  constructor(\\r\\n    address pool,\\r\\n    address underlyingAssetAddress,\\r\\n    string memory name,\\r\\n    string memory symbol,\\r\\n    uint8 decimals\\r\\n  ) public IncentivizedERC20(name, symbol, decimals) {\\r\\n    POOL = IMarginPool(pool);\\r\\n    UNDERLYING_ASSET_ADDRESS = underlyingAssetAddress;\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev delegates borrowing power to a user on the specific debt token\\r\\n   * @param delegatee the address receiving the delegated borrowing power\\r\\n   * @param amount the maximum amount being delegated. Delegation will still\\r\\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\\r\\n   * force a delegator HF to go below 1)\\r\\n   **/\\r\\n  function approveDelegation(address delegatee, uint256 amount) external override {\\r\\n    _borrowAllowances[_msgSender()][delegatee] = amount;\\r\\n    emit BorrowAllowanceDelegated(_msgSender(), delegatee, UNDERLYING_ASSET_ADDRESS, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev returns the borrow allowance of the user\\r\\n   * @param fromUser The user to giving allowance\\r\\n   * @param toUser The user to give allowance to\\r\\n   * @return the current allowance of toUser\\r\\n   **/\\r\\n  function borrowAllowance(address fromUser, address toUser)\\r\\n    external\\r\\n    view\\r\\n    override\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return _borrowAllowances[fromUser][toUser];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Being non transferrable, the debt token does not implement any of the\\r\\n   * standard ERC20 functions for transfer and allowance.\\r\\n   **/\\r\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n    recipient;\\r\\n    amount;\\r\\n    revert(\\u0027TRANSFER_NOT_SUPPORTED\\u0027);\\r\\n  }\\r\\n\\r\\n  function allowance(address owner, address spender)\\r\\n    public\\r\\n    view\\r\\n    virtual\\r\\n    override\\r\\n    returns (uint256)\\r\\n  {\\r\\n    owner;\\r\\n    spender;\\r\\n    revert(\\u0027ALLOWANCE_NOT_SUPPORTED\\u0027);\\r\\n  }\\r\\n\\r\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n    spender;\\r\\n    amount;\\r\\n    revert(\\u0027APPROVAL_NOT_SUPPORTED\\u0027);\\r\\n  }\\r\\n\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) public virtual override returns (bool) {\\r\\n    sender;\\r\\n    recipient;\\r\\n    amount;\\r\\n    revert(\\u0027TRANSFER_NOT_SUPPORTED\\u0027);\\r\\n  }\\r\\n\\r\\n  function increaseAllowance(address spender, uint256 addedValue)\\r\\n    public\\r\\n    virtual\\r\\n    override\\r\\n    returns (bool)\\r\\n  {\\r\\n    spender;\\r\\n    addedValue;\\r\\n    revert(\\u0027ALLOWANCE_NOT_SUPPORTED\\u0027);\\r\\n  }\\r\\n\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n    public\\r\\n    virtual\\r\\n    override\\r\\n    returns (bool)\\r\\n  {\\r\\n    spender;\\r\\n    subtractedValue;\\r\\n    revert(\\u0027ALLOWANCE_NOT_SUPPORTED\\u0027);\\r\\n  }\\r\\n\\r\\n  function _decreaseBorrowAllowance(\\r\\n    address delegator,\\r\\n    address delegatee,\\r\\n    uint256 amount\\r\\n  ) internal {\\r\\n    uint256 newAllowance =\\r\\n      _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH);\\r\\n\\r\\n    _borrowAllowances[delegator][delegatee] = newAllowance;\\r\\n\\r\\n    emit BorrowAllowanceDelegated(delegator, delegatee, UNDERLYING_ASSET_ADDRESS, newAllowance);\\r\\n  }\\r\\n}\\r\\n\"},\"DefaultReserveInterestRateStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {SafeMath} from \\u0027./SafeMath.sol\\u0027;\\r\\nimport {IReserveInterestRateStrategy} from \\u0027./IReserveInterestRateStrategy.sol\\u0027;\\r\\nimport {WadRayMath} from \\u0027./WadRayMath.sol\\u0027;\\r\\nimport {PercentageMath} from \\u0027./PercentageMath.sol\\u0027;\\r\\nimport {IMarginPoolAddressesProvider} from \\u0027./IMarginPoolAddressesProvider.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title DefaultReserveInterestRateStrategy contract\\r\\n * @notice Implements the calculation of the interest rates depending on the reserve state\\r\\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE`\\r\\n * point of utilization and another from that one to 100%\\r\\n * @author Lever\\r\\n **/\\r\\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\\r\\n  using WadRayMath for uint256;\\r\\n  using SafeMath for uint256;\\r\\n  using PercentageMath for uint256;\\r\\n\\r\\n  /**\\r\\n   * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates.\\r\\n   * Expressed in ray\\r\\n   **/\\r\\n  uint256 public immutable OPTIMAL_UTILIZATION_RATE;\\r\\n\\r\\n  /**\\r\\n   * @dev This constant represents the excess utilization rate above the optimal. It\\u0027s always equal to\\r\\n   * 1-optimal utilization rate. Added as a constant here for gas optimizations.\\r\\n   * Expressed in ray\\r\\n   **/\\r\\n\\r\\n  uint256 public immutable EXCESS_UTILIZATION_RATE;\\r\\n\\r\\n  IMarginPoolAddressesProvider public immutable addressesProvider;\\r\\n\\r\\n  // Base variable borrow rate when Utilization rate = 0. Expressed in ray\\r\\n  uint256 internal immutable _baseVariableBorrowRate;\\r\\n\\r\\n  // Slope of the variable interest curve when utilization rate \\u003e 0 and \\u003c= OPTIMAL_UTILIZATION_RATE. Expressed in ray\\r\\n  uint256 internal immutable _variableRateSlope1;\\r\\n\\r\\n  // Slope of the variable interest curve when utilization rate \\u003e OPTIMAL_UTILIZATION_RATE. Expressed in ray\\r\\n  uint256 internal immutable _variableRateSlope2;\\r\\n\\r\\n\\r\\n  constructor(\\r\\n    IMarginPoolAddressesProvider provider,\\r\\n    uint256 optimalUtilizationRate,\\r\\n    uint256 baseVariableBorrowRate,\\r\\n    uint256 variableRateSlope1,\\r\\n    uint256 variableRateSlope2\\r\\n  ) public {\\r\\n    OPTIMAL_UTILIZATION_RATE = optimalUtilizationRate;\\r\\n    EXCESS_UTILIZATION_RATE = WadRayMath.ray().sub(optimalUtilizationRate);\\r\\n    addressesProvider = provider;\\r\\n    _baseVariableBorrowRate = baseVariableBorrowRate;\\r\\n    _variableRateSlope1 = variableRateSlope1;\\r\\n    _variableRateSlope2 = variableRateSlope2;\\r\\n  }\\r\\n\\r\\n  function variableRateSlope1() external view returns (uint256) {\\r\\n    return _variableRateSlope1;\\r\\n  }\\r\\n\\r\\n  function variableRateSlope2() external view returns (uint256) {\\r\\n    return _variableRateSlope2;\\r\\n  }\\r\\n\\r\\n\\r\\n  function baseVariableBorrowRate() external view override returns (uint256) {\\r\\n    return _baseVariableBorrowRate;\\r\\n  }\\r\\n\\r\\n  function getMaxVariableBorrowRate() external view override returns (uint256) {\\r\\n    return _baseVariableBorrowRate.add(_variableRateSlope1).add(_variableRateSlope2);\\r\\n  }\\r\\n\\r\\n  struct CalcInterestRatesLocalVars {\\r\\n    uint256 totalDebt;\\r\\n    uint256 currentVariableBorrowRate;\\r\\n    uint256 currentLiquidityRate;\\r\\n    uint256 utilizationRate;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Calculates the interest rates depending on the reserve\\u0027s state and configurations\\r\\n   * @param availableLiquidity The liquidity available in the reserve\\r\\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\\r\\n   * @param reserveFactor The reserve portion of the interest that goes to the treasury address.\\r\\n   * @return The liquidity rate, the variable borrow rate\\r\\n   **/\\r\\n  function calculateInterestRates(\\r\\n    uint256 availableLiquidity,\\r\\n    uint256 totalVariableDebt,\\r\\n    uint256 reserveFactor\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    override\\r\\n    returns (\\r\\n      uint256,\\r\\n      uint256\\r\\n    )\\r\\n  {\\r\\n    CalcInterestRatesLocalVars memory vars;\\r\\n    vars.totalDebt = totalVariableDebt;\\r\\n    vars.currentVariableBorrowRate = 0;\\r\\n    vars.currentLiquidityRate = 0;\\r\\n\\r\\n    uint256 utilizationRate =\\r\\n      vars.totalDebt == 0 ? 0 : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\\r\\n\\r\\n    if (utilizationRate \\u003e OPTIMAL_UTILIZATION_RATE) {\\r\\n      uint256 excessUtilizationRateRatio =\\r\\n        utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE);\\r\\n\\r\\n\\r\\n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add(\\r\\n        _variableRateSlope2.rayMul(excessUtilizationRateRatio)\\r\\n      );\\r\\n    } else {\\r\\n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(\\r\\n        utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE)\\r\\n      );\\r\\n    }\\r\\n\\r\\n    vars.currentLiquidityRate = _getOverallBorrowRate(\\r\\n      totalVariableDebt,\\r\\n      vars.currentVariableBorrowRate\\r\\n    )\\r\\n      .rayMul(utilizationRate)\\r\\n      .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor));\\r\\n\\r\\n    return (\\r\\n      vars.currentLiquidityRate,\\r\\n      vars.currentVariableBorrowRate\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Calculates the overall borrow rate as the weighted average between the total variable debt \\r\\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\\r\\n   * @param currentVariableBorrowRate The current variable borrow rate of the reserve\\r\\n   * @return The weighted averaged borrow rate\\r\\n   **/\\r\\n  function _getOverallBorrowRate(\\r\\n    uint256 totalVariableDebt,\\r\\n    uint256 currentVariableBorrowRate\\r\\n  ) internal pure returns (uint256) {\\r\\n\\r\\n    if (totalVariableDebt == 0) return 0;\\r\\n\\r\\n    uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\\r\\n\\r\\n\\r\\n    uint256 overallBorrowRate =\\r\\n      weightedVariableRate.rayDiv(totalVariableDebt.wadToRay());\\r\\n\\r\\n    return overallBorrowRate;\\r\\n  }\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20 is Context, IERC20 {\\r\\n  using SafeMath for uint256;\\r\\n  using Address for address;\\r\\n\\r\\n  mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n  uint256 private _totalSupply;\\r\\n\\r\\n  string private _name;\\r\\n  string private _symbol;\\r\\n  uint8 private _decimals;\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\r\\n   * a default value of 18.\\r\\n   *\\r\\n   * To select a different value for {decimals}, use {_setupDecimals}.\\r\\n   *\\r\\n   * All three of these values are immutable: they can only be set once during\\r\\n   * construction.\\r\\n   */\\r\\n  constructor(string memory name, string memory symbol) public {\\r\\n    _name = name;\\r\\n    _symbol = symbol;\\r\\n    _decimals = 18;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the name of the token.\\r\\n   */\\r\\n  function name() public view returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n   * name.\\r\\n   */\\r\\n  function symbol() public view returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of decimals used to get its user representation.\\r\\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n   *\\r\\n   * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\r\\n   * called.\\r\\n   *\\r\\n   * NOTE: This information is only used for _display_ purposes: it in\\r\\n   * no way affects any of the arithmetic of the contract, including\\r\\n   * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n   */\\r\\n  function decimals() public view returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {IERC20-totalSupply}.\\r\\n   */\\r\\n  function totalSupply() public view override returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {IERC20-balanceOf}.\\r\\n   */\\r\\n  function balanceOf(address account) public view override returns (uint256) {\\r\\n    return _balances[account];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {IERC20-transfer}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `recipient` cannot be the zero address.\\r\\n   * - the caller must have a balance of at least `amount`.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n    _transfer(_msgSender(), recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {IERC20-allowance}.\\r\\n   */\\r\\n  function allowance(address owner, address spender)\\r\\n    public\\r\\n    view\\r\\n    virtual\\r\\n    override\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return _allowances[owner][spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {IERC20-approve}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n    _approve(_msgSender(), spender, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {IERC20-transferFrom}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n   * required by the EIP. See the note at the beginning of {ERC20};\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - `sender` and `recipient` cannot be the zero address.\\r\\n   * - `sender` must have a balance of at least `amount`.\\r\\n   * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\r\\n   * `amount`.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) public virtual override returns (bool) {\\r\\n    _transfer(sender, recipient, amount);\\r\\n    _approve(\\r\\n      sender,\\r\\n      _msgSender(),\\r\\n      _allowances[sender][_msgSender()].sub(amount, \\u0027ERC20: transfer amount exceeds allowance\\u0027)\\r\\n    );\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n   *\\r\\n   * This is an alternative to {approve} that can be used as a mitigation for\\r\\n   * problems described in {IERC20-approve}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n   *\\r\\n   * This is an alternative to {approve} that can be used as a mitigation for\\r\\n   * problems described in {IERC20-approve}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   * - `spender` must have allowance for the caller of at least\\r\\n   * `subtractedValue`.\\r\\n   */\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n    public\\r\\n    virtual\\r\\n    returns (bool)\\r\\n  {\\r\\n    _approve(\\r\\n      _msgSender(),\\r\\n      spender,\\r\\n      _allowances[_msgSender()][spender].sub(\\r\\n        subtractedValue,\\r\\n        \\u0027ERC20: decreased allowance below zero\\u0027\\r\\n      )\\r\\n    );\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n   *\\r\\n   * This is internal function is equivalent to {transfer}, and can be used to\\r\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `sender` cannot be the zero address.\\r\\n   * - `recipient` cannot be the zero address.\\r\\n   * - `sender` must have a balance of at least `amount`.\\r\\n   */\\r\\n  function _transfer(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) internal virtual {\\r\\n    require(sender != address(0), \\u0027ERC20: transfer from the zero address\\u0027);\\r\\n    require(recipient != address(0), \\u0027ERC20: transfer to the zero address\\u0027);\\r\\n\\r\\n    _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n    _balances[sender] = _balances[sender].sub(amount, \\u0027ERC20: transfer amount exceeds balance\\u0027);\\r\\n    _balances[recipient] = _balances[recipient].add(amount);\\r\\n    emit Transfer(sender, recipient, amount);\\r\\n  }\\r\\n\\r\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n   * the total supply.\\r\\n   *\\r\\n   * Emits a {Transfer} event with `from` set to the zero address.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `to` cannot be the zero address.\\r\\n   */\\r\\n  function _mint(address account, uint256 amount) internal virtual {\\r\\n    require(account != address(0), \\u0027ERC20: mint to the zero address\\u0027);\\r\\n\\r\\n    _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n    _totalSupply = _totalSupply.add(amount);\\r\\n    _balances[account] = _balances[account].add(amount);\\r\\n    emit Transfer(address(0), account, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n   * total supply.\\r\\n   *\\r\\n   * Emits a {Transfer} event with `to` set to the zero address.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `account` cannot be the zero address.\\r\\n   * - `account` must have at least `amount` tokens.\\r\\n   */\\r\\n  function _burn(address account, uint256 amount) internal virtual {\\r\\n    require(account != address(0), \\u0027ERC20: burn from the zero address\\u0027);\\r\\n\\r\\n    _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n    _balances[account] = _balances[account].sub(amount, \\u0027ERC20: burn amount exceeds balance\\u0027);\\r\\n    _totalSupply = _totalSupply.sub(amount);\\r\\n    emit Transfer(account, address(0), amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n   *\\r\\n   * This is internal function is equivalent to `approve`, and can be used to\\r\\n   * e.g. set automatic allowances for certain subsystems, etc.\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `owner` cannot be the zero address.\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function _approve(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 amount\\r\\n  ) internal virtual {\\r\\n    require(owner != address(0), \\u0027ERC20: approve from the zero address\\u0027);\\r\\n    require(spender != address(0), \\u0027ERC20: approve to the zero address\\u0027);\\r\\n\\r\\n    _allowances[owner][spender] = amount;\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets {decimals} to a value other than the default one of 18.\\r\\n   *\\r\\n   * WARNING: This function should only be called from the constructor. Most\\r\\n   * applications that interact with token contracts will not expect\\r\\n   * {decimals} to ever change, and may work incorrectly if it does.\\r\\n   */\\r\\n  function _setupDecimals(uint8 decimals_) internal {\\r\\n    _decimals = decimals_;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Hook that is called before any transfer of tokens. This includes\\r\\n   * minting and burning.\\r\\n   *\\r\\n   * Calling conditions:\\r\\n   *\\r\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n   * will be to transferred to `to`.\\r\\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n   * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n   * - `from` and `to` are never both zero.\\r\\n   *\\r\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n   */\\r\\n  function _beforeTokenTransfer(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount\\r\\n  ) internal virtual {}\\r\\n}\\r\\n\"},\"Errors.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @title Errors library\\n * @author Lever\\n * @notice Defines the error messages emitted by the different contracts of the Lever protocol\\n * @dev Error messages prefix glossary:\\n *  - VL = ValidationLogic\\n *  - MATH = Math libraries\\n *  - CT = Common errors between tokens (XToken, VariableDebtToken)\\n *  - XT = XToken\\n *  - DT = VariableDebtToken\\n *  - MP = MarginPool\\n *  - MPAPR = MarginPoolAddressesProviderRegistry\\n *  - MPC = MarginPoolConfiguration\\n *  - RL = ReserveLogic\\n *  - MPCM = MarginPoolCollateralManager\\n *  - P = Pausable\\n */\\nlibrary Errors {\\n  //common errors\\n  string public constant CALLER_NOT_POOL_ADMIN = \\u002733\\u0027; // \\u0027The caller must be the pool admin\\u0027\\n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = \\u002759\\u0027; // User borrows on behalf, but allowance are too small\\n\\n  //contract specific errors\\n  string public constant VL_INVALID_AMOUNT = \\u00271\\u0027; // \\u0027Amount must be greater than 0\\u0027\\n  string public constant VL_NO_ACTIVE_RESERVE = \\u00272\\u0027; // \\u0027Action requires an active reserve\\u0027\\n  string public constant VL_RESERVE_FROZEN = \\u00273\\u0027; // \\u0027Action cannot be performed because the reserve is frozen\\u0027\\n  string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = \\u00274\\u0027; // \\u0027The current liquidity is not enough\\u0027\\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = \\u00275\\u0027; // \\u0027User cannot withdraw more than the available balance\\u0027\\n  string public constant VL_TRANSFER_NOT_ALLOWED = \\u00276\\u0027; // \\u0027Transfer cannot be allowed.\\u0027\\n  string public constant VL_BORROWING_NOT_ENABLED = \\u00277\\u0027; // \\u0027Borrowing is not enabled\\u0027\\n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = \\u00278\\u0027; // \\u0027Invalid interest rate mode selected\\u0027\\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = \\u00279\\u0027; // \\u0027The collateral balance is 0\\u0027\\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \\u002710\\u0027; // \\u0027Health factor is lesser than the liquidation threshold\\u0027\\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = \\u002711\\u0027; // \\u0027There is not enough collateral to cover a new borrow\\u0027\\n  string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = \\u002713\\u0027; // collateral is (mostly) the same currency that is being borrowed\\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = \\u002715\\u0027; // \\u0027he needs to have variable debt\\u0027\\n  string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \\u002716\\u0027; // \\u0027To repay on behalf of an user an explicit amount to repay is needed\\u0027\\n  string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = \\u002718\\u0027; // \\u0027User does not have a variable rate loan in progress on this reserve\\u0027\\n  string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = \\u002719\\u0027; // \\u0027The underlying balance needs to be greater than 0\\u0027\\n  string public constant VL_DEPOSIT_ALREADY_IN_USE = \\u002720\\u0027; // \\u0027User deposit is already being used as collateral\\u0027\\n  string public constant MP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \\u002722\\u0027; // \\u0027Interest rate rebalance conditions were not met\\u0027\\n  string public constant MP_LIQUIDATION_CALL_FAILED = \\u002723\\u0027; // \\u0027Liquidation call failed\\u0027\\n  string public constant MP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = \\u002724\\u0027; // \\u0027There is not enough liquidity available to borrow\\u0027\\n  string public constant MP_REQUESTED_AMOUNT_TOO_SMALL = \\u002725\\u0027; // \\u0027The requested amount is too small for a FlashLoan.\\u0027\\n  string public constant MP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = \\u002726\\u0027; // \\u0027The actual balance of the protocol is inconsistent\\u0027\\n  string public constant MP_CALLER_NOT_MARGIN_POOL_CONFIGURATOR = \\u002727\\u0027; // \\u0027The caller of the function is not the margin pool configurator\\u0027\\n  string public constant MP_INCONSISTENT_FLASHLOAN_PARAMS = \\u002728\\u0027;\\n  string public constant CT_CALLER_MUST_BE_MARGIN_POOL = \\u002729\\u0027; // \\u0027The caller of this function must be a margin pool\\u0027\\n  string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = \\u002730\\u0027; // \\u0027User cannot give allowance to himself\\u0027\\n  string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = \\u002731\\u0027; // \\u0027Transferred amount needs to be greater than zero\\u0027\\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = \\u002732\\u0027; // \\u0027Reserve has already been initialized\\u0027\\n  string public constant MPC_RESERVE_LIQUIDITY_NOT_0 = \\u002734\\u0027; // \\u0027The liquidity of the reserve needs to be 0\\u0027\\n  string public constant MPC_INVALID_XTOKEN_POOL_ADDRESS = \\u002735\\u0027; // \\u0027The liquidity of the reserve needs to be 0\\u0027\\n  string public constant MPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = \\u002737\\u0027; // \\u0027The liquidity of the reserve needs to be 0\\u0027\\n  string public constant MPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = \\u002739\\u0027; // \\u0027The liquidity of the reserve needs to be 0\\u0027\\n  string public constant MPC_INVALID_ADDRESSES_PROVIDER_ID = \\u002740\\u0027; // \\u0027The liquidity of the reserve needs to be 0\\u0027\\n  string public constant MPC_INVALID_CONFIGURATION = \\u002775\\u0027; // \\u0027Invalid risk parameters for the reserve\\u0027\\n  string public constant MPC_CALLER_NOT_EMERGENCY_ADMIN = \\u002776\\u0027; // \\u0027The caller must be the emergency admin\\u0027\\n  string public constant MPAPR_PROVIDER_NOT_REGISTERED = \\u002741\\u0027; // \\u0027Provider is not registered\\u0027\\n  string public constant MPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \\u002742\\u0027; // \\u0027Health factor is not below the threshold\\u0027\\n  string public constant MPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = \\u002743\\u0027; // \\u0027The collateral chosen cannot be liquidated\\u0027\\n  string public constant MPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \\u002744\\u0027; // \\u0027User did not borrow the specified currency\\u0027\\n  string public constant MPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = \\u002745\\u0027; // \\\"There isn\\u0027t enough liquidity available to liquidate\\\"\\n  string public constant MPCM_NO_ERRORS = \\u002746\\u0027; // \\u0027No errors\\u0027\\n  string public constant MP_INVALID_FLASHLOAN_MODE = \\u002747\\u0027; //Invalid flashloan mode selected\\n  string public constant MATH_MULTIPLICATION_OVERFLOW = \\u002748\\u0027;\\n  string public constant MATH_ADDITION_OVERFLOW = \\u002749\\u0027;\\n  string public constant MATH_DIVISION_BY_ZERO = \\u002750\\u0027;\\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = \\u002751\\u0027; //  Liquidity index overflows uint128\\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = \\u002752\\u0027; //  Variable borrow index overflows uint128\\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = \\u002753\\u0027; //  Liquidity rate overflows uint128\\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = \\u002754\\u0027; //  Variable borrow rate overflows uint128\\n  string public constant CT_INVALID_MINT_AMOUNT = \\u002756\\u0027; //invalid amount to mint\\n  string public constant MP_FAILED_REPAY_WITH_COLLATERAL = \\u002757\\u0027;\\n  string public constant CT_INVALID_BURN_AMOUNT = \\u002758\\u0027; //invalid amount to burn\\n  string public constant MP_FAILED_COLLATERAL_SWAP = \\u002760\\u0027;\\n  string public constant MP_INVALID_EQUAL_ASSETS_TO_SWAP = \\u002761\\u0027;\\n  string public constant MP_REENTRANCY_NOT_ALLOWED = \\u002762\\u0027;\\n  string public constant MP_CALLER_MUST_BE_AN_XTOKEN = \\u002763\\u0027;\\n  string public constant MP_IS_PAUSED = \\u002764\\u0027; // \\u0027Pool is paused\\u0027\\n  string public constant MP_NO_MORE_RESERVES_ALLOWED = \\u002765\\u0027;\\n  string public constant MP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = \\u002766\\u0027;\\n  string public constant RC_INVALID_LTV = \\u002767\\u0027;\\n  string public constant RC_INVALID_LIQ_THRESHOLD = \\u002768\\u0027;\\n  string public constant RC_INVALID_LIQ_BONUS = \\u002769\\u0027;\\n  string public constant RC_INVALID_DECIMALS = \\u002770\\u0027;\\n  string public constant RC_INVALID_RESERVE_FACTOR = \\u002771\\u0027;\\n  string public constant MPAPR_INVALID_ADDRESSES_PROVIDER_ID = \\u002772\\u0027;\\n  string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = \\u002773\\u0027;\\n  string public constant MP_INCONSISTENT_PARAMS_LENGTH = \\u002774\\u0027;\\n  string public constant UL_INVALID_INDEX = \\u002777\\u0027;\\n  string public constant MP_NOT_CONTRACT = \\u002778\\u0027;\\n  string public constant SDT_BURN_EXCEEDS_BALANCE = \\u002780\\u0027;\\n\\n  enum CollateralManagerErrors {\\n    NO_ERROR,\\n    NO_COLLATERAL_AVAILABLE,\\n    COLLATERAL_CANNOT_BE_LIQUIDATED,\\n    CURRRENCY_NOT_BORROWED,\\n    HEALTH_FACTOR_ABOVE_THRESHOLD,\\n    NOT_ENOUGH_LIQUIDITY,\\n    NO_ACTIVE_RESERVE,\\n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\\n    INVALID_EQUAL_ASSETS_TO_SWAP,\\n    FROZEN_RESERVE\\n  }\\n}\\n\"},\"GenericLogic.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {SafeMath} from \\u0027./SafeMath.sol\\u0027;\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\nimport {ReserveLogic} from \\u0027./ReserveLogic.sol\\u0027;\\r\\nimport {ReserveConfiguration} from \\u0027./ReserveConfiguration.sol\\u0027;\\r\\nimport {UserConfiguration} from \\u0027./UserConfiguration.sol\\u0027;\\r\\nimport {WadRayMath} from \\u0027./WadRayMath.sol\\u0027;\\r\\nimport {PercentageMath} from \\u0027./PercentageMath.sol\\u0027;\\r\\nimport {IPriceOracleGetter} from \\u0027./IPriceOracleGetter.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title GenericLogic library\\r\\n * @author Lever\\r\\n * @title Implements protocol-level logic to calculate and validate the state of a user\\r\\n */\\r\\nlibrary GenericLogic {\\r\\n  using ReserveLogic for DataTypes.ReserveData;\\r\\n  using SafeMath for uint256;\\r\\n  using WadRayMath for uint256;\\r\\n  using PercentageMath for uint256;\\r\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\r\\n  using UserConfiguration for DataTypes.UserConfigurationMap;\\r\\n\\r\\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\\r\\n\\r\\n  struct balanceDecreaseAllowedLocalVars {\\r\\n    uint256 decimals;\\r\\n    uint256 liquidationThreshold;\\r\\n    uint256 totalCollateralInETH;\\r\\n    uint256 totalDebtInETH;\\r\\n    uint256 avgLiquidationThreshold;\\r\\n    uint256 amountToDecreaseInETH;\\r\\n    uint256 collateralBalanceAfterDecrease;\\r\\n    uint256 liquidationThresholdAfterDecrease;\\r\\n    uint256 healthFactorAfterDecrease;\\r\\n    bool reserveUsageAsCollateralEnabled;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Checks if a specific balance decrease is allowed\\r\\n   * (i.e. doesn\\u0027t bring the user borrow position health factor under HEALTH_FACTOR_LIQUIDATION_THRESHOLD)\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user\\r\\n   * @param amount The amount to decrease\\r\\n   * @param reservesData The data of all the reserves\\r\\n   * @param userConfig The user configuration\\r\\n   * @param reserves The list of all the active reserves\\r\\n   * @param oracle The address of the oracle contract\\r\\n   * @return true if the decrease of the balance is allowed\\r\\n   **/\\r\\n  function balanceDecreaseAllowed(\\r\\n    address asset,\\r\\n    address user,\\r\\n    uint256 amount,\\r\\n    mapping(address =\\u003e DataTypes.ReserveData) storage reservesData,\\r\\n    DataTypes.UserConfigurationMap calldata userConfig,\\r\\n    mapping(uint256 =\\u003e address) storage reserves,\\r\\n    uint256 reservesCount,\\r\\n    address oracle\\r\\n  ) external view returns (bool) {\\r\\n    if (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    balanceDecreaseAllowedLocalVars memory vars;\\r\\n\\r\\n    (, vars.liquidationThreshold, , vars.decimals, ) = reservesData[asset]\\r\\n      .configuration\\r\\n      .getParams();\\r\\n\\r\\n    if (vars.liquidationThreshold == 0) {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    (\\r\\n      vars.totalCollateralInETH,\\r\\n      vars.totalDebtInETH,\\r\\n      ,\\r\\n      vars.avgLiquidationThreshold,\\r\\n\\r\\n    ) = calculateUserAccountData(user, reservesData, userConfig, reserves, reservesCount, oracle);\\r\\n\\r\\n    if (vars.totalDebtInETH == 0) {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    vars.amountToDecreaseInETH = IPriceOracleGetter(oracle).getAssetPrice(asset).mul(amount).div(\\r\\n      10**vars.decimals\\r\\n    );\\r\\n\\r\\n    vars.collateralBalanceAfterDecrease = vars.totalCollateralInETH.sub(vars.amountToDecreaseInETH);\\r\\n\\r\\n    //if there is a borrow, there can\\u0027t be 0 collateral\\r\\n    if (vars.collateralBalanceAfterDecrease == 0) {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    vars.liquidationThresholdAfterDecrease = vars\\r\\n      .totalCollateralInETH\\r\\n      .mul(vars.avgLiquidationThreshold)\\r\\n      .sub(vars.amountToDecreaseInETH.mul(vars.liquidationThreshold))\\r\\n      .div(vars.collateralBalanceAfterDecrease);\\r\\n\\r\\n    uint256 healthFactorAfterDecrease =\\r\\n      calculateHealthFactorFromBalances(\\r\\n        vars.collateralBalanceAfterDecrease,\\r\\n        vars.totalDebtInETH,\\r\\n        vars.liquidationThresholdAfterDecrease\\r\\n      );\\r\\n\\r\\n    return healthFactorAfterDecrease \\u003e= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\\r\\n  }\\r\\n\\r\\n  struct CalculateUserAccountDataVars {\\r\\n    uint256 reserveUnitPrice;\\r\\n    uint256 tokenUnit;\\r\\n    uint256 compoundedLiquidityBalance;\\r\\n    uint256 compoundedBorrowBalance;\\r\\n    uint256 decimals;\\r\\n    uint256 ltv;\\r\\n    uint256 liquidationThreshold;\\r\\n    uint256 i;\\r\\n    uint256 healthFactor;\\r\\n    uint256 totalCollateralInETH;\\r\\n    uint256 totalDebtInETH;\\r\\n    uint256 avgLtv;\\r\\n    uint256 avgLiquidationThreshold;\\r\\n    uint256 reservesLength;\\r\\n    bool healthFactorBelowThreshold;\\r\\n    address currentReserveAddress;\\r\\n    bool usageAsCollateralEnabled;\\r\\n    bool userUsesReserveAsCollateral;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Calculates the user data across the reserves.\\r\\n   * this includes the total liquidity/collateral/borrow balances in ETH,\\r\\n   * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\\r\\n   * @param user The address of the user\\r\\n   * @param reservesData Data of all the reserves\\r\\n   * @param userConfig The configuration of the user\\r\\n   * @param reserves The list of the available reserves\\r\\n   * @param oracle The price oracle address\\r\\n   * @return The total collateral and total debt of the user in ETH, the avg ltv, liquidation threshold and the HF\\r\\n   **/\\r\\n  function calculateUserAccountData(\\r\\n    address user,\\r\\n    mapping(address =\\u003e DataTypes.ReserveData) storage reservesData,\\r\\n    DataTypes.UserConfigurationMap memory userConfig,\\r\\n    mapping(uint256 =\\u003e address) storage reserves,\\r\\n    uint256 reservesCount,\\r\\n    address oracle\\r\\n  )\\r\\n    internal\\r\\n    view\\r\\n    returns (\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256\\r\\n    )\\r\\n  {\\r\\n    CalculateUserAccountDataVars memory vars;\\r\\n\\r\\n    if (userConfig.isEmpty()) {\\r\\n      return (0, 0, 0, 0, uint256(-1));\\r\\n    }\\r\\n    for (vars.i = 0; vars.i \\u003c reservesCount; vars.i++) {\\r\\n      if (!userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\\r\\n        continue;\\r\\n      }\\r\\n\\r\\n      vars.currentReserveAddress = reserves[vars.i];\\r\\n      DataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\\r\\n\\r\\n      (vars.ltv, vars.liquidationThreshold, , vars.decimals, ) = currentReserve\\r\\n        .configuration\\r\\n        .getParams();\\r\\n\\r\\n      vars.tokenUnit = 10**vars.decimals;\\r\\n      vars.reserveUnitPrice = IPriceOracleGetter(oracle).getAssetPrice(vars.currentReserveAddress);\\r\\n\\r\\n      if (vars.liquidationThreshold != 0 \\u0026\\u0026 userConfig.isUsingAsCollateral(vars.i)) {\\r\\n        vars.compoundedLiquidityBalance = IERC20(currentReserve.xTokenAddress).balanceOf(user);\\r\\n\\r\\n        uint256 liquidityBalanceETH =\\r\\n          vars.reserveUnitPrice.mul(vars.compoundedLiquidityBalance).div(vars.tokenUnit);\\r\\n\\r\\n        vars.totalCollateralInETH = vars.totalCollateralInETH.add(liquidityBalanceETH);\\r\\n\\r\\n        vars.avgLtv = vars.avgLtv.add(liquidityBalanceETH.mul(vars.ltv));\\r\\n        vars.avgLiquidationThreshold = vars.avgLiquidationThreshold.add(\\r\\n          liquidityBalanceETH.mul(vars.liquidationThreshold)\\r\\n        );\\r\\n      }\\r\\n\\r\\n      if (userConfig.isBorrowing(vars.i)) {\\r\\n        vars.compoundedBorrowBalance = IERC20(currentReserve.variableDebtTokenAddress).balanceOf(\\r\\n          user\\r\\n        );\\r\\n\\r\\n        vars.totalDebtInETH = vars.totalDebtInETH.add(\\r\\n          vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n\\r\\n    vars.avgLtv = vars.totalCollateralInETH \\u003e 0 ? vars.avgLtv.div(vars.totalCollateralInETH) : 0;\\r\\n    vars.avgLiquidationThreshold = vars.totalCollateralInETH \\u003e 0\\r\\n      ? vars.avgLiquidationThreshold.div(vars.totalCollateralInETH)\\r\\n      : 0;\\r\\n\\r\\n    vars.healthFactor = calculateHealthFactorFromBalances(\\r\\n      vars.totalCollateralInETH,\\r\\n      vars.totalDebtInETH,\\r\\n      vars.avgLiquidationThreshold\\r\\n    );\\r\\n    return (\\r\\n      vars.totalCollateralInETH,\\r\\n      vars.totalDebtInETH,\\r\\n      vars.avgLtv,\\r\\n      vars.avgLiquidationThreshold,\\r\\n      vars.healthFactor\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Calculates the health factor from the corresponding balances\\r\\n   * @param totalCollateralInETH The total collateral in ETH\\r\\n   * @param totalDebtInETH The total debt in ETH\\r\\n   * @param liquidationThreshold The avg liquidation threshold\\r\\n   * @return The health factor calculated from the balances provided\\r\\n   **/\\r\\n  function calculateHealthFactorFromBalances(\\r\\n    uint256 totalCollateralInETH,\\r\\n    uint256 totalDebtInETH,\\r\\n    uint256 liquidationThreshold\\r\\n  ) internal pure returns (uint256) {\\r\\n    if (totalDebtInETH == 0) return uint256(-1);\\r\\n\\r\\n    return (totalCollateralInETH.percentMul(liquidationThreshold)).wadDiv(totalDebtInETH);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\\r\\n   * average Loan To Value\\r\\n   * @param totalCollateralInETH The total collateral in ETH\\r\\n   * @param totalDebtInETH The total borrow balance\\r\\n   * @param ltv The average loan to value\\r\\n   * @return the amount available to borrow in ETH for the user\\r\\n   **/\\r\\n\\r\\n  function calculateAvailableBorrowsETH(\\r\\n    uint256 totalCollateralInETH,\\r\\n    uint256 totalDebtInETH,\\r\\n    uint256 ltv\\r\\n  ) internal pure returns (uint256) {\\r\\n    uint256 availableBorrowsETH = totalCollateralInETH.percentMul(ltv);\\r\\n\\r\\n    if (availableBorrowsETH \\u003c totalDebtInETH) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    availableBorrowsETH = availableBorrowsETH.sub(totalDebtInETH);\\r\\n    return availableBorrowsETH;\\r\\n  }\\r\\n\\r\\n  struct AvailableCollateralToLiquidateLocalVars {\\r\\n    uint256 userCompoundedBorrowBalance;\\r\\n    uint256 liquidationBonus;\\r\\n    uint256 collateralPrice;\\r\\n    uint256 debtAssetPrice;\\r\\n    uint256 maxAmountCollateralToLiquidate;\\r\\n    uint256 debtAssetDecimals;\\r\\n    uint256 collateralDecimals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Calculates how much of a specific collateral can be liquidated, given\\r\\n    * a certain amount of debt asset.\\r\\n    * - This function needs to be called after all the checks to validate the liquidation have been performed,\\r\\n    *   otherwise it might fail.\\r\\n    * @param collateralReserve The data of the collateral reserve\\r\\n    * @param debtReserve The data of the debt reserve\\r\\n    * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n    * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n    * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n    * @param userCollateralBalance The collateral balance for the specific `collateralAsset` of the user being liquidated\\r\\n    * @return collateralAmount: The maximum amount that is possible to liquidate given all the liquidation constraints\\r\\n    *                           (user balance, close factor)\\r\\n    *         debtAmountNeeded: The amount to repay with the liquidation\\r\\n    **/\\r\\n  function calculateAvailableCollateralToLiquidate(\\r\\n    DataTypes.ReserveData storage collateralReserve,\\r\\n    DataTypes.ReserveData storage debtReserve,\\r\\n    address collateralAsset,\\r\\n    address debtAsset,\\r\\n    uint256 debtToCover,\\r\\n    uint256 userCollateralBalance,\\r\\n    address oracle\\r\\n  ) internal view returns (uint256, uint256) {\\r\\n      uint256 collateralAmount = 0;\\r\\n\\r\\n      AvailableCollateralToLiquidateLocalVars memory vars;\\r\\n\\r\\n      vars.collateralPrice = IPriceOracleGetter(oracle).getAssetPrice(\\r\\n          collateralAsset\\r\\n      );\\r\\n      vars.debtAssetPrice = IPriceOracleGetter(oracle).getAssetPrice(\\r\\n          debtAsset\\r\\n      );\\r\\n\\r\\n      (\\r\\n          ,\\r\\n          ,\\r\\n          vars.liquidationBonus,\\r\\n          vars.collateralDecimals,\\r\\n\\r\\n      ) = collateralReserve.configuration.getParams();\\r\\n      vars.debtAssetDecimals = debtReserve.configuration.getDecimals();\\r\\n\\r\\n      // This is the maximum possible amount of the selected collateral that can be liquidated, given the\\r\\n      // max amount of liquidatable debt\\r\\n      vars.maxAmountCollateralToLiquidate = vars\\r\\n          .debtAssetPrice\\r\\n          .mul(debtToCover)\\r\\n          .mul(10**vars.collateralDecimals)\\r\\n          .percentMul(vars.liquidationBonus)\\r\\n          .div(vars.collateralPrice.mul(10**vars.debtAssetDecimals));\\r\\n\\r\\n      if (vars.maxAmountCollateralToLiquidate \\u003e userCollateralBalance) {\\r\\n          collateralAmount = userCollateralBalance;\\r\\n      } else {\\r\\n          collateralAmount = vars.maxAmountCollateralToLiquidate;\\r\\n      }\\r\\n      return (\\r\\n          collateralAmount,\\r\\n          collateralAmount.percentDiv(vars.liquidationBonus)\\r\\n      );\\r\\n  }\\r\\n\\r\\n\\r\\n}\\r\\n\"},\"Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title Helpers library\\r\\n * @author Lever\\r\\n */\\r\\nlibrary Helpers {\\r\\n  /**\\r\\n   * @dev Fetches the user current variable debt balances\\r\\n   * @param user The user address\\r\\n   * @param reserve The reserve data object\\r\\n   * @return The variable debt balance\\r\\n   **/\\r\\n  function getUserCurrentDebt(address user, DataTypes.ReserveData storage reserve)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return IERC20(reserve.variableDebtTokenAddress).balanceOf(user);\\r\\n  }\\r\\n\\r\\n  function getUserCurrentDebtMemory(address user, DataTypes.ReserveData memory reserve)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return IERC20(reserve.variableDebtTokenAddress).balanceOf(user);\\r\\n  }\\r\\n}\\r\\n\"},\"IChainlinkAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IChainlinkAggregator {\\r\\n  function latestAnswer() external view returns (int256);\\r\\n\\r\\n  function latestTimestamp() external view returns (uint256);\\r\\n\\r\\n  function latestRound() external view returns (uint256);\\r\\n\\r\\n  function getAnswer(uint256 roundId) external view returns (int256);\\r\\n\\r\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\r\\n\\r\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\\r\\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\\r\\n}\\r\\n\"},\"ICreditDelegationToken.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface ICreditDelegationToken {\\r\\n  event BorrowAllowanceDelegated(\\r\\n    address indexed fromUser,\\r\\n    address indexed toUser,\\r\\n    address asset,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev delegates borrowing power to a user on the specific debt token\\r\\n   * @param delegatee the address receiving the delegated borrowing power\\r\\n   * @param amount the maximum amount being delegated. Delegation will still\\r\\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\\r\\n   * force a delegator HF to go below 1)\\r\\n   **/\\r\\n  function approveDelegation(address delegatee, uint256 amount) external;\\r\\n\\r\\n  /**\\r\\n   * @dev returns the borrow allowance of the user\\r\\n   * @param fromUser The user to giving allowance\\r\\n   * @param toUser The user to give allowance to\\r\\n   * @return the current allowance of toUser\\r\\n   **/\\r\\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens in existence.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens owned by `account`.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remaining number of tokens that `spender` will be\\r\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n   * zero by default.\\r\\n   *\\r\\n   * This value changes when {approve} or {transferFrom} are called.\\r\\n   */\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n   * that someone may use both the old and the new allowance by unfortunate\\r\\n   * transaction ordering. One possible solution to mitigate this race\\r\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n   * desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n   * allowance.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n   * another (`to`).\\r\\n   *\\r\\n   * Note that `value` may be zero.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n   * a call to {approve}. `value` is the new allowance.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IERC20Detailed.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IERC20Detailed is IERC20 {\\r\\n  function name() external view returns (string memory);\\r\\n\\r\\n  function symbol() external view returns (string memory);\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n}\\r\\n\"},\"IERC20DetailedBytes.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ncontract IERC20DetailedBytes {\\r\\n  bytes32 public name;\\r\\n  bytes32 public symbol;\\r\\n  uint256 public decimals;\\r\\n}\\r\\n\"},\"IERC20WithPermit.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IERC20WithPermit is IERC20 {\\r\\n  function permit(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external;\\r\\n}\\r\\n\"},\"IExtendedPriceAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IExtendedPriceAggregator {\\r\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\\r\\n\\r\\n  function getToken() external view returns (address);\\r\\n\\r\\n  function getTokenType() external view returns (uint256);\\r\\n\\r\\n  function getPlatformId() external view returns (uint256);\\r\\n\\r\\n  function getSubTokens() external view returns (address[] memory);\\r\\n\\r\\n  function latestAnswer() external view returns (int256);\\r\\n}\\r\\n\"},\"IMarginPool.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {IMarginPoolAddressesProvider} from \\u0027./IMarginPoolAddressesProvider.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\ninterface IMarginPool {\\r\\n  /**\\r\\n   * @dev Emitted on deposit()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address initiating the deposit\\r\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the xTokens\\r\\n   * @param amount The amount deposited\\r\\n   **/\\r\\n  event Deposit(\\r\\n    address indexed reserve,\\r\\n    address indexed user,\\r\\n    address indexed onBehalfOf,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on withdraw()\\r\\n   * @param reserve The address of the underlyng asset being withdrawn\\r\\n   * @param user The address initiating the withdrawal, owner of xTokens\\r\\n   * @param to Address that will receive the underlying\\r\\n   * @param amount The amount to be withdrawn\\r\\n   **/\\r\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on borrow() when debt needs to be opened\\r\\n   * @param reserve The address of the underlying asset being borrowed\\r\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow()\\r\\n   * @param onBehalfOf The address that will be getting the debt\\r\\n   * @param amount The amount borrowed out\\r\\n   * @param borrowRate The numeric rate at which the user has borrowed\\r\\n   **/\\r\\n  event Borrow(\\r\\n    address indexed reserve,\\r\\n    address indexed user,\\r\\n    address indexed onBehalfOf,\\r\\n    uint256 amount,\\r\\n    uint256 borrowRate\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on repay()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\r\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\r\\n   * @param amount The amount repaid\\r\\n   **/\\r\\n  event Repay(\\r\\n    address indexed reserve,\\r\\n    address indexed user,\\r\\n    address indexed repayer,\\r\\n    uint256 amount\\r\\n  );\\r\\n  \\r\\n    /**\\r\\n   * @dev Emitted on swapTokensForTokens() swapTokensForClosePosition() swapWithAggregation() closeWithAggregation()\\r\\n   * @param user The address initiating the swap\\r\\n   * @param srcReserve The address of the underlying asset of the source reserve\\r\\n   * @param dstReserve The address of the underlying asset of the destination reserve\\r\\n   * @param srcAmount The amount of source reserve\\r\\n   * @param dstAmount The amount of destination reserve\\r\\n   **/\\r\\n  event Swap(\\r\\n    address indexed user,\\r\\n    address indexed srcReserve,\\r\\n    address indexed dstReserve,\\r\\n    uint256 srcAmount,\\r\\n    uint256 dstAmount\\r\\n  );\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user enabling the usage as collateral\\r\\n   **/\\r\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user enabling the usage as collateral\\r\\n   **/\\r\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the pause is triggered.\\r\\n   */\\r\\n  event Paused();\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the pause is lifted.\\r\\n   */\\r\\n  event Unpaused();\\r\\n\\r\\n  /**\\r\\n    * @dev Emitted when a borrower is liquidated. This event is emitted by the MarginPool via\\r\\n    * MarginPoolCollateral manager using a DELEGATECALL\\r\\n    * This allows to have the events in the generated ABI for MarginPool.\\r\\n    * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n    * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n    * @param user The address of the borrower getting liquidated\\r\\n    * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n    * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\r\\n    * @param liquidator The address of the liquidator\\r\\n    **/\\r\\n  event LiquidationCall(\\r\\n      address indexed collateralAsset,\\r\\n      address indexed debtAsset,\\r\\n      address indexed user,\\r\\n      uint256 debtToCover,\\r\\n      uint256 liquidatedCollateralAmount,\\r\\n      address liquidator\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\r\\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\\r\\n   * the event will actually be fired by the MarginPool contract. The event is therefore replicated here so it\\r\\n   * gets added to the MarginPool ABI\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param liquidityRate The new liquidity rate\\r\\n   * @param variableBorrowRate The new variable borrow rate\\r\\n   * @param liquidityIndex The new liquidity index\\r\\n   * @param variableBorrowIndex The new variable borrow index\\r\\n   **/\\r\\n  event ReserveDataUpdated(\\r\\n    address indexed reserve,\\r\\n    uint256 liquidityRate,\\r\\n    uint256 variableBorrowRate,\\r\\n    uint256 liquidityIndex,\\r\\n    uint256 variableBorrowIndex\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying xTokens.\\r\\n   * - E.g. User deposits 100 USDC and gets in return 100 xUSDC\\r\\n   * @param asset The address of the underlying asset to deposit\\r\\n   * @param amount The amount to be deposited\\r\\n   * @param onBehalfOf The address that will receive the xTokens, same as msg.sender if the user\\r\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of xTokens\\r\\n   *   is a different wallet\\r\\n   **/\\r\\n  function deposit(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address onBehalfOf\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent xTokens owned\\r\\n   * E.g. User has 100 xUSDC, calls withdraw() and receives 100 USDC, burning the 100 xUSDC\\r\\n   * @param asset The address of the underlying asset to withdraw\\r\\n   * @param amount The underlying amount to be withdrawn\\r\\n   *   - Send the value type(uint256).max in order to withdraw the whole xToken balance\\r\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\r\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\r\\n   *   different wallet\\r\\n   * @return The final amount withdrawn\\r\\n   **/\\r\\n  function withdraw(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address to\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\r\\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\r\\n   * corresponding debt token ( VariableDebtToken)\\r\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\r\\n   *   and 100 variable debt tokens\\r\\n   * @param asset The address of the underlying asset to borrow\\r\\n   * @param amount The amount to be borrowed\\r\\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\r\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\r\\n   * if he has been given credit delegation allowance\\r\\n   **/\\r\\n  function borrow(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address onBehalfOf\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\r\\n   * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the `onBehalfOf` address\\r\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\r\\n   * @param amount The amount to repay\\r\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\r\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\r\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\r\\n   * other borrower whose debt should be removed\\r\\n   * @return The final amount repaid\\r\\n   **/\\r\\n  function repay(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address onBehalfOf\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  function swapTokensForTokens(\\r\\n    uint256 amountIn,\\r\\n    uint256 amountOut,\\r\\n    address[] calldata path,\\r\\n    bool isExactIn,\\r\\n    bool isUni\\r\\n  ) external;\\r\\n\\r\\n  function swapTokensForClosePosition(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        bool isExactIn,\\r\\n        bool isUni\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\r\\n   * @param asset The address of the underlying asset deposited\\r\\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\r\\n   **/\\r\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\r\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\r\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\r\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n   * @param user The address of the borrower getting liquidated\\r\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n   **/\\r\\n  function liquidationCall(\\r\\n    address collateralAsset,\\r\\n    address debtAsset,\\r\\n    address user,\\r\\n    uint256 debtToCover\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the user account data across all the reserves\\r\\n   * @param user The address of the user\\r\\n   * @return totalCollateralETH the total collateral in ETH of the user\\r\\n   * @return totalDebtETH the total debt in ETH of the user\\r\\n   * @return availableBorrowsETH the borrowing power left of the user\\r\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\r\\n   * @return ltv the loan to value of the user\\r\\n   * @return healthFactor the current health factor of the user\\r\\n   **/\\r\\n  function getUserAccountData(address user)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256 totalCollateralETH,\\r\\n      uint256 totalDebtETH,\\r\\n      uint256 availableBorrowsETH,\\r\\n      uint256 currentLiquidationThreshold,\\r\\n      uint256 ltv,\\r\\n      uint256 healthFactor\\r\\n    );\\r\\n\\r\\n  function initReserve(\\r\\n    address reserve,\\r\\n    address xTokenAddress,\\r\\n    address variableDebtAddress,\\r\\n    address interestRateStrategyAddress\\r\\n  ) external;\\r\\n\\r\\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\\r\\n    external;\\r\\n\\r\\n  function setConfiguration(address reserve, uint256 configuration) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The configuration of the reserve\\r\\n   **/\\r\\n  function getConfiguration(address asset)\\r\\n    external\\r\\n    view\\r\\n    returns (DataTypes.ReserveConfigurationMap memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the configuration of the user across all the reserves\\r\\n   * @param user The user address\\r\\n   * @return The configuration of the user\\r\\n   **/\\r\\n  function getUserConfiguration(address user)\\r\\n    external\\r\\n    view\\r\\n    returns (DataTypes.UserConfigurationMap memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized income normalized income of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve\\u0027s normalized income\\r\\n   */\\r\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized variable debt per unit of asset\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve normalized variable debt\\r\\n   */\\r\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the state and configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The state of the reserve\\r\\n   **/\\r\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\r\\n\\r\\n  function finalizeTransfer(\\r\\n    address asset,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount,\\r\\n    uint256 balanceFromAfter,\\r\\n    uint256 balanceToBefore\\r\\n  ) external;\\r\\n\\r\\n  function getReservesList() external view returns (address[] memory);\\r\\n\\r\\n  function getAddressesProvider() external view returns (IMarginPoolAddressesProvider);\\r\\n\\r\\n  function setPause(bool val) external;\\r\\n\\r\\n  function paused() external view returns (bool);\\r\\n}\\r\\n\"},\"IMarginPoolAddressesProvider.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @title MarginPoolAddressesProvider contract\\r\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\r\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\r\\n * - Owned by the Lever Governance\\r\\n * @author Lever\\r\\n **/\\r\\ninterface IMarginPoolAddressesProvider {\\r\\n  event MarginPoolUpdated(address indexed newAddress);\\r\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\r\\n  event EmergencyAdminUpdated(address indexed newAddress);\\r\\n  event MarginPoolConfiguratorUpdated(address indexed newAddress);\\r\\n  event MarginPoolCollateralManagerUpdated(address indexed newAddress);\\r\\n  event PriceOracleUpdated(address indexed newAddress);\\r\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\r\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\r\\n  event LeverTokenUpdated(address indexed newAddress);\\r\\n  event TreasuryAddressUpdated(address indexed newAddress);\\r\\n  event RewardsDistributionUpdated(address indexed newAddress);\\r\\n  event OrderBookUpdated(address indexed newAddress);\\r\\n  event SwapMinerUpdated(address indexed newAddress);\\r\\n\\r\\n\\r\\n  function setAddress(bytes32 id, address newAddress) external;\\r\\n\\r\\n  function setAddressAsProxy(bytes32 id, address impl) external;\\r\\n\\r\\n  function getAddress(bytes32 id) external view returns (address);\\r\\n\\r\\n  function getMarginPool() external view returns (address);\\r\\n\\r\\n  function setMarginPoolImpl(address pool, address UniswapRouter,address SushiswapRouter, address weth) external;\\r\\n\\r\\n  function getMarginPoolConfigurator() external view returns (address);\\r\\n\\r\\n  function setMarginPoolConfiguratorImpl(address configurator) external;\\r\\n\\r\\n  function getPoolAdmin() external view returns (address);\\r\\n\\r\\n  function setPoolAdmin(address admin) external;\\r\\n\\r\\n  function getEmergencyAdmin() external view returns (address);\\r\\n\\r\\n  function setEmergencyAdmin(address admin) external;\\r\\n\\r\\n  function getPriceOracle() external view returns (address);\\r\\n\\r\\n  function setPriceOracle(address priceOracle) external;\\r\\n\\r\\n  function getLeverToken() external view returns (address);\\r\\n\\r\\n  function setLeverToken(address lever) external;\\r\\n\\r\\n  function getTreasuryAddress() external view returns (address);\\r\\n\\r\\n  function setTreasuryAddress(address treasuryAddress) external;\\r\\n\\r\\n  function getRewardsDistribution() external view returns (address);\\r\\n\\r\\n  function setRewardsDistribution(address rewardsDistribution) external;\\r\\n\\r\\n  function getOrderBook() external view returns (address);\\r\\n\\r\\n  function setOrderBookImpl(address addressProvider, address UniswapRouter, address weth) external;\\r\\n\\r\\n  function getSwapMiner() external view returns (address);\\r\\n\\r\\n  function setSwapMinerImpl(address _swapMiner, address UniswapRouter, address _uniswapLevPairToken, address LeverUsdOracle) external;\\r\\n}\\r\\n\"},\"IncentivizedERC20.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {Context} from \\u0027./Context.sol\\u0027;\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\nimport {IERC20Detailed} from \\u0027./IERC20Detailed.sol\\u0027;\\r\\nimport {SafeMath} from \\u0027./SafeMath.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ERC20\\r\\n * @notice Basic ERC20 implementation\\r\\n * @author Lever, inspired by the Openzeppelin ERC20 implementation\\r\\n **/\\r\\ncontract IncentivizedERC20 is Context, IERC20, IERC20Detailed {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n\\r\\n  mapping(address =\\u003e uint256) internal _balances;\\r\\n\\r\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n  uint256 internal _totalSupply;\\r\\n  string private _name;\\r\\n  string private _symbol;\\r\\n  uint8 private _decimals;\\r\\n\\r\\n  constructor(\\r\\n    string memory name,\\r\\n    string memory symbol,\\r\\n    uint8 decimals\\r\\n  ) public {\\r\\n    _name = name;\\r\\n    _symbol = symbol;\\r\\n    _decimals = decimals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The name of the token\\r\\n   **/\\r\\n  function name() public view override returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The symbol of the token\\r\\n   **/\\r\\n  function symbol() public view override returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The decimals of the token\\r\\n   **/\\r\\n  function decimals() public view override returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The total supply of the token\\r\\n   **/\\r\\n  function totalSupply() public view virtual override returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The balance of the token\\r\\n   **/\\r\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n    return _balances[account];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Executes a transfer of tokens from _msgSender() to recipient\\r\\n   * @param recipient The recipient of the tokens\\r\\n   * @param amount The amount of tokens being transferred\\r\\n   * @return `true` if the transfer succeeds, `false` otherwise\\r\\n   **/\\r\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n    _transfer(_msgSender(), recipient, amount);\\r\\n    emit Transfer(_msgSender(), recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the allowance of spender on the tokens owned by owner\\r\\n   * @param owner The owner of the tokens\\r\\n   * @param spender The user allowed to spend the owner\\u0027s tokens\\r\\n   * @return The amount of owner\\u0027s tokens spender is allowed to spend\\r\\n   **/\\r\\n  function allowance(address owner, address spender)\\r\\n    public\\r\\n    view\\r\\n    virtual\\r\\n    override\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return _allowances[owner][spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows `spender` to spend the tokens owned by _msgSender()\\r\\n   * @param spender The user allowed to spend _msgSender() tokens\\r\\n   * @return `true`\\r\\n   **/\\r\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n    _approve(_msgSender(), spender, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Executes a transfer of token from sender to recipient, if _msgSender() is allowed to do so\\r\\n   * @param sender The owner of the tokens\\r\\n   * @param recipient The recipient of the tokens\\r\\n   * @param amount The amount of tokens being transferred\\r\\n   * @return `true` if the transfer succeeds, `false` otherwise\\r\\n   **/\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) public virtual override returns (bool) {\\r\\n    _transfer(sender, recipient, amount);\\r\\n    _approve(\\r\\n      sender,\\r\\n      _msgSender(),\\r\\n      _allowances[sender][_msgSender()].sub(amount, \\u0027ERC20: transfer amount exceeds allowance\\u0027)\\r\\n    );\\r\\n    emit Transfer(sender, recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Increases the allowance of spender to spend _msgSender() tokens\\r\\n   * @param spender The user allowed to spend on behalf of _msgSender()\\r\\n   * @param addedValue The amount being added to the allowance\\r\\n   * @return `true`\\r\\n   **/\\r\\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Decreases the allowance of spender to spend _msgSender() tokens\\r\\n   * @param spender The user allowed to spend on behalf of _msgSender()\\r\\n   * @param subtractedValue The amount being subtracted to the allowance\\r\\n   * @return `true`\\r\\n   **/\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n    public\\r\\n    virtual\\r\\n    returns (bool)\\r\\n  {\\r\\n    _approve(\\r\\n      _msgSender(),\\r\\n      spender,\\r\\n      _allowances[_msgSender()][spender].sub(\\r\\n        subtractedValue,\\r\\n        \\u0027ERC20: decreased allowance below zero\\u0027\\r\\n      )\\r\\n    );\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function _transfer(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) internal virtual {\\r\\n    require(sender != address(0), \\u0027ERC20: transfer from the zero address\\u0027);\\r\\n    require(recipient != address(0), \\u0027ERC20: transfer to the zero address\\u0027);\\r\\n\\r\\n    _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n    uint256 oldSenderBalance = _balances[sender];\\r\\n    _balances[sender] = oldSenderBalance.sub(amount, \\u0027ERC20: transfer amount exceeds balance\\u0027);\\r\\n    _balances[recipient] = _balances[recipient].add(amount);\\r\\n\\r\\n  }\\r\\n\\r\\n  function _mint(address account, uint256 amount) internal virtual {\\r\\n    require(account != address(0), \\u0027ERC20: mint to the zero address\\u0027);\\r\\n\\r\\n    _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n    uint256 oldTotalSupply = _totalSupply;\\r\\n    _totalSupply = oldTotalSupply.add(amount);\\r\\n\\r\\n    uint256 oldAccountBalance = _balances[account];\\r\\n    _balances[account] = oldAccountBalance.add(amount);\\r\\n  }\\r\\n\\r\\n  function _burn(address account, uint256 amount) internal virtual {\\r\\n    require(account != address(0), \\u0027ERC20: burn from the zero address\\u0027);\\r\\n\\r\\n    _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n    uint256 oldTotalSupply = _totalSupply;\\r\\n    _totalSupply = oldTotalSupply.sub(amount);\\r\\n\\r\\n    uint256 oldAccountBalance = _balances[account];\\r\\n    _balances[account] = oldAccountBalance.sub(amount, \\u0027ERC20: burn amount exceeds balance\\u0027);\\r\\n\\r\\n  }\\r\\n\\r\\n  function _approve(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 amount\\r\\n  ) internal virtual {\\r\\n    require(owner != address(0), \\u0027ERC20: approve from the zero address\\u0027);\\r\\n    require(spender != address(0), \\u0027ERC20: approve to the zero address\\u0027);\\r\\n\\r\\n    _allowances[owner][spender] = amount;\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n  function _setName(string memory newName) internal {\\r\\n    _name = newName;\\r\\n  }\\r\\n\\r\\n  function _setSymbol(string memory newSymbol) internal {\\r\\n    _symbol = newSymbol;\\r\\n  }\\r\\n\\r\\n  function _setDecimals(uint8 newDecimals) internal {\\r\\n    _decimals = newDecimals;\\r\\n  }\\r\\n\\r\\n  function _beforeTokenTransfer(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount\\r\\n  ) internal virtual {}\\r\\n}\\r\\n\"},\"Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity \\u003e=0.4.24 \\u003c0.7.0;\\r\\n\\r\\n/**\\r\\n * @title Initializable\\r\\n *\\r\\n * @dev Helper contract to support initializer functions. To use it, replace\\r\\n * the constructor with a function that has the `initializer` modifier.\\r\\n * WARNING: Unlike constructors, initializer functions must be manually\\r\\n * invoked. This applies both to deploying an Initializable contract, as well\\r\\n * as extending an Initializable contract via inheritance.\\r\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\r\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\r\\n * because this is not dealt with automatically as with constructors.\\r\\n */\\r\\ncontract Initializable {\\r\\n  /**\\r\\n   * @dev Indicates that the contract has been initialized.\\r\\n   */\\r\\n  bool private initialized;\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract is in the process of being initialized.\\r\\n   */\\r\\n  bool private initializing;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to use in the initializer function of a contract.\\r\\n   */\\r\\n  modifier initializer() {\\r\\n    require(\\r\\n      initializing || isConstructor() || !initialized,\\r\\n      \\u0027Contract instance has already been initialized\\u0027\\r\\n    );\\r\\n\\r\\n    bool isTopLevelCall = !initializing;\\r\\n    if (isTopLevelCall) {\\r\\n      initializing = true;\\r\\n      initialized = true;\\r\\n    }\\r\\n\\r\\n    _;\\r\\n\\r\\n    if (isTopLevelCall) {\\r\\n      initializing = false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Returns true if and only if the function is running in the constructor\\r\\n  function isConstructor() private view returns (bool) {\\r\\n    // extcodesize checks the size of the code stored in an address, and\\r\\n    // address returns the current address. Since the code is still not\\r\\n    // deployed when running a constructor, any checks on its code size will\\r\\n    // yield zero, making it an effective way to detect if a contract is\\r\\n    // under construction or not.\\r\\n    uint256 cs;\\r\\n    //solium-disable-next-line\\r\\n    assembly {\\r\\n      cs := extcodesize(address())\\r\\n    }\\r\\n    return cs == 0;\\r\\n  }\\r\\n\\r\\n  // Reserved storage space to allow for layout changes in the future.\\r\\n  uint256[50] private ______gap;\\r\\n}\\r\\n\"},\"InitializableAdminUpgradeabilityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\u0027./BaseAdminUpgradeabilityProxy.sol\\u0027;\\r\\nimport \\u0027./InitializableUpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title InitializableAdminUpgradeabilityProxy\\r\\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\\r\\n * initializing the implementation, admin, and init data.\\r\\n */\\r\\ncontract InitializableAdminUpgradeabilityProxy is\\r\\n  BaseAdminUpgradeabilityProxy,\\r\\n  InitializableUpgradeabilityProxy\\r\\n{\\r\\n  /**\\r\\n   * Contract initializer.\\r\\n   * @param logic address of the initial implementation.\\r\\n   * @param admin Address of the proxy administrator.\\r\\n   * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function initialize(\\r\\n    address logic,\\r\\n    address admin,\\r\\n    bytes memory data\\r\\n  ) public payable {\\r\\n    require(_implementation() == address(0),\\\"_implementation() != address(0)\\\");\\r\\n    InitializableUpgradeabilityProxy.initialize(logic, data);\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.admin\\u0027)) - 1));\\r\\n    _setAdmin(admin);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\\r\\n    BaseAdminUpgradeabilityProxy._willFallback();\\r\\n  }\\r\\n}\\r\\n\"},\"InitializableImmutableAdminUpgradeabilityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\u0027./BaseImmutableAdminUpgradeabilityProxy.sol\\u0027;\\r\\nimport \\u0027./InitializableUpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title InitializableAdminUpgradeabilityProxy\\r\\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\\r\\n */\\r\\ncontract InitializableImmutableAdminUpgradeabilityProxy is\\r\\n  BaseImmutableAdminUpgradeabilityProxy,\\r\\n  InitializableUpgradeabilityProxy\\r\\n{\\r\\n  constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {}\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\\r\\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\\r\\n  }\\r\\n}\\r\\n\"},\"InitializableUpgradeabilityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\u0027./BaseUpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title InitializableUpgradeabilityProxy\\r\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\r\\n * implementation and init data.\\r\\n */\\r\\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Contract initializer.\\r\\n   * @param _logic Address of the initial implementation.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function initialize(address _logic, bytes memory _data) public payable {\\r\\n    require(_implementation() == address(0),\\\"_implementation error!\\\");\\r\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.implementation\\u0027)) - 1));\\r\\n    _setImplementation(_logic);\\r\\n    if (_data.length \\u003e 0) {\\r\\n      (bool success, ) = _logic.delegatecall(_data);\\r\\n      require(success,\\\"_logic.delegatecall error!\\\");\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},\"IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/************\\r\\n@title IPriceOracle interface\\r\\n@notice Interface for the Lever price oracle.*/\\r\\ninterface IPriceOracle {\\r\\n  /***********\\r\\n    @dev returns the asset price in ETH\\r\\n     */\\r\\n  function getAssetPrice(address asset) external view returns (uint256);\\r\\n\\r\\n  /***********\\r\\n    @dev sets the asset price, in wei\\r\\n     */\\r\\n  function setAssetPrice(address asset, uint256 price) external;\\r\\n}\\r\\n\"},\"IPriceOracleGetter.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @title IPriceOracleGetter interface\\r\\n * @notice Interface for the Lever price oracle.\\r\\n **/\\r\\n\\r\\ninterface IPriceOracleGetter {\\r\\n  /**\\r\\n   * @dev returns the asset price in ETH\\r\\n   * @param asset the address of the asset\\r\\n   * @return the ETH price of the asset\\r\\n   **/\\r\\n  function getAssetPrice(address asset) external view returns (uint256);\\r\\n}\\r\\n\"},\"IReserveInterestRateStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @title IReserveInterestRateStrategyInterface interface\\r\\n * @dev Interface for the calculation of the interest rates\\r\\n * @author Lever\\r\\n */\\r\\ninterface IReserveInterestRateStrategy {\\r\\n  function baseVariableBorrowRate() external view returns (uint256);\\r\\n\\r\\n  function getMaxVariableBorrowRate() external view returns (uint256);\\r\\n\\r\\n  function calculateInterestRates(\\r\\n    uint256 utilizationRate,\\r\\n    uint256 totalVariableDebt,\\r\\n    uint256 reserveFactor\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256 liquidityRate,\\r\\n      uint256 variableBorrowRate\\r\\n    );\\r\\n}\\r\\n\"},\"IScaledBalanceToken.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IScaledBalanceToken {\\r\\n  /**\\r\\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\r\\n   * updated stored balance divided by the reserve\\u0027s liquidity index at the moment of the update\\r\\n   * @param user The user whose balance is calculated\\r\\n   * @return The scaled balance of the user\\r\\n   **/\\r\\n  function scaledBalanceOf(address user) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the scaled balance of the user and the scaled total supply.\\r\\n   * @param user The address of the user\\r\\n   * @return The scaled balance of the user\\r\\n   * @return The scaled balance and the scaled total supply\\r\\n   **/\\r\\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\r\\n   * @return The scaled total supply\\r\\n   **/\\r\\n  function scaledTotalSupply() external view returns (uint256);\\r\\n}\\r\\n\"},\"ITokenConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\n/**\\r\\n * @title ITokenConfiguration\\r\\n * @author Lever\\r\\n * @dev Common interface between xTokens and debt tokens to fetch the\\r\\n * token configuration\\r\\n **/\\r\\ninterface ITokenConfiguration {\\r\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\r\\n\\r\\n  function POOL() external view returns (address);\\r\\n}\\r\\n\"},\"IUniswapExchange.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IUniswapExchange {\\r\\n  event TokenPurchase(\\r\\n    address indexed buyer,\\r\\n    uint256 indexed eth_sold,\\r\\n    uint256 indexed tokens_bought\\r\\n  );\\r\\n  event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought);\\r\\n  event AddLiquidity(\\r\\n    address indexed provider,\\r\\n    uint256 indexed eth_amount,\\r\\n    uint256 indexed token_amount\\r\\n  );\\r\\n  event RemoveLiquidity(\\r\\n    address indexed provider,\\r\\n    uint256 indexed eth_amount,\\r\\n    uint256 indexed token_amount\\r\\n  );\\r\\n}\\r\\n\"},\"IUniswapV2Router01.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n  function factory() external pure returns (address);\\r\\n\\r\\n  function WETH() external pure returns (address);\\r\\n\\r\\n  function addLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint256 amountADesired,\\r\\n    uint256 amountBDesired,\\r\\n    uint256 amountAMin,\\r\\n    uint256 amountBMin,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  )\\r\\n    external\\r\\n    returns (\\r\\n      uint256 amountA,\\r\\n      uint256 amountB,\\r\\n      uint256 liquidity\\r\\n    );\\r\\n\\r\\n  function addLiquidityETH(\\r\\n    address token,\\r\\n    uint256 amountTokenDesired,\\r\\n    uint256 amountTokenMin,\\r\\n    uint256 amountETHMin,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  )\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n      uint256 amountToken,\\r\\n      uint256 amountETH,\\r\\n      uint256 liquidity\\r\\n    );\\r\\n\\r\\n  function removeLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint256 liquidity,\\r\\n    uint256 amountAMin,\\r\\n    uint256 amountBMin,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n  function removeLiquidityETH(\\r\\n    address token,\\r\\n    uint256 liquidity,\\r\\n    uint256 amountTokenMin,\\r\\n    uint256 amountETHMin,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n  function removeLiquidityWithPermit(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint256 liquidity,\\r\\n    uint256 amountAMin,\\r\\n    uint256 amountBMin,\\r\\n    address to,\\r\\n    uint256 deadline,\\r\\n    bool approveMax,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n  function removeLiquidityETHWithPermit(\\r\\n    address token,\\r\\n    uint256 liquidity,\\r\\n    uint256 amountTokenMin,\\r\\n    uint256 amountETHMin,\\r\\n    address to,\\r\\n    uint256 deadline,\\r\\n    bool approveMax,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n  function swapExactTokensForTokens(\\r\\n    uint256 amountIn,\\r\\n    uint256 amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external returns (uint256[] memory amounts);\\r\\n\\r\\n  function swapTokensForExactTokens(\\r\\n    uint256 amountOut,\\r\\n    uint256 amountInMax,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external returns (uint256[] memory amounts);\\r\\n\\r\\n  function swapExactETHForTokens(\\r\\n    uint256 amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n  function swapTokensForExactETH(\\r\\n    uint256 amountOut,\\r\\n    uint256 amountInMax,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external returns (uint256[] memory amounts);\\r\\n\\r\\n  function swapExactTokensForETH(\\r\\n    uint256 amountIn,\\r\\n    uint256 amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external returns (uint256[] memory amounts);\\r\\n\\r\\n  function swapETHForExactTokens(\\r\\n    uint256 amountOut,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n  function quote(\\r\\n    uint256 amountA,\\r\\n    uint256 reserveA,\\r\\n    uint256 reserveB\\r\\n  ) external pure returns (uint256 amountB);\\r\\n\\r\\n  function getAmountOut(\\r\\n    uint256 amountIn,\\r\\n    uint256 reserveIn,\\r\\n    uint256 reserveOut\\r\\n  ) external pure returns (uint256 amountOut);\\r\\n\\r\\n  function getAmountIn(\\r\\n    uint256 amountOut,\\r\\n    uint256 reserveIn,\\r\\n    uint256 reserveOut\\r\\n  ) external pure returns (uint256 amountIn);\\r\\n\\r\\n  function getAmountsOut(uint256 amountIn, address[] calldata path)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256[] memory amounts);\\r\\n\\r\\n  function getAmountsIn(uint256 amountOut, address[] calldata path)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256[] memory amounts);\\r\\n}\\r\\n\"},\"IUniswapV2Router02.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity \\u003e=0.6.2;\\r\\n\\r\\nimport \\u0027./IUniswapV2Router01.sol\\u0027;\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n    address token,\\r\\n    uint256 liquidity,\\r\\n    uint256 amountTokenMin,\\r\\n    uint256 amountETHMin,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external returns (uint256 amountETH);\\r\\n\\r\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n    address token,\\r\\n    uint256 liquidity,\\r\\n    uint256 amountTokenMin,\\r\\n    uint256 amountETHMin,\\r\\n    address to,\\r\\n    uint256 deadline,\\r\\n    bool approveMax,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external returns (uint256 amountETH);\\r\\n\\r\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n    uint256 amountIn,\\r\\n    uint256 amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external;\\r\\n\\r\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n    uint256 amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external payable;\\r\\n\\r\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n    uint256 amountIn,\\r\\n    uint256 amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint256 deadline\\r\\n  ) external;\\r\\n}\\r\\n\"},\"IVariableDebtToken.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IScaledBalanceToken} from \\u0027./IScaledBalanceToken.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title IVariableDebtToken\\r\\n * @author Lever\\r\\n * @notice Defines the basic interface for a variable debt token.\\r\\n **/\\r\\ninterface IVariableDebtToken is IScaledBalanceToken {\\r\\n  /**\\r\\n   * @dev Emitted after the mint action\\r\\n   * @param from The address performing the mint\\r\\n   * @param onBehalfOf The address of the user on which behalf minting has been performed\\r\\n   * @param value The amount to be minted\\r\\n   * @param index The last index of the reserve\\r\\n   **/\\r\\n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\\r\\n\\r\\n  /**\\r\\n   * @dev Mints debt token to the `onBehalfOf` address\\r\\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\\r\\n   * of credit delegate, or same as `onBehalfOf` otherwise\\r\\n   * @param onBehalfOf The address receiving the debt tokens\\r\\n   * @param amount The amount of debt being minted\\r\\n   * @param index The variable debt index of the reserve\\r\\n   * @return `true` if the the previous balance of the user is 0\\r\\n   **/\\r\\n  function mint(\\r\\n    address user,\\r\\n    address onBehalfOf,\\r\\n    uint256 amount,\\r\\n    uint256 index\\r\\n  ) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when variable debt is burnt\\r\\n   * @param user The user which debt has been burned\\r\\n   * @param amount The amount of debt being burned\\r\\n   * @param index The index of the user\\r\\n   **/\\r\\n  event Burn(address indexed user, uint256 amount, uint256 index);\\r\\n\\r\\n  /**\\r\\n   * @dev Burns user variable debt\\r\\n   * @param user The user which debt is burnt\\r\\n   * @param index The variable debt index of the reserve\\r\\n   **/\\r\\n  function burn(\\r\\n    address user,\\r\\n    uint256 amount,\\r\\n    uint256 index\\r\\n  ) external;\\r\\n}\\r\\n\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IWETH {\\r\\n  function deposit() external payable;\\r\\n\\r\\n  function withdraw(uint256) external;\\r\\n\\r\\n  function approve(address guy, uint256 wad) external returns (bool);\\r\\n\\r\\n  function transferFrom(\\r\\n    address src,\\r\\n    address dst,\\r\\n    uint256 wad\\r\\n  ) external returns (bool);\\r\\n}\\r\\n\"},\"IWETHGateway.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IWETHGateway {\\r\\n  function depositETH(address onBehalfOf) external payable;\\r\\n\\r\\n  function withdrawETH(uint256 amount, address onBehalfOf) external;\\r\\n\\r\\n  function borrowETH(\\r\\n    uint256 amount\\r\\n  ) external;\\r\\n}\\r\\n\"},\"IXToken.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\nimport {IScaledBalanceToken} from \\u0027./IScaledBalanceToken.sol\\u0027;\\r\\n\\r\\ninterface IXToken is IERC20, IScaledBalanceToken {\\r\\n  /**\\r\\n   * @dev Emitted after the mint action\\r\\n   * @param from The address performing the mint\\r\\n   * @param value The amount being\\r\\n   * @param index The new liquidity index of the reserve\\r\\n   **/\\r\\n  event Mint(address indexed from, uint256 value, uint256 index);\\r\\n\\r\\n  /**\\r\\n   * @dev Mints `amount` xTokens to `user`\\r\\n   * @param user The address receiving the minted tokens\\r\\n   * @param amount The amount of tokens getting minted\\r\\n   * @param index The new liquidity index of the reserve\\r\\n   * @return `true` if the the previous balance of the user was 0\\r\\n   */\\r\\n  function mint(\\r\\n    address user,\\r\\n    uint256 amount,\\r\\n    uint256 index\\r\\n  ) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted after xTokens are burned\\r\\n   * @param from The owner of the xTokens, getting them burned\\r\\n   * @param target The address that will receive the underlying\\r\\n   * @param value The amount being burned\\r\\n   * @param index The new liquidity index of the reserve\\r\\n   **/\\r\\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted during the transfer action\\r\\n   * @param from The user whose tokens are being transferred\\r\\n   * @param to The recipient\\r\\n   * @param value The amount being transferred\\r\\n   * @param index The new liquidity index of the reserve\\r\\n   **/\\r\\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\\r\\n\\r\\n  /**\\r\\n   * @dev Burns xTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\r\\n   * @param user The owner of the xTokens, getting them burned\\r\\n   * @param receiverOfUnderlying The address that will receive the underlying\\r\\n   * @param amount The amount being burned\\r\\n   * @param index The new liquidity index of the reserve\\r\\n   **/\\r\\n  function burn(\\r\\n    address user,\\r\\n    address receiverOfUnderlying,\\r\\n    uint256 amount,\\r\\n    uint256 index\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Mints xTokens to the reserve treasury\\r\\n   * @param amount The amount of tokens getting minted\\r\\n   * @param index The new liquidity index of the reserve\\r\\n   */\\r\\n  function mintToTreasury(uint256 amount, uint256 index) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers xTokens in the event of a borrow being liquidated, in case the liquidators reclaims the xToken\\r\\n   * @param from The address getting liquidated, current owner of the xTokens\\r\\n   * @param to The recipient\\r\\n   * @param value The amount of tokens getting transferred\\r\\n   **/\\r\\n  function transferOnLiquidation(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers the underlying asset to `target`. Used by the MarginPool to transfer\\r\\n   * assets in borrow(), withdraw() and flashLoan()\\r\\n   * @param user The recipient of the xTokens\\r\\n   * @param amount The amount getting transferred\\r\\n   * @return The amount transferred\\r\\n   **/\\r\\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\\r\\n}\\r\\n\"},\"LeverOracle.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {Ownable} from \\u0027./Ownable.sol\\u0027;\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\nimport {IPriceOracleGetter} from \\u0027./IPriceOracleGetter.sol\\u0027;\\r\\nimport {IChainlinkAggregator} from \\u0027./IChainlinkAggregator.sol\\u0027;\\r\\nimport {SafeERC20} from \\u0027./SafeERC20.sol\\u0027;\\r\\n\\r\\n/// @title LeverOracle\\r\\n/// @author Lever\\r\\n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Aggregator\\r\\n///         smart contracts as primary option\\r\\n/// - If the returned price by a Chainlink aggregator is \\u003c= 0, the call is forwarded to a fallbackOracle\\r\\n/// - Owned by the Lever governance system, allowed to add sources for assets, replace them\\r\\n///   and change the fallbackOracle\\r\\ncontract LeverUsdOracle is IPriceOracleGetter, Ownable {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  event WethSet(address indexed weth);\\r\\n  event AssetSourceUpdated(address indexed asset, address indexed source);\\r\\n  event FallbackOracleUpdated(address indexed fallbackOracle);\\r\\n\\r\\n  mapping(address =\\u003e IChainlinkAggregator) private assetsSources;\\r\\n  IPriceOracleGetter private _fallbackOracle;\\r\\n  address public immutable WETH;\\r\\n\\r\\n  /// @notice Constructor\\r\\n  /// @param assets The addresses of the assets\\r\\n  /// @param sources The address of the source of each asset\\r\\n  /// @param fallbackOracle The address of the fallback oracle to use if the data of an\\r\\n  ///        aggregator is not consistent\\r\\n  constructor(\\r\\n    address[] memory assets,\\r\\n    address[] memory sources,\\r\\n    address fallbackOracle,\\r\\n    address weth\\r\\n  ) public {\\r\\n    _setFallbackOracle(fallbackOracle);\\r\\n    _setAssetsSources(assets, sources);\\r\\n    WETH = weth;\\r\\n    emit WethSet(weth);\\r\\n  }\\r\\n\\r\\n  /// @notice External function called by the Lever governance to set or replace sources of assets\\r\\n  /// @param assets The addresses of the assets\\r\\n  /// @param sources The address of the source of each asset\\r\\n  function setAssetSources(address[] calldata assets, address[] calldata sources)\\r\\n    external\\r\\n    onlyOwner\\r\\n  {\\r\\n    _setAssetsSources(assets, sources);\\r\\n  }\\r\\n\\r\\n  /// @notice Sets the fallbackOracle\\r\\n  /// - Callable only by the Lever governance\\r\\n  /// @param fallbackOracle The address of the fallbackOracle\\r\\n  function setFallbackOracle(address fallbackOracle) external onlyOwner {\\r\\n    _setFallbackOracle(fallbackOracle);\\r\\n  }\\r\\n\\r\\n  /// @notice Internal function to set the sources for each asset\\r\\n  /// @param assets The addresses of the assets\\r\\n  /// @param sources The address of the source of each asset\\r\\n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal {\\r\\n    require(assets.length == sources.length, \\u0027INCONSISTENT_PARAMS_LENGTH\\u0027);\\r\\n    for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n      assetsSources[assets[i]] = IChainlinkAggregator(sources[i]);\\r\\n      emit AssetSourceUpdated(assets[i], sources[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Internal function to set the fallbackOracle\\r\\n  /// @param fallbackOracle The address of the fallbackOracle\\r\\n  function _setFallbackOracle(address fallbackOracle) internal {\\r\\n    _fallbackOracle = IPriceOracleGetter(fallbackOracle);\\r\\n    emit FallbackOracleUpdated(fallbackOracle);\\r\\n  }\\r\\n\\r\\n  /// @notice Gets an asset price by address\\r\\n  /// @param asset The asset address\\r\\n  function getAssetPrice(address asset) public view override returns (uint256) {\\r\\n    IChainlinkAggregator source = assetsSources[asset];\\r\\n    int256 price = IChainlinkAggregator(source).latestAnswer();\\r\\n    return uint256(price);\\r\\n  }\\r\\n\\r\\n  /// @notice Gets a list of prices from a list of assets addresses\\r\\n  /// @param assets The list of assets addresses\\r\\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) {\\r\\n    uint256[] memory prices = new uint256[](assets.length);\\r\\n    for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n      prices[i] = getAssetPrice(assets[i]);\\r\\n    }\\r\\n    return prices;\\r\\n  }\\r\\n\\r\\n  /// @notice Gets the address of the source for an asset address\\r\\n  /// @param asset The address of the asset\\r\\n  /// @return address The address of the source\\r\\n  function getSourceOfAsset(address asset) external view returns (address) {\\r\\n    return address(assetsSources[asset]);\\r\\n  }\\r\\n\\r\\n  /// @notice Gets the address of the fallback oracle\\r\\n  /// @return address The addres of the fallback oracle\\r\\n  function getFallbackOracle() external view returns (address) {\\r\\n    return address(_fallbackOracle);\\r\\n  }\\r\\n}\\r\\n\"},\"LeverUsdOracle.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {Ownable} from \\u0027./Ownable.sol\\u0027;\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\nimport {IPriceOracleGetter} from \\u0027./IPriceOracleGetter.sol\\u0027;\\r\\nimport {IChainlinkAggregator} from \\u0027./IChainlinkAggregator.sol\\u0027;\\r\\nimport {SafeERC20} from \\u0027./SafeERC20.sol\\u0027;\\r\\n\\r\\n/// @title LeverOracle\\r\\n/// @author Lever\\r\\n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Aggregator\\r\\n///         smart contracts as primary option\\r\\n/// - If the returned price by a Chainlink aggregator is \\u003c= 0, the call is forwarded to a fallbackOracle\\r\\n/// - Owned by the Lever governance system, allowed to add sources for assets, replace them\\r\\n///   and change the fallbackOracle\\r\\ncontract LeverOracle is IPriceOracleGetter, Ownable {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  event WethSet(address indexed weth);\\r\\n  event AssetSourceUpdated(address indexed asset, address indexed source);\\r\\n  event FallbackOracleUpdated(address indexed fallbackOracle);\\r\\n\\r\\n  mapping(address =\\u003e IChainlinkAggregator) private assetsSources;\\r\\n  IPriceOracleGetter private _fallbackOracle;\\r\\n  address public immutable WETH;\\r\\n\\r\\n  /// @notice Constructor\\r\\n  /// @param assets The addresses of the assets\\r\\n  /// @param sources The address of the source of each asset\\r\\n  /// @param fallbackOracle The address of the fallback oracle to use if the data of an\\r\\n  ///        aggregator is not consistent\\r\\n  constructor(\\r\\n    address[] memory assets,\\r\\n    address[] memory sources,\\r\\n    address fallbackOracle,\\r\\n    address weth\\r\\n  ) public {\\r\\n    _setFallbackOracle(fallbackOracle);\\r\\n    _setAssetsSources(assets, sources);\\r\\n    WETH = weth;\\r\\n    emit WethSet(weth);\\r\\n  }\\r\\n\\r\\n  /// @notice External function called by the Lever governance to set or replace sources of assets\\r\\n  /// @param assets The addresses of the assets\\r\\n  /// @param sources The address of the source of each asset\\r\\n  function setAssetSources(address[] calldata assets, address[] calldata sources)\\r\\n    external\\r\\n    onlyOwner\\r\\n  {\\r\\n    _setAssetsSources(assets, sources);\\r\\n  }\\r\\n\\r\\n  /// @notice Sets the fallbackOracle\\r\\n  /// - Callable only by the Lever governance\\r\\n  /// @param fallbackOracle The address of the fallbackOracle\\r\\n  function setFallbackOracle(address fallbackOracle) external onlyOwner {\\r\\n    _setFallbackOracle(fallbackOracle);\\r\\n  }\\r\\n\\r\\n  /// @notice Internal function to set the sources for each asset\\r\\n  /// @param assets The addresses of the assets\\r\\n  /// @param sources The address of the source of each asset\\r\\n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal {\\r\\n    require(assets.length == sources.length, \\u0027INCONSISTENT_PARAMS_LENGTH\\u0027);\\r\\n    for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n      assetsSources[assets[i]] = IChainlinkAggregator(sources[i]);\\r\\n      emit AssetSourceUpdated(assets[i], sources[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Internal function to set the fallbackOracle\\r\\n  /// @param fallbackOracle The address of the fallbackOracle\\r\\n  function _setFallbackOracle(address fallbackOracle) internal {\\r\\n    _fallbackOracle = IPriceOracleGetter(fallbackOracle);\\r\\n    emit FallbackOracleUpdated(fallbackOracle);\\r\\n  }\\r\\n\\r\\n  /// @notice Gets an asset price by address\\r\\n  /// @param asset The asset address\\r\\n  function getAssetPrice(address asset) public view override returns (uint256) {\\r\\n    IChainlinkAggregator source = assetsSources[asset];\\r\\n\\r\\n    if (asset == WETH) {\\r\\n      return 1 ether;\\r\\n    } else if (address(source) == address(0)) {\\r\\n      return _fallbackOracle.getAssetPrice(asset);\\r\\n    } else {\\r\\n      int256 price = IChainlinkAggregator(source).latestAnswer();\\r\\n      if (price \\u003e 0) {\\r\\n        return uint256(price);\\r\\n      } else {\\r\\n        return _fallbackOracle.getAssetPrice(asset);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Gets a list of prices from a list of assets addresses\\r\\n  /// @param assets The list of assets addresses\\r\\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) {\\r\\n    uint256[] memory prices = new uint256[](assets.length);\\r\\n    for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n      prices[i] = getAssetPrice(assets[i]);\\r\\n    }\\r\\n    return prices;\\r\\n  }\\r\\n\\r\\n  /// @notice Gets the address of the source for an asset address\\r\\n  /// @param asset The address of the asset\\r\\n  /// @return address The address of the source\\r\\n  function getSourceOfAsset(address asset) external view returns (address) {\\r\\n    return address(assetsSources[asset]);\\r\\n  }\\r\\n\\r\\n  /// @notice Gets the address of the fallback oracle\\r\\n  /// @return address The addres of the fallback oracle\\r\\n  function getFallbackOracle() external view returns (address) {\\r\\n    return address(_fallbackOracle);\\r\\n  }\\r\\n}\\r\\n\"},\"MarginPool.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\r\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\r\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\r\\nimport {Address} from \\\"./Address.sol\\\";\\r\\nimport {IMarginPoolAddressesProvider} from \\\"./IMarginPoolAddressesProvider.sol\\\";\\r\\nimport {IXToken} from \\\"./IXToken.sol\\\";\\r\\nimport {IVariableDebtToken} from \\\"./IVariableDebtToken.sol\\\";\\r\\nimport {IPriceOracleGetter} from \\\"./IPriceOracleGetter.sol\\\";\\r\\nimport {IMarginPool} from \\\"./IMarginPool.sol\\\";\\r\\nimport {VersionedInitializable} from \\\"./VersionedInitializable.sol\\\";\\r\\nimport {Helpers} from \\\"./Helpers.sol\\\";\\r\\nimport {Errors} from \\\"./Errors.sol\\\";\\r\\nimport {WadRayMath} from \\\"./WadRayMath.sol\\\";\\r\\nimport {PercentageMath} from \\\"./PercentageMath.sol\\\";\\r\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\r\\nimport {GenericLogic} from \\\"./GenericLogic.sol\\\";\\r\\nimport {ValidationLogic} from \\\"./ValidationLogic.sol\\\";\\r\\nimport {ReserveConfiguration} from \\\"./ReserveConfiguration.sol\\\";\\r\\nimport {UserConfiguration} from \\\"./UserConfiguration.sol\\\";\\r\\nimport {DataTypes} from \\\"./DataTypes.sol\\\";\\r\\nimport {MarginPoolStorage} from \\\"./MarginPoolStorage.sol\\\";\\r\\nimport {IUniswapV2Router02} from \\\"./IUniswapV2Router02.sol\\\";\\r\\n\\r\\ninterface ISwapMining {\\r\\n    function swapMint(\\r\\n        address account,\\r\\n        address input,\\r\\n        address output,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title MarginPool contract\\r\\n * @dev Main point of interaction with an Lever protocol\\u0027s market\\r\\n * - Users can:\\r\\n *   # Deposit\\r\\n *   # Withdraw\\r\\n *   # Borrow\\r\\n *   # Repay\\r\\n *   # Liquidate positions\\r\\n * - To be covered by a proxy contract, owned by the MarginPoolAddressesProvider of the specific market\\r\\n * - All admin functions are callable by the MarginPoolConfigurator contract defined also in the\\r\\n *   MarginPoolAddressesProvider\\r\\n * @author Lever\\r\\n **/\\r\\ncontract MarginPool is VersionedInitializable, IMarginPool, MarginPoolStorage {\\r\\n    using SafeMath for uint256;\\r\\n    using WadRayMath for uint256;\\r\\n    using PercentageMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    //main configuration parameters\\r\\n    uint256 public constant MAX_NUMBER_RESERVES = 128;\\r\\n    uint256 public constant MARGINPOOL_REVISION = 0x3;\\r\\n    IUniswapV2Router02 public uniswaper;\\r\\n    IUniswapV2Router02 public sushiSwaper;\\r\\n    address public wethAddress;\\r\\n    address public constant inchor = 0x11111112542D85B3EF69AE05771c2dCCff4fAa26;\\r\\n\\r\\n    modifier whenNotPaused() {\\r\\n        _whenNotPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyMarginPoolConfigurator() {\\r\\n        _onlyMarginPoolConfigurator();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _whenNotPaused() internal view {\\r\\n        require(!_paused, Errors.MP_IS_PAUSED);\\r\\n    }\\r\\n\\r\\n    function _onlyMarginPoolConfigurator() internal view {\\r\\n        require(\\r\\n            _addressesProvider.getMarginPoolConfigurator() == msg.sender,\\r\\n            Errors.MP_CALLER_NOT_MARGIN_POOL_CONFIGURATOR\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getRevision() internal pure override returns (uint256) {\\r\\n        return MARGINPOOL_REVISION;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function is invoked by the proxy contract when the MarginPool contract is added to the\\r\\n     * MarginPoolAddressesProvider of the market.\\r\\n     * - Caching the address of the MarginPoolAddressesProvider in order to reduce gas consumption\\r\\n     *   on subsequent operations\\r\\n     * @param provider The address of the MarginPoolAddressesProvider\\r\\n     **/\\r\\n    function initialize(\\r\\n        IMarginPoolAddressesProvider provider,\\r\\n        IUniswapV2Router02 _uniswaper,\\r\\n        IUniswapV2Router02 _sushiSwaper,\\r\\n        address _weth\\r\\n    ) public initializer {\\r\\n        _addressesProvider = provider;\\r\\n        uniswaper = _uniswaper;\\r\\n        sushiSwaper = _sushiSwaper;\\r\\n        wethAddress = _weth;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying xTokens.\\r\\n     * - E.g. User deposits 100 USDC and gets in return 100 xUSDC\\r\\n     * @param asset The address of the underlying asset to deposit\\r\\n     * @param amount The amount to be deposited\\r\\n     * @param onBehalfOf The address that will receive the xTokens, same as msg.sender if the user\\r\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of xTokens\\r\\n     *   is a different wallet\\r\\n     **/\\r\\n    function deposit(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf\\r\\n    ) external override whenNotPaused {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[asset];\\r\\n\\r\\n        ValidationLogic.validateDeposit(reserve, amount);\\r\\n\\r\\n        address xToken = reserve.xTokenAddress;\\r\\n\\r\\n        reserve.updateState();\\r\\n        reserve.updateInterestRates(asset, xToken, amount, 0);\\r\\n\\r\\n        IERC20(asset).safeTransferFrom(msg.sender, xToken, amount);\\r\\n        _depositLogic(asset, amount, onBehalfOf, xToken, reserve);\\r\\n    }\\r\\n\\r\\n    function reDeposit(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf\\r\\n    ) internal whenNotPaused {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[asset];\\r\\n\\r\\n        ValidationLogic.validateDeposit(reserve, amount);\\r\\n\\r\\n        address xToken = reserve.xTokenAddress;\\r\\n\\r\\n        reserve.updateState();\\r\\n        reserve.updateInterestRates(asset, xToken, amount, 0);\\r\\n\\r\\n        IERC20(asset).safeTransfer(xToken, amount);\\r\\n        _depositLogic(asset, amount, onBehalfOf, xToken, reserve);\\r\\n    }\\r\\n\\r\\n    function _depositLogic(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf,\\r\\n        address xToken,\\r\\n        DataTypes.ReserveData storage reserve\\r\\n    ) internal {\\r\\n        uint256 variableDebt = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\\r\\n        if (variableDebt \\u003e 0) {\\r\\n            uint256 paybackAmount = variableDebt;\\r\\n\\r\\n            if (amount \\u003c paybackAmount) {\\r\\n                paybackAmount = amount;\\r\\n            }\\r\\n\\r\\n            IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\\r\\n                onBehalfOf,\\r\\n                paybackAmount,\\r\\n                reserve.variableBorrowIndex\\r\\n            );\\r\\n\\r\\n            emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\\r\\n\\r\\n            if (variableDebt == paybackAmount) {\\r\\n                _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\\r\\n            }\\r\\n\\r\\n            if (amount \\u003e paybackAmount) {\\r\\n                bool isFirstDeposit =\\r\\n                    IXToken(xToken).mint(\\r\\n                        onBehalfOf,\\r\\n                        amount.sub(paybackAmount),\\r\\n                        reserve.liquidityIndex\\r\\n                    );\\r\\n\\r\\n                if (isFirstDeposit) {\\r\\n                    _usersConfig[onBehalfOf].setUsingAsCollateral(\\r\\n                        reserve.id,\\r\\n                        true\\r\\n                    );\\r\\n                    emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\\r\\n                }\\r\\n\\r\\n                emit Deposit(\\r\\n                    asset,\\r\\n                    msg.sender,\\r\\n                    onBehalfOf,\\r\\n                    amount.sub(paybackAmount)\\r\\n                );\\r\\n            }\\r\\n        } else {\\r\\n            bool isFirstDeposit =\\r\\n                IXToken(xToken).mint(\\r\\n                    onBehalfOf,\\r\\n                    amount,\\r\\n                    reserve.liquidityIndex\\r\\n                );\\r\\n\\r\\n            if (isFirstDeposit) {\\r\\n                _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\\r\\n                emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\\r\\n            }\\r\\n\\r\\n            emit Deposit(asset, msg.sender, onBehalfOf, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent xTokens owned\\r\\n     * E.g. User has 100 xUSDC, calls withdraw() and receives 100 USDC, burning the 100 xUSDC\\r\\n     * @param asset The address of the underlying asset to withdraw\\r\\n     * @param amount The underlying amount to be withdrawn\\r\\n     *   - Send the value type(uint256).max in order to withdraw the whole xToken balance\\r\\n     * @param to Address that will receive the underlying, same as msg.sender if the user\\r\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\r\\n     *   different wallet\\r\\n     * @return The final amount withdrawn\\r\\n     **/\\r\\n    function withdraw(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address to\\r\\n    ) external override whenNotPaused returns (uint256) {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[asset];\\r\\n\\r\\n        address xToken = reserve.xTokenAddress;\\r\\n\\r\\n        uint256 userBalance = IXToken(xToken).balanceOf(msg.sender);\\r\\n\\r\\n        uint256 amountToWithdraw = amount;\\r\\n\\r\\n        if (amount == type(uint256).max) {\\r\\n            amountToWithdraw = userBalance;\\r\\n        }\\r\\n\\r\\n        ValidationLogic.validateWithdraw(\\r\\n            asset,\\r\\n            amountToWithdraw,\\r\\n            userBalance,\\r\\n            _reserves,\\r\\n            _usersConfig[msg.sender],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        reserve.updateState();\\r\\n\\r\\n        reserve.updateInterestRates(asset, xToken, 0, amountToWithdraw);\\r\\n\\r\\n        if (amountToWithdraw == userBalance) {\\r\\n            _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\\r\\n            emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\\r\\n        }\\r\\n\\r\\n        IXToken(xToken).burn(\\r\\n            msg.sender,\\r\\n            to,\\r\\n            amountToWithdraw,\\r\\n            reserve.liquidityIndex\\r\\n        );\\r\\n\\r\\n        emit Withdraw(asset, msg.sender, to, amountToWithdraw);\\r\\n\\r\\n        return amountToWithdraw;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\r\\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\r\\n     * corresponding debt token ( VariableDebtToken)\\r\\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\r\\n     *   and 100 variable debt tokens\\r\\n     * @param asset The address of the underlying asset to borrow\\r\\n     * @param amount The amount to be borrowed\\r\\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\r\\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\r\\n     * if he has been given credit delegation allowance\\r\\n     **/\\r\\n    function borrow(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf\\r\\n    ) external override whenNotPaused {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[asset];\\r\\n\\r\\n        _executeBorrow(\\r\\n            ExecuteBorrowParams(\\r\\n                asset,\\r\\n                msg.sender,\\r\\n                onBehalfOf,\\r\\n                amount,\\r\\n                reserve.xTokenAddress,\\r\\n                true\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        bool isExactIn,\\r\\n        bool isUni\\r\\n    ) external override whenNotPaused {\\r\\n        _beforeSwap(path[0], amountIn);\\r\\n\\r\\n        IUniswapV2Router02 swaper = isUni ? uniswaper : sushiSwaper;\\r\\n        // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\\r\\n        IERC20(path[0]).safeApprove(address(swaper), 0);\\r\\n        IERC20(path[0]).safeApprove(address(swaper), amountIn);\\r\\n\\r\\n        uint256[] memory awards;\\r\\n        if (isExactIn) {\\r\\n            awards = swaper.swapExactTokensForTokens(\\r\\n                amountIn,\\r\\n                amountOut,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n        } else {\\r\\n            awards = swaper.swapTokensForExactTokens(\\r\\n                amountOut,\\r\\n                amountIn,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n\\r\\n        reDeposit(path[path.length - 1], awards[awards.length - 1], msg.sender);\\r\\n\\r\\n        if (amountIn \\u003e awards[0]) {\\r\\n            reDeposit(path[0], amountIn.sub(awards[0]), msg.sender);\\r\\n        }\\r\\n\\r\\n        ValidationLogic.validateSwap(\\r\\n            msg.sender,\\r\\n            _reserves,\\r\\n            _usersConfig[msg.sender],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n        ISwapMining(_addressesProvider.getSwapMiner()).swapMint(\\r\\n            msg.sender,\\r\\n            path[0],\\r\\n            path[path.length - 1],\\r\\n            awards[awards.length - 1]\\r\\n        );\\r\\n        \\r\\n        emit Swap(\\r\\n            msg.sender,\\r\\n            path[0],\\r\\n            path[path.length - 1],\\r\\n            awards[0],\\r\\n            awards[awards.length - 1]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapTokensForClosePosition(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        bool isExactIn,\\r\\n        bool isUni\\r\\n    ) external override whenNotPaused {\\r\\n        _beforeClose(path[0], amountIn);\\r\\n\\r\\n        IUniswapV2Router02 swaper = isUni ? uniswaper : sushiSwaper;\\r\\n\\r\\n        // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\\r\\n        IERC20(path[0]).safeApprove(address(swaper), 0);\\r\\n        IERC20(path[0]).safeApprove(address(swaper), amountIn);\\r\\n\\r\\n        uint256[] memory awards;\\r\\n        if (isExactIn) {\\r\\n            awards = swaper.swapExactTokensForTokens(\\r\\n                amountIn,\\r\\n                amountOut,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n        } else {\\r\\n            awards = swaper.swapTokensForExactTokens(\\r\\n                amountOut,\\r\\n                amountIn,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n\\r\\n        reDeposit(path[path.length - 1], awards[awards.length - 1], msg.sender);\\r\\n\\r\\n        if (amountIn \\u003e awards[0]) {\\r\\n            reDeposit(path[0], amountIn.sub(awards[0]), msg.sender);\\r\\n        }\\r\\n\\r\\n        ValidationLogic.validateSwap(\\r\\n            msg.sender,\\r\\n            _reserves,\\r\\n            _usersConfig[msg.sender],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        ISwapMining(_addressesProvider.getSwapMiner()).swapMint(\\r\\n            msg.sender,\\r\\n            path[0],\\r\\n            path[path.length - 1],\\r\\n            awards[awards.length - 1]\\r\\n        );\\r\\n        emit Swap(\\r\\n            msg.sender,\\r\\n            path[0],\\r\\n            path[path.length - 1],\\r\\n            awards[0],\\r\\n            awards[awards.length - 1]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapWithAggregation(\\r\\n        address _reserve,\\r\\n        uint256 amount,\\r\\n        address _reserveTo,\\r\\n        bytes memory codes,\\r\\n        uint256 gas,\\r\\n        uint8 swapType\\r\\n    ) external {\\r\\n        _beforeSwap(_reserve, amount);\\r\\n\\r\\n        IERC20(_reserve).safeApprove(inchor, 0);\\r\\n        IERC20(_reserve).safeApprove(inchor, amount);\\r\\n\\r\\n        (bool success, bytes memory result) = inchor.call{gas: gas}(codes);\\r\\n\\r\\n        require(success, \\\"swap failed\\\");\\r\\n\\r\\n        uint256 award;\\r\\n\\r\\n        if (swapType == 1) {\\r\\n            award = abi.decode(result, (uint256));\\r\\n        }\\r\\n\\r\\n        if (swapType == 2) {\\r\\n            (award, ) = abi.decode(result, (uint256, uint256));\\r\\n        }\\r\\n\\r\\n        if (swapType == 3) {\\r\\n            (award, , ) = abi.decode(result, (uint256, uint256, uint256));\\r\\n        }\\r\\n\\r\\n        reDeposit(_reserveTo, award, msg.sender);\\r\\n\\r\\n        ValidationLogic.validateSwap(\\r\\n            msg.sender,\\r\\n            _reserves,\\r\\n            _usersConfig[msg.sender],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        ISwapMining(_addressesProvider.getSwapMiner()).swapMint(\\r\\n            msg.sender,\\r\\n            _reserve,\\r\\n            _reserveTo,\\r\\n            award\\r\\n        );\\r\\n        emit Swap(msg.sender, _reserve, _reserveTo, amount, award);\\r\\n    }\\r\\n\\r\\n    function closeWithAggregation(\\r\\n        address _reserve,\\r\\n        uint256 amountIn,\\r\\n        address _reserveTo,\\r\\n        bytes memory codes,\\r\\n        uint256 gas,\\r\\n        uint8 swapType\\r\\n    ) external {\\r\\n        _beforeClose(_reserve, amountIn);\\r\\n\\r\\n        IERC20(_reserve).safeApprove(inchor, 0);\\r\\n        IERC20(_reserve).safeApprove(inchor, amountIn);\\r\\n\\r\\n        (bool success, bytes memory result) = inchor.call{gas: gas}(codes);\\r\\n\\r\\n        require(success, \\\"swap failed\\\");\\r\\n\\r\\n        uint256 award;\\r\\n\\r\\n        if (swapType == 1) {\\r\\n            award = abi.decode(result, (uint256));\\r\\n        }\\r\\n\\r\\n        if (swapType == 2) {\\r\\n            (award, ) = abi.decode(result, (uint256, uint256));\\r\\n        }\\r\\n\\r\\n        if (swapType == 3) {\\r\\n            (award, , ) = abi.decode(result, (uint256, uint256, uint256));\\r\\n        }\\r\\n\\r\\n        reDeposit(_reserveTo, award, msg.sender);\\r\\n\\r\\n        ValidationLogic.validateSwap(\\r\\n            msg.sender,\\r\\n            _reserves,\\r\\n            _usersConfig[msg.sender],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        ISwapMining(_addressesProvider.getSwapMiner()).swapMint(\\r\\n            msg.sender,\\r\\n            _reserve,\\r\\n            _reserveTo,\\r\\n            award\\r\\n        );\\r\\n        emit Swap(msg.sender, _reserve, _reserveTo, amountIn, award);\\r\\n    }\\r\\n\\r\\n    function _beforeClose(address _reserve, uint256 amountIn) private {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[_reserve];\\r\\n        ValidationLogic.validateDeposit(reserve, amountIn);\\r\\n        reserve.updateState();\\r\\n\\r\\n        uint256 userBalance =\\r\\n            IXToken(reserve.xTokenAddress).balanceOf(msg.sender);\\r\\n\\r\\n        reserve.updateInterestRates(\\r\\n            _reserve,\\r\\n            reserve.xTokenAddress,\\r\\n            0,\\r\\n            amountIn\\r\\n        );\\r\\n\\r\\n        IXToken(reserve.xTokenAddress).burn(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amountIn,\\r\\n            reserve.liquidityIndex\\r\\n        );\\r\\n\\r\\n        if (amountIn == userBalance) {\\r\\n            _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\\r\\n            emit ReserveUsedAsCollateralDisabled(_reserve, msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeSwap(address _reserve, uint256 amountIn) private {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[_reserve];\\r\\n        ValidationLogic.validateDeposit(reserve, amountIn);\\r\\n\\r\\n        DataTypes.UserConfigurationMap storage userConfig =\\r\\n            _usersConfig[msg.sender];\\r\\n\\r\\n        reserve.updateState();\\r\\n        bool isFirstBorrowing = false;\\r\\n        isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress)\\r\\n            .mint(\\r\\n            msg.sender,\\r\\n            msg.sender,\\r\\n            amountIn,\\r\\n            reserve.variableBorrowIndex\\r\\n        );\\r\\n        emit Borrow(\\r\\n            _reserve,\\r\\n            msg.sender,\\r\\n            msg.sender,\\r\\n            amountIn,\\r\\n            reserve.currentVariableBorrowRate\\r\\n        );\\r\\n\\r\\n        if (isFirstBorrowing) {\\r\\n            userConfig.setBorrowing(reserve.id, true);\\r\\n        }\\r\\n\\r\\n        reserve.updateInterestRates(\\r\\n            _reserve,\\r\\n            reserve.xTokenAddress,\\r\\n            0,\\r\\n            amountIn\\r\\n        );\\r\\n\\r\\n        IXToken(reserve.xTokenAddress).transferUnderlyingTo(\\r\\n            address(this),\\r\\n            amountIn\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\r\\n     * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the `onBehalfOf` address\\r\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\r\\n     * @param amount The amount to repay\\r\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\r\\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\r\\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\r\\n     * other borrower whose debt should be removed\\r\\n     * @return The final amount repaid\\r\\n     **/\\r\\n    function repay(\\r\\n        address asset,\\r\\n        uint256 amount,\\r\\n        address onBehalfOf\\r\\n    ) external override whenNotPaused returns (uint256) {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[asset];\\r\\n\\r\\n        uint256 variableDebt = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\\r\\n        address xToken = reserve.xTokenAddress;\\r\\n        uint256 userBalance = IERC20(xToken).balanceOf(msg.sender);\\r\\n\\r\\n        ValidationLogic.validateRepay(\\r\\n            reserve,\\r\\n            amount,\\r\\n            onBehalfOf,\\r\\n            variableDebt,\\r\\n            userBalance\\r\\n        );\\r\\n\\r\\n        uint256 paybackAmount = variableDebt;\\r\\n\\r\\n        if (amount \\u003c paybackAmount) {\\r\\n            paybackAmount = amount;\\r\\n        }\\r\\n\\r\\n        reserve.updateState();\\r\\n\\r\\n        IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\\r\\n            onBehalfOf,\\r\\n            paybackAmount,\\r\\n            reserve.variableBorrowIndex\\r\\n        );\\r\\n\\r\\n        reserve.updateInterestRates(asset, xToken, 0, 0);\\r\\n\\r\\n        if (variableDebt.sub(paybackAmount) == 0) {\\r\\n            _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\\r\\n        }\\r\\n\\r\\n        if (paybackAmount == userBalance) {\\r\\n            _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\\r\\n            emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\\r\\n        }\\r\\n\\r\\n        IXToken(xToken).burn(\\r\\n            msg.sender,\\r\\n            xToken,\\r\\n            paybackAmount,\\r\\n            reserve.liquidityIndex\\r\\n        );\\r\\n\\r\\n        emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\\r\\n\\r\\n        return paybackAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\r\\n     * @param asset The address of the underlying asset deposited\\r\\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\r\\n     **/\\r\\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\\r\\n        external\\r\\n        override\\r\\n        whenNotPaused\\r\\n    {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[asset];\\r\\n\\r\\n        ValidationLogic.validateSetUseReserveAsCollateral(\\r\\n            reserve,\\r\\n            asset,\\r\\n            useAsCollateral,\\r\\n            _reserves,\\r\\n            _usersConfig[msg.sender],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        _usersConfig[msg.sender].setUsingAsCollateral(\\r\\n            reserve.id,\\r\\n            useAsCollateral\\r\\n        );\\r\\n\\r\\n        if (useAsCollateral) {\\r\\n            emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\\r\\n        } else {\\r\\n            emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    struct LiquidationCallLocalVars {\\r\\n        uint256 variableDebt;\\r\\n        uint256 userBalance;\\r\\n        uint256 healthFactor;\\r\\n        uint256 maxCollateralToLiquidate;\\r\\n        uint256 collateralToSell;\\r\\n        uint256 liquidatorPreviousXTokenBalance;\\r\\n    }\\r\\n\\r\\n       /**\\r\\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\r\\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\r\\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\r\\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n     * @param user The address of the borrower getting liquidated\\r\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n     **/\\r\\n    function liquidationCall(\\r\\n        address collateralAsset,\\r\\n        address debtAsset,\\r\\n        address user,\\r\\n        uint256 debtToCover\\r\\n    ) external override whenNotPaused {\\r\\n        LiquidationCallLocalVars memory vars;\\r\\n        DataTypes.ReserveData storage collateralReserve =\\r\\n            _reserves[collateralAsset];\\r\\n        DataTypes.ReserveData storage debtReserve = _reserves[debtAsset];\\r\\n        DataTypes.UserConfigurationMap storage userConfig = _usersConfig[user];\\r\\n\\r\\n        vars.variableDebt = Helpers.getUserCurrentDebt(user, debtReserve).div(\\r\\n            2\\r\\n        );\\r\\n\\r\\n        (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\\r\\n            user,\\r\\n            _reserves,\\r\\n            _usersConfig[user],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        ValidationLogic.validateLiquidation(\\r\\n            collateralReserve,\\r\\n            debtReserve,\\r\\n            userConfig,\\r\\n            vars.healthFactor,\\r\\n            vars.variableDebt\\r\\n        );\\r\\n\\r\\n        vars.variableDebt = vars.variableDebt \\u003e debtToCover\\r\\n            ? debtToCover\\r\\n            : vars.variableDebt;\\r\\n\\r\\n        vars.userBalance = IERC20(collateralReserve.xTokenAddress).balanceOf(\\r\\n            user\\r\\n        );\\r\\n\\r\\n        (vars.maxCollateralToLiquidate, vars.collateralToSell) = GenericLogic\\r\\n            .calculateAvailableCollateralToLiquidate(\\r\\n            collateralReserve,\\r\\n            debtReserve,\\r\\n            collateralAsset,\\r\\n            debtAsset,\\r\\n            vars.variableDebt,\\r\\n            vars.userBalance,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        collateralReserve.updateState();\\r\\n\\r\\n        vars.liquidatorPreviousXTokenBalance = IERC20(\\r\\n            collateralReserve\\r\\n                .xTokenAddress\\r\\n        )\\r\\n            .balanceOf(msg.sender);\\r\\n\\r\\n        IXToken(collateralReserve.xTokenAddress).transferOnLiquidation(\\r\\n            user,\\r\\n            msg.sender,\\r\\n            (vars.maxCollateralToLiquidate.sub(vars.collateralToSell))\\r\\n        );\\r\\n\\r\\n        if (vars.liquidatorPreviousXTokenBalance == 0) {\\r\\n            DataTypes.UserConfigurationMap storage liquidatorConfig =\\r\\n                _usersConfig[msg.sender];\\r\\n            liquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\\r\\n            emit ReserveUsedAsCollateralEnabled(collateralAsset, msg.sender);\\r\\n        }\\r\\n\\r\\n        if (vars.maxCollateralToLiquidate == vars.userBalance) {\\r\\n              userConfig.setUsingAsCollateral(collateralReserve.id, false);\\r\\n              emit ReserveUsedAsCollateralDisabled(collateralAsset, user);\\r\\n        }\\r\\n\\r\\n        if(collateralAsset == debtAsset) {\\r\\n          IVariableDebtToken(collateralReserve.variableDebtTokenAddress).burn(\\r\\n              user,\\r\\n              vars.collateralToSell,\\r\\n              collateralReserve.variableBorrowIndex\\r\\n          );\\r\\n\\r\\n          collateralReserve.updateInterestRates(collateralAsset, collateralReserve.xTokenAddress, 0, 0);\\r\\n\\r\\n          IXToken(collateralReserve.xTokenAddress).burn(\\r\\n              user,\\r\\n              collateralReserve.xTokenAddress,\\r\\n              vars.collateralToSell,\\r\\n              collateralReserve.liquidityIndex\\r\\n          );\\r\\n          \\r\\n          emit LiquidationCall(\\r\\n              collateralAsset,\\r\\n              debtAsset,\\r\\n              user,\\r\\n              vars.collateralToSell,\\r\\n              vars.collateralToSell,\\r\\n              msg.sender\\r\\n          );\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        collateralReserve.updateInterestRates(\\r\\n            collateralAsset,\\r\\n            collateralReserve.xTokenAddress,\\r\\n            0,\\r\\n            vars.collateralToSell\\r\\n        );\\r\\n\\r\\n        IXToken(collateralReserve.xTokenAddress).burn(\\r\\n            user,\\r\\n            address(this),\\r\\n            vars.collateralToSell,\\r\\n            collateralReserve.liquidityIndex\\r\\n        );\\r\\n\\r\\n        IERC20(collateralAsset).safeApprove(address(uniswaper), 0);\\r\\n        IERC20(collateralAsset).safeApprove(\\r\\n            address(uniswaper),\\r\\n            vars.collateralToSell\\r\\n        );\\r\\n\\r\\n        address[] memory path;\\r\\n        if (collateralAsset != wethAddress \\u0026\\u0026 debtAsset != wethAddress) {\\r\\n            path = new address[](3);\\r\\n            path[0] = collateralAsset;\\r\\n            path[1] = wethAddress;\\r\\n            path[2] = debtAsset;\\r\\n        } else {\\r\\n            path = new address[](2);\\r\\n            path[0] = collateralAsset;\\r\\n            path[1] = debtAsset;\\r\\n        }\\r\\n\\r\\n        uint256[] memory awards =\\r\\n            uniswaper.swapExactTokensForTokens(\\r\\n                vars.collateralToSell,\\r\\n                vars.variableDebt.mul(97).div(100),\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n\\r\\n        reDeposit(debtAsset, awards[awards.length - 1], user);\\r\\n\\r\\n        emit LiquidationCall(\\r\\n            collateralAsset,\\r\\n            debtAsset,\\r\\n            user,\\r\\n            awards[awards.length - 1],\\r\\n            vars.collateralToSell,\\r\\n            msg.sender\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the state and configuration of the reserve\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @return The state of the reserve\\r\\n     **/\\r\\n    function getReserveData(address asset)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (DataTypes.ReserveData memory)\\r\\n    {\\r\\n        return _reserves[asset];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the user account data across all the reserves\\r\\n     * @param user The address of the user\\r\\n     * @return totalCollateralETH the total collateral in ETH of the user\\r\\n     * @return totalDebtETH the total debt in ETH of the user\\r\\n     * @return availableBorrowsETH the borrowing power left of the user\\r\\n     * @return currentLiquidationThreshold the liquidation threshold of the user\\r\\n     * @return ltv the loan to value of the user\\r\\n     * @return healthFactor the current health factor of the user\\r\\n     **/\\r\\n    function getUserAccountData(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            uint256 totalCollateralETH,\\r\\n            uint256 totalDebtETH,\\r\\n            uint256 availableBorrowsETH,\\r\\n            uint256 currentLiquidationThreshold,\\r\\n            uint256 ltv,\\r\\n            uint256 healthFactor\\r\\n        )\\r\\n    {\\r\\n        (\\r\\n            totalCollateralETH,\\r\\n            totalDebtETH,\\r\\n            ltv,\\r\\n            currentLiquidationThreshold,\\r\\n            healthFactor\\r\\n        ) = GenericLogic.calculateUserAccountData(\\r\\n            user,\\r\\n            _reserves,\\r\\n            _usersConfig[user],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(\\r\\n            totalCollateralETH,\\r\\n            totalDebtETH,\\r\\n            ltv\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the configuration of the reserve\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @return The configuration of the reserve\\r\\n     **/\\r\\n    function getConfiguration(address asset)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (DataTypes.ReserveConfigurationMap memory)\\r\\n    {\\r\\n        return _reserves[asset].configuration;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the configuration of the user across all the reserves\\r\\n     * @param user The user address\\r\\n     * @return The configuration of the user\\r\\n     **/\\r\\n    function getUserConfiguration(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (DataTypes.UserConfigurationMap memory)\\r\\n    {\\r\\n        return _usersConfig[user];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the normalized income per unit of asset\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @return The reserve\\u0027s normalized income\\r\\n     */\\r\\n    function getReserveNormalizedIncome(address asset)\\r\\n        external\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _reserves[asset].getNormalizedIncome();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the normalized variable debt per unit of asset\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @return The reserve normalized variable debt\\r\\n     */\\r\\n    function getReserveNormalizedVariableDebt(address asset)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _reserves[asset].getNormalizedDebt();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the MarginPool is paused\\r\\n     */\\r\\n    function paused() external view override returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the list of the initialized reserves\\r\\n     **/\\r\\n    function getReservesList()\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        address[] memory _activeReserves = new address[](_reservesCount);\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c _reservesCount; i++) {\\r\\n            _activeReserves[i] = _reservesList[i];\\r\\n        }\\r\\n        return _activeReserves;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the cached MarginPoolAddressesProvider connected to this contract\\r\\n     **/\\r\\n    function getAddressesProvider()\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (IMarginPoolAddressesProvider)\\r\\n    {\\r\\n        return _addressesProvider;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates and finalizes an xToken transfer\\r\\n     * - Only callable by the overlying xToken of the `asset`\\r\\n     * @param asset The address of the underlying asset of the xToken\\r\\n     * @param from The user from which the xTokens are transferred\\r\\n     * @param to The user receiving the xTokens\\r\\n     * @param amount The amount being transferred/withdrawn\\r\\n     * @param balanceFromBefore The xToken balance of the `from` user before the transfer\\r\\n     * @param balanceToBefore The xToken balance of the `to` user before the transfer\\r\\n     */\\r\\n    function finalizeTransfer(\\r\\n        address asset,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 balanceFromBefore,\\r\\n        uint256 balanceToBefore\\r\\n    ) external override whenNotPaused {\\r\\n        require(\\r\\n            msg.sender == _reserves[asset].xTokenAddress,\\r\\n            Errors.MP_CALLER_MUST_BE_AN_XTOKEN\\r\\n        );\\r\\n\\r\\n        ValidationLogic.validateTransfer(\\r\\n            from,\\r\\n            _reserves,\\r\\n            _usersConfig[from],\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            _addressesProvider.getPriceOracle()\\r\\n        );\\r\\n\\r\\n        uint256 reserveId = _reserves[asset].id;\\r\\n\\r\\n        if (from != to) {\\r\\n            if (balanceFromBefore.sub(amount) == 0) {\\r\\n                DataTypes.UserConfigurationMap storage fromConfig =\\r\\n                    _usersConfig[from];\\r\\n                fromConfig.setUsingAsCollateral(reserveId, false);\\r\\n                emit ReserveUsedAsCollateralDisabled(asset, from);\\r\\n            }\\r\\n\\r\\n            if (balanceToBefore == 0 \\u0026\\u0026 amount != 0) {\\r\\n                DataTypes.UserConfigurationMap storage toConfig =\\r\\n                    _usersConfig[to];\\r\\n                toConfig.setUsingAsCollateral(reserveId, true);\\r\\n                emit ReserveUsedAsCollateralEnabled(asset, to);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes a reserve, activating it, assigning an xToken and debt tokens and an\\r\\n     * interest rate strategy\\r\\n     * - Only callable by the MarginPoolConfigurator contract\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @param xTokenAddress The address of the xToken that will be assigned to the reserve\\r\\n     * @param xTokenAddress The address of the VariableDebtToken that will be assigned to the reserve\\r\\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\\r\\n     **/\\r\\n    function initReserve(\\r\\n        address asset,\\r\\n        address xTokenAddress,\\r\\n        address variableDebtAddress,\\r\\n        address interestRateStrategyAddress\\r\\n    ) external override onlyMarginPoolConfigurator {\\r\\n        require(Address.isContract(asset), Errors.MP_NOT_CONTRACT);\\r\\n        _reserves[asset].init(\\r\\n            xTokenAddress,\\r\\n            variableDebtAddress,\\r\\n            interestRateStrategyAddress\\r\\n        );\\r\\n        _addReserveToList(asset);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates the address of the interest rate strategy contract\\r\\n     * - Only callable by the MarginPoolConfigurator contract\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @param rateStrategyAddress The address of the interest rate strategy contract\\r\\n     **/\\r\\n    function setReserveInterestRateStrategyAddress(\\r\\n        address asset,\\r\\n        address rateStrategyAddress\\r\\n    ) external override onlyMarginPoolConfigurator {\\r\\n        _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the configuration bitmap of the reserve as a whole\\r\\n     * - Only callable by the MarginPoolConfigurator contract\\r\\n     * @param asset The address of the underlying asset of the reserve\\r\\n     * @param configuration The new configuration bitmap\\r\\n     **/\\r\\n    function setConfiguration(address asset, uint256 configuration)\\r\\n        external\\r\\n        override\\r\\n        onlyMarginPoolConfigurator\\r\\n    {\\r\\n        _reserves[asset].configuration.data = configuration;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set the _pause state of a reserve\\r\\n     * - Only callable by the MarginPoolConfigurator contract\\r\\n     * @param val `true` to pause the reserve, `false` to un-pause it\\r\\n     */\\r\\n    function setPause(bool val) external override onlyMarginPoolConfigurator {\\r\\n        _paused = val;\\r\\n        if (_paused) {\\r\\n            emit Paused();\\r\\n        } else {\\r\\n            emit Unpaused();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    struct ExecuteBorrowParams {\\r\\n        address asset;\\r\\n        address user;\\r\\n        address onBehalfOf;\\r\\n        uint256 amount;\\r\\n        address xTokenAddress;\\r\\n        bool releaseUnderlying;\\r\\n    }\\r\\n\\r\\n    function _executeBorrow(ExecuteBorrowParams memory vars) internal {\\r\\n        DataTypes.ReserveData storage reserve = _reserves[vars.asset];\\r\\n        DataTypes.UserConfigurationMap storage userConfig =\\r\\n            _usersConfig[vars.onBehalfOf];\\r\\n\\r\\n        address oracle = _addressesProvider.getPriceOracle();\\r\\n\\r\\n        uint256 amountInETH =\\r\\n            IPriceOracleGetter(oracle)\\r\\n                .getAssetPrice(vars.asset)\\r\\n                .mul(vars.amount)\\r\\n                .div(10**reserve.configuration.getDecimals());\\r\\n\\r\\n        ValidationLogic.validateBorrow(\\r\\n            reserve,\\r\\n            vars.onBehalfOf,\\r\\n            vars.amount,\\r\\n            amountInETH,\\r\\n            _reserves,\\r\\n            userConfig,\\r\\n            _reservesList,\\r\\n            _reservesCount,\\r\\n            oracle\\r\\n        );\\r\\n\\r\\n        reserve.updateState();\\r\\n\\r\\n        bool isFirstBorrowing = false;\\r\\n        isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress)\\r\\n            .mint(\\r\\n            vars.user,\\r\\n            vars.onBehalfOf,\\r\\n            vars.amount,\\r\\n            reserve.variableBorrowIndex\\r\\n        );\\r\\n\\r\\n        if (isFirstBorrowing) {\\r\\n            userConfig.setBorrowing(reserve.id, true);\\r\\n        }\\r\\n\\r\\n        reserve.updateInterestRates(\\r\\n            vars.asset,\\r\\n            vars.xTokenAddress,\\r\\n            0,\\r\\n            vars.releaseUnderlying ? vars.amount : 0\\r\\n        );\\r\\n\\r\\n        if (vars.releaseUnderlying) {\\r\\n            IXToken(vars.xTokenAddress).transferUnderlyingTo(\\r\\n                vars.user,\\r\\n                vars.amount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit Borrow(\\r\\n            vars.asset,\\r\\n            vars.user,\\r\\n            vars.onBehalfOf,\\r\\n            vars.amount,\\r\\n            reserve.currentVariableBorrowRate\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _addReserveToList(address asset) internal {\\r\\n        uint256 reservesCount = _reservesCount;\\r\\n\\r\\n        require(\\r\\n            reservesCount \\u003c MAX_NUMBER_RESERVES,\\r\\n            Errors.MP_NO_MORE_RESERVES_ALLOWED\\r\\n        );\\r\\n\\r\\n        bool reserveAlreadyAdded =\\r\\n            _reserves[asset].id != 0 || _reservesList[0] == asset;\\r\\n\\r\\n        if (!reserveAlreadyAdded) {\\r\\n            _reserves[asset].id = uint8(reservesCount);\\r\\n            _reservesList[reservesCount] = asset;\\r\\n\\r\\n            _reservesCount = reservesCount + 1;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"MarginPoolAddressesProvider.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {Ownable} from \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\n\\r\\n// Prettier ignore to prevent buidler flatter bug\\r\\n// prettier-ignore\\r\\nimport {InitializableImmutableAdminUpgradeabilityProxy} from \\u0027./InitializableImmutableAdminUpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\nimport {IMarginPoolAddressesProvider} from \\u0027./IMarginPoolAddressesProvider.sol\\u0027;\\r\\n// import \\u0027./BaseUpgradeabilityProxy.sol\\u0027;\\r\\n/**\\r\\n * @title MarginPoolAddressesProvider contract\\r\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\r\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\r\\n * - Owned by the Lever Governance\\r\\n * @author Lever\\r\\n **/\\r\\ncontract MarginPoolAddressesProvider is Ownable, IMarginPoolAddressesProvider {\\r\\n  mapping(bytes32 =\\u003e address) private _addresses;\\r\\n\\r\\n  bytes32 private constant MARGIN_POOL = \\u0027MARGIN_POOL\\u0027;\\r\\n  bytes32 private constant MARGIN_POOL_CONFIGURATOR = \\u0027MARGIN_POOL_CONFIGURATOR\\u0027;\\r\\n  bytes32 private constant POOL_ADMIN = \\u0027POOL_ADMIN\\u0027;\\r\\n  bytes32 private constant EMERGENCY_ADMIN = \\u0027EMERGENCY_ADMIN\\u0027;\\r\\n  bytes32 private constant PRICE_ORACLE = \\u0027PRICE_ORACLE\\u0027;\\r\\n  bytes32 private constant LENDING_RATE_ORACLE = \\u0027LENDING_RATE_ORACLE\\u0027;\\r\\n  bytes32 private constant LEVER_TOKEN = \\u0027LEVER_TOKEN\\u0027;\\r\\n  bytes32 private constant TREASURY_ADDRESS = \\u0027TREASURY_ADDRESS\\u0027;\\r\\n  bytes32 private constant REWARDS_DISTRIBUTION = \\u0027REWARDS_DISTRIBUTION\\u0027;\\r\\n  bytes32 private constant SWAP_MINER = \\u0027SWAP_MINER\\u0027;\\r\\n  bytes32 private constant ORDER_BOOK = \\u0027ORDER_BOOK\\u0027;\\r\\n\\r\\n  constructor() public {\\r\\n  }\\r\\n  \\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev General function to update the implementation of a proxy registered with\\r\\n   * certain `id`. If there is no proxy registered, it will instantiate one and\\r\\n   * set as implementation the `implementationAddress`\\r\\n   * IMPORTANT Use this function carefully, only for ids that don\\u0027t have an explicit\\r\\n   * setter function, in order to avoid unexpected consequences\\r\\n   * @param id The id\\r\\n   * @param implementationAddress The address of the new implementation\\r\\n   */\\r\\n  function setAddressAsProxy(bytes32 id, address implementationAddress)\\r\\n    external\\r\\n    override\\r\\n    onlyOwner\\r\\n  {\\r\\n    _updateImpl(id, implementationAddress);\\r\\n    emit AddressSet(id, implementationAddress, true);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets an address for an id replacing the address saved in the addresses map\\r\\n   * IMPORTANT Use this function carefully, as it will do a hard replacement\\r\\n   * @param id The id\\r\\n   * @param newAddress The address to set\\r\\n   */\\r\\n  function setAddress(bytes32 id, address newAddress) external override onlyOwner {\\r\\n    _addresses[id] = newAddress;\\r\\n    emit AddressSet(id, newAddress, false);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns an address by id\\r\\n   * @return The address\\r\\n   */\\r\\n  function getAddress(bytes32 id) public view override returns (address) {\\r\\n    return _addresses[id];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the address of the MarginPool proxy\\r\\n   * @return The MarginPool proxy address\\r\\n   **/\\r\\n  function getMarginPool() external view override returns (address) {\\r\\n    return getAddress(MARGIN_POOL);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the implementation of the MarginPool, or creates the proxy\\r\\n   * setting the new `pool` implementation on the first time calling it\\r\\n   * @param pool The new MarginPool implementation\\r\\n   **/\\r\\n  function setMarginPoolImpl(address pool,address UniswapRouter, address SushiswapRouter,address _weth) external override onlyOwner {\\r\\n    _updatePoolImpl(MARGIN_POOL, pool, UniswapRouter,SushiswapRouter, _weth);\\r\\n    emit MarginPoolUpdated(pool);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the address of the MarginPoolConfigurator proxy\\r\\n   * @return The MarginPoolConfigurator proxy address\\r\\n   **/\\r\\n  function getMarginPoolConfigurator() external view override returns (address) {\\r\\n    return getAddress(MARGIN_POOL_CONFIGURATOR);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the implementation of the MarginPoolConfigurator, or creates the proxy\\r\\n   * setting the new `configurator` implementation on the first time calling it\\r\\n   * @param configurator The new MarginPoolConfigurator implementation\\r\\n   **/\\r\\n  function setMarginPoolConfiguratorImpl(address configurator) external override onlyOwner {\\r\\n    _updateImpl(MARGIN_POOL_CONFIGURATOR, configurator);\\r\\n    emit MarginPoolConfiguratorUpdated(configurator);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev The functions below are getters/setters of addresses that are outside the context\\r\\n   * of the protocol hence the upgradable proxy pattern is not used\\r\\n   **/\\r\\n\\r\\n  function getPoolAdmin() external view override returns (address) {\\r\\n    return getAddress(POOL_ADMIN);\\r\\n  }\\r\\n\\r\\n  function setPoolAdmin(address admin) external override onlyOwner {\\r\\n    _addresses[POOL_ADMIN] = admin;\\r\\n    emit ConfigurationAdminUpdated(admin);\\r\\n  }\\r\\n\\r\\n  function getEmergencyAdmin() external view override returns (address) {\\r\\n    return getAddress(EMERGENCY_ADMIN);\\r\\n  }\\r\\n\\r\\n  function setEmergencyAdmin(address emergencyAdmin) external override onlyOwner {\\r\\n    _addresses[EMERGENCY_ADMIN] = emergencyAdmin;\\r\\n    emit EmergencyAdminUpdated(emergencyAdmin);\\r\\n  }\\r\\n\\r\\n  function getPriceOracle() external view override returns (address) {\\r\\n    return getAddress(PRICE_ORACLE);\\r\\n  }\\r\\n\\r\\n  function setPriceOracle(address priceOracle) external override onlyOwner {\\r\\n    _addresses[PRICE_ORACLE] = priceOracle;\\r\\n    emit PriceOracleUpdated(priceOracle);\\r\\n  }\\r\\n\\r\\n\\r\\n  function getLeverToken() external view override returns (address) {\\r\\n    return getAddress(LEVER_TOKEN);\\r\\n  }\\r\\n\\r\\n  function setLeverToken(address lever) external override onlyOwner {\\r\\n    _addresses[LEVER_TOKEN] = lever;\\r\\n    emit LeverTokenUpdated(lever);\\r\\n  }\\r\\n  \\r\\n  function getTreasuryAddress() external view override returns (address) {\\r\\n    return getAddress(TREASURY_ADDRESS);\\r\\n  }\\r\\n\\r\\n  function setTreasuryAddress(address treasuryAddress) external override onlyOwner {\\r\\n    _addresses[TREASURY_ADDRESS] = treasuryAddress;\\r\\n    emit TreasuryAddressUpdated(treasuryAddress);\\r\\n  }\\r\\n  \\r\\n  function getRewardsDistribution() external view override returns (address) {\\r\\n    return getAddress(REWARDS_DISTRIBUTION);\\r\\n  }\\r\\n\\r\\n  function setRewardsDistribution(address rewardsDistribution) external override onlyOwner {\\r\\n    _addresses[REWARDS_DISTRIBUTION] = rewardsDistribution;\\r\\n    emit RewardsDistributionUpdated(rewardsDistribution);\\r\\n  }\\r\\n\\r\\n    /**\\r\\n   * @dev Returns the address of the OrderBook proxy\\r\\n   * @return The OrderBook proxy address\\r\\n   **/\\r\\n  function getOrderBook() external view override returns (address) {\\r\\n    return getAddress(ORDER_BOOK);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the implementation of the OrderBook, or creates the proxy\\r\\n   * setting the new `pool` implementation on the first time calling it\\r\\n   * @param orderBook The new OrderBook implementation\\r\\n   **/\\r\\n  function setOrderBookImpl(address orderBook, address UniswapRouter, address _weth) external override onlyOwner {\\r\\n    _updateImpl(ORDER_BOOK, orderBook, UniswapRouter, _weth);\\r\\n    emit OrderBookUpdated(orderBook);\\r\\n  }\\r\\n    /**\\r\\n   * @dev Returns the address of the SwapMiner proxy\\r\\n   * @return The SwapMiner proxy address\\r\\n   **/\\r\\n  function getSwapMiner() external view override returns (address) {\\r\\n    return getAddress(SWAP_MINER);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the implementation of the SwapMiner, or creates the proxy\\r\\n   * setting the new `pool` implementation on the first time calling it\\r\\n   * @param swapMiner The new SwapMiner implementation\\r\\n   **/\\r\\n  function setSwapMinerImpl(address swapMiner, address UniswapRouter, address _uniswapLevPairToken, address LeverUsdOracle) external override onlyOwner {\\r\\n    _updateSwapMinerImpl(SWAP_MINER, swapMiner, UniswapRouter, _uniswapLevPairToken, LeverUsdOracle);\\r\\n    emit SwapMinerUpdated(swapMiner);\\r\\n  }\\r\\n\\r\\n  \\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to update the implementation of a specific proxied component of the protocol\\r\\n   * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\\r\\n   *   as implementation and calls the initialize() function on the proxy\\r\\n   * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\\r\\n   *   calls the initialize() function via upgradeToAndCall() in the proxy\\r\\n   * @param id The id of the proxy to be updated\\r\\n   * @param newAddress The address of the new implementation\\r\\n   **/\\r\\n  function _updateImpl(bytes32 id, address newAddress) internal {\\r\\n    address payable proxyAddress = payable(_addresses[id]);\\r\\n\\r\\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\\r\\n      InitializableImmutableAdminUpgradeabilityProxy(proxyAddress);\\r\\n    bytes memory params = abi.encodeWithSignature(\\u0027initialize(address)\\u0027, address(this));\\r\\n\\r\\n    if (proxyAddress == address(0)) {\\r\\n      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\\r\\n      proxy.initialize(newAddress, params);\\r\\n      _addresses[id] = address(proxy);\\r\\n      emit ProxyCreated(id, address(proxy));\\r\\n    } else {\\r\\n      proxy.upgradeToAndCall(newAddress, params);\\r\\n    }\\r\\n  }\\r\\n\\r\\n    /**\\r\\n   * @dev Internal function to update the implementation of a specific proxied component of the protocol\\r\\n   * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\\r\\n   *   as implementation and calls the initialize() function on the proxy\\r\\n   * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\\r\\n   *   calls the initialize() function via upgradeToAndCall() in the proxy\\r\\n   * @param id The id of the proxy to be updated\\r\\n   * @param newAddress The address of the new implementation\\r\\n   **/\\r\\n  function _updateImpl(bytes32 id, address newAddress, address UniswapRouter,address _weth) internal {\\r\\n    address payable proxyAddress = payable(_addresses[id]);\\r\\n\\r\\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\\r\\n      InitializableImmutableAdminUpgradeabilityProxy(proxyAddress);\\r\\n    bytes memory params = abi.encodeWithSignature(\\u0027initialize(address,address,address)\\u0027, address(this), UniswapRouter,_weth);\\r\\n\\r\\n    if (proxyAddress == address(0)) {\\r\\n      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\\r\\n      proxy.initialize(newAddress, params);\\r\\n      _addresses[id] = address(proxy);\\r\\n      emit ProxyCreated(id, address(proxy));\\r\\n    } else {\\r\\n      proxy.upgradeToAndCall(newAddress, params);\\r\\n    }\\r\\n  }\\r\\n    /**\\r\\n   * @dev Internal function to update the implementation of a specific proxied component of the protocol\\r\\n   * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\\r\\n   *   as implementation and calls the initialize() function on the proxy\\r\\n   * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\\r\\n   *   calls the initialize() function via upgradeToAndCall() in the proxy\\r\\n   * @param id The id of the proxy to be updated\\r\\n   * @param newAddress The address of the new implementation\\r\\n   **/\\r\\n  function _updatePoolImpl(bytes32 id, address newAddress, address UniswapRouter, address SushiswapRouter,address _weth) internal {\\r\\n    address payable proxyAddress = payable(_addresses[id]);\\r\\n\\r\\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\\r\\n      InitializableImmutableAdminUpgradeabilityProxy(proxyAddress);\\r\\n    bytes memory params = abi.encodeWithSignature(\\u0027initialize(address,address,address,address)\\u0027, address(this), UniswapRouter,SushiswapRouter, _weth);\\r\\n\\r\\n    if (proxyAddress == address(0)) {\\r\\n      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\\r\\n      proxy.initialize(newAddress, params);\\r\\n      _addresses[id] = address(proxy);\\r\\n      emit ProxyCreated(id, address(proxy));\\r\\n    } else {\\r\\n      proxy.upgradeToAndCall(newAddress, params);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _updateSwapMinerImpl(bytes32 id, address newAddress, address UniswapRouter,address _uniswapLevPairToken,address LeverUsdOracle) internal {\\r\\n    address payable proxyAddress = payable(_addresses[id]);\\r\\n\\r\\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\\r\\n      InitializableImmutableAdminUpgradeabilityProxy(proxyAddress);\\r\\n    bytes memory params = abi.encodeWithSignature(\\u0027initialize(address,address,address,address)\\u0027, address(this), UniswapRouter,_uniswapLevPairToken,LeverUsdOracle);\\r\\n\\r\\n    if (proxyAddress == address(0)) {\\r\\n      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\\r\\n      proxy.initialize(newAddress, params);\\r\\n      _addresses[id] = address(proxy);\\r\\n      emit ProxyCreated(id, address(proxy));\\r\\n    } else {\\r\\n      proxy.upgradeToAndCall(newAddress, params);\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n}\\r\\n\"},\"MarginPoolConfigurator.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {SafeMath} from \\u0027./SafeMath.sol\\u0027;\\r\\nimport {VersionedInitializable} from \\u0027./VersionedInitializable.sol\\u0027;\\r\\nimport {ReserveConfiguration} from \\u0027./ReserveConfiguration.sol\\u0027;\\r\\nimport {IMarginPoolAddressesProvider} from \\u0027./IMarginPoolAddressesProvider.sol\\u0027;\\r\\nimport {IMarginPool} from \\u0027./IMarginPool.sol\\u0027;\\r\\nimport {ITokenConfiguration} from \\u0027./ITokenConfiguration.sol\\u0027;\\r\\nimport {IERC20Detailed} from \\u0027./IERC20Detailed.sol\\u0027;\\r\\nimport {Errors} from \\u0027./Errors.sol\\u0027;\\r\\nimport {PercentageMath} from \\u0027./PercentageMath.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title MarginPoolConfigurator contract\\r\\n * @author Lever\\r\\n * @dev Implements the configuration methods for the Lever protocol\\r\\n **/\\r\\n\\r\\ncontract MarginPoolConfigurator is VersionedInitializable {\\r\\n  using SafeMath for uint256;\\r\\n  using PercentageMath for uint256;\\r\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a reserve is initialized.\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param xToken The address of the associated xToken contract\\r\\n   * @param variableDebtToken The address of the associated variable rate debt token\\r\\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\\r\\n   **/\\r\\n  event ReserveInitialized(\\r\\n    address indexed asset,\\r\\n    address indexed xToken,\\r\\n    address variableDebtToken,\\r\\n    address interestRateStrategyAddress\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when borrowing is enabled on a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param rateEnabled false otherwise\\r\\n   **/\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when borrowing is disabled on a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  event BorrowingDisabledOnReserve(address indexed asset);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param ltv The loan to value of the asset when used as collateral\\r\\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\\r\\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\\r\\n   **/\\r\\n  event CollateralConfigurationChanged(\\r\\n    address indexed asset,\\r\\n    uint256 ltv,\\r\\n    uint256 liquidationThreshold,\\r\\n    uint256 liquidationBonus\\r\\n  );\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a reserve is activated\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  event ReserveActivated(address indexed asset);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a reserve is deactivated\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  event ReserveDeactivated(address indexed asset);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a reserve is frozen\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  event ReserveFrozen(address indexed asset);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a reserve is unfrozen\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  event ReserveUnfrozen(address indexed asset);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a reserve factor is updated\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param factor The new reserve factor\\r\\n   **/\\r\\n  event ReserveFactorChanged(address indexed asset, uint256 factor);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the reserve decimals are updated\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param decimals The new decimals\\r\\n   **/\\r\\n  event ReserveDecimalsChanged(address indexed asset, uint256 decimals);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a reserve interest strategy contract is updated\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param strategy The new address of the interest strategy contract\\r\\n   **/\\r\\n  event ReserveInterestRateStrategyChanged(address indexed asset, address strategy);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when an xToken implementation is upgraded\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param proxy The xToken proxy address\\r\\n   * @param implementation The new xToken implementation\\r\\n   **/\\r\\n  event XTokenUpgraded(\\r\\n    address indexed asset,\\r\\n    address indexed proxy,\\r\\n    address indexed implementation\\r\\n  );\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the implementation of a variable debt token is upgraded\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param proxy The variable debt token proxy address\\r\\n   * @param implementation The new xToken implementation\\r\\n   **/\\r\\n  event VariableDebtTokenUpgraded(\\r\\n    address indexed asset,\\r\\n    address indexed proxy,\\r\\n    address indexed implementation\\r\\n  );\\r\\n\\r\\n  IMarginPoolAddressesProvider public addressesProvider;\\r\\n  IMarginPool public pool;\\r\\n\\r\\n  modifier onlyPoolAdmin {\\r\\n    require(addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlyEmergencyAdmin {\\r\\n    require(\\r\\n      addressesProvider.getEmergencyAdmin() == msg.sender,\\r\\n      Errors.MPC_CALLER_NOT_EMERGENCY_ADMIN\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  uint256 internal constant CONFIGURATOR_REVISION = 0x1;\\r\\n\\r\\n  function getRevision() internal pure override returns (uint256) {\\r\\n    return CONFIGURATOR_REVISION;\\r\\n  }\\r\\n\\r\\n  function initialize(IMarginPoolAddressesProvider provider) public initializer {\\r\\n    addressesProvider = provider;\\r\\n    pool = IMarginPool(addressesProvider.getMarginPool());\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Initializes a reserve\\r\\n   * @param xTokenImpl  The address of the xToken contract implementation\\r\\n   * @param variableDebtTokenImpl The address of the variable debt token contract\\r\\n   * @param underlyingAssetDecimals The decimals of the reserve underlying asset\\r\\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract for this reserve\\r\\n   **/\\r\\n  function initReserve(\\r\\n    address xTokenImpl,\\r\\n    address variableDebtTokenImpl,\\r\\n    uint8 underlyingAssetDecimals,\\r\\n    address interestRateStrategyAddress\\r\\n  ) public onlyPoolAdmin {\\r\\n    address asset = ITokenConfiguration(xTokenImpl).UNDERLYING_ASSET_ADDRESS();\\r\\n\\r\\n    require(\\r\\n      address(pool) == ITokenConfiguration(xTokenImpl).POOL(),\\r\\n      Errors.MPC_INVALID_XTOKEN_POOL_ADDRESS\\r\\n    );\\r\\n    require(\\r\\n      address(pool) == ITokenConfiguration(variableDebtTokenImpl).POOL(),\\r\\n      Errors.MPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS\\r\\n    );\\r\\n    require(\\r\\n      asset == ITokenConfiguration(variableDebtTokenImpl).UNDERLYING_ASSET_ADDRESS(),\\r\\n      Errors.MPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS\\r\\n    );\\r\\n\\r\\n\\r\\n    pool.initReserve(\\r\\n      asset,\\r\\n      xTokenImpl,\\r\\n      variableDebtTokenImpl,\\r\\n      interestRateStrategyAddress\\r\\n    );\\r\\n\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    currentConfig.setDecimals(underlyingAssetDecimals);\\r\\n\\r\\n    currentConfig.setActive(true);\\r\\n    currentConfig.setFrozen(false);\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n\\r\\n    emit ReserveInitialized(\\r\\n      asset,\\r\\n      xTokenImpl,\\r\\n      variableDebtTokenImpl,\\r\\n      interestRateStrategyAddress\\r\\n    );\\r\\n  }\\r\\n  \\r\\n \\r\\n\\r\\n  /**\\r\\n   * @dev Enables borrowing on a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  function enableBorrowingOnReserve(address asset)\\r\\n    external\\r\\n    onlyPoolAdmin\\r\\n  {\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    currentConfig.setBorrowingEnabled(true);\\r\\n\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Disables borrowing on a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  function disableBorrowingOnReserve(address asset) external onlyPoolAdmin {\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    currentConfig.setBorrowingEnabled(false);\\r\\n\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n    emit BorrowingDisabledOnReserve(asset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Configures the reserve collateralization parameters\\r\\n   * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param ltv The loan to value of the asset when used as collateral\\r\\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\\r\\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset. The values is always above 100%. A value of 105%\\r\\n   * means the liquidator will receive a 5% bonus\\r\\n   **/\\r\\n  function configureReserveAsCollateral(\\r\\n    address asset,\\r\\n    uint256 ltv,\\r\\n    uint256 liquidationThreshold,\\r\\n    uint256 liquidationBonus\\r\\n  ) external onlyPoolAdmin {\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    //validation of the parameters: the LTV can\\r\\n    //only be lower or equal than the liquidation threshold\\r\\n    //(otherwise a loan against the asset would cause instantaneous liquidation)\\r\\n    require(ltv \\u003c= liquidationThreshold, Errors.MPC_INVALID_CONFIGURATION);\\r\\n\\r\\n    if (liquidationThreshold != 0) {\\r\\n      //liquidation bonus must be bigger than 100.00%, otherwise the liquidator would receive less\\r\\n      //collateral than needed to cover the debt\\r\\n      require(\\r\\n        liquidationBonus \\u003e PercentageMath.PERCENTAGE_FACTOR,\\r\\n        Errors.MPC_INVALID_CONFIGURATION\\r\\n      );\\r\\n\\r\\n      //if threshold * bonus is less than PERCENTAGE_FACTOR, it\\u0027s guaranteed that at the moment\\r\\n      //a loan is taken there is enough collateral available to cover the liquidation bonus\\r\\n      require(\\r\\n        liquidationThreshold.percentMul(liquidationBonus) \\u003c= PercentageMath.PERCENTAGE_FACTOR,\\r\\n        Errors.MPC_INVALID_CONFIGURATION\\r\\n      );\\r\\n    } else {\\r\\n      require(liquidationBonus == 0, Errors.MPC_INVALID_CONFIGURATION);\\r\\n      //if the liquidation threshold is being set to 0,\\r\\n      // the reserve is being disabled as collateral. To do so,\\r\\n      //we need to ensure no liquidity is deposited\\r\\n      _checkNoLiquidity(asset);\\r\\n    }\\r\\n\\r\\n    currentConfig.setLtv(ltv);\\r\\n    currentConfig.setLiquidationThreshold(liquidationThreshold);\\r\\n    currentConfig.setLiquidationBonus(liquidationBonus);\\r\\n\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n\\r\\n    emit CollateralConfigurationChanged(asset, ltv, liquidationThreshold, liquidationBonus);\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Activates a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  function activateReserve(address asset) external onlyPoolAdmin {\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    currentConfig.setActive(true);\\r\\n\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n\\r\\n    emit ReserveActivated(asset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Deactivates a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  function deactivateReserve(address asset) external onlyPoolAdmin {\\r\\n    _checkNoLiquidity(asset);\\r\\n\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    currentConfig.setActive(false);\\r\\n\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n\\r\\n    emit ReserveDeactivated(asset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Freezes a reserve. A frozen reserve doesn\\u0027t allow any new deposit, borrow or rate swap\\r\\n   *  but allows repayments, liquidations, rate rebalances and withdrawals\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  function freezeReserve(address asset) external onlyPoolAdmin {\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    currentConfig.setFrozen(true);\\r\\n\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n\\r\\n    emit ReserveFrozen(asset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Unfreezes a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   **/\\r\\n  function unfreezeReserve(address asset) external onlyPoolAdmin {\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    currentConfig.setFrozen(false);\\r\\n\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n\\r\\n    emit ReserveUnfrozen(asset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the reserve factor of a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param reserveFactor The new reserve factor of the reserve\\r\\n   **/\\r\\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\\r\\n    DataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\\r\\n\\r\\n    currentConfig.setReserveFactor(reserveFactor);\\r\\n\\r\\n    pool.setConfiguration(asset, currentConfig.data);\\r\\n\\r\\n    emit ReserveFactorChanged(asset, reserveFactor);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the interest rate strategy of a reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param rateStrategyAddress The new address of the interest strategy contract\\r\\n   **/\\r\\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\\r\\n    external\\r\\n    onlyPoolAdmin\\r\\n  {\\r\\n    pool.setReserveInterestRateStrategyAddress(asset, rateStrategyAddress);\\r\\n    emit ReserveInterestRateStrategyChanged(asset, rateStrategyAddress);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev pauses or unpauses all the actions of the protocol, including xToken transfers\\r\\n   * @param val true if protocol needs to be paused, false otherwise\\r\\n   **/\\r\\n  function setPoolPause(bool val) external onlyEmergencyAdmin {\\r\\n    pool.setPause(val);\\r\\n  }\\r\\n\\r\\n\\r\\n  function _checkNoLiquidity(address asset) internal view {\\r\\n    DataTypes.ReserveData memory reserveData = pool.getReserveData(asset);\\r\\n\\r\\n    uint256 availableLiquidity = IERC20Detailed(asset).balanceOf(reserveData.xTokenAddress);\\r\\n\\r\\n    require(\\r\\n      availableLiquidity == 0 \\u0026\\u0026 reserveData.currentLiquidityRate == 0,\\r\\n      Errors.MPC_RESERVE_LIQUIDITY_NOT_0\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\"},\"MarginPoolStorage.sol\":{\"content\":\"pragma solidity 0.6.12;\\r\\n// SPDX-License-Identifier: agpl-3.0\\r\\n\\r\\nimport {UserConfiguration} from \\u0027./UserConfiguration.sol\\u0027;\\r\\nimport {ReserveConfiguration} from \\u0027./ReserveConfiguration.sol\\u0027;\\r\\nimport {ReserveLogic} from \\u0027./ReserveLogic.sol\\u0027;\\r\\nimport {IMarginPoolAddressesProvider} from \\u0027./IMarginPoolAddressesProvider.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\ncontract MarginPoolStorage {\\r\\n  using ReserveLogic for DataTypes.ReserveData;\\r\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\r\\n  using UserConfiguration for DataTypes.UserConfigurationMap;\\r\\n\\r\\n  IMarginPoolAddressesProvider internal _addressesProvider;\\r\\n\\r\\n  mapping(address =\\u003e DataTypes.ReserveData) internal _reserves;\\r\\n  mapping(address =\\u003e DataTypes.UserConfigurationMap) internal _usersConfig;\\r\\n\\r\\n  // the list of the available reserves, structured as a mapping for gas savings reasons\\r\\n  mapping(uint256 =\\u003e address) internal _reservesList;\\r\\n\\r\\n  uint256 internal _reservesCount;\\r\\n\\r\\n  bool internal _paused;\\r\\n}\\r\\n\"},\"MathUtils.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {SafeMath} from \\u0027./SafeMath.sol\\u0027;\\r\\nimport {WadRayMath} from \\u0027./WadRayMath.sol\\u0027;\\r\\n\\r\\nlibrary MathUtils {\\r\\n  using SafeMath for uint256;\\r\\n  using WadRayMath for uint256;\\r\\n\\r\\n  /// @dev Ignoring leap years\\r\\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\\r\\n\\r\\n  /**\\r\\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\\r\\n   * @param rate The interest rate, in ray\\r\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\r\\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\\r\\n   **/\\r\\n\\r\\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    //solium-disable-next-line\\r\\n    uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp));\\r\\n\\r\\n    return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\r\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\r\\n   *\\r\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\r\\n   *\\r\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\r\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\r\\n   *\\r\\n   * @param rate The interest rate, in ray\\r\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\r\\n   * @return The interest rate compounded during the timeDelta, in ray\\r\\n   **/\\r\\n  function calculateCompoundedInterest(\\r\\n    uint256 rate,\\r\\n    uint40 lastUpdateTimestamp,\\r\\n    uint256 currentTimestamp\\r\\n  ) internal pure returns (uint256) {\\r\\n    //solium-disable-next-line\\r\\n    uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\\r\\n\\r\\n    if (exp == 0) {\\r\\n      return WadRayMath.ray();\\r\\n    }\\r\\n\\r\\n    uint256 expMinusOne = exp - 1;\\r\\n\\r\\n    uint256 expMinusTwo = exp \\u003e 2 ? exp - 2 : 0;\\r\\n\\r\\n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\\r\\n\\r\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\r\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\r\\n\\r\\n    uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\\r\\n    uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6;\\r\\n\\r\\n    return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\\r\\n   * @param rate The interest rate (in ray)\\r\\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\\r\\n   **/\\r\\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\\r\\n  }\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n  address private _owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  /**\\r\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n   */\\r\\n  constructor() internal {\\r\\n    address msgSender = _msgSender();\\r\\n    _owner = msgSender;\\r\\n    emit OwnershipTransferred(address(0), msgSender);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the address of the current owner.\\r\\n   */\\r\\n  function owner() public view returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(_owner == _msgSender(), \\u0027Ownable: caller is not the owner\\u0027);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Leaves the contract without owner. It will not be possible to call\\r\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n   *\\r\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n   * thereby removing any functionality that is only available to the owner.\\r\\n   */\\r\\n  function renounceOwnership() public virtual onlyOwner {\\r\\n    emit OwnershipTransferred(_owner, address(0));\\r\\n    _owner = address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n   * Can only be called by the current owner.\\r\\n   */\\r\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n    require(newOwner != address(0), \\u0027Ownable: new owner is the zero address\\u0027);\\r\\n    emit OwnershipTransferred(_owner, newOwner);\\r\\n    _owner = newOwner;\\r\\n  }\\r\\n}\\r\\n\"},\"PercentageMath.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {Errors} from \\u0027./Errors.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title PercentageMath library\\r\\n * @author Lever\\r\\n * @notice Provides functions to perform percentage calculations\\r\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\r\\n * @dev Operations are rounded half up\\r\\n **/\\r\\n\\r\\nlibrary PercentageMath {\\r\\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\r\\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\r\\n\\r\\n  /**\\r\\n   * @dev Executes a percentage multiplication\\r\\n   * @param value The value of which the percentage needs to be calculated\\r\\n   * @param percentage The percentage of the value to be calculated\\r\\n   * @return The percentage of value\\r\\n   **/\\r\\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\\r\\n    if (value == 0 || percentage == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    require(\\r\\n      value \\u003c= (type(uint256).max - HALF_PERCENT) / percentage,\\r\\n      Errors.MATH_MULTIPLICATION_OVERFLOW\\r\\n    );\\r\\n\\r\\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Executes a percentage division\\r\\n   * @param value The value of which the percentage needs to be calculated\\r\\n   * @param percentage The percentage of the value to be calculated\\r\\n   * @return The value divided the percentage\\r\\n   **/\\r\\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\\r\\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\\r\\n    uint256 halfPercentage = percentage / 2;\\r\\n\\r\\n    require(\\r\\n      value \\u003c= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\\r\\n      Errors.MATH_MULTIPLICATION_OVERFLOW\\r\\n    );\\r\\n\\r\\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\r\\n  }\\r\\n}\\r\\n\"},\"PriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IPriceOracle} from \\u0027./IPriceOracle.sol\\u0027;\\r\\n\\r\\ncontract PriceOracle is IPriceOracle {\\r\\n  mapping(address =\\u003e uint256) prices;\\r\\n  uint256 ethPriceUsd;\\r\\n\\r\\n  event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp);\\r\\n  event EthPriceUpdated(uint256 _price, uint256 timestamp);\\r\\n\\r\\n  function getAssetPrice(address _asset) external view override returns (uint256) {\\r\\n    return prices[_asset];\\r\\n  }\\r\\n\\r\\n  function setAssetPrice(address _asset, uint256 _price) external override {\\r\\n    prices[_asset] = _price;\\r\\n    emit AssetPriceUpdated(_asset, _price, block.timestamp);\\r\\n  }\\r\\n\\r\\n  function getEthUsdPrice() external view returns (uint256) {\\r\\n    return ethPriceUsd;\\r\\n  }\\r\\n\\r\\n  function setEthUsdPrice(uint256 _price) external {\\r\\n    ethPriceUsd = _price;\\r\\n    emit EthPriceUpdated(_price, block.timestamp);\\r\\n  }\\r\\n}\\r\\n\"},\"Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/**\\r\\n * @title Proxy\\r\\n * @dev Implements delegation of calls to other contracts, with proper\\r\\n * forwarding of return values and bubbling of failures.\\r\\n * It defines a fallback function that delegates all calls to the address\\r\\n * returned by the abstract _implementation() internal function.\\r\\n */\\r\\nabstract contract Proxy {\\r\\n  /**\\r\\n   * @dev Fallback function.\\r\\n   * Implemented entirely in `_fallback`.\\r\\n   */\\r\\n  fallback() external payable {\\r\\n    _fallback();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The Address of the implementation.\\r\\n   */\\r\\n  function _implementation() internal view virtual returns (address);\\r\\n\\r\\n  /**\\r\\n   * @dev Delegates execution to an implementation contract.\\r\\n   * This is a low level function that doesn\\u0027t return to its internal call site.\\r\\n   * It will return to the external caller whatever the implementation returns.\\r\\n   * @param implementation Address to delegate.\\r\\n   */\\r\\n  function _delegate(address implementation) internal {\\r\\n    //solium-disable-next-line\\r\\n    assembly {\\r\\n      // Copy msg.data. We take full control of memory in this inline assembly\\r\\n      // block because it will not return to Solidity code. We overwrite the\\r\\n      // Solidity scratch pad at memory position 0.\\r\\n      calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n      // Call the implementation.\\r\\n      // out and outsize are 0 because we don\\u0027t know the size yet.\\r\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n      // Copy the returned data.\\r\\n      returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n      switch result\\r\\n        // delegatecall returns 0 on error.\\r\\n        case 0 {\\r\\n          revert(0, returndatasize())\\r\\n        }\\r\\n        default {\\r\\n          return(0, returndatasize())\\r\\n        }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Function that is run as the first thing in the fallback function.\\r\\n   * Can be redefined in derived contracts to add functionality.\\r\\n   * Redefinitions must call super._willFallback().\\r\\n   */\\r\\n  function _willFallback() internal virtual {}\\r\\n\\r\\n  /**\\r\\n   * @dev fallback implementation.\\r\\n   * Extracted to enable manual triggering.\\r\\n   */\\r\\n  function _fallback() internal {\\r\\n    _willFallback();\\r\\n    _delegate(_implementation());\\r\\n  }\\r\\n}\\r\\n\"},\"ReserveConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {Errors} from \\u0027./Errors.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ReserveConfiguration library\\r\\n * @author Lever\\r\\n * @notice Implements the bitmap logic to handle the reserve configuration\\r\\n */\\r\\nlibrary ReserveConfiguration {\\r\\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\r\\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\r\\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\r\\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\\r\\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\r\\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\r\\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\\r\\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\\r\\n\\r\\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\r\\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\r\\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\r\\n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\\r\\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\\r\\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\\r\\n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\\r\\n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\\r\\n\\r\\n  uint256 constant MAX_VALID_LTV = 65535;\\r\\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\r\\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\\r\\n  uint256 constant MAX_VALID_DECIMALS = 255;\\r\\n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the Loan to Value of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @param ltv the new ltv\\r\\n   **/\\r\\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\\r\\n    require(ltv \\u003c= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\\r\\n\\r\\n    self.data = (self.data \\u0026 LTV_MASK) | ltv;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the Loan to Value of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The loan to value\\r\\n   **/\\r\\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\r\\n    return self.data \\u0026 ~LTV_MASK;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the liquidation threshold of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @param threshold The new liquidation threshold\\r\\n   **/\\r\\n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold)\\r\\n    internal\\r\\n    pure\\r\\n  {\\r\\n    require(threshold \\u003c= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\\r\\n\\r\\n    self.data =\\r\\n      (self.data \\u0026 LIQUIDATION_THRESHOLD_MASK) |\\r\\n      (threshold \\u003c\\u003c LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the liquidation threshold of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The liquidation threshold\\r\\n   **/\\r\\n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\r\\n    return (self.data \\u0026 ~LIQUIDATION_THRESHOLD_MASK) \\u003e\\u003e LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the liquidation bonus of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @param bonus The new liquidation bonus\\r\\n   **/\\r\\n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus)\\r\\n    internal\\r\\n    pure\\r\\n  {\\r\\n    require(bonus \\u003c= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\r\\n\\r\\n    self.data =\\r\\n      (self.data \\u0026 LIQUIDATION_BONUS_MASK) |\\r\\n      (bonus \\u003c\\u003c LIQUIDATION_BONUS_START_BIT_POSITION);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the liquidation bonus of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The liquidation bonus\\r\\n   **/\\r\\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return (self.data \\u0026 ~LIQUIDATION_BONUS_MASK) \\u003e\\u003e LIQUIDATION_BONUS_START_BIT_POSITION;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the decimals of the underlying asset of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @param decimals The decimals\\r\\n   **/\\r\\n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals)\\r\\n    internal\\r\\n    pure\\r\\n  {\\r\\n    require(decimals \\u003c= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\\r\\n\\r\\n    self.data = (self.data \\u0026 DECIMALS_MASK) | (decimals \\u003c\\u003c RESERVE_DECIMALS_START_BIT_POSITION);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the decimals of the underlying asset of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The decimals of the asset\\r\\n   **/\\r\\n  function getDecimals(DataTypes.ReserveConfigurationMap storage self)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return (self.data \\u0026 ~DECIMALS_MASK) \\u003e\\u003e RESERVE_DECIMALS_START_BIT_POSITION;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the active state of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @param active The active state\\r\\n   **/\\r\\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\\r\\n    self.data =\\r\\n      (self.data \\u0026 ACTIVE_MASK) |\\r\\n      (uint256(active ? 1 : 0) \\u003c\\u003c IS_ACTIVE_START_BIT_POSITION);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the active state of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The active state\\r\\n   **/\\r\\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\r\\n    return (self.data \\u0026 ~ACTIVE_MASK) != 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the frozen state of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @param frozen The frozen state\\r\\n   **/\\r\\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\\r\\n    self.data =\\r\\n      (self.data \\u0026 FROZEN_MASK) |\\r\\n      (uint256(frozen ? 1 : 0) \\u003c\\u003c IS_FROZEN_START_BIT_POSITION);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the frozen state of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The frozen state\\r\\n   **/\\r\\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\r\\n    return (self.data \\u0026 ~FROZEN_MASK) != 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Enables or disables borrowing on the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\\r\\n   **/\\r\\n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled)\\r\\n    internal\\r\\n    pure\\r\\n  {\\r\\n    self.data =\\r\\n      (self.data \\u0026 BORROWING_MASK) |\\r\\n      (uint256(enabled ? 1 : 0) \\u003c\\u003c BORROWING_ENABLED_START_BIT_POSITION);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the borrowing state of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The borrowing state\\r\\n   **/\\r\\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self)\\r\\n    internal\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return (self.data \\u0026 ~BORROWING_MASK) != 0;\\r\\n  }\\r\\n\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the reserve factor of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @param reserveFactor The reserve factor\\r\\n   **/\\r\\n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor)\\r\\n    internal\\r\\n    pure\\r\\n  {\\r\\n    require(reserveFactor \\u003c= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\\r\\n\\r\\n    self.data =\\r\\n      (self.data \\u0026 RESERVE_FACTOR_MASK) |\\r\\n      (reserveFactor \\u003c\\u003c RESERVE_FACTOR_START_BIT_POSITION);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the reserve factor of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The reserve factor\\r\\n   **/\\r\\n  function getReserveFactor(DataTypes.ReserveConfigurationMap storage self)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return (self.data \\u0026 ~RESERVE_FACTOR_MASK) \\u003e\\u003e RESERVE_FACTOR_START_BIT_POSITION;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the configuration flags of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The state flags representing active, frozen, borrowing enabled\\r\\n   **/\\r\\n  function getFlags(DataTypes.ReserveConfigurationMap storage self)\\r\\n    internal\\r\\n    view\\r\\n    returns (\\r\\n      bool,\\r\\n      bool,\\r\\n      bool\\r\\n    )\\r\\n  {\\r\\n    uint256 dataLocal = self.data;\\r\\n\\r\\n    return (\\r\\n      (dataLocal \\u0026 ~ACTIVE_MASK) != 0,\\r\\n      (dataLocal \\u0026 ~FROZEN_MASK) != 0,\\r\\n      (dataLocal \\u0026 ~BORROWING_MASK) != 0\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the configuration paramters of the reserve\\r\\n   * @param self The reserve configuration\\r\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\r\\n   **/\\r\\n  function getParams(DataTypes.ReserveConfigurationMap storage self)\\r\\n    internal\\r\\n    view\\r\\n    returns (\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256\\r\\n    )\\r\\n  {\\r\\n    uint256 dataLocal = self.data;\\r\\n\\r\\n    return (\\r\\n      dataLocal \\u0026 ~LTV_MASK,\\r\\n      (dataLocal \\u0026 ~LIQUIDATION_THRESHOLD_MASK) \\u003e\\u003e LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\r\\n      (dataLocal \\u0026 ~LIQUIDATION_BONUS_MASK) \\u003e\\u003e LIQUIDATION_BONUS_START_BIT_POSITION,\\r\\n      (dataLocal \\u0026 ~DECIMALS_MASK) \\u003e\\u003e RESERVE_DECIMALS_START_BIT_POSITION,\\r\\n      (dataLocal \\u0026 ~RESERVE_FACTOR_MASK) \\u003e\\u003e RESERVE_FACTOR_START_BIT_POSITION\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the configuration paramters of the reserve from a memory object\\r\\n   * @param self The reserve configuration\\r\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\r\\n   **/\\r\\n  function getParamsMemory(DataTypes.ReserveConfigurationMap memory self)\\r\\n    internal\\r\\n    pure\\r\\n    returns (\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256,\\r\\n      uint256\\r\\n    )\\r\\n  {\\r\\n    return (\\r\\n      self.data \\u0026 ~LTV_MASK,\\r\\n      (self.data \\u0026 ~LIQUIDATION_THRESHOLD_MASK) \\u003e\\u003e LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\r\\n      (self.data \\u0026 ~LIQUIDATION_BONUS_MASK) \\u003e\\u003e LIQUIDATION_BONUS_START_BIT_POSITION,\\r\\n      (self.data \\u0026 ~DECIMALS_MASK) \\u003e\\u003e RESERVE_DECIMALS_START_BIT_POSITION,\\r\\n      (self.data \\u0026 ~RESERVE_FACTOR_MASK) \\u003e\\u003e RESERVE_FACTOR_START_BIT_POSITION\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the configuration flags of the reserve from a memory object\\r\\n   * @param self The reserve configuration\\r\\n   * @return The state flags representing active, frozen, borrowing enabled\\r\\n   **/\\r\\n  function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self)\\r\\n    internal\\r\\n    pure\\r\\n    returns (\\r\\n      bool,\\r\\n      bool,\\r\\n      bool\\r\\n    )\\r\\n  {\\r\\n    return (\\r\\n      (self.data \\u0026 ~ACTIVE_MASK) != 0,\\r\\n      (self.data \\u0026 ~FROZEN_MASK) != 0,\\r\\n      (self.data \\u0026 ~BORROWING_MASK) != 0\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\"},\"ReserveLogic.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {SafeMath} from \\u0027./SafeMath.sol\\u0027;\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\nimport {SafeERC20} from \\u0027./SafeERC20.sol\\u0027;\\r\\nimport {IXToken} from \\u0027./IXToken.sol\\u0027;\\r\\nimport {IVariableDebtToken} from \\u0027./IVariableDebtToken.sol\\u0027;\\r\\nimport {IReserveInterestRateStrategy} from \\u0027./IReserveInterestRateStrategy.sol\\u0027;\\r\\nimport {ReserveConfiguration} from \\u0027./ReserveConfiguration.sol\\u0027;\\r\\nimport {MathUtils} from \\u0027./MathUtils.sol\\u0027;\\r\\nimport {WadRayMath} from \\u0027./WadRayMath.sol\\u0027;\\r\\nimport {PercentageMath} from \\u0027./PercentageMath.sol\\u0027;\\r\\nimport {Errors} from \\u0027./Errors.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ReserveLogic library\\r\\n * @author Lever\\r\\n * @notice Implements the logic to update the reserves state\\r\\n */\\r\\nlibrary ReserveLogic {\\r\\n  using SafeMath for uint256;\\r\\n  using WadRayMath for uint256;\\r\\n  using PercentageMath for uint256;\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the state of a reserve is updated\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @param liquidityRate The new liquidity rate\\r\\n   * @param variableBorrowRate The new variable borrow rate\\r\\n   * @param liquidityIndex The new liquidity index\\r\\n   * @param variableBorrowIndex The new variable borrow index\\r\\n   **/\\r\\n  event ReserveDataUpdated(\\r\\n    address indexed asset,\\r\\n    uint256 liquidityRate,\\r\\n    uint256 variableBorrowRate,\\r\\n    uint256 liquidityIndex,\\r\\n    uint256 variableBorrowIndex\\r\\n  );\\r\\n\\r\\n  using ReserveLogic for DataTypes.ReserveData;\\r\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the ongoing normalized income for the reserve\\r\\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\\r\\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\\r\\n   * @param reserve The reserve object\\r\\n   * @return the normalized income. expressed in ray\\r\\n   **/\\r\\n  function getNormalizedIncome(DataTypes.ReserveData storage reserve)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    uint40 timestamp = reserve.lastUpdateTimestamp;\\r\\n\\r\\n    //solium-disable-next-line\\r\\n    if (timestamp == uint40(block.timestamp)) {\\r\\n      //if the index was updated in the same block, no need to perform any calculation\\r\\n      return reserve.liquidityIndex;\\r\\n    }\\r\\n\\r\\n    uint256 cumulated =\\r\\n      MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\\r\\n        reserve.liquidityIndex\\r\\n      );\\r\\n\\r\\n    return cumulated;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the ongoing normalized variable debt for the reserve\\r\\n   * A value of 1e27 means there is no debt. As time passes, the income is accrued\\r\\n   * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\\r\\n   * @param reserve The reserve object\\r\\n   * @return The normalized variable debt. expressed in ray\\r\\n   **/\\r\\n  function getNormalizedDebt(DataTypes.ReserveData storage reserve)\\r\\n    internal\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    uint40 timestamp = reserve.lastUpdateTimestamp;\\r\\n\\r\\n    //solium-disable-next-line\\r\\n    if (timestamp == uint40(block.timestamp)) {\\r\\n      //if the index was updated in the same block, no need to perform any calculation\\r\\n      return reserve.variableBorrowIndex;\\r\\n    }\\r\\n\\r\\n    uint256 cumulated =\\r\\n      MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\\r\\n        reserve.variableBorrowIndex\\r\\n      );\\r\\n\\r\\n    return cumulated;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\\r\\n   * @param reserve the reserve object\\r\\n   **/\\r\\n  function updateState(DataTypes.ReserveData storage reserve) internal {\\r\\n    uint256 scaledVariableDebt =\\r\\n      IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply();\\r\\n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\\r\\n    uint256 previousLiquidityIndex = reserve.liquidityIndex;\\r\\n    uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\\r\\n\\r\\n    (uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) =\\r\\n      _updateIndexes(\\r\\n        reserve,\\r\\n        scaledVariableDebt,\\r\\n        previousLiquidityIndex,\\r\\n        previousVariableBorrowIndex,\\r\\n        lastUpdatedTimestamp\\r\\n      );\\r\\n\\r\\n    _mintToTreasury(\\r\\n      reserve,\\r\\n      scaledVariableDebt,\\r\\n      previousVariableBorrowIndex,\\r\\n      newLiquidityIndex,\\r\\n      newVariableBorrowIndex\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\\r\\n   * the flashloan fee to the reserve, and spread it between all the depositors\\r\\n   * @param reserve The reserve object\\r\\n   * @param totalLiquidity The total liquidity available in the reserve\\r\\n   * @param amount The amount to accomulate\\r\\n   **/\\r\\n  function cumulateToLiquidityIndex(\\r\\n    DataTypes.ReserveData storage reserve,\\r\\n    uint256 totalLiquidity,\\r\\n    uint256 amount\\r\\n  ) internal {\\r\\n    uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\\r\\n\\r\\n    uint256 result = amountToLiquidityRatio.add(WadRayMath.ray());\\r\\n\\r\\n    result = result.rayMul(reserve.liquidityIndex);\\r\\n    require(result \\u003c= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\\r\\n\\r\\n    reserve.liquidityIndex = uint128(result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Initializes a reserve\\r\\n   * @param reserve The reserve object\\r\\n   * @param xTokenAddress The address of the overlying xtoken contract\\r\\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\\r\\n   **/\\r\\n  function init(\\r\\n    DataTypes.ReserveData storage reserve,\\r\\n    address xTokenAddress,\\r\\n    address variableDebtTokenAddress,\\r\\n    address interestRateStrategyAddress\\r\\n  ) external {\\r\\n    require(reserve.xTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\\r\\n\\r\\n    reserve.liquidityIndex = uint128(WadRayMath.ray());\\r\\n    reserve.variableBorrowIndex = uint128(WadRayMath.ray());\\r\\n    reserve.xTokenAddress = xTokenAddress;\\r\\n    reserve.variableDebtTokenAddress = variableDebtTokenAddress;\\r\\n    reserve.interestRateStrategyAddress = interestRateStrategyAddress;\\r\\n  }\\r\\n\\r\\n  struct UpdateInterestRatesLocalVars {\\r\\n    uint256 availableLiquidity;\\r\\n    uint256 newLiquidityRate;\\r\\n    uint256 newVariableRate;\\r\\n    uint256 totalVariableDebt;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the reserve  current variable borrow rate and the current liquidity rate\\r\\n   * @param reserve The address of the reserve to be updated\\r\\n   * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\\r\\n   * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\\r\\n   **/\\r\\n  function updateInterestRates(\\r\\n    DataTypes.ReserveData storage reserve,\\r\\n    address reserveAddress,\\r\\n    address xTokenAddress,\\r\\n    uint256 liquidityAdded,\\r\\n    uint256 liquidityTaken\\r\\n  ) internal {\\r\\n    UpdateInterestRatesLocalVars memory vars;\\r\\n\\r\\n    //calculates the total variable debt locally using the scaled total supply instead\\r\\n    //of totalSupply(), as it\\u0027s noticeably cheaper. Also, the index has been\\r\\n    //updated by the previous updateState() call\\r\\n    vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress)\\r\\n      .scaledTotalSupply()\\r\\n      .rayMul(reserve.variableBorrowIndex);\\r\\n\\r\\n    vars.availableLiquidity = IERC20(reserveAddress).balanceOf(xTokenAddress);\\r\\n\\r\\n    (\\r\\n      vars.newLiquidityRate,\\r\\n      vars.newVariableRate\\r\\n    ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(\\r\\n      vars.availableLiquidity.add(liquidityAdded).sub(liquidityTaken),\\r\\n      vars.totalVariableDebt,\\r\\n      reserve.configuration.getReserveFactor()\\r\\n    );\\r\\n    require(vars.newLiquidityRate \\u003c= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\\r\\n    require(vars.newVariableRate \\u003c= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\\r\\n\\r\\n    reserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\\r\\n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\\r\\n\\r\\n    emit ReserveDataUpdated(\\r\\n      reserveAddress,\\r\\n      vars.newLiquidityRate,\\r\\n      vars.newVariableRate,\\r\\n      reserve.liquidityIndex,\\r\\n      reserve.variableBorrowIndex\\r\\n    );\\r\\n  }\\r\\n\\r\\n  struct MintToTreasuryLocalVars {\\r\\n    uint256 currentVariableDebt;\\r\\n    uint256 previousVariableDebt;\\r\\n    uint256 totalDebtAccrued;\\r\\n    uint256 amountToMint;\\r\\n    uint256 reserveFactor;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\\r\\n   * specific asset.\\r\\n   * @param reserve The reserve reserve to be updated\\r\\n   * @param scaledVariableDebt The current scaled total variable debt\\r\\n   * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\\r\\n   * @param newLiquidityIndex The new liquidity index\\r\\n   * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\\r\\n   **/\\r\\n  function _mintToTreasury(\\r\\n    DataTypes.ReserveData storage reserve,\\r\\n    uint256 scaledVariableDebt,\\r\\n    uint256 previousVariableBorrowIndex,\\r\\n    uint256 newLiquidityIndex,\\r\\n    uint256 newVariableBorrowIndex\\r\\n  ) internal {\\r\\n    MintToTreasuryLocalVars memory vars;\\r\\n\\r\\n    vars.reserveFactor = reserve.configuration.getReserveFactor();\\r\\n\\r\\n    if (vars.reserveFactor == 0) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n\\r\\n    //calculate the last principal variable debt\\r\\n    vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\\r\\n\\r\\n    //calculate the new total supply after accumulation of the index\\r\\n    vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\\r\\n\\r\\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\\r\\n    vars.totalDebtAccrued = vars\\r\\n      .currentVariableDebt\\r\\n      .sub(vars.previousVariableDebt);\\r\\n\\r\\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\\r\\n\\r\\n    if (vars.amountToMint != 0) {\\r\\n      IXToken(reserve.xTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the reserve indexes and the timestamp of the update\\r\\n   * @param reserve The reserve reserve to be updated\\r\\n   * @param scaledVariableDebt The scaled variable debt\\r\\n   * @param liquidityIndex The last stored liquidity index\\r\\n   * @param variableBorrowIndex The last stored variable borrow index\\r\\n   **/\\r\\n  function _updateIndexes(\\r\\n    DataTypes.ReserveData storage reserve,\\r\\n    uint256 scaledVariableDebt,\\r\\n    uint256 liquidityIndex,\\r\\n    uint256 variableBorrowIndex,\\r\\n    uint40 timestamp\\r\\n  ) internal returns (uint256, uint256) {\\r\\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\\r\\n\\r\\n    uint256 newLiquidityIndex = liquidityIndex;\\r\\n    uint256 newVariableBorrowIndex = variableBorrowIndex;\\r\\n\\r\\n    //only cumulating if there is any income being produced\\r\\n    if (currentLiquidityRate \\u003e 0) {\\r\\n      uint256 cumulatedLiquidityInterest =\\r\\n        MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);\\r\\n      newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);\\r\\n      require(newLiquidityIndex \\u003c= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\\r\\n\\r\\n      reserve.liquidityIndex = uint128(newLiquidityIndex);\\r\\n\\r\\n      //we need to ensure that there is actual variable debt before accumulating\\r\\n      if (scaledVariableDebt != 0) {\\r\\n        uint256 cumulatedVariableBorrowInterest =\\r\\n          MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp);\\r\\n        newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\\r\\n        require(\\r\\n          newVariableBorrowIndex \\u003c= type(uint128).max,\\r\\n          Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW\\r\\n        );\\r\\n        reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    //solium-disable-next-line\\r\\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\\r\\n    return (newLiquidityIndex, newVariableBorrowIndex);\\r\\n  }\\r\\n}\\r\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\nimport {SafeMath} from \\u0027./SafeMath.sol\\u0027;\\r\\nimport {Address} from \\u0027./Address.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n  using SafeMath for uint256;\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\u0027SafeERC20: approve from non-zero to non-zero allowance\\u0027\\r\\n    );\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    require(address(token).isContract(), \\u0027SafeERC20: call to non-contract\\u0027);\\r\\n\\r\\n    // solhint-disable-next-line avoid-low-level-calls\\r\\n    (bool success, bytes memory returndata) = address(token).call(data);\\r\\n    require(success, \\u0027SafeERC20: low-level call failed\\u0027);\\r\\n\\r\\n    if (returndata.length \\u003e 0) {\\r\\n      // Return data is optional\\r\\n      // solhint-disable-next-line max-line-length\\r\\n      require(abi.decode(returndata, (bool)), \\u0027SafeERC20: ERC20 operation did not succeed\\u0027);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n  /**\\r\\n   * @dev Returns the addition of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `+` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Addition cannot overflow.\\r\\n   */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a, \\u0027SafeMath: addition overflow\\u0027);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return sub(a, b, \\u0027SafeMath: subtraction overflow\\u0027);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a, errorMessage);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `*` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Multiplication cannot overflow.\\r\\n   */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\u0027SafeMath: multiplication overflow\\u0027);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return div(a, b, \\u0027SafeMath: division by zero\\u0027);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b \\u003e 0, errorMessage);\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return mod(a, b, \\u0027SafeMath: modulo by zero\\u0027);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts with custom message when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function mod(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b != 0, errorMessage);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"},\"StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nlibrary StringLib {\\r\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\r\\n    return string(abi.encodePacked(a, b));\\r\\n  }\\r\\n}\\r\\n\"},\"UpgradeabilityProxy.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\u0027./BaseUpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title UpgradeabilityProxy\\r\\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\\r\\n * implementation and init data.\\r\\n */\\r\\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Contract constructor.\\r\\n   * @param _logic Address of the initial implementation.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  constructor(address _logic, bytes memory _data) public payable {\\r\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.implementation\\u0027)) - 1));\\r\\n    _setImplementation(_logic);\\r\\n    if (_data.length \\u003e 0) {\\r\\n      (bool success, ) = _logic.delegatecall(_data);\\r\\n      require(success);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},\"UserConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {Errors} from \\u0027./Errors.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title UserConfiguration library\\r\\n * @author Lever\\r\\n * @notice Implements the bitmap logic to handle the user configuration\\r\\n */\\r\\nlibrary UserConfiguration {\\r\\n  uint256 internal constant BORROWING_MASK =\\r\\n    0x5555555555555555555555555555555555555555555555555555555555555555;\\r\\n\\r\\n  /**\\r\\n   * @dev Sets if the user is borrowing the reserve identified by reserveIndex\\r\\n   * @param self The configuration object\\r\\n   * @param reserveIndex The index of the reserve in the bitmap\\r\\n   * @param borrowing True if the user is borrowing the reserve, false otherwise\\r\\n   **/\\r\\n  function setBorrowing(\\r\\n    DataTypes.UserConfigurationMap storage self,\\r\\n    uint256 reserveIndex,\\r\\n    bool borrowing\\r\\n  ) internal {\\r\\n    require(reserveIndex \\u003c 128, Errors.UL_INVALID_INDEX);\\r\\n    self.data =\\r\\n      (self.data \\u0026 ~(1 \\u003c\\u003c (reserveIndex * 2))) |\\r\\n      (uint256(borrowing ? 1 : 0) \\u003c\\u003c (reserveIndex * 2));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets if the user is using as collateral the reserve identified by reserveIndex\\r\\n   * @param self The configuration object\\r\\n   * @param reserveIndex The index of the reserve in the bitmap\\r\\n   * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise\\r\\n   **/\\r\\n  function setUsingAsCollateral(\\r\\n    DataTypes.UserConfigurationMap storage self,\\r\\n    uint256 reserveIndex,\\r\\n    bool usingAsCollateral\\r\\n  ) internal {\\r\\n    require(reserveIndex \\u003c 128, Errors.UL_INVALID_INDEX);\\r\\n    self.data =\\r\\n      (self.data \\u0026 ~(1 \\u003c\\u003c (reserveIndex * 2 + 1))) |\\r\\n      (uint256(usingAsCollateral ? 1 : 0) \\u003c\\u003c (reserveIndex * 2 + 1));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Used to validate if a user has been using the reserve for borrowing or as collateral\\r\\n   * @param self The configuration object\\r\\n   * @param reserveIndex The index of the reserve in the bitmap\\r\\n   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\\r\\n   **/\\r\\n  function isUsingAsCollateralOrBorrowing(\\r\\n    DataTypes.UserConfigurationMap memory self,\\r\\n    uint256 reserveIndex\\r\\n  ) internal pure returns (bool) {\\r\\n    require(reserveIndex \\u003c 128, Errors.UL_INVALID_INDEX);\\r\\n    return (self.data \\u003e\\u003e (reserveIndex * 2)) \\u0026 3 != 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Used to validate if a user has been using the reserve for borrowing\\r\\n   * @param self The configuration object\\r\\n   * @param reserveIndex The index of the reserve in the bitmap\\r\\n   * @return True if the user has been using a reserve for borrowing, false otherwise\\r\\n   **/\\r\\n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\\r\\n    internal\\r\\n    pure\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(reserveIndex \\u003c 128, Errors.UL_INVALID_INDEX);\\r\\n    return (self.data \\u003e\\u003e (reserveIndex * 2)) \\u0026 1 != 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Used to validate if a user has been using the reserve as collateral\\r\\n   * @param self The configuration object\\r\\n   * @param reserveIndex The index of the reserve in the bitmap\\r\\n   * @return True if the user has been using a reserve as collateral, false otherwise\\r\\n   **/\\r\\n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\\r\\n    internal\\r\\n    pure\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(reserveIndex \\u003c 128, Errors.UL_INVALID_INDEX);\\r\\n    return (self.data \\u003e\\u003e (reserveIndex * 2 + 1)) \\u0026 1 != 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Used to validate if a user has been borrowing from any reserve\\r\\n   * @param self The configuration object\\r\\n   * @return True if the user has been borrowing any reserve, false otherwise\\r\\n   **/\\r\\n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\\r\\n    return self.data \\u0026 BORROWING_MASK != 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Used to validate if a user has not been using any reserve\\r\\n   * @param self The configuration object\\r\\n   * @return True if the user has been borrowing any reserve, false otherwise\\r\\n   **/\\r\\n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\\r\\n    return self.data == 0;\\r\\n  }\\r\\n}\\r\\n\"},\"ValidationLogic.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\r\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\r\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\r\\nimport {GenericLogic} from \\\"./GenericLogic.sol\\\";\\r\\nimport {WadRayMath} from \\\"./WadRayMath.sol\\\";\\r\\nimport {PercentageMath} from \\\"./PercentageMath.sol\\\";\\r\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\r\\nimport {ReserveConfiguration} from \\\"./ReserveConfiguration.sol\\\";\\r\\nimport {UserConfiguration} from \\\"./UserConfiguration.sol\\\";\\r\\nimport {Errors} from \\\"./Errors.sol\\\";\\r\\nimport {Helpers} from \\\"./Helpers.sol\\\";\\r\\nimport {IReserveInterestRateStrategy} from \\\"./IReserveInterestRateStrategy.sol\\\";\\r\\nimport {DataTypes} from \\\"./DataTypes.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ReserveLogic library\\r\\n * @author Lever\\r\\n * @notice Implements functions to validate the different actions of the protocol\\r\\n */\\r\\nlibrary ValidationLogic {\\r\\n    using ReserveLogic for DataTypes.ReserveData;\\r\\n    using SafeMath for uint256;\\r\\n    using WadRayMath for uint256;\\r\\n    using PercentageMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\r\\n    using UserConfiguration for DataTypes.UserConfigurationMap;\\r\\n\\r\\n    uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\\r\\n    uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\\r\\n\\r\\n    /**\\r\\n     * @dev Validates a deposit action\\r\\n     * @param reserve The reserve object on which the user is depositing\\r\\n     * @param amount The amount to be deposited\\r\\n     */\\r\\n    function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\\r\\n        (bool isActive, bool isFrozen,) = reserve.configuration.getFlags();\\r\\n\\r\\n        require(amount != 0, Errors.VL_INVALID_AMOUNT);\\r\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\r\\n        require(!isFrozen, Errors.VL_RESERVE_FROZEN);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates a withdraw action\\r\\n     * @param reserveAddress The address of the reserve\\r\\n     * @param amount The amount to be withdrawn\\r\\n     * @param userBalance The balance of the user\\r\\n     * @param reservesData The reserves state\\r\\n     * @param userConfig The user configuration\\r\\n     * @param reserves The addresses of the reserves\\r\\n     * @param reservesCount The number of reserves\\r\\n     * @param oracle The price oracle\\r\\n     */\\r\\n    function validateWithdraw(\\r\\n        address reserveAddress,\\r\\n        uint256 amount,\\r\\n        uint256 userBalance,\\r\\n        mapping(address =\\u003e DataTypes.ReserveData) storage reservesData,\\r\\n        DataTypes.UserConfigurationMap storage userConfig,\\r\\n        mapping(uint256 =\\u003e address) storage reserves,\\r\\n        uint256 reservesCount,\\r\\n        address oracle\\r\\n    ) external view {\\r\\n        require(amount != 0, Errors.VL_INVALID_AMOUNT);\\r\\n        require(amount \\u003c= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\\r\\n\\r\\n        (bool isActive, ,) = reservesData[reserveAddress].configuration.getFlags();\\r\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\r\\n\\r\\n        require(\\r\\n            GenericLogic.balanceDecreaseAllowed(\\r\\n                reserveAddress,\\r\\n                msg.sender,\\r\\n                amount,\\r\\n                reservesData,\\r\\n                userConfig,\\r\\n                reserves,\\r\\n                reservesCount,\\r\\n                oracle\\r\\n            ),\\r\\n            Errors.VL_TRANSFER_NOT_ALLOWED\\r\\n        );\\r\\n    }\\r\\n\\r\\n    struct ValidateBorrowLocalVars {\\r\\n        uint256 currentLtv;\\r\\n        uint256 currentLiquidationThreshold;\\r\\n        uint256 amountOfCollateralNeededETH;\\r\\n        uint256 userCollateralBalanceETH;\\r\\n        uint256 userBorrowBalanceETH;\\r\\n        uint256 availableLiquidity;\\r\\n        uint256 healthFactor;\\r\\n        bool isActive;\\r\\n        bool isFrozen;\\r\\n        bool borrowingEnabled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates a borrow action\\r\\n     * @param reserve The reserve state from which the user is borrowing\\r\\n     * @param userAddress The address of the user\\r\\n     * @param amount The amount to be borrowed\\r\\n     * @param amountInETH The amount to be borrowed, in ETH\\r\\n     * @param reservesData The state of all the reserves\\r\\n     * @param userConfig The state of the user for the specific reserve\\r\\n     * @param reserves The addresses of all the active reserves\\r\\n     * @param oracle The price oracle\\r\\n     */\\r\\n\\r\\n    function validateBorrow(\\r\\n        DataTypes.ReserveData storage reserve,\\r\\n        address userAddress,\\r\\n        uint256 amount,\\r\\n        uint256 amountInETH,\\r\\n        mapping(address =\\u003e DataTypes.ReserveData) storage reservesData,\\r\\n        DataTypes.UserConfigurationMap storage userConfig,\\r\\n        mapping(uint256 =\\u003e address) storage reserves,\\r\\n        uint256 reservesCount,\\r\\n        address oracle\\r\\n    ) external view {\\r\\n        ValidateBorrowLocalVars memory vars;\\r\\n\\r\\n        (vars.isActive, vars.isFrozen, vars.borrowingEnabled) = reserve\\r\\n            .configuration\\r\\n            .getFlags();\\r\\n\\r\\n        require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\\r\\n        require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\\r\\n        require(amount != 0, Errors.VL_INVALID_AMOUNT);\\r\\n\\r\\n        require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\\r\\n\\r\\n        (\\r\\n            vars.userCollateralBalanceETH,\\r\\n            vars.userBorrowBalanceETH,\\r\\n            vars.currentLtv,\\r\\n            vars.currentLiquidationThreshold,\\r\\n            vars.healthFactor\\r\\n        ) = GenericLogic.calculateUserAccountData(\\r\\n            userAddress,\\r\\n            reservesData,\\r\\n            userConfig,\\r\\n            reserves,\\r\\n            reservesCount,\\r\\n            oracle\\r\\n        );\\r\\n\\r\\n        require(vars.userCollateralBalanceETH \\u003e 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\\r\\n\\r\\n        require(vars.healthFactor \\u003e GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD, Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD);\\r\\n\\r\\n        //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\\r\\n        vars.amountOfCollateralNeededETH = vars\\r\\n            .userBorrowBalanceETH\\r\\n            .add(amountInETH)\\r\\n            .percentDiv(vars.currentLtv); //LTV is calculated in percentage\\r\\n\\r\\n        require(\\r\\n            vars.amountOfCollateralNeededETH \\u003c= vars.userCollateralBalanceETH,\\r\\n            Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\\r\\n        );\\r\\n    }\\r\\n\\r\\n    struct ValidateSwapLocalVars {\\r\\n        uint256 currentLtv;\\r\\n        uint256 amountOfCollateralNeededETH;\\r\\n        uint256 userCollateralBalanceETH;\\r\\n        uint256 userBorrowBalanceETH;\\r\\n        uint256 healthFactor;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates a swap action\\r\\n     * @param userAddress The address of the user\\r\\n     * @param reservesData The state of all the reserves\\r\\n     * @param userConfig The state of the user for the specific reserve\\r\\n     * @param reserves The addresses of all the active reserves\\r\\n     * @param oracle The price oracle\\r\\n     */\\r\\n\\r\\n    function validateSwap(\\r\\n        address userAddress,\\r\\n        mapping(address =\\u003e DataTypes.ReserveData) storage reservesData,\\r\\n        DataTypes.UserConfigurationMap storage userConfig,\\r\\n        mapping(uint256 =\\u003e address) storage reserves,\\r\\n        uint256 reservesCount,\\r\\n        address oracle\\r\\n    ) external view {\\r\\n        ValidateSwapLocalVars memory vars;\\r\\n\\r\\n        (\\r\\n            vars.userCollateralBalanceETH,\\r\\n            vars.userBorrowBalanceETH,\\r\\n            vars.currentLtv,\\r\\n            ,\\r\\n            vars.healthFactor\\r\\n        ) = GenericLogic.calculateUserAccountData(\\r\\n            userAddress,\\r\\n            reservesData,\\r\\n            userConfig,\\r\\n            reserves,\\r\\n            reservesCount,\\r\\n            oracle\\r\\n        );\\r\\n\\r\\n        require(vars.userCollateralBalanceETH \\u003e 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\\r\\n\\r\\n        require(vars.healthFactor \\u003e GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD, Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD);\\r\\n\\r\\n        //the current already borrowed amount requested to calculate the total collateral needed.\\r\\n        vars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.percentDiv(vars.currentLtv); //LTV is calculated in percentage\\r\\n\\r\\n        require(\\r\\n            vars.amountOfCollateralNeededETH \\u003c= vars.userCollateralBalanceETH,\\r\\n            Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates a repay action\\r\\n     * @param reserve The reserve state from which the user is repaying\\r\\n     * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\\r\\n     * @param onBehalfOf The address of the user msg.sender is repaying for\\r\\n     * @param variableDebt The borrow balance of the user\\r\\n     */\\r\\n    function validateRepay(\\r\\n        DataTypes.ReserveData storage reserve,\\r\\n        uint256 amountSent,\\r\\n        address onBehalfOf,\\r\\n        uint256 variableDebt,\\r\\n        uint256 userBalance\\r\\n    ) external view {\\r\\n        bool isActive = reserve.configuration.getActive();\\r\\n\\r\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\r\\n\\r\\n        require(amountSent \\u003e 0, Errors.VL_INVALID_AMOUNT);\\r\\n\\r\\n        require(variableDebt \\u003e 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\\r\\n        require(userBalance \\u003e= amountSent, \\\"deposit is less than debt\\\");\\r\\n\\r\\n        require(\\r\\n            amountSent != uint256(-1) || msg.sender == onBehalfOf,\\r\\n            Errors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Validates the action of setting an asset as collateral\\r\\n     * @param reserve The state of the reserve that the user is enabling or disabling as collateral\\r\\n     * @param reserveAddress The address of the reserve\\r\\n     * @param reservesData The data of all the reserves\\r\\n     * @param userConfig The state of the user for the specific reserve\\r\\n     * @param reserves The addresses of all the active reserves\\r\\n     * @param oracle The price oracle\\r\\n     */\\r\\n    function validateSetUseReserveAsCollateral(\\r\\n        DataTypes.ReserveData storage reserve,\\r\\n        address reserveAddress,\\r\\n        bool useAsCollateral,\\r\\n        mapping(address =\\u003e DataTypes.ReserveData) storage reservesData,\\r\\n        DataTypes.UserConfigurationMap storage userConfig,\\r\\n        mapping(uint256 =\\u003e address) storage reserves,\\r\\n        uint256 reservesCount,\\r\\n        address oracle\\r\\n    ) external view {\\r\\n        uint256 underlyingBalance = IERC20(reserve.xTokenAddress).balanceOf(msg.sender);\\r\\n\\r\\n        require(underlyingBalance \\u003e 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\\r\\n\\r\\n        require(\\r\\n            useAsCollateral ||\\r\\n                GenericLogic.balanceDecreaseAllowed(\\r\\n                    reserveAddress,\\r\\n                    msg.sender,\\r\\n                    underlyingBalance,\\r\\n                    reservesData,\\r\\n                    userConfig,\\r\\n                    reserves,\\r\\n                    reservesCount,\\r\\n                    oracle\\r\\n                ),\\r\\n            Errors.VL_DEPOSIT_ALREADY_IN_USE\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates a flashloan action\\r\\n     * @param assets The assets being flashborrowed\\r\\n     * @param amounts The amounts for each asset being borrowed\\r\\n     **/\\r\\n    function validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure {\\r\\n        require(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n     * @dev Validates the liquidation action\\r\\n     * @param collateralReserve The reserve data of the collateral\\r\\n     * @param principalReserve The reserve data of the principal\\r\\n     * @param userConfig The user configuration\\r\\n     * @param userHealthFactor The user\\u0027s health factor\\r\\n     * @param userVariableDebt Total variable debt balance of the user\\r\\n     **/\\r\\n    function validateLiquidation(\\r\\n        DataTypes.ReserveData storage collateralReserve,\\r\\n        DataTypes.ReserveData storage principalReserve,\\r\\n        DataTypes.UserConfigurationMap storage userConfig,\\r\\n        uint256 userHealthFactor,\\r\\n        uint256 userVariableDebt\\r\\n    ) external view {\\r\\n        require(\\r\\n            collateralReserve.configuration.getActive() \\u0026\\u0026\\r\\n                principalReserve.configuration.getActive(),\\r\\n            Errors.VL_NO_ACTIVE_RESERVE\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            userHealthFactor \\u003c GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\\r\\n            Errors.MPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\\r\\n        );\\r\\n\\r\\n        bool isCollateralEnabled =\\r\\n            collateralReserve.configuration.getLiquidationThreshold() \\u003e 0 \\u0026\\u0026\\r\\n                userConfig.isUsingAsCollateral(collateralReserve.id);\\r\\n\\r\\n        //if collateral isn\\u0027t enabled as collateral by user, it cannot be liquidated\\r\\n        require(\\r\\n            isCollateralEnabled,\\r\\n            Errors.MPCM_COLLATERAL_CANNOT_BE_LIQUIDATED\\r\\n        );\\r\\n        require(\\r\\n            userVariableDebt \\u003e 0,\\r\\n            Errors.MPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates an xToken transfer\\r\\n     * @param from The user from which the xTokens are being transferred\\r\\n     * @param reservesData The state of all the reserves\\r\\n     * @param userConfig The state of the user for the specific reserve\\r\\n     * @param reserves The addresses of all the active reserves\\r\\n     * @param oracle The price oracle\\r\\n     */\\r\\n    function validateTransfer(\\r\\n        address from,\\r\\n        mapping(address =\\u003e DataTypes.ReserveData) storage reservesData,\\r\\n        DataTypes.UserConfigurationMap storage userConfig,\\r\\n        mapping(uint256 =\\u003e address) storage reserves,\\r\\n        uint256 reservesCount,\\r\\n        address oracle\\r\\n    ) internal view {\\r\\n        (, , , , uint256 healthFactor) =\\r\\n            GenericLogic.calculateUserAccountData(\\r\\n                from,\\r\\n                reservesData,\\r\\n                userConfig,\\r\\n                reserves,\\r\\n                reservesCount,\\r\\n                oracle\\r\\n            );\\r\\n\\r\\n        require(\\r\\n            healthFactor \\u003e= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\\r\\n            Errors.VL_TRANSFER_NOT_ALLOWED\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"},\"VariableDebtToken.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IVariableDebtToken} from \\\"./IVariableDebtToken.sol\\\";\\r\\nimport {WadRayMath} from \\\"./WadRayMath.sol\\\";\\r\\nimport {Errors} from \\\"./Errors.sol\\\";\\r\\nimport {DebtTokenBase} from \\\"./DebtTokenBase.sol\\\";\\r\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\r\\nimport {\\r\\n    IMarginPoolAddressesProvider\\r\\n} from \\\"./IMarginPoolAddressesProvider.sol\\\";\\r\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\r\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\\r\\n * available, which can be aplied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n */\\r\\ncontract ReentrancyGuard {\\r\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\r\\n    uint256 private _guardCounter;\\r\\n\\r\\n    constructor() internal {\\r\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\r\\n        // value, which is a more expensive operation.\\r\\n        _guardCounter = 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _guardCounter += 1;\\r\\n        uint256 localCounter = _guardCounter;\\r\\n        _;\\r\\n        require(\\r\\n            localCounter == _guardCounter,\\r\\n            \\\"ReentrancyGuard: reentrant call\\\"\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title VariableDebtToken\\r\\n * @notice Implements a variable debt token to track the borrowing positions of users\\r\\n * at variable rate mode\\r\\n * @author Lever\\r\\n **/\\r\\ncontract VariableDebtToken is DebtTokenBase, IVariableDebtToken, ReentrancyGuard {\\r\\n    using WadRayMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n    uint256 public constant DEBT_TOKEN_REVISION = 0x1;\\r\\n    address public rewardsDistribution;\\r\\n    IERC20 public rewardsToken;\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public rewardsDuration = 30 days;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n    constructor(\\r\\n        address _addressesProvider,\\r\\n        address underlyingAsset,\\r\\n        string memory name,\\r\\n        string memory symbol,\\r\\n        uint8 decimals\\r\\n    )\\r\\n        public\\r\\n        DebtTokenBase(\\r\\n            IMarginPoolAddressesProvider(_addressesProvider).getMarginPool(),\\r\\n            underlyingAsset,\\r\\n            name,\\r\\n            symbol,\\r\\n            decimals\\r\\n        )\\r\\n    {\\r\\n      rewardsDistribution = IMarginPoolAddressesProvider(_addressesProvider).getRewardsDistribution();\\r\\n      rewardsToken = IERC20(IMarginPoolAddressesProvider(_addressesProvider).getLeverToken());\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRewardsDistribution() {\\r\\n        require(\\r\\n            msg.sender == rewardsDistribution,\\r\\n            \\\"Caller is not RewardsDistribution contract\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates the accumulated debt balance of the user\\r\\n     * @return The debt balance of the user\\r\\n     **/\\r\\n    function balanceOf(address user)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 scaledBalance = super.balanceOf(user);\\r\\n\\r\\n        if (scaledBalance == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        return\\r\\n            scaledBalance.rayMul(\\r\\n                POOL.getReserveNormalizedVariableDebt(UNDERLYING_ASSET_ADDRESS)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints debt token to the `onBehalfOf` address\\r\\n     * -  Only callable by the MarginPool\\r\\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\\r\\n     * of credit delegate, or same as `onBehalfOf` otherwise\\r\\n     * @param onBehalfOf The address receiving the debt tokens\\r\\n     * @param amount The amount of debt being minted\\r\\n     * @param index The variable debt index of the reserve\\r\\n     * @return `true` if the the previous balance of the user is 0\\r\\n     **/\\r\\n    function mint(\\r\\n        address user,\\r\\n        address onBehalfOf,\\r\\n        uint256 amount,\\r\\n        uint256 index\\r\\n    ) external override onlyMarginPool updateReward(onBehalfOf) returns (bool) {\\r\\n        if (user != onBehalfOf) {\\r\\n            _decreaseBorrowAllowance(onBehalfOf, user, amount);\\r\\n        }\\r\\n\\r\\n        uint256 previousBalance = super.balanceOf(onBehalfOf);\\r\\n        uint256 amountScaled = amount.rayDiv(index);\\r\\n        require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\\r\\n\\r\\n        _mint(onBehalfOf, amountScaled);\\r\\n        emit Transfer(address(0), onBehalfOf, amount);\\r\\n        emit Mint(user, onBehalfOf, amount, index);\\r\\n\\r\\n        return previousBalance == 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burns user variable debt\\r\\n     * - Only callable by the MarginPool\\r\\n     * @param user The user whose debt is getting burned\\r\\n     * @param amount The amount getting burned\\r\\n     * @param index The variable debt index of the reserve\\r\\n     **/\\r\\n    function burn(\\r\\n        address user,\\r\\n        uint256 amount,\\r\\n        uint256 index\\r\\n    ) external override onlyMarginPool updateReward(user) {\\r\\n        uint256 amountScaled = amount.rayDiv(index);\\r\\n        require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\\r\\n\\r\\n        _burn(user, amountScaled);\\r\\n        emit Transfer(user, address(0), amount);\\r\\n        emit Burn(user, amount, index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the principal debt balance of the user from\\r\\n     * @return The debt balance of the user since the last burn/mint action\\r\\n     **/\\r\\n    function scaledBalanceOf(address user)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return super.balanceOf(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total supply of the variable debt token. Represents the total debt accrued by the users\\r\\n     * @return The total supply\\r\\n     **/\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return\\r\\n            super.totalSupply().rayMul(\\r\\n                POOL.getReserveNormalizedVariableDebt(UNDERLYING_ASSET_ADDRESS)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\r\\n     * @return the scaled total supply\\r\\n     **/\\r\\n    function scaledTotalSupply()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return super.totalSupply();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the principal balance of the user and principal total supply.\\r\\n     * @param user The address of the user\\r\\n     * @return The principal balance of the user\\r\\n     * @return The principal total supply\\r\\n     **/\\r\\n    function getScaledUserBalanceAndSupply(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        return (super.balanceOf(user), super.totalSupply());\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override updateReward(from) updateReward(to) {\\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    function getRewardForDuration() external view returns (uint256) {\\r\\n        return rewardRate.mul(rewardsDuration);\\r\\n    }\\r\\n\\r\\n    function getReward() public nonReentrant updateReward(msg.sender) {\\r\\n      uint256 reward = rewards[msg.sender];\\r\\n      require(reward \\u003e 0);\\r\\n      rewards[msg.sender] = 0;\\r\\n      rewardsToken.safeTransfer(msg.sender, reward);\\r\\n      emit RewardPaid(msg.sender, reward);\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n       function notifyRewardAmount(uint256 reward, uint256 _rewardsDuration)\\r\\n        external\\r\\n        onlyRewardsDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n         // Ensure the provided reward amount is not more than the balance in the contract.\\r\\n        // This keeps the reward rate in the right range, preventing overflows due to\\r\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\r\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\r\\n        uint256 balance = rewardsToken.balanceOf(address(this));\\r\\n        if (block.timestamp \\u003e= periodFinish) {\\r\\n            rewardsDuration = _rewardsDuration;\\r\\n            rewardRate = reward.div(rewardsDuration);\\r\\n            require(\\r\\n                rewardRate \\u003c= balance.div(rewardsDuration),\\r\\n                \\\"Provided reward too high\\\"\\r\\n            );\\r\\n            periodFinish = block.timestamp.add(rewardsDuration);\\r\\n        } else {\\r\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n            uint256 leftover = remaining.mul(rewardRate);\\r\\n            rewardRate = reward.add(leftover).div(remaining);\\r\\n            require(\\r\\n                rewardRate \\u003c= balance.div(remaining),\\r\\n                \\\"Provided reward too high\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n\\r\\n        lastUpdateTime = block.timestamp;\\r\\n        emit RewardAdded(reward, _rewardsDuration);\\r\\n    }\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event RewardAdded(uint256 reward, uint256 _rewardsDuration);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n}\\r\\n\"},\"VariableTokensHelper.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {VariableDebtToken} from \\u0027./VariableDebtToken.sol\\u0027;\\r\\nimport {Ownable} from \\u0027./Ownable.sol\\u0027;\\r\\nimport {StringLib} from \\u0027./StringLib.sol\\u0027;\\r\\n\\r\\ncontract VariableTokensHelper is Ownable {\\r\\n  address payable private pool;\\r\\n  address private addressesProvider;\\r\\n  event deployedContracts(address variableToken);\\r\\n\\r\\n  constructor(address payable _pool, address _addressesProvider) public {\\r\\n    pool = _pool;\\r\\n    addressesProvider = _addressesProvider; \\r\\n  }\\r\\n\\r\\n  function initDeployment(\\r\\n    address[] calldata tokens,\\r\\n    string[] calldata symbols,\\r\\n    uint8[] calldata decimals\\r\\n  ) external onlyOwner {\\r\\n    require(tokens.length == symbols.length, \\u0027Arrays not same length\\u0027);\\r\\n    require(pool != address(0), \\u0027Pool can not be zero address\\u0027);\\r\\n    for (uint256 i = 0; i \\u003c tokens.length; i++) {\\r\\n      emit deployedContracts(\\r\\n        address(\\r\\n          new VariableDebtToken(\\r\\n            addressesProvider,\\r\\n            tokens[i],\\r\\n            StringLib.concat(\\u0027Lever variable debt bearing \\u0027, symbols[i]),\\r\\n            StringLib.concat(\\u0027d\\u0027, symbols[i]),\\r\\n            decimals[i]\\r\\n          )\\r\\n        )\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"},\"VersionedInitializable.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @title VersionedInitializable\\r\\n *\\r\\n * @dev Helper contract to implement initializer functions. To use it, replace\\r\\n * the constructor with a function that has the `initializer` modifier.\\r\\n * WARNING: Unlike constructors, initializer functions must be manually\\r\\n * invoked. This applies both to deploying an Initializable contract, as well\\r\\n * as extending an Initializable contract via inheritance.\\r\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\r\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\r\\n * because this is not dealt with automatically as with constructors.\\r\\n *\\r\\n * @author Lever, inspired by the OpenZeppelin Initializable contract\\r\\n */\\r\\nabstract contract VersionedInitializable {\\r\\n  /**\\r\\n   * @dev Indicates that the contract has been initialized.\\r\\n   */\\r\\n  uint256 private lastInitializedRevision = 0;\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract is in the process of being initialized.\\r\\n   */\\r\\n  bool private initializing;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to use in the initializer function of a contract.\\r\\n   */\\r\\n  modifier initializer() {\\r\\n    uint256 revision = getRevision();\\r\\n    require(\\r\\n      initializing || isConstructor() || revision \\u003e lastInitializedRevision,\\r\\n      \\u0027Contract instance has already been initialized\\u0027\\r\\n    );\\r\\n\\r\\n    bool isTopLevelCall = !initializing;\\r\\n    if (isTopLevelCall) {\\r\\n      initializing = true;\\r\\n      lastInitializedRevision = revision;\\r\\n    }\\r\\n\\r\\n    _;\\r\\n\\r\\n    if (isTopLevelCall) {\\r\\n      initializing = false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev returns the revision number of the contract\\r\\n   * Needs to be defined in the inherited class as a constant.\\r\\n   **/\\r\\n  function getRevision() internal pure virtual returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns true if and only if the function is running in the constructor\\r\\n   **/\\r\\n  function isConstructor() private view returns (bool) {\\r\\n    // extcodesize checks the size of the code stored in an address, and\\r\\n    // address returns the current address. Since the code is still not\\r\\n    // deployed when running a constructor, any checks on its code size will\\r\\n    // yield zero, making it an effective way to detect if a contract is\\r\\n    // under construction or not.\\r\\n    uint256 cs;\\r\\n    //solium-disable-next-line\\r\\n    assembly {\\r\\n      cs := extcodesize(address())\\r\\n    }\\r\\n    return cs == 0;\\r\\n  }\\r\\n\\r\\n  // Reserved storage space to allow for layout changes in the future.\\r\\n  uint256[50] private ______gap;\\r\\n}\\r\\n\"},\"WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {Errors} from \\u0027./Errors.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title WadRayMath library\\r\\n * @author Lever\\r\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\r\\n **/\\r\\n\\r\\nlibrary WadRayMath {\\r\\n  uint256 internal constant WAD = 1e18;\\r\\n  uint256 internal constant halfWAD = WAD / 2;\\r\\n\\r\\n  uint256 internal constant RAY = 1e27;\\r\\n  uint256 internal constant halfRAY = RAY / 2;\\r\\n\\r\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\r\\n\\r\\n  /**\\r\\n   * @return One ray, 1e27\\r\\n   **/\\r\\n  function ray() internal pure returns (uint256) {\\r\\n    return RAY;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return One wad, 1e18\\r\\n   **/\\r\\n\\r\\n  function wad() internal pure returns (uint256) {\\r\\n    return WAD;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Half ray, 1e27/2\\r\\n   **/\\r\\n  function halfRay() internal pure returns (uint256) {\\r\\n    return halfRAY;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Half ray, 1e18/2\\r\\n   **/\\r\\n  function halfWad() internal pure returns (uint256) {\\r\\n    return halfWAD;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\r\\n   * @param a Wad\\r\\n   * @param b Wad\\r\\n   * @return The result of a*b, in wad\\r\\n   **/\\r\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0 || b == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    require(a \\u003c= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\r\\n\\r\\n    return (a * b + halfWAD) / WAD;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Divides two wad, rounding half up to the nearest wad\\r\\n   * @param a Wad\\r\\n   * @param b Wad\\r\\n   * @return The result of a/b, in wad\\r\\n   **/\\r\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\r\\n    uint256 halfB = b / 2;\\r\\n\\r\\n    require(a \\u003c= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\\r\\n\\r\\n    return (a * WAD + halfB) / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\r\\n   * @param a Ray\\r\\n   * @param b Ray\\r\\n   * @return The result of a*b, in ray\\r\\n   **/\\r\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0 || b == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    require(a \\u003c= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\r\\n\\r\\n    return (a * b + halfRAY) / RAY;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Divides two ray, rounding half up to the nearest ray\\r\\n   * @param a Ray\\r\\n   * @param b Ray\\r\\n   * @return The result of a/b, in ray\\r\\n   **/\\r\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\r\\n    uint256 halfB = b / 2;\\r\\n\\r\\n    require(a \\u003c= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\\r\\n\\r\\n    return (a * RAY + halfB) / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Casts ray down to wad\\r\\n   * @param a Ray\\r\\n   * @return a casted to wad, rounded half up to the nearest wad\\r\\n   **/\\r\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\r\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\r\\n    uint256 result = halfRatio + a;\\r\\n    require(result \\u003e= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\\r\\n\\r\\n    return result / WAD_RAY_RATIO;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Converts wad up to ray\\r\\n   * @param a Wad\\r\\n   * @return a converted in ray\\r\\n   **/\\r\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\r\\n    uint256 result = a * WAD_RAY_RATIO;\\r\\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\\r\\n    return result;\\r\\n  }\\r\\n}\\r\\n\"},\"WETHGateway.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {Ownable} from \\u0027./Ownable.sol\\u0027;\\r\\nimport {IERC20} from \\u0027./IERC20.sol\\u0027;\\r\\nimport {IWETH} from \\u0027./IWETH.sol\\u0027;\\r\\nimport {IWETHGateway} from \\u0027./IWETHGateway.sol\\u0027;\\r\\nimport {IMarginPool} from \\u0027./IMarginPool.sol\\u0027;\\r\\nimport {IXToken} from \\u0027./IXToken.sol\\u0027;\\r\\nimport {ICreditDelegationToken} from \\u0027./ICreditDelegationToken.sol\\u0027;\\r\\nimport {ReserveConfiguration} from \\u0027./ReserveConfiguration.sol\\u0027;\\r\\nimport {UserConfiguration} from \\u0027./UserConfiguration.sol\\u0027;\\r\\nimport {Helpers} from \\u0027./Helpers.sol\\u0027;\\r\\nimport {DataTypes} from \\u0027./DataTypes.sol\\u0027;\\r\\n\\r\\ncontract WETHGateway is IWETHGateway, Ownable {\\r\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\r\\n  using UserConfiguration for DataTypes.UserConfigurationMap;\\r\\n\\r\\n  IWETH internal immutable WETH;\\r\\n  IMarginPool internal immutable POOL;\\r\\n  IXToken internal immutable xWETH;\\r\\n  ICreditDelegationToken internal immutable dWETH;\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the WETH address and the MarginPoolAddressesProvider address. Infinite approves margin pool.\\r\\n   * @param weth Address of the Wrapped Ether contract\\r\\n   * @param pool Address of the MarginPool contract\\r\\n   **/\\r\\n  constructor(address weth, address pool) public {\\r\\n    IMarginPool poolInstance = IMarginPool(pool);\\r\\n    WETH = IWETH(weth);\\r\\n    POOL = poolInstance;\\r\\n    xWETH = IXToken(poolInstance.getReserveData(weth).xTokenAddress);\\r\\n    dWETH = ICreditDelegationToken(poolInstance.getReserveData(weth).variableDebtTokenAddress);\\r\\n    IWETH(weth).approve(pool, uint256(-1));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev deposits WETH into the reserve, using native ETH. A corresponding amount of the overlying asset (xTokens)\\r\\n   * is minted.\\r\\n   * @param onBehalfOf address of the user who will receive the xTokens representing the deposit\\r\\n   **/\\r\\n  function depositETH(address onBehalfOf) external payable override {\\r\\n    WETH.deposit{value: msg.value}();\\r\\n    POOL.deposit(address(WETH), msg.value, onBehalfOf);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev withdraws the WETH _reserves of msg.sender.\\r\\n   * @param amount amount of xWETH to withdraw and receive native ETH\\r\\n   * @param to address of the user who will receive native ETH\\r\\n   */\\r\\n  function withdrawETH(uint256 amount, address to) external override {\\r\\n    uint256 userBalance = xWETH.balanceOf(msg.sender);\\r\\n    uint256 amountToWithdraw = amount;\\r\\n\\r\\n    // if amount is equal to uint(-1), the user wants to redeem everything\\r\\n    if (amount == type(uint256).max) {\\r\\n      amountToWithdraw = userBalance;\\r\\n    }\\r\\n    xWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\\r\\n    POOL.withdraw(address(WETH), amountToWithdraw, address(this));\\r\\n    WETH.withdraw(amountToWithdraw);\\r\\n    _safeTransferETH(to, amountToWithdraw);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev borrow WETH, unwraps to ETH and send both the ETH and DebtTokens to msg.sender, via `approveDelegation` and onBehalf argument in `MarginPool.borrow`.\\r\\n   * @param amount the amount of ETH to borrow\\r\\n   */\\r\\n  function borrowETH(\\r\\n    uint256 amount\\r\\n  ) external override {\\r\\n    POOL.borrow(address(WETH), amount, msg.sender);\\r\\n    WETH.withdraw(amount);\\r\\n    _safeTransferETH(msg.sender, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev transfer ETH to an address, revert if it fails.\\r\\n   * @param to recipient of the transfer\\r\\n   * @param value the amount to send\\r\\n   */\\r\\n  function _safeTransferETH(address to, uint256 value) internal {\\r\\n    (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n    require(success, \\u0027ETH_TRANSFER_FAILED\\u0027);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\\r\\n   * direct transfers to the contract address.\\r\\n   * @param token token to transfer\\r\\n   * @param to recipient of the transfer\\r\\n   * @param amount amount to send\\r\\n   */\\r\\n  function emergencyTokenTransfer(\\r\\n    address token,\\r\\n    address to,\\r\\n    uint256 amount\\r\\n  ) external onlyOwner {\\r\\n    IERC20(token).transfer(to, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\\r\\n   * due selfdestructs or transfer ether to pre-computated contract address before deployment.\\r\\n   * @param to recipient of the transfer\\r\\n   * @param amount amount to send\\r\\n   */\\r\\n  function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\\r\\n    _safeTransferETH(to, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Get WETH address used by WETHGateway\\r\\n   */\\r\\n  function getWETHAddress() external view returns (address) {\\r\\n    return address(WETH);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Get xWETH address used by WETHGateway\\r\\n   */\\r\\n  function getXWETHAddress() external view returns (address) {\\r\\n    return address(xWETH);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Get MarginPool address used by WETHGateway\\r\\n   */\\r\\n  function getMarginPoolAddress() external view returns (address) {\\r\\n    return address(POOL);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\\r\\n   */\\r\\n  receive() external payable {\\r\\n    require(msg.sender == address(WETH), \\u0027Receive not allowed\\u0027);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Revert fallback calls\\r\\n   */\\r\\n  fallback() external payable {\\r\\n    revert(\\u0027Fallback not allowed\\u0027);\\r\\n  }\\r\\n}\\r\\n\"},\"XToken.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\r\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\r\\nimport {IMarginPool} from \\\"./IMarginPool.sol\\\";\\r\\nimport {IXToken} from \\\"./IXToken.sol\\\";\\r\\nimport {WadRayMath} from \\\"./WadRayMath.sol\\\";\\r\\nimport {Errors} from \\\"./Errors.sol\\\";\\r\\nimport {IncentivizedERC20} from \\\"./IncentivizedERC20.sol\\\";\\r\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\r\\nimport {\\r\\n    IMarginPoolAddressesProvider\\r\\n} from \\\"./IMarginPoolAddressesProvider.sol\\\";\\r\\nimport {Address} from \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\\r\\n * available, which can be aplied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n */\\r\\ncontract ReentrancyGuard {\\r\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\r\\n    uint256 private _guardCounter;\\r\\n\\r\\n    constructor() internal {\\r\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\r\\n        // value, which is a more expensive operation.\\r\\n        _guardCounter = 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _guardCounter += 1;\\r\\n        uint256 localCounter = _guardCounter;\\r\\n        _;\\r\\n        require(\\r\\n            localCounter == _guardCounter,\\r\\n            \\\"ReentrancyGuard: reentrant call\\\"\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Lever ERC20 XToken\\r\\n * @dev Implementation of the interest bearing token for the Lever protocol\\r\\n * @author Lever\\r\\n */\\r\\ncontract XToken is\\r\\n    IncentivizedERC20,\\r\\n    IXToken,\\r\\n    ReentrancyGuard\\r\\n{\\r\\n    using WadRayMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n    address public rewardsDistribution;\\r\\n    IERC20 public rewardsToken;\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public rewardsDuration = 30 days;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n    bytes public constant EIP712_REVISION = bytes(\\\"1\\\");\\r\\n    bytes32 internal constant EIP712_DOMAIN =\\r\\n        keccak256(\\r\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\r\\n        );\\r\\n    bytes32 public constant PERMIT_TYPEHASH =\\r\\n        keccak256(\\r\\n            \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\r\\n        );\\r\\n\\r\\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\\r\\n    address public immutable UNDERLYING_ASSET_ADDRESS;\\r\\n    address public immutable RESERVE_TREASURY_ADDRESS;\\r\\n    IMarginPool public immutable POOL;\\r\\n    IMarginPoolAddressesProvider public addressesProvider;\\r\\n\\r\\n    /// @dev owner =\\u003e next valid nonce to submit with permit()\\r\\n    mapping(address =\\u003e uint256) public _nonces;\\r\\n\\r\\n    bytes32 public DOMAIN_SEPARATOR;\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRewardsDistribution() {\\r\\n        require(\\r\\n            msg.sender == rewardsDistribution,\\r\\n            \\\"Caller is not RewardsDistribution contract\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyMarginPool {\\r\\n        require(\\r\\n            _msgSender() == address(POOL),\\r\\n            Errors.CT_CALLER_MUST_BE_MARGIN_POOL\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _addressesProvider,\\r\\n        address underlyingAssetAddress,\\r\\n        string memory tokenName,\\r\\n        string memory tokenSymbol,\\r\\n        uint8 decimals\\r\\n    ) public IncentivizedERC20(tokenName, tokenSymbol, decimals) {\\r\\n        addressesProvider = IMarginPoolAddressesProvider(_addressesProvider);\\r\\n        POOL = IMarginPool(addressesProvider.getMarginPool());\\r\\n        UNDERLYING_ASSET_ADDRESS = underlyingAssetAddress;\\r\\n        RESERVE_TREASURY_ADDRESS = addressesProvider.getTreasuryAddress();\\r\\n        rewardsDistribution = addressesProvider.getRewardsDistribution();\\r\\n        rewardsToken = IERC20(IMarginPoolAddressesProvider(_addressesProvider).getLeverToken());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burns xTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\r\\n     * - Only callable by the MarginPool, as extra state updates there need to be managed\\r\\n     * @param user The owner of the xTokens, getting them burned\\r\\n     * @param receiverOfUnderlying The address that will receive the underlying\\r\\n     * @param amount The amount being burned\\r\\n     * @param index The new liquidity index of the reserve\\r\\n     **/\\r\\n    function burn(\\r\\n        address user,\\r\\n        address receiverOfUnderlying,\\r\\n        uint256 amount,\\r\\n        uint256 index\\r\\n    ) external override onlyMarginPool updateReward(user) {\\r\\n        uint256 amountScaled = amount.rayDiv(index);\\r\\n        require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\\r\\n        _burn(user, amountScaled);\\r\\n        if (receiverOfUnderlying != address(this)) {\\r\\n            IERC20(UNDERLYING_ASSET_ADDRESS).safeTransfer(\\r\\n                receiverOfUnderlying,\\r\\n                amount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit Transfer(user, address(0), amount);\\r\\n        emit Burn(user, receiverOfUnderlying, amount, index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `amount` xTokens to `user`\\r\\n     * - Only callable by the MarginPool, as extra state updates there need to be managed\\r\\n     * @param user The address receiving the minted tokens\\r\\n     * @param amount The amount of tokens getting minted\\r\\n     * @param index The new liquidity index of the reserve\\r\\n     * @return `true` if the the previous balance of the user was 0\\r\\n     */\\r\\n    function mint(\\r\\n        address user,\\r\\n        uint256 amount,\\r\\n        uint256 index\\r\\n    ) external override onlyMarginPool updateReward(user) returns (bool) {\\r\\n        uint256 previousBalance = super.balanceOf(user);\\r\\n\\r\\n        uint256 amountScaled = amount.rayDiv(index);\\r\\n        require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\\r\\n        _mint(user, amountScaled);\\r\\n        emit Transfer(address(0), user, amount);\\r\\n        emit Mint(user, amount, index);\\r\\n\\r\\n        return previousBalance == 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints xTokens to the reserve treasury\\r\\n     * - Only callable by the MarginPool\\r\\n     * @param amount The amount of tokens getting minted\\r\\n     * @param index The new liquidity index of the reserve\\r\\n     */\\r\\n    function mintToTreasury(uint256 amount, uint256 index)\\r\\n        external\\r\\n        override\\r\\n        onlyMarginPool\\r\\n        updateReward(RESERVE_TREASURY_ADDRESS)\\r\\n    {\\r\\n        if (amount == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Compared to the normal mint, we don\\u0027t check for rounding errors.\\r\\n        // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\\r\\n        // In that case, the treasury will experience a (very small) loss, but it\\r\\n        // wont cause potentially valid transactions to fail.\\r\\n        _mint(RESERVE_TREASURY_ADDRESS, amount.rayDiv(index));\\r\\n        emit Transfer(address(0), RESERVE_TREASURY_ADDRESS, amount);\\r\\n        emit Mint(RESERVE_TREASURY_ADDRESS, amount, index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers xTokens in the event of a borrow being liquidated, in case the liquidators reclaims the xToken\\r\\n     * - Only callable by the MarginPool\\r\\n     * @param from The address getting liquidated, current owner of the xTokens\\r\\n     * @param to The recipient\\r\\n     * @param value The amount of tokens getting transferred\\r\\n     **/\\r\\n    function transferOnLiquidation(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external override onlyMarginPool updateReward(from) updateReward(to) {\\r\\n        // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted\\r\\n        // so no need to emit a specific event here\\r\\n        _transfer(from, to, value, false);\\r\\n        emit Transfer(from, to, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates the balance of the user: principal balance + interest generated by the principal\\r\\n     * @param user The user whose balance is calculated\\r\\n     * @return The balance of the user\\r\\n     **/\\r\\n    function balanceOf(address user)\\r\\n        public\\r\\n        view\\r\\n        override(IncentivizedERC20, IERC20)\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            super.balanceOf(user).rayMul(\\r\\n                POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\r\\n     * updated stored balance divided by the reserve\\u0027s liquidity index at the moment of the update\\r\\n     * @param user The user whose balance is calculated\\r\\n     * @return The scaled balance of the user\\r\\n     **/\\r\\n    function scaledBalanceOf(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return super.balanceOf(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the scaled balance of the user and the scaled total supply.\\r\\n     * @param user The address of the user\\r\\n     * @return The scaled balance of the user\\r\\n     * @return The scaled balance and the scaled total supply\\r\\n     **/\\r\\n    function getScaledUserBalanceAndSupply(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        return (super.balanceOf(user), super.totalSupply());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev calculates the total supply of the specific xToken\\r\\n     * since the balance of every single user increases over time, the total supply\\r\\n     * does that too.\\r\\n     * @return the current total supply\\r\\n     **/\\r\\n    function totalSupply()\\r\\n        public\\r\\n        view\\r\\n        override(IncentivizedERC20, IERC20)\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 currentSupplyScaled = super.totalSupply();\\r\\n\\r\\n        if (currentSupplyScaled == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        return\\r\\n            currentSupplyScaled.rayMul(\\r\\n                POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\r\\n     * @return the scaled total supply\\r\\n     **/\\r\\n    function scaledTotalSupply()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return super.totalSupply();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers the underlying asset to `target`. Used by the MarginPool to transfer\\r\\n     * assets in borrow(), withdraw()\\r\\n     * @param target The recipient of the xTokens\\r\\n     * @param amount The amount getting transferred\\r\\n     * @return The amount transferred\\r\\n     **/\\r\\n    function transferUnderlyingTo(address target, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyMarginPool\\r\\n        returns (uint256)\\r\\n    {\\r\\n        IERC20(UNDERLYING_ASSET_ADDRESS).safeTransfer(target, amount);\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev implements the permit function as for\\r\\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\\r\\n     * @param owner The owner of the funds\\r\\n     * @param spender The spender\\r\\n     * @param value The amount\\r\\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\\r\\n     * @param v Signature param\\r\\n     * @param s Signature param\\r\\n     * @param r Signature param\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external {\\r\\n        require(owner != address(0), \\\"INVALID_OWNER\\\");\\r\\n        //solium-disable-next-line\\r\\n        require(block.timestamp \\u003c= deadline, \\\"INVALID_EXPIRATION\\\");\\r\\n        uint256 currentValidNonce = _nonces[owner];\\r\\n        bytes32 digest =\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    \\\"\\\\x19\\\\x01\\\",\\r\\n                    DOMAIN_SEPARATOR,\\r\\n                    keccak256(\\r\\n                        abi.encode(\\r\\n                            PERMIT_TYPEHASH,\\r\\n                            owner,\\r\\n                            spender,\\r\\n                            value,\\r\\n                            currentValidNonce,\\r\\n                            deadline\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        require(owner == ecrecover(digest, v, r, s), \\\"INVALID_SIGNATURE\\\");\\r\\n        _nonces[owner] = currentValidNonce.add(1);\\r\\n        _approve(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers the xTokens between two users. Validates the transfer\\r\\n     * (ie checks for valid HF after the transfer) if required\\r\\n     * @param from The source address\\r\\n     * @param to The destination address\\r\\n     * @param amount The amount getting transferred\\r\\n     * @param validate `true` if the transfer needs to be validated\\r\\n     **/\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        bool validate\\r\\n    ) internal updateReward(from) updateReward(to) {\\r\\n        uint256 index =\\r\\n            POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS);\\r\\n\\r\\n        uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\\r\\n        uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\\r\\n\\r\\n        super._transfer(from, to, amount.rayDiv(index));\\r\\n        if (validate) {\\r\\n            POOL.finalizeTransfer(\\r\\n                UNDERLYING_ASSET_ADDRESS,\\r\\n                from,\\r\\n                to,\\r\\n                amount,\\r\\n                fromBalanceBefore,\\r\\n                toBalanceBefore\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit BalanceTransfer(from, to, amount, index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\\r\\n     * @param from The source address\\r\\n     * @param to The destination address\\r\\n     * @param amount The amount getting transferred\\r\\n     **/\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        _transfer(from, to, amount, true);\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    function getRewardForDuration() external view returns (uint256) {\\r\\n        return rewardRate.mul(rewardsDuration);\\r\\n    }\\r\\n\\r\\n    function getReward() public nonReentrant updateReward(msg.sender) {\\r\\n        uint256 reward = rewards[msg.sender];\\r\\n        require(reward \\u003e 0);\\r\\n        rewards[msg.sender] = 0;\\r\\n        rewardsToken.safeTransfer(msg.sender, reward);\\r\\n        emit RewardPaid(msg.sender, reward);\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward, uint256 _rewardsDuration)\\r\\n        external\\r\\n        onlyRewardsDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\r\\n        // This keeps the reward rate in the right range, preventing overflows due to\\r\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\r\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\r\\n        uint256 balance = rewardsToken.balanceOf(address(this));\\r\\n        if (block.timestamp \\u003e= periodFinish) {\\r\\n            rewardsDuration = _rewardsDuration;\\r\\n            rewardRate = reward.div(rewardsDuration);\\r\\n            require(\\r\\n                rewardRate \\u003c= balance.div(rewardsDuration),\\r\\n                \\\"Provided reward too high\\\"\\r\\n            );\\r\\n            periodFinish = block.timestamp.add(rewardsDuration);\\r\\n        } else {\\r\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n            uint256 leftover = remaining.mul(rewardRate);\\r\\n            rewardRate = reward.add(leftover).div(remaining);\\r\\n            require(\\r\\n                rewardRate \\u003c= balance.div(remaining),\\r\\n                \\\"Provided reward too high\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        lastUpdateTime = block.timestamp;\\r\\n        emit RewardAdded(reward, _rewardsDuration);\\r\\n    }\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event RewardAdded(uint256 reward, uint256 _rewardsDuration);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n}\\r\\n\"},\"XTokensAndRatesHelper.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {IMarginPoolAddressesProvider} from \\u0027./IMarginPoolAddressesProvider.sol\\u0027;\\r\\nimport {MarginPoolConfigurator} from \\u0027./MarginPoolConfigurator.sol\\u0027;\\r\\nimport {XToken} from \\u0027./XToken.sol\\u0027;\\r\\nimport {\\r\\n  DefaultReserveInterestRateStrategy\\r\\n} from \\u0027./DefaultReserveInterestRateStrategy.sol\\u0027;\\r\\nimport {Ownable} from \\u0027./Ownable.sol\\u0027;\\r\\nimport {StringLib} from \\u0027./StringLib.sol\\u0027;\\r\\n\\r\\ncontract XTokensAndRatesHelper is Ownable {\\r\\n  address payable private pool;\\r\\n  address private addressesProvider;\\r\\n  address private poolConfigurator;\\r\\n  event deployedContracts(address xToken, address strategy);\\r\\n\\r\\n  constructor(\\r\\n    address _addressesProvider,\\r\\n    address _poolConfigurator\\r\\n  ) public {\\r\\n    addressesProvider = _addressesProvider;\\r\\n    poolConfigurator = _poolConfigurator;\\r\\n  }\\r\\n\\r\\n \\r\\n  function initDeployment(\\r\\n    address[] calldata assets,\\r\\n    string[] calldata symbols,\\r\\n    uint256[4][] calldata rates,\\r\\n    uint8[] calldata decimals\\r\\n  ) external onlyOwner {\\r\\n    require(assets.length == symbols.length, \\u0027t Arrays not same length\\u0027);\\r\\n    require(rates.length == symbols.length, \\u0027r Arrays not same length\\u0027);\\r\\n    for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n      emit deployedContracts(\\r\\n        address(\\r\\n          new XToken(\\r\\n            addressesProvider,\\r\\n            assets[i],\\r\\n            StringLib.concat(\\u0027Lever interest bearing \\u0027, symbols[i]),\\r\\n            StringLib.concat(\\u0027x\\u0027, symbols[i]),\\r\\n            decimals[i]\\r\\n          )\\r\\n        ),\\r\\n        address(\\r\\n          new DefaultReserveInterestRateStrategy(\\r\\n            IMarginPoolAddressesProvider(addressesProvider),\\r\\n            rates[i][0],\\r\\n            rates[i][1],\\r\\n            rates[i][2],\\r\\n            rates[i][3]\\r\\n          )\\r\\n        )\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function initReserve(\\r\\n    address[] calldata variables,\\r\\n    address[] calldata xTokens,\\r\\n    address[] calldata strategies,\\r\\n    uint8[] calldata reserveDecimals\\r\\n  ) external onlyOwner {\\r\\n    require(xTokens.length == variables.length);\\r\\n    require(strategies.length == variables.length);\\r\\n    require(reserveDecimals.length == variables.length);\\r\\n\\r\\n    for (uint256 i = 0; i \\u003c variables.length; i++) {\\r\\n      MarginPoolConfigurator(poolConfigurator).initReserve(\\r\\n        xTokens[i],\\r\\n        variables[i],\\r\\n        reserveDecimals[i],\\r\\n        strategies[i]\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function configureReserves(\\r\\n    address[] calldata assets,\\r\\n    uint256[] calldata baseLTVs,\\r\\n    uint256[] calldata liquidationThresholds,\\r\\n    uint256[] calldata liquidationBonuses,\\r\\n    uint256[] calldata reserveFactors\\r\\n  ) external onlyOwner {\\r\\n    require(baseLTVs.length == assets.length);\\r\\n    require(liquidationThresholds.length == assets.length);\\r\\n    require(liquidationBonuses.length == assets.length);\\r\\n    require(reserveFactors.length == assets.length);\\r\\n\\r\\n    MarginPoolConfigurator configurator = MarginPoolConfigurator(poolConfigurator);\\r\\n    for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n      configurator.configureReserveAsCollateral(\\r\\n        assets[i],\\r\\n        baseLTVs[i],\\r\\n        liquidationThresholds[i],\\r\\n        liquidationBonuses[i]\\r\\n      );\\r\\n\\r\\n      configurator.setReserveFactor(assets[i], reserveFactors[i]);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressesProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingAssetAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"BalanceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rewardsDuration\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_REVISION\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL\",\"outputs\":[{\"internalType\":\"contract IMarginPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESERVE_TREASURY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UINT_MAX_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNDERLYING_ASSET_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressesProvider\",\"outputs\":[{\"internalType\":\"contract IMarginPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverOfUnderlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardForDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getScaledUserBalanceAndSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"mintToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsDuration\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDistribution\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"scaledBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaledTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferOnLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferUnderlyingTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "XToken", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000062cd2e277de84521bdf7f0cc94c5e002b495590f000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001b4c6576657220696e7465726573742062656172696e672057424e42000000000000000000000000000000000000000000000000000000000000000000000000057857424e42000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fee5e69244728dec23b694ed7e4715f57549bb39cc2cf83f0d66e2138b4afcaf"}