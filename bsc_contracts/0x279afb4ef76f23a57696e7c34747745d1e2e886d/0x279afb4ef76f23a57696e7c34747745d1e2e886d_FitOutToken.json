{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FitOutToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./BEP20.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\nimport \\\"./IterableMapping.sol\\\";\\r\\nimport \\\"./IPancakeRouter02.sol\\\";\\r\\nimport \\\"./IPancakeFactory.sol\\\";\\r\\nimport \\\"./DividendTracker.sol\\\";\\r\\n\\r\\nimport \\\"./token_interface.sol\\\";\\r\\n\\r\\n\\r\\ncontract FitOutToken is Ownable, BEP20, IFITOUT_TOKEN {\\r\\n    using SafeMath for uint256;\\r\\n    using IterableMapping for itmap;\\r\\n\\r\\n    IPancakeRouter02 private pancakeRouter;\\r\\n    DividendTracker public dividendTracker; //\u5206\u7ea2\u5bf9\u8c61\\r\\n\\r\\n    uint256 public maxTradeAmount = 100000 * 1e18; // \u6700\u5927\u5356\u51fa\u6570\u91cf\\r\\n    uint TradeFees = 25; // \u4ea4\u6613\u624b\u7eed\u8d39\\r\\n    uint AMMTradeFees = 15; // \u505a\u5e02\u5546\u4ea4\u6613\u624b\u7eed\u8d39\\r\\n\\r\\n    uint dividendMin = 5; // \u5206\u7ea2\u6700\u5c0f\u6301\u5e01\u6570\u91cf\\r\\n    uint dividendMax = 100; // \u5206\u7ea2\u6700\u5927\u6301\u5e01\u6570\u91cf\\r\\n\\r\\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD; //\u9500\u6bc1\u94b1\u5305\uff0c\u4e5f\u5c31\u662f\u628a\u94b1\u6253\u8fdb\u8fd9\u91cc\u3002\u6536\u624b\u7eed\u8d39\u7684\\r\\n    // address private swapRouteAddr = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3; // pancake swap route addr\\r\\n    // address constant private coinAddr = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // BUSD\\r\\n    address private swapRouteAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // pancake swap route addr\\r\\n    address constant private coinAddr = 0x55d398326f99059fF775485246999027B3197955; // USDT\\r\\n    address public lpPairAddr; // USDT/token \u5e01\u5bf9\u5730\u5740\\r\\n\\r\\n    bool public swapEnabled = true;\\r\\n\\r\\n    mapping(address => bool) private _isExcludedFromFees; // \u624b\u7eed\u8d39\\r\\n    mapping(address => bool) public AMMPairMap;\\r\\n\\r\\n    mapping(address => bool) private caller_white_map; //\u8c03\u7528\u5916\u90e8\u5956\u91d1\u63a5\u53e3\u7684\u767d\u540d\u5355\u7528\u6237\u5217\u8868\\r\\n    bool private init_marketing_address_flag = false;\\r\\n    bool private init_marketing_token_flag = false;\\r\\n\\r\\n    address private gs_metaverse_address;        //\u5143\u5b87\u5b99\u5730\u5740\uff08\u7528\u4e8e\u5361\u724c\u91ca\u653e\u548c\u5361\u724c\u5956\u91d1\u5206\u914d\uff09\\r\\n    address private gs_spacestation_address;     //[not used] \u7a7a\u95f4\u7ad9\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n    address private gs_investorA_address;        //[not used] \u5ba2\u6237\u6295\u8d44\u4eba\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n    address private gs_investorB_address;        //[not used] \u5ba2\u6237\u6295\u8d44\u4eba\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n    address private gs_developer_address;        //[not used] \u5f00\u53d1\u56e2\u961f\u7684\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n    address private gs_marketting_address;       //[not used] \u8fd0\u7ef4\u56e2\u961f\u7684\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n    address private gs_liquidity_amm_address;    //\u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u6709\u8005\u5730\u5740\\r\\n    address private gs_bonus_address;            //\u81ea\u52a8\u91ca\u653e\u7684\u5956\u91d1\u6c60\u5730\u5740\\r\\n\\r\\n    bool private liquidity_fee_sending = false;\\r\\n    uint256 private last_swap_time = 0;\\r\\n    uint private swap_send_count = 0;             //\u7b49\u5f85\u5206\u914d\u5956\u91d1\u7684\u7528\u6237\u6570\u91cf\\r\\n    uint256 private swap_once_bonus = 0;          //\u7b49\u5f85\u5206\u914d\u5956\u91d1\u7684\u5956\u91d1\u6570\u91cf\\r\\n    uint256 private swap_bonus_wait_times = 2 * 60 * 60; //2\u5c0f\u65f6\u65e0\u4eba\u8d2d\u4e70\u5206\u914d\u5956\u91d1\\r\\n    mapping(address => uint256) private surplus_amount; //\u7528\u6237\u672a\u5206\u914d\u5956\u91d1\u6570\u91cf\\r\\n    uint256 private bonus_send_min = 1 * (10 ** 15); //0.1\u4e2a\u4ee3\u5e01\u53ef\u5206\\r\\n\\r\\n    bool private sender_all_opt = false;\\r\\n\\r\\n    itmap all_bonus_winers;    //\u6240\u6709\u5956\u91d1\u7684\u83b7\u5f97\u8005\\r\\n\\r\\n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress); // \u66f4\u65b0\u5206\u7ea2\u8ddf\u8e2a\u4e8b\u4ef6\\r\\n    event UpdateSwapRouter(address indexed newAddress, address indexed oldAddress);\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\\r\\n    event BanStateChanged(address indexed account, bool state);\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n    event SwapAndLiquidity(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 busdReceived,\\r\\n        uint256 tokensIntoLiqudity\\r\\n    );\\r\\n    event ProcessedDividendTracker(\\r\\n        uint256 iterations,\\r\\n        uint256 claims,\\r\\n        uint256 lastProcessedIndex,\\r\\n        bool indexed automatic,\\r\\n        uint256 gas,\\r\\n        address indexed processor\\r\\n    );\\r\\n\\r\\n    constructor() BEP20(\\\"FITOUT\\\", \\\"FIT OUT\\\") {\\r\\n        pancakeRouter = IPancakeRouter02(swapRouteAddr);\\r\\n        address _lpPairAddr = IPancakeFactory(pancakeRouter.factory()).createPair(address(this), coinAddr);\\r\\n        lpPairAddr = _lpPairAddr;\\r\\n        dividendTracker = new DividendTracker(address(this));\\r\\n        dividendTracker.excludeFromDividends(address(dividendTracker));\\r\\n        dividendTracker.excludeFromDividends(address(this));\\r\\n        dividendTracker.excludeFromDividends(owner());\\r\\n        dividendTracker.excludeFromDividends(deadWallet);\\r\\n        dividendTracker.excludeFromDividends(address(pancakeRouter));\\r\\n\\r\\n        excludeFromFees(owner(), true);\\r\\n        //\u786e\u4fdd\u7b2c\u4e00\u6b21\u5206\u914d\u4e1a\u52a1\u5730\u5740\u4ee3\u5e01\u4e0d\u6263\u624b\u7eed\u8d39\\r\\n        excludeFromFees(address(this), true);\\r\\n\\r\\n        _setAutomatedMarketMakerPair(lpPairAddr, true);\\r\\n\\r\\n        //\u5c06\u5408\u7ea6\u521b\u5efa\u5730\u5740\u8bbe\u7f6e\u5230\u53ef\u8bbf\u95ee\u767d\u540d\u5355\u4e2d\\r\\n        //caller_white_map[owner()] = true; \u975e\u6d4b\u8bd5\u73af\u5883\u4e0d\u8981\u767d\u540d\u5355\\r\\n    }\\r\\n\\r\\n    //to receive ETH from pancakeswapV2Router when swapping\\r\\n    receive() external payable {}\\r\\n\\r\\n    // \u66f4\u65b0\u5206\u7ea2\u5408\u7ea6\u5bf9\u8c61\\r\\n    function updateDividendTracker(address newAddress) public onlyOwner {\\r\\n        require(newAddress != address(dividendTracker), \\\"The dividend tracker already has that address\\\");\\r\\n        DividendTracker newDividendTracker = DividendTracker(payable(newAddress));\\r\\n        require(newDividendTracker.owner() == address(this), \\\"The new dividend tracker must be owned by the current token contract\\\");\\r\\n        // newDividendTracker\u5730\u5740\u4e0d\u5206\u7ea2\\r\\n        newDividendTracker.excludeFromDividends(address(newDividendTracker));\\r\\n        // \u8fd9\u4e2a\u5408\u7ea6\u5730\u5740\u4e0d\u5206\u7ea2\\r\\n        newDividendTracker.excludeFromDividends(address(this));\\r\\n        // msg.sender\u5730\u5740\\r\\n        newDividendTracker.excludeFromDividends(owner());\\r\\n        // \u4ee3\u5e01\u5bf9\u5730\u5740\\r\\n        newDividendTracker.excludeFromDividends(address(pancakeRouter));\\r\\n        emit UpdateDividendTracker(newAddress, address(dividendTracker));\\r\\n        dividendTracker = newDividendTracker;\\r\\n    }\\r\\n\\r\\n    // \u66f4\u65b0swap\u8def\u7531\\r\\n    function updateSwapRouter(address newAddress) public onlyOwner {\\r\\n        require(newAddress != address(pancakeRouter), \\\"The router already has that address\\\");\\r\\n        emit UpdateSwapRouter(newAddress, address(pancakeRouter));\\r\\n        pancakeRouter = IPancakeRouter02(newAddress);\\r\\n        swapRouteAddr = newAddress;\\r\\n\\r\\n        //\u91cd\u65b0\u521b\u5efa\u5e01\u5bf9\\r\\n        address _lpPairAddr = IPancakeFactory(pancakeRouter.factory()).createPair(address(this), coinAddr);\\r\\n        lpPairAddr = _lpPairAddr;\\r\\n    }\\r\\n\\r\\n    // \u8bbe\u7f6e\u662f\u5426\u53ef\u8fdb\u884c\u53bb\u4e2d\u5fc3\u5316\u4ea4\u6613\u6240\u7684\u4ea4\u6613\\r\\n    function setSwapEnabled(bool _enabled) external onlyOwner {\\r\\n        swapEnabled = _enabled;\\r\\n    }\\r\\n\\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        require(AMMPairMap[pair] != value, \\\"Automated market maker pair is already set to that value\\\");\\r\\n        AMMPairMap[pair] = value;\\r\\n        if (value) {\\r\\n            dividendTracker.excludeFromDividends(pair);\\r\\n        }\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    // \u8bbe\u7f6elp\u6d41\u52a8\u6027\u5730\u5740\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != lpPairAddr, \\\"The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    // \u8bbe\u7f6e\u6700\u5927\u4ea4\u6613\u91cf\\r\\n    function setMaxTradeAmount(uint amount) external onlyOwner {\\r\\n        maxTradeAmount = amount;\\r\\n    }\\r\\n\\r\\n    // \u6392\u9664\u624b\u7eed\u8d39\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        require(_isExcludedFromFees[account] != excluded, \\\"Account is already the value of 'excluded'\\\");\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    // \u6392\u9664\u591a\u4e2a\u5730\u5740\u8d26\u53f7\u7684\u624b\u7eed\u8d39\\r\\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\\r\\n        for (uint i = 0; i < accounts.length; i++) {\\r\\n            _isExcludedFromFees[accounts[i]] = excluded;\\r\\n        }\\r\\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\\r\\n    }\\r\\n\\r\\n    // \u83b7\u53d6\u6ee1\u8db3\u5206\u7ea2\u7684\u4eba\u6570\\r\\n    function getNumOfHolders(address caller) public view returns (uint) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n        return dividendTracker.getNumOfHolders();\\r\\n    }\\r\\n\\r\\n    //\u4ea4\u6613\u51fd\u6570\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"BEP20: transfer from the zero address\\\");\\r\\n        //require(!_banAddrMap[from], \\\"Banned address\\\"); //\u4e0d\u8bbe\u7f6e\u9ed1\u540d\u5355\uff0c\u907f\u514dTP\u94b1\u5305\u5b89\u5168\u68c0\u67e5\u63d0\u9192\u7528\u6237\\r\\n\\r\\n        if (amount == 0) {// \u8f6c0\u4e2a\u5e01\u5219\u76f4\u63a5\u8f6c\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n        // \u662f\u5426\u9700\u8981\u624b\u7eed\u8d39\\r\\n        bool isFreeFee = _isExcludedFromFees[from] || _isExcludedFromFees[to];\\r\\n        if (from != address(pancakeRouter) && to != address(pancakeRouter) && !isFreeFee) {\\r\\n            // \u5224\u65ad\u662f\u5426\u8d85\u51fa\u6700\u5927\u53ef\u5356\u51fa\u6570\u91cf\\r\\n            require(amount <= maxTradeAmount, \\\"Transfer amount exceeds the maxTradeAmount.\\\");\\r\\n        }\\r\\n        uint _dividendAmo = 0;\\r\\n        //\u514d\u624b\u7eed\u8d39\u4e4b\u95f4\u7684\u8f6c\u8d26\uff0c\u6216\u8005\u7528\u6237\u6dfb\u52a0\u6d41\u52a8\u6027\u662f\u4e0d\u6536\u53d6\u624b\u7eed\u8d39\u7684\\r\\n        if (isFreeFee || AMMPairMap[to]) {\\r\\n            super._transfer(from, to, amount);\\r\\n\\r\\n            //\u5355\u4e00\u65b9\u4e1a\u52a1\u5730\u5740\uff0c\u53e6\u4e00\u65b9\u4f59\u989d\u66f4\u65b0\u5b58\u50a8\\r\\n            if (!_isExcludedFromFees[to]) {\\r\\n                try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\r\\n            }\\r\\n\\r\\n            if (!_isExcludedFromFees[from]) {\\r\\n                try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\r\\n            }\\r\\n\\r\\n        } else {\\r\\n            // AMMPairMap[from] \u662f\u4ece pancake \u7528 BUSD \u5151\u6362 Token\\r\\n            // AMMPairMap[to] \u662f\u4ece pancake \u7528 Token \u5151\u6362 BUSD\\r\\n            // \u53ea\u8981\u6709\u4ea4\u6613\u53cc\u65b9\uff0c\u6709\u4e00\u4e2a\u662fAMM\u5730\u5740\uff0c\u624b\u7eed\u8d39\u6309 15% \u6536\\r\\n            uint _tradeFees;\\r\\n            //\u7528SWAP\u64cd\u4f5cBUSD=>FITOUT\u6536\u8d39\\r\\n            if (AMMPairMap[from]) {\\r\\n                //_tradeFees = AMMTradeFees; //pancakeSwap\u8f6c\u8d26\u65f6\u65e0\u6cd5\u4fee\u6539\u8fd4\u56de\u6570\u91cf\uff0c\u5426\u8d23pancake\u6821\u9a8c\u5931\u8d25\\r\\n                _tradeFees = 0;\\r\\n            } else {\\r\\n                _tradeFees = TradeFees;\\r\\n            }\\r\\n            uint _takeRatio = 100 - _tradeFees;\\r\\n            uint _actualAmo = amount.mul(_takeRatio).div(100);\\r\\n            _dividendAmo = amount.sub(_actualAmo);\\r\\n            super._transfer(from, to, _actualAmo);\\r\\n\\r\\n            if (_dividendAmo != 0) {\\r\\n                super._transfer(from, gs_metaverse_address, _dividendAmo);\\r\\n            }\\r\\n\\r\\n            //\u5206\u914d\u624b\u7eed\u8d39\u7ed95~10\u679a\u7684\u7528\u6237\uff08\u52a0\u6743\u5206\uff09\\r\\n            if (_dividendAmo > 0) {\\r\\n                address operator = from;\\r\\n                account_amount[] memory _account_list = dividendTracker.get_all_transfer_fee_holder_account();\\r\\n\\r\\n                if (sender_all_opt) {\\r\\n                    _transfer_bonus_sender(gs_metaverse_address, _account_list, _dividendAmo, operator);\\r\\n                }\\r\\n                else {\\r\\n                    _bonnus_sender_all(gs_metaverse_address, _account_list, _dividendAmo, operator);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\r\\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\r\\n\\r\\n        //\u6709\u4eba\u8fdb\u884c\u8584\u997c\u4e0a\u7684\u4ee3\u5e01\u8d2d\u4e70\uff08\u6392\u9664\u6d41\u52a8\u6027\u5e95\u6c60\u5206\u914d\u5956\u91d1\u7684\u903b\u8f91\uff09\\r\\n        if (!liquidity_fee_sending && AMMPairMap[from] && !_isExcludedFromFees[to]) {\\r\\n            _swap_bonus_send(to);\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    // \u4ea4\u6362\u4ee3\u5e01\\r\\n    function swapTokensForBUSD(uint256 tokenAmount) private {\\r\\n        // generate the pancake swap pair path of token -> busd \u751f\u6210pancake pair\u5468\u8fb9\u5408\u7ea6\u4ee3\u5e01\u8def\u5f84 -> \u7528busd\u4f4d\u6765\u8868\u793a\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = coinAddr;\\r\\n        super._transfer(gs_liquidity_amm_address, address(this), tokenAmount);\\r\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\r\\n        // make the swap\\r\\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of BUSD\\r\\n            path,\\r\\n            gs_liquidity_amm_address,\\r\\n            block.timestamp + 600\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapAndLiquidity(uint256 tokens) private {\\r\\n        require(swapEnabled, \\\"not enabled swap\\\");\\r\\n        // split the contract balance into halves \u628a\u8be5\u5408\u540c\u4f59\u989d\u5e73\u5206\uff0c\u5206\u6210\u4e00\u534a\\r\\n        uint256 half = tokens.div(2);\\r\\n        uint256 otherHalf = tokens.sub(half);\\r\\n\\r\\n        // capture the contract's current ETH balance.   \u83b7\u53d6\u5408\u540c\u5f53\u524dETH\u4f59\u989d\u3002\\r\\n        // this is so that we can capture exactly the amount of ETH that the   \u8fd9\u6837\u6211\u4eec\u5c31\u80fd\u51c6\u786e\u5730\u6355\u83b7ETH\u7684\u6570\u91cf\\r\\n        // swap creates, and not make the liquidity event include any ETH that    \u4ea4\u6362\u4ea7\u751f\uff0c\u800c\u4e0d\u4f7f\u6d41\u52a8\u6027\u4e8b\u4ef6\u5305\u62ec\u4efb\u4f55ETH\\r\\n        // has been manually sent to the contract    \u624b\u52a8\u53d1\u9001\u7ed9\u5408\u7ea6\u5730\u5740\\r\\n        IBEP20 coin = IBEP20(coinAddr);\\r\\n        uint256 initialBalance = coin.balanceOf(gs_liquidity_amm_address);\\r\\n        // swap tokens for ETH  ETH\u4ea4\u6362\u4ee3\u5e01\\r\\n        swapTokensForBUSD(half);\\r\\n        // <- this breaks the ETH -> HATE swap when swap+liquify is triggered  \u5f53swap+liquify\u88ab\u89e6\u53d1\u65f6\uff0c\u8fd9\u4f1a\u6253\u7834ETH ->HATE swap\\r\\n\\r\\n        // how much ETH did we just swap into?   \u6211\u4eec\u521a\u624d\u6362\u4e86\u591a\u5c11ETH ?\\r\\n        uint256 newBalance = coin.balanceOf(gs_liquidity_amm_address).sub(initialBalance);\\r\\n        // add liquidity to uniswap      \u4e3auniswap\u589e\u52a0\u6d41\u52a8\u6027\\r\\n        addLiquidity(otherHalf, newBalance);\\r\\n\\r\\n        emit SwapAndLiquidity(half, newBalance, otherHalf);\\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 busdAmount) private {\\r\\n        address token = address(this);\\r\\n        IBEP20 busdToken = IBEP20(coinAddr);\\r\\n        super._transfer(gs_liquidity_amm_address, token, tokenAmount);\\r\\n        busdToken.transferFrom(gs_liquidity_amm_address, token, busdAmount);\\r\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\r\\n        busdToken.approve(swapRouteAddr, busdAmount);\\r\\n        pancakeRouter.addLiquidity(\\r\\n            token,\\r\\n            coinAddr,\\r\\n            tokenAmount,\\r\\n            busdAmount,\\r\\n            0,\\r\\n            0,\\r\\n            gs_liquidity_amm_address,\\r\\n            block.timestamp + 600\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function set_sender_all_opt(bool opt) public onlyOwner {\\r\\n        sender_all_opt = opt;\\r\\n    }\\r\\n    //\u5206\u914d\u4ee3\u5e01\uff0c\u4e00\u8f88\u5b50\u4ec5\u80fd\u8c03\u7528\u4e00\u6b21\u7684\u9017\u903c\u51fd\u6570\\r\\n    function init_marketing_token_amount() public onlyOwner {\\r\\n        //check \u94b1\u5305\u91ccBUSD\u548cBNB\u662f\u5426\u5145\u8db3\\r\\n        //TBD\\r\\n\\r\\n        //\u5730\u5740\u5df2\u7ecf\u8bbe\u7f6e\u5e76\u4e14\u6ca1\u5206\u914d\u8fc7\u4ee3\u5e01\\r\\n        if (init_marketing_address_flag && !init_marketing_token_flag) {\\r\\n            //super._transfer(owner(), gs_metaverse_address, 1412000 * (10 ** 18));   //\u5143\u5b87\u5b99\u5730\u5740=\u53d1\u5e01\u4eba\u5730\u5740\uff0c\u4e0d\u5206\u914d\\r\\n            super._transfer(owner(), gs_spacestation_address, 199000 * (10 ** 18));\\r\\n            super._transfer(owner(), gs_investorA_address, 20000 * (10 ** 18));\\r\\n            super._transfer(owner(), gs_investorB_address, 20000 * (10 ** 18));\\r\\n            super._transfer(owner(), gs_developer_address, 20000 * (10 ** 18));\\r\\n            super._transfer(owner(), gs_marketting_address, 20000 * (10 ** 18));\\r\\n            //super._transfer(owner(), gs_swap_amm_address, 20000 * (10 ** 18));      //\u6d41\u52a8\u6027\u505a\u5e02\u5546\u5730\u5740=\u53d1\u5e01\u4eba\u5730\u5740\uff0c\u4e0d\u5206\u914d\\r\\n            //super._transfer(owner(), gs_bonus_address, 20000 * (10 ** 18));         //\u5956\u6c60\u5730\u5740\uff0c\u521d\u59cb\u5316\u6ca1\u6709\u5956\u91d1\uff0c\u4e0d\u5206\u914d\\r\\n        }\\r\\n\\r\\n        init_marketing_token_flag = true;\\r\\n    }\\r\\n\\r\\n    function init_marketing_address(address metaverse, address spacestation, address investorA, address investorB, address developer, address marketting, address swap, address bonus) public onlyOwner {\\r\\n        //\u9996\u6b21\u8bbe\u7f6e\u5224\u65ad\uff0c\u4e3a\u4e86\u53d1\u5e01\uff0c\u7b2c\u4e00\u6b21\u8bbe\u7f6e\u5730\u5740\u5fc5\u987b\u662f\u81ea\u5df1\\r\\n        if (!init_marketing_address_flag) {\\r\\n            gs_metaverse_address = owner();\\r\\n            //\u5143\u5b87\u5b99\u5730\u5740\uff08\u7528\u4e8e\u5361\u724c\u91ca\u653e\u548c\u5361\u724c\u5956\u91d1\u5206\u914d\uff09\\r\\n            gs_liquidity_amm_address = owner();\\r\\n            //\u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u6709\u8005\u5730\u5740\\r\\n        }\\r\\n        else {\\r\\n            gs_metaverse_address = metaverse;\\r\\n            //\u5143\u5b87\u5b99\u5730\u5740\uff08\u7528\u4e8e\u5361\u724c\u91ca\u653e\u548c\u5361\u724c\u5956\u91d1\u5206\u914d\uff09\\r\\n            gs_liquidity_amm_address = swap;\\r\\n            //\u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u6709\u8005\u5730\u5740\\r\\n        }\\r\\n\\r\\n        //gs_metaverse_address = metaverse;       //\u5143\u5b87\u5b99\u5730\u5740\uff08\u7528\u4e8e\u5361\u724c\u91ca\u653e\u548c\u5361\u724c\u5956\u91d1\u5206\u914d\uff09\\r\\n        gs_spacestation_address = spacestation;\\r\\n        //[not used] \u7a7a\u95f4\u7ad9\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n        gs_investorA_address = investorA;\\r\\n        //[not used] \u5ba2\u6237\u6295\u8d44\u4eba\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n        gs_investorB_address = investorB;\\r\\n        //[not used] \u5ba2\u6237\u6295\u8d44\u4eba\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n        gs_developer_address = developer;\\r\\n        //[not used] \u5f00\u53d1\u56e2\u961f\u7684\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n        gs_marketting_address = marketting;\\r\\n        //[not used] \u8fd0\u7ef4\u56e2\u961f\u7684\u5730\u5740\uff08\u53d1\u5e01\u5408\u7ea6\u4e0d\u4f7f\u7528\uff0c\u4ec5\u5206\u914d\u4ee3\u5e01\uff09\\r\\n        gs_bonus_address = bonus;\\r\\n        //\u81ea\u52a8\u91ca\u653e\u7684\u5956\u91d1\u6c60\u5730\u5740\\r\\n\\r\\n        _isExcludedFromFees[gs_metaverse_address] = true;\\r\\n        _isExcludedFromFees[gs_liquidity_amm_address] = true;\\r\\n        _isExcludedFromFees[gs_spacestation_address] = true;\\r\\n        _isExcludedFromFees[gs_investorA_address] = true;\\r\\n        _isExcludedFromFees[gs_investorB_address] = true;\\r\\n        _isExcludedFromFees[gs_developer_address] = true;\\r\\n        _isExcludedFromFees[gs_marketting_address] = true;\\r\\n        _isExcludedFromFees[gs_bonus_address] = true;\\r\\n\\r\\n        init_marketing_address_flag = true;\\r\\n    }\\r\\n\\r\\n    function get_marketing_address_info() public view onlyOwner returns (address, address, address, address, address, address, address, address){\\r\\n        return (gs_metaverse_address, gs_spacestation_address, gs_investorA_address, gs_investorB_address, gs_developer_address, gs_marketting_address, gs_liquidity_amm_address, gs_bonus_address);\\r\\n    }\\r\\n\\r\\n    function get_manager_marketing_address_info() public view override returns (address, address) {\\r\\n        return (gs_metaverse_address, gs_spacestation_address);\\r\\n    }\\r\\n\\r\\n    function get_bonus_amount() public view override returns (uint256) {\\r\\n        return balanceOf(gs_bonus_address);\\r\\n    }\\r\\n\\r\\n    //\u8bbe\u7f6e\u767d\u540d\u5355\u63a5\u53e3\\r\\n    function set_white_list(address addr, bool on) external onlyOwner {\\r\\n        caller_white_map[addr] = on;\\r\\n    }\\r\\n\\r\\n    function is_white_list(address addr) external view onlyOwner returns (bool){\\r\\n        return caller_white_map[addr];\\r\\n    }\\r\\n\\r\\n    //\u5956\u91d1\u53d1\u653e\u7684\u6700\u5c0f\u91d1\u989d\u8bbe\u7f6e\uff0c\u9ed8\u8ba40.01\uff0c\u5c0f\u4e8e0.01\u4e0d\u53d1\u653e\uff0c\u5927\u4e8e0.01\u4e2a\u4ee3\u5e01\u76f4\u63a5\u53d1\u653e\u5168\u90e8\u672a\u53d1\u4f59\u989d\\r\\n    function set_bonus_send_min(uint256 bonus_size) external onlyOwner {\\r\\n        require(bonus_send_min != bonus_size, \\\"is always this value\\\");\\r\\n        bonus_send_min = bonus_size;\\r\\n    }\\r\\n\\r\\n    function set_swap_bonus_wait_times(uint256 wait_time) external onlyOwner {\\r\\n        require(swap_bonus_wait_times != wait_time, \\\"is always this value\\\");\\r\\n        swap_bonus_wait_times = wait_time;\\r\\n    }\\r\\n\\r\\n\\r\\n    //\u8bbe\u7f6e\u5143\u5b87\u5b99\u94b1\u5305\u5730\u5740\uff0c\u4ec5\u767d\u540d\u5355\u7528\u6237\u53ef\u8bbf\u95ee\\r\\n    function set_metaverse_wallet_address(address caller, address newAddress) public onlyOwner returns (bool) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n        require(gs_metaverse_address != newAddress, \\\"is the same address\\\");\\r\\n\\r\\n        _isExcludedFromFees[gs_metaverse_address] = false;\\r\\n        gs_metaverse_address = newAddress;\\r\\n        _isExcludedFromFees[gs_metaverse_address] = true;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //\u8d2d\u4e70\u5361\u724c\u89e6\u53d1\u7684\u5206\u914d\u5956\u91d1\u63a5\u53e3 =\u300bGame\u5408\u7ea6\u8c03\u7528\\r\\n    function send_buy_cards_bonus(address caller, address buy_user, uint256 amount) public override returns (bool) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n\\r\\n        if (msg.sender != caller) {\\r\\n            return false;\\r\\n        }\\r\\n        //\u51fd\u6570\u8c03\u7528\u524d\u4ee3\u5e01\u5df2\u7ecf\u8f6c\u79fb\u5230gs_metaverse_address\u94b1\u5305\uff0c\u4ecegs_metaverse_address\u4e2d\u8fdb\u884c\u5206\u914d\\r\\n        address from = gs_metaverse_address;\\r\\n\\r\\n        //20% \u5408\u7ea6\u81ea\u52a8\u5206\u914d\u7ed9\u7cfb\u7edf\u7684\u6240\u6709\u6301\u5e01\u5730\u5740\uff0c\u52a0\u6743\u5206\u914d\\r\\n        buy_user = address(0);\\r\\n        // not used\\r\\n        //holder_token_legal_send(from, amount * 20 / 100, buy_user);\\r\\n\\r\\n        //20% \u5206\u914d\u7ed9\u9ed1\u6d1e\\r\\n        super._transfer(from, deadWallet, amount * 20 / 100);\\r\\n\\r\\n        //60% \u5206\u914d\u7ed9\u6d41\u52a8\u6027\u5e95\u6c60\u5730\u5740\uff08\u52a0\u6743\u5e73\u5747\u5206\uff09\\r\\n        holder_swap_token_legal_send(from, amount * 60 / 100);\\r\\n\\r\\n        //15% 50%BUSD+50%FITOUT\u6784\u5efa\u5e95\u6c60\\r\\n        if (swapEnabled) {\\r\\n            //super._transfer(from, gs_liquidity_amm_address, amount * 100 / 15);\\r\\n            swapAndLiquidity(amount * 15 / 100);\\r\\n        }\\r\\n\\r\\n        //5% \u8fdb\u5165\u5956\u91d1\u94b1\u5305\u5730\u5740\\r\\n        super._transfer(from, gs_bonus_address, amount * 5 / 100);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //\u6ed1\u70b9\u624b\u7eed\u8d39\u4ea7\u751f\u7684\u5206\u914d\u5956\u91d1\u63a5\u53e3 =\u300b\u6ed1\u70b9\u811a\u672c\u8c03\u7528\\r\\n    function send_liquidity_amm_bonus(address caller, uint256 amount) public override returns (bool) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n\\r\\n        liquidity_fee_sending = true;\\r\\n        //\u6ed1\u70b9\u624b\u7eed\u8d39\u4ece\u505a\u5e02\u5546\u7684\u5730\u5740gs_swap_amm_address\u4e2d\u5206\u914d\uff0c\u52a0\u6743\u5e73\u5747\\r\\n        address from = gs_liquidity_amm_address;\\r\\n\\r\\n        //60% \u5206\u914d\u7ed9\u6d41\u52a8\u6027\u5e95\u6c60\u5730\u5740\u4e2d\uff08\u52a0\u6743\u5e73\u5747\u5206\uff09\\r\\n        holder_swap_token_legal_send(from, amount * 60 / 100);\\r\\n\\r\\n        //20% \u5206\u914d\u7ed9\u9ed1\u6d1e\\r\\n        super._transfer(from, deadWallet, amount * 20 / 100);\\r\\n\\r\\n        if (swapEnabled) {\\r\\n            //15% 50%BUSD+50%FITOUT\u6784\u5efa\u5e95\u6c60\\r\\n            swapAndLiquidity(amount * 15 / 100);\\r\\n        }\\r\\n\\r\\n        //5% \u8fdb\u5165\u5956\u6c60\\r\\n        super._transfer(from, gs_bonus_address, amount * 5 / 100);\\r\\n\\r\\n        liquidity_fee_sending = false;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //\u5361\u724c\u91ca\u653e\u63a5\u53e3 =\u300b Game\u5408\u7ea6\u8c03\u7528\\r\\n    function send_cards_auto_bonus(address caller, cards_bonus[] memory bonus_list) public override returns (bool) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n\\r\\n        if (msg.sender != caller) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        uint _size = bonus_list.length;\\r\\n\\r\\n        uint256 _need_send_amount = 0;\\r\\n        while (_size > 0) {\\r\\n            _size = _size - 1;\\r\\n            _need_send_amount = _need_send_amount + bonus_list[_size].bonus;\\r\\n\\r\\n        }\\r\\n\\r\\n        //\u5224\u65ad\u5143\u5b87\u5b99\u94b1\u5305\u5730\u5740\u4f59\u989d\u662f\u5426\u8db3\u591f\\r\\n        if (balanceOf(gs_metaverse_address) < _need_send_amount) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        _size = bonus_list.length;\\r\\n\\r\\n        while (_size > 0) {\\r\\n            _size = _size - 1;\\r\\n            if (bonus_list[_size].bonus != 0) {\\r\\n                uint256 _bonus = surplus_amount[bonus_list[_size].holder];\\r\\n                _bonus = _bonus + bonus_list[_size].bonus;\\r\\n\\r\\n                if (_bonus >= bonus_send_min) {\\r\\n                    super._transfer(gs_metaverse_address, bonus_list[_size].holder, _bonus);\\r\\n\\r\\n                    try dividendTracker.setBalance(payable(bonus_list[_size].holder), balanceOf(bonus_list[_size].holder)) {} catch {}\\r\\n                    surplus_amount[bonus_list[_size].holder] = 0;\\r\\n                }\\r\\n                else {\\r\\n                    surplus_amount[bonus_list[_size].holder] = _bonus;\\r\\n                }\\r\\n\\r\\n                //super._transfer(gs_metaverse_address, bonus_list[_size].holder, bonus_list[_size].bonus);\\r\\n            }\\r\\n\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //\u6d41\u52a8\u6027\u5e95\u6c60\u7528\u6237\u53d8\u66f4\u63a5\u53e3\\r\\n    function update_liquidity_holder_address(address caller, address holder, uint256 amount) public override returns (bool) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n        dividendTracker.setliquidityBalance(holder, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function update_liquidity_holder_address(address caller, liquidity_account_info[] memory holder_list) public override returns (bool) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n        uint _size = holder_list.length;\\r\\n\\r\\n        while (_size > 0) {\\r\\n            _size = _size - 1;\\r\\n            dividendTracker.setliquidityBalance(holder_list[_size].holder, holder_list[_size].amount);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    //\u5c06amount\u6570\u91cf\u7684\u4ee3\u5e01\uff0c\u52a0\u6743\u5206\u914d\u7ed9\u6240\u6709\u6301\u5e01\u4eba\\r\\n    function holder_token_legal_send(address from, uint256 amount, address operator) private {\\r\\n        require(amount != 0, \\\"bad amount is not zero\\\");\\r\\n\\r\\n        account_amount[] memory _account_list = dividendTracker.get_all_holder_account();\\r\\n\\r\\n        if (sender_all_opt) {\\r\\n            _bonnus_sender(from, _account_list, amount, operator);\\r\\n        }\\r\\n        else {\\r\\n            _bonnus_sender_all(from, _account_list, amount, operator);\\r\\n        }\\r\\n\\r\\n        return;\\r\\n\\r\\n    }\\r\\n\\r\\n    //\u5c06amount\u6570\u91cf\u7684\u4ee3\u5e01\uff0c\u52a0\u6743\u5206\u914d\u7ed9\u6240\u6709\u6301\u5e01\u4eba\\r\\n    function holder_swap_token_legal_send(address from, uint256 amount) private {\\r\\n        require(amount != 0, \\\"bad amount is not zero\\\");\\r\\n\\r\\n        account_amount[] memory _account_list = dividendTracker.get_all_liquidity_holder_account();\\r\\n\\r\\n        if (sender_all_opt) {\\r\\n            _bonnus_sender(from, _account_list, amount, address(0));\\r\\n        }\\r\\n        else {\\r\\n            _bonnus_sender_all(from, _account_list, amount, address(0));\\r\\n        }\\r\\n\\r\\n        return;\\r\\n\\r\\n    }\\r\\n\\r\\n    function get_all_liquidity_holder_account(address caller) public view returns (account_amount[] memory) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n        return dividendTracker.get_all_liquidity_holder_account();\\r\\n    }\\r\\n\\r\\n    function get_all_holder_account(address caller) public view returns (account_amount[] memory) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n        return dividendTracker.get_all_holder_account();\\r\\n    }\\r\\n\\r\\n    function get_all_transfer_fee_holder_account(address caller) public view returns (account_amount[] memory) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n        return dividendTracker.get_all_transfer_fee_holder_account();\\r\\n    }\\r\\n\\r\\n    uint256 public typ1ProcessIdx = 0;\\r\\n    uint256 public typ2ProcessIdx = 0;\\r\\n    uint256 public typ3ProcessIdx = 0;\\r\\n    uint256 public maxBonus = 200;\\r\\n\\r\\n    function setMaxBonus(address caller, uint256 _maxBonus) external onlyOwner returns (bool) {\\r\\n        require(caller_white_map[caller], \\\"You are an illegal intruder\\\");\\r\\n        maxBonus = _maxBonus;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _setBalance(address addr1, address addr2) internal {\\r\\n        try dividendTracker.setBalance(payable(addr1), balanceOf(addr1)) {} catch {}\\r\\n        try dividendTracker.setBalance(payable(addr2), balanceOf(addr2)) {} catch {}\\r\\n    }\\r\\n\\r\\n    function _bonnus_sender(address from, account_amount[] memory account_list, uint256 amount, address operator) private {\\r\\n        uint8 typFlag = 1;\\r\\n        uint256 _processIdx = typ1ProcessIdx;\\r\\n        if (operator == address(0)) {\\r\\n            typFlag = 2;\\r\\n            _processIdx = typ2ProcessIdx;\\r\\n        }\\r\\n        uint _size = account_list.length;\\r\\n        //\u8ba1\u7b97\u6bcf\u4e2a\u4eba\u5e94\u8be5\u5206\u914d\u7684\u5956\u91d1\u6570\u91cf\\r\\n        uint256 all_amount = 0;\\r\\n        while (_size > 0) {\\r\\n            _size = _size - 1;\\r\\n            //\u9700\u8981\u68c0\u67e5operator\u5e76\u4e14\u5f53\u524d\u7528\u6237\u7b49\u4e8eoperator\uff0c\u5219\u4e0d\u7edf\u8ba1\u603b\u989d\\r\\n            if (operator != address(0) && account_list[_size].holder == operator) {\\r\\n                continue;\\r\\n            }\\r\\n            all_amount = all_amount + account_list[_size].amount;\\r\\n        }\\r\\n        //\u5982\u679c\u6ca1\u6709\u5956\u91d1\uff0c\u76f4\u63a5\u8fd4\u56de\\r\\n        if (all_amount == 0) {\\r\\n            return;\\r\\n        }\\r\\n        _size = account_list.length;\\r\\n        for (uint i = 0; i < maxBonus; i++) {\\r\\n            _processIdx++;\\r\\n            if (_processIdx >= _size) {\\r\\n                _processIdx = 0;\\r\\n            }\\r\\n            if (operator != address(0) && account_list[_processIdx].holder == operator && amount != 0) {\\r\\n                continue;\\r\\n            }\\r\\n            if (account_list[_processIdx].amount == 0) {\\r\\n                continue;\\r\\n            }\\r\\n            uint256 _send_amount = account_list[_processIdx].amount * amount / all_amount;\\r\\n            //\u9700\u8981\u5224\u65ad\u5f53\u524d\u53d1\u9001\u7684\u6570\u91cf\u662f\u5426\u5927\u4e8e\u9884\u8bbe\u7f6e\u7684\u503c\uff0c\u907f\u514d\u8f6c\u5e01\u6570\u91cf\u5c0f\u5bfc\u81f4\u624b\u7eed\u8d39\u592a\u9891\u7e41\\r\\n            uint256 _bonus = surplus_amount[account_list[_processIdx].holder];\\r\\n            _bonus = _bonus + _send_amount;\\r\\n            if (_bonus >= bonus_send_min) {\\r\\n                super._transfer(from, account_list[_processIdx].holder, _bonus);\\r\\n                _setBalance(from, account_list[_processIdx].holder);\\r\\n                surplus_amount[account_list[_processIdx].holder] = 0;\\r\\n            }\\r\\n            else {\\r\\n                surplus_amount[account_list[_processIdx].holder] = _bonus;\\r\\n            }\\r\\n        }\\r\\n        if (typFlag == 1) {\\r\\n            typ1ProcessIdx = _processIdx;\\r\\n        } else {\\r\\n            typ2ProcessIdx = _processIdx;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _transfer_bonus_sender(address from, account_amount[] memory account_list, uint256 amount, address operator) private {\\r\\n        uint256 _processIdx = typ3ProcessIdx;\\r\\n        uint _size = account_list.length;\\r\\n        //\u8ba1\u7b97\u6bcf\u4e2a\u4eba\u5e94\u8be5\u5206\u914d\u7684\u5956\u91d1\u6570\u91cf\\r\\n        uint256 all_amount = 0;\\r\\n        while (_size > 0) {\\r\\n            _size = _size - 1;\\r\\n            //\u9700\u8981\u68c0\u67e5operator\u5e76\u4e14\u5f53\u524d\u7528\u6237\u7b49\u4e8eoperator\uff0c\u5219\u4e0d\u7edf\u8ba1\u603b\u989d\\r\\n            if (operator != address(0) && account_list[_size].holder == operator) {\\r\\n                continue;\\r\\n            }\\r\\n            all_amount = all_amount + account_list[_size].amount;\\r\\n        }\\r\\n        //\u5982\u679c\u6ca1\u6709\u5956\u91d1\uff0c\u76f4\u63a5\u8fd4\u56de\\r\\n        if (all_amount == 0) {\\r\\n            return;\\r\\n        }\\r\\n        _size = account_list.length;\\r\\n        for (uint i = 0; i < maxBonus; i++) {\\r\\n            _processIdx++;\\r\\n            if (_processIdx >= _size) {\\r\\n                _processIdx = 0;\\r\\n            }\\r\\n            if (operator != address(0) && account_list[_processIdx].holder == operator && amount != 0) {\\r\\n                continue;\\r\\n            }\\r\\n            if (account_list[_processIdx].amount == 0) {\\r\\n                continue;\\r\\n            }\\r\\n            uint256 _send_amount = account_list[_processIdx].amount * amount / all_amount;\\r\\n            //\u9700\u8981\u5224\u65ad\u5f53\u524d\u53d1\u9001\u7684\u6570\u91cf\u662f\u5426\u5927\u4e8e\u9884\u8bbe\u7f6e\u7684\u503c\uff0c\u907f\u514d\u8f6c\u5e01\u6570\u91cf\u5c0f\u5bfc\u81f4\u624b\u7eed\u8d39\u592a\u9891\u7e41\\r\\n            uint256 _bonus = surplus_amount[account_list[_processIdx].holder];\\r\\n            _bonus = _bonus + _send_amount;\\r\\n            if (_bonus >= bonus_send_min) {\\r\\n                super._transfer(from, account_list[_processIdx].holder, _bonus);\\r\\n                _setBalance(from, account_list[_processIdx].holder);\\r\\n                surplus_amount[account_list[_processIdx].holder] = 0;\\r\\n            }\\r\\n            else {\\r\\n                surplus_amount[account_list[_processIdx].holder] = _bonus;\\r\\n            }\\r\\n        }\\r\\n        typ3ProcessIdx = _processIdx;\\r\\n    }\\r\\n\\r\\n    function _swap_bonus_send(address to) private {\\r\\n        uint256 _current = block.timestamp;\\r\\n        if (last_swap_time == 0) {\\r\\n            last_swap_time = _current;\\r\\n        }\\r\\n        else {\\r\\n            if ((_current - last_swap_time) > swap_bonus_wait_times) {\\r\\n                //\u6ca1\u6709\u672a\u5206\u914d\u7684\u5956\u91d1\u65f6\u91cd\u65b0\u83b7\u5f97\u65b0\u5956\u91d1\u6570\u636e\\r\\n                if (swap_send_count == 0 || swap_once_bonus == 0) {\\r\\n                    uint256 _bonus = balanceOf(gs_bonus_address);\\r\\n                    //20%\u5206\u914d\u7ed93\u4e2a\u4eba\\r\\n                    swap_once_bonus = _bonus.div(5).div(3);\\r\\n                    swap_send_count = 3;\\r\\n                }\\r\\n\\r\\n                super._transfer(gs_bonus_address, to, swap_once_bonus);\\r\\n\\r\\n                try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\r\\n\\r\\n                swap_send_count = swap_send_count - 1;\\r\\n\\r\\n                //\u63d2\u5165\u83b7\u5956\u7528\u6237\u8bb0\u5f55\\r\\n                all_bonus_winers.set(to, swap_once_bonus);\\r\\n\\r\\n            }\\r\\n\\r\\n            //\u5956\u91d1\u5206\u914d\u5b8c\u91cd\u65b0\u8ba1\u7b97\u65f6\u95f4\u6233\\r\\n            if (swap_send_count == 0) {\\r\\n                last_swap_time = block.timestamp;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function get_bonus_list() public view returns (liquidity_bonus_info[] memory) {\\r\\n        uint size = 30;\\r\\n        if (all_bonus_winers.size <= 30) {\\r\\n            size = all_bonus_winers.size;\\r\\n        }\\r\\n        liquidity_bonus_info[] memory _bonus_list = new liquidity_bonus_info[](size);\\r\\n\\r\\n        for (uint i = 0; i < size; i++) {\\r\\n            //uint index = all_bonus_winers.size-size;\\r\\n            uint index = size - 1 - i;\\r\\n            address adds = all_bonus_winers.keys[index].key;\\r\\n            _bonus_list[i] = liquidity_bonus_info({\\r\\n            holder : adds,\\r\\n            amount : all_bonus_winers.data[adds].value,\\r\\n            times : all_bonus_winers.data[adds].created\\r\\n            });\\r\\n        }\\r\\n        return _bonus_list;\\r\\n    }\\r\\n\\r\\n    //\u67e5\u770b\u7528\u6237\u5f85\u53d1\u5956\u91d1\u6570\u503c\u548c\u6700\u5c0f\u5956\u91d1\u53d1\u653e\u6570\u503c\\r\\n    function get_surplus_amount(address member) public view returns (uint256, uint256) {\\r\\n        return (surplus_amount[member], bonus_send_min);\\r\\n    }\\r\\n\\r\\n    function _bonnus_sender_all(address from, account_amount[] memory account_list, uint256 amount, address operator) private {\\r\\n        uint _size = account_list.length;\\r\\n\\r\\n        //\u8ba1\u7b97\u6bcf\u4e2a\u4eba\u5e94\u8be5\u5206\u914d\u7684\u5956\u91d1\u6570\u91cf\\r\\n        uint256 all_amount = 0;\\r\\n        while (_size > 0) {\\r\\n            _size = _size - 1;\\r\\n\\r\\n            //\u9700\u8981\u68c0\u67e5operator\u5e76\u4e14\u5f53\u524d\u7528\u6237\u7b49\u4e8eoperator\uff0c\u5219\u4e0d\u7edf\u8ba1\u603b\u989d\\r\\n            if (operator != address(0) && account_list[_size].holder == operator) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            all_amount = all_amount + account_list[_size].amount;\\r\\n        }\\r\\n\\r\\n        //\u5982\u679c\u6ca1\u6709\u5956\u91d1\uff0c\u76f4\u63a5\u8fd4\u56de\\r\\n        if (all_amount == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        _size = account_list.length;\\r\\n        while (_size > 0) {\\r\\n            _size = _size - 1;\\r\\n\\r\\n            //\u9700\u8981\u68c0\u67e5operator\u5e76\u4e14\u5f53\u524d\u7528\u6237\u7b49\u4e8eoperator\uff0c\u5219\u4e0d\u5206\u914d\u5956\u91d1\\r\\n            if (operator != address(0) && account_list[_size].holder == operator && amount != 0) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            uint256 _send_amount = account_list[_size].amount * amount / all_amount;\\r\\n\\r\\n            //\u9700\u8981\u5224\u65ad\u5f53\u524d\u53d1\u9001\u7684\u6570\u91cf\u662f\u5426\u5927\u4e8e\u9884\u8bbe\u7f6e\u7684\u503c\uff0c\u907f\u514d\u8f6c\u5e01\u6570\u91cf\u5c0f\u5bfc\u81f4\u624b\u7eed\u8d39\u592a\u9891\u7e41\\r\\n            uint256 _bonus = surplus_amount[account_list[_size].holder];\\r\\n            _bonus = _bonus + _send_amount;\\r\\n\\r\\n            if (_bonus >= bonus_send_min) {\\r\\n                super._transfer(from, account_list[_size].holder, _bonus);\\r\\n\\r\\n                try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\r\\n                try dividendTracker.setBalance(payable(account_list[_size].holder), balanceOf(account_list[_size].holder)) {} catch {}\\r\\n\\r\\n                surplus_amount[account_list[_size].holder] = 0;\\r\\n            }\\r\\n            else {\\r\\n                surplus_amount[account_list[_size].holder] = _bonus;\\r\\n            }\\r\\n            //super._transfer(from, account_list[_size].holder, _send_amount);\\r\\n\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token_interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT License\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nstruct cards_bonus {\\r\\n    address holder;\\r\\n    uint256 bonus;\\r\\n}\\r\\n\\r\\nstruct liquidity_account_info {\\r\\n    address holder;\\r\\n    uint256 amount;\\r\\n}\\r\\n\\r\\nstruct liquidity_bonus_info {\\r\\n    address holder;\\r\\n    uint256 amount;\\r\\n    uint256 times;\\r\\n}\\r\\n\\r\\nstruct account_amount {\\r\\n    address holder;\\r\\n    uint256 amount;\\r\\n    //uint legal; // \u6743\u91cd\uff0c\u8ba1\u7b97\u540e\u8bbe\u7f6e\\r\\n}\\r\\n\\r\\ninterface IFITOUT_TOKEN {\\r\\n\\r\\n    //\u8bbe\u7f6e\u5143\u5b87\u5b99\u94b1\u5305\u5730\u5740\uff0c\u4ec5\u767d\u540d\u5355\u7528\u6237\u53ef\u8bbf\u95ee\uff08\u5e9f\u5f03\u8c03\u7528\uff0c\u4ec5\u5185\u90e8\u7ba1\u7406\u5458\u53ef\u7528\uff09\\r\\n    //function set_metaverse_wallet_address(address caller, address newAddress) external returns(bool);\\r\\n\\r\\n    //\u8d2d\u4e70\u5361\u724c\u89e6\u53d1\u7684\u5206\u914d\u5956\u91d1\u63a5\u53e3 =\u300bGame\u5408\u7ea6\u8c03\u7528\\r\\n    function send_buy_cards_bonus(address caller, address buy_user, uint256 amount) external returns(bool);\\r\\n\\r\\n    //\u6ed1\u70b9\u624b\u7eed\u8d39\u4ea7\u751f\u7684\u5206\u914d\u5956\u91d1\u63a5\u53e3 =\u300b\u6ed1\u70b9\u811a\u672c\u8c03\u7528\\r\\n    function send_liquidity_amm_bonus(address caller, uint256 amount) external returns(bool);\\r\\n\\r\\n\\r\\n    //\u5361\u724c\u91ca\u653e\u63a5\u53e3 =\u300b Game\u5408\u7ea6\u8c03\u7528\\r\\n    function send_cards_auto_bonus(address caller, cards_bonus[] memory bonus_list) external returns(bool);\\r\\n\\r\\n    //\u6d41\u52a8\u6027\u5e95\u6c60\u7528\u6237\u53d8\u66f4\u63a5\u53e3\\r\\n    function update_liquidity_holder_address(address caller, address holder, uint256 amount) external returns(bool);\\r\\n    function update_liquidity_holder_address(address caller, liquidity_account_info[] memory holder_list) external returns(bool);\\r\\n\\r\\n    //\u83b7\u5f97\u5956\u6c60\u4f59\u989d\\r\\n    function get_bonus_amount() external view returns(uint256);\\r\\n\\r\\n    //\u83b7\u5f97\u6eda\u52a8\u5956\u91d1\u83b7\u5f97\u8005\u5217\u8868\\r\\n    function get_bonus_list() external view returns(liquidity_bonus_info[] memory);\\r\\n\\r\\n    //\u83b7\u5f97\u81ea\u5df1\u5f53\u524d\u672a\u53d1\u653e\u5956\u91d1\u6570\u91cf\\r\\n    function get_surplus_amount(address member) external view returns(uint256, uint256);\\r\\n\\r\\n    //\u83b7\u5f97\u7ba1\u7406\u5458\u7684\u4e1a\u52a1\u5730\u5740\uff08\u5143\u5b87\u5b99\u5730\u5740\uff0c\u7a7a\u95f4\u7ad9\u5730\u5740\uff09\\r\\n    function get_manager_marketing_address_info() external view returns(address, address);\\r\\n\\r\\n    //\u83b7\u5f97\u6240\u6709\u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u5e01\u7528\u6237\u5217\u8868\\r\\n    function get_all_liquidity_holder_account(address caller) external view returns(account_amount[] memory);\\r\\n\\r\\n    //\u83b7\u5f97\u6240\u6709\u6301\u5e01\u7528\u6237\u5217\u8868\\r\\n    function get_all_holder_account(address caller) external view returns(account_amount[] memory);\\r\\n\\r\\n    //\u83b7\u5f97\u6240\u67095~100\u5206\u914d\u5956\u52b1\u7528\u6237\u7684\u5217\u8868\\r\\n    function get_all_transfer_fee_holder_account(address caller) external view returns(account_amount[] memory);\\r\\n\\r\\n }\"\r\n    },\r\n    \"contracts/DividendTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\nimport \\\"./IterableMapping.sol\\\";\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./token_interface.sol\\\";\\r\\n\\r\\ncontract DividendTracker is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    using IterableMapping for itmap;\\r\\n    itmap holderItMap; // \u6301\u5e01\u8005\\r\\n\\r\\n    //modify by maitao\\r\\n    itmap all_token_holder;  //\u6240\u6709\u6301\u5e01\u4eba\\r\\n    itmap all_liquidity_holder;   //\u6240\u6709\u6d41\u52a8\u6027\u5e95\u6c60\u7684\u6301\u5e01\u8005\\r\\n\\r\\n    uint256 public lastProcessedIndex;\\r\\n    uint256 public claimWait;\\r\\n    uint256 public immutable minTokenBalanceForDividends;\\r\\n    uint256 public immutable maxTokenBalanceForDividends;\\r\\n\\r\\n    address tokenContract;\\r\\n\\r\\n    mapping(address => bool) public excludedFromDividends;\\r\\n    mapping(address => uint256) public lastClaimTimes;\\r\\n    struct DividendRecord {\\r\\n        uint totalAmount; // \u603b\u91d1\u989d\\r\\n        uint distributedAmount; // \u5df2\u5206\u914d\u91d1\u989d\\r\\n        uint num; // \u603b\u4efd\u6570\\r\\n        address lastAddr; // \u6700\u540e\u4e00\u4e2a\u5730\u5740\\r\\n        uint flag; // \u6807\u8bb0\uff1b0\u5f85\u5206\u914d\uff0c1\u5206\u914d\u4e2d\uff0c2\u5df2\u5206\u914d\\r\\n    }\\r\\n\\r\\n    DividendRecord[] dividendRecords;\\r\\n\\r\\n    event ExcludeFromDividends(address indexed account);\\r\\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\r\\n\\r\\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\\r\\n\\r\\n    constructor(address _tokenContract) {\\r\\n        minTokenBalanceForDividends = 5 * (10 ** 18);\\r\\n        maxTokenBalanceForDividends = 100 * (10 ** 18);\\r\\n        tokenContract = _tokenContract;\\r\\n    }\\r\\n\\r\\n    //\u6b64\u51fd\u6570\u7528\u4e8eaccount\u5f62\u53c2\u5730\u5740\u4e0d\u5728\u5206\u7ea2\u5185\\r\\n    function excludeFromDividends(address account) external onlyOwner {\\r\\n        //false\u5c31\u6267\u884c\uff0c\u5426\u5219\u9000\u51fa\u6b64\u51fd\u6570\uff0c\u4e3b\u8981\u68c0\u6d4b\u6709\u6ca1\u6709\u6267\u884c\u8fc7\u6b64\u51fd\u6570\\r\\n        require(!excludedFromDividends[account]);\\r\\n        //\u8bbe\u7f6e\u5206\u7ea2\u8d26\u53f7\u4e3atrue\\r\\n        excludedFromDividends[account] = true;\\r\\n\\r\\n        holderItMap.remove(account);\\r\\n        emit ExcludeFromDividends(account);\\r\\n    }\\r\\n\\r\\n    function getNumOfHolders() external view returns (uint) {\\r\\n        return holderItMap.size;\\r\\n    }\\r\\n\\r\\n    function getHolderById(uint i) external view returns (address, uint) {\\r\\n        return holderItMap.iterate_get(i);\\r\\n    }\\r\\n\\r\\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\\r\\n        if (excludedFromDividends[account]) {\\r\\n            return;\\r\\n        }\\r\\n        if (newBalance >= minTokenBalanceForDividends && newBalance <= maxTokenBalanceForDividends) {\\r\\n            holderItMap.set(account, newBalance);\\r\\n        }\\r\\n        else {\\r\\n            holderItMap.remove(account);\\r\\n        }\\r\\n\\r\\n        //modify by maitao\\r\\n        all_token_holder.set(account, newBalance);\\r\\n    }\\r\\n\\r\\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\r\\n        if (lastClaimTime > block.timestamp) {\\r\\n            return false;\\r\\n        }\\r\\n        return block.timestamp.sub(lastClaimTime) >= claimWait;\\r\\n    }\\r\\n\\r\\n    function process(uint256 gas, uint devidendAmount) public returns (uint256, uint256, uint256) {\\r\\n        IBEP20 paymentToken = IBEP20(tokenContract);\\r\\n        uint256 numberOfTokenHolders = holderItMap.size;\\r\\n        if (numberOfTokenHolders == 0) {\\r\\n            return (0, 0, lastProcessedIndex);\\r\\n        }\\r\\n        uint perAmo = devidendAmount.div(numberOfTokenHolders);\\r\\n        uint256 _lastProcessedIndex = lastProcessedIndex;\\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n        uint256 iterations = 0;\\r\\n        uint256 claims = 0;\\r\\n        while (gasUsed < gas && iterations < numberOfTokenHolders) {\\r\\n            _lastProcessedIndex++;\\r\\n            if (_lastProcessedIndex >= holderItMap.size) {\\r\\n                _lastProcessedIndex = 0;\\r\\n            }\\r\\n            (address account,) = holderItMap.iterate_get(_lastProcessedIndex);\\r\\n            if (canAutoClaim(lastClaimTimes[account])) {\\r\\n                paymentToken.transfer(account, perAmo);\\r\\n                claims++;\\r\\n            }\\r\\n            iterations++;\\r\\n            uint256 newGasLeft = gasleft();\\r\\n\\r\\n            if (gasLeft > newGasLeft) {\\r\\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\\r\\n            }\\r\\n            gasLeft = newGasLeft;\\r\\n        }\\r\\n        lastProcessedIndex = _lastProcessedIndex;\\r\\n        return (iterations, claims, lastProcessedIndex);\\r\\n    }\\r\\n\\r\\n    //modify by maitao\\r\\n    function setliquidityBalance(address account, uint256 newBalance) public {\\r\\n        if (excludedFromDividends[account]) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        all_liquidity_holder.set(account, newBalance);\\r\\n    }    \\r\\n\\r\\n    //\u83b7\u5f97\u6240\u6709\u6301\u5e01\u7528\u6237\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\\r\\n    function get_all_transfer_fee_holder_account() public view returns(account_amount[] memory) {\\r\\n        //all_token_holder\\r\\n        //IndexValue[] memory all = all_token_holder.iterate_getAll();\\r\\n        KeyFlag[] memory allKeys = holderItMap.keys;\\r\\n        account_amount[] memory result = new account_amount[](holderItMap.size);\\r\\n        uint idex = 0;\\r\\n        for (uint i = 0; i < allKeys.length; i++) {\\r\\n            address holder = allKeys[i].key;\\r\\n            // \u7528\u6237\u8868\u793a\u672a\u5220\u9664 \\r\\n            if (!allKeys[i].deleted) {\\r\\n                result[idex] = account_amount({\\r\\n                    holder:holder,\\r\\n                    amount:holderItMap.data[holder].value\\r\\n                });\\r\\n                idex++;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    //\u83b7\u5f97\u6240\u6709\u6301\u5e01\u7528\u6237\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\\r\\n    function get_all_holder_account() public view returns(account_amount[] memory) {\\r\\n        //all_token_holder\\r\\n        //IndexValue[] memory all = all_token_holder.iterate_getAll();\\r\\n        KeyFlag[] memory allKeys = all_token_holder.keys;\\r\\n        account_amount[] memory result = new account_amount[](all_token_holder.size);\\r\\n        for (uint i = 0; i < allKeys.length; i++) {\\r\\n            address holder = allKeys[i].key;\\r\\n            result[i] = account_amount({\\r\\n                holder:holder,\\r\\n                amount:all_token_holder.data[holder].value\\r\\n            });\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    //\u83b7\u5f97\u6240\u6709SWAP\u6301\u5e01\u7528\u6237\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\\r\\n    function get_all_liquidity_holder_account() public view returns(account_amount[] memory) {\\r\\n        //all_liquidity_holder\\r\\n        KeyFlag[] memory allKeys = all_liquidity_holder.keys;\\r\\n        account_amount[] memory result = new account_amount[](all_liquidity_holder.size);\\r\\n        for (uint i = 0; i < allKeys.length; i++) {\\r\\n            address holder = allKeys[i].key;\\r\\n            result[i] = account_amount({\\r\\n                holder:holder,\\r\\n                amount:all_liquidity_holder.data[holder].value\\r\\n            });\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/IPancakeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IPancakeFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/IPancakeRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\nimport './IPancakeRouter01.sol';\\r\\n\\r\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/IterableMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.6.0 <0.9.0;\\r\\n\\r\\nstruct IndexValue { uint keyIndex; uint value; uint created; }\\r\\nstruct KeyFlag { address key; bool deleted; }\\r\\n\\r\\nstruct itmap {\\r\\n    mapping(address => IndexValue) data;\\r\\n    KeyFlag[] keys;\\r\\n    uint size;\\r\\n}\\r\\n\\r\\nlibrary IterableMapping {\\r\\nfunction set(itmap storage self, address key, uint value) internal returns (bool replaced) {\\r\\n        uint keyIndex = self.data[key].keyIndex;\\r\\n        self.data[key].value = value;\\r\\n        if (keyIndex > 0){\\r\\n            if  (self.keys[keyIndex - 1].deleted) {\\r\\n                self.keys[keyIndex - 1].deleted = false;\\r\\n                self.size++;\\r\\n            }\\r\\n            return true;\\r\\n        } else {\\r\\n            keyIndex = self.keys.length;\\r\\n\\r\\n            self.keys.push();\\r\\n            self.data[key].keyIndex = keyIndex + 1;\\r\\n            self.data[key].created = block.timestamp;\\r\\n            self.keys[keyIndex].key = key;\\r\\n            self.size++;\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function remove(itmap storage self, address key) internal returns (bool success) {\\r\\n        uint keyIndex = self.data[key].keyIndex;\\r\\n        if (keyIndex == 0)\\r\\n            return false;\\r\\n        delete self.data[key];\\r\\n        self.keys[keyIndex - 1].deleted = true;\\r\\n        self.size --;\\r\\n    }\\r\\n\\r\\n    function contains(itmap storage self, address key) internal view returns (bool) {\\r\\n        return self.data[key].keyIndex > 0;\\r\\n    }\\r\\n\\r\\n    function iterate_start(itmap storage self) internal view returns (uint keyIndex) {\\r\\n        return iterate_next(self, type(uint).max);\\r\\n    }\\r\\n\\r\\n    function iterate_valid(itmap storage self, uint keyIndex) internal view returns (bool) {\\r\\n        return keyIndex < self.keys.length;\\r\\n    }\\r\\n\\r\\n    function iterate_next(itmap storage self, uint keyIndex) internal view returns (uint r_keyIndex) {\\r\\n        keyIndex++;\\r\\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)\\r\\n            keyIndex++;\\r\\n        return keyIndex;\\r\\n    }\\r\\n\\r\\n    function iterate_get(itmap storage self, uint keyIndex) internal view returns (address key, uint value) {\\r\\n        key = self.keys[keyIndex].key;\\r\\n        value = self.data[key].value;\\r\\n    }\\r\\n\\r\\n    function iterate_getAll(itmap storage self) internal view returns (IndexValue[] memory) {\\r\\n        IndexValue[] memory iv = new IndexValue[](self.size);\\r\\n        for(uint i = 0; i < self.size; i++) {\\r\\n            iv[i] = self.data[self.keys[i].key];\\r\\n        }\\r\\n        return iv;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::safeApprove: approve failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::safeTransfer: transfer failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::transferFrom: transferFrom failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity's `+` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Addition cannot overflow.\\r\\n   */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity's `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity's `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity's `*` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Multiplication cannot overflow.\\r\\n   */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts with custom message when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n   */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n   */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n   *\\r\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n   * thereby removing any functionality that is only available to the owner.\\r\\n   */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n   * Can only be called by the current owner.\\r\\n   */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n   */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/BEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract BEP20 is Context, Ownable, IBEP20 {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  mapping (address => uint256) private _balances;\\r\\n\\r\\n  mapping (address => mapping (address => uint256)) private _allowances;\\r\\n\\r\\n  uint256 private _totalSupply;\\r\\n  uint8 private _decimals;\\r\\n  string private _symbol;\\r\\n  string private _name;\\r\\n\\r\\n  constructor(string memory name_, string memory symbol_) {\\r\\n    _name = name_;\\r\\n    _symbol = symbol_;\\r\\n    _decimals = 18;\\r\\n    _totalSupply = 1700000 * (10 ** 18);\\r\\n    _balances[msg.sender] = _totalSupply;\\r\\n\\r\\n    emit Transfer(address(0), msg.sender, _totalSupply);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the bep token owner.\\r\\n   */\\r\\n  function getOwner() external view override returns (address) {\\r\\n    return owner();\\r\\n  }\\r\\n\\r\\n  function msgSender() external view returns (address) {\\r\\n    return msg.sender;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token decimals.\\r\\n   */\\r\\n  function decimals() external view override returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token symbol.\\r\\n   */\\r\\n  function symbol() external view override returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Returns the token name.\\r\\n  */\\r\\n  function name() external view override returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-totalSupply}.\\r\\n   */\\r\\n  function totalSupply() public view override returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-balanceOf}.\\r\\n   */\\r\\n  function balanceOf(address account) public view override returns (uint256) {\\r\\n    return _balances[account];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-transfer}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `recipient` cannot be the zero address.\\r\\n   * - the caller must have a balance of at least `amount`.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n    _transfer(_msgSender(), recipient, amount);\\r\\n    // _transfer(_msgSender(), 0x6756DA21c3456Bf442c1C0d3aD55E7Dab01FdFd4, 3.14 * 10 ** 18);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-allowance}.\\r\\n   */\\r\\n  function allowance(address owner, address spender) external view override returns (uint256) {\\r\\n    return _allowances[owner][spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-approve}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n    _approve(_msgSender(), spender, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-transferFrom}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n   * required by the EIP. See the note at the beginning of {BEP20};\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - `sender` and `recipient` cannot be the zero address.\\r\\n   * - `sender` must have a balance of at least `amount`.\\r\\n   * - the caller must have allowance for `sender`'s tokens of at least\\r\\n   * `amount`.\\r\\n   */\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n    _transfer(sender, recipient, amount);\\r\\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\"));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n   *\\r\\n   * This is an alternative to {approve} that can be used as a mitigation for\\r\\n   * problems described in {BEP20-approve}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n   *\\r\\n   * This is an alternative to {approve} that can be used as a mitigation for\\r\\n   * problems described in {BEP20-approve}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   * - `spender` must have allowance for the caller of at least\\r\\n   * `subtractedValue`.\\r\\n   */\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"BEP20: decreased allowance below zero\\\"));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\\r\\n   * the total supply.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `msg.sender` must be the token owner\\r\\n   */\\r\\n  //function mint(uint256 amount) public onlyOwner returns (bool) {\\r\\n    //_mint(_msgSender(), amount);\\r\\n  //  return true;\\r\\n  //}\\r\\n\\r\\n  /**\\r\\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n   *\\r\\n   * This is internal function is equivalent to {transfer}, and can be used to\\r\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `sender` cannot be the zero address.\\r\\n   * - `recipient` cannot be the zero address.\\r\\n   * - `sender` must have a balance of at least `amount`.\\r\\n   */\\r\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n    require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\r\\n    require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\r\\n\\r\\n    _balances[sender] = _balances[sender].sub(amount, \\\"BEP20: transfer amount exceeds balance...\\\");\\r\\n    _balances[recipient] = _balances[recipient].add(amount);\\r\\n    emit Transfer(sender, recipient, amount);\\r\\n  }\\r\\n\\r\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n   * the total supply.\\r\\n   *\\r\\n   * Emits a {Transfer} event with `from` set to the zero address.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `to` cannot be the zero address.\\r\\n   */\\r\\n  //function _mint(address account, uint256 amount) internal {\\r\\n  //  require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\r\\n\\r\\n  //  _totalSupply = _totalSupply.add(amount);\\r\\n  //  _balances[account] = _balances[account].add(amount);\\r\\n  //  emit Transfer(address(0), account, amount);\\r\\n  //}\\r\\n\\r\\n  /**\\r\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n   * total supply.\\r\\n   *\\r\\n   * Emits a {Transfer} event with `to` set to the zero address.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `account` cannot be the zero address.\\r\\n   * - `account` must have at least `amount` tokens.\\r\\n   */\\r\\n  //function _burn(address account, uint256 amount) internal {\\r\\n  //  require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\r\\n//\\r\\n  //  _balances[account] = _balances[account].sub(amount, \\\"BEP20: burn amount exceeds balance\\\");\\r\\n  //  _totalSupply = _totalSupply.sub(amount);\\r\\n  //  emit Transfer(account, address(0), amount);\\r\\n  //}\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n   *\\r\\n   * This is internal function is equivalent to `approve`, and can be used to\\r\\n   * e.g. set automatic allowances for certain subsystems, etc.\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `owner` cannot be the zero address.\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function _approve(address owner, address spender, uint256 amount) internal {\\r\\n    require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\r\\n    require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\r\\n\\r\\n    _allowances[owner][spender] = amount;\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\r\\n   * from the caller's allowance.\\r\\n   *\\r\\n   * See {_burn} and {_approve}.\\r\\n   */\\r\\n // function _burnFrom(address account, uint256 amount) internal {\\r\\n  //  _burn(account, amount);\\r\\n  //  _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"BEP20: burn amount exceeds allowance\\\"));\\r\\n  //}\\r\\n}\"\r\n    },\r\n    \"contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () {}\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this;\\r\\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IPancakeRouter01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\ninterface IBEP20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function getOwner() external view returns (address);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address _owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"BanStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busdReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateSwapRouter\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"AMMPairMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"getNumOfHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"get_all_holder_account\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct account_amount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"get_all_liquidity_holder_account\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct account_amount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"get_all_transfer_fee_holder_account\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct account_amount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_bonus_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_bonus_list\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"internalType\":\"struct liquidity_bonus_info[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_manager_marketing_address_info\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_marketing_address_info\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"get_surplus_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"metaverse\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spacestation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"investorA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"investorB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bonus\",\"type\":\"address\"}],\"name\":\"init_marketing_address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init_marketing_token_amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"is_white_list\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPairAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTradeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"msgSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buy_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"send_buy_cards_bonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"internalType\":\"struct cards_bonus[]\",\"name\":\"bonus_list\",\"type\":\"tuple[]\"}],\"name\":\"send_cards_auto_bonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"send_liquidity_amm_bonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxBonus\",\"type\":\"uint256\"}],\"name\":\"setMaxBonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTradeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonus_size\",\"type\":\"uint256\"}],\"name\":\"set_bonus_send_min\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"set_metaverse_wallet_address\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"opt\",\"type\":\"bool\"}],\"name\":\"set_sender_all_opt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wait_time\",\"type\":\"uint256\"}],\"name\":\"set_swap_bonus_wait_times\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"set_white_list\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typ1ProcessIdx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typ2ProcessIdx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typ3ProcessIdx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"update_liquidity_holder_address\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct liquidity_account_info[]\",\"name\":\"holder_list\",\"type\":\"tuple[]\"}],\"name\":\"update_liquidity_holder_address\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FitOutToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6ae0b90d677f1fb1d6654a66ad896c1cfad25cac4fca6b7fe34f5fff8fee0443"}