{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/BulkSeller/BulkSellerMathCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/TokenHelper.sol\\\";\\nimport \\\"../libraries/math/Math.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\n\\nstruct BulkSellerState {\\n    uint256 rateTokenToSy;\\n    uint256 rateSyToToken;\\n    uint256 totalToken;\\n    uint256 totalSy;\\n    uint256 feeRate;\\n}\\n\\nlibrary BulkSellerMathCore {\\n    using Math for uint256;\\n\\n    function swapExactTokenForSy(\\n        BulkSellerState memory state,\\n        uint256 netTokenIn\\n    ) internal pure returns (uint256 netSyOut) {\\n        netSyOut = calcSwapExactTokenForSy(state, netTokenIn);\\n        state.totalToken += netTokenIn;\\n        state.totalSy -= netSyOut;\\n    }\\n\\n    function swapExactSyForToken(\\n        BulkSellerState memory state,\\n        uint256 netSyIn\\n    ) internal pure returns (uint256 netTokenOut) {\\n        netTokenOut = calcSwapExactSyForToken(state, netSyIn);\\n        state.totalSy += netSyIn;\\n        state.totalToken -= netTokenOut;\\n    }\\n\\n    function calcSwapExactTokenForSy(\\n        BulkSellerState memory state,\\n        uint256 netTokenIn\\n    ) internal pure returns (uint256 netSyOut) {\\n        uint256 postFeeRate = state.rateTokenToSy.mulDown(Math.ONE - state.feeRate);\\n        assert(postFeeRate != 0);\\n\\n        netSyOut = netTokenIn.mulDown(postFeeRate);\\n        if (netSyOut > state.totalSy)\\n            revert Errors.BulkInsufficientSyForTrade(state.totalSy, netSyOut);\\n    }\\n\\n    function calcSwapExactSyForToken(\\n        BulkSellerState memory state,\\n        uint256 netSyIn\\n    ) internal pure returns (uint256 netTokenOut) {\\n        uint256 postFeeRate = state.rateSyToToken.mulDown(Math.ONE - state.feeRate);\\n        assert(postFeeRate != 0);\\n\\n        netTokenOut = netSyIn.mulDown(postFeeRate);\\n        if (netTokenOut > state.totalToken)\\n            revert Errors.BulkInsufficientTokenForTrade(state.totalToken, netTokenOut);\\n    }\\n\\n    function getTokenProp(BulkSellerState memory state) internal pure returns (uint256) {\\n        uint256 totalToken = state.totalToken;\\n        uint256 totalTokenFromSy = state.totalSy.mulDown(state.rateSyToToken);\\n        return totalToken.divDown(totalToken + totalTokenFromSy);\\n    }\\n\\n    function getReBalanceParams(\\n        BulkSellerState memory state,\\n        uint256 targetTokenProp\\n    ) internal pure returns (uint256 netTokenToDeposit, uint256 netSyToRedeem) {\\n        uint256 currentTokenProp = getTokenProp(state);\\n\\n        if (currentTokenProp > targetTokenProp) {\\n            netTokenToDeposit = state\\n                .totalToken\\n                .mulDown(currentTokenProp - targetTokenProp)\\n                .divDown(currentTokenProp);\\n        } else {\\n            uint256 currentSyProp = Math.ONE - currentTokenProp;\\n            netSyToRedeem = state.totalSy.mulDown(targetTokenProp - currentTokenProp).divDown(\\n                currentSyProp\\n            );\\n        }\\n    }\\n\\n    function reBalanceTokenToSy(\\n        BulkSellerState memory state,\\n        uint256 netTokenToDeposit,\\n        uint256 netSyFromToken,\\n        uint256 maxDiff\\n    ) internal pure {\\n        uint256 rate = netSyFromToken.divDown(netTokenToDeposit);\\n\\n        if (!Math.isAApproxB(rate, state.rateTokenToSy, maxDiff))\\n            revert Errors.BulkBadRateTokenToSy(rate, state.rateTokenToSy, maxDiff);\\n\\n        state.totalToken -= netTokenToDeposit;\\n        state.totalSy += netSyFromToken;\\n    }\\n\\n    function reBalanceSyToToken(\\n        BulkSellerState memory state,\\n        uint256 netSyToRedeem,\\n        uint256 netTokenFromSy,\\n        uint256 maxDiff\\n    ) internal pure {\\n        uint256 rate = netTokenFromSy.divDown(netSyToRedeem);\\n\\n        if (!Math.isAApproxB(rate, state.rateSyToToken, maxDiff))\\n            revert Errors.BulkBadRateSyToToken(rate, state.rateSyToToken, maxDiff);\\n\\n        state.totalToken += netTokenFromSy;\\n        state.totalSy -= netSyToRedeem;\\n    }\\n\\n    function setRate(\\n        BulkSellerState memory state,\\n        uint256 rateSyToToken,\\n        uint256 rateTokenToSy,\\n        uint256 maxDiff\\n    ) internal pure {\\n        if (\\n            state.rateTokenToSy != 0 &&\\n            !Math.isAApproxB(rateTokenToSy, state.rateTokenToSy, maxDiff)\\n        ) {\\n            revert Errors.BulkBadRateTokenToSy(rateTokenToSy, state.rateTokenToSy, maxDiff);\\n        }\\n\\n        if (\\n            state.rateSyToToken != 0 &&\\n            !Math.isAApproxB(rateSyToToken, state.rateSyToToken, maxDiff)\\n        ) {\\n            revert Errors.BulkBadRateSyToToken(rateSyToToken, state.rateSyToToken, maxDiff);\\n        }\\n\\n        state.rateTokenToSy = rateTokenToSy;\\n        state.rateSyToToken = rateSyToToken;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nlibrary Errors {\\n    // BulkSeller\\n    error BulkInsufficientSyForTrade(uint256 currentAmount, uint256 requiredAmount);\\n    error BulkInsufficientTokenForTrade(uint256 currentAmount, uint256 requiredAmount);\\n    error BulkInSufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\\n    error BulkInSufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n    error BulkInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error BulkNotMaintainer();\\n    error BulkNotAdmin();\\n    error BulkSellerAlreadyExisted(address token, address SY, address bulk);\\n    error BulkSellerInvalidToken(address token, address SY);\\n    error BulkBadRateTokenToSy(uint256 actualRate, uint256 currentRate, uint256 eps);\\n    error BulkBadRateSyToToken(uint256 actualRate, uint256 currentRate, uint256 eps);\\n\\n    // APPROX\\n    error ApproxFail();\\n    error ApproxParamsInvalid(uint256 guessMin, uint256 guessMax, uint256 eps);\\n    error ApproxBinarySearchInputInvalid(\\n        uint256 approxGuessMin,\\n        uint256 approxGuessMax,\\n        uint256 minGuessMin,\\n        uint256 maxGuessMax\\n    );\\n\\n    // MARKET + MARKET MATH CORE\\n    error MarketExpired();\\n    error MarketZeroAmountsInput();\\n    error MarketZeroAmountsOutput();\\n    error MarketZeroLnImpliedRate();\\n    error MarketInsufficientPtForTrade(int256 currentAmount, int256 requiredAmount);\\n    error MarketInsufficientPtReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error MarketInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error MarketZeroTotalPtOrTotalAsset(int256 totalPt, int256 totalAsset);\\n    error MarketExchangeRateBelowOne(int256 exchangeRate);\\n    error MarketProportionMustNotEqualOne();\\n    error MarketRateScalarBelowZero(int256 rateScalar);\\n    error MarketScalarRootBelowZero(int256 scalarRoot);\\n    error MarketProportionTooHigh(int256 proportion, int256 maxProportion);\\n\\n    error OracleUninitialized();\\n    error OracleTargetTooOld(uint32 target, uint32 oldest);\\n    error OracleZeroCardinality();\\n\\n    error MarketFactoryExpiredPt();\\n    error MarketFactoryInvalidPt();\\n    error MarketFactoryMarketExists();\\n\\n    error MarketFactoryLnFeeRateRootTooHigh(uint80 lnFeeRateRoot, uint256 maxLnFeeRateRoot);\\n    error MarketFactoryReserveFeePercentTooHigh(\\n        uint8 reserveFeePercent,\\n        uint8 maxReserveFeePercent\\n    );\\n    error MarketFactoryZeroTreasury();\\n    error MarketFactoryInitialAnchorTooLow(int256 initialAnchor, int256 minInitialAnchor);\\n\\n    // ROUTER\\n    error RouterInsufficientLpOut(uint256 actualLpOut, uint256 requiredLpOut);\\n    error RouterInsufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\\n    error RouterInsufficientPtOut(uint256 actualPtOut, uint256 requiredPtOut);\\n    error RouterInsufficientYtOut(uint256 actualYtOut, uint256 requiredYtOut);\\n    error RouterInsufficientPYOut(uint256 actualPYOut, uint256 requiredPYOut);\\n    error RouterInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n    error RouterExceededLimitSyIn(uint256 actualSyIn, uint256 limitSyIn);\\n    error RouterExceededLimitPtIn(uint256 actualPtIn, uint256 limitPtIn);\\n    error RouterExceededLimitYtIn(uint256 actualYtIn, uint256 limitYtIn);\\n    error RouterInsufficientSyRepay(uint256 actualSyRepay, uint256 requiredSyRepay);\\n    error RouterInsufficientPtRepay(uint256 actualPtRepay, uint256 requiredPtRepay);\\n    error RouterNotAllSyUsed(uint256 netSyDesired, uint256 netSyUsed);\\n\\n    error RouterTimeRangeZero();\\n    error RouterCallbackNotPendleMarket(address caller);\\n    error RouterInvalidAction(bytes4 selector);\\n    error RouterInvalidFacet(address facet);\\n\\n    error RouterKyberSwapDataZero();\\n\\n    // YIELD CONTRACT\\n    error YCExpired();\\n    error YCNotExpired();\\n    error YieldContractInsufficientSy(uint256 actualSy, uint256 requiredSy);\\n    error YCNothingToRedeem();\\n    error YCPostExpiryDataNotSet();\\n    error YCNoFloatingSy();\\n\\n    // YieldFactory\\n    error YCFactoryInvalidExpiry();\\n    error YCFactoryYieldContractExisted();\\n    error YCFactoryZeroExpiryDivisor();\\n    error YCFactoryZeroTreasury();\\n    error YCFactoryInterestFeeRateTooHigh(uint256 interestFeeRate, uint256 maxInterestFeeRate);\\n    error YCFactoryRewardFeeRateTooHigh(uint256 newRewardFeeRate, uint256 maxRewardFeeRate);\\n\\n    // SY\\n    error SYInvalidTokenIn(address token);\\n    error SYInvalidTokenOut(address token);\\n    error SYZeroDeposit();\\n    error SYZeroRedeem();\\n    error SYInsufficientSharesOut(uint256 actualSharesOut, uint256 requiredSharesOut);\\n    error SYInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n\\n    // SY-specific\\n    error SYQiTokenMintFailed(uint256 errCode);\\n    error SYQiTokenRedeemFailed(uint256 errCode);\\n    error SYQiTokenRedeemRewardsFailed(uint256 rewardAccruedType0, uint256 rewardAccruedType1);\\n    error SYQiTokenBorrowRateTooHigh(uint256 borrowRate, uint256 borrowRateMax);\\n\\n    error SYCurveInvalidPid();\\n    error SYCurve3crvPoolNotFound();\\n\\n    error SYApeDepositAmountTooSmall(uint256 amountDeposited);\\n    error SYBalancerInvalidPid();\\n    error SYInvalidRewardToken(address token);\\n\\n    error SYStargateRedeemCapExceeded(uint256 amountLpDesired, uint256 amountLpRedeemable);\\n\\n    error SYBalancerReentrancy();\\n\\n    // Liquidity Mining\\n    error VCInactivePool(address pool);\\n    error VCPoolAlreadyActive(address pool);\\n    error VCZeroVePendle(address user);\\n    error VCExceededMaxWeight(uint256 totalWeight, uint256 maxWeight);\\n    error VCEpochNotFinalized(uint256 wTime);\\n    error VCPoolAlreadyAddAndRemoved(address pool);\\n\\n    error VEInvalidNewExpiry(uint256 newExpiry);\\n    error VEExceededMaxLockTime();\\n    error VEInsufficientLockTime();\\n    error VENotAllowedReduceExpiry();\\n    error VEZeroAmountLocked();\\n    error VEPositionNotExpired();\\n    error VEZeroPosition();\\n    error VEZeroSlope(uint128 bias, uint128 slope);\\n    error VEReceiveOldSupply(uint256 msgTime);\\n\\n    error GCNotPendleMarket(address caller);\\n    error GCNotVotingController(address caller);\\n\\n    error InvalidWTime(uint256 wTime);\\n    error ExpiryInThePast(uint256 expiry);\\n    error ChainNotSupported(uint256 chainId);\\n\\n    error FDTotalAmountFundedNotMatch(uint256 actualTotalAmount, uint256 expectedTotalAmount);\\n    error FDEpochLengthMismatch();\\n    error FDInvalidPool(address pool);\\n    error FDPoolAlreadyExists(address pool);\\n    error FDInvalidNewFinishedEpoch(uint256 oldFinishedEpoch, uint256 newFinishedEpoch);\\n    error FDInvalidStartEpoch(uint256 startEpoch);\\n    error FDInvalidWTimeFund(uint256 lastFunded, uint256 wTime);\\n    error FDFutureFunding(uint256 lastFunded, uint256 currentWTime);\\n\\n    error BDInvalidEpoch(uint256 epoch, uint256 startTime);\\n\\n    // Cross-Chain\\n    error MsgNotFromSendEndpoint(uint16 srcChainId, bytes path);\\n    error MsgNotFromReceiveEndpoint(address sender);\\n    error InsufficientFeeToSendMsg(uint256 currentFee, uint256 requiredFee);\\n    error ApproxDstExecutionGasNotSet();\\n    error InvalidRetryData();\\n\\n    // GENERIC MSG\\n    error ArrayLengthMismatch();\\n    error ArrayEmpty();\\n    error ArrayOutOfBounds();\\n    error ZeroAddress();\\n    error FailedToSendEther();\\n    error InvalidMerkleProof();\\n\\n    error OnlyLayerZeroEndpoint();\\n    error OnlyYT();\\n    error OnlyYCFactory();\\n    error OnlyWhitelisted();\\n\\n    // Swap Aggregator\\n    error SAInsufficientTokenIn(address tokenIn, uint256 amountExpected, uint256 amountActual);\\n    error UnsupportedSelector(uint256 aggregatorType, bytes4 selector);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/libraries/math/LogExpMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity 0.8.17;\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        unchecked {\\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \\\"Invalid exponent\\\");\\n\\n            if (x < 0) {\\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n                // Fixed point division requires multiplying by ONE_18.\\n                return ((ONE_18 * ONE_18) / exp(-x));\\n            }\\n\\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n            // decomposition.\\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest x_n.\\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n            // decomposition.\\n\\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n            // it and compute the accumulated product.\\n\\n            int256 firstAN;\\n            if (x >= x0) {\\n                x -= x0;\\n                firstAN = a0;\\n            } else if (x >= x1) {\\n                x -= x1;\\n                firstAN = a1;\\n            } else {\\n                firstAN = 1; // One with no decimal places\\n            }\\n\\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n            // smaller terms.\\n            x *= 100;\\n\\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n            int256 product = ONE_20;\\n\\n            if (x >= x2) {\\n                x -= x2;\\n                product = (product * a2) / ONE_20;\\n            }\\n            if (x >= x3) {\\n                x -= x3;\\n                product = (product * a3) / ONE_20;\\n            }\\n            if (x >= x4) {\\n                x -= x4;\\n                product = (product * a4) / ONE_20;\\n            }\\n            if (x >= x5) {\\n                x -= x5;\\n                product = (product * a5) / ONE_20;\\n            }\\n            if (x >= x6) {\\n                x -= x6;\\n                product = (product * a6) / ONE_20;\\n            }\\n            if (x >= x7) {\\n                x -= x7;\\n                product = (product * a7) / ONE_20;\\n            }\\n            if (x >= x8) {\\n                x -= x8;\\n                product = (product * a8) / ONE_20;\\n            }\\n            if (x >= x9) {\\n                x -= x9;\\n                product = (product * a9) / ONE_20;\\n            }\\n\\n            // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n            // The first term is simply x.\\n            term = x;\\n            seriesSum += term;\\n\\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n            term = ((term * x) / ONE_20) / 2;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 3;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 4;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 5;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 6;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 7;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 8;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 9;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 10;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 11;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 12;\\n            seriesSum += term;\\n\\n            // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n            // and then drop two digits to return an 18 decimal value.\\n\\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        unchecked {\\n            // The real natural logarithm is not defined for negative numbers or zero.\\n            require(a > 0, \\\"out of bounds\\\");\\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n                return _ln_36(a) / ONE_18;\\n            } else {\\n                return _ln(a);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            if (y == 0) {\\n                // We solve the 0^0 indetermination by making it equal one.\\n                return uint256(ONE_18);\\n            }\\n\\n            if (x == 0) {\\n                return 0;\\n            }\\n\\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n            // x^y = exp(y * ln(x)).\\n\\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n            require(x < 2 ** 255, \\\"x out of bounds\\\");\\n            int256 x_int256 = int256(x);\\n\\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n            require(y < MILD_EXPONENT_BOUND, \\\"y out of bounds\\\");\\n            int256 y_int256 = int256(y);\\n\\n            int256 logx_times_y;\\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n                int256 ln_36_x = _ln_36(x_int256);\\n\\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n                // (downscaled) last 18 decimals.\\n                logx_times_y = ((ln_36_x / ONE_18) *\\n                    y_int256 +\\n                    ((ln_36_x % ONE_18) * y_int256) /\\n                    ONE_18);\\n            } else {\\n                logx_times_y = _ln(x_int256) * y_int256;\\n            }\\n            logx_times_y /= ONE_18;\\n\\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n            require(\\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n                \\\"product out of bounds\\\"\\n            );\\n\\n            return uint256(exp(logx_times_y));\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        unchecked {\\n            if (a < ONE_18) {\\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n                // Fixed point division requires multiplying by ONE_18.\\n                return (-_ln((ONE_18 * ONE_18) / a));\\n            }\\n\\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest a_n.\\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n            // ONE_18 to convert them to fixed point.\\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n            // by it and compute the accumulated sum.\\n\\n            int256 sum = 0;\\n            if (a >= a0 * ONE_18) {\\n                a /= a0; // Integer, not fixed point division\\n                sum += x0;\\n            }\\n\\n            if (a >= a1 * ONE_18) {\\n                a /= a1; // Integer, not fixed point division\\n                sum += x1;\\n            }\\n\\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n            sum *= 100;\\n            a *= 100;\\n\\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n            if (a >= a2) {\\n                a = (a * ONE_20) / a2;\\n                sum += x2;\\n            }\\n\\n            if (a >= a3) {\\n                a = (a * ONE_20) / a3;\\n                sum += x3;\\n            }\\n\\n            if (a >= a4) {\\n                a = (a * ONE_20) / a4;\\n                sum += x4;\\n            }\\n\\n            if (a >= a5) {\\n                a = (a * ONE_20) / a5;\\n                sum += x5;\\n            }\\n\\n            if (a >= a6) {\\n                a = (a * ONE_20) / a6;\\n                sum += x6;\\n            }\\n\\n            if (a >= a7) {\\n                a = (a * ONE_20) / a7;\\n                sum += x7;\\n            }\\n\\n            if (a >= a8) {\\n                a = (a * ONE_20) / a8;\\n                sum += x8;\\n            }\\n\\n            if (a >= a9) {\\n                a = (a * ONE_20) / a9;\\n                sum += x9;\\n            }\\n\\n            if (a >= a10) {\\n                a = (a * ONE_20) / a10;\\n                sum += x10;\\n            }\\n\\n            if (a >= a11) {\\n                a = (a * ONE_20) / a11;\\n                sum += x11;\\n            }\\n\\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n            // Let z = (a - 1) / (a + 1).\\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n            // division by ONE_20.\\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n            int256 z_squared = (z * z) / ONE_20;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 11;\\n\\n            // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n            seriesSum *= 2;\\n\\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n            // value.\\n\\n            return (sum + seriesSum) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        unchecked {\\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n            // worthwhile.\\n\\n            // First, we transform x to a 36 digit fixed point value.\\n            x *= ONE_18;\\n\\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n            // division by ONE_36.\\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n            int256 z_squared = (z * z) / ONE_36;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 11;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 13;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 15;\\n\\n            // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // All that remains is multiplying by 2 (non fixed point).\\n            return seriesSum * 2;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/libraries/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.17;\\n\\n/* solhint-disable private-vars-leading-underscore, reason-string */\\n\\nlibrary Math {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    int256 internal constant IONE = 1e18; // 18 decimal places\\n\\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return (a >= b ? a - b : 0);\\n        }\\n    }\\n\\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\\n        require(a >= b, \\\"negative\\\");\\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        unchecked {\\n            return product / ONE;\\n        }\\n    }\\n\\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\\n        int256 product = a * b;\\n        unchecked {\\n            return product / IONE;\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 aInflated = a * ONE;\\n        unchecked {\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\\n        int256 aInflated = a * IONE;\\n        unchecked {\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a + b - 1) / b;\\n    }\\n\\n    // @author Uniswap\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    function square(uint256 x) internal pure returns (uint256) {\\n        return x * x;\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x > 0 ? x : -x);\\n    }\\n\\n    function neg(int256 x) internal pure returns (int256) {\\n        return x * (-1);\\n    }\\n\\n    function neg(uint256 x) internal pure returns (int256) {\\n        return Int(x) * (-1);\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return (x > y ? x : y);\\n    }\\n\\n    function max(int256 x, int256 y) internal pure returns (int256) {\\n        return (x > y ? x : y);\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return (x < y ? x : y);\\n    }\\n\\n    function min(int256 x, int256 y) internal pure returns (int256) {\\n        return (x < y ? x : y);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               SIGNED CASTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function Int(uint256 x) internal pure returns (int256) {\\n        require(x <= uint256(type(int256).max));\\n        return int256(x);\\n    }\\n\\n    function Int128(int256 x) internal pure returns (int128) {\\n        require(type(int128).min <= x && x <= type(int128).max);\\n        return int128(x);\\n    }\\n\\n    function Int128(uint256 x) internal pure returns (int128) {\\n        return Int128(Int(x));\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               UNSIGNED CASTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function Uint(int256 x) internal pure returns (uint256) {\\n        require(x >= 0);\\n        return uint256(x);\\n    }\\n\\n    function Uint32(uint256 x) internal pure returns (uint32) {\\n        require(x <= type(uint32).max);\\n        return uint32(x);\\n    }\\n\\n    function Uint112(uint256 x) internal pure returns (uint112) {\\n        require(x <= type(uint112).max);\\n        return uint112(x);\\n    }\\n\\n    function Uint96(uint256 x) internal pure returns (uint96) {\\n        require(x <= type(uint96).max);\\n        return uint96(x);\\n    }\\n\\n    function Uint128(uint256 x) internal pure returns (uint128) {\\n        require(x <= type(uint128).max);\\n        return uint128(x);\\n    }\\n\\n    function isAApproxB(\\n        uint256 a,\\n        uint256 b,\\n        uint256 eps\\n    ) internal pure returns (bool) {\\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\\n    }\\n\\n    function isAGreaterApproxB(\\n        uint256 a,\\n        uint256 b,\\n        uint256 eps\\n    ) internal pure returns (bool) {\\n        return a >= b && a <= mulDown(b, ONE + eps);\\n    }\\n\\n    function isASmallerApproxB(\\n        uint256 a,\\n        uint256 b,\\n        uint256 eps\\n    ) internal pure returns (bool) {\\n        return a <= b && a >= mulDown(b, ONE - eps);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/libraries/MiniHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nlibrary MiniHelpers {\\n    function isCurrentlyExpired(uint256 expiry) internal view returns (bool) {\\n        return (expiry <= block.timestamp);\\n    }\\n\\n    function isExpired(uint256 expiry, uint256 blockTime) internal pure returns (bool) {\\n        return (expiry <= blockTime);\\n    }\\n\\n    function isTimeInThePast(uint256 timestamp) internal view returns (bool) {\\n        return (timestamp <= block.timestamp); // same definition as isCurrentlyExpired\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/libraries/TokenHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/IWETH.sol\\\";\\n\\nabstract contract TokenHelper {\\n    using SafeERC20 for IERC20;\\n    address internal constant NATIVE = address(0);\\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\\n\\n    function _transferIn(address token, address from, uint256 amount) internal {\\n        if (token == NATIVE) require(msg.value == amount, \\\"eth mismatch\\\");\\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\\n    }\\n\\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\\n    }\\n\\n    function _transferOut(address token, address to, uint256 amount) internal {\\n        if (amount == 0) return;\\n        if (token == NATIVE) {\\n            (bool success, ) = to.call{ value: amount }(\\\"\\\");\\n            require(success, \\\"eth send failed\\\");\\n        } else {\\n            IERC20(token).safeTransfer(to, amount);\\n        }\\n    }\\n\\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\\n        uint256 numTokens = tokens.length;\\n        require(numTokens == amounts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < numTokens; ) {\\n            _transferOut(tokens[i], to, amounts[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function _selfBalance(address token) internal view returns (uint256) {\\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\\n    function _safeApprove(address token, address to, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"Safe Approve\\\");\\n    }\\n\\n    function _safeApproveInf(address token, address to) internal {\\n        if (token == NATIVE) return;\\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\\n            _safeApprove(token, to, 0);\\n            _safeApprove(token, to, type(uint256).max);\\n        }\\n    }\\n\\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{ value: netTokenIn }();\\n        else IWETH(tokenIn).withdraw(netTokenIn);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/Market/MarketMathCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/math/Math.sol\\\";\\nimport \\\"../libraries/math/LogExpMath.sol\\\";\\n\\nimport \\\"../StandardizedYield/PYIndex.sol\\\";\\nimport \\\"../libraries/MiniHelpers.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\n\\nstruct MarketState {\\n    int256 totalPt;\\n    int256 totalSy;\\n    int256 totalLp;\\n    address treasury;\\n    /// immutable variables ///\\n    int256 scalarRoot;\\n    uint256 expiry;\\n    /// fee data ///\\n    uint256 lnFeeRateRoot;\\n    uint256 reserveFeePercent; // base 100\\n    /// last trade data ///\\n    uint256 lastLnImpliedRate;\\n}\\n\\n// params that are expensive to compute, therefore we pre-compute them\\nstruct MarketPreCompute {\\n    int256 rateScalar;\\n    int256 totalAsset;\\n    int256 rateAnchor;\\n    int256 feeRate;\\n}\\n\\n// solhint-disable ordering\\nlibrary MarketMathCore {\\n    using Math for uint256;\\n    using Math for int256;\\n    using LogExpMath for int256;\\n    using PYIndexLib for PYIndex;\\n\\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\\n    uint256 internal constant DAY = 86400;\\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\\n\\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\\n\\n    using Math for uint256;\\n    using Math for int256;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function addLiquidity(\\n        MarketState memory market,\\n        uint256 syDesired,\\n        uint256 ptDesired,\\n        uint256 blockTime\\n    )\\n        internal\\n        pure\\n        returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed)\\n    {\\n        (\\n            int256 _lpToReserve,\\n            int256 _lpToAccount,\\n            int256 _syUsed,\\n            int256 _ptUsed\\n        ) = addLiquidityCore(market, syDesired.Int(), ptDesired.Int(), blockTime);\\n\\n        lpToReserve = _lpToReserve.Uint();\\n        lpToAccount = _lpToAccount.Uint();\\n        syUsed = _syUsed.Uint();\\n        ptUsed = _ptUsed.Uint();\\n    }\\n\\n    function removeLiquidity(\\n        MarketState memory market,\\n        uint256 lpToRemove\\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\\n\\n        netSyToAccount = _syToAccount.Uint();\\n        netPtToAccount = _ptToAccount.Uint();\\n    }\\n\\n    function swapExactPtForSy(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactPtToMarket,\\n        uint256 blockTime\\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\\n            market,\\n            index,\\n            exactPtToMarket.neg(),\\n            blockTime\\n        );\\n\\n        netSyToAccount = _netSyToAccount.Uint();\\n        netSyFee = _netSyFee.Uint();\\n        netSyToReserve = _netSyToReserve.Uint();\\n    }\\n\\n    function swapSyForExactPt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactPtToAccount,\\n        uint256 blockTime\\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\\n            market,\\n            index,\\n            exactPtToAccount.Int(),\\n            blockTime\\n        );\\n\\n        netSyToMarket = _netSyToAccount.neg().Uint();\\n        netSyFee = _netSyFee.Uint();\\n        netSyToReserve = _netSyToReserve.Uint();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    CORE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function addLiquidityCore(\\n        MarketState memory market,\\n        int256 syDesired,\\n        int256 ptDesired,\\n        uint256 blockTime\\n    )\\n        internal\\n        pure\\n        returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed)\\n    {\\n        /// ------------------------------------------------------------\\n        /// CHECKS\\n        /// ------------------------------------------------------------\\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\\n\\n        /// ------------------------------------------------------------\\n        /// MATH\\n        /// ------------------------------------------------------------\\n        if (market.totalLp == 0) {\\n            lpToAccount = Math.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\\n            lpToReserve = MINIMUM_LIQUIDITY;\\n            syUsed = syDesired;\\n            ptUsed = ptDesired;\\n        } else {\\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\\n            if (netLpByPt < netLpBySy) {\\n                lpToAccount = netLpByPt;\\n                ptUsed = ptDesired;\\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\\n            } else {\\n                lpToAccount = netLpBySy;\\n                syUsed = syDesired;\\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\\n            }\\n        }\\n\\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\\n\\n        /// ------------------------------------------------------------\\n        /// WRITE\\n        /// ------------------------------------------------------------\\n        market.totalSy += syUsed;\\n        market.totalPt += ptUsed;\\n        market.totalLp += lpToAccount + lpToReserve;\\n    }\\n\\n    function removeLiquidityCore(\\n        MarketState memory market,\\n        int256 lpToRemove\\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\\n        /// ------------------------------------------------------------\\n        /// CHECKS\\n        /// ------------------------------------------------------------\\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\\n\\n        /// ------------------------------------------------------------\\n        /// MATH\\n        /// ------------------------------------------------------------\\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\\n\\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\\n\\n        /// ------------------------------------------------------------\\n        /// WRITE\\n        /// ------------------------------------------------------------\\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\\n    }\\n\\n    function executeTradeCore(\\n        MarketState memory market,\\n        PYIndex index,\\n        int256 netPtToAccount,\\n        uint256 blockTime\\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\\n        /// ------------------------------------------------------------\\n        /// CHECKS\\n        /// ------------------------------------------------------------\\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\\n        if (market.totalPt <= netPtToAccount)\\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\\n\\n        /// ------------------------------------------------------------\\n        /// MATH\\n        /// ------------------------------------------------------------\\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\\n\\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(\\n            market,\\n            comp,\\n            index,\\n            netPtToAccount\\n        );\\n\\n        /// ------------------------------------------------------------\\n        /// WRITE\\n        /// ------------------------------------------------------------\\n        _setNewMarketStateTrade(\\n            market,\\n            comp,\\n            index,\\n            netPtToAccount,\\n            netSyToAccount,\\n            netSyToReserve,\\n            blockTime\\n        );\\n    }\\n\\n    function getMarketPreCompute(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 blockTime\\n    ) internal pure returns (MarketPreCompute memory res) {\\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\\n\\n        uint256 timeToExpiry = market.expiry - blockTime;\\n\\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\\n        res.totalAsset = index.syToAsset(market.totalSy);\\n\\n        if (market.totalPt == 0 || res.totalAsset == 0)\\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\\n\\n        res.rateAnchor = _getRateAnchor(\\n            market.totalPt,\\n            market.lastLnImpliedRate,\\n            res.totalAsset,\\n            res.rateScalar,\\n            timeToExpiry\\n        );\\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\\n    }\\n\\n    function calcTrade(\\n        MarketState memory market,\\n        MarketPreCompute memory comp,\\n        PYIndex index,\\n        int256 netPtToAccount\\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\\n        int256 preFeeExchangeRate = _getExchangeRate(\\n            market.totalPt,\\n            comp.totalAsset,\\n            comp.rateScalar,\\n            comp.rateAnchor,\\n            netPtToAccount\\n        );\\n\\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\\n        int256 fee = comp.feeRate;\\n\\n        if (netPtToAccount > 0) {\\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\\n            if (postFeeExchangeRate < Math.IONE)\\n                revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\\n\\n            fee = preFeeAssetToAccount.mulDown(Math.IONE - fee);\\n        } else {\\n            fee = ((preFeeAssetToAccount * (Math.IONE - fee)) / fee).neg();\\n        }\\n\\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\\n\\n        netSyToAccount = netAssetToAccount < 0\\n            ? index.assetToSyUp(netAssetToAccount)\\n            : index.assetToSy(netAssetToAccount);\\n        netSyFee = index.assetToSy(fee);\\n        netSyToReserve = index.assetToSy(netAssetToReserve);\\n    }\\n\\n    function _setNewMarketStateTrade(\\n        MarketState memory market,\\n        MarketPreCompute memory comp,\\n        PYIndex index,\\n        int256 netPtToAccount,\\n        int256 netSyToAccount,\\n        int256 netSyToReserve,\\n        uint256 blockTime\\n    ) internal pure {\\n        uint256 timeToExpiry = market.expiry - blockTime;\\n\\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\\n\\n        market.lastLnImpliedRate = _getLnImpliedRate(\\n            market.totalPt,\\n            index.syToAsset(market.totalSy),\\n            comp.rateScalar,\\n            comp.rateAnchor,\\n            timeToExpiry\\n        );\\n\\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\\n    }\\n\\n    function _getRateAnchor(\\n        int256 totalPt,\\n        uint256 lastLnImpliedRate,\\n        int256 totalAsset,\\n        int256 rateScalar,\\n        uint256 timeToExpiry\\n    ) internal pure returns (int256 rateAnchor) {\\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\\n\\n        if (newExchangeRate < Math.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\\n\\n        {\\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\\n\\n            int256 lnProportion = _logProportion(proportion);\\n\\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\\n        }\\n    }\\n\\n    /// @notice Calculates the current market implied rate.\\n    /// @return lnImpliedRate the implied rate\\n    function _getLnImpliedRate(\\n        int256 totalPt,\\n        int256 totalAsset,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        uint256 timeToExpiry\\n    ) internal pure returns (uint256 lnImpliedRate) {\\n        // This will check for exchange rates < Math.IONE\\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\\n\\n        // exchangeRate >= 1 so its ln >= 0\\n        uint256 lnRate = exchangeRate.ln().Uint();\\n\\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\\n    }\\n\\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\\n    /// formula is E = e^rt\\n    function _getExchangeRateFromImpliedRate(\\n        uint256 lnImpliedRate,\\n        uint256 timeToExpiry\\n    ) internal pure returns (int256 exchangeRate) {\\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\\n\\n        exchangeRate = LogExpMath.exp(rt.Int());\\n    }\\n\\n    function _getExchangeRate(\\n        int256 totalPt,\\n        int256 totalAsset,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        int256 netPtToAccount\\n    ) internal pure returns (int256 exchangeRate) {\\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\\n\\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\\n\\n        if (proportion > MAX_MARKET_PROPORTION)\\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\\n\\n        int256 lnProportion = _logProportion(proportion);\\n\\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\\n\\n        if (exchangeRate < Math.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\\n    }\\n\\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\\n        if (proportion == Math.IONE) revert Errors.MarketProportionMustNotEqualOne();\\n\\n        int256 logitP = proportion.divDown(Math.IONE - proportion);\\n\\n        res = logitP.ln();\\n    }\\n\\n    function _getRateScalar(\\n        MarketState memory market,\\n        uint256 timeToExpiry\\n    ) internal pure returns (int256 rateScalar) {\\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\\n    }\\n\\n    function setInitialLnImpliedRate(\\n        MarketState memory market,\\n        PYIndex index,\\n        int256 initialAnchor,\\n        uint256 blockTime\\n    ) internal pure {\\n        /// ------------------------------------------------------------\\n        /// CHECKS\\n        /// ------------------------------------------------------------\\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\\n\\n        /// ------------------------------------------------------------\\n        /// MATH\\n        /// ------------------------------------------------------------\\n        int256 totalAsset = index.syToAsset(market.totalSy);\\n        uint256 timeToExpiry = market.expiry - blockTime;\\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\\n\\n        /// ------------------------------------------------------------\\n        /// WRITE\\n        /// ------------------------------------------------------------\\n        market.lastLnImpliedRate = _getLnImpliedRate(\\n            market.totalPt,\\n            totalAsset,\\n            rateScalar,\\n            initialAnchor,\\n            timeToExpiry\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/StandardizedYield/PYIndex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\nimport \\\"../../interfaces/IPYieldToken.sol\\\";\\nimport \\\"../../interfaces/IPPrincipalToken.sol\\\";\\n\\nimport \\\"./SYUtils.sol\\\";\\nimport \\\"../libraries/math/Math.sol\\\";\\n\\ntype PYIndex is uint256;\\n\\nlibrary PYIndexLib {\\n    using Math for uint256;\\n    using Math for int256;\\n\\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\\n        return PYIndex.wrap(YT.pyIndexCurrent());\\n    }\\n\\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\\n    }\\n\\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\\n    }\\n\\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\\n    }\\n\\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\\n        uint256 _index = PYIndex.unwrap(index);\\n        return SYUtils.syToAssetUp(_index, syAmount);\\n    }\\n\\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\\n    }\\n\\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\\n    }\\n\\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/core/StandardizedYield/SYUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nlibrary SYUtils {\\n    uint256 internal constant ONE = 1e18;\\n\\n    function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\\n        return (syAmount * exchangeRate) / ONE;\\n    }\\n\\n    function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\\n    }\\n\\n    function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\\n        return (assetAmount * ONE) / exchangeRate;\\n    }\\n\\n    function assetToSyUp(\\n        uint256 exchangeRate,\\n        uint256 assetAmount\\n    ) internal pure returns (uint256) {\\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(\\n        address _facet\\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPActionAddRemoveLiq.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../router/base/MarketApproxLib.sol\\\";\\nimport \\\"../router/base/ActionBaseMintRedeem.sol\\\";\\n\\ninterface IPActionAddRemoveLiq {\\n    event AddLiquidityDualSyAndPt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netSyUsed,\\n        uint256 netPtUsed,\\n        uint256 netLpOut\\n    );\\n\\n    event AddLiquidityDualTokenAndPt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed tokenIn,\\n        address receiver,\\n        uint256 netTokenUsed,\\n        uint256 netPtUsed,\\n        uint256 netLpOut\\n    );\\n\\n    event AddLiquiditySinglePt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netPtIn,\\n        uint256 netLpOut\\n    );\\n\\n    event AddLiquiditySingleSy(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netSyIn,\\n        uint256 netLpOut\\n    );\\n\\n    event AddLiquiditySingleToken(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 netLpOut\\n    );\\n\\n    event AddLiquiditySingleSyKeepYt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netSyIn,\\n        uint256 netLpOut,\\n        uint256 netYtOut\\n    );\\n\\n    event AddLiquiditySingleTokenKeepYt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 netLpOut,\\n        uint256 netYtOut\\n    );\\n\\n    event RemoveLiquidityDualSyAndPt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netLpToRemove,\\n        uint256 netPtOut,\\n        uint256 netSyOut\\n    );\\n\\n    event RemoveLiquidityDualTokenAndPt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed tokenOut,\\n        address receiver,\\n        uint256 netLpToRemove,\\n        uint256 netPtOut,\\n        uint256 netTokenOut\\n    );\\n\\n    event RemoveLiquiditySinglePt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netLpToRemove,\\n        uint256 netPtOut\\n    );\\n\\n    event RemoveLiquiditySingleSy(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netLpToRemove,\\n        uint256 netSyOut\\n    );\\n\\n    event RemoveLiquiditySingleToken(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        uint256 netLpToRemove,\\n        uint256 netTokenOut\\n    );\\n\\n    function addLiquidityDualSyAndPt(\\n        address receiver,\\n        address market,\\n        uint256 netSyDesired,\\n        uint256 netPtDesired,\\n        uint256 minLpOut\\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\\n\\n    function addLiquidityDualTokenAndPt(\\n        address receiver,\\n        address market,\\n        TokenInput calldata input,\\n        uint256 netPtDesired,\\n        uint256 minLpOut\\n    ) external payable returns (uint256 netLpOut, uint256 netTokenUsed, uint256 netPtUsed);\\n\\n    function addLiquiditySinglePt(\\n        address receiver,\\n        address market,\\n        uint256 netPtIn,\\n        uint256 minLpOut,\\n        ApproxParams calldata guessPtSwapToSy\\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\\n\\n    function addLiquiditySingleSy(\\n        address receiver,\\n        address market,\\n        uint256 netSyIn,\\n        uint256 minLpOut,\\n        ApproxParams calldata guessPtReceivedFromSy\\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\\n\\n    function addLiquiditySingleToken(\\n        address receiver,\\n        address market,\\n        uint256 minLpOut,\\n        ApproxParams calldata guessPtReceivedFromSy,\\n        TokenInput calldata input\\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee);\\n\\n    function addLiquiditySingleSyKeepYt(\\n        address receiver,\\n        address market,\\n        uint256 netSyIn,\\n        uint256 minLpOut,\\n        uint256 minYtOut\\n    ) external returns (uint256 netLpOut, uint256 netYtOut);\\n\\n    function addLiquiditySingleTokenKeepYt(\\n        address receiver,\\n        address market,\\n        uint256 minLpOut,\\n        uint256 minYtOut,\\n        TokenInput calldata input\\n    ) external returns (uint256 netLpOut, uint256 netYtOut);\\n\\n    function removeLiquidityDualSyAndPt(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        uint256 minSyOut,\\n        uint256 minPtOut\\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\\n\\n    function removeLiquidityDualTokenAndPt(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        TokenOutput calldata output,\\n        uint256 minPtOut\\n    ) external returns (uint256 netTokenOut, uint256 netPtOut);\\n\\n    function removeLiquiditySinglePt(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        uint256 minPtOut,\\n        ApproxParams calldata guessPtOut\\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\\n\\n    function removeLiquiditySingleSy(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        uint256 minSyOut\\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\\n\\n    function removeLiquiditySingleToken(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        TokenOutput calldata output\\n    ) external returns (uint256 netTokenOut, uint256 netSyFee);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPActionMintRedeem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../router/base/MarketApproxLib.sol\\\";\\nimport \\\"../router/base/ActionBaseMintRedeem.sol\\\";\\n\\ninterface IPActionMintRedeem {\\n    event MintSyFromToken(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed SY,\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 netSyOut\\n    );\\n\\n    event RedeemSyToToken(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        address indexed SY,\\n        address receiver,\\n        uint256 netSyIn,\\n        uint256 netTokenOut\\n    );\\n\\n    event MintPyFromSy(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed YT,\\n        uint256 netSyIn,\\n        uint256 netPyOut\\n    );\\n\\n    event RedeemPyToSy(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed YT,\\n        uint256 netPyIn,\\n        uint256 netSyOut\\n    );\\n\\n    event MintPyFromToken(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed YT,\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 netPyOut\\n    );\\n\\n    event RedeemPyToToken(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        address indexed YT,\\n        address receiver,\\n        uint256 netPyIn,\\n        uint256 netTokenOut\\n    );\\n\\n    function mintSyFromToken(\\n        address receiver,\\n        address SY,\\n        uint256 minSyOut,\\n        TokenInput calldata input\\n    ) external payable returns (uint256 netSyOut);\\n\\n    function redeemSyToToken(\\n        address receiver,\\n        address SY,\\n        uint256 netSyIn,\\n        TokenOutput calldata output\\n    ) external returns (uint256 netTokenOut);\\n\\n    function mintPyFromToken(\\n        address receiver,\\n        address YT,\\n        uint256 minPyOut,\\n        TokenInput calldata input\\n    ) external payable returns (uint256 netPyOut);\\n\\n    function redeemPyToToken(\\n        address receiver,\\n        address YT,\\n        uint256 netPyIn,\\n        TokenOutput calldata output\\n    ) external returns (uint256 netTokenOut);\\n\\n    function mintPyFromSy(\\n        address receiver,\\n        address YT,\\n        uint256 netSyIn,\\n        uint256 minPyOut\\n    ) external returns (uint256 netPyOut);\\n\\n    function redeemPyToSy(\\n        address receiver,\\n        address YT,\\n        uint256 netPyIn,\\n        uint256 minSyOut\\n    ) external returns (uint256 netSyOut);\\n\\n    function redeemDueInterestAndRewards(\\n        address user,\\n        address[] calldata sys,\\n        address[] calldata yts,\\n        address[] calldata markets\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPActionMisc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\ninterface IPActionMisc {\\n    struct MultiApproval {\\n        address[] tokens;\\n        address spender;\\n    }\\n\\n    struct Call3 {\\n        bool allowFailure;\\n        bytes callData;\\n    }\\n\\n    struct Result {\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    function approveInf(MultiApproval[] calldata) external;\\n\\n    function batchExec(Call3[] calldata calls) external returns (Result[] memory returnData);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPActionSwapPT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../router/base/MarketApproxLib.sol\\\";\\nimport \\\"../router/base/ActionBaseMintRedeem.sol\\\";\\n\\ninterface IPActionSwapPT {\\n    event SwapPtAndSy(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        int256 netPtToAccount,\\n        int256 netSyToAccount\\n    );\\n\\n    event SwapPtAndToken(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        int256 netPtToAccount,\\n        int256 netTokenToAccount\\n    );\\n\\n    function swapExactPtForSy(\\n        address receiver,\\n        address market,\\n        uint256 exactPtIn,\\n        uint256 minSyOut\\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\\n\\n    function swapPtForExactSy(\\n        address receiver,\\n        address market,\\n        uint256 exactSyOut,\\n        uint256 maxPtIn,\\n        ApproxParams calldata guessPtIn\\n    ) external returns (uint256 netPtIn, uint256 netSyFee);\\n\\n    function swapSyForExactPt(\\n        address receiver,\\n        address market,\\n        uint256 exactPtOut,\\n        uint256 maxSyIn\\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\\n\\n    function swapExactSyForPt(\\n        address receiver,\\n        address market,\\n        uint256 exactSyIn,\\n        uint256 minPtOut,\\n        ApproxParams calldata guessPtOut\\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\\n\\n    function swapExactTokenForPt(\\n        address receiver,\\n        address market,\\n        uint256 minPtOut,\\n        ApproxParams calldata guessPtOut,\\n        TokenInput calldata input\\n    ) external payable returns (uint256 netPtOut, uint256 netSyFee);\\n\\n    function swapExactPtForToken(\\n        address receiver,\\n        address market,\\n        uint256 exactPtIn,\\n        TokenOutput calldata output\\n    ) external returns (uint256 netTokenOut, uint256 netSyFee);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPActionSwapYT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../router/base/MarketApproxLib.sol\\\";\\nimport \\\"../router/base/ActionBaseMintRedeem.sol\\\";\\n\\ninterface IPActionSwapYT {\\n    event SwapYtAndSy(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        int256 netYtToAccount,\\n        int256 netSyToAccount\\n    );\\n\\n    event SwapYtAndToken(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        int256 netYtToAccount,\\n        int256 netTokenToAccount\\n    );\\n\\n    event SwapPtAndYt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        int256 netPtToAccount,\\n        int256 netYtToAccount\\n    );\\n\\n    function swapExactSyForYt(\\n        address receiver,\\n        address market,\\n        uint256 exactSyIn,\\n        uint256 minYtOut,\\n        ApproxParams calldata guessYtOut\\n    ) external returns (uint256 netYtOut, uint256 netSyFee);\\n\\n    function swapExactYtForSy(\\n        address receiver,\\n        address market,\\n        uint256 exactYtIn,\\n        uint256 minSyOut\\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\\n\\n    function swapSyForExactYt(\\n        address receiver,\\n        address market,\\n        uint256 exactYtOut,\\n        uint256 maxSyIn\\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\\n\\n    function swapYtForExactSy(\\n        address receiver,\\n        address market,\\n        uint256 exactSyOut,\\n        uint256 maxYtIn,\\n        ApproxParams calldata guessYtIn\\n    ) external returns (uint256 netYtIn, uint256 netSyFee);\\n\\n    function swapExactTokenForYt(\\n        address receiver,\\n        address market,\\n        uint256 minYtOut,\\n        ApproxParams calldata guessYtOut,\\n        TokenInput calldata input\\n    ) external payable returns (uint256 netYtOut, uint256 netSyFee);\\n\\n    function swapExactYtForToken(\\n        address receiver,\\n        address market,\\n        uint256 netYtIn,\\n        TokenOutput calldata output\\n    ) external returns (uint256 netTokenOut, uint256 netSyFee);\\n\\n    function swapExactPtForYt(\\n        address receiver,\\n        address market,\\n        uint256 exactPtIn,\\n        uint256 minYtOut,\\n        ApproxParams calldata guessTotalPtToSwap\\n    ) external returns (uint256 netYtOut, uint256 netSyFee);\\n\\n    function swapExactYtForPt(\\n        address receiver,\\n        address market,\\n        uint256 exactYtIn,\\n        uint256 minPtOut,\\n        ApproxParams calldata guessTotalPtSwapped\\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPAllAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IPActionAddRemoveLiq.sol\\\";\\nimport \\\"./IPActionSwapPT.sol\\\";\\nimport \\\"./IPActionSwapYT.sol\\\";\\nimport \\\"./IPActionMintRedeem.sol\\\";\\nimport \\\"./IPActionMisc.sol\\\";\\nimport \\\"./IPMarketSwapCallback.sol\\\";\\nimport \\\"./IDiamondLoupe.sol\\\";\\n\\ninterface IPAllAction is\\n    IPActionAddRemoveLiq,\\n    IPActionSwapPT,\\n    IPActionSwapYT,\\n    IPActionMintRedeem,\\n    IPActionMisc,\\n    IPMarketSwapCallback,\\n    IDiamondLoupe\\n{}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPBulkSeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../core/BulkSeller/BulkSellerMathCore.sol\\\";\\n\\ninterface IPBulkSeller {\\n    event SwapExactTokenForSy(address receiver, uint256 netTokenIn, uint256 netSyOut);\\n    event SwapExactSyForToken(address receiver, uint256 netSyIn, uint256 netTokenOut);\\n    event RateUpdated(\\n        uint256 newRateTokenToSy,\\n        uint256 newRateSyToToken,\\n        uint256 oldRateTokenToSy,\\n        uint256 oldRateSyToToken\\n    );\\n    event ReBalanceTokenToSy(\\n        uint256 netTokenDeposit,\\n        uint256 netSyFromToken,\\n        uint256 newTokenProp,\\n        uint256 oldTokenProp\\n    );\\n    event ReBalanceSyToToken(\\n        uint256 netSyRedeem,\\n        uint256 netTokenFromSy,\\n        uint256 newTokenProp,\\n        uint256 oldTokenProp\\n    );\\n    event ReserveUpdated(uint256 totalToken, uint256 totalSy);\\n    event FeeRateUpdated(uint256 newFeeRate, uint256 oldFeeRate);\\n\\n    function swapExactTokenForSy(\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 minSyOut\\n    ) external payable returns (uint256 netSyOut);\\n\\n    function swapExactSyForToken(\\n        address receiver,\\n        uint256 exactSyIn,\\n        uint256 minTokenOut,\\n        bool swapFromInternalBalance\\n    ) external returns (uint256 netTokenOut);\\n\\n    function SY() external view returns (address);\\n\\n    function token() external view returns (address);\\n\\n    function readState() external view returns (BulkSellerState memory);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPInterestManagerYT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\ninterface IPInterestManagerYT {\\n    function userInterest(\\n        address user\\n    ) external view returns (uint128 lastPYIndex, uint128 accruedInterest);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPMarketSwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\ninterface IPMarketSwapCallback {\\n    function swapCallback(int256 ptToAccount, int256 syToAccount, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPPrincipalToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IPPrincipalToken is IERC20Metadata {\\n    function burnByYT(address user, uint256 amount) external;\\n\\n    function mintByYT(address user, uint256 amount) external;\\n\\n    function initialize(address _YT) external;\\n\\n    function SY() external view returns (address);\\n\\n    function YT() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function expiry() external view returns (uint256);\\n\\n    function isExpired() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IPYieldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"./IRewardManager.sol\\\";\\nimport \\\"./IPInterestManagerYT.sol\\\";\\n\\ninterface IPYieldToken is IERC20Metadata, IRewardManager, IPInterestManagerYT {\\n    event NewInterestIndex(uint256 indexed newIndex);\\n\\n    event Mint(\\n        address indexed caller,\\n        address indexed receiverPT,\\n        address indexed receiverYT,\\n        uint256 amountSyToMint,\\n        uint256 amountPYOut\\n    );\\n\\n    event Burn(\\n        address indexed caller,\\n        address indexed receiver,\\n        uint256 amountPYToRedeem,\\n        uint256 amountSyOut\\n    );\\n\\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\\n\\n    event RedeemInterest(address indexed user, uint256 interestOut);\\n\\n    event WithdrawFeeToTreasury(uint256[] amountRewardsOut, uint256 syOut);\\n\\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\\n\\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\\n\\n    function redeemPYMulti(\\n        address[] calldata receivers,\\n        uint256[] calldata amountPYToRedeems\\n    ) external returns (uint256[] memory amountSyOuts);\\n\\n    function redeemDueInterestAndRewards(\\n        address user,\\n        bool redeemInterest,\\n        bool redeemRewards\\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\\n\\n    function rewardIndexesCurrent() external returns (uint256[] memory);\\n\\n    function pyIndexCurrent() external returns (uint256);\\n\\n    function pyIndexStored() external view returns (uint256);\\n\\n    function getRewardTokens() external view returns (address[] memory);\\n\\n    function SY() external view returns (address);\\n\\n    function PT() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function expiry() external view returns (uint256);\\n\\n    function isExpired() external view returns (bool);\\n\\n    function doCacheIndexSameBlock() external view returns (bool);\\n\\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IRewardManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\ninterface IRewardManager {\\n    function userReward(\\n        address token,\\n        address user\\n    ) external view returns (uint128 index, uint128 accrued);\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IStandardizedYield.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity 0.8.17;\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IStandardizedYield is IERC20Metadata {\\n    /// @dev Emitted when any base tokens is deposited to mint shares\\n    event Deposit(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed tokenIn,\\n        uint256 amountDeposited,\\n        uint256 amountSyOut\\n    );\\n\\n    /// @dev Emitted when any shares are redeemed for base tokens\\n    event Redeem(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed tokenOut,\\n        uint256 amountSyToRedeem,\\n        uint256 amountTokenOut\\n    );\\n\\n    /// @dev check `assetInfo()` for more information\\n    enum AssetType {\\n        TOKEN,\\n        LIQUIDITY\\n    }\\n\\n    /// @dev Emitted when (`user`) claims their rewards\\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\\n\\n    /**\\n     * @notice mints an amount of shares by depositing a base token.\\n     * @param receiver shares recipient address\\n     * @param tokenIn address of the base tokens to mint shares\\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\\n     * @param minSharesOut reverts if amount of shares minted is lower than this\\n     * @return amountSharesOut amount of shares minted\\n     * @dev Emits a {Deposit} event\\n     *\\n     * Requirements:\\n     * - (`tokenIn`) must be a valid base token.\\n     */\\n    function deposit(\\n        address receiver,\\n        address tokenIn,\\n        uint256 amountTokenToDeposit,\\n        uint256 minSharesOut\\n    ) external payable returns (uint256 amountSharesOut);\\n\\n    /**\\n     * @notice redeems an amount of base tokens by burning some shares\\n     * @param receiver recipient address\\n     * @param amountSharesToRedeem amount of shares to be burned\\n     * @param tokenOut address of the base token to be redeemed\\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\\n     * @return amountTokenOut amount of base tokens redeemed\\n     * @dev Emits a {Redeem} event\\n     *\\n     * Requirements:\\n     * - (`tokenOut`) must be a valid base token.\\n     */\\n    function redeem(\\n        address receiver,\\n        uint256 amountSharesToRedeem,\\n        address tokenOut,\\n        uint256 minTokenOut,\\n        bool burnFromInternalBalance\\n    ) external returns (uint256 amountTokenOut);\\n\\n    /**\\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\\n     he can mint must be X * exchangeRate / 1e18\\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\\n     & division\\n     */\\n    function exchangeRate() external view returns (uint256 res);\\n\\n    /**\\n     * @notice claims reward for (`user`)\\n     * @param user the user receiving their rewards\\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\\n     * @dev\\n     * Emits a `ClaimRewards` event\\n     * See {getRewardTokens} for list of reward tokens\\n     */\\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\\n\\n    /**\\n     * @notice get the amount of unclaimed rewards for (`user`)\\n     * @param user the user to check for\\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\\n     */\\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\\n\\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\\n\\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\\n\\n    /**\\n     * @notice returns the list of reward token addresses\\n     */\\n    function getRewardTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @notice returns the address of the underlying yield token\\n     */\\n    function yieldToken() external view returns (address);\\n\\n    /**\\n     * @notice returns all tokens that can mint this SY\\n     */\\n    function getTokensIn() external view returns (address[] memory res);\\n\\n    /**\\n     * @notice returns all tokens that can be redeemed by this SY\\n     */\\n    function getTokensOut() external view returns (address[] memory res);\\n\\n    function isValidTokenIn(address token) external view returns (bool);\\n\\n    function isValidTokenOut(address token) external view returns (bool);\\n\\n    function previewDeposit(address tokenIn, uint256 amountTokenToDeposit)\\n        external\\n        view\\n        returns (uint256 amountSharesOut);\\n\\n    function previewRedeem(address tokenOut, uint256 amountSharesToRedeem)\\n        external\\n        view\\n        returns (uint256 amountTokenOut);\\n\\n    /**\\n     * @notice This function contains information to interpret what the asset is\\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\\n     * @return assetAddress the address of the asset\\n     * @return assetDecimals the decimals of the asset\\n     */\\n    function assetInfo()\\n        external\\n        view\\n        returns (\\n            AssetType assetType,\\n            address assetAddress,\\n            uint8 assetDecimals\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/base/ActionBaseMintRedeem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../../core/libraries/TokenHelper.sol\\\";\\nimport \\\"../../interfaces/IStandardizedYield.sol\\\";\\nimport \\\"../../interfaces/IPYieldToken.sol\\\";\\nimport \\\"../../interfaces/IPBulkSeller.sol\\\";\\n\\nimport \\\"../../core/libraries/Errors.sol\\\";\\nimport \\\"../swap-aggregator/IPSwapAggregator.sol\\\";\\n\\nstruct TokenInput {\\n    // Token/Sy data\\n    address tokenIn;\\n    uint256 netTokenIn;\\n    address tokenMintSy;\\n    address bulk;\\n    // aggregator data\\n    address pendleSwap;\\n    SwapData swapData;\\n}\\n\\nstruct TokenOutput {\\n    // Token/Sy data\\n    address tokenOut;\\n    uint256 minTokenOut;\\n    address tokenRedeemSy;\\n    address bulk;\\n    // aggregator data\\n    address pendleSwap;\\n    SwapData swapData;\\n}\\n\\n// solhint-disable no-empty-blocks\\nabstract contract ActionBaseMintRedeem is TokenHelper {\\n    bytes internal constant EMPTY_BYTES = abi.encode();\\n\\n    function _mintSyFromToken(\\n        address receiver,\\n        address SY,\\n        uint256 minSyOut,\\n        TokenInput calldata inp\\n    ) internal returns (uint256 netSyOut) {\\n        SwapType swapType = inp.swapData.swapType;\\n\\n        uint256 netTokenMintSy;\\n\\n        if (swapType == SwapType.NONE) {\\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\\n            netTokenMintSy = inp.netTokenIn;\\n        } else if (swapType == SwapType.ETH_WETH) {\\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\\n            netTokenMintSy = inp.netTokenIn;\\n        } else {\\n            if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\\n            else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\\n\\n            IPSwapAggregator(inp.pendleSwap).swap{\\n                value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0\\n            }(inp.tokenIn, inp.netTokenIn, inp.swapData);\\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\\n        }\\n\\n        // outcome of all branches: satisfy pre-condition of __mintSy\\n\\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\\n    }\\n\\n    /// @dev pre-condition: having netTokenMintSy of tokens in this contract\\n    function __mintSy(\\n        address receiver,\\n        address SY,\\n        uint256 netTokenMintSy,\\n        uint256 minSyOut,\\n        TokenInput calldata inp\\n    ) private returns (uint256 netSyOut) {\\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\\n\\n        if (inp.bulk != address(0)) {\\n            netSyOut = IPBulkSeller(inp.bulk).swapExactTokenForSy{ value: netNative }(\\n                receiver,\\n                netTokenMintSy,\\n                minSyOut\\n            );\\n        } else {\\n            netSyOut = IStandardizedYield(SY).deposit{ value: netNative }(\\n                receiver,\\n                inp.tokenMintSy,\\n                netTokenMintSy,\\n                minSyOut\\n            );\\n        }\\n    }\\n\\n    function _redeemSyToToken(\\n        address receiver,\\n        address SY,\\n        uint256 netSyIn,\\n        TokenOutput calldata out,\\n        bool doPull\\n    ) internal returns (uint256 netTokenOut) {\\n        SwapType swapType = out.swapData.swapType;\\n\\n        if (swapType == SwapType.NONE) {\\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\\n        } else if (swapType == SwapType.ETH_WETH) {\\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\\n\\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\\n\\n            _transferOut(out.tokenOut, receiver, netTokenOut);\\n        } else {\\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\\n\\n            IPSwapAggregator(out.pendleSwap).swap(\\n                out.tokenRedeemSy,\\n                netTokenRedeemed,\\n                out.swapData\\n            );\\n\\n            netTokenOut = _selfBalance(out.tokenOut);\\n\\n            _transferOut(out.tokenOut, receiver, netTokenOut);\\n        }\\n\\n        // outcome of all branches: netTokenOut of tokens goes back to receiver\\n\\n        if (netTokenOut < out.minTokenOut) {\\n            revert Errors.RouterInsufficientTokenOut(netTokenOut, out.minTokenOut);\\n        }\\n    }\\n\\n    function __redeemSy(\\n        address receiver,\\n        address SY,\\n        uint256 netSyIn,\\n        TokenOutput calldata out,\\n        bool doPull\\n    ) private returns (uint256 netTokenRedeemed) {\\n        if (doPull) {\\n            _transferFrom(IERC20(SY), msg.sender, _syOrBulk(SY, out), netSyIn);\\n        }\\n\\n        if (out.bulk != address(0)) {\\n            netTokenRedeemed = IPBulkSeller(out.bulk).swapExactSyForToken(\\n                receiver,\\n                netSyIn,\\n                0,\\n                true\\n            );\\n        } else {\\n            netTokenRedeemed = IStandardizedYield(SY).redeem(\\n                receiver,\\n                netSyIn,\\n                out.tokenRedeemSy,\\n                0,\\n                true\\n            );\\n        }\\n    }\\n\\n    function _mintPyFromSy(\\n        address receiver,\\n        address SY,\\n        address YT,\\n        uint256 netSyIn,\\n        uint256 minPyOut,\\n        bool doPull\\n    ) internal returns (uint256 netPyOut) {\\n        if (doPull) {\\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\\n        }\\n\\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\\n        if (netPyOut < minPyOut) revert Errors.RouterInsufficientPYOut(netPyOut, minPyOut);\\n    }\\n\\n    function _redeemPyToSy(\\n        address receiver,\\n        address YT,\\n        uint256 netPyIn,\\n        uint256 minSyOut\\n    ) internal returns (uint256 netSyOut) {\\n        address PT = IPYieldToken(YT).PT();\\n\\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\\n\\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\\n\\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\\n        if (netSyOut < minSyOut) revert Errors.RouterInsufficientSyOut(netSyOut, minSyOut);\\n    }\\n\\n    function _syOrBulk(address SY, TokenOutput calldata output)\\n        internal\\n        pure\\n        returns (address addr)\\n    {\\n        return output.bulk != address(0) ? output.bulk : SY;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/base/MarketApproxLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"../../core/libraries/math/Math.sol\\\";\\nimport \\\"../../core/Market/MarketMathCore.sol\\\";\\n\\nstruct ApproxParams {\\n    uint256 guessMin;\\n    uint256 guessMax;\\n    uint256 guessOffchain; // pass 0 in to skip this variable\\n    uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\\n    uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\\n    // to 1e15 (1e18/1000 = 0.1%)\\n\\n    /// Further explanation of the eps. Take swapExactSyForPt for example. To calc the corresponding amount of Pt to swap out,\\n    /// it's necessary to run an approximation algorithm, because by default there only exists the Pt to Sy formula\\n    /// To approx, the 5 values above will have to be provided, and the approx process will run as follows:\\n    /// mid = (guessMin + guessMax) / 2 // mid here is the current guess of the amount of Pt out\\n    /// netSyNeed = calcSwapSyForExactPt(mid)\\n    /// if (netSyNeed > exactSyIn) guessMax = mid - 1 // since the maximum Sy in can't exceed the exactSyIn\\n    /// else guessMin = mid (1)\\n    /// For the (1), since netSyNeed <= exactSyIn, the result might be usable. If the netSyNeed is within eps of\\n    /// exactSyIn (ex eps=0.1% => we have used 99.9% the amount of Sy specified), mid will be chosen as the final guess result\\n\\n    /// for guessOffchain, this is to provide a shortcut to guessing. The offchain SDK can precalculate the exact result\\n    /// before the tx is sent. When the tx reaches the contract, the guessOffchain will be checked first, and if it satisfies the\\n    /// approximation, it will be used (and save all the guessing). It's expected that this shortcut will be used in most cases\\n    /// except in cases that there is a trade in the same market right before the tx\\n}\\n\\nlibrary MarketApproxPtInLib {\\n    using MarketMathCore for MarketState;\\n    using PYIndexLib for PYIndex;\\n    using Math for uint256;\\n    using Math for int256;\\n    using LogExpMath for int256;\\n\\n    /**\\n     * @dev algorithm:\\n        - Bin search the amount of PT to swap in\\n        - Try swapping & get netSyOut\\n        - Stop when netSyOut greater & approx minSyOut\\n        - guess & approx is for netPtIn\\n     */\\n    function approxSwapPtForExactSy(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 minSyOut,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256 /*netPtIn*/, uint256 /*netSyOut*/, uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            // no limit on min\\n            approx.guessMax = Math.min(approx.guessMax, calcMaxPtIn(market, comp));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\\n\\n            if (netSyOut >= minSyOut) {\\n                if (Math.isAGreaterApproxB(netSyOut, minSyOut, approx.eps))\\n                    return (guess, netSyOut, netSyFee);\\n                approx.guessMax = guess;\\n            } else {\\n                approx.guessMin = guess;\\n            }\\n        }\\n        revert Errors.ApproxFail();\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n        - Bin search the amount of PT to swap in\\n        - Flashswap the corresponding amount of SY out\\n        - Pair those amount with exactSyIn SY to tokenize into PT & YT\\n        - PT to repay the flashswap, YT transferred to user\\n        - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\\n        - guess & approx is for netYtOut (also netPtIn)\\n     */\\n    function approxSwapExactSyForYt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactSyIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256 /*netYtOut*/, uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            approx.guessMin = Math.max(approx.guessMin, index.syToAsset(exactSyIn));\\n            approx.guessMax = Math.min(approx.guessMax, calcMaxPtIn(market, comp));\\n            validateApprox(approx);\\n        }\\n\\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\\n\\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\\n\\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\\n\\n            if (netSyToPull <= exactSyIn) {\\n                if (Math.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps))\\n                    return (guess, netSyFee);\\n                approx.guessMin = guess;\\n            } else {\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert Errors.ApproxFail();\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n        - Bin search the amount of PT to swap to SY\\n        - Swap PT to SY\\n        - Pair the remaining PT with the SY to add liquidity\\n        - Stop when the ratio of PT / totalPt & SY / totalSy is approx\\n        - guess & approx is for netPtSwap\\n     */\\n    function approxSwapPtToAddLiquidity(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 totalPtIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    )\\n        internal\\n        pure\\n        returns (uint256 /*netPtSwap*/, uint256 /*netSyFromSwap*/, uint256 /*netSyFee*/)\\n    {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            // no limit on min\\n            approx.guessMax = Math.min(approx.guessMax, calcMaxPtIn(market, comp));\\n            approx.guessMax = Math.min(approx.guessMax, totalPtIn);\\n            validateApprox(approx);\\n            require(market.totalLp != 0, \\\"no existing lp\\\");\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (\\n                uint256 syNumerator,\\n                uint256 ptNumerator,\\n                uint256 netSyOut,\\n                uint256 netSyFee,\\n\\n            ) = calcNumerators(market, index, totalPtIn, comp, guess);\\n\\n            if (Math.isAApproxB(syNumerator, ptNumerator, approx.eps))\\n                return (guess, netSyOut, netSyFee);\\n\\n            if (syNumerator <= ptNumerator) {\\n                // needs more SY --> swap more PT\\n                approx.guessMin = guess + 1;\\n            } else {\\n                // needs less SY --> swap less PT\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert Errors.ApproxFail();\\n    }\\n\\n    function calcNumerators(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 totalPtIn,\\n        MarketPreCompute memory comp,\\n        uint256 guess\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256 syNumerator,\\n            uint256 ptNumerator,\\n            uint256 netSyOut,\\n            uint256 netSyFee,\\n            uint256 netSyToReserve\\n        )\\n    {\\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\\n\\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\\n\\n        // it is desired that\\n        // netSyOut / newTotalSy = netPtRemaining / newTotalPt\\n        // which is equivalent to\\n        // netSyOut * newTotalPt = netPtRemaining * newTotalSy\\n\\n        syNumerator = netSyOut * newTotalPt;\\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\\n    }\\n\\n    struct Args7 {\\n        MarketState market;\\n        PYIndex index;\\n        uint256 exactPtIn;\\n        uint256 blockTime;\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n        - Bin search the amount of PT to swap to SY\\n        - Flashswap the corresponding amount of SY out\\n        - Tokenize all the SY into PT + YT\\n        - PT to repay the flashswap, YT transferred to user\\n        - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\\n        - guess & approx is for totalPtToSwap\\n     */\\n    function approxSwapExactPtForYt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactPtIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    )\\n        internal\\n        pure\\n        returns (uint256 /*netYtOut*/, uint256 /*totalPtToSwap*/, uint256 /*netSyFee*/)\\n    {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            approx.guessMin = Math.max(approx.guessMin, exactPtIn);\\n            approx.guessMax = Math.min(approx.guessMax, calcMaxPtIn(market, comp));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\\n\\n            uint256 netAssetOut = index.syToAsset(netSyOut);\\n\\n            // guess >= netAssetOut since we are swapping PT to SY\\n            uint256 netPtToPull = guess - netAssetOut;\\n\\n            if (netPtToPull <= exactPtIn) {\\n                if (Math.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps))\\n                    return (netAssetOut, guess, netSyFee);\\n                approx.guessMin = guess;\\n            } else {\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert Errors.ApproxFail();\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////\\n\\n    function calcSyOut(\\n        MarketState memory market,\\n        MarketPreCompute memory comp,\\n        PYIndex index,\\n        uint256 netPtIn\\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(\\n            comp,\\n            index,\\n            -int256(netPtIn)\\n        );\\n        netSyOut = uint256(_netSyOut);\\n        netSyFee = uint256(_netSyFee);\\n        netSyToReserve = uint256(_netSyToReserve);\\n    }\\n\\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\\n        revert Errors.ApproxFail();\\n    }\\n\\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\\n\\n    function validateApprox(ApproxParams memory approx) internal pure {\\n        if (approx.guessMin > approx.guessMax || approx.eps > Math.ONE)\\n            revert Errors.ApproxParamsInvalid(approx.guessMin, approx.guessMax, approx.eps);\\n    }\\n\\n    function calcMaxPtIn(\\n        MarketState memory market,\\n        MarketPreCompute memory comp\\n    ) internal pure returns (uint256) {\\n        uint256 low = 0;\\n        uint256 hi = uint256(comp.totalAsset) - 1;\\n\\n        while (low != hi) {\\n            uint256 mid = (low + hi + 1) / 2;\\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\\n            else low = mid;\\n        }\\n        return low;\\n    }\\n\\n    function calcSlope(\\n        MarketPreCompute memory comp,\\n        int256 totalPt,\\n        int256 ptToMarket\\n    ) internal pure returns (int256) {\\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\\n        int256 sumPt = ptToMarket + totalPt;\\n\\n        require(diffAssetPtToMarket > 0 && sumPt > 0, \\\"invalid ptToMarket\\\");\\n\\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(\\n            sumPt * diffAssetPtToMarket\\n        );\\n\\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\\n        int256 part3 = Math.IONE.divDown(comp.rateScalar);\\n\\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\\n    }\\n}\\n\\nlibrary MarketApproxPtOutLib {\\n    using MarketMathCore for MarketState;\\n    using PYIndexLib for PYIndex;\\n    using Math for uint256;\\n    using Math for int256;\\n    using LogExpMath for int256;\\n\\n    /**\\n     * @dev algorithm:\\n        - Bin search the amount of PT to swapExactOut\\n        - Calculate the amount of SY needed\\n        - Stop when the netSyIn is smaller approx exactSyIn\\n        - guess & approx is for netSyIn\\n     */\\n    function approxSwapExactSyForPt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactSyIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256 /*netPtOut*/, uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            // no limit on min\\n            approx.guessMax = Math.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\\n\\n            if (netSyIn <= exactSyIn) {\\n                if (Math.isASmallerApproxB(netSyIn, exactSyIn, approx.eps))\\n                    return (guess, netSyFee);\\n                approx.guessMin = guess;\\n            } else {\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n\\n        revert Errors.ApproxFail();\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n        - Bin search the amount of PT to swapExactOut\\n        - Flashswap that amount of PT & pair with YT to redeem SY\\n        - Use the SY to repay the flashswap debt and the remaining is transferred to user\\n        - Stop when the netSyOut is greater approx the minSyOut\\n        - guess & approx is for netSyOut\\n     */\\n    function approxSwapYtForExactSy(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 minSyOut,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256 /*netYtIn*/, uint256 /*netSyOut*/, uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            // no limit on min\\n            approx.guessMax = Math.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\\n\\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\\n\\n            if (netSyOut >= minSyOut) {\\n                if (Math.isAGreaterApproxB(netSyOut, minSyOut, approx.eps))\\n                    return (guess, netSyOut, netSyFee);\\n                approx.guessMax = guess;\\n            } else {\\n                approx.guessMin = guess + 1;\\n            }\\n        }\\n        revert Errors.ApproxFail();\\n    }\\n\\n    struct Args6 {\\n        MarketState market;\\n        PYIndex index;\\n        uint256 totalSyIn;\\n        uint256 blockTime;\\n        ApproxParams approx;\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n        - Bin search the amount of PT to swapExactOut\\n        - Swap that amount of PT out\\n        - Pair the remaining PT with the SY to add liquidity\\n        - Stop when the ratio of PT / totalPt & SY / totalSy is approx\\n        - guess & approx is for netPtFromSwap\\n     */\\n    function approxSwapSyToAddLiquidity(\\n        MarketState memory _market,\\n        PYIndex _index,\\n        uint256 _totalSyIn,\\n        uint256 _blockTime,\\n        ApproxParams memory _approx\\n    )\\n        internal\\n        pure\\n        returns (uint256 /*netPtFromSwap*/, uint256 /*netSySwap*/, uint256 /*netSyFee*/)\\n    {\\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _blockTime, _approx);\\n\\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\\n        if (a.approx.guessOffchain == 0) {\\n            // no limit on min\\n            a.approx.guessMax = Math.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\\n            validateApprox(a.approx);\\n            require(a.market.totalLp != 0, \\\"no existing lp\\\");\\n        }\\n\\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(a.approx, iter);\\n\\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(\\n                a.market,\\n                comp,\\n                a.index,\\n                guess\\n            );\\n\\n            if (netSyIn > a.totalSyIn) {\\n                a.approx.guessMax = guess - 1;\\n                continue;\\n            }\\n\\n            uint256 syNumerator;\\n            uint256 ptNumerator;\\n\\n            {\\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\\n\\n                // it is desired that\\n                // netPtFromSwap / newTotalPt = netSyRemaining / netTotalSy\\n                // which is equivalent to\\n                // netPtFromSwap * netTotalSy = netSyRemaining * newTotalPt\\n\\n                ptNumerator = guess * netTotalSy;\\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\\n            }\\n\\n            if (Math.isAApproxB(ptNumerator, syNumerator, a.approx.eps))\\n                return (guess, netSyIn, netSyFee);\\n\\n            if (ptNumerator <= syNumerator) {\\n                // needs more PT\\n                a.approx.guessMin = guess + 1;\\n            } else {\\n                // needs less PT\\n                a.approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert Errors.ApproxFail();\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n        - Bin search the amount of PT to swapExactOut\\n        - Flashswap that amount of PT out\\n        - Pair all the PT with the YT to redeem SY\\n        - Use the SY to repay the flashswap debt\\n        - Stop when the amount of YT required to pair with PT is approx exactYtIn\\n        - guess & approx is for netPtFromSwap\\n     */\\n    function approxSwapExactYtForPt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactYtIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    )\\n        internal\\n        pure\\n        returns (uint256 /*netPtOut*/, uint256 /*totalPtSwapped*/, uint256 /*netSyFee*/)\\n    {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            approx.guessMin = Math.max(approx.guessMin, exactYtIn);\\n            approx.guessMax = Math.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\\n\\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\\n\\n            if (netYtToPull <= exactYtIn) {\\n                if (Math.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps))\\n                    return (guess - netYtToPull, guess, netSyFee);\\n                approx.guessMin = guess;\\n            } else {\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert Errors.ApproxFail();\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////\\n\\n    function calcSyIn(\\n        MarketState memory market,\\n        MarketPreCompute memory comp,\\n        PYIndex index,\\n        uint256 netPtOut\\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(\\n            comp,\\n            index,\\n            int256(netPtOut)\\n        );\\n\\n        // all safe since totalPt and totalSy is int128\\n        netSyIn = uint256(-_netSyIn);\\n        netSyFee = uint256(_netSyFee);\\n        netSyToReserve = uint256(_netSyToReserve);\\n    }\\n\\n    function calcMaxPtOut(\\n        MarketPreCompute memory comp,\\n        int256 totalPt\\n    ) internal pure returns (uint256) {\\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\\n        int256 proportion = logitP.divDown(logitP + Math.IONE);\\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\\n        int256 maxPtOut = totalPt - numerator;\\n        // only get 99.9% of the theoretical max to accommodate some precision issues\\n        return (uint256(maxPtOut) * 999) / 1000;\\n    }\\n\\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\\n        revert Errors.ApproxFail();\\n    }\\n\\n    function validateApprox(ApproxParams memory approx) internal pure {\\n        if (approx.guessMin > approx.guessMax || approx.eps > Math.ONE)\\n            revert Errors.ApproxParamsInvalid(approx.guessMin, approx.guessMax, approx.eps);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/PendleRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"../interfaces/IPAllAction.sol\\\";\\nimport \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// solhint-disable no-empty-blocks\\ncontract PendleRouter is Proxy, IDiamondLoupe {\\n    address internal immutable ACTION_MINT_REDEEM;\\n    address internal immutable ACTION_ADD_REMOVE_LIQ;\\n    address internal immutable ACTION_SWAP_PT;\\n    address internal immutable ACTION_SWAP_YT;\\n    address internal immutable ACTION_MISC;\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    constructor(\\n        address _ACTION_MINT_REDEEM,\\n        address _ACTION_ADD_REMOVE_LIQ,\\n        address _ACTION_SWAP_PT,\\n        address _ACTION_SWAP_YT,\\n        address _ACTION_MISC\\n    ) {\\n        ACTION_MINT_REDEEM = _ACTION_MINT_REDEEM;\\n        ACTION_ADD_REMOVE_LIQ = _ACTION_ADD_REMOVE_LIQ;\\n        ACTION_SWAP_PT = _ACTION_SWAP_PT;\\n        ACTION_SWAP_YT = _ACTION_SWAP_YT;\\n        ACTION_MISC = _ACTION_MISC;\\n        _emitEvents();\\n    }\\n\\n    function _emitEvents() internal {\\n        Facet[] memory facets_ = facets();\\n\\n        uint256 nFacets = facets_.length;\\n\\n        IDiamondCut.FacetCut[] memory cuts = new IDiamondCut.FacetCut[](nFacets);\\n        for (uint256 i; i < nFacets; ) {\\n            cuts[i].facetAddress = facets_[i].facetAddress;\\n            cuts[i].action = IDiamondCut.FacetCutAction.Add;\\n            cuts[i].functionSelectors = facets_[i].functionSelectors;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit DiamondCut(cuts, address(0), \\\"\\\");\\n    }\\n\\n    receive() external payable virtual override {}\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() public view returns (Facet[] memory facets_) {\\n        address[] memory facetAddresses_ = facetAddresses();\\n        uint256 numFacets = facetAddresses_.length;\\n\\n        facets_ = new Facet[](numFacets);\\n        for (uint256 i; i < numFacets; ) {\\n            facets_[i].facetAddress = facetAddresses_[i];\\n            facets_[i].functionSelectors = facetFunctionSelectors(facetAddresses_[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function facetFunctionSelectors(address facet) public view returns (bytes4[] memory res) {\\n        if (facet == ACTION_ADD_REMOVE_LIQ) {\\n            res = new bytes4[](12);\\n            res[0] = 0x97ee279e; // addLiquidityDualSyAndPt\\n            res[1] = 0xcb591eb2; // addLiquidityDualTokenAndPt\\n            res[2] = 0x3af1f329; // addLiquiditySinglePt\\n            res[3] = 0x409c7a89; // addLiquiditySingleSy\\n            res[4] = 0x015491d1; // addLiquiditySingleToken\\n            res[5] = 0xb7d75b8b; // removeLiquidityDualSyAndPt\\n            res[6] = 0xe6eaba01; // removeLiquidityDualTokenAndPt\\n            res[7] = 0x694ab559; // removeLiquiditySinglePt\\n            res[8] = 0x178d29d3; // removeLiquiditySingleSy\\n            res[9] = 0x690807ad; // removeLiquiditySingleToken\\n            res[10] = 0xdfbc814e; // addLiquiditySingleTokenKeepYt\\n            res[11] = 0x844384aa; // addLiquiditySingleSyKeepYt\\n            return res;\\n        }\\n        if (facet == ACTION_MINT_REDEEM) {\\n            res = new bytes4[](7);\\n            res[0] = 0x1a8631b2; // mintPyFromSy\\n            res[1] = 0x46eb2db6; // mintPyFromToken\\n            res[2] = 0x443e6512; // mintSyFromToken\\n            res[3] = 0xf7e375e8; // redeemDueInterestAndRewards\\n            res[4] = 0x339748cb; // redeemPyToSy\\n            res[5] = 0x527df199; // redeemPyToToken\\n            res[6] = 0x85b29936; // redeemSyToToken\\n            return res;\\n        }\\n        if (facet == ACTION_SWAP_PT) {\\n            res = new bytes4[](6);\\n            res[0] = 0x2032aecd; // swapExactPtForSy\\n            res[1] = 0xb85f50ba; // swapExactPtForToken\\n            res[2] = 0x83c71b69; // swapExactSyForPt\\n            res[3] = 0xa5f9931b; // swapExactTokenForPt\\n            res[4] = 0xdd371acd; // swapPtForExactSy\\n            res[5] = 0x6b8bdf32; // swapSyForExactPt\\n            return res;\\n        }\\n        if (facet == ACTION_SWAP_YT) {\\n            res = new bytes4[](9);\\n            res[0] = 0xfa483e72; // swapCallback\\n            res[1] = 0xc861a898; // swapExactPtForYt\\n            res[2] = 0x448b9b95; // swapExactYtForPt\\n            res[3] = 0xfdd71f43; // swapExactSyForYt\\n            res[4] = 0xc4a9c7de; // swapExactTokenForYt\\n            res[5] = 0x357d6540; // swapExactYtForSy\\n            res[6] = 0xd6308fa4; // swapExactYtForToken\\n            res[7] = 0xbf1bd434; // swapSyForExactYt\\n            res[8] = 0xe15cc098; // swapYtForExactSy\\n            return res;\\n        }\\n        if (facet == ACTION_MISC) {\\n            res = new bytes4[](2);\\n            res[0] = 0xacdb32df; // approveInf\\n            res[1] = 0xd617b03b; // batchExec\\n            return res;\\n        }\\n        if (facet == address(this)) {\\n            res = new bytes4[](4);\\n            res[0] = 0xcdffacc6; // facetAddress\\n            res[1] = 0x52ef6b2c; // facetAddresses\\n            res[2] = 0xadfca15e; // facetFunctionSelectors\\n            res[3] = 0x7a0ed627; // facets\\n            return res;\\n        }\\n        revert Errors.RouterInvalidFacet(facet);\\n    }\\n\\n    function facetAddress(bytes4 sig) public view returns (address) {\\n        if (sig < 0x97ee279e) {\\n            if (sig < 0x46eb2db6) {\\n                if (sig < 0x357d6540) {\\n                    if (sig < 0x1a8631b2) {\\n                        if (sig == 0x015491d1) return ACTION_ADD_REMOVE_LIQ; // addLiquiditySingleToken 5\\n                        if (sig == 0x178d29d3) return ACTION_ADD_REMOVE_LIQ; // removeLiquiditySingleSy 6\\n                    } else {\\n                        if (sig == 0x1a8631b2) return ACTION_MINT_REDEEM; // mintPyFromSy 5\\n                        if (sig == 0x2032aecd) return ACTION_SWAP_PT; // swapExactPtForSy 6\\n                        if (sig == 0x339748cb) return ACTION_MINT_REDEEM; // redeemPyToSy 7\\n                    }\\n                } else {\\n                    if (sig < 0x409c7a89) {\\n                        if (sig == 0x357d6540) return ACTION_SWAP_YT; // swapExactYtForSy 5\\n                        if (sig == 0x3af1f329) return ACTION_ADD_REMOVE_LIQ; // addLiquiditySinglePt 6\\n                    } else {\\n                        if (sig == 0x409c7a89) return ACTION_ADD_REMOVE_LIQ; // addLiquiditySingleSy 5\\n                        if (sig == 0x443e6512) return ACTION_MINT_REDEEM; // mintSyFromToken 6\\n                        if (sig == 0x448b9b95) return ACTION_SWAP_YT; // swapExactYtForPt 7\\n                    }\\n                }\\n            } else {\\n                if (sig < 0x6b8bdf32) {\\n                    if (sig < 0x52ef6b2c) {\\n                        if (sig == 0x46eb2db6) return ACTION_MINT_REDEEM; // mintPyFromToken 5\\n                        if (sig == 0x527df199) return ACTION_MINT_REDEEM; // redeemPyToToken 6\\n                    } else {\\n                        if (sig == 0x690807ad) return ACTION_ADD_REMOVE_LIQ; // removeLiquiditySingleToken 5\\n                        if (sig == 0x694ab559) return ACTION_ADD_REMOVE_LIQ; // removeLiquiditySinglePt 6\\n                        if (sig == 0x52ef6b2c) return address(this); // facetAddresses 7\\n                    }\\n                } else {\\n                    if (sig < 0x83c71b69) {\\n                        if (sig == 0x6b8bdf32) return ACTION_SWAP_PT; // swapSyForExactPt 5\\n                        if (sig == 0x7a0ed627) return address(this); // facets 6\\n                    } else {\\n                        if (sig == 0x85b29936) return ACTION_MINT_REDEEM; // redeemSyToToken 5\\n                        if (sig == 0x844384aa) return ACTION_ADD_REMOVE_LIQ; // addLiquiditySingleSyKeepYt 6\\n                        if (sig == 0x83c71b69) return ACTION_SWAP_PT; // swapExactSyForPt 7\\n                    }\\n                }\\n            }\\n        } else {\\n            if (sig < 0xcdffacc6) {\\n                if (sig < 0xb85f50ba) {\\n                    if (sig < 0xacdb32df) {\\n                        if (sig == 0xa5f9931b) return ACTION_SWAP_PT; // swapExactTokenForPt 5\\n                        if (sig == 0x97ee279e) return ACTION_ADD_REMOVE_LIQ; // addLiquidityDualSyAndPt 6\\n                    } else {\\n                        if (sig == 0xb7d75b8b) return ACTION_ADD_REMOVE_LIQ; // removeLiquidityDualSyAndPt 5\\n                        if (sig == 0xacdb32df) return ACTION_MISC; // approveInf 6\\n                        if (sig == 0xadfca15e) return address(this); // facetFunctionSelectors 7\\n                    }\\n                } else {\\n                    if (sig < 0xc4a9c7de) {\\n                        if (sig == 0xb85f50ba) return ACTION_SWAP_PT; // swapExactPtForToken 5\\n                        if (sig == 0xbf1bd434) return ACTION_SWAP_YT; // swapSyForExactYt 6\\n                    } else {\\n                        if (sig == 0xc4a9c7de) return ACTION_SWAP_YT; // swapExactTokenForYt 5\\n                        if (sig == 0xcb591eb2) return ACTION_ADD_REMOVE_LIQ; // addLiquidityDualTokenAndPt 6\\n                        if (sig == 0xc861a898) return ACTION_SWAP_YT; // swapExactPtForYt 7\\n                    }\\n                }\\n            } else {\\n                if (sig < 0xe15cc098) {\\n                    if (sig < 0xd6308fa4) {\\n                        if (sig == 0xd617b03b) return ACTION_MISC; // batchExec 5\\n                        if (sig == 0xcdffacc6) return address(this); // facetAddress 6\\n                    } else {\\n                        if (sig == 0xd6308fa4) return ACTION_SWAP_YT; // swapExactYtForToken 5\\n                        if (sig == 0xdfbc814e) return ACTION_ADD_REMOVE_LIQ; // addLiquiditySingleTokenKeepYt 6\\n                        if (sig == 0xdd371acd) return ACTION_SWAP_PT; // swapPtForExactSy 7\\n                    }\\n                } else {\\n                    if (sig < 0xf7e375e8) {\\n                        if (sig == 0xe6eaba01) return ACTION_ADD_REMOVE_LIQ; // removeLiquidityDualTokenAndPt 5\\n                        if (sig == 0xe15cc098) return ACTION_SWAP_YT; // swapYtForExactSy 6\\n                    } else {\\n                        if (sig == 0xfa483e72) return ACTION_SWAP_YT; // swapCallback 5\\n                        if (sig == 0xf7e375e8) return ACTION_MINT_REDEEM; // redeemDueInterestAndRewards 6\\n                        if (sig == 0xfdd71f43) return ACTION_SWAP_YT; // swapExactSyForYt 7\\n                    }\\n                }\\n            }\\n        }\\n        revert Errors.RouterInvalidAction(sig);\\n        // NUM_FUNC: 40 AVG:5.80 STD:0.75 WORST_CASE:7 STOP_BRANCH:3\\n    }\\n\\n    function facetAddresses() public view returns (address[] memory) {\\n        address[] memory res = new address[](6);\\n        res[0] = ACTION_ADD_REMOVE_LIQ;\\n        res[1] = ACTION_MINT_REDEEM;\\n        res[2] = ACTION_SWAP_PT;\\n        res[3] = ACTION_SWAP_YT;\\n        res[4] = ACTION_MISC;\\n        res[5] = address(this);\\n        return res;\\n    }\\n\\n    function _implementation() internal view override returns (address) {\\n        return facetAddress(msg.sig);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pendle/contracts/router/swap-aggregator/IPSwapAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nstruct SwapData {\\n    SwapType swapType;\\n    address extRouter;\\n    bytes extCalldata;\\n    bool needScale;\\n}\\n\\nenum SwapType {\\n    NONE,\\n    KYBERSWAP,\\n    ONE_INCH,\\n    // ETH_WETH not used in Aggregator\\n    ETH_WETH\\n}\\n\\ninterface IPSwapAggregator {\\n    function swap(address tokenIn, uint256 amountIn, SwapData calldata swapData) external payable;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ACTION_MINT_REDEEM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ACTION_ADD_REMOVE_LIQ\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ACTION_SWAP_PT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ACTION_SWAP_YT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ACTION_MISC\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"RouterInvalidAction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"RouterInvalidFacet\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"res\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PendleRouter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000a13ea97c61ed1d858b5dc0e9c9b76ab8710cd1490000000000000000000000003b0e43ce9f44da9ee82d017a5bfb2688dc05a651000000000000000000000000019426383c70296a2b5bb1027a0622482a01b6c200000000000000000000000022e55fc5104f48f99d8a8ebc01bc45969c3cb8e30000000000000000000000005d59b607bf8b3196950238320d551543f756efd3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xa13ea97c61ed1d858b5dc0e9c9b76ab8710cd149", "SwarmSource": ""}