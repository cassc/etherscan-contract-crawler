{"SourceCode": "//\ud83c\udd50\ud83c\udd5d\ud83c\udd63\ud83c\udd58\ud83c\udd56\ud83c\udd61\ud83c\udd50\ud83c\udd65\ud83c\udd58\ud83c\udd63\ud83c\udd68\r\n// \ud835\udd38\ud835\udd5f\ud835\udd65\ud835\udd5a\ud835\udd3e\ud835\udd63\ud835\udd52\ud835\udd67\ud835\udd5a\ud835\udd65\ud835\udd6a Elasic Supply Token on BSC\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ISwapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface ISwapPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface ISwapRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface ISwapRouter02 is ISwapRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n//++++++++++++++++++++++++++++++++++++\r\n\r\n//  __\u00b6\u00b6________________________\u00b6\u00b6\r\n//  _\u00b6\u00b6\u00b6____________\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6__\u00b6\u00b6\u00b6\u00b6\u00b6\r\n//  __\u00b6\u00b6\u00b6_________\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6_\r\n//  __\u00b6\u00b6\u00b6\u00b6_______\u00b6\u00b6\u00b6\u00b6_____\u00b6\u00b6\u00b6\u00b6____\r\n//  __\u00b6\u00b6\u00b6\u00b6_______\u00b6\u00b6\u00b6\u00b6_____________\r\n//  __\u00b6\u00b6\u00b6___\u00b6\u00b6\u00b6__\u00b6\u00b6\u00b6\u00b6___\u00b6\u00b6\u00b6_______\r\n//  __\u00b6\u00b6\u00b6___\u00b6\u00b6\u00b6___\u00b6\u00b6\u00b6___\u00b6\u00b6\u00b6_______\r\n//  __\u00b6\u00b6\u00b6_________\u00b6\u00b6\u00b6_____________\r\n//  __\u00b6\u00b6\u00b6_________\u00b6\u00b6\u00b6_____________\r\n//  __\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6__\r\n//  ___\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6_\r\n//  ______________\u00b6\u00b6\u00b6\u00b6_______\u00b6\u00b6\u00b6\u00b6_\r\n//  ______________\u00b6\u00b6\u00b6\u00b6_______\u00b6\u00b6\u00b6\u00b6_\r\n//  ________\u00b6\u00b6\u00b6____\u00b6\u00b6\u00b6__\u00b6\u00b6\u00b6__\u00b6\u00b6\u00b6\u00b6_\r\n//  ________\u00b6\u00b6\u00b6____\u00b6\u00b6\u00b6__\u00b6\u00b6\u00b6__\u00b6\u00b6\u00b6\u00b6_\r\n//  _______________\u00b6\u00b6\u00b6_______\u00b6\u00b6\u00b6\u00b6_\r\n//  ___\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6_______\u00b6\u00b6\u00b6\u00b6_\r\n//  _\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6_________\u00b6\u00b6\u00b6_\r\n//  \u00b6\u00b6\u00b6\u00b6_______________________\u00b6\u00b6\u00b6\r\n\r\n//  \u0935\u0915\u094d\u0930 \u0924\u0941\u0902\u0921 \u092e\u0939\u093e\u0915\u093e\u092f, \u0938\u0942\u0930\u094d\u092f \u0915\u094b\u091f\u093f \u0938\u092e\u092a\u094d\u0930\u092d:\u0964 \u0928\u093f\u0930\u094d\u0935\u093f\u0918\u094d\u0928\u0902 \u0915\u0941\u0930\u0941 \u092e\u0947 \u0926\u0947\u0935 \u0936\u0941\u092d \u0915\u093e\u0930\u094d\u092f\u0947\u0937\u0941 \u0938\u0930\u094d\u0935\u0926\u093e \u0965\r\n\r\n//++++++++++++++++++++++++++++++++++++++++++++\r\n\r\ncontract AntiGravity is IERC20, Ownable {\r\n    uint256 private constant MAX_UINT256 = ~uint256(0);\r\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 10 * 10**15 * 10**DECIMALS;\r\n    uint256 private constant BP_DIVISOR = 10000;\r\n    \r\n    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    string private constant NAME = \"AntiGravity\"; \r\n    string private constant SYMBOL = \"AntiG\"; \r\n    uint8 private constant DECIMALS = 9;\r\n\r\n    uint256 public liquidityTax = 500;\r\n    uint256 public marketingTax = 200;\r\n    uint256 public lotteryTax = 200;\r\n    uint256 public transactionTax = liquidityTax + marketingTax + lotteryTax;\r\n    uint256 public numTokensSellDivisor = 10000;\r\n\r\n    ISwapRouter02 public swapRouter;\r\n    address public swapPair;\r\n    address public marketingWallet = 0xd3a2d311CD31BF60F29b4e718e25868DF1b543d1;\r\n    address public lotteryWallet = 0x101a70664cF5035048D6ccD6a63b8b379e13304e;\r\n    address public operator;\r\n    uint256 private marketingWalletHoldings;\r\n    uint256 public maxTx = 100;\r\n    uint256 public maxWallet = 50;\r\n\r\n    bool private inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled = true;\r\n\r\n    mapping (address => bool) private _isExcluded;    \r\n    mapping (address => bool) private _isMaxTxExcluded;\r\n    mapping(address => bool) public isBlacklisted;\r\n    uint256 public launchTime;\r\n\r\n    // TOTAL_FOMOS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _fomosPerFragment is an integer.\r\n    // Use the highest value that fits in a uint256 for max granularity.\r\n    uint256 private constant TOTAL_FOMOS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\r\n\r\n    // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_FOMOS + 1) - 1) / 2\r\n    uint256 private constant MAX_SUPPLY = ~uint128(0);  // (2^128) - 1\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 public _fomosPerFragment;\r\n    mapping(address => uint256) public _fomoBalances;\r\n\r\n    // This is denominated in Fragments, because the fomos-fragments conversion might change before it's fully paid.\r\n    mapping (address => mapping (address => uint256)) private _allowedFragments;\r\n    \r\n    event LogRebase (uint256 indexed epoch, uint256 totalSupply);\r\n    \r\n    modifier lockTheSwap {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n    \r\n    modifier onlyOperator {\r\n        require (msg.sender == operator || msg.sender == owner(), \"AntiG: Not authorised\");\r\n        _;\r\n    }\r\n\r\n    constructor (address prouter) {\r\n        ISwapRouter02 _swapRouter = ISwapRouter02 (prouter);\r\n        swapPair = ISwapFactory(_swapRouter.factory()).createPair(address(this), _swapRouter.WETH());\r\n        swapRouter = _swapRouter;\r\n        \r\n        marketingWalletHoldings = _totalSupply * 5 / 100;\r\n\r\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\r\n        _fomoBalances[owner()] = TOTAL_FOMOS;\r\n        _fomosPerFragment = TOTAL_FOMOS / _totalSupply;\r\n\r\n        //exclude owner and this contract from fee\r\n        _isExcluded[owner()] = true;\r\n        _isExcluded[address(this)] = true;\r\n        operator = msg.sender;\r\n        //require (block.number / 10 == 5);\r\n\r\n        emit Transfer(address(0), owner(), _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function rebase (uint256 epoch, int256 supplyDelta) external onlyOperator returns (uint256) {\r\n        if (supplyDelta == 0) {\r\n            emit LogRebase (epoch, _totalSupply);\r\n            return _totalSupply;\r\n        }\r\n\r\n        if (supplyDelta < 0)\r\n            _totalSupply -= (uint256(-supplyDelta) * 10**DECIMALS);\r\n        else\r\n            _totalSupply = _totalSupply + (uint256(supplyDelta) * 10**DECIMALS) > MAX_SUPPLY ? MAX_SUPPLY : _totalSupply + (uint256(supplyDelta) * 10**DECIMALS);\r\n\r\n        _fomosPerFragment = TOTAL_FOMOS / _totalSupply;\r\n        ISwapPair(swapPair).sync();\r\n\r\n        emit LogRebase(epoch, _totalSupply);\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function setOperator (address newOperator) external onlyOwner {\r\n        require (newOperator != address(0), \"AntiG: Can't set operator to the zero address\");\r\n        operator = newOperator;\r\n    }\r\n\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    \r\n    function transfer (address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function transferFrom (address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowedFragments[sender][msg.sender] - amount);\r\n        return true;\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return NAME;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return SYMBOL;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return DECIMALS;\r\n    }\r\n    \r\n    \r\n    function increaseAllowance (address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowedFragments[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function decreaseAllowance (address spender, uint256 subtractedValue) external returns (bool) {\r\n        require (subtractedValue <= _allowedFragments[msg.sender][spender], \"AntiG: Allowance not high enough\");\r\n        _approve(msg.sender, spender, _allowedFragments[msg.sender][spender] - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve (address spender, uint256 amount) public override returns (bool) {\r\n        _approve (msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function allowance (address owner_, address spender) public view override returns (uint256) {\r\n        return _allowedFragments[owner_][spender];\r\n    }\r\n    \r\n\r\n    function setSwapAndLiquifyEnabled (bool _enabled) public onlyOwner {\r\n        swapAndLiquifyEnabled = _enabled;\r\n    }\r\n\r\n\r\n    function balanceOf (address account) public view override returns (uint256) {\r\n        return _fomoBalances[account] / _fomosPerFragment;\r\n    }\r\n    \r\n    \r\n    function _approve (address owner, address spender, uint256 amount) private {\r\n        require (owner != address(0), \"AntiG: Cannot approve from the zero address\");\r\n        require (spender != address(0), \"AntiG: Cannot approve the zero address\");\r\n    \r\n        _allowedFragments[owner][spender] = amount;\r\n        emit Approval (owner, spender, amount);\r\n    }\r\n\r\n\r\n    function _transfer (address sender, address recipient, uint256 amount) private {\r\n        require (recipient != address(0), \"AntiG: Cannot transfer to the zero address\");\r\n        require (amount > 0, \"AntiG: Cannot transfer zero tokens\");\r\n        require (!isBlacklisted[sender] && !isBlacklisted[recipient], \"AntiG: Blacklisted\");\r\n        require (launchTime != 0 || _isExcluded[sender] || _isExcluded[recipient], \"AntiG: Not launched\");\r\n\r\n        uint256 contractTokenBalance = balanceOf (address(this));\r\n        uint256 _maxTxAmount = _totalSupply * maxTx / BP_DIVISOR;\r\n        uint256 numTokensSell = _totalSupply / numTokensSellDivisor;\r\n        \r\n        if (!_isExcluded[sender] && !_isExcluded[recipient])\r\n            require (amount <= _maxTxAmount, \"AntiG: Transfer amount exceeds the maxTxAmount.\");\r\n        \r\n        if (contractTokenBalance >= numTokensSell && !inSwapAndLiquify && swapAndLiquifyEnabled && sender != swapPair && !_isExcluded[sender] && !_isExcluded[recipient])\r\n            swapAndLiquify (numTokensSell);\r\n        \r\n        _tokenTransfer (sender, recipient, amount);\r\n    }\r\n\r\n    function _tokenTransfer (address sender, address recipient, uint256 amount) private {\r\n        if (_fomoBalances[sender] - (amount * _fomosPerFragment) == 0 && !_isExcluded[sender])\r\n            amount -= 1;\r\n            \r\n        uint256 transferAmount = amount * _fomosPerFragment;\r\n        uint256 receiveAmount = transferAmount;\r\n        uint256 fee;\r\n        uint256 maxWalletAmount = (_totalSupply * maxWallet / BP_DIVISOR) * _fomosPerFragment;\r\n        \r\n        if (!_isExcluded[recipient] && sender != owner() && recipient != swapPair)\r\n            require (_fomoBalances[recipient] + receiveAmount <= maxWalletAmount, \"AntiG: Can't hold that much\");\r\n        \r\n        if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n            uint256 denominator = (launchTime > 0 && block.timestamp < launchTime + 5) ? transactionTax + 100 : BP_DIVISOR;\r\n            fee = amount * transactionTax / denominator;\r\n            receiveAmount -= (fee * _fomosPerFragment);\r\n        }\r\n        \r\n        _fomoBalances[sender] -= transferAmount;\r\n        _fomoBalances[recipient] += receiveAmount;\r\n        \r\n        if (fee > 0) {\r\n            _fomoBalances[address(this)] += (fee * _fomosPerFragment);\r\n            emit Transfer (sender, address(this), fee);\r\n        }\r\n            \r\n        emit Transfer (sender, recipient, amount - fee);\r\n    }\r\n\r\n    function swapAndLiquify (uint256 contractTokenBalance) private lockTheSwap {\r\n        uint256 feeDivisor = transactionTax;\r\n        uint256 tokensForLiquidity = contractTokenBalance * liquidityTax / (feeDivisor * 2);\r\n        uint256 tokensToETH = contractTokenBalance - tokensForLiquidity;\r\n        swapTokensForEth (tokensToETH);\r\n        uint256 ethForOtherFees = addLiquidity (tokensForLiquidity, address(this).balance);\r\n        feeDivisor -= liquidityTax;\r\n        uint256 marketingETH = ethForOtherFees * marketingTax / feeDivisor;\r\n        \r\n        if (marketingETH > 0) {\r\n            payable(marketingWallet).transfer (marketingETH);\r\n            payable(lotteryWallet).transfer (address(this).balance);\r\n        }\r\n    }\r\n    \r\n    function swapTokensForEth (uint256 tokenAmount) private {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = swapRouter.WETH();\r\n\r\n        _approve (address(this), address(swapRouter), tokenAmount);\r\n\r\n        swapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens (\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function addLiquidity (uint256 tokenAmount, uint256 ethAmount) private returns (uint256) {\r\n        _approve (address(this), address(swapRouter), tokenAmount);\r\n\r\n        // add the liquidity\r\n        (, uint256 amountEthFromLiquidity,) = swapRouter.addLiquidityETH { value: ethAmount } (\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        \r\n        return (ethAmount - amountEthFromLiquidity);\r\n    }\r\n\r\n    function excludeAddressFromFees (address account) external onlyOwner {\r\n        _isExcluded[account] = true;\r\n    }\r\n\r\n    function excludeFromMaxTxLimit (address account) external onlyOwner {\r\n        _isMaxTxExcluded[account] = true;\r\n    }\r\n    \r\n    function blacklistAddress (address account, bool blacklist) external onlyOwner {\r\n        isBlacklisted[account] = blacklist;\r\n    }\r\n\r\n    function airDrop(address[] calldata recipients, uint256[] calldata amounts) external onlyOwner {\r\n        require (recipients.length == amounts.length, \"AntiG: Recipients and amounts lengths must match\");\r\n        \r\n        for (uint256 i = 0; i < recipients.length; i++)\r\n            _tokenTransfer (msg.sender, recipients[i], amounts[i]);\r\n    }\r\n\r\n    function setNumTokensSellDivisor (uint256 _numTokensSellDivisor) external onlyOwner {\r\n        numTokensSellDivisor = _numTokensSellDivisor;\r\n    }\r\n\r\n    function setFees (uint256 _marketingFee, uint256 _liquidityFee, uint256 _lotteryFee) external onlyOwner {\r\n        uint256 totalFee = _marketingFee + _liquidityFee + _lotteryFee;\r\n        require (totalFee < 3000, \"AntiG: Total fee must be < 30%\");\r\n        liquidityTax = _liquidityFee;\r\n        marketingTax = _marketingFee;\r\n        lotteryTax = _lotteryFee;\r\n        transactionTax = totalFee;\r\n    }\r\n    \r\n    function setMarketingWallet(address payable wallet) external onlyOwner{\r\n        require(marketingWallet != address(0), \"Ronin: Can't set marketing wallet to the zero address\");\r\n        marketingWallet = wallet;\r\n    }\r\n    \r\n    function setLotteryWallet(address payable wallet) external onlyOwner{\r\n        require(lotteryWallet != address(0), \"Ronin: Can't set marketing wallet to the zero address\");\r\n        lotteryWallet = wallet;\r\n    }\r\n\r\n    function setMaxTx (uint256 _maxTx) external onlyOwner {\r\n        require (_maxTx > 10, \"AntiG: Max tx must be > 0.1%\");\r\n        maxTx = _maxTx;\r\n    }\r\n\r\n    function setMaxWallet (uint256 _maxWallet) external onlyOwner {\r\n        require (_maxWallet > 10, \"AntiG: Max wallet must be > 0.1%\");\r\n        maxWallet = _maxWallet;\r\n    }\r\n    \r\n    function launch() external onlyOwner {\r\n        launchTime = block.timestamp;\r\n    }\r\n    \r\n    function withdrawWETH (address _account) external onlyOwner  {\r\n        require (_account != address(0), \"AntiG: Can't withdraw to the zero address\");\r\n        \r\n        uint256 contractBalance = address(this).balance;\r\n        \r\n        if (contractBalance > 0)\r\n            payable(_account).transfer(contractBalance);\r\n    }\r\n    \r\n    function withdrawToken (address _token, address _account) external onlyOwner {\r\n        require (_token != address(0), \"AntiG: Can't withdraw a token of zero address\");\r\n        require (_token != address(this), \"AntiG: Can't withdraw AntiG token\");\r\n        require (_account != address(0), \"AntiG: Can't withdraw to the zero address\");\r\n        \r\n        uint256 tokenBalance = IERC20(_token).balanceOf (address(this));\r\n        \r\n        if (tokenBalance > 0)\r\n            IERC20(_token).transfer (_account, tokenBalance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_fomoBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fomosPerFragment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"airDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"blacklist\",\"type\":\"bool\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAddressFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromMaxTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyDelta\",\"type\":\"int256\"}],\"name\":\"rebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lotteryFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setLotteryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTx\",\"type\":\"uint256\"}],\"name\":\"setMaxTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWallet\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokensSellDivisor\",\"type\":\"uint256\"}],\"name\":\"setNumTokensSellDivisor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"withdrawWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AntiGravity", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://29b3bd932c26bc4f16316cd9cffbd8b2088cd9f14121ca6f031c92d9a0ba58b6"}