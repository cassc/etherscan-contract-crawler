{"SourceCode": "pragma solidity 0.8.4;\r\n//SPDX-License-Identifier: UNLICENSED\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender)\r\n  external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value)\r\n  external returns (bool);\r\n  \r\n  function transferFrom(address from, address to, uint256 value)\r\n  external returns (bool);\r\n  function burn(uint256 value)\r\n  external returns (bool);\r\n  event Transfer(address indexed from,address indexed to,uint256 value);\r\n  event Approval(address indexed owner,address indexed spender,uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n   \r\ncontract LAROSTAKING  \r\n{\r\n     using SafeMath for uint256;\r\n     struct Stake {\r\n        uint256 id;\r\n        uint amount;\r\n        uint duration;\r\n        uint startTimestamp;\r\n        uint endTimestamp;\r\n        uint nextwithdate;\r\n        uint stakingExpiryDate;\r\n        uint stakingStatus;\r\n    }\r\n    struct GrowthLevelStake {\r\n        uint256 grid;\r\n        address fromuser;\r\n        uint vAmount;\r\n        uint growthShare;\r\n        uint duration;\r\n        uint startTimestamp;\r\n        uint endTimestamp;\r\n        uint nextwithdate;\r\n    }\r\n\r\n    struct User {\r\n        uint userId;\r\n        address referrer;\r\n        uint partnerCount;\r\n        uint directBusiness;\r\n        uint totalStake;\r\n        uint stakingReward;\r\n        uint growthReward;\r\n        mapping(uint=>uint) directCountWithTime;\r\n        mapping(uint=>Stake) stakes;\r\n        mapping(uint=>GrowthLevelStake) growthStakes;\r\n    }\r\n   \r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n   \r\n    uint public lastUserId = 2;\r\n    uint public nextStackId = 1;\r\n    uint public stakingPackage = 100000*1e18;\r\n    uint public laroRate=100;   //1 lro=100 laro\r\n \taddress public owner;\r\n    \r\n    IBEP20 private LARO; \r\n    IBEP20 private LRO; \r\n\r\n    event StakingUserReg(address indexed user,address indexed referrer,uint256 totalstaking);\r\n    event Staking(address indexed user,uint256 StackId,uint256 totalstaking,uint256 unstakingDate, uint256 expiryDate);\r\n    event GrowthStaking(address indexed user,uint256 StackId,address indexed fromUser,uint256 totalstaking,uint256 growthStakes);\r\n    event UnStaking(address indexed user,uint256 StackId,uint256 amount);\r\n    event StakingWithdrawal(address indexed user,uint256 withAmt,string withtype,address indexed fromUser,uint256 stakingId);\r\n  \r\n    constructor(address ownerAddress, IBEP20 _LARO,IBEP20 _LRO)  \r\n    {\r\n        owner = ownerAddress;\r\n        LARO = _LARO;\r\n        LRO=_LRO;\r\n\r\n        users[ownerAddress].userId = 1;\r\n\r\n        users[ownerAddress].referrer = owner;\r\n        users[ownerAddress].partnerCount = 0;\r\n        users[ownerAddress].totalStake = 0;\r\n        users[ownerAddress].directBusiness = 0;\r\n        users[ownerAddress].stakingReward=0;\r\n        users[ownerAddress].growthReward=0;\r\n        idToAddress[1] = ownerAddress;\r\n   }\r\n\r\n    function regUser(address referrerAddress,uint256 stakingAmt) public payable\r\n    {\r\n       \r\n        require(stakingAmt>=stakingPackage,\"Minimum Staking is 1 Lakh\");\r\n        require(isUserExists(referrerAddress), \"Referral Not exists\");\r\n        require(!isUserExists(msg.sender), \"User Allready exists\");\r\n        require(LRO.balanceOf(msg.sender)>=stakingAmt,\"Low Token Balance In Wallet\");\r\n        LRO.transferFrom(msg.sender,address(this),stakingAmt);\r\n        users[msg.sender].userId = lastUserId;\r\n        users[msg.sender].referrer = referrerAddress;\r\n        users[msg.sender].partnerCount = 0;\r\n        users[msg.sender].totalStake = stakingAmt;\r\n        users[referrerAddress].directBusiness = stakingAmt;\r\n        uint256 unstakingDate=expiryMonth(block.timestamp,12);\r\n        uint256 expiryDate=expiryMonth(block.timestamp,48);\r\n        uint256 nextwithDate=addOneMonth(block.timestamp);\r\n        users[msg.sender].stakes[nextStackId]=Stake(nextStackId,stakingAmt,48,block.timestamp,\r\n            expiryDate,nextwithDate,unstakingDate,0);\r\n\r\n        emit Staking(msg.sender,nextStackId,stakingAmt,unstakingDate,expiryDate);\r\n        lastUserId++;\r\n        users[referrerAddress].growthStakes[nextStackId]=\r\n            GrowthLevelStake(nextStackId,msg.sender,stakingAmt,stakingAmt,48,block.timestamp,\r\n            expiryDate,nextwithDate);\r\n        emit GrowthStaking(referrerAddress,nextStackId,msg.sender,stakingAmt,stakingAmt);\r\n        nextStackId++;\r\n\r\n    }\r\n\r\n   function regUserowner(address referrerAddress,address userAddress,uint256 stakingAmt) public payable\r\n    {\r\n         require(msg.sender==owner,'Only Owner');\r\n        require(stakingAmt>=stakingPackage,\"Minimum Staking is 1 Lakh\");\r\n        require(isUserExists(referrerAddress), \"Referral Not exists\");\r\n        require(!isUserExists(userAddress), \"User Allready exists\");\r\n\r\n        users[userAddress].userId = lastUserId;\r\n        users[userAddress].referrer = referrerAddress;\r\n        users[userAddress].partnerCount = 0;\r\n        users[userAddress].totalStake = stakingAmt;\r\n        users[referrerAddress].directBusiness = stakingAmt;\r\n        uint256 unstakingDate=expiryMonth(block.timestamp,12);\r\n        uint256 expiryDate=expiryMonth(block.timestamp,48);\r\n        uint256 nextwithDate=addOneMonth(block.timestamp);\r\n        users[userAddress].stakes[nextStackId]=Stake(nextStackId,stakingAmt,48,block.timestamp,\r\n            expiryDate,nextwithDate,unstakingDate,0);\r\n\r\n        emit Staking(userAddress,nextStackId,stakingAmt,unstakingDate,expiryDate);\r\n\r\n        lastUserId++;\r\n\r\n        users[referrerAddress].growthStakes[nextStackId]=\r\n            GrowthLevelStake(nextStackId,userAddress,stakingAmt,stakingAmt,48,block.timestamp,\r\n            expiryDate,nextwithDate);\r\n        emit GrowthStaking(referrerAddress,nextStackId,userAddress,stakingAmt,stakingAmt);\r\n        nextStackId++;\r\n\r\n    }\r\n    function swapLaro(uint256 laroQty) public payable\r\n    {\r\n        uint256 lroQty=laroQty/laroRate;\r\n        require(LARO.balanceOf(msg.sender)>=laroQty,\"Low Token Balance In Wallet\");\r\n        LARO.transferFrom(msg.sender,address(this),laroQty);\r\n        LRO.transfer(msg.sender,lroQty);\r\n    }\r\n    function Restaking(uint256 stakingAmt) public payable\r\n    {\r\n        require(stakingAmt>=stakingPackage,\"Minimum Staking is 1 Lakh\");\r\n        require(isUserExists(msg.sender), \"User Not exists\");\r\n        require(LRO.balanceOf(msg.sender)>=stakingAmt,\"Low Token Balance In Wallet\");\r\n        LRO.transferFrom(msg.sender,address(this),stakingAmt);\r\n        address referrerAddress=users[msg.sender].referrer;\r\n        users[msg.sender].totalStake += stakingAmt;\r\n        users[referrerAddress].directBusiness = stakingAmt;\r\n        users[msg.sender].stakingReward=0;\r\n        users[msg.sender].growthReward=0;\r\n        idToAddress[lastUserId] = msg.sender;\r\n        uint256 unstakingDate=expiryMonth(block.timestamp,12);\r\n        uint256 expiryDate=expiryMonth(block.timestamp,48);\r\n        uint256 nextwithDate=addOneMonth(block.timestamp);\r\n        users[msg.sender].stakes[nextStackId]=\r\n            Stake(nextStackId,stakingAmt,48,block.timestamp,\r\n            expiryDate,nextwithDate,unstakingDate,0);\r\n        emit Staking(msg.sender,nextStackId,stakingAmt,unstakingDate,expiryDate);\r\n\r\n        lastUserId++;\r\n\r\n        users[referrerAddress].growthStakes[nextStackId]=GrowthLevelStake(nextStackId,msg.sender,stakingAmt,stakingAmt,48,block.timestamp,\r\n            expiryDate,nextwithDate);\r\n        emit GrowthStaking(referrerAddress,nextStackId,msg.sender,stakingAmt,stakingAmt);\r\n        nextStackId++;\r\n\r\n    }\r\n    function addOneMonth(uint256 _timestamp) public pure returns (uint256) {\r\n        uint256 secondsInMonth = 30 days;\r\n       // uint256 secondsInMonth = 60;\r\n        return _timestamp.add(secondsInMonth);\r\n    }\r\n    function expiryMonth(uint256 _timestamp,uint duration) public pure returns (uint256) {\r\n        uint256 secondsInMonth = 30 days;\r\n        //uint256 secondsInMonth = 60;\r\n        return _timestamp.add(secondsInMonth*duration);\r\n    }\r\n    function claimRoiReward(uint256 stakingId) external  {\r\n        Stake storage userStakes = users[msg.sender].stakes[stakingId];\r\n        if (block.timestamp>=userStakes.nextwithdate ) \r\n        {\r\n            uint256 withAmt=(userStakes.amount)*3/100;\r\n            LRO.transfer(msg.sender,withAmt);\r\n            users[msg.sender].stakingReward+=withAmt;\r\n            emit StakingWithdrawal(msg.sender,withAmt,\"STAKING\",msg.sender,stakingId);\r\n            if(userStakes.endTimestamp>userStakes.nextwithdate)\r\n            {\r\n                uint nextMonth=addOneMonth(userStakes.nextwithdate); \r\n                userStakes.nextwithdate=  nextMonth;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            revert(\"Stake not found\"); \r\n        }\r\n        \r\n    }\r\n    \r\n    function unStack(uint256 stakingId) external  {\r\n        Stake storage userStakes = users[msg.sender].stakes[stakingId];\r\n        uint stStaus=userStakes.stakingStatus;\r\n        if (block.timestamp>=userStakes.stakingExpiryDate && stStaus==0) \r\n        {\r\n            uint256 withAmt=userStakes.amount;\r\n            LRO.transfer(msg.sender,withAmt);\r\n            users[msg.sender].totalStake-=withAmt;\r\n            emit UnStaking(msg.sender,stakingId,withAmt);\r\n           userStakes.stakingStatus=  1;\r\n        }\r\n        else{\r\n            revert(\"Stake not found\"); \r\n        }\r\n     \r\n        \r\n    }\r\n    function claimGrwthReward(uint256 stakingId) external  {\r\n        GrowthLevelStake storage userStakes = users[msg.sender].growthStakes[stakingId];\r\n     \r\n            if (block.timestamp>=userStakes.nextwithdate) \r\n            {\r\n                uint256 withAmt=(userStakes.vAmount)*2/100;\r\n                LRO.transfer(msg.sender,withAmt);\r\n                users[msg.sender].growthReward+=withAmt;\r\n                emit StakingWithdrawal(msg.sender,withAmt,\"GROWTH\",userStakes.fromuser,stakingId);\r\n                if(userStakes.endTimestamp>userStakes.nextwithdate)\r\n                {\r\n                    uint nextMonth=addOneMonth(userStakes.nextwithdate); \r\n                    userStakes.nextwithdate=  nextMonth;\r\n                }\r\n            }\r\n            else{\r\n                revert(\"Stake not found\"); \r\n            }\r\n      \r\n        \r\n    }\r\n\r\n    function getStakeByUser(address _user,uint256 idn) external view returns (uint256,uint,uint,uint,uint,uint,uint,uint) {\r\n        Stake storage userStakes = users[_user].stakes[idn];\r\n        return (userStakes.id,userStakes.amount,userStakes.duration,userStakes.startTimestamp,userStakes.endTimestamp,userStakes.nextwithdate,userStakes.stakingExpiryDate,userStakes.stakingStatus);\r\n       }\r\n     function getGrowthByUser(address _user,uint256 idn) external view returns(GrowthLevelStake memory) {\r\n       return users[_user].growthStakes[idn];\r\n    }\r\n    \r\n\tfunction isUserExists(address user) public view returns (bool) \r\n    {\r\n        return (users[user].userId != 0);\r\n    }\r\n\t\r\n    function isContract(address _address) public view returns (bool _isContract)\r\n    {\r\n          uint32 size;\r\n          assembly {\r\n            size := extcodesize(_address)\r\n          }\r\n          return (size > 0);\r\n    }    \r\n    function setPackage(uint256 _package) public \r\n    {\r\n        require(msg.sender==owner,'Only Owner');\r\n        stakingPackage=_package;\r\n    }  \r\n\r\n       function tokenRelise(uint256 _withAmt,IBEP20 _Token) public \r\n    {\r\n        require(msg.sender==owner,'Only Owner');\r\n        _Token.transfer(msg.sender,_withAmt);\r\n    }  \r\n     \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"contract IBEP20\",\"name\":\"_LARO\",\"type\":\"address\"},{\"internalType\":\"contract IBEP20\",\"name\":\"_LRO\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"StackId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalstaking\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"growthStakes\",\"type\":\"uint256\"}],\"name\":\"GrowthStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"StackId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalstaking\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakingDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"}],\"name\":\"Staking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalstaking\",\"type\":\"uint256\"}],\"name\":\"StakingUserReg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"withtype\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"StakingWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"StackId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnStaking\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingAmt\",\"type\":\"uint256\"}],\"name\":\"Restaking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"addOneMonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"claimGrwthReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"claimRoiReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"expiryMonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"idn\",\"type\":\"uint256\"}],\"name\":\"getGrowthByUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"grid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromuser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"growthShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextwithdate\",\"type\":\"uint256\"}],\"internalType\":\"struct LAROSTAKING.GrowthLevelStake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"idn\",\"type\":\"uint256\"}],\"name\":\"getStakeByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isContract\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"laroRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextStackId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmt\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmt\",\"type\":\"uint256\"}],\"name\":\"regUserowner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_package\",\"type\":\"uint256\"}],\"name\":\"setPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPackage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"laroQty\",\"type\":\"uint256\"}],\"name\":\"swapLaro\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withAmt\",\"type\":\"uint256\"},{\"internalType\":\"contract IBEP20\",\"name\":\"_Token\",\"type\":\"address\"}],\"name\":\"tokenRelise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"unStack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"partnerCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"growthReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LAROSTAKING", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d4cbbb154f54611ab1b94268ec021e1210a10674000000000000000000000000f31da2bbd0cc88cf204f76b21425a865ad9acc31000000000000000000000000c279c59301b9278022c5a271e4c185b03c193713", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://25ee2e62916ef3226144b606ffaf7746006a2f8744d84c6eb40c7082fe8033a2"}