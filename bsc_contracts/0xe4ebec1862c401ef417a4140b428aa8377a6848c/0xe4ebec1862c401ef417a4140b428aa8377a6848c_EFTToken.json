{"SourceCode": "pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ncontract Context {\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface NewLease{\r\n    function getAllOrderCountByUserAddress(address userAddress) external view returns (uint[5] memory);\r\n}\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC165 {\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IERC721 is IERC165 {\r\n   \r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n   \r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n   \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n  \r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    \r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n \r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    \r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function balanceOfLevel(address owner,uint level) external view returns (uint);\r\n\r\n    function  totalSupplyOfLevel(uint level) external view returns (uint);\r\n\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (signature.length != 65) {\r\n           return address(0);\r\n        }\r\n\r\n        assembly {\r\n        r := mload(add(signature, 32))\r\n        s := mload(add(signature, 64))\r\n        v := and(mload(add(signature, 65)), 255)\r\n        }\r\n\r\n        // https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n        v += 27;\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n           return address(0);\r\n        }\r\n\r\n        /* prefix might be needed for geth only\r\n        * https://github.com/ethereum/go-ethereum/issues/3731\r\n        */\r\n        // bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        // hash = sha3(prefix, hash);\r\n\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n    \r\n}\r\n\r\n \r\ncontract ERC20 is Context,IERC20,Ownable{\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    using ECDSA for *;\r\n\r\n    mapping (address => uint) public _balances;\r\n\r\n    mapping (address => mapping (address => uint)) private _allowances;\r\n\r\n    event WithdrawEFT(address indexed account, uint256 indexed etf);\r\n\r\n    uint private _totalSupply;\r\n    \r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    uint256 public _nftFee=30;\r\n\r\n    uint256 public _LPFee=20;\r\n\r\n    mapping (address => bool) public _isExcludedFromFee;\r\n\r\n    bool public issueNft;\r\n\r\n    address public leaseAddress;\r\n    uint public addPriceTokenAmount = 1e14;\r\n    address public GSDAddress=0xB12E8Eb6b1F24e14381514d2f3B75e7c61487016;\r\n    address public nftAddress=0x1a62fe088F46561bE92BB5F6e83266289b94C154;\r\n\r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    address public  uniswapV2Pair;\r\n\r\n    uint public period=1800;\r\n    uint public lastSendLPTime;\r\n    uint public lastSendNFTTime;\r\n    uint public sendCount=50;\r\n\r\n\r\n    address[] public shareholdersOfNFT;\r\n    mapping (address => uint256) public shareholderIndexesOfNFT;\r\n    mapping(address => bool) public _updatedOfNFT;\r\n    uint256  public currentIndexOfNFT;  \r\n    address[] public shareholdersOfLP;\r\n    mapping (address => uint256) public shareholderIndexesOfLP;\r\n    mapping(address => bool) public _updatedOfLP;\r\n    uint256 public currentIndexOfLP;  \r\n\r\n    struct HistoryInfo {\r\n        uint256 withdrawType;\r\n        uint256 withdrawTime;\r\n        uint256 withdrawAmount;\r\n    }\r\n\r\n    mapping(address=>HistoryInfo[]) public withdrawHistory;\r\n\r\n    \r\n\r\n    address public _specialAddress;\r\n\r\n    mapping (address => uint256) private _nonces;\r\n    bool isCreatePair;\r\n\r\n\r\n\r\n    bytes32 constant public _withdrawEFT_TYPEHASH = keccak256(\"withdrawEFT(uint8 chain_id, address sender, address signer, uint256 EFT, uint256 nonce, uint256 deadline)\");\r\n\r\n\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint totalSupply) public {\r\n        require(GSDAddress<address(this));\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = totalSupply;\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n         // Create a uniswap pair for this new token\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), GSDAddress);\r\n\r\n        // set the rest of the contract variables\r\n        uniswapV2Router = _uniswapV2Router;\r\n\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n\r\n        _specialAddress=msg.sender;\r\n        lastSendLPTime =block.timestamp;\r\n        \r\n    }\r\n\r\n    function nonces(address account) external view returns (uint256) {\r\n\t\treturn _nonces[account];\r\n\t}\r\n\r\n\r\n    function withdrawEFT(uint256 EFT, uint256 deadline, uint256 withdrawType,bytes memory signature) public returns (bool){\r\n        require(msg.sender == tx.origin,\"Address: The transferred address cannot be a contract\");\r\n\t\trequire(EFT > 0, \"mine EFT is zero\");\r\n        require(block.timestamp <= deadline, \"withdrawEFT: expired deadline\");\r\n\t    require(EFT<=_balances[address(this)], \"cannot mine more EFT\");\r\n        bytes32 digest = keccak256(abi.encode(_withdrawEFT_TYPEHASH, 56,_specialAddress, msg.sender, EFT, _nonces[msg.sender], deadline)\r\n        );\r\n        address recoveredAddress = digest.recover(signature);\r\n        \r\n        require(recoveredAddress != address(0) &&recoveredAddress == _specialAddress, \"sign address is error\");\r\n        _nonces[msg.sender] = _nonces[msg.sender].add(1);\r\n        _balances[address(this)] = _balances[address(this)].sub(EFT);\r\n\t\t_balances[msg.sender] = _balances[msg.sender].add(EFT);\r\n        emit Transfer(address(this), msg.sender, EFT);\r\n         withdrawHistory[msg.sender].push(\r\n            HistoryInfo({\r\n                withdrawType:withdrawType,\r\n                withdrawTime:block.timestamp,\r\n                withdrawAmount:EFT\r\n            })\r\n        );\r\n\t\temit WithdrawEFT(msg.sender, EFT);\r\n\t    return true;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view override returns (uint) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view override returns (uint) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from,address to, uint256 amount) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        bool isAddLiquidity;\r\n        bool isDelLiquidity;\r\n        ( isAddLiquidity, isDelLiquidity) = _isLiquidity(from,to);\r\n        bool takeFee = true;\r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]||to!=uniswapV2Pair||isAddLiquidity||isDelLiquidity){\r\n            takeFee=false;\r\n        }\r\n\r\n        uint256 LPFee;\r\n        uint256 NFTFee;\r\n        if (takeFee){\r\n            LPFee=calculateLPFee(amount);\r\n            _takeLPFee(from,LPFee);\r\n            NFTFee=calculateNFTFee(amount);\r\n            _takeNFTFee(to,NFTFee);\r\n        }\r\n\r\n\r\n        _balances[from] = _balances[from].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        uint256 trunAmount=amount.sub(LPFee).sub(NFTFee);\r\n        _balances[to] = _balances[to].add(trunAmount);\r\n        emit Transfer(from, to, trunAmount);\r\n        if(!address(from).isContract() && from != address(0) ) setShareOfLP(from);\r\n        if(!address(to).isContract() && to != address(0) )setShareOfLP(to);\r\n        if (issueNft){\r\n            if(!address(from).isContract() && from != address(0) ) setShareOfNFT(from);\r\n            if(!address(to).isContract() && to != address(0) ) setShareOfNFT(to);\r\n         }\r\n\r\n        if(lastSendLPTime <block.timestamp&&lastSendLPTime!=0) {\r\n             processOfLP();\r\n             lastSendLPTime = block.timestamp.add(period);\r\n        }else if(lastSendNFTTime <block.timestamp&&lastSendNFTTime!=0&&issueNft) {\r\n             processOfNFT();\r\n             lastSendNFTTime = block.timestamp.add(period).add(600);\r\n        }\r\n\r\n\r\n        if (to==uniswapV2Pair&&!isCreatePair){\r\n            // require(from==0xb00985Da0555EE582ebdf24a1b72996AE77a72cD);\r\n            isCreatePair=true;\r\n            lastSendLPTime=block.timestamp.add(period);\r\n            lastSendNFTTime = block.timestamp.add(period).add(600);\r\n        }\r\n    }\r\n    function _approve(address owner, address spender, uint amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    function processOfNFT() private {\r\n        \r\n        uint256 shareholderCount = shareholdersOfNFT.length;\r\n\r\n        if(shareholderCount == 0)return;\r\n        uint256 nowbalance3 = _balances[address(0x3000000000000000000000000000000000000000)];\r\n        uint256 nowbalance4 = _balances[address(0x4000000000000000000000000000000000000000)];\r\n        uint256 nowbalance5 = _balances[address(0x5000000000000000000000000000000000000000)];\r\n\r\n        uint256 iterations = 0;\r\n\r\n        while(iterations<sendCount && iterations < shareholderCount) {\r\n            if(currentIndexOfNFT >= shareholderCount){\r\n                currentIndexOfNFT = 0;\r\n            }\r\n            uint[5] memory balanceList=NewLease(leaseAddress).getAllOrderCountByUserAddress(shareholdersOfNFT[currentIndexOfNFT]);\r\n            uint256 amount3 = nowbalance3.mul(IERC721(nftAddress).balanceOfLevel(shareholdersOfNFT[currentIndexOfNFT],3).add(balanceList[2])).div(IERC721(nftAddress).totalSupplyOfLevel(3));\r\n            uint256 amount4 = nowbalance4.mul(IERC721(nftAddress).balanceOfLevel(shareholdersOfNFT[currentIndexOfNFT],4).add(balanceList[3])).div(IERC721(nftAddress).totalSupplyOfLevel(4));\r\n            uint256 amount5 = nowbalance5.mul(IERC721(nftAddress).balanceOfLevel(shareholdersOfNFT[currentIndexOfNFT],5).add(balanceList[4])).div(IERC721(nftAddress).totalSupplyOfLevel(5));\r\n            \r\n            distributeDividendOfNFT(shareholdersOfNFT[currentIndexOfNFT],amount3,amount4,amount5);\r\n            currentIndexOfNFT++;\r\n            iterations++;\r\n\r\n            }\r\n    }\r\n\r\n    function distributeDividendOfNFT(address shareholder ,uint256 amount3,uint256 amount4,uint256 amount5) internal {\r\n        if (_balances[address(0x3000000000000000000000000000000000000000)]>amount3&&amount3!=0){\r\n            _balances[address(0x3000000000000000000000000000000000000000)] = _balances[address(0x3000000000000000000000000000000000000000)].sub(amount3);\r\n            _balances[shareholder] = _balances[shareholder].add(amount3);\r\n             emit Transfer(address(0x3000000000000000000000000000000000000000), shareholder, amount3);\r\n        }\r\n        if (_balances[address(0x4000000000000000000000000000000000000000)]>amount4&&amount4!=0){\r\n            _balances[address(0x4000000000000000000000000000000000000000)] = _balances[address(0x4000000000000000000000000000000000000000)].sub(amount4);\r\n            _balances[shareholder] = _balances[shareholder].add(amount4);\r\n             emit Transfer(address(0x4000000000000000000000000000000000000000), shareholder, amount4);\r\n        }\r\n        if (_balances[address(0x5000000000000000000000000000000000000000)]>amount5&&amount5!=0){\r\n            _balances[address(0x5000000000000000000000000000000000000000)] = _balances[address(0x5000000000000000000000000000000000000000)].sub(amount5);\r\n            _balances[shareholder] = _balances[shareholder].add(amount5);\r\n             emit Transfer(address(0x5000000000000000000000000000000000000000), shareholder, amount5);\r\n        } \r\n    }\r\n\r\n    function setShareOfNFT(address shareholder) private {\r\n           uint balance3=IERC721(nftAddress).balanceOfLevel(shareholder,3);\r\n           uint balance4=IERC721(nftAddress).balanceOfLevel(shareholder,4);\r\n           uint balance5=IERC721(nftAddress).balanceOfLevel(shareholder,5);\r\n           uint[5] memory balanceList=NewLease(leaseAddress).getAllOrderCountByUserAddress(shareholder);\r\n           if(_updatedOfNFT[shareholder] ){      \r\n                if(balance3== 0&&balance4 == 0&&balance5 == 0&&balanceList[2]==0&&balanceList[3]==0&&balanceList[4]==0) {\r\n                    quitShareOfNFT(shareholder); \r\n                }           \r\n                return; \r\n           }\r\n           if(balance3== 0&&balance4 == 0&&balance5 == 0&&balanceList[2]==0&&balanceList[3]==0&&balanceList[4]==0)return;\r\n            addShareholderOfNFT(shareholder);\r\n            _updatedOfNFT[shareholder] = true;\r\n      }\r\n    function addShareholderOfNFT(address shareholder) internal {\r\n        shareholderIndexesOfNFT[shareholder] = shareholdersOfNFT.length;\r\n        shareholdersOfNFT.push(shareholder);\r\n    }\r\n    function quitShareOfNFT(address shareholder) private {\r\n           removeShareholderOfNFT(shareholder);   \r\n           _updatedOfNFT[shareholder] = false; \r\n      }\r\n    function removeShareholderOfNFT(address shareholder) internal {\r\n        shareholdersOfNFT[shareholderIndexesOfNFT[shareholder]] = shareholdersOfNFT[shareholdersOfNFT.length-1];\r\n        shareholderIndexesOfNFT[shareholdersOfNFT[shareholdersOfNFT.length-1]] = shareholderIndexesOfNFT[shareholder];\r\n        shareholdersOfNFT.pop();\r\n    }\r\n\r\n    function processOfLP() private {\r\n        uint256 shareholderCount = shareholdersOfLP.length;\r\n\r\n        if(shareholderCount == 0)return;\r\n        uint256 nowbalance = _balances[address(0x8888888888888888888888888888888888888888)];\r\n\r\n        uint256 iterations = 0;\r\n\r\n        while(iterations<sendCount && iterations < shareholderCount) {\r\n            if(currentIndexOfLP >= shareholderCount){\r\n                currentIndexOfLP = 0;\r\n            }\r\n            uint256 amount = nowbalance.mul(IERC20(uniswapV2Pair).balanceOf(shareholdersOfLP[currentIndexOfLP])).div(IERC20(uniswapV2Pair).totalSupply());\r\n\r\n            if(_balances[address(0x8888888888888888888888888888888888888888)] < amount)return;\r\n                distributeDividendOfLP(shareholdersOfLP[currentIndexOfLP],amount);\r\n                currentIndexOfLP++;\r\n                iterations++;\r\n            }\r\n    }\r\n\r\n    function distributeDividendOfLP(address shareholder ,uint256 amount) internal {\r\n            _balances[address(0x8888888888888888888888888888888888888888)] = _balances[address(0x8888888888888888888888888888888888888888)].sub(amount);\r\n            _balances[shareholder] = _balances[shareholder].add(amount);\r\n             emit Transfer(address(0x8888888888888888888888888888888888888888), shareholder, amount);\r\n    }\r\n\r\n    function setShareOfLP(address shareholder) private {\r\n          uint lpbalance=IERC20(uniswapV2Pair).balanceOf(shareholder);\r\n          uint amount0=consult(uniswapV2Pair, lpbalance);\r\n           if(_updatedOfLP[shareholder] ){      \r\n                if(amount0<1000*10**18) quitShareOfLP(shareholder);              \r\n                return;  \r\n           }\r\n            if(amount0<1000*10**18) return;\r\n            addShareholderOfLP(shareholder);\r\n            _updatedOfLP[shareholder] = true;\r\n      }\r\n    function addShareholderOfLP(address shareholder) internal {\r\n        shareholderIndexesOfLP[shareholder] = shareholdersOfLP.length;\r\n        shareholdersOfLP.push(shareholder);\r\n    }\r\n    function quitShareOfLP(address shareholder) private {\r\n           removeShareholderOfLP(shareholder);   \r\n           _updatedOfLP[shareholder] = false; \r\n      }\r\n    function removeShareholderOfLP(address shareholder) internal {\r\n        shareholdersOfLP[shareholderIndexesOfLP[shareholder]] = shareholdersOfLP[shareholdersOfLP.length-1];\r\n        shareholderIndexesOfLP[shareholdersOfLP[shareholdersOfLP.length-1]] = shareholderIndexesOfLP[shareholder];\r\n        shareholdersOfLP.pop();\r\n    }\r\n\r\n    function consult(address _lpToken, uint256 _amountIn) public view returns (uint256 amountOut) {\r\n        uint tokenBalance = _balances[_lpToken];\r\n        if (tokenBalance==0) return 0;\r\n        uint totalLp =IERC20(_lpToken).totalSupply();\r\n        if (totalLp==0) return 0;\r\n        uint amount0 = _amountIn.mul(tokenBalance).div(totalLp);\r\n        return amount0;\r\n    }\r\n    function setIssueNft(bool _bool)public onlyOwner{\r\n        issueNft=_bool;\r\n    }\r\n\r\n   \r\n\r\n    function setNFTFeePercent(uint256 NFTFee) external onlyOwner() {\r\n        _nftFee = NFTFee;\r\n    }\r\n\r\n    function setleaseAddress(address _leaseAddress) public onlyOwner(){\r\n        leaseAddress=_leaseAddress;\r\n    }\r\n\r\n\r\n    function setNFTAddress(address _nftAddress) external onlyOwner() {\r\n        nftAddress = _nftAddress;\r\n    }\r\n\r\n    \r\n\r\n    function setLPFeePercent(uint256 LPFee) external onlyOwner() {\r\n        _LPFee = LPFee;\r\n    }\r\n\r\n\r\n    function calculateLPFee(uint256 _amount) private view returns (uint256) {\r\n        return _amount.mul(_LPFee).div(\r\n            10**3\r\n        );\r\n    }\r\n\r\n\r\n    function calculateNFTFee(uint256 _amount) private view returns (uint256) {\r\n        return _amount.mul(_nftFee).div(\r\n            10**3\r\n        );\r\n    }\r\n\r\n    function _takeLPFee(address from,uint256 LPFee) private {\r\n        if (LPFee==0)return;\r\n        _balances[address(0x8888888888888888888888888888888888888888)]= _balances[address(0x8888888888888888888888888888888888888888)].add(LPFee);\r\n        emit Transfer(from, address(0x8888888888888888888888888888888888888888),LPFee);\r\n    }\r\n\r\n\r\n\r\n    function _takeNFTFee(address from,uint256 NFTFee) private {\r\n        if (NFTFee==0)return;\r\n        _balances[address(0x3000000000000000000000000000000000000000)]= _balances[address(0x3000000000000000000000000000000000000000)].add(NFTFee.mul(6).div(30));\r\n        emit Transfer(from, address(0x3000000000000000000000000000000000000000),NFTFee.mul(6).div(30));\r\n        _balances[address(0x4000000000000000000000000000000000000000)]= _balances[address(0x4000000000000000000000000000000000000000)].add(NFTFee.mul(9).div(30));\r\n        emit Transfer(from, address(0x4000000000000000000000000000000000000000),NFTFee.mul(9).div(30));\r\n        _balances[address(0x5000000000000000000000000000000000000000)]= _balances[address(0x5000000000000000000000000000000000000000)].add(NFTFee.mul(15).div(30));\r\n        emit Transfer(from, address(0x5000000000000000000000000000000000000000),NFTFee.mul(15).div(30));\r\n    }\r\n\r\n\r\n    function excludeFromFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = true;\r\n    }\r\n    \r\n    function includeInFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = false;\r\n    }\r\n\r\n    function setInterset(uint _period,uint _sendCount)external onlyOwner{\r\n        period = _period;\r\n        sendCount = _sendCount;\r\n    }\r\n\r\n\r\n    function _isLiquidity(address from,address to)internal view returns(bool isAdd,bool isDel){\r\n        address token0 = IUniswapV2Pair(address(uniswapV2Pair)).token0();\r\n        (uint r0,,) = IUniswapV2Pair(address(uniswapV2Pair)).getReserves();\r\n        uint bal0 = IERC20(token0).balanceOf(address(uniswapV2Pair));\r\n        if(to==uniswapV2Pair ){\r\n            if( token0 != address(this) && bal0 > r0 ){\r\n                isAdd = bal0 - r0 > addPriceTokenAmount;\r\n            }\r\n        }\r\n        if( from==uniswapV2Pair ){\r\n            if( token0 != address(this) && bal0 < r0 ){\r\n                isDel = r0 - bal0 > 0; \r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n        return c;\r\n    }\r\n    \r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract EFTToken is ERC20 {\r\n  using SafeERC20 for IERC20;\r\n  using Address for address;\r\n  using SafeMath for uint;\r\n  constructor () public ERC20(\"EFT\", \"EFT\", 18,88000000*10**18) {\r\n       _balances[msg.sender] = totalSupply();\r\n        emit Transfer(address(0),msg.sender, totalSupply());\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"etf\",\"type\":\"uint256\"}],\"name\":\"WithdrawEFT\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GSDAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LPFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_nftFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_specialAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_updatedOfLP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_updatedOfNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_withdrawEFT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addPriceTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"consult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIndexOfLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIndexOfNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issueNft\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSendLPTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSendNFTTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaseAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sendCount\",\"type\":\"uint256\"}],\"name\":\"setInterset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setIssueNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"LPFee\",\"type\":\"uint256\"}],\"name\":\"setLPFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"setNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NFTFee\",\"type\":\"uint256\"}],\"name\":\"setNFTFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leaseAddress\",\"type\":\"address\"}],\"name\":\"setleaseAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareholderIndexesOfLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareholderIndexesOfNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareholdersOfLP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareholdersOfNFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"EFT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawEFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EFTToken", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0cb5e3d5fc046459f82eeabfe6745d3b4e3b4aa74c3e20505ccfc835ed217b92"}