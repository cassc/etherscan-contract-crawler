{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/tokens/dividendToken/dividendToken/DividendToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nlibrary SafeMath {\\n    function tryAdd(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function trySub(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function tryMul(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function tryDiv(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function tryMod(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\nlibrary SafeMathInt {\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a * b;\\n\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\n        require((b == 0) || (c / b == a));\\n        return c;\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != -1 || a != MIN_INT256);\\n\\n        return a / b;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\n        return c;\\n    }\\n\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\n        return c;\\n    }\\n\\n    function abs(int256 a) internal pure returns (int256) {\\n        require(a != MIN_INT256);\\n        return a < 0 ? -a : a;\\n    }\\n\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\n        require(a >= 0);\\n        return uint256(a);\\n    }\\n}\\n\\nlibrary SafeMathUint {\\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\\n        int256 b = int256(a);\\n        require(b >= 0);\\n        return b;\\n    }\\n}\\n\\nabstract contract Initializable {\\n    bool private _initialized;\\n\\n    bool private _initializing;\\n\\n    modifier initializer() {\\n        require(\\n            _initializing || !_initialized,\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {}\\n\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\\ninterface IERC20Upgradeable {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\ncontract ERC20Upgradeable is\\n    Initializable,\\n    ContextUpgradeable,\\n    IERC20Upgradeable,\\n    IERC20MetadataUpgradeable\\n{\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    function __ERC20_init(\\n        string memory name_,\\n        string memory symbol_\\n    ) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(\\n        string memory name_,\\n        string memory symbol_\\n    ) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(\\n        address account\\n    ) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(\\n            currentAllowance >= amount,\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\n        );\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    ) public virtual returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    ) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(\\n            currentAllowance >= subtractedValue,\\n            \\\"ERC20: decreased allowance below zero\\\"\\n        );\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(\\n            senderBalance >= amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    uint256[45] private __gap;\\n}\\n\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\\ninterface DividendPayingTokenInterface {\\n    function dividendOf(address _owner) external view returns (uint256);\\n\\n    function withdrawDividend() external;\\n\\n    event DividendsDistributed(address indexed from, uint256 weiAmount);\\n\\n    event DividendWithdrawn(address indexed to, uint256 weiAmount);\\n}\\n\\ninterface DividendPayingTokenOptionalInterface {\\n    function withdrawableDividendOf(\\n        address _owner\\n    ) external view returns (uint256);\\n\\n    function withdrawnDividendOf(\\n        address _owner\\n    ) external view returns (uint256);\\n\\n    function accumulativeDividendOf(\\n        address _owner\\n    ) external view returns (uint256);\\n}\\n\\ncontract DividendPayingToken is\\n    ERC20Upgradeable,\\n    OwnableUpgradeable,\\n    DividendPayingTokenInterface,\\n    DividendPayingTokenOptionalInterface\\n{\\n    using SafeMath for uint256;\\n    using SafeMathUint for uint256;\\n    using SafeMathInt for int256;\\n\\n    address public rewardToken;\\n\\n    uint256 internal constant magnitude = 2 ** 128;\\n\\n    uint256 internal magnifiedDividendPerShare;\\n\\n    mapping(address => int256) internal magnifiedDividendCorrections;\\n    mapping(address => uint256) internal withdrawnDividends;\\n\\n    uint256 public totalDividendsDistributed;\\n\\n    function __DividendPayingToken_init(\\n        address _rewardToken,\\n        string memory _name,\\n        string memory _symbol\\n    ) internal initializer {\\n        __Ownable_init();\\n        __ERC20_init(_name, _symbol);\\n        rewardToken = _rewardToken;\\n    }\\n\\n    function distributeCAKEDividends(uint256 amount) public onlyOwner {\\n        require(totalSupply() > 0);\\n\\n        if (amount > 0) {\\n            magnifiedDividendPerShare = magnifiedDividendPerShare.add(\\n                (amount).mul(magnitude) / totalSupply()\\n            );\\n            emit DividendsDistributed(msg.sender, amount);\\n\\n            totalDividendsDistributed = totalDividendsDistributed.add(amount);\\n        }\\n    }\\n\\n    function withdrawDividend() public virtual override {\\n        _withdrawDividendOfUser(payable(msg.sender));\\n    }\\n\\n    function _withdrawDividendOfUser(\\n        address payable user\\n    ) internal returns (uint256) {\\n        uint256 _withdrawableDividend = withdrawableDividendOf(user);\\n        if (_withdrawableDividend > 0) {\\n            withdrawnDividends[user] = withdrawnDividends[user].add(\\n                _withdrawableDividend\\n            );\\n            emit DividendWithdrawn(user, _withdrawableDividend);\\n            bool success = IERC20(rewardToken).transfer(\\n                user,\\n                _withdrawableDividend\\n            );\\n\\n            if (!success) {\\n                withdrawnDividends[user] = withdrawnDividends[user].sub(\\n                    _withdrawableDividend\\n                );\\n                return 0;\\n            }\\n\\n            return _withdrawableDividend;\\n        }\\n\\n        return 0;\\n    }\\n\\n    function dividendOf(address _owner) public view override returns (uint256) {\\n        return withdrawableDividendOf(_owner);\\n    }\\n\\n    function withdrawableDividendOf(\\n        address _owner\\n    ) public view override returns (uint256) {\\n        return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\\n    }\\n\\n    function withdrawnDividendOf(\\n        address _owner\\n    ) public view override returns (uint256) {\\n        return withdrawnDividends[_owner];\\n    }\\n\\n    function accumulativeDividendOf(\\n        address _owner\\n    ) public view override returns (uint256) {\\n        return\\n            magnifiedDividendPerShare\\n                .mul(balanceOf(_owner))\\n                .toInt256Safe()\\n                .add(magnifiedDividendCorrections[_owner])\\n                .toUint256Safe() / magnitude;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal virtual override {\\n        require(false);\\n\\n        int256 _magCorrection = magnifiedDividendPerShare\\n            .mul(value)\\n            .toInt256Safe();\\n        magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from]\\n            .add(_magCorrection);\\n        magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(\\n            _magCorrection\\n        );\\n    }\\n\\n    function _mint(address account, uint256 value) internal override {\\n        super._mint(account, value);\\n\\n        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[\\n            account\\n        ].sub((magnifiedDividendPerShare.mul(value)).toInt256Safe());\\n    }\\n\\n    function _burn(address account, uint256 value) internal override {\\n        super._burn(account, value);\\n\\n        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[\\n            account\\n        ].add((magnifiedDividendPerShare.mul(value)).toInt256Safe());\\n    }\\n\\n    function _setBalance(address account, uint256 newBalance) internal {\\n        uint256 currentBalance = balanceOf(account);\\n\\n        if (newBalance > currentBalance) {\\n            uint256 mintAmount = newBalance.sub(currentBalance);\\n            _mint(account, mintAmount);\\n        } else if (newBalance < currentBalance) {\\n            uint256 burnAmount = currentBalance.sub(newBalance);\\n            _burn(account, burnAmount);\\n        }\\n    }\\n}\\n\\nlibrary IterableMapping {\\n    struct Map {\\n        address[] keys;\\n        mapping(address => uint256) values;\\n        mapping(address => uint256) indexOf;\\n        mapping(address => bool) inserted;\\n    }\\n\\n    function get(Map storage map, address key) public view returns (uint256) {\\n        return map.values[key];\\n    }\\n\\n    function getIndexOfKey(\\n        Map storage map,\\n        address key\\n    ) public view returns (int256) {\\n        if (!map.inserted[key]) {\\n            return -1;\\n        }\\n        return int256(map.indexOf[key]);\\n    }\\n\\n    function getKeyAtIndex(\\n        Map storage map,\\n        uint256 index\\n    ) public view returns (address) {\\n        return map.keys[index];\\n    }\\n\\n    function size(Map storage map) public view returns (uint256) {\\n        return map.keys.length;\\n    }\\n\\n    function set(Map storage map, address key, uint256 val) public {\\n        if (map.inserted[key]) {\\n            map.values[key] = val;\\n        } else {\\n            map.inserted[key] = true;\\n            map.values[key] = val;\\n            map.indexOf[key] = map.keys.length;\\n            map.keys.push(key);\\n        }\\n    }\\n\\n    function remove(Map storage map, address key) public {\\n        if (!map.inserted[key]) {\\n            return;\\n        }\\n\\n        delete map.inserted[key];\\n        delete map.values[key];\\n\\n        uint256 index = map.indexOf[key];\\n        uint256 lastIndex = map.keys.length - 1;\\n        address lastKey = map.keys[lastIndex];\\n\\n        map.indexOf[lastKey] = index;\\n        delete map.indexOf[key];\\n\\n        map.keys[index] = lastKey;\\n        map.keys.pop();\\n    }\\n}\\n\\ncontract DividendTracker is OwnableUpgradeable, DividendPayingToken {\\n    using SafeMath for uint256;\\n    using SafeMathInt for int256;\\n    using IterableMapping for IterableMapping.Map;\\n\\n    IterableMapping.Map private tokenHoldersMap;\\n    uint256 public lastProcessedIndex;\\n\\n    mapping(address => bool) public excludedFromDividends;\\n\\n    mapping(address => uint256) public lastClaimTimes;\\n\\n    uint256 public claimWait;\\n    uint256 public minimumTokenBalanceForDividends;\\n\\n    event ExcludeFromDividends(address indexed account);\\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n\\n    event Claim(\\n        address indexed account,\\n        uint256 amount,\\n        bool indexed automatic\\n    );\\n\\n    function initialize(\\n        address rewardToken_,\\n        uint256 minimumTokenBalanceForDividends_\\n    ) external initializer {\\n        DividendPayingToken.__DividendPayingToken_init(\\n            rewardToken_,\\n            \\\"DividendTracker\\\",\\n            \\\"DividendTracker\\\"\\n        );\\n        claimWait = 3600;\\n        minimumTokenBalanceForDividends = minimumTokenBalanceForDividends_;\\n    }\\n\\n    function _transfer(address, address, uint256) internal pure override {\\n        require(false, \\\"DividendTracker transfers are not allowed\\\");\\n    }\\n\\n    function withdrawDividend() public pure override {\\n        require(false, \\\"DividendTracker withdrawDividend is disabled.\\\");\\n    }\\n\\n    function excludeFromDividends(address account) external onlyOwner {\\n        require(!excludedFromDividends[account]);\\n        excludedFromDividends[account] = true;\\n\\n        _setBalance(account, 0);\\n        tokenHoldersMap.remove(account);\\n\\n        emit ExcludeFromDividends(account);\\n    }\\n\\n    function isExcludedFromDividends(\\n        address account\\n    ) public view returns (bool) {\\n        return excludedFromDividends[account];\\n    }\\n\\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\\n        require(\\n            newClaimWait >= 3600 && newClaimWait <= 86400,\\n            \\\"ClaimWait must be between 1 to 24 hours\\\"\\n        );\\n        require(\\n            newClaimWait != claimWait,\\n            \\\"Cannot update newClaimWait to the same value\\\"\\n        );\\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\\n        claimWait = newClaimWait;\\n    }\\n\\n    function updateMinimumTokenBalanceForDividends(\\n        uint256 amount\\n    ) external onlyOwner {\\n        minimumTokenBalanceForDividends = amount;\\n    }\\n\\n    function getLastProcessedIndex() external view returns (uint256) {\\n        return lastProcessedIndex;\\n    }\\n\\n    function getNumberOfTokenHolders() external view returns (uint256) {\\n        return tokenHoldersMap.keys.length;\\n    }\\n\\n    function getAccount(\\n        address _account\\n    )\\n        public\\n        view\\n        returns (\\n            address account,\\n            int256 index,\\n            int256 iterationsUntilProcessed,\\n            uint256 withdrawableDividends,\\n            uint256 totalDividends,\\n            uint256 lastClaimTime,\\n            uint256 nextClaimTime,\\n            uint256 secondsUntilAutoClaimAvailable\\n        )\\n    {\\n        account = _account;\\n\\n        index = tokenHoldersMap.getIndexOfKey(account);\\n\\n        iterationsUntilProcessed = -1;\\n\\n        if (index >= 0) {\\n            if (uint256(index) > lastProcessedIndex) {\\n                iterationsUntilProcessed = index.sub(\\n                    int256(lastProcessedIndex)\\n                );\\n            } else {\\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >\\n                    lastProcessedIndex\\n                    ? tokenHoldersMap.keys.length.sub(lastProcessedIndex)\\n                    : 0;\\n\\n                iterationsUntilProcessed = index.add(\\n                    int256(processesUntilEndOfArray)\\n                );\\n            }\\n        }\\n\\n        withdrawableDividends = withdrawableDividendOf(account);\\n        totalDividends = accumulativeDividendOf(account);\\n\\n        lastClaimTime = lastClaimTimes[account];\\n\\n        nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;\\n\\n        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp\\n            ? nextClaimTime.sub(block.timestamp)\\n            : 0;\\n    }\\n\\n    function getAccountAtIndex(\\n        uint256 index\\n    )\\n        public\\n        view\\n        returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        if (index >= tokenHoldersMap.size()) {\\n            return (address(0), -1, -1, 0, 0, 0, 0, 0);\\n        }\\n\\n        address account = tokenHoldersMap.getKeyAtIndex(index);\\n\\n        return getAccount(account);\\n    }\\n\\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\n        if (lastClaimTime > block.timestamp) {\\n            return false;\\n        }\\n\\n        return block.timestamp.sub(lastClaimTime) >= claimWait;\\n    }\\n\\n    function setBalance(\\n        address payable account,\\n        uint256 newBalance\\n    ) external onlyOwner {\\n        if (excludedFromDividends[account]) {\\n            return;\\n        }\\n        if (newBalance >= minimumTokenBalanceForDividends) {\\n            _setBalance(account, newBalance);\\n            tokenHoldersMap.set(account, newBalance);\\n        } else {\\n            _setBalance(account, 0);\\n            tokenHoldersMap.remove(account);\\n        }\\n        processAccount(account, true);\\n    }\\n\\n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\\n        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\\n\\n        if (numberOfTokenHolders == 0) {\\n            return (0, 0, lastProcessedIndex);\\n        }\\n\\n        uint256 _lastProcessedIndex = lastProcessedIndex;\\n\\n        uint256 gasUsed = 0;\\n\\n        uint256 gasLeft = gasleft();\\n\\n        uint256 iterations = 0;\\n        uint256 claims = 0;\\n\\n        while (gasUsed < gas && iterations < numberOfTokenHolders) {\\n            _lastProcessedIndex++;\\n\\n            if (_lastProcessedIndex >= tokenHoldersMap.keys.length) {\\n                _lastProcessedIndex = 0;\\n            }\\n\\n            address account = tokenHoldersMap.keys[_lastProcessedIndex];\\n\\n            if (canAutoClaim(lastClaimTimes[account])) {\\n                if (processAccount(payable(account), true)) {\\n                    claims++;\\n                }\\n            }\\n\\n            iterations++;\\n\\n            uint256 newGasLeft = gasleft();\\n\\n            if (gasLeft > newGasLeft) {\\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\\n            }\\n\\n            gasLeft = newGasLeft;\\n        }\\n\\n        lastProcessedIndex = _lastProcessedIndex;\\n\\n        return (iterations, claims, lastProcessedIndex);\\n    }\\n\\n    function processAccount(\\n        address payable account,\\n        bool automatic\\n    ) public onlyOwner returns (bool) {\\n        uint256 amount = _withdrawDividendOfUser(account);\\n\\n        if (amount > 0) {\\n            lastClaimTimes[account] = block.timestamp;\\n            emit Claim(account, amount, automatic);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n    uint8 private _decimals;\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(\\n        address account\\n    ) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(\\n            currentAllowance >= amount,\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\n        );\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    ) public virtual returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    ) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(\\n            currentAllowance >= subtractedValue,\\n            \\\"ERC20: decreased allowance below zero\\\"\\n        );\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(\\n            senderBalance >= amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\nlibrary Clones {\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(\\n                ptr,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(\\n                add(ptr, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function WETC() external pure returns (address);\\n\\n    function WHT() external pure returns (address);\\n\\n    function WROSE() external pure returns (address);\\n\\n    function WAVAX() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function addLiquidityAVAX(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function addLiquidityETC(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function addLiquidityROSE(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactTokensForETCSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForROSESupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\nabstract contract BaseToken {\\n    event TokenCreated(\\n        address indexed owner,\\n        address indexed token,\\n        string tokenType,\\n        uint256 version\\n    );\\n}\\n\\nabstract contract CoinscopeBuyback {\\n    address public constant COINSCOPE_ADDRESS =\\n        0xD41C4805A9A3128f9F7A7074Da25965371Ba50d5;\\n\\n    IUniswapV2Router02 public constant BSC_PANCAKE_ROUTER =\\n        IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n\\n    event CoinscopeBuybackRejectedSwapBalance();\\n    event CoinscopeBuybackApproved(\\n        uint256 amountToken,\\n        uint256 amountETH,\\n        uint256 liquidity,\\n        uint256 ownerAmountReceiveed\\n    );\\n    event CoinscopeBuybackRejectedLiquidity();\\n    event CoinscopeBuybackRejectedSwap();\\n\\n    function coinscopeBuyback(\\n        address recepient,\\n        address platformFeeReceiver,\\n        uint8 feeShare\\n    ) internal {\\n        if (block.chainid != 56 || address(this).balance == 0 || feeShare > 100)\\n            return;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = BSC_PANCAKE_ROUTER.WETH();\\n        path[1] = COINSCOPE_ADDRESS;\\n\\n        uint256 swapAmount = (address(this).balance * feeShare) / 100;\\n\\n        try\\n            BSC_PANCAKE_ROUTER.swapExactETHForTokens{value: swapAmount}(\\n                0,\\n                path,\\n                address(this),\\n                block.timestamp\\n            )\\n        returns (uint256[] memory amounts) {\\n            uint256 coinscopeBalance = amounts[amounts.length - 1];\\n\\n            if (coinscopeBalance == 0) {\\n                emit CoinscopeBuybackRejectedSwapBalance();\\n                return;\\n            }\\n\\n            uint256 ownerTokens = coinscopeBalance / 100;\\n\\n            IERC20 coinscopeToken = IERC20(COINSCOPE_ADDRESS);\\n\\n            require(\\n                coinscopeToken.transfer(recepient, ownerTokens),\\n                \\\"Coinscope tokens should transferred to owner\\\"\\n            );\\n\\n            coinscopeBalance = coinscopeToken.balanceOf(address(this));\\n\\n            require(\\n                coinscopeToken.approve(\\n                    address(BSC_PANCAKE_ROUTER),\\n                    coinscopeBalance\\n                ),\\n                \\\"Coinscope allowance should be approved\\\"\\n            );\\n\\n            try\\n                BSC_PANCAKE_ROUTER.addLiquidityETH{\\n                    value: address(this).balance\\n                }(\\n                    COINSCOPE_ADDRESS,\\n                    coinscopeBalance,\\n                    0,\\n                    0,\\n                    platformFeeReceiver,\\n                    block.timestamp\\n                )\\n            returns (\\n                uint256 amountToken,\\n                uint256 amountETH,\\n                uint256 liquidity\\n            ) {\\n                emit CoinscopeBuybackApproved(\\n                    amountToken,\\n                    amountETH,\\n                    liquidity,\\n                    ownerTokens\\n                );\\n            } catch {\\n                emit CoinscopeBuybackRejectedLiquidity();\\n            }\\n        } catch {\\n            emit CoinscopeBuybackRejectedSwap();\\n        }\\n    }\\n}\\n\\ncontract DividendToken is ERC20, Ownable, BaseToken, CoinscopeBuyback {\\n    uint256 public constant VERSION = 3;\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public uniswapV2Pair;\\n\\n    bool private swapping;\\n\\n    DividendTracker public dividendTracker;\\n\\n    address public rewardToken;\\n\\n    uint256 public swapTokensAtAmount;\\n\\n    uint256 public tokenRewardsFee;\\n    uint256 public liquidityFee;\\n    uint256 public marketingFee;\\n    uint256 public totalFees;\\n\\n    address public marketingWalletAddress;\\n\\n    uint256 public gasForProcessing;\\n\\n    mapping(address => bool) private _isExcludedFromFees;\\n\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n\\n    event ExcludeFromFees(address indexed account);\\n    event ExcludeMultipleAccountsFromFees(address[] accounts);\\n\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n\\n    event GasForProcessingUpdated(\\n        uint256 indexed newValue,\\n        uint256 indexed oldValue\\n    );\\n\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n\\n    event SendDividends(uint256 amount);\\n\\n    event ProcessedDividendTracker(\\n        uint256 iterations,\\n        uint256 claims,\\n        uint256 lastProcessedIndex,\\n        bool indexed automatic,\\n        uint256 gas,\\n        address indexed processor\\n    );\\n\\n    event swapedETHForTokens(uint256 eth, uint256 tokens, address receiver);\\n\\n    event addLiquidityETH(uint256 eth, uint256 tokens, address receiver);\\n\\n    event transferTokens(uint256 _value, address receiver);\\n\\n    event rejected(string reason);\\n\\n    event SwapTokensAtAmountChanged(uint256 amount);\\n    event UpdatedMarketingWallet(address account);\\n    event UpdatedRewardsFee(uint256 amount);\\n    event UpdatedLiquidityFee(uint256 amount);\\n    event UpdatedMarketingFee(uint256 amount);\\n    event SwapTokensForRewardFailed(uint256 amount);\\n    event SwapTokensForEth(uint256 amount);\\n\\n    modifier lockTheSwap() {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        uint8 decimal_,\\n        address dividendTrackerAddress_,\\n        address[3] memory addrs,\\n        uint256[3] memory feeSettings,\\n        uint256 minimumTokenBalanceForDividends_,\\n        address feeReceiver,\\n        uint8 feeShare\\n    ) payable ERC20(name_, symbol_, decimal_) {\\n        rewardToken = addrs[0];\\n        marketingWalletAddress = addrs[2];\\n        uniswapV2Router = IUniswapV2Router02(addrs[1]);\\n\\n        address nativeCurrency = getNativeCurrency();\\n\\n        require(\\n            nativeCurrency != rewardToken,\\n            \\\"The reward token cannot be the native token\\\"\\n        );\\n\\n        IUniswapV2Factory factory = IUniswapV2Factory(\\n            uniswapV2Router.factory()\\n        );\\n\\n        require(\\n            factory.getPair(nativeCurrency, rewardToken) != address(0x0),\\n            \\\"reward token does not have a pair with the native currency\\\"\\n        );\\n\\n        tokenRewardsFee = feeSettings[0];\\n        liquidityFee = feeSettings[1];\\n        marketingFee = feeSettings[2];\\n\\n        updateFees();\\n\\n        swapTokensAtAmount = totalSupply_ / 1000;\\n        gasForProcessing = 300000;\\n\\n        dividendTracker = DividendTracker(\\n            payable(Clones.clone(dividendTrackerAddress_))\\n        );\\n        dividendTracker.initialize(\\n            rewardToken,\\n            minimumTokenBalanceForDividends_\\n        );\\n\\n        _setAutomatedMarketMakerPair(\\n            factory.createPair(address(this), nativeCurrency),\\n            true\\n        );\\n\\n        dividendTracker.excludeFromDividends(address(dividendTracker));\\n        dividendTracker.excludeFromDividends(address(this));\\n        dividendTracker.excludeFromDividends(owner());\\n        dividendTracker.excludeFromDividends(address(0xdead));\\n        dividendTracker.excludeFromDividends(address(uniswapV2Router));\\n\\n        _isExcludedFromFees[owner()] = true;\\n        _isExcludedFromFees[marketingWalletAddress] = true;\\n        _isExcludedFromFees[address(this)] = true;\\n\\n        _mint(owner(), totalSupply_);\\n\\n        emit TokenCreated(owner(), address(this), \\\"dividendTracker\\\", VERSION);\\n\\n        if (feeReceiver == address(0x0)) return;\\n\\n        coinscopeBuyback(owner(), feeReceiver, feeShare);\\n        payable(feeReceiver).transfer(address(this).balance);\\n    }\\n\\n    function getNativeCurrency() internal view returns (address) {\\n        if (block.chainid == 61) {\\n            //etc\\n            return uniswapV2Router.WETC();\\n        } else if (block.chainid == 128) {\\n            //heco chain\\n            return uniswapV2Router.WHT();\\n        } else if (block.chainid == 42262) {\\n            //oasis\\n            return uniswapV2Router.WROSE();\\n        } else if (block.chainid == 43114 || block.chainid == 43113) {\\n            //avalance\\n            return uniswapV2Router.WAVAX();\\n        } else {\\n            return uniswapV2Router.WETH();\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {\\n        require(\\n            amount > totalSupply() / 10 ** 6 &&\\n                amount <= totalSupply() / 10 ** 4,\\n            \\\"Amount must be between 0.001% - 0.1 of total supply\\\"\\n        );\\n        swapTokensAtAmount = amount;\\n\\n        emit SwapTokensAtAmountChanged(amount);\\n    }\\n\\n    function excludeFromFees(address account) external onlyOwner {\\n        require(!_isExcludedFromFees[account], \\\"Account is already excluded\\\");\\n\\n        _isExcludedFromFees[account] = true;\\n\\n        emit ExcludeFromFees(account);\\n    }\\n\\n    function excludeMultipleAccountsFromFees(\\n        address[] calldata accounts\\n    ) external onlyOwner {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            _isExcludedFromFees[accounts[i]] = true;\\n        }\\n\\n        emit ExcludeMultipleAccountsFromFees(accounts);\\n    }\\n\\n    function setMarketingWallet(address payable wallet) external onlyOwner {\\n        require(wallet != address(0), \\\"Can not be address(0).\\\");\\n\\n        marketingWalletAddress = wallet;\\n\\n        emit UpdatedMarketingWallet(wallet);\\n    }\\n\\n    function setTokenRewardsFee(uint256 value) external onlyOwner {\\n        tokenRewardsFee = value;\\n\\n        updateFees();\\n\\n        emit UpdatedRewardsFee(value);\\n    }\\n\\n    function setLiquidityFee(uint256 value) external onlyOwner {\\n        liquidityFee = value;\\n\\n        updateFees();\\n\\n        emit UpdatedLiquidityFee(value);\\n    }\\n\\n    function setMarketingFee(uint256 value) external onlyOwner {\\n        marketingFee = value;\\n\\n        updateFees();\\n\\n        emit UpdatedMarketingFee(value);\\n    }\\n\\n    function updateFees() internal {\\n        totalFees = tokenRewardsFee + liquidityFee + marketingFee;\\n\\n        require(totalFees <= 20, \\\"Total fees can not be over 20%.\\\");\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        require(pair != address(0x0), \\\"cannot mutate the address\\\");\\n        require(pair != uniswapV2Pair, \\\"cannot mutate the main pair address\\\");\\n        require(\\n            automatedMarketMakerPairs[pair] != value,\\n            \\\"Pair is already set to this address.\\\"\\n        );\\n\\n        automatedMarketMakerPairs[pair] = value;\\n\\n        if (value) {\\n            dividendTracker.excludeFromDividends(pair);\\n        }\\n\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function updateGasForProcessing(uint256 newValue) public onlyOwner {\\n        require(\\n            newValue >= 200000 && newValue <= 500000,\\n            \\\"GasForProcessing must be between 200,000 and 500,000.\\\"\\n        );\\n        require(\\n            newValue != gasForProcessing,\\n            \\\"Cannot update gasForProcessing to same value.\\\"\\n        );\\n\\n        emit GasForProcessingUpdated(newValue, gasForProcessing);\\n\\n        gasForProcessing = newValue;\\n    }\\n\\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\\n        dividendTracker.updateClaimWait(claimWait);\\n    }\\n\\n    function getClaimWait() external view returns (uint256) {\\n        return dividendTracker.claimWait();\\n    }\\n\\n    function updateMinimumTokenBalanceForDividends(\\n        uint256 amount\\n    ) external onlyOwner {\\n        dividendTracker.updateMinimumTokenBalanceForDividends(amount);\\n    }\\n\\n    function getMinimumTokenBalanceForDividends()\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return dividendTracker.minimumTokenBalanceForDividends();\\n    }\\n\\n    function getTotalDividendsDistributed() external view returns (uint256) {\\n        return dividendTracker.totalDividendsDistributed();\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function withdrawableDividendOf(\\n        address account\\n    ) public view returns (uint256) {\\n        return dividendTracker.withdrawableDividendOf(account);\\n    }\\n\\n    function dividendTokenBalanceOf(\\n        address account\\n    ) public view returns (uint256) {\\n        return dividendTracker.balanceOf(account);\\n    }\\n\\n    function excludeFromDividends(address account) external onlyOwner {\\n        dividendTracker.excludeFromDividends(account);\\n    }\\n\\n    function isExcludedFromDividends(\\n        address account\\n    ) public view returns (bool) {\\n        return dividendTracker.isExcludedFromDividends(account);\\n    }\\n\\n    function getAccountDividendsInfo(\\n        address account\\n    )\\n        external\\n        view\\n        returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return dividendTracker.getAccount(account);\\n    }\\n\\n    function getAccountDividendsInfoAtIndex(\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return dividendTracker.getAccountAtIndex(index);\\n    }\\n\\n    function processDividendTracker(uint256 gas) external {\\n        (\\n            uint256 iterations,\\n            uint256 claims,\\n            uint256 lastProcessedIndex\\n        ) = dividendTracker.process(gas);\\n        emit ProcessedDividendTracker(\\n            iterations,\\n            claims,\\n            lastProcessedIndex,\\n            false,\\n            gas,\\n            tx.origin\\n        );\\n    }\\n\\n    function claim() external {\\n        dividendTracker.processAccount(payable(msg.sender), false);\\n    }\\n\\n    function getLastProcessedIndex() external view returns (uint256) {\\n        return dividendTracker.getLastProcessedIndex();\\n    }\\n\\n    function getNumberOfDividendTokenHolders() external view returns (uint256) {\\n        return dividendTracker.getNumberOfTokenHolders();\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(from != address(0), \\\"Can not transfer from the zero address\\\");\\n        require(to != address(0), \\\"Can not transfer to the zero address\\\");\\n\\n        if (amount == 0) {\\n            super._transfer(from, to, 0);\\n            return;\\n        }\\n\\n        bool localSwapping = swapping;\\n        uint256 localTotalFees = totalFees;\\n\\n        bool canSwap = balanceOf(address(this)) >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap &&\\n            !localSwapping &&\\n            !automatedMarketMakerPairs[from] &&\\n            from != owner() &&\\n            to != owner() &&\\n            localTotalFees > 0\\n        ) {\\n            swap();\\n        }\\n\\n        bool takeFee = !localSwapping &&\\n            !_isExcludedFromFees[from] &&\\n            !_isExcludedFromFees[to] &&\\n            localTotalFees > 0;\\n\\n        if (takeFee) {\\n            uint256 fees = (amount * localTotalFees) / 100;\\n\\n            amount = amount - fees;\\n\\n            super._transfer(from, address(this), fees);\\n        }\\n\\n        super._transfer(from, to, amount);\\n\\n        try\\n            dividendTracker.setBalance(payable(from), balanceOf(from))\\n        {} catch {}\\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\n\\n        if (localSwapping) return;\\n\\n        try dividendTracker.process(gasForProcessing) returns (\\n            uint256 iterations,\\n            uint256 claims,\\n            uint256 lastProcessedIndex\\n        ) {\\n            emit ProcessedDividendTracker(\\n                iterations,\\n                claims,\\n                lastProcessedIndex,\\n                true,\\n                gasForProcessing,\\n                tx.origin\\n            );\\n        } catch {}\\n    }\\n\\n    function swap() private lockTheSwap {\\n        uint256 amount = swapTokensAtAmount;\\n\\n        uint256 localTotalFees = totalFees;\\n\\n        uint256 swapTokens = (amount * liquidityFee) / localTotalFees;\\n\\n        if (swapTokens > 0) swapAndLiquify(swapTokens);\\n\\n        uint256 marketingTokens = (amount * marketingFee) / localTotalFees;\\n\\n        uint256 dividendTokens = amount - marketingTokens - swapTokens;\\n\\n        uint256 totalTokens = marketingTokens + dividendTokens;\\n\\n        uint256 swappedAmount = swapTokensForReward(totalTokens);\\n\\n        uint256 marketingShare = (swappedAmount * marketingTokens) /\\n            totalTokens;\\n\\n        if (marketingShare > 0)\\n            IERC20(rewardToken).transfer(\\n                marketingWalletAddress,\\n                marketingShare\\n            );\\n\\n        swapAndSendDividends();\\n    }\\n\\n    function swapAndLiquify(uint256 tokens) private {\\n        uint256 half = tokens / 2;\\n        uint256 otherHalf = tokens - half;\\n\\n        uint256 initialBalance = address(this).balance;\\n\\n        swapTokensForEth(half);\\n\\n        uint256 newBalance = address(this).balance - initialBalance;\\n\\n        if (newBalance == 0) return;\\n\\n        addLiquidity(otherHalf, newBalance);\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = getNativeCurrency();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        if (block.chainid == 61) {\\n            //etc\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETCSupportingFeeOnTransferTokens(\\n                        tokenAmount,\\n                        0,\\n                        path,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {\\n                emit SwapTokensForEth(tokenAmount);\\n            }\\n        } else if (block.chainid == 42262) {\\n            //oasis\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForROSESupportingFeeOnTransferTokens(\\n                        tokenAmount,\\n                        0,\\n                        path,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {\\n                emit SwapTokensForEth(tokenAmount);\\n            }\\n        } else if (block.chainid == 43114 || block.chainid == 43113) {\\n            //avalance\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\n                        tokenAmount,\\n                        0,\\n                        path,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {\\n                emit SwapTokensForEth(tokenAmount);\\n            }\\n        } else {\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        tokenAmount,\\n                        0,\\n                        path,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {\\n                emit SwapTokensForEth(tokenAmount);\\n            }\\n        }\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        if (block.chainid == 61) {\\n            uniswapV2Router.addLiquidityETC{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                0,\\n                0,\\n                address(0xdead),\\n                block.timestamp\\n            );\\n        } else if (block.chainid == 42262) {\\n            uniswapV2Router.addLiquidityROSE{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                0,\\n                0,\\n                address(0xdead),\\n                block.timestamp\\n            );\\n        } else if (block.chainid == 43114 || block.chainid == 43113) {\\n            uniswapV2Router.addLiquidityAVAX{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                0,\\n                0,\\n                address(0xdead),\\n                block.timestamp\\n            );\\n        } else {\\n            uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                0,\\n                0,\\n                address(0xdead),\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    function swapTokensForReward(\\n        uint256 tokenAmount\\n    ) private returns (uint256) {\\n        address[] memory path = new address[](3);\\n        path[0] = address(this);\\n        path[1] = getNativeCurrency();\\n        path[2] = rewardToken;\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        IERC20 localRewardToken = IERC20(rewardToken);\\n\\n        uint256 balance = localRewardToken.balanceOf(address(this));\\n\\n        try\\n            uniswapV2Router\\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n                    tokenAmount,\\n                    0,\\n                    path,\\n                    address(this),\\n                    block.timestamp\\n                )\\n        {\\n            return localRewardToken.balanceOf(address(this)) - balance;\\n        } catch {\\n            emit SwapTokensForRewardFailed(tokenAmount);\\n            return 0;\\n        }\\n    }\\n\\n    function swapAndSendDividends() private {\\n        IERC20 localRewardToken = IERC20(rewardToken);\\n\\n        uint256 dividends = localRewardToken.balanceOf(address(this));\\n\\n        bool success = localRewardToken.transfer(\\n            address(dividendTracker),\\n            dividends\\n        );\\n\\n        if (success) {\\n            dividendTracker.distributeCAKEDividends(dividends);\\n            emit SendDividends(dividends);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimal_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"dividendTrackerAddress_\",\"type\":\"address\"},{\"internalType\":\"address[3]\",\"name\":\"addrs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"feeSettings\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"minimumTokenBalanceForDividends_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"feeShare\",\"type\":\"uint8\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerAmountReceiveed\",\"type\":\"uint256\"}],\"name\":\"CoinscopeBuybackApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CoinscopeBuybackRejectedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CoinscopeBuybackRejectedSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CoinscopeBuybackRejectedSwapBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapTokensAtAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapTokensForEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapTokensForRewardFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UpdatedLiquidityFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMarketingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UpdatedMarketingWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UpdatedRewardsFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"addLiquidityETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"rejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"swapedETHForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"transferTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BSC_PANCAKE_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COINSCOPE_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAccountDividendsInfoAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumTokenBalanceForDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMarketingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setTokenRewardsFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimWait\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateMinimumTokenBalanceForDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DividendToken", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000033b2e3c9fd0803ce800000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000009795dcf2cfee83456bcd4801eeb7a7f9c7a7551b000000000000000000000000d41c4805a9a3128f9f7a7074da25965371ba50d500000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000004f5e3c8b92db6e10ee49b030e98473d654051aad00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000152d02c7e14af68000000000000000000000000000004f5e3c8b92db6e10ee49b030e98473d654051aad00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000004746573740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000047465737400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}