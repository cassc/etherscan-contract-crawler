{"SourceCode": "pragma solidity ^0.5.17;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n      c = a * b;\r\n      assert(c / a == b);\r\n      return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n      c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n    }\r\n}\r\n\r\ncontract TOKEN {\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function burnFrom(address account, uint256 amount) public;\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n      owner = address(0x201B8b73E2D5F03606081e48205bB97306BEbd65); //change on mainnet to multisig address on gnosis\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }\r\n}\r\n\r\ncontract Vault is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event onBackingRedeem(\r\n        address indexed customerAddress,\r\n        uint256 burntAmount,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event onTokenListing(\r\n        address indexed tokenAddress,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event onBackingDeposit(\r\n        address indexed tokenAddress,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    address[] public tokenList; //to help with iteration\r\n    mapping(address => TOKEN) private acceptedTokens;\r\n    \r\n    uint256 public leverage = 1;\r\n    \r\n    TOKEN pad;\r\n    \r\n    constructor() public {\r\n      pad = TOKEN(address(0xC0888d80EE0AbF84563168b3182650c0AdDEb6d5)); //Pad Address\r\n    }\r\n    \r\n    function() payable external {\r\n        revert();\r\n    }\r\n    \r\n    function checkAndTransferToken(address _tokenAddress, uint256 _amount) private {\r\n        require(acceptedTokens[_tokenAddress].transferFrom(msg.sender, address(this), _amount) == true, \"transfer must succeed\");\r\n    }\r\n    \r\n    function redeemBacking(uint256 _burnAmount) public returns (uint256) {\r\n        address payable _customerAddress = msg.sender;\r\n        uint256 _padSupply = getPadSupply();\r\n       \r\n        pad.burnFrom(_customerAddress, _burnAmount);\r\n        \r\n        for (uint i = 0; i<tokenList.length; i++) {\r\n            uint256 tokenBalance = TOKEN(tokenList[i]).balanceOf(address(this));\r\n            uint256 backingAmount = tokenBalance.mul(_burnAmount).mul(leverage).div(_padSupply);\r\n            acceptedTokens[tokenList[i]].transfer(_customerAddress, backingAmount);\r\n        }\r\n        \r\n        emit onBackingRedeem(_customerAddress, _burnAmount, now);\r\n        \r\n    }\r\n\r\n    function listToken(address _tokenAddress) onlyOwner external returns  (address [] memory) {\r\n        require(acceptedTokens[_tokenAddress] == TOKEN(address(0)), 'This token is already listed.');\r\n        acceptedTokens[_tokenAddress] = TOKEN(address(_tokenAddress));\r\n        tokenList.push(_tokenAddress);\r\n        return tokenList;\r\n    }\r\n    \r\n    //manipulating arrays is costly and this function is only present in case a wrong token address is listed as a mistake.\r\n    function delistToken(address _tokenAddress) onlyOwner external returns (address  [] memory) {\r\n        require(acceptedTokens[_tokenAddress] != TOKEN(address(0)), 'This token is not listed.');\r\n        acceptedTokens[_tokenAddress] = TOKEN(address(0));\r\n         for (uint i = 0; i<tokenList.length; i++) {\r\n            if(tokenList[i] == _tokenAddress) {\r\n                tokenList[i] = tokenList[tokenList.length-1]; //overrides the element we want to delete with the last one\r\n                delete tokenList[tokenList.length-1]; //deletes the last one\r\n                tokenList.length --;\r\n            }\r\n        }\r\n        return tokenList;\r\n    }\r\n    \r\n    function updateLeverage(uint256 _leverage) onlyOwner external returns (bool) {\r\n        require(_leverage >= 1 && _leverage <= 3, \"Invalid leverage value.\");\r\n        leverage = _leverage;\r\n        return true;\r\n    }\r\n    \r\n    //transfering any accepted token directly to the contract also works (but wont emit an event)\r\n    function addBacking(address _tokenAddress, uint256 _amount) public {\r\n        require(_amount > 0, \"must be a positive value\");\r\n        checkAndTransferToken(_tokenAddress, _amount);\r\n        emit onBackingDeposit(_tokenAddress, _amount, now);\r\n    }\r\n\r\n\r\n    function getPadSupply() public view returns (uint256) {\r\n        return pad.totalSupply();\r\n    }\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBackingDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burntAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBackingRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenListing\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addBacking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"delistToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPadSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"listToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_burnAmount\",\"type\":\"uint256\"}],\"name\":\"redeemBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_leverage\",\"type\":\"uint256\"}],\"name\":\"updateLeverage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Vault", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://1fe0dd02eadc734fb81a131cd1c6572168e1840d932b770b82953599bd22a4d5"}