{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface IERC20 {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external;\r\n\r\n    function transfer(address to, uint256 value) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract skybitAradena {\r\n    using SafeMath for uint256;\r\n    address payable public owner;\r\n    uint256[] public vestDuration = [0, 30 days, 60 days];\r\n    uint256[] public vestingClaim = [30, 35, 35]; // in percentage\r\n    address wBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n\r\n    enum Release {\r\n        NOT_SET,\r\n        FAILED,\r\n        RELEASED\r\n    }\r\n\r\n    IERC20 public tokenSell;\r\n    uint256 public perTokenBuy;\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n    uint256 public totalTokenSell;\r\n    uint256 public softCap;\r\n    uint256 public hardCap;\r\n    uint256 public maxBuy;\r\n    uint256 public minBuy;\r\n    uint256 public alreadyRaised;\r\n    Release public release;\r\n    uint256 public releaseTime;\r\n    IERC20 public activeCurrency;\r\n    bool public isWhitelist;\r\n    bool public isCheckSoftCap = true;\r\n    bool public isVesting = true;\r\n\r\n    struct UserInfo {\r\n        uint256 totalToken;\r\n        uint256 totalSpent;\r\n    }\r\n\r\n    enum Claims {\r\n        HALF,\r\n        FULL,\r\n        FAILED\r\n    }\r\n\r\n    mapping(address => UserInfo) public usersTokenBought; // userAddress => User Info\r\n    mapping(address => bool) public whitelistedAddress;\r\n    mapping(address => mapping(uint256 => bool)) public claimInPeriod; // userAddress => period => true/false\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    modifier withdrawCheck() {\r\n        require(getSoftFilled() == true, \"Can't withdraw\");\r\n        _;\r\n    }\r\n\r\n    event BUY(address Buyer, uint256 amount);\r\n    event CLAIM(address Buyer, Claims claim);\r\n    event RELEASE(Release released);\r\n    // Saat Release \r\n    // lempar BNB / Activecurrency ke LP berdasarkan router yang di pilih ( Pancake & Ape )\r\n    // Lock LP \r\n    // Withdraw LP\r\n\r\n    constructor(address payable _owner, address _activeCurrency) {\r\n        owner = _owner;\r\n        activeCurrency = IERC20(_activeCurrency);\r\n    }\r\n\r\n    // onlyOwner Function\r\n    function setEventPeriod(uint256 _startTime, uint256 _endTime)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(address(tokenSell) != address(0), \"Setup raised first\");\r\n        require(_startTime != 0, \"Cannot set 0 value\");\r\n        require(_endTime > _startTime, \"End time must be greater\");\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n    function setRaised(\r\n        address _tokenSale,\r\n        uint256 _perTokenBuy,\r\n        uint256 _softcap,\r\n        uint256 _hardcap,\r\n        uint256 _maxBuy,\r\n        uint256 _minBuy,\r\n        bool _isWhitelist,\r\n        bool _isCheckSoftCap,\r\n        bool _isVesting\r\n    ) external onlyOwner {\r\n        // require(startTime == 0, \"Raising period already start\");\r\n        require(_hardcap > _softcap, \"Hardcap must greater than softcap\");\r\n        tokenSell = IERC20(_tokenSale);\r\n        uint256 _totalTokenSale = _hardcap.mul(_perTokenBuy);\r\n        uint256 allowance = tokenSell.allowance(msg.sender, address(this));\r\n        uint256 balance = tokenSell.balanceOf(msg.sender);\r\n        //require(balance >= _totalTokenSale, \"Not enough tokens\");\r\n        require(allowance >= _totalTokenSale, \"Check the token allowance\");\r\n        perTokenBuy = _perTokenBuy; //4 \r\n        totalTokenSell = _totalTokenSale;\r\n        softCap = _softcap;\r\n        hardCap = _hardcap;\r\n        maxBuy = _maxBuy; // in in active currency\r\n        minBuy = _minBuy; // in in active currency\r\n        isWhitelist = _isWhitelist;\r\n        isVesting = _isVesting; // only set one time\r\n        isCheckSoftCap = _isCheckSoftCap; // only set one time\r\n        //tokenSell.transferFrom(msg.sender, address(this), _perTokenBuy.div(100).mul(75) ); \r\n    }\r\n\r\n    function setMinMaxBuy(uint256 _minBuy, uint _maxBuy) external onlyOwner {\r\n        require(_maxBuy > _minBuy, \"max buy less than min buy\");\r\n        minBuy = _minBuy;\r\n        maxBuy = _maxBuy;\r\n    }\r\n\r\n    function setIsWhitelist(bool _isWhitelist) external onlyOwner {\r\n        require(isWhitelist != _isWhitelist, \"cannot assign same value\");\r\n        isWhitelist = _isWhitelist;\r\n    }\r\n\r\n    function addWhitelised(\r\n        address[] memory whitelistAddresses,\r\n        bool[] memory values\r\n    ) external onlyOwner {\r\n        require(\r\n            whitelistAddresses.length == values.length,\r\n            \"provide same length\"\r\n        );\r\n        for (uint256 i = 0; i < whitelistAddresses.length; i++) {\r\n            whitelistedAddress[whitelistAddresses[i]] = values[i];\r\n        }\r\n    }\r\n\r\n    function setVestingPeriodAndClaim(\r\n        uint256[] memory _vests,\r\n        uint256[] memory _claims\r\n    ) external onlyOwner {\r\n        require(_vests.length == _claims.length, \"length must be same\");\r\n        require(block.timestamp < startTime, \"Raising period already started\");\r\n        uint total;\r\n        for (uint256 i = 0; i < _claims.length; i++) {\r\n            total += _claims[i];\r\n        }\r\n        require(total == 100, \"total claim must be 100\");\r\n\r\n        for (uint256 i = 0; i < _vests.length; i++) {\r\n            vestDuration[i] = _vests[i].mul(1 days);\r\n            vestingClaim[i] = _claims[i];\r\n        }\r\n    }\r\n\r\n    function setRelease(Release _release) external onlyOwner {\r\n        require(startTime != 0, \"Raise no start\");\r\n        require(release != _release, \"Can't setup same release\");\r\n        if (isCheckSoftCap) {\r\n            require(getSoftFilled(), \"Softcap not fullfiled\");\r\n        }\r\n        if (getHardFilled() == false) {\r\n            require(block.timestamp > endTime, \"Raising not end\");\r\n        }\r\n        release = _release;\r\n        releaseTime = block.timestamp;\r\n\r\n        emit RELEASE(_release);\r\n    }\r\n\r\n    function withdrawBNB() public onlyOwner withdrawCheck {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"does not have any balance\");\r\n        payable(msg.sender).transfer(balance);\r\n    }\r\n\r\n    function sync(address _tokenAddress, uint256 _amount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        IERC20(_tokenAddress).transfer(msg.sender, _amount);\r\n    }\r\n\r\n    // Buy Function\r\n    function getHardFilled() public view returns (bool) {\r\n        return alreadyRaised >= hardCap;\r\n    }\r\n\r\n    function getSoftFilled() public view returns (bool) {\r\n        return alreadyRaised >= softCap;\r\n    }\r\n\r\n    function getSellTokenAmount(uint256 _amount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _amount * perTokenBuy;\r\n    }\r\n\r\n    function buy(uint256 amount) external payable {\r\n        if (isWhitelist) {\r\n            require(whitelistedAddress[msg.sender], \"not whitelisted\");\r\n        }\r\n        require(block.timestamp != 0, \"Raising period not set\");\r\n        require(block.timestamp >= startTime, \"Raising period not started yet\");\r\n        require(block.timestamp < endTime, \"Raising period already end\");\r\n        require(getHardFilled() == false, \"Raise already fullfilled\");\r\n\r\n        UserInfo memory userInfo = usersTokenBought[msg.sender];\r\n\r\n        uint256 tokenSellAmount;\r\n\r\n        if (activeCurrency == IERC20(wBNB)) {\r\n            require(msg.value > 0, \"Please input value\");\r\n            require(\r\n                userInfo.totalSpent.add(msg.value) >= minBuy,\r\n                \"Less than min buy\"\r\n            );\r\n            require(\r\n                userInfo.totalSpent.add(msg.value) <= maxBuy,\r\n                \"More than max buy\"\r\n            );\r\n            require(\r\n                msg.value + alreadyRaised <= hardCap,\r\n                \"amount buy more than total hardcap\"\r\n            );\r\n\r\n            tokenSellAmount = getSellTokenAmount(msg.value);\r\n            userInfo.totalToken = userInfo.totalToken.add(tokenSellAmount);\r\n            userInfo.totalSpent = userInfo.totalSpent.add(msg.value);\r\n            usersTokenBought[msg.sender] = userInfo;\r\n\r\n            alreadyRaised = alreadyRaised.add(msg.value);\r\n        } else {\r\n            require(amount > 0, \"Please input value\");\r\n            require(\r\n                userInfo.totalSpent.add(amount) >= minBuy,\r\n                \"Less than min buy\"\r\n            );\r\n            require(\r\n                userInfo.totalSpent.add(amount) <= maxBuy,\r\n                \"More than max buy\"\r\n            );\r\n            require(\r\n                amount + alreadyRaised <= hardCap,\r\n                \"amount buy more than total hardcap\"\r\n            );\r\n\r\n            tokenSellAmount = getSellTokenAmount(amount);\r\n            require(\r\n                activeCurrency.balanceOf(msg.sender) >= amount,\r\n                \"not enough balance\"\r\n            );\r\n            require(\r\n                activeCurrency.allowance(msg.sender, address(this)) >= amount,\r\n                \"not enough allowance\"\r\n            );\r\n\r\n            activeCurrency.transferFrom(msg.sender, address(this), amount);\r\n            userInfo.totalToken = userInfo.totalToken.add(tokenSellAmount);\r\n            userInfo.totalSpent = userInfo.totalSpent.add(amount);\r\n            usersTokenBought[msg.sender] = userInfo;\r\n            alreadyRaised = alreadyRaised.add(amount);\r\n        }\r\n\r\n        emit BUY(msg.sender, tokenSellAmount);\r\n    }\r\n\r\n    // Claim Function\r\n    function claimFailed() external {\r\n        require(block.timestamp > endTime, \"Raising not end\");\r\n        if (isCheckSoftCap) {\r\n            require(getSoftFilled() == false, \"Soft cap already fullfiled\");\r\n        } else {\r\n            require(release == Release.FAILED, \"Release not failed\");\r\n        }\r\n\r\n        uint256 userSpent = usersTokenBought[msg.sender].totalSpent;\r\n        require(userSpent > 0, \"Already claimed\");\r\n\r\n        if (activeCurrency == IERC20(wBNB)) {\r\n            payable(msg.sender).transfer(userSpent);\r\n        } else {\r\n            activeCurrency.transfer(msg.sender, userSpent);\r\n        }\r\n\r\n        delete usersTokenBought[msg.sender];\r\n        emit CLAIM(msg.sender, Claims.FAILED);\r\n    }\r\n\r\n    modifier checkPeriod(uint256 _claim) {\r\n        require(\r\n            vestDuration[_claim] + releaseTime <= block.timestamp,\r\n            \"Claim not avalaible yet\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function claimSuccess(uint256 _claim)\r\n        external\r\n        checkPeriod(uint256(_claim))\r\n    {\r\n        require(release == Release.RELEASED, \"Not Release Time\");\r\n        UserInfo storage userInfo = usersTokenBought[msg.sender];\r\n        require(userInfo.totalToken > 0, \"You can't claim any amount\");\r\n\r\n        uint256 amountClaim;\r\n        Claims claim;\r\n\r\n        if (isVesting == false) {\r\n            amountClaim = userInfo.totalToken;\r\n            usersTokenBought[msg.sender] = userInfo;\r\n            tokenSell.transfer(msg.sender, amountClaim);\r\n            claim = Claims.FULL;\r\n        } else {\r\n            require(_claim < vestDuration.length, \"more than max claim\");\r\n            require(\r\n                claimInPeriod[msg.sender][_claim] == false,\r\n                \"already claim\"\r\n            );\r\n            amountClaim = userInfo.totalToken.mul(vestingClaim[_claim]).div(\r\n                100\r\n            );\r\n            usersTokenBought[msg.sender] = userInfo;\r\n            tokenSell.transfer(msg.sender, amountClaim);\r\n            claimInPeriod[msg.sender][_claim] = true;\r\n            claim = Claims.HALF;\r\n        }\r\n\r\n        emit CLAIM(msg.sender, claim);\r\n    }\r\n\r\n    function getRaised()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256[] memory,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            IERC20,\r\n            bool,\r\n            bool,\r\n            bool\r\n        )\r\n    {\r\n        return (\r\n            alreadyRaised,\r\n            startTime,\r\n            endTime,\r\n            softCap,\r\n            hardCap,\r\n            releaseTime,\r\n            vestDuration,\r\n            minBuy,\r\n            maxBuy,\r\n            perTokenBuy,\r\n            activeCurrency,\r\n            isWhitelist,\r\n            isCheckSoftCap,\r\n            isVesting\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_activeCurrency\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BUY\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum skybitAradena.Claims\",\"name\":\"claim\",\"type\":\"uint8\"}],\"name\":\"CLAIM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum skybitAradena.Release\",\"name\":\"released\",\"type\":\"uint8\"}],\"name\":\"RELEASE\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeCurrency\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"whitelistAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"values\",\"type\":\"bool[]\"}],\"name\":\"addWhitelised\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alreadyRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFailed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimInPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claim\",\"type\":\"uint256\"}],\"name\":\"claimSuccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHardFilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSoftFilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCheckSoftCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVesting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"perTokenBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[{\"internalType\":\"enum skybitAradena.Release\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setEventPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isWhitelist\",\"type\":\"bool\"}],\"name\":\"setIsWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBuy\",\"type\":\"uint256\"}],\"name\":\"setMinMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenSale\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_perTokenBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_softcap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hardcap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBuy\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isCheckSoftCap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isVesting\",\"type\":\"bool\"}],\"name\":\"setRaised\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum skybitAradena.Release\",\"name\":\"_release\",\"type\":\"uint8\"}],\"name\":\"setRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_vests\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_claims\",\"type\":\"uint256[]\"}],\"name\":\"setVestingPeriodAndClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSell\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersTokenBought\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSpent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "skybitAradena", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e46876b3ab8ebded259fe01529b8196ecd3302fe000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7a15a5bf17f58cb6c6c71ec936f89a54e79fb1d47624efb7847316a5dc000ceb"}