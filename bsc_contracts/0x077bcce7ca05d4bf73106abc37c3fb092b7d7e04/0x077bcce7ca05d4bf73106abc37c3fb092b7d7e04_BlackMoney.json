{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-11-23\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT License\r\npragma solidity 0.8.9;\r\n\r\ninterface IERC20 {    \r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction getOwner() external view returns (address);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction allowance(address _owner, address spender) external view returns (uint256);\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            \r\n            if (returndata.length > 0) {\r\n                \r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    \r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        \r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n    \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            \r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = msgSender;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n\t\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    bool internal locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract BlackMoney is Context, Ownable, ReentrancyGuard  {\r\n    using SafeMath for uint256;\r\n\tusing SafeERC20 for IERC20;\r\n    \r\n\tevent _Deposit(address indexed addr, uint256 amount, uint40 tm, uint8 ttype);\r\n    event _Withdraw(address indexed addr, uint256 amount, uint8 ttype);\r\n    event _Refund(address indexed addr, uint8 t, uint256 index, uint256 deposit);    \r\n\r\n\tIERC20[2] public Tether;    \r\n    address[2] public paymentTokenAddress = [0x55d398326f99059fF775485246999027B3197955, //USDT\r\n\t\t\t\t\t\t\t\t\t\t\t 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d]; //USDC\r\n\t\r\n    address payable private dev;\r\n    address payable private mkg;\r\n    \r\n\tuint256[2] public dev_comm\t\t= [450, 50];     \r\n    uint256[3] public ref_comm\t\t= [100, 30, 20];     \r\n    uint256[2] public fees          = [50,50];\r\n    uint16 constant PERCENT_DIVIDER = 1000; \r\n    uint256[4] public minimums      = [0.05 ether, 0.02 ether, 10 ether, 5 ether]; \r\n    \r\n\tuint256[3] private deposits;\r\n    uint256[3] private payouts;\r\n    uint256[3] private commissions;\r\n    uint256[3] private refunds;\r\n    uint256[3] private addedfunds;\r\n\r\n    struct Follower {\r\n        uint8 level;    \r\n        address wallet;\r\n    }\r\n\r\n    struct Tarif {\r\n        uint256 life_days;\r\n        uint256 percent;\r\n    }\r\n\r\n    struct Depo {\r\n\t\tuint8 depotype;\r\n        uint8 refunded;\r\n        uint40 time;  \r\n        uint256 tarif;\r\n        uint256 amount;        \r\n    }\r\n\r\n\tstruct Player {\t\t\r\n\t\taddress sponsor;\r\n        uint256[3] dividends;        \r\n\t\tuint256[3] total_deposits;\r\n        uint256[3] total_payouts;\r\n        uint256[3] total_commissions;\r\n\t\tuint256[3] total_refunds;\r\n\t\tuint40[3] lastWithdrawn;\r\n\r\n        Follower[] followers1;\r\n   \t\tFollower[] followers2;\r\n   \t\tFollower[] followers3;\r\n        uint256[3] structure; \t\t\r\n        Depo[] deposits;\r\n    }\r\n\r\n    mapping(address => Player) public players;\r\n    mapping(uint256 => Tarif) public tarifs;\r\n    mapping(uint256 => address) public membersNo;    \r\n    mapping(address => uint8) public banned;\r\n\r\n    uint public nextMemberNo;\r\n    uint public nextBannedWallet;\r\n\r\n    constructor() {\r\n        Tether[0] = IERC20(paymentTokenAddress[0]);       \r\n        Tether[1] = IERC20(paymentTokenAddress[1]);               \t\t\r\n        tarifs[0] = Tarif(365, 600); //1.6438% Daily for a year => 600%                    \r\n\t\tdev = payable(msg.sender); \r\n\t\tmkg = payable(msg.sender); \r\n    }    \r\n\t\r\n    function BNBFunds() external payable {\r\n        addedfunds[2] += msg.value;\r\n    }\r\n\r\n    function TetherFunds(uint256 amount, uint8 ttype) external { \r\n        require(ttype <= 1,\"Invalid Token Index!\");        \r\n        Tether[ttype].safeTransferFrom(msg.sender, address(this), amount);\r\n        addedfunds[ttype] += amount;\r\n    }\r\n\r\n    function BNBDeposit(address _upline) external payable {\r\n        require(msg.value >= minimums[0], \"Amount is less than minimum BNB deposit!\");        \r\n        \t\t\r\n        Player storage player = players[msg.sender];\r\n        setUpline(msg.sender, _upline);\r\n        player.deposits.push(Depo({\r\n\t\t\tdepotype: 2,\r\n            refunded: 0,\r\n            tarif: 0,\r\n            amount: msg.value,\r\n            time: uint40(block.timestamp)\r\n        }));  \r\n        player.total_deposits[2] += msg.value;\r\n        deposits[2] += msg.value;\r\n        \r\n\t\tcommissionPayouts(msg.sender, msg.value, 2);        \r\n        \r\n\t\tuint256 m1 = SafeMath.div(SafeMath.mul(msg.value, dev_comm[0]), PERCENT_DIVIDER);\r\n\t\tpayable(dev).transfer(m1);                              \r\n        \r\n\t\tuint256 m2 = SafeMath.div(SafeMath.mul(msg.value, dev_comm[1]), PERCENT_DIVIDER);\r\n\t\tpayable(mkg).transfer(m2);                              \r\n        \r\n        payouts[2] += SafeMath.add(m1, m2);\r\n\r\n\t\temit _Deposit(msg.sender, msg.value, uint40(block.timestamp), 2);        \r\n    }\r\n\r\n    function TetherDeposit(address _upline, uint256 amount, uint8 ttype) external { \r\n        require(ttype <= 1,\"Invalid Payment Index!\");\r\n        require(amount >= minimums[2], \"Amount is less than minimum deposit!\");        \r\n        \r\n        Tether[ttype].safeTransferFrom(msg.sender, address(this), amount);\r\n        \r\n        Player storage player = players[msg.sender];\r\n        setUpline(msg.sender, _upline);\r\n        player.deposits.push(Depo({\r\n\t\t\tdepotype: ttype,\r\n            refunded: 0,\r\n            tarif: 0,\r\n            amount: amount,\r\n            time: uint40(block.timestamp)\r\n        }));  \r\n        player.total_deposits[ttype] += amount;\r\n        deposits[ttype] += amount;\r\n        \r\n        commissionPayouts(msg.sender, amount, ttype);\r\n        \r\n        uint256 m1 = SafeMath.div(SafeMath.mul(amount, dev_comm[0]), PERCENT_DIVIDER);\r\n        Tether[ttype].safeTransfer(dev, m1);         \r\n        \r\n        uint256 m2 = SafeMath.div(SafeMath.mul(amount, dev_comm[1]), PERCENT_DIVIDER);\r\n        Tether[ttype].safeTransfer(mkg, m2);         \r\n        \r\n        payouts[ttype] += SafeMath.add(m1, m2);\r\n    \r\n        emit _Deposit(msg.sender, amount, uint40(block.timestamp), ttype);\t        \r\n    }\r\n    \t\r\n\tfunction commissionPayouts(address _addr, uint256 _amount, uint8 ttype) private {\r\n        address up = players[_addr].sponsor;\r\n        if(up == address(0) || up == owner()) return;\r\n\r\n        for(uint8 i = 0; i < ref_comm.length; i++) {\r\n            if(up == address(0)) break;\r\n            \r\n            uint256 bonus = _amount * ref_comm[i] / PERCENT_DIVIDER;\r\n            \r\n            if(ttype <= 1){\r\n                Tether[ttype].safeTransfer(up, bonus);\r\n\t\t\t}else {\r\n                payable(up).transfer(bonus);\r\n\t\t\t}   \r\n            players[up].total_commissions[ttype] += bonus;\r\n\t\t\tcommissions[ttype] += bonus;            \r\n            up = players[up].sponsor;\r\n        }       \r\n    }\r\n\t\r\n    function setUpline(address _addr, address sp) private {\r\n        if(players[_addr].sponsor == address(0) && _addr != owner()) {     \r\n\r\n            if(players[sp].deposits.length == 0) {\r\n\t\t\t\tsp = owner();\r\n            }\t\r\n            membersNo[ nextMemberNo ] = _addr;\t\t\t\t\r\n\t\t\tnextMemberNo++;           \t\t\t            \r\n            players[_addr].sponsor = sp;\r\n            for(uint8 i = 0; i < ref_comm.length; i++) {\r\n                players[sp].structure[i]++;\r\n\t\t\t\tPlayer storage up = players[sp];\r\n                if(i == 0){\r\n                    up.followers1.push(Follower({\r\n                        level: 1,\r\n                        wallet: _addr\r\n                    }));  \r\n                }else if(i == 1){\r\n                    up.followers2.push(Follower({\r\n                        level: 2,\r\n                        wallet: _addr\r\n                    }));  \r\n                }else if(i == 2){\r\n                    up.followers3.push(Follower({\r\n                        level: 3,\r\n                        wallet: _addr\r\n                    }));  \r\n                }\r\n\t\t\t\t\r\n                sp = players[sp].sponsor;\r\n                if(sp == address(0)) break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function ImportDeposit(address _upline, address wallet, uint256 amount, uint8 ttype, uint8 comm) public returns (bool success) {\r\n        require(msg.sender==dev,\"Unauthorized!\");        \r\n        Player storage player = players[wallet];\r\n        setUpline(wallet, _upline);\r\n        player.deposits.push(Depo({depotype: ttype, refunded: 0, tarif: 0, amount: amount, time: uint40(block.timestamp) }));  \r\n        player.total_deposits[ttype] += amount;\r\n        deposits[ttype] += amount;             \r\n        if(comm > 0){ commissionPayouts(wallet, amount, ttype); } \r\n        emit _Deposit(wallet, amount, uint40(block.timestamp), ttype);\r\n        return true;\r\n    }    \r\n    \r\n    function Payout(uint256 requestamount, uint8 ttype) external noReentrant  returns (bool success){     \r\n        if( banned[msg.sender] > 0) { return false; }\r\n        require(ttype <= 2,\"Invalid Token Index!\");\r\n        Player storage player = players[msg.sender];\r\n        \r\n        getPayout(msg.sender, ttype);\r\n        uint8 i = 3;\r\n        if(ttype == 2){ i = 1; }\r\n        require(player.dividends[ttype] >= minimums[i], \"Your dividends is less than minimum payout!\");\r\n        \r\n        uint256 amount =  player.dividends[ttype];\r\n        if(requestamount <= amount && requestamount > 0){            \r\n            player.dividends[ttype] = SafeMath.sub(amount, requestamount);\r\n            amount = requestamount;\r\n        }else{\r\n            player.dividends[ttype] = 0;\r\n        }        \r\n                \r\n        player.total_payouts[ttype] += amount;            \r\n        payouts[ttype] += amount;\r\n        emit _Withdraw(msg.sender, amount, ttype);    \r\n\r\n        uint256 fee = 0;\r\n        if(fees[0] > 0) {\r\n            fee = SafeMath.div(SafeMath.mul(amount, fees[0]), PERCENT_DIVIDER);\r\n            amount = SafeMath.sub(amount, fee);\r\n        }\r\n\r\n        if(ttype == 2){\r\n            payable(msg.sender).transfer(amount);            \r\n            if(fee > 0) {\r\n                payable(dev).transfer(fee);     \r\n            }                         \r\n        }else{\r\n            Tether[ttype].safeTransfer(msg.sender, amount);\r\n            if(fee > 0) {\r\n                Tether[ttype].safeTransfer(dev, fee);\r\n            }\r\n        }\r\n        return true;        \r\n    }\r\n\t\r\n\r\n    function Refund(uint256 index) external noReentrant  returns (bool success){     \r\n        if( banned[msg.sender] > 0) { return false; }\r\n        \r\n        Player storage player = players[msg.sender];\r\n        if( player.deposits.length == 0 ) { return false; }\r\n        if( index > player.deposits.length ) { return false; }\r\n        \r\n        Depo storage dep = player.deposits[index];\r\n        if(dep.refunded > 0) { return false; }\r\n        \r\n        uint8 t = dep.depotype;\r\n        uint256 deposit = dep.amount;\r\n\r\n        player.deposits[index].refunded = 1;\r\n\r\n        uint256 fee = SafeMath.div(SafeMath.mul(deposit, fees[1]), PERCENT_DIVIDER);\r\n\t\t\r\n        player.total_refunds[t] += deposit;            \r\n        refunds[t] += deposit;\r\n        emit _Refund(msg.sender, t, index, deposit);    \r\n\r\n        deposit = SafeMath.sub(deposit, fee);\r\n        if(t == 2){\r\n            payable(msg.sender).transfer(deposit);            \r\n            payable(dev).transfer(fee);                              \r\n        }else{\r\n            Tether[t].safeTransfer(msg.sender, deposit);\r\n            Tether[t].safeTransfer(dev, fee);\r\n        }\r\n        return true;        \r\n    }\r\n\r\n    function computePayout(address _addr, uint8 ttype) view external returns(uint256 value) {\r\n\t\tif( banned[_addr] > 0) { return 0; }\r\n        Player storage player = players[_addr];\r\n    \r\n        for(uint256 i = 0; i < player.deposits.length; i++) {\r\n            Depo storage dep = player.deposits[i];\r\n            if(dep.refunded == 0){\r\n                if(dep.depotype == ttype){\r\n                    Tarif storage tarif = tarifs[dep.tarif];\r\n        \r\n                    uint256 time_end = dep.time + tarif.life_days * 86400;\r\n                    uint40 from = player.lastWithdrawn[ttype] > dep.time ? player.lastWithdrawn[ttype] : dep.time;\r\n                    uint256 to = block.timestamp > time_end ? time_end : block.timestamp;\r\n\r\n                    if(from < to) {\r\n                        value += dep.amount * (to - from) * tarif.percent / tarif.life_days / 8640000;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function getPayout(address _addr, uint8 i) private {\r\n        uint256 payout = this.computePayout(_addr, i);\r\n        if(payout > 0) {            \r\n            players[_addr].lastWithdrawn[i] = uint40(block.timestamp);\r\n            players[_addr].dividends[i] += payout;\r\n        }\r\n    }      \r\n   \r\n    function setPaymentToken(uint8 index, address newval) public returns (bool success) {\r\n        require(msg.sender==dev,\"Unauthorized!\");\r\n        paymentTokenAddress[index] = newval;\r\n        Tether[index] = IERC20(paymentTokenAddress[index]); \r\n        return true;\r\n    }\r\n\r\n    function setRate(uint8 index, uint256 index2, uint256 newval) public returns (bool success) {   \r\n        require(msg.sender==dev,\"Unauthorized!\"); \r\n        if(index==1)\r\n        {\r\n            dev_comm[index2] = newval;\r\n        }else if(index==2){\r\n            ref_comm[index2] = newval;\r\n        }else if(index==3){\r\n            minimums[index2] = newval;\r\n        }else if(index==4){\r\n            fees[index2] = newval;\r\n        }\r\n        return true;\r\n    }   \r\n       \r\n    function setSponsor(address member, address newSP) public returns(bool success) {\r\n        require(msg.sender==dev,\"Unauthorized!\");\r\n        players[member].sponsor = newSP;\r\n        return true;\r\n    }\r\n\r\n    function setDev(uint8 i, address payable newval) public returns (bool success) {\r\n        require(msg.sender==dev,\"Unauthorized!\");\r\n        if(i==1){\r\n\t\t\tdev = newval;\r\n\t\t}else{\r\n\t\t\tmkg = newval;\r\n\t\t}\r\n        return true;\r\n    }\t\r\n\r\n    function setPercentage(uint256 total_days, uint256 total_perc) public returns (bool success) {\r\n        require(msg.sender==dev,\"Unauthorized!\");\r\n\t    tarifs[0] = Tarif(total_days, total_perc);\r\n        return true;\r\n    }\r\n\r\n    function banWallet(address wallet) public returns (bool success) {\r\n        require(msg.sender==dev,\"Unauthorized!\");\r\n        banned[wallet] = 1;\r\n        nextBannedWallet++;\r\n        return true;\r\n    }\r\n\t\r\n\tfunction unbanWallet(address wallet) public returns (bool success) {\r\n        require(msg.sender==dev,\"Unauthorized!\");\r\n        banned[wallet] = 0;\r\n        players[wallet].lastWithdrawn[0] = uint40(block.timestamp);\r\n        players[wallet].lastWithdrawn[1] = uint40(block.timestamp);\r\n        players[wallet].lastWithdrawn[2] = uint40(block.timestamp);\r\n        if(nextBannedWallet > 0){ nextBannedWallet--; }\r\n        return true;\r\n    }   \r\n\r\n    function memberAddressByNo(uint256 idx) public view returns(address) {\r\n         return membersNo[idx];\r\n    }\r\n\t    \r\n       \r\n    function memberStruct(address _addr) view external returns(address sp, uint256 numDeposits, uint256[3] memory structure) {\r\n        Player storage player = players[_addr];        \r\n        for(uint8 i = 0; i < ref_comm.length; i++) {\r\n            structure[i] = player.structure[i];\r\n        }\r\n        return (player.sponsor, player.deposits.length, structure);\r\n    } \r\n\t\r\n    function memberStats(address _addr, uint8 ttype) view external returns(uint256 _deposits, uint256 _payouts, uint256 _comm, uint256 _refunds, \r\n                                                                           uint256 forwithdraw, uint40 lastW)\r\n    {\r\n        Player storage player = players[_addr];        \r\n         if( player.deposits.length == 0 ) { return (0,0,0,0,0,0); }\r\n        uint256 payout = this.computePayout(_addr, ttype);\r\n        return( player.total_deposits[ttype],\r\n                player.total_payouts[ttype],\r\n                player.total_commissions[ttype], \r\n                player.total_refunds[ttype], (payout + player.dividends[ttype]), player.lastWithdrawn[ttype]);\r\n    }\r\n\r\n    function memberDownline(address _addr, uint8 level, uint256 index) view external returns(address follower)\r\n    {\r\n        Player storage player = players[_addr];\r\n        Follower storage dl;\r\n        if(level==1){\r\n            dl  = player.followers1[index];\r\n        }else if(level == 2){\r\n            dl  = player.followers2[index];\r\n        }else{\r\n            dl  = player.followers3[index];\r\n        }        \r\n        return(dl.wallet);\r\n    }\r\n\r\n    function memberDeposit(address _addr, uint256 index) view external returns(uint40 time, uint256 amount, uint256 lifedays, uint256 percent, \r\n                                                                                uint8 ttype, uint8 refunded)\r\n    {\r\n        Player storage player = players[_addr];\r\n        Depo storage dep = player.deposits[index];\r\n        Tarif storage tarif = tarifs[dep.tarif];\r\n        return(dep.time, dep.amount, tarif.life_days, tarif.percent, dep.depotype, dep.refunded);\r\n    }     \r\n\r\n    function contractInfo(address _addr) view external returns(uint256 invested1, uint256 invested2, uint256 invested3, \r\n                                                               uint256 withdrawn1, uint256 withdrawn2, uint256 withdrawn3, \r\n                                                               uint256 rewards1, uint256 rewards2, uint256 rewards3) {\r\n        Player storage player = players[_addr];        \r\n        if(player.deposits.length > 0){\r\n            return (deposits[0], deposits[1], deposits[2], payouts[0], payouts[1], payouts[2], commissions[0], commissions[1], commissions[2]);\r\n        }\r\n        return (0,0,0,0,0,0,0,0,0);\r\n    }\r\n    \r\n    function fundsInfo(address _addr) view external returns(uint256 refunds1, uint256 refunds2, uint256 refunds3, \r\n                                                               uint256 addedfunds1, uint256 addedfunds2, uint256 addedfunds3) {\r\n        Player storage player = players[_addr];        \r\n        if(player.deposits.length > 0){\r\n            return (refunds[0], refunds[1], refunds[2], addedfunds[0], addedfunds[1], addedfunds[2]);\r\n        }\r\n        return (0,0,0,0,0,0);\r\n    }\r\n\r\n    function getBNBBalance() public view returns(uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getUSDBalance(uint256 index) public view returns (uint256) {\r\n        return IERC20(paymentTokenAddress[index]).balanceOf(address(this));\r\n    }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"tm\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"}],\"name\":\"_Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"t\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"_Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"}],\"name\":\"_Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"BNBDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BNBFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"comm\",\"type\":\"uint8\"}],\"name\":\"ImportDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestamount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"}],\"name\":\"Payout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Tether\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"}],\"name\":\"TetherDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"}],\"name\":\"TetherFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"banWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"banned\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"}],\"name\":\"computePayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"contractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"invested1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invested2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invested3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards3\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dev_comm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"fundsInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"refunds1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refunds2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refunds3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addedfunds1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addedfunds2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addedfunds3\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBNBBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUSDBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"memberAddressByNo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"memberDeposit\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"time\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lifedays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"refunded\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"memberDownline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"follower\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"ttype\",\"type\":\"uint8\"}],\"name\":\"memberStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_comm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forwithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"lastW\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"memberStruct\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"structure\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"membersNo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minimums\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextBannedWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextMemberNo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ref_comm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"i\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"newval\",\"type\":\"address\"}],\"name\":\"setDev\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"newval\",\"type\":\"address\"}],\"name\":\"setPaymentToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total_days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_perc\",\"type\":\"uint256\"}],\"name\":\"setPercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newval\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newSP\",\"type\":\"address\"}],\"name\":\"setSponsor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tarifs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"life_days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"unbanWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BlackMoney", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bf1005013f7a1203ebf369a37f1b547acffc1dfb8d287946548a1e0752decec2"}