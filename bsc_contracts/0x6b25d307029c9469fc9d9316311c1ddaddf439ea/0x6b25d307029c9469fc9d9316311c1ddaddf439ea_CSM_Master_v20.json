{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CaesiumV20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n\\r\\ninterface IBEP20Token\\r\\n{\\r\\n    function mintTokens(address receipient, uint256 tokenAmount) external returns(bool);\\r\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\r\\n    function balanceOf(address user) external view returns(uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function maxsupply() external view returns (uint256);\\r\\n    function repurches(address _from, address _to, uint256 _value) external returns(bool);\\r\\n    function burn_internal(uint256 _value, address _to) external returns (bool);\\r\\n}\\r\\n\\r\\n\\r\\ncontract CSM_Master_v20{\\r\\n    \\r\\n    IBEP20Token public rewardToken;\\r\\n\\r\\n    AggregatorV3Interface internal priceFeed;\\r\\n    /*===============================\\r\\n    =         DATA STORAGE          =\\r\\n    ===============================*/\\r\\n\\r\\n    // Public variables of the token\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMath for uint;\\r\\n\\r\\n\\r\\n\\r\\n    struct Deposit {\\r\\n\\t\\tuint256 amount;\\r\\n\\t\\tuint256 start;\\r\\n        uint256 lastdate;\\r\\n\\t}\\r\\n\\r\\n\\r\\n    struct User {\\r\\n\\t\\tDeposit[] deposits;\\r\\n\\t\\taddress referrer;\\r\\n        uint256 bonus;\\r\\n        uint256 totalBonus;\\r\\n        uint256 totalWithdrwan;\\r\\n        uint256 totalDownLineBusiness;\\r\\n        uint256 totalDownLineBusinessInBnb;\\r\\n        uint256 directBonusEligibility;\\r\\n        uint256[15] refStageBusiness; //total business of referrer each stage\\r\\n        uint256[2] refStageBonus; //bonus of referrer each stage\\r\\n\\t\\tuint[15] refs;  // number of referrer each stage\\r\\n        uint totalDepositInUSD;\\r\\n        uint stakeTokenWithdrawn;\\r\\n\\t}\\r\\n\\r\\n    struct ScheduleTokenWithdrawal {\\r\\n        uint256 withdrawToken;\\r\\n        uint256 maturitydate;\\r\\n        bool ispaid;\\r\\n        uint256 startTime;\\r\\n    }\\r\\n\\r\\n    struct TokenStaked {\\r\\n        uint256 amountOfToken;\\r\\n        uint256 rewardToken;\\r\\n        uint package;\\r\\n    }\\r\\n\\r\\n    struct FlushBusiness {\\r\\n\\t\\tuint256 groupA;\\r\\n\\t\\tuint256 groupB;\\r\\n        uint256 groupC;\\r\\n        uint256 startDate;\\r\\n        uint256 endDate;\\r\\n        uint cycle;\\r\\n        uint flushdate;\\r\\n\\t}\\r\\n\\r\\n    \\r\\n\\r\\n    \\r\\n    \\r\\n    \\r\\n    mapping (address => TokenStaked[]) public tokenStakes;\\r\\n    mapping (address => mapping(uint => ScheduleTokenWithdrawal[])) public scheduleWithdrawals;\\r\\n    mapping (address => User) public users;\\r\\n    mapping (address => FlushBusiness) public flushBusiness;\\r\\n    mapping (address => uint256) public principalToken;\\r\\n    mapping (address => uint256) public numberOfFarming;\\r\\n    mapping (address => mapping(uint => uint)) public numberOfstakeAgainstFarming;\\r\\n    mapping (address => mapping(uint256 => address)) public directs;\\r\\n    bool public started;\\r\\n    address payable public ownerWallet;\\r\\n\\taddress payable public supportWallet;\\r\\n    bool private IsInitinalized;\\r\\n    uint public totalUsers;\\r\\n   \\r\\n\\r\\n    uint[2] public ref_bonuses; // first level bonus calculate as per the package amount.\\r\\n    uint[4] public plan ; //usd\\r\\n    uint[4] public plan_ref_bonuses; // Direct Bonus\\r\\n    uint256 public csmTokenPrice;\\r\\n\\r\\n    uint[5] public farmingRewardPercentage; // farming percentage\\r\\n    uint[5] public farmingLockPeriod; // farming locked days\\r\\n\\r\\n    uint[7] public farmingTokenAchive; // farming locked days\\r\\n\\r\\n    //uint[6] public Group_Rewards_Program = [10000,50000,100000,200000,500000,1000000];\\r\\n    uint[6] public Group_Rewards_Program;\\r\\n\\r\\n    //uint[3] public flushCycleDays = [90 days, 60 days, 30 days];\\r\\n    uint[3] public flushCycleDays;\\r\\n\\r\\n    uint256 public TotalInvestment;\\r\\n    \\r\\n    \\r\\n\\r\\n    struct BusinessLog {\\r\\n\\r\\n\\t\\tuint256 matching;\\r\\n        uint256 received;\\r\\n\\t\\tuint256 groupA;\\r\\n        uint256 groupB;\\r\\n        uint256 groupC;\\r\\n        bool ispaid;\\r\\n        bool isclaim;\\r\\n\\t}\\r\\n\\r\\n    mapping (address => BusinessLog[]) public businessLogs;\\r\\n    mapping (address => uint) public businessLogsCount;\\r\\n\\r\\n    struct FlushLog {\\r\\n\\r\\n\\t\\tuint256 matching;\\r\\n        uint256 received;\\r\\n\\t\\tuint256 groupA;\\r\\n        uint256 groupB;\\r\\n        uint256 groupC;\\r\\n        uint timeStamp;\\r\\n\\t}\\r\\n\\r\\n    mapping (address => uint) public numberOfFlushLogs;\\r\\n    mapping (address => FlushLog[]) public flushLogs;\\r\\n\\r\\n     uint public totalSupply;\\r\\n     uint public tokenPriceIncrement;\\r\\n     uint public token_price_changeOn;\\r\\n     address public cps_Contract;\\r\\n\\r\\n    struct stakeTokenLog{\\r\\n     uint tokenAmount;\\r\\n     uint lockedTime;\\r\\n    }\\r\\n    mapping(address=>stakeTokenLog[]) public stakeTokenLogs;\\r\\n    // Modified by aknashu Date 26-12-2022\\r\\n    mapping(address=>bool) public teamBusinessStatus;\\r\\n    address public tokenAdmin;\\r\\n    address public admin1;\\r\\n    address public admin2;\\r\\n\\r\\n    mapping(address=>uint) public settlementAmount;\\r\\n\\r\\n     struct BusinessLogNew {\\r\\n\\r\\n\\t\\tuint256 matching;\\r\\n        uint256 received;\\r\\n\\t\\tuint256 groupA;\\r\\n        uint256 groupB;\\r\\n        uint256 groupC;\\r\\n        bool ispaid;\\r\\n        bool isclaim;\\r\\n\\t}\\r\\n\\r\\n    mapping (address => BusinessLogNew[]) public newBusinessLogs;\\r\\n    mapping (address => uint) public newBusinessLogsCount;\\r\\n    /////////////////////////////\\r\\n\\r\\n    function initialize(address payable _ownerWallet,address payable _spWallet) public {\\r\\n        require (IsInitinalized == false,\\\"Already Started\\\");\\r\\n        ref_bonuses = [0,5];\\r\\n        plan = [100,500,1000,5000];\\r\\n        plan_ref_bonuses = [10,15,20,25];\\r\\n        csmTokenPrice = 0.007 ether;\\r\\n        farmingRewardPercentage = [20,50,75,100,100];\\r\\n        farmingLockPeriod = [180,365,545,730,365];\\r\\n        farmingTokenAchive = [180,270,360,450,545,630,730];\\r\\n        Group_Rewards_Program = [10000*1e8,50000*1e8,100000*1e8,200000*1e8,500000*1e8,1000000*1e8];\\r\\n        flushCycleDays = [90 days, 60 days, 30 days ];\\r\\n        priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE);\\r\\n        ownerWallet = _ownerWallet;\\r\\n        supportWallet = _spWallet;\\r\\n        IsInitinalized = true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n   \\r\\n\\r\\n\\r\\n    function invest(address _referrer, uint256 _package_index) public payable {\\r\\n\\r\\n       require(uint256(TotalusdPrice(int(msg.value))) >= 50*1e8, 'required min 50 USD!');\\r\\n       User storage user = users[msg.sender];\\r\\n       \\r\\n       if(_package_index ==4 && uint256(TotalusdPrice(int(msg.value))) < plan[3]*1e8 ){\\r\\n        revert(\\\"Please invest min amount of 100000 for this package\\\");\\r\\n       }\\r\\n\\r\\n       require((users[_referrer].deposits.length > 0 && _referrer != msg.sender) || ownerWallet == msg.sender,  \\\"No upline found\\\");\\r\\n         \\r\\n        if (user.referrer == address(0) && ownerWallet != msg.sender) {\\r\\n\\t\\t\\tuser.referrer = _referrer;\\r\\n        }\\r\\n\\r\\n\\r\\n        uint256 geteligibleForDirectBonus = eligibleForDirectBonus(msg.sender,msg.value);\\r\\n        user.directBonusEligibility = geteligibleForDirectBonus;\\r\\n\\r\\n         user.totalDepositInUSD += uint256(TotalusdPrice(int(msg.value)));\\r\\n         \\r\\n         \\r\\n        \\r\\n        address upline = user.referrer;\\r\\n        for(uint i=0; i < 15; i++){\\r\\n            if (upline != address(0)) {\\r\\n                users[upline].refs[i] += 1;              \\r\\n                 users[upline].refStageBusiness[i] = users[upline].refStageBusiness[i].add(msg.value);\\r\\n                 users[upline].totalDownLineBusinessInBnb += msg.value;\\r\\n                 users[upline].totalDownLineBusiness += uint256(TotalusdPrice(int(msg.value)));        \\r\\n                if(i < 2){ \\r\\n                uint256 bonus_percentage;\\r\\n                if(_package_index==4){\\r\\n                bonus_percentage = (i==0)? users[upline].directBonusEligibility : ref_bonuses[0];   \\r\\n                }else{\\r\\n                bonus_percentage = (i==0)? users[upline].directBonusEligibility : ref_bonuses[i];\\r\\n                }         \\r\\n                uint256 bonus = msg.value.mul(bonus_percentage).div(100);\\r\\n                users[upline].bonus += bonus;\\r\\n                }\\r\\n            }else break; \\r\\n          upline = users[upline].referrer;\\r\\n        }\\r\\n\\r\\n           if(user.referrer != address(0) && user.deposits.length == 0 ){\\r\\n             directs[user.referrer][users[user.referrer].refs[0]-1] = msg.sender;\\r\\n         }\\r\\n\\r\\n        if(user.deposits.length == 0){\\r\\n            flushBusiness[msg.sender].startDate = block.timestamp;\\r\\n            flushBusiness[msg.sender].endDate = block.timestamp.add(flushCycleDays[0]);\\r\\n            flushBusiness[msg.sender].cycle = 1;\\r\\n            flushBusiness[msg.sender].flushdate = flushBusiness[msg.sender].endDate.add(1 days);\\r\\n            totalUsers = totalUsers.add(1);\\r\\n        }\\r\\n         \\r\\n         \\r\\n         user.totalDownLineBusiness += uint256(TotalusdPrice(int(msg.value)));\\r\\n         user.totalDownLineBusinessInBnb += msg.value;\\r\\n        \\r\\n \\r\\n\\r\\n        TotalInvestment += msg.value;\\r\\n        uint256 tokenReceivedPrincipal = msg.value.div(csmTokenPrice)*1e8;\\r\\n        rewardToken.mintTokens(address(this), tokenReceivedPrincipal);\\r\\n        principalToken[msg.sender] += tokenReceivedPrincipal;\\r\\n        totalSupply += tokenReceivedPrincipal;\\r\\n        if(totalSupply >= token_price_changeOn){\\r\\n            uint increment = getTokenPriceIncrement();\\r\\n            totalSupply = 0;\\r\\n            csmTokenPrice=csmTokenPrice.add(increment);\\r\\n        }\\r\\n        stake(_package_index);\\r\\n        user.deposits.push(Deposit(msg.value, block.timestamp, 0));\\r\\n\\r\\n    }\\r\\n\\r\\n    function groupAIncome(address _userAddress) public view returns(uint256 _income, address _address){\\r\\n        User storage user = users[_userAddress];\\r\\n        uint256 maxBusiness;\\r\\n        address _addressa;\\r\\n        for(uint i=0; i < user.refs[0]; i++){\\r\\n             address groupAuser =  directs[_userAddress][i];\\r\\n            \\r\\n                if(users[groupAuser].totalDownLineBusiness > maxBusiness ) {\\r\\n                    maxBusiness =  users[groupAuser].totalDownLineBusiness;\\r\\n                    _addressa = groupAuser;\\r\\n                }\\r\\n             \\r\\n         }\\r\\n    \\r\\n        _income = maxBusiness;            \\r\\n         _address = _addressa;\\r\\n    }\\r\\n\\r\\n    function groupBIncome(address _userAddress) public view returns(uint256 _income, address _address){\\r\\n        User storage user = users[_userAddress];\\r\\n        (, address address_) = groupAIncome(_userAddress);\\r\\n        uint256 maxBusiness;\\r\\n        address _addressb;\\r\\n        for(uint i=0; i < user.refs[0]; i++){\\r\\n             address groupBuser =  directs[_userAddress][i];\\r\\n            \\r\\n                if(address_ != groupBuser && users[groupBuser].totalDownLineBusiness > maxBusiness){\\r\\n                    maxBusiness =  users[groupBuser].totalDownLineBusiness;\\r\\n                    _addressb = groupBuser;\\r\\n                }\\r\\n             \\r\\n         }\\r\\n            _income = maxBusiness;          \\r\\n            _address = _addressb;\\r\\n    }\\r\\n\\r\\n    function groupCIncome(address _userAddress) public view returns(uint256 _income){\\r\\n         User storage user = users[_userAddress];\\r\\n         (, address addressA_) = groupAIncome(_userAddress);\\r\\n         (, address addressB_) = groupBIncome(_userAddress);\\r\\n         for(uint i=0; i < user.refs[0]; i++){\\r\\n            address groupCuser =  directs[_userAddress][i];\\r\\n            if(addressA_ != groupCuser && addressB_ != groupCuser){\\r\\n              _income += users[groupCuser].totalDownLineBusiness;\\r\\n             }\\r\\n         }\\r\\n             _income =_income;\\r\\n    }\\r\\n    function DoflushBusiness() public returns(bool){\\r\\n        require(users[msg.sender].deposits.length > 0,\\\"You need to deposit First\\\");\\r\\n        require(block.timestamp > flushBusiness[msg.sender].flushdate ,\\\"You need cliam first\\\");\\r\\n\\r\\n        uint256 groupRewardIncome = groupEligibilityIncome(msg.sender);\\r\\n        uint256 groupRewardReceived = getReInvestmentAmount(msg.sender);\\r\\n        if(groupRewardIncome > 0){\\r\\n          flushBusiness[msg.sender].cycle +=1;\\r\\n        }\\r\\n        uint nextcycledate;\\r\\n        if(flushBusiness[msg.sender].cycle == 1){\\r\\n            nextcycledate = flushCycleDays[0];\\r\\n        }else if(flushBusiness[msg.sender].cycle == 2){\\r\\n            nextcycledate = flushCycleDays[1];\\r\\n        }else if(flushBusiness[msg.sender].cycle == 3){\\r\\n            nextcycledate = flushCycleDays[2];\\r\\n        }else{\\r\\n            nextcycledate = flushCycleDays[2];\\r\\n        }\\r\\n        flushBusiness[msg.sender].startDate = block.timestamp;\\r\\n        flushBusiness[msg.sender].endDate = block.timestamp.add(nextcycledate);\\r\\n        flushBusiness[msg.sender].flushdate = flushBusiness[msg.sender].endDate.add(1 days);\\r\\n\\r\\n         \\r\\n\\r\\n        (uint256 incomeA_,) = groupAIncome(msg.sender); \\r\\n        (uint256 incomeB_,) = groupBIncome(msg.sender);\\r\\n\\r\\n       numberOfFlushLogs[msg.sender] += 1;\\r\\n       flushLogs[msg.sender].push(FlushLog(groupRewardIncome,groupRewardReceived,incomeA_,incomeB_,groupCIncome(msg.sender),block.timestamp));\\r\\n\\r\\n\\r\\n        flushBusiness[msg.sender].groupA += incomeA_;\\r\\n        flushBusiness[msg.sender].groupB += incomeB_;\\r\\n        flushBusiness[msg.sender].groupC += groupCIncome(msg.sender);\\r\\n        resetDowlineBusiness(msg.sender);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n    // Modified by aknashu Date 26-12-2022\\r\\n    function resetDowlineBusiness(address _userAddress) private {\\r\\n        User storage user = users[_userAddress];\\r\\n        for(uint i=0; i < user.refs[0]; i++){\\r\\n                address downline =  directs[_userAddress][i];\\r\\n                users[downline].totalDownLineBusiness = 0;          \\r\\n            }\\r\\n    }\\r\\n\\r\\n// Modified by aknashu Date 01-12-2022\\r\\n    function doResetCycle(uint _index) public {\\r\\n     uint256 groupRewardIncome = groupEligibilityIncome(msg.sender);\\r\\n     uint256 groupRewardReceived = getReInvestmentAmount(msg.sender);\\r\\n   if(newBusinessLogs[msg.sender][_index].isclaim == true && newBusinessLogs[msg.sender][_index].ispaid == false){\\r\\n    require(newBusinessLogs[msg.sender][_index].received>0,\\\"you don't have funds\\\");\\r\\n        uint nextcycledate;\\r\\n        if(flushBusiness[msg.sender].cycle == 1){\\r\\n            nextcycledate = flushCycleDays[0];\\r\\n        }else if(flushBusiness[msg.sender].cycle == 2){\\r\\n            nextcycledate = flushCycleDays[1];\\r\\n        }else if(flushBusiness[msg.sender].cycle == 3){\\r\\n            nextcycledate = flushCycleDays[2];\\r\\n        }else{\\r\\n            nextcycledate = flushCycleDays[2];\\r\\n        } \\r\\n        flushBusiness[msg.sender].startDate = block.timestamp;\\r\\n        flushBusiness[msg.sender].endDate = block.timestamp.add(nextcycledate);\\r\\n        flushBusiness[msg.sender].flushdate = flushBusiness[msg.sender].endDate.add(1 days);\\r\\n\\r\\n         \\r\\n\\r\\n        (uint256 incomeA_,) = groupAIncome(msg.sender); \\r\\n        (uint256 incomeB_,) = groupBIncome(msg.sender);\\r\\n\\r\\n       numberOfFlushLogs[msg.sender] += 1;\\r\\n       flushLogs[msg.sender].push(FlushLog(groupRewardIncome,groupRewardReceived,incomeA_,incomeB_,groupCIncome(msg.sender),block.timestamp));\\r\\n\\r\\n\\r\\n        flushBusiness[msg.sender].groupA += incomeA_;\\r\\n        flushBusiness[msg.sender].groupB += incomeB_;\\r\\n        flushBusiness[msg.sender].groupC += groupCIncome(msg.sender);\\r\\n        newBusinessLogs[msg.sender][_index].ispaid = true;\\r\\n        resetDowlineBusiness(msg.sender);\\r\\n   }\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n    function claimBonus() public returns(uint256){\\r\\n        require(block.timestamp<=flushBusiness[msg.sender].flushdate && block.timestamp >= flushBusiness[msg.sender].endDate, 'not eligibile to claim');\\r\\n        claim(msg.sender);\\r\\n         return 1;\\r\\n    }\\r\\n// Modified by aknashu Date 01-12-2022\\r\\n    function beforeTimeclaimBonus() public returns(uint256){\\r\\n        require(block.timestamp < flushBusiness[msg.sender].endDate, 'not eligibile to claim');\\r\\n        uint256 groupRewardIncome = groupEligibilityIncome(msg.sender);\\r\\n        require(groupRewardIncome>0,\\\"you don't have income yet\\\");\\r\\n        claim(msg.sender);\\r\\n         return 1;\\r\\n    }\\r\\n\\r\\n    function businessLogChange(address _user,uint _index) public {\\r\\n        require(msg.sender == supportWallet, \\\"permission Diened\\\");\\r\\n         newBusinessLogs[_user][_index].ispaid = true;\\r\\n    }\\r\\n\\r\\n    function claim(address _useraddress) internal returns(uint){\\r\\n\\r\\n            \\r\\n\\r\\n            (uint256 incomeA_,) = groupAIncome(_useraddress); \\r\\n            (uint256 incomeB_,) = groupBIncome(_useraddress);\\r\\n            uint256 groupRewardIncome = groupEligibilityIncome(_useraddress);\\r\\n            uint256 groupRewardReceived = getReInvestmentAmount(_useraddress);\\r\\n\\r\\n            if(newBusinessLogsCount[_useraddress] ==0){\\r\\n                newBusinessLogsCount[_useraddress] +=1;\\r\\n\\r\\n                newBusinessLogs[_useraddress].push(BusinessLogNew(groupRewardIncome, groupRewardReceived, incomeA_, incomeB_, groupCIncome(_useraddress),false,true));\\r\\n\\r\\n                \\r\\n            }\\r\\n            if((newBusinessLogsCount[_useraddress] >0) && (newBusinessLogs[_useraddress][newBusinessLogsCount[_useraddress]-1].ispaid)){\\r\\n                newBusinessLogsCount[_useraddress] +=1;\\r\\n                newBusinessLogs[_useraddress].push(BusinessLogNew(groupRewardIncome, groupRewardReceived, incomeA_, incomeB_, groupCIncome(_useraddress),false,true));\\r\\n             \\r\\n            }\\r\\n\\r\\n            if(groupRewardIncome <= 0){\\r\\n                uint nextcycledate;\\r\\n                if(flushBusiness[_useraddress].cycle == 1){\\r\\n                    nextcycledate = flushCycleDays[0];\\r\\n                }else if(flushBusiness[_useraddress].cycle == 2){\\r\\n                    nextcycledate = flushCycleDays[1];\\r\\n                }else if(flushBusiness[_useraddress].cycle == 3){\\r\\n                    nextcycledate = flushCycleDays[2];\\r\\n                }else{\\r\\n                    nextcycledate = flushCycleDays[2];\\r\\n                }\\r\\n                flushBusiness[_useraddress].startDate = block.timestamp;\\r\\n                flushBusiness[_useraddress].endDate = block.timestamp.add(nextcycledate);\\r\\n                flushBusiness[_useraddress].flushdate = flushBusiness[_useraddress].endDate.add(1 days);\\r\\n\\r\\n\\r\\n                numberOfFlushLogs[_useraddress] += 1;\\r\\n                flushLogs[_useraddress].push(FlushLog(groupRewardIncome,groupRewardReceived,incomeA_,incomeB_,groupCIncome(_useraddress),block.timestamp));\\r\\n\\r\\n\\r\\n\\r\\n                flushBusiness[_useraddress].groupA += incomeA_;\\r\\n                flushBusiness[_useraddress].groupB += incomeB_;\\r\\n                flushBusiness[_useraddress].groupC += groupCIncome(_useraddress);\\r\\n                resetDowlineBusiness(_useraddress);\\r\\n\\r\\n                newBusinessLogs[_useraddress][newBusinessLogsCount[_useraddress]-1].ispaid = true;\\r\\n            }\\r\\n\\r\\n\\r\\n\\r\\n            return 1;\\r\\n    }\\r\\n\\r\\n    function receiveGroupIncome(uint _index) public payable {\\r\\n\\r\\n        if(newBusinessLogs[msg.sender][_index].isclaim == true && newBusinessLogs[msg.sender][_index].ispaid == false){\\r\\n            if( newBusinessLogs[msg.sender][_index].matching > 0){\\r\\n            uint256 amountToBepay =  newBusinessLogs[msg.sender][_index].received;\\r\\n\\r\\n            uint bnb =  getCalculatedBnbRecieved(amountToBepay);\\r\\n\\r\\n            if(newBusinessLogs[msg.sender][_index].received > 0){\\r\\n            require(msg.value >= bnb, 'not enough fund!');\\r\\n            }\\r\\n        \\r\\n            newBusinessLogs[msg.sender][_index].ispaid = true;\\r\\n            users[msg.sender].totalDepositInUSD += uint256(TotalusdPrice(int(bnb)));\\r\\n            users[msg.sender].deposits.push(Deposit(bnb, block.timestamp, 0));\\r\\n            flushBusiness[msg.sender].cycle +=1;\\r\\n            uint nextcycledate = (flushBusiness[msg.sender].cycle >= 3) ? flushCycleDays[2] : flushCycleDays[1]; \\r\\n            flushBusiness[msg.sender].startDate = block.timestamp;\\r\\n            flushBusiness[msg.sender].endDate = block.timestamp.add(nextcycledate);\\r\\n            flushBusiness[msg.sender].flushdate = flushBusiness[msg.sender].endDate.add(1 days);\\r\\n\\r\\n            (uint256 incomeA_,) = groupAIncome(msg.sender); \\r\\n            (uint256 incomeB_,) = groupBIncome(msg.sender);\\r\\n            flushBusiness[msg.sender].groupA += incomeA_;\\r\\n            flushBusiness[msg.sender].groupB += incomeB_;\\r\\n            flushBusiness[msg.sender].groupC += groupCIncome(msg.sender);\\r\\n            resetDowlineBusiness(msg.sender);\\r\\n\\r\\n            uint bnbtosend = getCalculatedBnbRecieved(newBusinessLogs[msg.sender][_index].matching);\\r\\n            uint bnbtoToken = bnbtosend.mul(25).div(100);\\r\\n            uint reciveToken = bnbtoToken.div(csmTokenPrice)*1e8;\\r\\n            principalToken[msg.sender] = principalToken[msg.sender].add(reciveToken);\\r\\n            stakeTokenLogs[msg.sender].push(stakeTokenLog(reciveToken,block.timestamp.add(180 days)));\\r\\n\\r\\n            payable(msg.sender).transfer(bnbtosend.mul(75).div(100));\\r\\n\\r\\n           \\r\\n            }else{\\r\\n\\r\\n                uint nextcycledate;\\r\\n                if(flushBusiness[msg.sender].cycle == 1){\\r\\n                    nextcycledate = flushCycleDays[0];\\r\\n                }else if(flushBusiness[msg.sender].cycle == 2){\\r\\n                    nextcycledate = flushCycleDays[1];\\r\\n                }else if(flushBusiness[msg.sender].cycle == 3){\\r\\n                    nextcycledate = flushCycleDays[2];\\r\\n                }else{\\r\\n                    nextcycledate = flushCycleDays[2];\\r\\n                } \\r\\n                flushBusiness[msg.sender].startDate = block.timestamp;\\r\\n                flushBusiness[msg.sender].endDate = block.timestamp.add(nextcycledate);\\r\\n\\r\\n                (uint256 incomeA_,) = groupAIncome(msg.sender); \\r\\n                (uint256 incomeB_,) = groupBIncome(msg.sender);\\r\\n\\r\\n                flushBusiness[msg.sender].groupA += incomeA_;\\r\\n                flushBusiness[msg.sender].groupB += incomeB_;\\r\\n                flushBusiness[msg.sender].groupC += groupCIncome(msg.sender);\\r\\n                resetDowlineBusiness(msg.sender);\\r\\n\\r\\n            }\\r\\n\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function getReInvestmentAmount(address _useraddress) public view returns(uint _reInvestmentAmount){\\r\\n        User storage user = users[_useraddress];\\r\\n        uint256 groupRewardIncome = groupEligibilityIncome(_useraddress);\\r\\n        if (groupRewardIncome > 0){\\r\\n            uint256 reInvestmentAmount = groupRewardIncome.mul(25).div(100);\\r\\n\\r\\n        if(user.totalDepositInUSD >=reInvestmentAmount){\\r\\n            _reInvestmentAmount = 0;\\r\\n            \\r\\n        }else {\\r\\n         _reInvestmentAmount  =  reInvestmentAmount.sub(user.totalDepositInUSD);\\r\\n        }\\r\\n\\r\\n        }\\r\\n        \\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function groupEligibilityIncome(address _userAddress) public view returns(uint256){\\r\\n\\r\\n        uint256[] memory arrayIncome = new uint[](3);\\r\\n\\r\\n        (uint256 incomeA_,) = groupAIncome(_userAddress); \\r\\n        (uint256 incomeB_,) = groupBIncome(_userAddress);\\r\\n        arrayIncome[0] = incomeA_;\\r\\n        arrayIncome[1] = incomeB_;\\r\\n        arrayIncome[2] = groupCIncome(_userAddress);\\r\\n\\r\\n        uint256 minimumBusinessFromGroup = min(arrayIncome);\\r\\n        uint256 nextMatching;\\r\\n        if(newBusinessLogsCount[_userAddress] > 0 && newBusinessLogs[_userAddress][newBusinessLogsCount[_userAddress]-1].isclaim){\\r\\n           nextMatching  =  newBusinessLogs[_userAddress][newBusinessLogsCount[_userAddress]-1].matching;\\r\\n        }\\r\\n\\r\\n        \\r\\n        uint256 groupReward;\\r\\n       if(minimumBusinessFromGroup >= nextMatching){\\r\\n\\r\\n            if(minimumBusinessFromGroup >= Group_Rewards_Program[0] && minimumBusinessFromGroup < Group_Rewards_Program[1]){\\r\\n                groupReward = Group_Rewards_Program[0];\\r\\n            }else if(minimumBusinessFromGroup >= Group_Rewards_Program[1] && minimumBusinessFromGroup < Group_Rewards_Program[2]){\\r\\n                groupReward = Group_Rewards_Program[1];\\r\\n            }else if(minimumBusinessFromGroup >= Group_Rewards_Program[2] && minimumBusinessFromGroup < Group_Rewards_Program[3]){\\r\\n                groupReward = Group_Rewards_Program[2];\\r\\n            }else if(minimumBusinessFromGroup >= Group_Rewards_Program[3] && minimumBusinessFromGroup < Group_Rewards_Program[4]){\\r\\n                groupReward = Group_Rewards_Program[3];\\r\\n            }else if(minimumBusinessFromGroup >= Group_Rewards_Program[4] && minimumBusinessFromGroup < Group_Rewards_Program[5]){\\r\\n                groupReward = Group_Rewards_Program[4];\\r\\n            }else if(minimumBusinessFromGroup >= Group_Rewards_Program[5]){\\r\\n                groupReward = Group_Rewards_Program[5];\\r\\n            }\\r\\n       }\\r\\n        return groupReward;\\r\\n\\r\\n    }\\r\\n\\r\\n    function min(uint256[] memory numbers) public pure returns (uint256) {\\r\\n     require(numbers.length > 0); // throw an exception if the condition is not met\\r\\n        uint256 minNumber; // default 0, the lowest value of `uint256`\\r\\n\\r\\n        for (uint256 i = 0; i < numbers.length; i++) {\\r\\n           if(i==0){\\r\\n                if (minNumber <= numbers[i]) {\\r\\n                    minNumber = numbers[i];\\r\\n                }\\r\\n           }else if (minNumber > numbers[i]){\\r\\n                    minNumber = numbers[i]; \\r\\n                } \\r\\n        }\\r\\n\\r\\n        return minNumber;\\r\\n    }\\r\\n\\r\\n\\r\\n    function stake(uint256 _package) private returns(bool){\\r\\n        \\r\\n        uint256 calRewardToken = principalToken[msg.sender].mul(farmingRewardPercentage[_package]).div(100);\\r\\n        tokenStakes[msg.sender].push(TokenStaked(principalToken[msg.sender], principalToken[msg.sender].add(calRewardToken),_package));\\r\\n        numberOfFarming[msg.sender] += 1;\\r\\n\\r\\n        //Basic\\r\\n        if(farmingLockPeriod[_package]==180){\\r\\n\\r\\n            uint256 receivable = principalToken[msg.sender].add(calRewardToken).div(2); \\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable,180,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable,270,false,block.timestamp));\\r\\n            numberOfstakeAgainstFarming[msg.sender][numberOfFarming[msg.sender]] = 2;\\r\\n        }\\r\\n        //Premium\\r\\n        if(_package == 1 && farmingLockPeriod[_package]==365){\\r\\n\\r\\n            uint256 receivable = principalToken[msg.sender].add(calRewardToken); \\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(333).div(1000),180,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(333).div(1000),270,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(333).div(1000),365,false,block.timestamp));\\r\\n            numberOfstakeAgainstFarming[msg.sender][numberOfFarming[msg.sender]] = 3;\\r\\n        }\\r\\n\\r\\n\\r\\n        //Glod\\r\\n        if(farmingLockPeriod[_package]==545){\\r\\n\\r\\n            uint256 receivable = principalToken[msg.sender].add(calRewardToken); \\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(200).div(1000),180,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(200).div(1000),270,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(200).div(1000),360,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(200).div(1000),450,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(200).div(1000),545,false,block.timestamp));\\r\\n            numberOfstakeAgainstFarming[msg.sender][numberOfFarming[msg.sender]] = 5;\\r\\n        }\\r\\n\\r\\n        // platinum\\r\\n        if(farmingLockPeriod[_package]==730){\\r\\n\\r\\n            uint256 receivable = principalToken[msg.sender].add(calRewardToken); \\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(150).div(1000),180,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(150).div(1000),270,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(150).div(1000),360,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(150).div(1000),450,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(150).div(1000),545,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(150).div(1000),630,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(100).div(1000),730,false,block.timestamp));\\r\\n            numberOfstakeAgainstFarming[msg.sender][numberOfFarming[msg.sender]] = 7;\\r\\n            \\r\\n        }\\r\\n\\r\\n        // VIP platinum\\r\\n        if(_package == 4 && farmingLockPeriod[_package]==365){\\r\\n\\r\\n            uint256 receivable = principalToken[msg.sender].add(calRewardToken); \\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(300).div(1000),545,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(300).div(1000),630,false,block.timestamp));\\r\\n            scheduleWithdrawals[msg.sender][numberOfFarming[msg.sender]].push(ScheduleTokenWithdrawal(receivable.mul(400).div(1000),730,false,block.timestamp));\\r\\n            numberOfstakeAgainstFarming[msg.sender][numberOfFarming[msg.sender]] = 3;\\r\\n            \\r\\n        }\\r\\n\\r\\n        return true;\\r\\n\\r\\n    }\\r\\n\\r\\n    function WithdrawalToken(uint _fno, uint _sno) public {\\r\\n        if( scheduleWithdrawals[msg.sender][_fno][_sno].maturitydate > 0 && block.timestamp >=(scheduleWithdrawals[msg.sender][_fno][_sno].maturitydate.mul(1 days)+scheduleWithdrawals[msg.sender][_fno][_sno].startTime)){\\r\\n            scheduleWithdrawals[msg.sender][_fno][_sno].ispaid = true;\\r\\n            uint token =  scheduleWithdrawals[msg.sender][_fno][_sno].withdrawToken;\\r\\n            rewardToken.transfer(msg.sender, token);\\r\\n        } else{\\r\\n            revert (\\\"You are not Eligibile for Widhdrwan Right now\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function WithdrawalDirectIncome() public {\\r\\n        \\r\\n       uint256 bonus =  users[msg.sender].bonus;\\r\\n       users[msg.sender].bonus = 0;\\r\\n       users[msg.sender].totalBonus += bonus;\\r\\n\\r\\n       payable(msg.sender).transfer(bonus);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n    function getNumberOfFrearminig(address _userAddress) public view returns(uint){\\r\\n        return numberOfFarming[_userAddress];\\r\\n    }\\r\\n\\r\\n    function getNumberOfStakeAgainstFrearminig(address _userAddress,uint _index) public view returns( uint _NoOfStakes){\\r\\n        _NoOfStakes = numberOfstakeAgainstFarming[_userAddress][_index];\\r\\n    }\\r\\n\\r\\n\\r\\n        \\r\\n    function getUserDetails(address _address) public view returns(address _referrer, uint256 _bonus, uint256 _totalBonus, uint256 _totalWithdrwan, uint256 _totalDownLineBusiness ){\\r\\n        User storage user = users[_address];\\r\\n        return(user.referrer,user.bonus, user.totalBonus, user.totalWithdrwan, user.totalDownLineBusiness);\\r\\n    }\\r\\n\\r\\n    function eligibleForDirectBonus( address _useraddress ,uint256 amount) public view returns(uint256){\\r\\n\\r\\n        uint256 _percent;\\r\\n\\t\\tuint _amount = uint(TotalusdPrice(int(amount)));\\r\\n        _amount += users[_useraddress].totalDepositInUSD;\\r\\n\\r\\n        if(_amount >= (plan[0]*1e8) && _amount < (plan[1]*1e8)){\\r\\n\\t\\t\\t_percent = plan_ref_bonuses[0];\\r\\n\\t\\t}else if(_amount >= (plan[1]*1e8) && _amount < (plan[2]*1e8)){\\r\\n\\t\\t\\t_percent = plan_ref_bonuses[1];\\r\\n\\t\\t}else if(_amount >= (plan[2]*1e8) && _amount < (plan[3]*1e8)){\\r\\n\\t\\t\\t_percent = plan_ref_bonuses[2];\\r\\n\\t\\t}else if(_amount >= (plan[3]*1e8)){\\r\\n\\t\\t\\t_percent = ref_bonuses[1];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn (_percent);\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\r\\n    function revertBack(uint256 _amount) external{\\r\\n        require(ownerWallet == msg.sender);\\r\\n        if((_amount*1e18) <= address(this).balance){\\r\\n         payable(ownerWallet).transfer(_amount*1e18);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function getLatestPrice() public view returns (int) {\\r\\n        (\\r\\n            /* uint80 roundID */,\\r\\n            int price,\\r\\n            /*uint startedAt */,\\r\\n            /*uint timeStamp*/,\\r\\n           /* uint80 answeredInRound*/\\r\\n        ) = priceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    function TotalusdPrice(int _amount) public view returns (int) {\\r\\n        int usdt = getLatestPrice();\\r\\n        return (usdt * _amount)/1e18;\\r\\n    }\\r\\n\\r\\n    function getCalculatedBnbRecieved(uint256 _amount) public view returns(uint256) {\\r\\n\\t\\tuint256 usdt = uint256(getLatestPrice());\\r\\n\\t\\tuint256 recieved_bnb = (_amount*1e18/usdt*1e18)/1e18;\\r\\n\\t\\treturn recieved_bnb;\\r\\n\\t  }\\r\\n    function getSystemInfo() public view returns( uint _TotalInvestment, uint _totalUsers){\\r\\n        return (TotalInvestment,totalUsers);\\r\\n        \\r\\n    }\\r\\n    function getDepositLength(address _useraddress) public view returns(uint){\\r\\n        User storage u = users[_useraddress] ;\\r\\n        return u.deposits.length;\\r\\n    }   \\r\\n    function getDepositInfo(uint _index ,address _useraddress) public view returns(uint _amount  , uint _start, uint _lastdate){\\r\\n        User storage u = users[_useraddress] ;\\r\\n        return (u.deposits[_index].amount , u.deposits[_index].start,u.deposits[_index].lastdate);\\r\\n    }\\r\\n    \\r\\n    function getUserRef(address _useraddress , uint _index) public view returns(uint _refcount, uint _refStageBusiness) {\\r\\n        User storage user = users[_useraddress];\\r\\n        return(\\r\\n            user.refs[_index],\\r\\n            user.refStageBusiness[_index]\\r\\n        );\\r\\n    }\\r\\n   \\r\\n    function addFund() external payable{\\r\\n       \\r\\n    }\\r\\n    function initinalizeRewardToken(IBEP20Token _rewardtoken) public {\\r\\n        require(supportWallet == msg.sender,\\\"permision Denied\\\");\\r\\n        rewardToken = _rewardtoken;\\r\\n\\r\\n    }\\r\\n\\r\\n    function getTotalStake(address _useraddress) public view returns(uint256 _totalStaked){\\r\\n       uint256 farmingcount =  numberOfFarming[_useraddress];\\r\\n       for(uint256 i = 1 ;i<=farmingcount;i++){\\r\\n          _totalStaked +=  tokenStakes[_useraddress][i].rewardToken;   \\r\\n       }\\r\\n    }\\r\\n\\r\\n    function updateTokenPrice(uint256 _amount) public {\\r\\n        require(ownerWallet == msg.sender,\\\"Premision Denied\\\");\\r\\n        csmTokenPrice = _amount;\\r\\n    }\\r\\n\\r\\n    function getCSMTokenPrice() external view returns(uint256){\\r\\n        return csmTokenPrice;\\r\\n    }\\r\\n\\r\\n    function getTokenPriceIncrement() internal view returns(uint){\\r\\n          uint  tokenPriceIncrementBNB  = tokenPriceIncrement;\\r\\n          return tokenPriceIncrementBNB;\\r\\n    }\\r\\n\\r\\n    function updateTokenSettings(uint bnbValue, uint onChangeValueUsd) public {\\r\\n        require(supportWallet == msg.sender,\\\"permision Denied\\\");\\r\\n        tokenPriceIncrement = bnbValue;\\r\\n        token_price_changeOn = onChangeValueUsd;\\r\\n    }\\r\\n\\r\\n    function supplyRestart() public {\\r\\n    require(supportWallet == msg.sender,\\\"permision Denied\\\");\\r\\n        totalSupply = 0;\\r\\n    }\\r\\n    function mintToken(address _user , uint _amount) external returns(bool){\\r\\n        require(cps_Contract == msg.sender,\\\"Invalid caller\\\");\\r\\n        rewardToken.mintTokens(_user, _amount);\\r\\n        return true;\\r\\n    }\\r\\n    function burnToken(address _user , uint _amount) external returns(bool) {\\r\\n       require(cps_Contract == msg.sender,\\\"Invalid caller\\\");\\r\\n       rewardToken.burn_internal(_amount, _user);\\r\\n       return true;\\r\\n    }\\r\\n    function setMinner(address _minner) public {\\r\\n       require(supportWallet == msg.sender,\\\"permision Denied\\\");\\r\\n       cps_Contract = _minner;\\r\\n    }\\r\\n\\r\\n\\r\\n    function availableToken(address _user) public view returns(uint _availableToken) {\\r\\n        if(stakeTokenLogs[_user].length>0){\\r\\n            for(uint i = 0; i<stakeTokenLogs[_user].length;i++){\\r\\n                if(block.timestamp >= stakeTokenLogs[_user][i].lockedTime){\\r\\n                    _availableToken = _availableToken.add(stakeTokenLogs[_user][i].tokenAmount);\\r\\n                }\\r\\n            }\\r\\n            _availableToken = _availableToken.sub(users[_user].stakeTokenWithdrawn);\\r\\n        }\\r\\n\\r\\n        return _availableToken;\\r\\n    }\\r\\n\\r\\n    function userStakeTokenLength(address user) public view returns(uint count){\\r\\n        count = stakeTokenLogs[user].length;\\r\\n    }\\r\\n\\r\\n    function tokenWithdraw() public {\\r\\n       uint token = availableToken(msg.sender);\\r\\n       require(token>0,\\\"no tokens to withdraw\\\");\\r\\n       users[msg.sender].stakeTokenWithdrawn = users[msg.sender].stakeTokenWithdrawn.add(token);\\r\\n       rewardToken.transfer(msg.sender, token);\\r\\n    }\\r\\n\\r\\n    function addtotalDownlineBussiness(address _user,uint _usdamount) public {\\r\\n        require(supportWallet == msg.sender,\\\"permision Denied\\\");\\r\\n        users[_user].totalDownLineBusiness = users[_user].totalDownLineBusiness.add(_usdamount);\\r\\n        users[_user].totalDownLineBusinessInBnb = users[_user].totalDownLineBusinessInBnb.add(getCalculatedBnbRecieved(_usdamount));\\r\\n    }\\r\\n\\r\\n     function setTokenAdmin(address _admin) public {\\r\\n      require(supportWallet == msg.sender,\\\"permision Denied\\\");\\r\\n      tokenAdmin = _admin;\\r\\n    }\\r\\n\\r\\n    function setTokenForStake(address _user,uint _tokenamount) public {\\r\\n        require(tokenAdmin == msg.sender,\\\"permision Denied\\\");\\r\\n        rewardToken.mintTokens(address(this), _tokenamount);\\r\\n        totalSupply = totalSupply.add(_tokenamount);\\r\\n        if(totalSupply >= token_price_changeOn){\\r\\n            uint increment = getTokenPriceIncrement();\\r\\n            totalSupply = 0;\\r\\n            csmTokenPrice=csmTokenPrice.add(increment);\\r\\n        }\\r\\n        principalToken[_user] = principalToken[_user].add(_tokenamount);\\r\\n        stakeTokenLogs[_user].push(stakeTokenLog(_tokenamount,block.timestamp.add(180 days)));\\r\\n    }\\r\\n\\r\\n    \\r\\n   \\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n//*******************************************************************//\\r\\n//------------------------ SafeMath Library -------------------------//\\r\\n//*******************************************************************//\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0) {\\r\\n        return 0;\\r\\n    }\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, 'SafeMath mul failed');\\r\\n    return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n    return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b <= a, 'SafeMath sub failed');\\r\\n    return a - b;\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, 'SafeMath add failed');\\r\\n    return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b == 0, 'SafeMath add failed');\\r\\n        return (a % b);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function decimals()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint8\\r\\n    );\\r\\n\\r\\n  function description()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      string memory\\r\\n    );\\r\\n\\r\\n  function version()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256\\r\\n    );\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(\\r\\n    uint80 _roundId\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"DoflushBusiness\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Group_Rewards_Program\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_amount\",\"type\":\"int256\"}],\"name\":\"TotalusdPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawalDirectIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fno\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sno\",\"type\":\"uint256\"}],\"name\":\"WithdrawalToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addFund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_usdamount\",\"type\":\"uint256\"}],\"name\":\"addtotalDownlineBussiness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"availableToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_availableToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beforeTimeclaimBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"businessLogChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"businessLogs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"matching\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupC\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ispaid\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isclaim\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"businessLogsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cps_Contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"csmTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"doResetCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eligibleForDirectBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"farmingLockPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"farmingRewardPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"farmingTokenAchive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"flushBusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"groupA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flushdate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flushCycleDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flushLogs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"matching\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCSMTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getCalculatedBnbRecieved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"getDepositInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastdate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"getDepositLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getNumberOfFrearminig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getNumberOfStakeAgainstFrearminig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_NoOfStakes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"getReInvestmentAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reInvestmentAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_TotalInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalUsers\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"getTotalStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStaked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalWithdrwan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalDownLineBusiness\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserRef\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_refcount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refStageBusiness\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"groupAIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_income\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"groupBIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_income\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"groupCIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_income\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"groupEligibilityIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_ownerWallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_spWallet\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBEP20Token\",\"name\":\"_rewardtoken\",\"type\":\"address\"}],\"name\":\"initinalizeRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_package_index\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"numbers\",\"type\":\"uint256[]\"}],\"name\":\"min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"newBusinessLogs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"matching\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"groupC\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ispaid\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isclaim\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"newBusinessLogsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numberOfFarming\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numberOfFlushLogs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numberOfstakeAgainstFarming\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plan_ref_bonuses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"principalToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"receiveGroupIncome\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ref_bonuses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"revertBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IBEP20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scheduleWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturitydate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ispaid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minner\",\"type\":\"address\"}],\"name\":\"setMinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenamount\",\"type\":\"uint256\"}],\"name\":\"setTokenForStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"settlementAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeTokenLogs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyRestart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamBusinessStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPriceIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_price_changeOn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bnbValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"onChangeValueUsd\",\"type\":\"uint256\"}],\"name\":\"updateTokenSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userStakeTokenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrwan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDownLineBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDownLineBusinessInBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBonusEligibility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTokenWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CSM_Master_v20", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}