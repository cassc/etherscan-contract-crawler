{"SourceCode": "/**\r\n * \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588    \u2588\u2588\r\n * \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588     \u2588\u2588  \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588\r\n * \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588\r\n * \u2588\u2588   \u2588\u2588 \u2588\u2588       \u2588\u2588  \u2588\u2588  \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588  \u2588\u2588     \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\r\n * \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\u2588\u2588\r\n * \r\n * @title Aurinko Network\r\n * \r\n * @notice This is a SAFU smart contract developed by Revoluzion for Aurinko Network.\r\n * \r\n * @dev This smart contract was developed based on the general\r\n * OpenZeppelin Contracts guidelines where functions revert instead of\r\n * returning `false` on failure. \r\n * \r\n * @author Revoluzion Ecosystem\r\n * @custom:email support@revoluzion.io\r\n * @custom:telegram https://t.me/RevoluzionEcosystem\r\n * @custom:website https://revoluzion.io\r\n * @custom:dapp https://revoluzion.app\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\n/********************************************************************************************\r\n  INTERFACE\r\n********************************************************************************************/\r\n\r\n/**\r\n * @title Router Interface\r\n * \r\n * @notice Interface of the Router contract, providing functions to interact with\r\n * Router contract that is derived from Uniswap V2 Router.\r\n * \r\n * @dev See https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02\r\n */\r\ninterface IRouter {\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Get the address of the Wrapped Ether (WETH) token.\r\n     * \r\n     * @return The address of the WETH token.\r\n     */\r\n    function WETH() external pure returns (address);\r\n            \r\n    /**\r\n     * @notice Get the address of the linked Factory contract.\r\n     * \r\n     * @return The address of the Factory contract.\r\n     */\r\n    function factory() external pure returns (address);\r\n\r\n    /**\r\n     * @notice Swaps an exact amount of tokens for ETH, supporting\r\n     * tokens that implement fee-on-transfer mechanisms.\r\n     * \r\n     * @param amountIn The exact amount of input tokens for the swap.\r\n     * @param amountOutMin The minimum acceptable amount of ETH to receive in the swap.\r\n     * @param path An array of token addresses representing the token swap path.\r\n     * @param to The recipient address that will receive the swapped ETH.\r\n     * @param deadline The timestamp by which the transaction must be executed to be\r\n     * considered valid.\r\n     * \r\n     * @dev This function swaps a specific amount of tokens for ETH on a specified path, \r\n     * ensuring a minimum amount of output ETH.\r\n     */\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n\r\n    /**\r\n     * @notice Swaps a precise amount of ETH for tokens, supporting tokens with fee-on-transfer mechanisms.\r\n     * \r\n     * @param amountOutMin The minimum acceptable amount of output tokens expected from the swap.\r\n     * @param path An array of token addresses representing the token swap path.\r\n     * @param to The recipient address that will receive the swapped tokens.\r\n     * @param deadline The timestamp by which the transaction must be executed to be considered valid.\r\n     * \r\n     * @dev This function performs a direct swap of a specified amount of ETH for tokens based on the provided\r\n     * path and minimum acceptable output token amount.\r\n     */\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n}\r\n\r\n/**\r\n * @title Factory Interface\r\n * \r\n * @notice Interface of the Factory contract, providing functions to interact with\r\n * Factory contract that is derived from Uniswap V2 Factory.\r\n * \r\n * @dev See https://docs.uniswap.org/contracts/v2/reference/smart-contracts/factory\r\n */\r\ninterface IFactory {\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Create a new token pair for two given tokens on Uniswap V2-based factory.\r\n     * \r\n     * @param tokenA The address of the first token.\r\n     * @param tokenB The address of the second token.\r\n     * \r\n     * @return pair The address of the created pair for the given tokens.\r\n     */\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    /**\r\n     * @notice Get the address of the pair for two tokens on the decentralized exchange.\r\n     * \r\n     * @param tokenA The address of the first token.\r\n     * @param tokenB The address of the second token.\r\n     * \r\n     * @return pair The address of the pair corresponding to the provided tokens.\r\n     */\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\n/**\r\n * @title Pair Interface\r\n * \r\n * @notice Interface of the Pair contract in a decentralized exchange based on the\r\n * Pair contract that is derived from Uniswap V2 Pair.\r\n * \r\n * @dev See https://docs.uniswap.org/contracts/v2/reference/smart-contracts/pair\r\n */\r\ninterface IPair {\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Get the address of the first token in the pair.\r\n     * \r\n     * @return The address of the first token.\r\n     */\r\n    function token0() external view returns (address);\r\n\r\n    /**\r\n     * @notice Get the address of the second token in the pair.\r\n     * \r\n     * @return The address of the second token.\r\n     */\r\n    function token1() external view returns (address);\r\n}\r\n\r\n/**\r\n * @title ERC20 Token Standard Interface\r\n * \r\n * @notice Interface of the ERC-20 standard token as defined in the ERC.\r\n * \r\n * @dev See https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    \r\n    // EVENT\r\n    \r\n    /**\r\n     * @notice Emitted when `value` tokens are transferred from\r\n     * one account (`from`) to another (`to`).\r\n     * \r\n     * @param from The address tokens are transferred from.\r\n     * @param to The address tokens are transferred to.\r\n     * @param value The amount of tokens transferred.\r\n     * \r\n     * @dev The `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @notice Emitted when the allowance of a `spender` for an `owner`\r\n     * is set by a call to {approve}.\r\n     * \r\n     * @param owner The address allowing `spender` to spend on their behalf.\r\n     * @param spender The address allowed to spend tokens on behalf of `owner`.\r\n     * @param value The allowance amount set for `spender`.\r\n     * \r\n     * @dev The `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Returns the value of tokens in existence.\r\n     * \r\n     * @return The value of the total supply of tokens.\r\n     * \r\n     * @dev This should get the total token supply.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the value of tokens owned by `account`.\r\n     * \r\n     * @param account The address to query the balance for.\r\n     * \r\n     * @return The token balance of `account`.\r\n     * \r\n     * @dev This should get the token balance of a specific account.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Moves a `value` amount of tokens from the caller's account to `to`.\r\n     * \r\n     * @param to The address to transfer tokens to.\r\n     * @param value The amount of tokens to be transferred.\r\n     * \r\n     * @return A boolean indicating whether the transfer was successful or not.\r\n     * \r\n     * @dev This should transfer tokens to a specified address and emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @notice Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}.\r\n     * \r\n     * @param owner The address allowing `spender` to spend on their behalf.\r\n     * @param spender The address allowed to spend tokens on behalf of `owner`.\r\n     * \r\n     * @return The allowance amount for `spender`.\r\n     * \r\n     * @dev The return value should be zero by default and\r\n     * changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     * \r\n     * @param spender The address allowed to spend tokens on behalf of the sender.\r\n     * @param value The allowance amount for `spender`.\r\n     * \r\n     * @return A boolean indicating whether the approval was successful or not.\r\n     * \r\n     * @dev This should approve `spender` to spend a specified amount of tokens\r\n     * on behalf of the sender and emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @notice Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's allowance.\r\n     * \r\n     * @param from The address to transfer tokens from.\r\n     * @param to The address to transfer tokens to.\r\n     * @param value The amount of tokens to be transferred.\r\n     * \r\n     * @return A boolean indicating whether the transfer was successful or not.\r\n     * \r\n     * @dev This should transfer tokens from one address to another after\r\n     * spending caller's allowance and emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title ERC20 Token Metadata Interface\r\n * \r\n * @notice Interface for the optional metadata functions of the ERC-20 standard as defined in the ERC.\r\n * \r\n * @dev It extends the IERC20 interface. See https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n\r\n    // FUNCTION\r\n    \r\n    /**\r\n     * @notice Returns the name of the token.\r\n     * \r\n     * @return The name of the token as a string.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Returns the symbol of the token.\r\n     * \r\n     * @return The symbol of the token as a string.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Returns the number of decimals used to display the token.\r\n     * \r\n     * @return The number of decimals as a uint8.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @title ERC20 Token Standard Error Interface\r\n * \r\n * @notice Interface of the ERC-6093 custom errors that defined common errors\r\n * related to the ERC-20 standard token functionalities.\r\n * \r\n * @dev See https://eips.ethereum.org/EIPS/eip-6093\r\n */\r\ninterface IERC20Errors {\r\n    \r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that the `sender` has inssufficient `balance` for the operation.\r\n     * \r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     *\r\n     * @dev The `needed` value is required to inform user on the needed amount.\r\n     */\r\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n\r\n    /**\r\n     * @notice Error indicating that the `sender` is invalid for the operation.\r\n     * \r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC20InvalidSender(address sender);\r\n    \r\n    /**\r\n     * @notice Error indicating that the `receiver` is invalid for the operation.\r\n     * \r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC20InvalidReceiver(address receiver);\r\n    \r\n    /**\r\n     * @notice Error indicating that the `spender` does not have enough `allowance` for the operation.\r\n     * \r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     * \r\n     * @dev The `needed` value is required to inform user on the needed amount.\r\n     */\r\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n    \r\n    /**\r\n     * @notice Error indicating that the `approver` is invalid for the approval operation.\r\n     * \r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC20InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @notice Error indicating that the `spender` is invalid for the allowance operation.\r\n     * \r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC20InvalidSpender(address spender);\r\n}\r\n\r\n/**\r\n * @title Common Error Interface\r\n * \r\n * @notice Interface of the common errors not specific to ERC-20 functionalities.\r\n */\r\ninterface ICommonError {\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that the `current` address cannot be used in this context.\r\n     * \r\n     * @param current Address used in the context.\r\n     */\r\n    error CannotUseCurrentAddress(address current);\r\n\r\n    /**\r\n     * @notice Error indicating that the `current` value cannot be used in this context.\r\n     * \r\n     * @param current Value used in the context.\r\n     */\r\n    error CannotUseCurrentValue(uint256 current);\r\n\r\n    /**\r\n     * @notice Error indicating that the `current` state cannot be used in this context.\r\n     * \r\n     * @param current Boolean state used in the context.\r\n     */\r\n    error CannotUseCurrentState(bool current);\r\n\r\n    /**\r\n     * @notice Error indicating that the `invalid` address provided is not a valid address for this context.\r\n     * \r\n     * @param invalid Address used in the context.\r\n     */\r\n    error InvalidAddress(address invalid);\r\n\r\n    /**\r\n     * @notice Error indicating that the `invalid` value provided is not a valid value for this context.\r\n     * \r\n     * @param invalid Value used in the context.\r\n     */\r\n    error InvalidValue(uint256 invalid);\r\n}\r\n\r\n/********************************************************************************************\r\n  ACCESS\r\n********************************************************************************************/\r\n\r\n/**\r\n * @title Ownable Contract\r\n * \r\n * @notice Abstract contract module implementing ownership functionality through\r\n * inheritance as a basic access control mechanism, where there is an owner account\r\n * that can be granted exclusive access to specific functions.\r\n * \r\n * @dev The initial owner is set to the address provided by the deployer and can\r\n * later be changed with {transferOwnership}.\r\n */\r\nabstract contract Ownable {\r\n\r\n    // DATA\r\n\r\n    address private _owner;\r\n\r\n    // MODIFIER\r\n\r\n    /**\r\n     * @notice Modifier that allows access only to the contract owner.\r\n     *\r\n     * @dev Should throw if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that the `account` is not authorized to perform an operation.\r\n     * \r\n     * @param account Address used to perform the operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @notice Error indicating that the provided `owner` address is invalid.\r\n     * \r\n     * @param owner Address used to perform the operation.\r\n     * \r\n     * @dev Should throw if called by an invalid owner account such as address(0) as an example.\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /**\r\n     * @notice Initializes the contract setting the `initialOwner` address provided by\r\n     * the deployer as the initial owner.\r\n     * \r\n     * @param initialOwner The address to set as the initial owner.\r\n     *\r\n     * @dev Should throw an error if called with address(0) as the `initialOwner`.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n    \r\n    // EVENT\r\n    \r\n    /**\r\n     * @notice Emitted when ownership of the contract is transferred.\r\n     * \r\n     * @param previousOwner The address of the previous owner.\r\n     * @param newOwner The address of the new owner.\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // FUNCTION\r\n\r\n    /**\r\n     * @notice Get the address of the smart contract owner.\r\n     * \r\n     * @return The address of the current owner.\r\n     *\r\n     * @dev Should return the address of the current smart contract owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if the caller is the owner and reverts if not.\r\n     * \r\n     * @dev Should throw if the sender is not the current owner of the smart contract.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != msg.sender) {\r\n            revert OwnableUnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Allows the current owner to renounce ownership and make the\r\n     * smart contract ownerless.\r\n     * \r\n     * @dev This function can only be called by the current owner and will\r\n     * render all `onlyOwner` functions inoperable.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    \r\n    /**\r\n     * @notice Allows the current owner to transfer ownership of the smart contract\r\n     * to `newOwner` address.\r\n     * \r\n     * @param newOwner The address to transfer ownership to.\r\n     *\r\n     * @dev This function can only be called by the current owner and will render\r\n     * all `onlyOwner` functions inoperable to him/her. Should throw if called with\r\n     * address(0) as the `newOwner`.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n    \r\n    /**\r\n     * @notice Internal function to transfer ownership of the smart contract\r\n     * to `newOwner` address.\r\n     * \r\n     * @param newOwner The address to transfer ownership to.\r\n     *\r\n     * @dev This function replace current owner address stored as _owner with \r\n     * the address of the `newOwner`.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/********************************************************************************************\r\n  TOKEN\r\n********************************************************************************************/\r\n\r\n/**\r\n * @title Aurinko Network Token Contract\r\n *\r\n * @notice Aurinko Network is an extended version of ERC-20 standard token that\r\n * includes additional functionalities for ownership control, trading enabling,\r\n * and exemption management.\r\n * \r\n * @dev Implements ERC20Metadata, ERC20Errors, and CommonError interfaces, and\r\n * extends Ownable contract.\r\n */\r\ncontract AurinkoNetwork is Ownable, IERC20Metadata, IERC20Errors, ICommonError {\r\n\r\n    // DATA\r\n\r\n    struct Fee {\r\n        uint256 marketing;\r\n    }\r\n\r\n    Fee public buyFee = Fee(200);\r\n    Fee public sellFee = Fee(200);\r\n    Fee public transferFee = Fee(200);\r\n    Fee public collectedFee = Fee(0);\r\n    Fee public redeemedFee = Fee(0);\r\n\r\n    IRouter public router = IRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    string private constant NAME = \"Aurinko Network\";\r\n    string private constant SYMBOL = \"ARK\";\r\n\r\n    uint8 private constant DECIMALS = 18;\r\n\r\n    uint256 public constant FEEDENOMINATOR = 10_000;\r\n\r\n    uint256 private _totalSupply;\r\n        \r\n    uint256 public tradeStartTime = 0;\r\n    uint256 public totalTriggerZeusBuyback = 0;\r\n    uint256 public lastTriggerZeusTimestamp = 0;\r\n    uint256 public totalFeeCollected = 0;\r\n    uint256 public totalFeeRedeemed = 0;\r\n    uint256 public minSwap = 5_000 ether;\r\n\r\n    address public projectOwner = 0x6BA557B2e13e4CdB34d8Cb546f5B9fE415B9B2fF;\r\n    address public marketingReceiver = 0x6BA557B2e13e4CdB34d8Cb546f5B9fE415B9B2fF;\r\n    \r\n    address public pair;\r\n    \r\n    bool public tradeEnabled = false;\r\n    bool public isFeeActive = false;\r\n    bool public isFeeLocked = false;\r\n    bool public isReceiverLocked = false;\r\n    bool public isSwapEnabled = false;\r\n    bool public inSwap = false;\r\n\r\n    // MAPPING\r\n\r\n    mapping(address account => uint256) private _balances;\r\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\r\n    \r\n    mapping(address pair => bool) public isPairLP;\r\n    mapping(address account => bool) public isExemptFee;\r\n\r\n    // MODIFIER\r\n    \r\n    /**\r\n     * @notice Modifier to mark the start and end of a swapping operation.\r\n     */\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    // ERROR\r\n\r\n    /**\r\n     * @notice Error indicating that an action is attempted before the cooldown period ends.\r\n     * \r\n     * @param cooldownEnd The timestamp when the cooldown period ends.\r\n     * @param timeLeft The time remaining in the cooldown period.\r\n     *\r\n     * @dev The `timeLeft` is required to inform user of the waiting period.\r\n     */\r\n    error WaitForCooldownTimer(uint256 cooldownEnd, uint256 timeLeft);\r\n\r\n    /**\r\n     * @notice Error indicating that trading has already been enabled at a specific `timestamp`.\r\n     * \r\n     * @param currentState The current state of trading.\r\n     * @param timestamp The timestamp when trading was enabled.\r\n     *\r\n     * @dev The `currentState` is required to inform user of the current state of trading.\r\n     */\r\n    error TradeAlreadyEnabled(bool currentState, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Error indicating that a certain state is already in its intended condition.\r\n     * \r\n     * @param stateType The type of state that is already in its current state.\r\n     * @param state The current state value that indicates its already active status.\r\n     *\r\n     * @dev The `currentState` is required to inform user of the current state of trading.\r\n     */\r\n    error AlreadyCurrentState(string stateType, bool state);\r\n\r\n    /**\r\n     * @notice Error indicating an invalid total fee compared to the maximum allowed.\r\n     * \r\n     * @param current The current total fee.\r\n     * @param max The maximum allowed total fee.\r\n     *\r\n     * @dev The `max` is required to inform user of the maximum value allowed.\r\n     */\r\n    error InvalidTotalFee(uint256 current, uint256 max);\r\n\r\n    /**\r\n     * @notice Error indicating an invalid amount compared to the maximum allowed.\r\n     * \r\n     * @param current The current amount used.\r\n     * @param max The maximum amount allowed to be used.\r\n     *\r\n     * @dev The `max` is required to inform user of the maximum value allowed.\r\n     */\r\n    error CannotRedeemMoreThanAllowedTreshold(uint256 current, uint256 max);\r\n\r\n    /**\r\n     * @notice Error indicating that trading has not been enabled yet.\r\n     */\r\n    error TradeNotYetEnabled();\r\n\r\n    /**\r\n     * @notice Error indicating that the native token cannot be withdrawn from the smart contract.\r\n     */\r\n    error CannotWithdrawNativeToken();\r\n\r\n    /**\r\n     * @notice Error indicating that fees have been locked and cannot be modified.\r\n     */\r\n    error FeeLocked();\r\n\r\n    /**\r\n     * @notice Error indicating that receivers have been locked and cannot be modified.\r\n     */\r\n    error ReceiverLocked();\r\n\r\n    /**\r\n     * @notice Error indicating that the receiver cannot initiate transfer of Ether.\r\n     * \r\n     * @dev Should throw if called by the receiver address.\r\n     */\r\n    error ReceiverCannotInitiateTransferEther();\r\n    \r\n    /**\r\n     * @notice Error indicating that only a wallet address is allowed to perform the action.\r\n     * \r\n     * @dev Should throw if called to use an address that is not believed to be a wallet.\r\n     */\r\n    error OnlyWalletAddressAllowed();\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /**\r\n     * @notice Constructs the Aurinko Network contract and initializes both owner\r\n     * and project owner addresses. Deployer will receive 50,000,000 tokens after\r\n     * the smart contract was deployed.\r\n     * \r\n     * @dev If deployer is not the project owner, then deployer will be exempted\r\n     * from fees along with the project owner and router.\r\n     * \r\n     * IMPORTANT: Project owner should be aware that {enableTrade} function and\r\n     * feature usually would significantly impact the audit score since these\r\n     * functions/features possess the potential for malicious exploitation,\r\n     * which might affect the received score. However, since this contract will be\r\n     * a development for SAFU smart contract under Pinksale, this could be omitted.\r\n     */\r\n    constructor() Ownable (msg.sender) {\r\n        isExemptFee[projectOwner] = true;\r\n        isExemptFee[address(router)] = true;\r\n\r\n        if (projectOwner != msg.sender) {\r\n            isExemptFee[msg.sender] = true;\r\n        }\r\n        \r\n        _mint(msg.sender, 50_000_000 * 10**DECIMALS);\r\n\r\n        pair = IFactory(router.factory()).createPair(address(this), router.WETH());\r\n        isPairLP[pair] = true;\r\n    }\r\n\r\n    // EVENT\r\n\r\n    /**\r\n     * @notice Emits when an automatic or manual redemption occurs, distributing fees\r\n     * and redeeming a specific amount.\r\n     * \r\n     * @param marketingFeeDistribution The amount distributed for marketing fees.\r\n     * @param amountToRedeem The total amount being redeemed.\r\n     * @param caller The address that triggered the redemption.\r\n     * @param timestamp The timestamp at which the redemption event occurred.\r\n     */\r\n    event AutoRedeem(uint256 marketingFeeDistribution, uint256 amountToRedeem, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the router address is updated.\r\n     * \r\n     * @param oldRouter The address of the old router.\r\n     * @param newRouter The address of the new router.\r\n     * @param caller The address that triggered the router update.\r\n     * @param timestamp The timestamp when the update occurred.\r\n     */\r\n    event UpdateRouter(address oldRouter, address newRouter, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted upon setting the status of a specific address type.\r\n     * \r\n     * @param addressType The type of address status being modified.\r\n     * @param account The address of the account whose status is being updated.\r\n     * @param oldStatus The previous exemption status.\r\n     * @param newStatus The new exemption status.\r\n     * @param caller The address that triggered the status update.\r\n     * @param timestamp The timestamp when the update occurred.\r\n     */\r\n    event SetAddressState(string addressType, address account, bool oldStatus, bool newStatus, address caller, uint256 timestamp); \r\n    \r\n    /**\r\n     * @notice Emitted when trading is enabled for the contract.\r\n     * \r\n     * @param caller The address that triggered the trading enablement.\r\n     * @param timestamp The timestamp when trading was enabled.\r\n     */\r\n    event TradeEnabled(address caller, uint256 timestamp);\r\n    \r\n    /**\r\n     * @notice Emitted when a lock is applied.\r\n     * \r\n     * @param lockType The type of lock applied.\r\n     * @param caller The address of the caller who applied the lock.\r\n     * @param timestamp The timestamp when the lock was applied.\r\n     */\r\n    event Lock(string lockType, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the minimum swap value is updated.\r\n     * \r\n     * @param oldMinSwap The old minimum swap value before the update.\r\n     * @param newMinSwap The new minimum swap value after the update.\r\n     * @param caller The address of the caller who updated the minimum swap value.\r\n     * @param timestamp The timestamp when the update occurred.\r\n     */\r\n    event UpdateMinSwap(uint256 oldMinSwap, uint256 newMinSwap, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the state of a feature is updated.\r\n     * \r\n     * @param stateType The type of state being updated.\r\n     * @param oldStatus The previous status before the update.\r\n     * @param newStatus The new status after the update.\r\n     * @param caller The address of the caller who updated the state.\r\n     * @param timestamp The timestamp when the update occurred.\r\n     */\r\n     event UpdateState(string stateType, bool oldStatus, bool newStatus, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted when the state of a feature is updated.\r\n     * \r\n     * @param feeType The type of fee being updated.\r\n     * @param oldMarketingFee The previous marketing fee value before the update.\r\n     * @param newMarketingFee The new marketing fee value after the update.\r\n     * @param caller The address of the caller who updated the fee.\r\n     * @param timestamp The timestamp when the fee update occurred.\r\n     */\r\n    event UpdateFee(string feeType, uint256 oldMarketingFee, uint256 newMarketingFee, address caller, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice Emitted upon updating a receiver address.\r\n     * \r\n     * @param receiverType The type of receiver being updated.\r\n     * @param oldReceiver The previous receiver address before the update.\r\n     * @param newReceiver The new receiver address after the update.\r\n     * @param caller The address of the caller who updated the receiver address.\r\n     * @param timestamp The timestamp when the receiver address was updated.\r\n     */\r\n    event UpdateReceiver(string receiverType, address oldReceiver, address newReceiver, address caller, uint256 timestamp);\r\n\r\n    // FUNCTION\r\n\r\n    /* General */\r\n    \r\n    /**\r\n     * @notice Allows the contract to receive Ether.\r\n     * \r\n     * @dev This is a required feature to have in order to allow the smart contract\r\n     * to be able to receive ether from the swap.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @notice Withdraws tokens or Ether from the contract to a specified address.\r\n     * \r\n     * @param tokenAddress The address of the token to withdraw.\r\n     * @param amount The amount of tokens or Ether to withdraw.\r\n     * \r\n     * @dev You need to use address(0) as `tokenAddress` to withdraw Ether and\r\n     * use 0 as `amount` to withdraw the whole balance amount in the smart contract.\r\n     * Anyone can trigger this function to send the fund to the `marketingReceiver`.\r\n     * Only `marketingReceiver` address will not be able to trigger this function to\r\n     * withdraw Ether from the smart contract by himself/herself. Should throw if try\r\n     * to withdraw any amount of native token from the smart contract. Distribution\r\n     * of native token can only be done through autoRedeem function.\r\n     */\r\n    function wTokens(address tokenAddress, uint256 amount) external {\r\n        uint256 toTransfer = amount;\r\n        address receiver = marketingReceiver;\r\n        \r\n        if (tokenAddress == address(this)) {\r\n            revert CannotWithdrawNativeToken();\r\n        } else if (tokenAddress == address(0)) {\r\n            if (amount == 0) {\r\n                toTransfer = address(this).balance;\r\n            }\r\n            if (msg.sender == receiver) {\r\n                revert ReceiverCannotInitiateTransferEther();\r\n            }\r\n            payable(receiver).transfer(toTransfer);\r\n        } else {\r\n            if (amount == 0) {\r\n                toTransfer = IERC20(tokenAddress).balanceOf(address(this));\r\n            }\r\n            require(\r\n                IERC20(tokenAddress).transfer(receiver, toTransfer),\r\n                \"WithdrawTokens: Transfer transaction might fail.\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Enables trading functionality for the token contract.\r\n     * \r\n     * @dev Only the smart contract owner can trigger this function and should throw if\r\n     * trading already enabled. Can only be triggered once and emits a TradeEnabled event\r\n     * upon successful transaction. This function also set necessary states and emitting\r\n     * an event upon success.\r\n     */\r\n    function enableTrading() external onlyOwner {\r\n        if (tradeEnabled) {\r\n            revert TradeAlreadyEnabled(tradeEnabled, tradeStartTime);\r\n        }\r\n        if (isFeeActive) {\r\n            revert AlreadyCurrentState(\"isFeeActive\", isFeeActive);\r\n        }\r\n        if (isSwapEnabled) {\r\n            revert AlreadyCurrentState(\"isSwapEnabled\", isSwapEnabled);\r\n        }\r\n        tradeEnabled = true;\r\n        isFeeActive = true;\r\n        isSwapEnabled = true;\r\n        tradeStartTime = block.timestamp;\r\n\r\n        emit TradeEnabled(msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the circulating supply of the token.\r\n     * \r\n     * @return The circulating supply of the token.\r\n     * \r\n     * @dev This should only return the token supply that is in circulation,\r\n     * which excluded the potential balance that could be in both address(0)\r\n     * and address(0xdead) that are already known to not be out of circulation.\r\n     */\r\n    function circulatingSupply() public view returns (uint256) {\r\n        return totalSupply() - balanceOf(address(0xdead)) - balanceOf(address(0));\r\n    }\r\n\r\n    /* Redeem */\r\n\r\n    /**\r\n     * @notice Initiates an automatic redemption process by distributing a specific\r\n     * amount of tokens for marketing purposes, swapping a portion for ETH. Limited\r\n     * to a maximum of 10% of circulating supply per transaction.\r\n     * \r\n     * @param amountToRedeem The amount of tokens to be redeemed and distributed\r\n     * for marketing.\r\n     * \r\n     * @dev This function calculates the distribution of tokens for marketing,\r\n     * redeems the specified amount, and triggers a swap for ETH. This function can\r\n     * be used for both auto and manual redeem of the specified amount.\r\n     */\r\n    function autoRedeem(uint256 amountToRedeem) public swapping {\r\n        if (amountToRedeem > circulatingSupply() * 1_000 / FEEDENOMINATOR) {\r\n            revert CannotRedeemMoreThanAllowedTreshold(amountToRedeem, circulatingSupply() * 1_000 / FEEDENOMINATOR);\r\n        }\r\n        uint256 marketingToRedeem = collectedFee.marketing - redeemedFee.marketing;\r\n        uint256 totalToRedeem = totalFeeCollected - totalFeeRedeemed;\r\n        \r\n        uint256 marketingFeeDistribution = amountToRedeem * marketingToRedeem / totalToRedeem;\r\n\r\n        redeemedFee.marketing += marketingFeeDistribution;\r\n        totalFeeRedeemed += amountToRedeem;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        _approve(address(this), address(router), amountToRedeem);\r\n    \r\n        emit AutoRedeem(marketingFeeDistribution, amountToRedeem, msg.sender, block.timestamp);\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            marketingFeeDistribution,\r\n            0,\r\n            path,\r\n            marketingReceiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /* Update */\r\n    \r\n    /**\r\n     * @notice Locks the fee mechanism, preventing further changes once locked.\r\n     * \r\n     * @dev This function will emits the Lock event.\r\n     */\r\n    function lockFees() external onlyOwner {\r\n        if (isFeeLocked) {\r\n            revert FeeLocked();\r\n        }\r\n        isFeeLocked = true;\r\n        emit Lock(\"isFeeLocked\", msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Locks the receivers, preventing further changes once locked.\r\n     * \r\n     * @dev This function will emits the Lock event.\r\n     */\r\n    function lockReceivers() external onlyOwner {\r\n        if (isReceiverLocked) {\r\n            revert ReceiverLocked();\r\n        }\r\n        isReceiverLocked = true;\r\n        emit Lock(\"isReceiverLocked\", msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the minimum swap value, ensuring it doesn't exceed\r\n     * a certain threshold.\r\n     * \r\n     * @param newMinSwap The new minimum swap value to be set.\r\n     * \r\n     * @dev This function will emits the UpdateMinSwap event.\r\n     */\r\n    function updateMinSwap(uint256 newMinSwap) external onlyOwner {\r\n        if (newMinSwap > circulatingSupply() * 1_000 / FEEDENOMINATOR) {\r\n            revert InvalidValue(newMinSwap);\r\n        }\r\n        if (minSwap == newMinSwap) {\r\n            revert CannotUseCurrentValue(newMinSwap);\r\n        }\r\n        uint256 oldMinSwap = minSwap;\r\n        minSwap = newMinSwap;\r\n        emit UpdateMinSwap(oldMinSwap, newMinSwap, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the status of fee activation, allowing toggling the fee mechanism.\r\n     * a certain threshold.\r\n     * \r\n     * @param newStatus The new status for fee activation.\r\n     * \r\n     * @dev This function will emits the UpdateState event.\r\n     */\r\n    function updateFeeActive(bool newStatus) external onlyOwner {\r\n        if (isFeeLocked) {\r\n            revert FeeLocked();\r\n        }\r\n        if (isFeeActive == newStatus) {\r\n            revert CannotUseCurrentState(newStatus);\r\n        }\r\n        bool oldStatus = isFeeActive;\r\n        isFeeActive = newStatus;\r\n        emit UpdateState(\"isFeeActive\", oldStatus, newStatus, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the status of swap enabling, allowing toggling the swap mechanism.\r\n     * \r\n     * @param newStatus The new status for swap enabling.\r\n     * \r\n     * @dev This function will emits the UpdateState event.\r\n     */\r\n    function updateSwapEnabled(bool newStatus) external onlyOwner {\r\n        if (isSwapEnabled == newStatus) {\r\n            revert CannotUseCurrentState(newStatus);\r\n        }\r\n        bool oldStatus = isSwapEnabled;\r\n        isSwapEnabled = newStatus;\r\n        emit UpdateState(\"isSwapEnabled\", oldStatus, newStatus, msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Allow the owner to modify marketing fee for buy transactions.\r\n     * \r\n     * @param newMarketingFee The new marketing fee percentage for buy transactions.\r\n     * \r\n     * @dev This function will emits the UpdateFee event and should throw if triggered\r\n     * with the current value or if the fee was locked.\r\n     */\r\n    function updateBuyFee(uint256 newMarketingFee) external onlyOwner {\r\n        if (isFeeLocked) {\r\n            revert FeeLocked();\r\n        }\r\n        if (newMarketingFee > 1000) {\r\n            revert InvalidTotalFee(newMarketingFee, 1000);\r\n        }\r\n        if (newMarketingFee == buyFee.marketing) {\r\n            revert CannotUseCurrentValue(newMarketingFee);\r\n        }\r\n        uint256 oldMarketingFee = buyFee.marketing;\r\n        buyFee.marketing = newMarketingFee;\r\n        emit UpdateFee(\"buyFee\", oldMarketingFee, newMarketingFee, msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Allow the owner to modify marketing fee for sell transactions.\r\n     * \r\n     * @param newMarketingFee The new marketing fee percentage for sell transactions.\r\n     * \r\n     * @dev This function will emits the UpdateFee event and should throw if triggered\r\n     * with the current value or if the fee was locked.\r\n     */\r\n    function updateSellFee(uint256 newMarketingFee) external onlyOwner {\r\n        if (isFeeLocked) {\r\n            revert FeeLocked();\r\n        }\r\n        if (newMarketingFee > 1000) {\r\n            revert InvalidTotalFee(newMarketingFee, 1000);\r\n        }\r\n        if (newMarketingFee == sellFee.marketing) {\r\n            revert CannotUseCurrentValue(newMarketingFee);\r\n        }\r\n        uint256 oldMarketingFee = sellFee.marketing;\r\n        sellFee.marketing = newMarketingFee;\r\n        emit UpdateFee(\"sellFee\", oldMarketingFee, newMarketingFee, msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Allow the owner to modify marketing fee for transfer transactions.\r\n     * \r\n     * @param newMarketingFee The new marketing fee percentage for transfer transactions.\r\n     * \r\n     * @dev This function will emits the UpdateFee event and should throw if triggered\r\n     * with the current value or if the fee was locked.\r\n     */\r\n    function updateTransferFee(uint256 newMarketingFee) external onlyOwner {\r\n        if (isFeeLocked) {\r\n            revert FeeLocked();\r\n        }\r\n        if (newMarketingFee > 1000) {\r\n            revert InvalidTotalFee(newMarketingFee, 1000);\r\n        }\r\n        if (newMarketingFee == transferFee.marketing) {\r\n            revert CannotUseCurrentValue(newMarketingFee);\r\n        }\r\n        uint256 oldMarketingFee = transferFee.marketing;\r\n        transferFee.marketing = newMarketingFee;\r\n        emit UpdateFee(\"transferFee\", oldMarketingFee, newMarketingFee, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Allow the owner to change the address receiving marketing fees.\r\n     * \r\n     * @param newMarketingReceiver The new address to receive marketing fees.\r\n     * \r\n     * @dev This function will emits the UpdateReceiver event and should throw\r\n     * if triggered with the current address or if the receiver was locked.\r\n     */\r\n    function updateMarketingReceiver(address newMarketingReceiver) external onlyOwner {\r\n        if (isReceiverLocked) {\r\n            revert ReceiverLocked();\r\n        }\r\n        if (newMarketingReceiver == address(0)) {\r\n            revert InvalidAddress(address(0));\r\n        }\r\n        if (marketingReceiver == newMarketingReceiver) {\r\n            revert CannotUseCurrentAddress(newMarketingReceiver);\r\n        }\r\n        if (newMarketingReceiver.code.length > 0) {\r\n            revert OnlyWalletAddressAllowed();\r\n        }\r\n        address oldMarketingReceiver = marketingReceiver;\r\n        marketingReceiver = newMarketingReceiver;\r\n        emit UpdateReceiver(\"marketingReceiver\", oldMarketingReceiver, newMarketingReceiver, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Allow the owner to set the status of a specified LP pair.\r\n     * \r\n     * @param lpPair The LP pair address.\r\n     * @param newStatus The new status of the LP pair.\r\n     * \r\n     * @dev This function will emits the SetAddressState event and should throw\r\n     * if triggered with the current state for the address or if the lpPair\r\n     * address is not a valid pair address.\r\n     */\r\n    function setPairLP(address lpPair, bool newStatus) external onlyOwner {\r\n        if (isPairLP[lpPair] == newStatus) {\r\n            revert CannotUseCurrentState(newStatus);\r\n        }\r\n        if (IPair(lpPair).token0() != address(this) && IPair(lpPair).token1() != address(this)) {\r\n            revert InvalidAddress(lpPair);\r\n        }\r\n        bool oldStatus = isPairLP[lpPair];\r\n        isPairLP[lpPair] = newStatus;\r\n        emit SetAddressState(\"isPairLP\", lpPair, oldStatus, newStatus, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the router address used for token swaps.\r\n     * \r\n     * @param newRouter The address of the new router contract.\r\n     * \r\n     * @dev This should also generate the pair address using the factory of the `newRouter` if\r\n     * the address of the pair on the new router's factory is address(0).If the new pair address's\r\n     * isPairLP status is not yet set to true, this function will automatically set it to true.\r\n     */\r\n    function updateRouter(address newRouter) external onlyOwner {\r\n        if (newRouter == address(router)) {\r\n            revert CannotUseCurrentAddress(newRouter);\r\n        }\r\n\r\n        address oldRouter = address(router);\r\n        router = IRouter(newRouter);\r\n\r\n        emit UpdateRouter(oldRouter, newRouter, msg.sender, block.timestamp);\r\n\r\n        if (address(IFactory(router.factory()).getPair(address(this), router.WETH())) == address(0)) {\r\n            pair = IFactory(router.factory()).createPair(address(this), router.WETH());\r\n            if (!isPairLP[pair]) {\r\n                isPairLP[pair] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the exemption status for fee on a specific account.\r\n     * \r\n     * @param user The address of the account.\r\n     * @param newStatus The new exemption status.\r\n     * \r\n     * @dev Should throw if the `newStatus` is the exact same state as the current state\r\n     * for the `user` address.\r\n     */\r\n    function updateExemptFee(address user, bool newStatus) external onlyOwner {\r\n        if (isExemptFee[user] == newStatus) { revert CannotUseCurrentState(newStatus); }\r\n        bool oldStatus = isExemptFee[user];\r\n        isExemptFee[user] = newStatus;\r\n        emit SetAddressState(\"isExemptFee\", user, oldStatus, newStatus, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /* Fee */\r\n\r\n    /**\r\n     * @notice Takes the buy fee from the specified address and amount, and distribute\r\n     * the fees accordingly.\r\n     * \r\n     * @param from The address from which the fee is taken.\r\n     * @param amount The amount from which the fee is taken.\r\n     * \r\n     * @return The new amount after deducting the fee.\r\n     */\r\n    function takeBuyFee(address from, uint256 amount) internal swapping returns (uint256) {\r\n        return takeFee(buyFee, from, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Takes the sell fee from the specified address and amount, and distribute\r\n     * the fees accordingly.\r\n     * \r\n     * @param from The address from which the fee is taken.\r\n     * @param amount The amount from which the fee is taken.\r\n     * \r\n     * @return The new amount after deducting the fee.\r\n     */\r\n    function takeSellFee(address from, uint256 amount) internal swapping returns (uint256) {\r\n        return takeFee(sellFee, from, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Takes the transfer fee from the specified address and amount, and distribute\r\n     * the fees accordingly.\r\n     * \r\n     * @param from The address from which the fee is taken.\r\n     * @param amount The amount from which the fee is taken.\r\n     * \r\n     * @return The new amount after deducting the fee.\r\n     */\r\n    function takeTransferFee(address from, uint256 amount) internal swapping returns (uint256) {\r\n        return takeFee(transferFee, from, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Takes the transfer fee from the specified address and amount, and distribute\r\n     * the fees accordingly.\r\n     * \r\n     * @param feeType The type of fee being taken.\r\n     * @param from The address from which the fee is taken.\r\n     * @param amount The amount from which the fee is taken.\r\n     * \r\n     * @return The new amount after deducting the fee.\r\n     */\r\n    function takeFee(Fee memory feeType, address from, uint256 amount) internal swapping returns (uint256) {\r\n        uint256 feeTotal = feeType.marketing;\r\n        uint256 feeAmount = amount * feeTotal / FEEDENOMINATOR;\r\n        uint256 newAmount = amount - feeAmount;\r\n        if (feeAmount > 0) {\r\n            tallyFee(feeType, from, feeAmount, feeTotal);\r\n        }\r\n        return newAmount;\r\n    }\r\n    \r\n    /**\r\n     * @notice Tally the collected fee for a given fee type and address,\r\n     * based on the amount and fee provided.\r\n     * \r\n     * @param feeType The type of fee being tallied.\r\n     * @param from The address from which the fee is collected.\r\n     * @param amount The total amount being collected as a fee.\r\n     * @param fee The total fee being collected.\r\n     */\r\n    function tallyFee(Fee memory feeType, address from, uint256 amount, uint256 fee) internal swapping {\r\n        uint256 collectMarketing = amount * feeType.marketing / fee;\r\n        tallyCollection(collectMarketing, amount);\r\n        \r\n        _update(from, address(this), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Tally the collected fee for marketing based on\r\n     * provided amounts.\r\n     * \r\n     * @param collectMarketing The amount collected for marketing fees.\r\n     * @param amount The total amount collected as a fee.\r\n     */\r\n    function tallyCollection(uint256 collectMarketing, uint256 amount) internal swapping {\r\n        collectedFee.marketing += collectMarketing;\r\n        totalFeeCollected += amount;\r\n    }\r\n\r\n    /* Buyback */\r\n\r\n    /**\r\n     * @notice Triggers a buyback with a specified amount,\r\n     * limited to 5 ether per transaction.\r\n     * \r\n     * @param amount The amount of ETH to be used for the buyback.\r\n     * \r\n     * @dev This can only be triggered by the smart contract owner.\r\n     */\r\n    function triggerZeusBuyback(uint256 amount) external onlyOwner {\r\n        if (amount > 5 ether) {\r\n            revert InvalidValue(5 ether);\r\n        }\r\n        totalTriggerZeusBuyback += amount;\r\n        lastTriggerZeusTimestamp = block.timestamp;\r\n        buyTokens(amount, address(0xdead));\r\n    }\r\n\r\n    /**\r\n     * @notice Initiates a buyback by swapping ETH for tokens.\r\n     * \r\n     * @param amount The amount of ETH to be used for the buyback.\r\n     * @param to The address to which the bought tokens will be sent.\r\n     */\r\n    function buyTokens(uint256 amount, address to) internal swapping {\r\n        if (msg.sender == address(0xdead)) { revert InvalidAddress(address(0xdead)); }\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = address(this);\r\n\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: amount\r\n        } (0, path, to, block.timestamp);\r\n    }\r\n\r\n    /* Override */\r\n    \r\n    /**\r\n     * @notice Overrides the {transferOwnership} function to update project owner.\r\n     * \r\n     * @param newOwner The address of the new owner.\r\n     * \r\n     * @dev Should throw if the `newOwner` is set to the current owner address or address(0xdead).\r\n     * This overrides function is just an extended version of the original {transferOwnership}\r\n     * function. See {Ownable-transferOwnership} for more information.\r\n     */\r\n    function transferOwnership(address newOwner) public override onlyOwner {\r\n        if (newOwner == owner()) {\r\n            revert CannotUseCurrentAddress(newOwner);\r\n        }\r\n        if (newOwner == address(0xdead)) {\r\n            revert InvalidAddress(newOwner);\r\n        }\r\n        projectOwner = newOwner;\r\n        super.transferOwnership(newOwner);\r\n    }\r\n\r\n    /* ERC20 Standard */\r\n\r\n    /**\r\n     * @notice Returns the name of the token.\r\n     * \r\n     * @return The name of the token.\r\n     * \r\n     * @dev This is usually a longer version of the name.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return NAME;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the symbol of the token.\r\n     * \r\n     * @return The symbol of the token.\r\n     * \r\n     * @dev This is usually a shorter version of the name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return SYMBOL;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of decimals used for token display purposes.\r\n     * \r\n     * @return The number of decimals.\r\n     * \r\n     * @dev This is purely used for user representation of the amount and does not\r\n     * affect any of the arithmetic of the smart contract including, but not limited\r\n     * to {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return DECIMALS;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total supply of tokens.\r\n     * \r\n     * @return The total supply of tokens.\r\n     * \r\n     * @dev See {IERC20-totalSupply} for more information.\r\n     */\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the balance of tokens for a given account.\r\n     * \r\n     * @param account The address of the account to check.\r\n     * \r\n     * @return The token balance of the account.\r\n     * \r\n     * @dev See {IERC20-balanceOf} for more information.\r\n     */\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens from the sender to a specified recipient.\r\n     * \r\n     * @param to The address of the recipient.\r\n     * @param value The amount of tokens to transfer.\r\n     * \r\n     * @return A boolean indicating whether the transfer was successful or not.\r\n     * \r\n     * @dev See {IERC20-transfer} for more information.\r\n     */\r\n    function transfer(address to, uint256 value) public virtual returns (bool) {\r\n        address provider = msg.sender;\r\n        _transfer(provider, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the allowance amount that a spender is allowed to spend on behalf of a provider.\r\n     * \r\n     * @param provider The address allowing spending.\r\n     * @param spender The address allowed to spend tokens.\r\n     * \r\n     * @return The allowance amount for the spender.\r\n     * \r\n     * @dev See {IERC20-allowance} for more information.\r\n     */\r\n    function allowance(address provider, address spender) public view virtual returns (uint256) {\r\n        return _allowances[provider][spender];\r\n    }\r\n    \r\n    /**\r\n     * @notice Approves a spender to spend a certain amount of tokens on behalf of the sender.\r\n     * \r\n     * @param spender The address allowed to spend tokens.\r\n     * @param value The allowance amount for the spender.\r\n     * \r\n     * @return A boolean indicating whether the approval was successful or not.\r\n     * \r\n     * @dev See {IERC20-approve} for more information.\r\n     */\r\n    function approve(address spender, uint256 value) public virtual returns (bool) {\r\n        address provider = msg.sender;\r\n        _approve(provider, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens from one address to another on behalf of a spender.\r\n     * \r\n     * @param from The address to transfer tokens from.\r\n     * @param to The address to transfer tokens to.\r\n     * @param value The amount of tokens to transfer.\r\n     * \r\n     * @return A boolean indicating whether the transfer was successful or not.\r\n     * \r\n     * @dev See {IERC20-transferFrom} for more information.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\r\n        address spender = msg.sender;\r\n        _spendAllowance(from, spender, value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to handle token transfers with additional checks.\r\n     * \r\n     * @param from The address tokens are transferred from.\r\n     * @param to The address tokens are transferred to.\r\n     * @param value The amount of tokens to transfer.\r\n     * \r\n     * @dev This internal function is equivalent to {transfer}, and thus can be used for other functions\r\n     * such as implementing automatic token fees, slashing mechanisms, etc. Since this function is not\r\n     * virtual, {_update} should be overridden instead. This function can only be called if the address\r\n     * for `from` and `to` are not address(0) and the sender should at least have a balance of `value`.\r\n     * It also enforces various conditions including validations for trade status, fees, exemptions,\r\n     * and redemption.\r\n     * \r\n     * IMPORTANT: Since this project implement logic for trading restriction, the transaction will only\r\n     * go through if the trade was already enabled or if the trade is still disabled, both addresses must\r\n     * be exempted from fees. Please note that this feature could significantly impact the audit score as\r\n     * since it possesses the potential for malicious exploitation, which might affect the received score.\r\n     * However, since this contract will be a development for SAFU smart contract under Pinksale, this\r\n     * could be omitted.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        if (from == address(0)) {\r\n            revert ERC20InvalidSender(address(0));\r\n        }\r\n        if (to == address(0)) {\r\n            revert ERC20InvalidReceiver(address(0));\r\n        }\r\n        if (!tradeEnabled) {\r\n            if (!isExemptFee[from] && !isExemptFee[to]) {\r\n                revert TradeNotYetEnabled();\r\n            }\r\n        }\r\n\r\n        if (inSwap || isExemptFee[from]) {\r\n            return _update(from, to, value);\r\n        }\r\n        if (from != pair && isSwapEnabled && totalFeeCollected - totalFeeRedeemed >= minSwap && balanceOf(address(this)) >= minSwap) {\r\n            autoRedeem(minSwap);\r\n        }\r\n\r\n        uint256 newValue = value;\r\n\r\n        if (isFeeActive && !isExemptFee[from] && !isExemptFee[to]) {\r\n            newValue = _beforeTokenTransfer(from, to, value);\r\n        }\r\n\r\n        _update(from, to, newValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function called before token transfer, applying fee mechanisms\r\n     * based on transaction specifics.\r\n     * \r\n     * @param from The address from which tokens are being transferred.\r\n     * @param to The address to which tokens are being transferred.\r\n     * @param amount The amount of tokens being transferred.\r\n     * \r\n     * @return The modified amount after applying potential fees.\r\n     * \r\n     * @dev This function calculates and applies fees before executing token transfers\r\n     * based on the transaction details and address types.\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal swapping virtual returns (uint256) {\r\n        if (isPairLP[from] && (buyFee.marketing > 0)) {\r\n            return takeBuyFee(from, amount);\r\n        }\r\n        if (isPairLP[to] && (sellFee.marketing > 0)) {\r\n            return takeSellFee(from, amount);\r\n        }\r\n        if (!isPairLP[from] && !isPairLP[to] && (transferFee.marketing > 0)) {\r\n            return takeTransferFee(from, amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to update token balances during transfers.\r\n     * \r\n     * @param from The address tokens are transferred from.\r\n     * @param to The address tokens are transferred to.\r\n     * @param value The amount of tokens to transfer.\r\n     * \r\n     * @dev This function is used internally to transfer a `value` amount of token from\r\n     * `from` address to `to` address. This function is also used for mints if `from`\r\n     * is the zero address and for burns if `to` is the zero address.\r\n     * \r\n     * IMPORTANT: All customizations that are required for transfers, mints, and burns\r\n     * should be done by overriding this function.\r\n\r\n     */\r\n    function _update(address from, address to, uint256 value) internal virtual {\r\n        if (from == address(0)) {\r\n            _totalSupply += value;\r\n        } else {\r\n            uint256 fromBalance = _balances[from];\r\n            if (fromBalance < value) {\r\n                revert ERC20InsufficientBalance(from, fromBalance, value);\r\n            }\r\n            unchecked {\r\n                _balances[from] = fromBalance - value;\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            unchecked {\r\n                _totalSupply -= value;\r\n            }\r\n        } else {\r\n            unchecked {\r\n                _balances[to] += value;\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, value);\r\n    }\r\n \r\n    /**\r\n     * @notice Internal function to mint tokens and update the total supply.\r\n     * \r\n     * @param account The address to mint tokens to.\r\n     * @param value The amount of tokens to mint.\r\n     * \r\n     * @dev The `account` address cannot be address(0) because it does not make any sense to mint to it.\r\n     * Since this function is not virtual, {_update} should be overridden instead for customization.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        if (account == address(0)) {\r\n            revert ERC20InvalidReceiver(address(0));\r\n        }\r\n        _update(address(0), account, value);\r\n    }\r\n \r\n    /**\r\n     * @notice Internal function to set an allowance for a `spender` to spend a specific `value` of tokens\r\n     * on behalf of a `provider`.\r\n     * \r\n     * @param provider The address allowing spending.\r\n     * @param spender The address allowed to spend tokens.\r\n     * @param value The allowance amount for the spender.\r\n     * \r\n     * @dev This internal function is equivalent to {approve}, and thus can be used for other functions\r\n     * such as setting automatic allowances for certain subsystems, etc. \r\n     * \r\n     * IMPORTANT: This function internally calls {_approve} with the emitEvent parameter set to `true`.\r\n     */\r\n    function _approve(address provider, address spender, uint256 value) internal {\r\n        _approve(provider, spender, value, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\r\n     * \r\n     * @param provider The address allowing spending.\r\n     * @param spender The address allowed to spend tokens.\r\n     * @param value The allowance amount for the spender.\r\n     * @param emitEvent A boolean indicating whether to emit the Approval event.\r\n     * \r\n     * @dev This internal function is equivalent to {approve}, and thus can be used for other functions\r\n     * such as setting automatic allowances for certain subsystems, etc. This function can only be called\r\n     * if the address for `provider` and `spender` are not address(0). If `emitEvent` is set to `true`,\r\n     * this function will emits the Approval event.\r\n     */\r\n    function _approve(address provider, address spender, uint256 value, bool emitEvent) internal virtual {\r\n        if (provider == address(0)) {\r\n            revert ERC20InvalidApprover(address(0));\r\n        }\r\n        if (spender == address(0)) {\r\n            revert ERC20InvalidSpender(address(0));\r\n        }\r\n        _allowances[provider][spender] = value;\r\n        if (emitEvent) {\r\n            emit Approval(provider, spender, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to decrease allowance when tokens are spent.\r\n     * \r\n     * @param provider The address allowing spending.\r\n     * @param spender The address allowed to spend tokens.\r\n     * @param value The amount of tokens spent.\r\n     * \r\n     * @dev If the allowance value for the `spender` is infinite/the max value of uint256,\r\n     * this function will notupdate the allowance value. Should throw if not enough allowance\r\n     * is available. On all occasion, this function will not emit an Approval event.\r\n     */\r\n    function _spendAllowance(address provider, address spender, uint256 value) internal virtual {\r\n        uint256 currentAllowance = allowance(provider, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if (currentAllowance < value) {\r\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\r\n            }\r\n            unchecked {\r\n                _approve(provider, spender, currentAllowance - value, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ERC20 Extended */\r\n\r\n    /**\r\n     * @notice Increases the allowance granted by the message sender to the spender.\r\n     * \r\n     * @param spender The address to whom the allowance is being increased.\r\n     * @param value The additional amount by which the allowance is increased.\r\n     * \r\n     * @return A boolean indicating whether the operation was successful or not.\r\n     * \r\n     * @dev Allow a spender to spend more tokens on behalf of the message sender and\r\n     * update the allowance accordingly.\r\n     */\r\n    function increaseAllowance(address spender, uint256 value) external virtual returns (bool) {\r\n        address provider = msg.sender;\r\n        uint256 currentAllowance = allowance(provider, spender);\r\n        _approve(provider, spender, currentAllowance + value, true);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @notice Decreases the allowance granted by the message sender to the spender.\r\n     * \r\n     * @param spender The address whose allowance is being decreased.\r\n     * @param value The amount by which the allowance is decreased.\r\n     * \r\n     * @return A boolean indicating whether the operation was successful or not.\r\n     * \r\n     * @dev Reduce the spender's allowance by a specified amount. Should throw if the\r\n     * current allowance is insufficient.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 value) external virtual returns (bool) {\r\n        address provider = msg.sender;\r\n        uint256 currentAllowance = allowance(provider, spender);\r\n        if (currentAllowance < value) {\r\n            revert ERC20InsufficientAllowance(spender, currentAllowance, value);\r\n        }\r\n        unchecked {\r\n            _approve(provider, spender, currentAllowance - value, true);\r\n        }\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"stateType\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"AlreadyCurrentState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"CannotRedeemMoreThanAllowedTreshold\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"CannotUseCurrentAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"current\",\"type\":\"bool\"}],\"name\":\"CannotUseCurrentState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"name\":\"CannotUseCurrentValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotWithdrawNativeToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeLocked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"invalid\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"InvalidTotalFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"invalid\",\"type\":\"uint256\"}],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyWalletAddressAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReceiverCannotInitiateTransferEther\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReceiverLocked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"currentState\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TradeAlreadyEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TradeNotYetEnabled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cooldownEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLeft\",\"type\":\"uint256\"}],\"name\":\"WaitForCooldownTimer\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingFeeDistribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToRedeem\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AutoRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lockType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"addressType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldStatus\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SetAddressState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TradeEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"feeType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMarketingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMarketingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinSwap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinSwap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateMinSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"receiverType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"stateType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldStatus\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateState\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEEDENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToRedeem\",\"type\":\"uint256\"}],\"name\":\"autoRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExemptFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFeeActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFeeLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"isPairLP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReceiverLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTriggerZeusTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpPair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"setPairLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeeCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeeRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTriggerZeusBuyback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"triggerZeusBuyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketingFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"updateExemptFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"updateFeeActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketingReceiver\",\"type\":\"address\"}],\"name\":\"updateMarketingReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinSwap\",\"type\":\"uint256\"}],\"name\":\"updateMinSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketingFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"updateSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketingFee\",\"type\":\"uint256\"}],\"name\":\"updateTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AurinkoNetwork", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://be11415f86867ac999dceb61a06c203bd98e063bb7647df5df684a5563fde63a"}