{"SourceCode": "// Sources flattened with hardhat v2.12.2 https://hardhat.org\r\n\r\n// File contracts/interfaces/FactoryType.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ninterface FactoryType {\r\n    // INTERNAL TYPE TO DESCRIBE EACH BATCH INFO\r\n    struct BatchInfo {\r\n        uint256 batchId;\r\n        uint256 count;\r\n        uint256 unlockTime;\r\n        bool claimed;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.7.3\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.7.3\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File contracts/protocols/Factory.sol\r\n\r\npragma solidity 0.8.17;\r\n\r\ncontract Factory is Ownable, FactoryType {\r\n    string public constant PROXY_FUNCTION = \"callXEN(bytes)\";\r\n    string public constant XEN_MINT_FUNCTION = \"claimRank(uint256)\";\r\n    string public constant XEN_CLAIM_FUNCTION =\r\n        \"claimMintRewardAndShare(address,uint256)\";\r\n\r\n    /// The percentage of the XEN token returned to user\r\n    uint256 public constant SHARE_PCT = 100;\r\n    uint256 public constant SECONDS_IN_DAY = 3600 * 24;\r\n\r\n    address public xen;\r\n    address public automation;\r\n    address public minterTemplate;\r\n\r\n    /// Proxy contract bytecode hash which is used to compute proxy address\r\n    bytes32 public bytecodeHash;\r\n\r\n    /// user address => batch count\r\n    mapping(address => uint256) public userBtachId;\r\n\r\n    /// user address => batch index => batch info\r\n    mapping(address => mapping(uint256 => BatchInfo)) private batchInfo;\r\n\r\n    /**\r\n     * @dev Initialize the Factory contract\r\n     */\r\n    function initialize(\r\n        address _xen,\r\n        address _minterTemplate,\r\n        address _automation\r\n    ) external {\r\n        xen = _xen;\r\n        minterTemplate = _minterTemplate;\r\n        automation = _automation;\r\n        bytecodeHash = keccak256(\r\n            abi.encodePacked(\r\n                bytes.concat(\r\n                    bytes20(0x3D602d80600A3D3981F3363d3d373d3D3D363d73),\r\n                    bytes20(_minterTemplate),\r\n                    bytes15(0x5af43d82803e903d91602b57fd5bf3)\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Set address of automation contract\r\n     */\r\n    function setAutomation(address newAutomation) external onlyOwner {\r\n        automation = newAutomation;\r\n        emit SetAutomation(newAutomation);\r\n    }\r\n\r\n    /**\r\n     * @dev Create multiple contracts to batch mint XEN token\r\n     */\r\n    function mintBatch(\r\n        address receiver,\r\n        uint256 term,\r\n        uint256 count\r\n    ) external returns (uint256 batchId) {\r\n        require(\r\n            msg.sender == tx.origin || msg.sender == automation,\r\n            \"firbidden\"\r\n        );\r\n\r\n        batchId = ++userBtachId[receiver];\r\n        batchInfo[receiver][batchId] = BatchInfo(\r\n            batchId,\r\n            count,\r\n            block.timestamp + term * SECONDS_IN_DAY,\r\n            false\r\n        );\r\n\r\n        bytes memory bytecode = bytes.concat(\r\n            bytes20(0x3D602d80600A3D3981F3363d3d373d3D3D363d73),\r\n            bytes20(minterTemplate),\r\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\r\n        );\r\n        bytes memory data = abi.encodeWithSignature(\r\n            PROXY_FUNCTION,\r\n            abi.encodeWithSignature(XEN_MINT_FUNCTION, term)\r\n        );\r\n\r\n        uint256 i;\r\n        while (i < count) {\r\n            unchecked {\r\n                ++i;\r\n            }\r\n\r\n            bytes32 salt = keccak256(abi.encodePacked(receiver, batchId, i));\r\n\r\n            assembly {\r\n                let minter := create2(\r\n                    0,\r\n                    add(bytecode, 32),\r\n                    mload(bytecode),\r\n                    salt\r\n                )\r\n                let success := call(\r\n                    gas(),\r\n                    minter,\r\n                    0,\r\n                    add(data, 0x20),\r\n                    mload(data),\r\n                    0,\r\n                    0\r\n                )\r\n            }\r\n        }\r\n\r\n        emit BatchMint(receiver, term, count, batchId);\r\n    }\r\n\r\n    /**\r\n     * @dev Call multiple contracts created for receiver to batch claim XEN\r\n     */\r\n    function claimBatch(address receiver, uint256 batchId) external {\r\n        require(\r\n            msg.sender == tx.origin || msg.sender == automation,\r\n            \"firbidden\"\r\n        );\r\n\r\n        require(batchId <= userBtachId[receiver], \"invalid batch id\");\r\n\r\n        BatchInfo memory info = batchInfo[receiver][batchId];\r\n        require(block.timestamp >= info.unlockTime, \"time is not reach\");\r\n        require(!info.claimed, \"claimed\");\r\n\r\n        info.claimed = true;\r\n        batchInfo[receiver][batchId] = info;\r\n\r\n        bytes memory proxy_data = abi.encodeWithSignature(\r\n            PROXY_FUNCTION,\r\n            abi.encodeWithSignature(XEN_CLAIM_FUNCTION, receiver, SHARE_PCT)\r\n        );\r\n\r\n        uint256 i;\r\n        while (i < info.count) {\r\n            unchecked {\r\n                ++i;\r\n            }\r\n            bytes32 salt = keccak256(abi.encodePacked(receiver, batchId, i));\r\n            address minter = address(\r\n                uint160(\r\n                    uint(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                hex\"ff\",\r\n                                address(this),\r\n                                salt,\r\n                                bytecodeHash\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n            assembly {\r\n                let success := call(\r\n                    gas(),\r\n                    minter,\r\n                    0,\r\n                    add(proxy_data, 0x20),\r\n                    mload(proxy_data),\r\n                    0,\r\n                    0\r\n                )\r\n            }\r\n        }\r\n\r\n        emit BatchClaim(receiver, batchId);\r\n    }\r\n\r\n    /**\r\n     * @notice get user batch info with specific batch id\r\n     */\r\n    function getBatchInfo(address receiver, uint256 batchId)\r\n        external\r\n        view\r\n        returns (BatchInfo memory)\r\n    {\r\n        return batchInfo[receiver][batchId];\r\n    }\r\n\r\n    // ==================== Events ====================\r\n    event SetAutomation(address automation);\r\n    event BatchMint(\r\n        address indexed receiver,\r\n        uint256 term,\r\n        uint256 count,\r\n        uint256 batchId\r\n    );\r\n    event BatchClaim(address indexed receiver, uint256 batchId);\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"BatchClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"BatchMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"automation\",\"type\":\"address\"}],\"name\":\"SetAutomation\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PROXY_FUNCTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHARE_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"XEN_CLAIM_FUNCTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"XEN_MINT_FUNCTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bytecodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"claimBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"getBatchInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"internalType\":\"struct FactoryType.BatchInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xen\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minterTemplate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_automation\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"mintBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterTemplate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAutomation\",\"type\":\"address\"}],\"name\":\"setAutomation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBtachId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xen\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Factory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://51ab7f03215aead612b7216cdf6975ec2b3a465a4ecb401bd40adb7aeb20efa5"}