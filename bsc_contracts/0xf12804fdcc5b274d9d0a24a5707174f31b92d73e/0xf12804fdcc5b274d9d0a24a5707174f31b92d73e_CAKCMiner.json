{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public _owner;\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(msg.sender, spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(\r\n            value\r\n        );\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value\r\n        );\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\ninterface ICakePool {\r\n    function deposit(uint256 _amount, uint256 _lockDuration) external;\r\n    function withdrawByAmount(uint256 _amount) external;\r\n    function userInfo(address _user) \r\n        external \r\n        view \r\n        returns (\r\n            uint256 shares, // number of shares for a user.\r\n            uint256 lastDepositedTime, // keep track of deposited time for potential penalty.\r\n            uint256 cakeAtLastUserAction, // keep track of cake deposited at the last user action.\r\n            uint256 lastUserActionTime, // keep track of the last user action time.\r\n            uint256 lockStartTime, // lock start time.\r\n            uint256 lockEndTime, // lock end time.\r\n            uint256 userBoostedShare, // boost share, in order to give the user higher reward. The user only enjoys the reward, so the principal needs to be recorded as a debt.\r\n            bool locked, //lock status.\r\n            uint256 lockedAmount // amount deposited during lock period.\r\n        );\r\n}\r\n\r\ninterface IPancakeRouter {\r\n    function getAmountsOut(uint amountIn, address[] memory path)\r\n        external \r\n        view\r\n        returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ncontract CAKCMiner is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 private MAX = ~uint256(0);\r\n    //init TOKEN price\r\n    uint256 private INITIALPRICE = 1 * 10 ** 17;\r\n    //range price\r\n    uint256 private RANGEPRICE = 1 * 10 ** 23;\r\n    //total buy tickets amount\r\n    uint256 public tvlTickets;\r\n    //total invest amount\r\n    uint256 public tvlInvest;\r\n    //total burn amount\r\n    uint256 public tvlBurn;\r\n    //invest burn fee\r\n    uint256 public burnFee = 500;\r\n    //invest burn address\r\n    address public burnAddr;\r\n\r\n    mapping(address => uint256) private invests;\r\n    mapping(address => address) private inviter;\r\n    mapping(address => address[]) private inviterSuns;\r\n\r\n    address private constant USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n    IERC20 private constant CAKE = IERC20(address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82));\r\n    IERC20 private constant TOKEN = IERC20(address(0x668D09f708fd000cdd09495E9B318fac6619a615));\r\n    ICakePool public constant CAKEPOOL = ICakePool(address(0x45c54210128a065de780C4B0Df3d16664f7f859e));\r\n    IPancakeRouter PANCAKEROUTER = IPancakeRouter(address(0x10ED43C718714eb63d5aA57B78B54704E256024E));\r\n\r\n    event Bind(address indexed user, address indexed inviter);\r\n    event BuyTickets(address indexed user, uint256 amountA, uint256 amountB);\r\n    event Invest(address indexed user, uint256 amountA, uint256 amountB);\r\n    event WC(address indexed user, uint256 amount);\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n        \r\n        burnAddr = msg.sender;\r\n\r\n        CAKE.approve(address(CAKEPOOL), MAX);\r\n    }\r\n\r\n    //to recieve ETH from uniswapV2Router when swaping\r\n    receive() external payable {}\r\n\r\n    function invite(address parent) external returns (bool) {\r\n        require(inviter[msg.sender] == address(0), \"Invite: user has invited\");\r\n        require(inviter[parent] != address(0), \"Invite: parent is not bind\");\r\n\r\n        inviter[msg.sender] = parent;\r\n        inviterSuns[parent].push(msg.sender);\r\n\r\n        emit Bind(msg.sender, parent);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getInviter(address user) external view returns (address) {\r\n        return inviter[user];\r\n    }\r\n\r\n    function SetInviteByAdmin(address user, address parent) external onlyOwner returns (bool) {\r\n        require(inviter[user] == address(0), \"Already bind\");\r\n        inviter[user] = parent;\r\n        inviterSuns[parent].push(user);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getInviterSuns(address user)\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return inviterSuns[user];\r\n    }\r\n\r\n    function getInviterSunSize(address user) external view returns (uint256) {\r\n        return inviterSuns[user].length;\r\n    }\r\n\r\n    function getInvest(address user) external view returns (uint256) {\r\n        return invests[user];\r\n    }\r\n\r\n    function buyTickets(uint256 amountA) external returns (bool) {\r\n\r\n        uint256 amountB = swapEForB(amountA);\r\n\r\n        tvlTickets = amountB.add(tvlTickets);\r\n\r\n        CAKE.safeTransferFrom(msg.sender, address(this), amountA);\r\n        \r\n        TOKEN.safeTransfer(msg.sender, amountB);\r\n\r\n        CAKEPOOL.deposit(amountA, 0);\r\n\r\n        emit BuyTickets(msg.sender, amountA, amountB);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getBPrice() public view returns (uint256) {\r\n        uint256 price = INITIALPRICE;\r\n\r\n        uint256 index = tvlTickets.div(RANGEPRICE);\r\n        for (uint256 i = 0; i < index; i++) {\r\n            price = price.div(10).add(price);\r\n        }\r\n\r\n        return price;\r\n    }\r\n\r\n    function swapEForB(uint256 amountIn) public view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(CAKE);\r\n        path[1] = USDT;\r\n\r\n        uint256[] memory amounts = PANCAKEROUTER.getAmountsOut(amountIn, path);\r\n\r\n        uint256 amountOut = amounts[1].mul(1e18).div(getBPrice());\r\n\r\n        return amountOut;\r\n\r\n    }\r\n\r\n    function invest(uint256 amountA) external returns (bool) {\r\n        require(inviter[msg.sender] != address(0), \"user is not bind\");\r\n\r\n        invests[msg.sender] = invests[msg.sender].add(amountA);\r\n\r\n        tvlInvest = amountA.add(tvlInvest);\r\n\r\n        uint256 amountB = swapEForB(amountA.mul(burnFee).div(10000));\r\n\r\n        tvlBurn = amountB.add(tvlBurn);\r\n\r\n        TOKEN.safeTransferFrom(msg.sender, burnAddr, amountB);\r\n\r\n        CAKE.safeTransferFrom(msg.sender, address(this), amountA);\r\n\r\n        CAKEPOOL.deposit(amountA, 0);\r\n\r\n        emit Invest(msg.sender, amountA, amountB);\r\n\r\n        return true;\r\n    }\r\n\r\n    function changeBurnFee(uint256 fee) external onlyOwner returns (bool) {\r\n        burnFee = fee;\r\n\r\n        return true;\r\n    }\r\n\r\n    function changeBurnAddr(address addr) external onlyOwner returns (bool) {\r\n        burnAddr = addr;\r\n\r\n        return true;\r\n    }\r\n\r\n    function wc(address user, uint256 amount) external onlyOwner() returns (bool) {\r\n        (uint256 shares, , , , , , , , ) = CAKEPOOL.userInfo(address(this));\r\n\r\n        require(shares >= amount, \"bigger amount\");\r\n\r\n        CAKEPOOL.withdrawByAmount(amount);\r\n\r\n        if (CAKE.balanceOf(address(this)) > amount) {\r\n            CAKE.safeTransfer(user, amount);\r\n        } else {\r\n            CAKE.safeTransfer(user, CAKE.balanceOf(address(this)));\r\n        }\r\n\r\n        emit WC(user, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function rescueToken(\r\n        address token,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        IERC20(token).transfer(recipient, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"Bind\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"BuyTickets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WC\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CAKEPOOL\",\"outputs\":[{\"internalType\":\"contract ICakePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"}],\"name\":\"SetInviteByAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"}],\"name\":\"buyTickets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeBurnAddr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"changeBurnFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getInvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getInviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getInviterSunSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getInviterSuns\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"}],\"name\":\"invite\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"swapEForB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tvlBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tvlInvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tvlTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wc\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CAKCMiner", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a6c26a1e9498db63b9a0fa79f940a6405674f6f52e7587bff1045b69b9047a40"}