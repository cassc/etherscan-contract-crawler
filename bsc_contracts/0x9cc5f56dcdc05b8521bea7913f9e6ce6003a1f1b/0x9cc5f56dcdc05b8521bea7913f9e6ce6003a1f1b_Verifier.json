{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\ncontract Verifier {\r\n    // Scalar field size\r\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    // Base field size\r\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    // Verification Key data\r\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\r\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\r\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\r\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\r\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\r\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\r\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\r\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\r\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\r\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\r\n    uint256 constant deltax1 = 4279206304898316236100034083988815584412013399274817078792880912599905686232;\r\n    uint256 constant deltax2 = 12941333110246055381083029204376371234521470612555233549206395019057358324499;\r\n    uint256 constant deltay1 = 15660690256145008705577648628853902621689785743156680297186611342246311040440;\r\n    uint256 constant deltay2 = 11298011573375829500527133038757936951637313830084311750935041313652713155857;\r\n\r\n    \r\n    uint256 constant IC0x = 15744513443685431653489977124559316775589144373101905215540098362271682264636;\r\n    uint256 constant IC0y = 6181230803245730221322895786403215897209999458320708362064389956730848313282;\r\n    \r\n    uint256 constant IC1x = 5670333109040999605532207042029676573423810467263412828429337280223735635438;\r\n    uint256 constant IC1y = 9045718617374033938334534148199950652277581363725131126977514795832489383597;\r\n    \r\n    uint256 constant IC2x = 7940035212217149489091346041223742733332700278746355412134158794768275581053;\r\n    uint256 constant IC2y = 2615144925918320500366689068819061138649445255385146685020394785891745898436;\r\n    \r\n \r\n    // Memory data\r\n    uint16 constant pVk = 0;\r\n    uint16 constant pPairing = 128;\r\n\r\n    uint16 constant pLastMem = 896;\r\n\r\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[2] calldata _pubSignals) public view returns (bool) {\r\n        assembly {\r\n            function checkField(v) {\r\n                if iszero(lt(v, q)) {\r\n                    mstore(0, 0)\r\n                    return(0, 0x20)\r\n                }\r\n            }\r\n            \r\n            // G1 function to multiply a G1 value(x,y) to value in an address\r\n            function g1_mulAccC(pR, x, y, s) {\r\n                let success\r\n                let mIn := mload(0x40)\r\n                mstore(mIn, x)\r\n                mstore(add(mIn, 32), y)\r\n                mstore(add(mIn, 64), s)\r\n\r\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\r\n\r\n                if iszero(success) {\r\n                    mstore(0, 0)\r\n                    return(0, 0x20)\r\n                }\r\n\r\n                mstore(add(mIn, 64), mload(pR))\r\n                mstore(add(mIn, 96), mload(add(pR, 32)))\r\n\r\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\r\n\r\n                if iszero(success) {\r\n                    mstore(0, 0)\r\n                    return(0, 0x20)\r\n                }\r\n            }\r\n\r\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\r\n                let _pPairing := add(pMem, pPairing)\r\n                let _pVk := add(pMem, pVk)\r\n\r\n                mstore(_pVk, IC0x)\r\n                mstore(add(_pVk, 32), IC0y)\r\n\r\n                // Compute the linear combination vk_x\r\n                \r\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\r\n                \r\n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\r\n                \r\n\r\n                // -A\r\n                mstore(_pPairing, calldataload(pA))\r\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\r\n\r\n                // B\r\n                mstore(add(_pPairing, 64), calldataload(pB))\r\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\r\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\r\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\r\n\r\n                // alpha1\r\n                mstore(add(_pPairing, 192), alphax)\r\n                mstore(add(_pPairing, 224), alphay)\r\n\r\n                // beta2\r\n                mstore(add(_pPairing, 256), betax1)\r\n                mstore(add(_pPairing, 288), betax2)\r\n                mstore(add(_pPairing, 320), betay1)\r\n                mstore(add(_pPairing, 352), betay2)\r\n\r\n                // vk_x\r\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\r\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\r\n\r\n\r\n                // gamma2\r\n                mstore(add(_pPairing, 448), gammax1)\r\n                mstore(add(_pPairing, 480), gammax2)\r\n                mstore(add(_pPairing, 512), gammay1)\r\n                mstore(add(_pPairing, 544), gammay2)\r\n\r\n                // C\r\n                mstore(add(_pPairing, 576), calldataload(pC))\r\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\r\n\r\n                // delta2\r\n                mstore(add(_pPairing, 640), deltax1)\r\n                mstore(add(_pPairing, 672), deltax2)\r\n                mstore(add(_pPairing, 704), deltay1)\r\n                mstore(add(_pPairing, 736), deltay2)\r\n\r\n\r\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\r\n\r\n                isOk := and(success, mload(_pPairing))\r\n            }\r\n\r\n            let pMem := mload(0x40)\r\n            mstore(0x40, add(pMem, pLastMem))\r\n\r\n            // Validate that all evaluations \u2208 F\r\n            \r\n            checkField(calldataload(add(_pubSignals, 0)))\r\n            \r\n            checkField(calldataload(add(_pubSignals, 32)))\r\n            \r\n            checkField(calldataload(add(_pubSignals, 64)))\r\n            \r\n\r\n            // Validate all evaluations\r\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\r\n\r\n            mstore(0, isValid)\r\n             return(0, 0x20)\r\n         }\r\n     }\r\n }", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"_pA\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"_pB\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_pC\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_pubSignals\",\"type\":\"uint256[2]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Verifier", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8e34bd3f117a6c57f339a676ee1b61eac75b22b42bb1371c16209c4c231188ee"}