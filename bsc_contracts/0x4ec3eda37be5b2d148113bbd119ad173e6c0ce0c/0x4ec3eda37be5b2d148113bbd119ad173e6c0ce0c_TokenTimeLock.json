{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Claimable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.2;\\n// SPDX-License-Identifier: MIT\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\ncontract Claimable {\\n\\n    modifier validAddress(address _to) {\\n        require(_to != address(0));\\n        _;\\n    }\\n    function _claimValues(address token_, address to_) internal validAddress(to_) {\\n        if (token_ == address(0)) {\\n            _claimNativeCoins(to_);\\n        } else {\\n            _claimErc20Tokens(token_, to_);\\n        }\\n    }\\n\\n    function _claimNativeCoins(address to_) internal {\\n        uint256 value = address(this).balance;\\n        _sendValue(payable(to_), value);\\n    }\\n\\n    function _claimErc20Tokens(address token_, address to_) internal {\\n        IERC20 _ERC20 = IERC20(token_);\\n        uint256 balance = _ERC20.balanceOf(address(this));\\n        _ERC20.transfer(to_, balance);\\n    }\\n\\n    function _sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n        (bool success,) = recipient.call{value : amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.2;\\n// SPDX-License-Identifier: MIT\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/TokenTimeLock.sol\": {\r\n      \"content\": \"// contracts/TokenTimeLock.sol\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\nimport \\\"./Claimable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @title TokenTimeLock\\n */\\ncontract TokenTimeLock is Claimable {\\n    using SafeMath for uint256;\\n    address[] private _beneficiaryList;\\n    uint256 private _start;\\n    uint256 private _stages;\\n    uint256 private _interval;\\n    uint256 private _released;\\n    address private  _token;\\n    address private _owner;\\n\\n    event Released(uint256 amount);\\n\\n    fallback() external payable {\\n\\n    }\\n\\n    receive() external payable {\\n\\n    }\\n\\n    constructor(\\n        address[]memory beneficiaryList_,\\n        uint256 start_,\\n        uint256 stages_,\\n        uint256 interval_,\\n        address token_\\n    ){\\n        require(beneficiaryList_.length > 0, \\\"beneficiaryList is empty\\\");\\n        _beneficiaryList = beneficiaryList_;\\n        _start = start_;\\n        _stages = stages_;\\n        _interval = interval_;\\n        _token = token_;\\n        _owner = msg.sender;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function token() public view virtual returns (address) {\\n        return _token;\\n    }\\n\\n    function start() public view virtual returns (uint256) {\\n        return _start;\\n    }\\n\\n    function stages() public view virtual returns (uint256) {\\n        return _stages;\\n    }\\n\\n    function interval() public view virtual returns (uint256) {\\n        return _interval;\\n    }\\n\\n    function beneficiaryList() public view virtual returns (address[] memory) {\\n        return _beneficiaryList;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function releasableAmount() public view returns (uint256) {\\n        uint256 currentBalance = IERC20(_token).balanceOf(address(this));\\n        if (block.timestamp < _start) {\\n            return 0;\\n        } else if (block.timestamp >= _start.add(_stages.mul(_interval))) {\\n            return currentBalance;\\n        } else {\\n            uint256 totalBalance = currentBalance.add(_released);\\n            uint256 amountTmp = totalBalance\\n            .mul(block.timestamp.sub(_start).div(_interval))\\n            .div(_stages);\\n            return amountTmp.sub(_released);\\n        }\\n    }\\n\\n    function release() public virtual {\\n        uint256 unreleased = releasableAmount();\\n        require(unreleased > 0, \\\"TokenTimeLock: no to release\\\");\\n        _released = _released.add(unreleased);\\n        uint256 averageAmount = unreleased.div(_beneficiaryList.length);\\n        uint256 diff = unreleased.sub(averageAmount.mul(_beneficiaryList.length));\\n        uint256 randomIndex = 0;\\n        if (diff > 0) {\\n            randomIndex = _random(_beneficiaryList.length);\\n        }\\n        for (uint256 i = 0; i < _beneficiaryList.length; i++) {\\n            uint256 amount = averageAmount;\\n            if (diff > 0 && i == randomIndex) {\\n                amount = amount.add(diff);\\n            }\\n            if (amount > 0) {\\n                IERC20(_token).transfer(_beneficiaryList[i], amount);\\n            }\\n        }\\n        emit Released(unreleased);\\n    }\\n\\n    function _random(uint256 count_) public view returns (uint256) {\\n        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));\\n        return random % count_;\\n    }\\n\\n    function claimValues(address token_, address to_) public virtual onlyOwner {\\n        require(token_ != _token, \\\"token is error\\\");\\n        _claimValues(token_, to_);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"beneficiaryList_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"start_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stages_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count_\",\"type\":\"uint256\"}],\"name\":\"_random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiaryList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"claimValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releasableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenTimeLock", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000673bd5000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000076a7000000000000000000000000007ebeaff3b53a63ed26c476d761866d4eb84c217e00000000000000000000000000000000000000000000000000000000000000050000000000000000000000002a3eb618367197ab2d290b322e2b143f5016ddb40000000000000000000000007344b0019b1dc6e4b7412d908b2b1f588cfd64170000000000000000000000006a0a90c0d0ad4cfaf2458eac6af4a03ffeb9411c00000000000000000000000077809e66c944a120834123f2a41519a794c527bc00000000000000000000000053c75cf87aede1b418123dc7b7447c0df49ba2ae", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}