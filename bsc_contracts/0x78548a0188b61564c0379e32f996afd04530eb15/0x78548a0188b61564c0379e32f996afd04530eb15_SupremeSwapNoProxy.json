{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPermit {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISupport.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IFactory {\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n}\\n\\ninterface IPriceAggregator {\\n    function swap(address)\\n        external\\n        returns (uint256 swappedAmount, address swappedToken);\\n}\\n\\ninterface IPair {\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function token0() external view returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV1Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    // ---\\n\\n    function swapExactBNBForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function swapTokensForExactBNB(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactTokensForBNB(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapBNBForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IUniswapV2Router01} from \\\"./IUniswapV1Router.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactBNBForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForBNBSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/SupremeSwapNoProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport {IPermit} from \\\"./interfaces/IPermit.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./interfaces/IUniswapV2Router.sol\\\";\\nimport \\\"./interfaces/ISupport.sol\\\";\\nimport {SwapParams, DEXParams, Response} from \\\"./Types/types.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/**\\n    @notice SupremeSwap: This contract allows users to find the best path between two tokens that would give the maximum possible\\n    return for a swap and does the swap as well.\\n    @dev The path finding algorithm can be found in the form of `view` functions and rest all are related to swapping\\n */\\ncontract SupremeSwapNoProxy is ReentrancyGuard {\\n    event Swap(address token1, address token2, uint256 amount);\\n    /** \\n        @notice WETH address for BSC chain\\n    */\\n    address private WETH;\\n    /**\\n        @dev MAX_DEPTH represents the maximum depth we're willing to go to find the path of trade\\n        E.g. Input -> Token1 -> Token2 -> Output, here depth = 2 (which is the max depth we go right now) \\n    */\\n    uint256 private MAX_DEPTH;\\n\\n    /// @notice ___gap variable to avoid storage clashes\\n    uint256[49] private __gap;\\n\\n    /**\\n        @notice sets the aforementioned variables\\n    */\\n    constructor(uint256 _MAX_DEPTH, address _WETH) {\\n        MAX_DEPTH = _MAX_DEPTH;\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n        @notice Swap function that will allow us to swap the entire path of the token to reach a particular output (token)\\n        @dev A list of `SwapParams` struct are passed, each of which contains enough information to do a swap between a pair of tokens.\\n        The next SwapParams then does the next swap in the queue until all are complete and desired out tokens are received.\\n        @param _sParams A list of `SwapParams` struct\\n    */\\n    function swap(SwapParams[] memory _sParams) external payable nonReentrant {\\n        uint256 pathLength = _sParams.length;\\n\\n        // Perform swap only once if array length is 1\\n        if (pathLength == 1) {\\n            _sParams[0].to = msg.sender;\\n            singleSwap(_sParams[0], msg.sender);\\n        }\\n        require(\\n            pathLength <= MAX_DEPTH,\\n            \\\"SupremeSwap: Max path length exceeded\\\"\\n        );\\n\\n        // Perform multiple swaps\\n        if (pathLength > 1) {\\n            uint256 beforeBalance;\\n            uint256 afterBalance;\\n            for (uint64 i = 0; i < pathLength; ) {\\n                beforeBalance = IERC20(_sParams[i].path[1]).balanceOf(\\n                    address(this)\\n                );\\n                if (i == pathLength - 1) {\\n                    _sParams[i].to = msg.sender;\\n                    singleSwap(_sParams[i], address(this));\\n                } else if (i == 0) {\\n                    _sParams[i].to = address(this);\\n                    singleSwap(_sParams[i], msg.sender);\\n                    afterBalance = IERC20(_sParams[i].path[1]).balanceOf(\\n                        address(this)\\n                    );\\n                    _sParams[i + 1].amountIn = afterBalance - beforeBalance;\\n                } else {\\n                    _sParams[i].to = address(this);\\n                    singleSwap(_sParams[i], address(this));\\n                    afterBalance = IERC20(_sParams[i].path[1]).balanceOf(\\n                        address(this)\\n                    );\\n                    _sParams[i + 1].amountIn = afterBalance - beforeBalance;\\n                }\\n\\n                unchecked {\\n                    i++;\\n                }\\n            }\\n        }\\n        emit Swap(\\n            _sParams[0].path[0],\\n            _sParams[pathLength - 1].path[1],\\n            _sParams[0].amountIn\\n        );\\n    }\\n\\n    /**\\n        @notice Function to do one swap at a time\\n        @param _params A struct containing all the necessary variables to do a swap on the given pair\\n        @param _to The address that will be sending the tokens to this address to swap (if required, not in case of native coin)\\n    */\\n    function singleSwap(SwapParams memory _params, address _to) private {\\n        if (_params.isETHSwap == true) {\\n            if (_params.path[0] != WETH) {\\n                // this contract approving the router contract to spend _amountIn\\n                IERC20(_params.path[0]).approve(\\n                    address(_params.router),\\n                    _params.amountIn\\n                );\\n                if (_to != address(this)) {\\n                    IERC20(_params.path[0]).transferFrom(\\n                        _to,\\n                        address(this),\\n                        _params.amountIn\\n                    );\\n                }\\n            }\\n            swapEthAndToken(_params);\\n        } else {\\n            if (_to != address(this)) {\\n                uint256 beforeBalance = IERC20(_params.path[0]).balanceOf(\\n                    address(this)\\n                );\\n                IERC20(_params.path[0]).transferFrom(\\n                    _to,\\n                    address(this),\\n                    _params.amountIn\\n                );\\n                // Use the amount that got in the contract\\n                uint256 afterBalance = IERC20(_params.path[0]).balanceOf(\\n                    address(this)\\n                );\\n                // Check if the token supports fee on transfer or not\\n                if (!_params.supportFee) {\\n                    require(\\n                        (afterBalance - beforeBalance) == _params.amountIn,\\n                        \\\"SupremeSwap: Invalid fee flag\\\"\\n                    );\\n                } else {\\n                    _params.amountIn = afterBalance - beforeBalance;\\n                }\\n            }\\n\\n            // this contract approving the router contract to spend _amountIn\\n            IERC20(_params.path[0]).approve(\\n                address(_params.router),\\n                _params.amountIn\\n            );\\n            swapTokenAndToken(_params);\\n        }\\n    }\\n\\n    /**\\n        @notice A helper function do a swap between token and ETH\\n    */\\n    function swapEthAndToken(SwapParams memory _params) private {\\n        // Eth and token pair combinations\\n        if (_params.path[0] == WETH && _params.supportFee) {\\n            if (_params.isBNBRouterInterface) {\\n                _params\\n                    .router\\n                    .swapExactBNBForTokensSupportingFeeOnTransferTokens{\\n                    value: _params.amountIn\\n                }(\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            } else {\\n                _params\\n                    .router\\n                    .swapExactETHForTokensSupportingFeeOnTransferTokens{\\n                    value: _params.amountIn\\n                }(\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            }\\n        } else if (\\n            _params.path[0] != WETH &&\\n            _params.supportFee == true &&\\n            _params.inputExact == true\\n        ) {\\n            if (_params.isBNBRouterInterface) {\\n                _params\\n                    .router\\n                    .swapExactTokensForBNBSupportingFeeOnTransferTokens(\\n                        _params.amountIn,\\n                        _params.amountOutMin,\\n                        _params.path,\\n                        _params.to,\\n                        _params.deadline\\n                    );\\n            } else {\\n                _params\\n                    .router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        _params.amountIn,\\n                        _params.amountOutMin,\\n                        _params.path,\\n                        _params.to,\\n                        _params.deadline\\n                    );\\n            }\\n        } else if (\\n            _params.path[0] == WETH && !_params.supportFee && _params.inputExact\\n        ) {\\n            if (_params.isBNBRouterInterface) {\\n                _params.router.swapExactBNBForTokens{value: _params.amountIn}(\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            } else {\\n                _params.router.swapExactETHForTokens{value: _params.amountIn}(\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            }\\n        } else if (\\n            _params.path[0] != WETH &&\\n            !_params.supportFee &&\\n            !_params.inputExact\\n        ) {\\n            if (_params.isBNBRouterInterface) {\\n                _params.router.swapTokensForExactBNB(\\n                    _params.amountOutMin,\\n                    _params.amountIn,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            } else {\\n                _params.router.swapTokensForExactETH(\\n                    _params.amountOutMin,\\n                    _params.amountIn,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            }\\n        } else if (\\n            _params.path[0] == WETH &&\\n            !_params.supportFee &&\\n            !_params.inputExact\\n        ) {\\n            if (_params.isBNBRouterInterface) {\\n                _params.router.swapBNBForExactTokens{value: _params.amountIn}(\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            } else {\\n                _params.router.swapETHForExactTokens{value: _params.amountIn}(\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            }\\n        } else if (\\n            _params.path[0] != WETH && !_params.supportFee && _params.inputExact\\n        ) {\\n            if (_params.isBNBRouterInterface) {\\n                _params.router.swapExactTokensForBNB(\\n                    _params.amountIn,\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            } else {\\n                _params.router.swapExactTokensForETH(\\n                    _params.amountIn,\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n            }\\n        } else {\\n            revert(\\\"SupremeSwap: Invalid Params\\\");\\n        }\\n    }\\n\\n    /**\\n        @notice A helper function do a swap between token and ETH\\n    */\\n    function swapTokenAndToken(SwapParams memory _params) private {\\n        // Token to token combinations\\n        if (_params.supportFee) {\\n            _params\\n                .router\\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n                    _params.amountIn,\\n                    _params.amountOutMin,\\n                    _params.path,\\n                    _params.to,\\n                    _params.deadline\\n                );\\n        } else if (!_params.supportFee && !_params.inputExact) {\\n            _params.router.swapTokensForExactTokens(\\n                _params.amountOutMin,\\n                _params.amountIn,\\n                _params.path,\\n                _params.to,\\n                _params.deadline\\n            );\\n        } else if (!_params.supportFee && _params.inputExact) {\\n            _params.router.swapExactTokensForTokens(\\n                _params.amountIn,\\n                _params.amountOutMin,\\n                _params.path,\\n                _params.to,\\n                _params.deadline\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Types/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IUniswapV2Router02} from \\\"../interfaces/IUniswapV2Router.sol\\\";\\nimport \\\"../interfaces/ISupport.sol\\\";\\n\\nstruct SwapParams {\\n    IUniswapV2Router02 router;\\n    bool isETHSwap;\\n    bool supportFee;\\n    bool inputExact;\\n    uint256 amountIn;\\n    uint256 amountOutMin;\\n    uint256 deadline;\\n    address[] path;\\n    address to;\\n    bool isBNBRouterInterface;\\n}\\nstruct DEXParams {\\n    IUniswapV2Router02 router;\\n    IFactory factory;\\n}\\n\\nstruct Response {\\n    uint256 maxAmt;\\n    uint256 maxAmt1;\\n    uint256 maxAmt2;\\n    address[3] router;\\n    address pathAddr1;\\n    address pathAddr2;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_MAX_DEPTH\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isETHSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"supportFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"inputExact\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBNBRouterInterface\",\"type\":\"bool\"}],\"internalType\":\"struct SwapParams[]\",\"name\":\"_sParams\",\"type\":\"tuple[]\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SupremeSwapNoProxy", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "50", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}