{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/markfrance/HBSC/HBSCNew/contracts/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the BEP20 standard as defined in the EIP.\\n */\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/Users/markfrance/HBSC/HBSCNew/contracts/IHBSC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the BEP20 standard as defined in the EIP.\\n */\\ninterface IHBSC {\\n\\t function mintTo(address to, uint256 amount) external;\\n\\t function approve(address spender, uint256 amount) external returns (bool);\\n\\t function allowance(address owner, address spender) external view returns (uint256);\\n\\t function balanceOf(address account) external view returns (uint256);\\n\\t function burnTokens(uint256 amount) external returns (bool);\\n\\t function transfer(address recipient, uint256 amount) external returns (bool);\\n\\t function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\"\r\n    },\r\n    \"/Users/markfrance/HBSC/HBSCNew/contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/markfrance/HBSC/HBSCNew/contracts/staking/HBSCStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../SafeMath.sol\\\";\\nimport \\\"../IHBSC.sol\\\";\\nimport \\\"../IBEP20.sol\\\";\\n/**\\n * @title HBSC Staking Contract\\n */\\ncontract HBSCStake {\\n\\n    using SafeMath for uint256;\\n\\n    struct Staked{\\n        uint256 Stake0StartTimestamp;\\n        uint256 Stake180StartTimestamp;\\n        uint256 Stake270StartTimestamp;\\n        uint256 Stake365StartTimestamp;\\n    }\\n\\n    //rate is APY / 365 * rateDecimals\\n    uint256 public initialRate0;  //0.35% = 958\\n    uint256 public initialRate180; //0.525% = 1438\\n    uint256 public initialRate270; //0.875% = 2397\\n    uint256 public initialRate365; // 1.75% = 4794\\n    uint256 public rateDecimals = 100000000;\\n    uint256 public daySeconds = 86400; \\n    uint256 public totalStaked;\\n    uint256 public total0Staked;\\n    uint256 public total180Staked;\\n    uint256 public total270Staked;\\n    uint256 public total365Staked;\\n    bool private sync;\\n    address public hbscAddress;\\n    IHBSC hbscToken;\\n    address public adminWallet;\\n    address devWallet;\\n    address owner;\\n  \\n    mapping(address => uint256) public token0StakedBalances;\\n    mapping(address => uint256) public token180StakedBalances;\\n    mapping(address => uint256) public token270StakedBalances;\\n    mapping(address => uint256) public token365StakedBalances;\\n    mapping(address => uint256) public lastClaimed;\\n    mapping(address => Staked) public staked;\\n\\n    event TokenStake(\\n        address user,\\n        uint value,\\n        uint length\\n    );\\n\\n    event TokenUnStake(\\n        address user,\\n        uint value,\\n        uint length\\n    );\\n\\n    event DividendsClaimed(\\n        address user,\\n        uint value\\n    );\\n\\n    constructor(\\n        address hbscTokenAddress, \\n        address admin,\\n        address dev,\\n        uint256 newInitialRate0,\\n        uint256 newInitialRate180,\\n        uint256 newInitialRate270,\\n        uint256 newInitialRate365\\n    ) \\n    {\\n        hbscAddress = hbscTokenAddress;\\n        hbscToken = IHBSC(hbscTokenAddress);\\n        adminWallet = admin;\\n        devWallet = dev;\\n        owner = msg.sender;\\n        initialRate0 = newInitialRate0;\\n        initialRate180 = newInitialRate180;\\n        initialRate270 = newInitialRate270;\\n        initialRate365 = newInitialRate365;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(\\n            msg.sender == adminWallet || msg.sender == owner, \\n            \\\"Admin only function\\\"\\n        );\\n        _;\\n    }\\n\\n    /*\\n    * @dev Protects against reentrancy\\n    */\\n    modifier synchronized {\\n        require(!sync, \\\"Sync lock\\\");\\n        sync = true;\\n        _;\\n        sync = false;\\n    }\\n\\n    /*\\n    * @dev Allows staker to claim HBSC dividends\\n    */\\n    function claimDividends() \\n        external\\n    {\\n        uint256 claimAmount = getClaimAmount(msg.sender);\\n        if(claimAmount > 0){\\n            claim(msg.sender, claimAmount);     \\n        }\\n    }\\n\\n    /*\\n    * @dev Stake HBSC tokens\\n    */\\n    function stakeTokens(uint256 amount, uint256 dayLength)\\n        external\\n    {\\n        address user = msg.sender;\\n\\n        require(hbscToken.allowance(user, address(this)) >= amount, \\n           \\\"Please first approve HBSC\\\");\\n        require(amount > 0, \\\"Stake amount can not be 0\\\");\\n        require(hbscToken.balanceOf(user) >= amount, \\\"Insufficient balance\\\");\\n        require(hbscToken.transferFrom(user, address(this), amount), \\\"Transfer failed\\\");\\n\\n        Staked memory userStake = staked[user];\\n\\n        autoClaim(user);\\n\\n        if(dayLength == 0){\\n            token0StakedBalances[user] += amount;\\n            total0Staked += amount;\\n            userStake.Stake0StartTimestamp = block.timestamp;\\n        }\\n        else if(dayLength == 180){\\n            token180StakedBalances[user] += amount;\\n            total180Staked += amount;\\n            userStake.Stake180StartTimestamp = block.timestamp;\\n        }\\n        else if(dayLength == 270){\\n            token270StakedBalances[user] += amount;\\n            total270Staked += amount;\\n            userStake.Stake270StartTimestamp = block.timestamp;\\n        }\\n        else if(dayLength == 365){\\n            token365StakedBalances[user] += amount;\\n            total365Staked += amount;\\n            userStake.Stake365StartTimestamp = block.timestamp;\\n        }\\n        else{\\n            revert(\\\"Invalid stake length\\\");\\n        }\\n        \\n        totalStaked = totalStaked.add(amount);\\n        staked[user] = userStake;\\n        lastClaimed[user] = block.timestamp;\\n\\n        emit TokenStake(user, amount, dayLength);\\n    }\\n\\n    /**\\n    * @dev UnStake HBSC Token\\n    */\\n    function unStakeTokens(uint dayLength)\\n        external\\n        synchronized\\n    {\\n        uint256 amount;\\n        address user = msg.sender;\\n        autoClaim(user);\\n\\n        if(dayLength == 0){\\n            amount = token0StakedBalances[user];\\n\\n            require(\\n                amount > 0,\\n                \\\"No available tokens to unstake in tier 0\\\"\\n            );\\n\\n            token0StakedBalances[user] = 0;\\n            staked[user].Stake0StartTimestamp = 0;\\n            total0Staked = total0Staked.sub(amount);\\n            totalStaked = totalStaked.sub(amount);\\n            hbscToken.transfer(user, amount);\\n        }\\n        else if(dayLength == 180){\\n            amount = token180StakedBalances[user];\\n\\n            require(\\n                amount > 0,\\n                \\\"No available tokens to unstake in tier 180\\\"\\n            );\\n\\n            if(isStakeFinished(user, dayLength)) {\\n                hbscToken.transfer(user, amount);\\n            }\\n            else {\\n                emergencyUnstake(user, dayLength);\\n            }\\n\\n            token180StakedBalances[user] = 0;\\n            staked[user].Stake180StartTimestamp = 0;\\n            total180Staked = total180Staked.sub(amount);\\n            totalStaked = totalStaked.sub(amount);\\n        }\\n        else if(dayLength == 270){\\n            amount = token270StakedBalances[user];\\n\\n            require(\\n                amount > 0,\\n                \\\"No available tokens to unstake in tier 270\\\"\\n            );\\n\\n            if(isStakeFinished(user, dayLength)) {\\n                hbscToken.transfer(user, amount);\\n            }\\n            else {\\n                emergencyUnstake(user, dayLength);\\n            }\\n\\n            token270StakedBalances[user] = 0;\\n            staked[user].Stake270StartTimestamp = 0;\\n            total270Staked = total270Staked.sub(amount);\\n            totalStaked = totalStaked.sub(amount);\\n        }\\n        else if(dayLength == 365){\\n            amount = token365StakedBalances[user];\\n\\n            require(\\n                amount > 0,\\n                \\\"No available tokens to unstake in tier 365\\\"\\n            );\\n            if(isStakeFinished(user, dayLength)){\\n                hbscToken.transfer(user, amount);\\n            }\\n            else {\\n                emergencyUnstake(user, dayLength);\\n            }\\n\\n            token365StakedBalances[user] = 0;\\n            staked[user].Stake365StartTimestamp = 0;\\n            total365Staked = total365Staked.sub(amount);\\n            totalStaked = totalStaked.sub(amount);           \\n        }\\n        else{\\n            revert(\\\"Invalid stake length\\\");\\n        }\\n\\n        emit TokenUnStake(user, amount, dayLength);\\n    }\\n\\n    /*\\n    * @dev Allows admin to claim tokens accidentaly sent to the contract address\\n    */\\n    function reclaimTokens(\\n        address tokenAddress, \\n        address wallet\\n    ) \\n        external\\n        onlyAdmin\\n    {\\n        IBEP20 token = IBEP20(tokenAddress);\\n        uint256 balance = token.balanceOf(address(this));\\n        \\n        if(tokenAddress == hbscAddress){\\n            balance = token.balanceOf(address(this)).sub(totalStaked);\\n        }\\n\\n        require(balance > 0, \\\"No tokens available for this contract address\\\");\\n\\n        token.transfer(wallet, balance);\\n    }\\n\\n    /*\\n    * @dev Determines whether stake is fininshed or liable to emergency unstake penalty\\n    */\\n    function isStakeFinished(\\n        address user, \\n        uint256 stakeDayLength\\n    )\\n        public\\n        view\\n        returns(bool)\\n    {\\n        if(stakeDayLength == 0){\\n            return true;\\n        }\\n        else if(stakeDayLength == 180){\\n            if(staked[user].Stake180StartTimestamp == 0){\\n                return false;\\n            }\\n            else{\\n               return staked[user].Stake180StartTimestamp\\n                  .add(\\n                    stakeDayLength\\n                    .mul(daySeconds)\\n                  ) <= block.timestamp;               \\n            }\\n        }\\n        else if(stakeDayLength == 270){\\n            if(staked[user].Stake270StartTimestamp == 0){\\n                return false;\\n            }\\n            else{\\n               return staked[user].Stake270StartTimestamp\\n                  .add(\\n                    stakeDayLength\\n                    .mul(daySeconds)\\n                  ) <= block.timestamp;               \\n            }\\n        }\\n        else if(stakeDayLength == 365){\\n            if(staked[user].Stake365StartTimestamp == 0){\\n                return false;\\n            }\\n            else{\\n               return staked[user].Stake365StartTimestamp\\n                  .add(\\n                    stakeDayLength\\n                    .mul(daySeconds)\\n                  ) <= block.timestamp;               \\n            }\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n\\n    /*\\n    * @dev Gets total amount of unclaimed dividends for stakeholder\\n    */\\n    function getClaimAmount(address stakeholder) \\n        public\\n        view\\n        returns(uint256)\\n    {\\n        Staked memory stakeInfo = staked[stakeholder];\\n        uint256 dividendAmount = 0;\\n        uint256 lastClaimDate = lastClaimed[stakeholder];\\n        \\n        uint256 daysSinceLastClaim = getElapsedDays(lastClaimDate);\\n        dividendAmount += calculateDividends(\\n            token0StakedBalances[stakeholder],\\n            initialRate0,\\n            daysSinceLastClaim\\n        );\\n\\n        dividendAmount += getOutstandingDividends(\\n            token180StakedBalances[stakeholder],\\n            initialRate180,\\n            lastClaimDate,\\n            stakeInfo.Stake180StartTimestamp,\\n            180\\n        );\\n\\n        dividendAmount += getOutstandingDividends(\\n            token270StakedBalances[stakeholder],\\n            initialRate270,\\n            lastClaimDate,\\n            stakeInfo.Stake270StartTimestamp,\\n            270\\n        );\\n\\n        dividendAmount += getOutstandingDividends(\\n            token365StakedBalances[stakeholder],\\n            initialRate365,\\n            lastClaimDate,\\n            stakeInfo.Stake365StartTimestamp,\\n            365\\n        );\\n\\n        return dividendAmount;\\n    }\\n\\n    /*\\n    * @dev Emergency unstake process\\n    * Refund completed stake amount corresponding to 10% percentiles\\n    */\\n    function emergencyUnstake(\\n        address user, \\n        uint256 stakeDayLength\\n    )\\n        internal\\n    {\\n        uint256 balance;\\n        uint256 startTimestamp;\\n        Staked memory userStake = staked[user];\\n\\n        if(stakeDayLength == 180) {\\n            balance = token180StakedBalances[user];\\n            startTimestamp = userStake.Stake180StartTimestamp;\\n        }\\n        else if(stakeDayLength == 270) {\\n            balance = token270StakedBalances[user];\\n            startTimestamp = userStake.Stake270StartTimestamp;\\n        }\\n        else if(stakeDayLength == 365) {\\n            balance = token365StakedBalances[user];\\n            startTimestamp = userStake.Stake365StartTimestamp;\\n        }\\n        else {\\n            revert(\\\"Invalid stake length\\\");\\n        }\\n\\n        uint256 percentile = getPercentileStaked(stakeDayLength, startTimestamp);\\n        uint256 refundAmount;\\n        uint256 lostAmount;\\n\\n        if(percentile < 10){\\n            refundAmount = 0;\\n            lostAmount = balance;\\n        }\\n        else {\\n            refundAmount = balance.mul(percentile).div(100);\\n            lostAmount = balance.sub(refundAmount);\\n            hbscToken.transfer(user, refundAmount);\\n        }\\n\\n        uint256 teamAmount = lostAmount.mul(10).div(100);\\n        teamSplit(teamAmount);\\n\\n        uint256 burnAmount = lostAmount.sub(teamAmount);\\n        hbscToken.burnTokens(burnAmount);\\n    }\\n\\n    /*\\n    * @dev Splits and transfers admin and dev amounts\\n    */\\n    function teamSplit(uint256 amount) private {\\n        uint256 adminAmount = amount.mul(90).div(100);\\n        uint256 devAmount = amount.sub(adminAmount);\\n        hbscToken.transfer(adminWallet, adminAmount);\\n        hbscToken.transfer(devWallet, devAmount);\\n    }\\n\\n    /*\\n    * @dev rounds down to the nearest 10%\\n    */\\n    function getPercentileStaked(\\n        uint256 stakeDayLength, \\n        uint256 startTimestamp\\n    ) \\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalStakeTime = stakeDayLength.mul(daySeconds);\\n        uint256 timeRemaining = (startTimestamp.add(totalStakeTime)).sub(block.timestamp);\\n\\n        uint256 percent = 100 - timeRemaining.mul(100) / totalStakeTime;\\n\\n        return percent.sub(percent.mod(10));\\n    }\\n\\n    /*\\n    * @dev Claims dividends\\n    */\\n    function claim(address user, uint256 amount) private {\\n        hbscToken.mintTo(msg.sender, amount);\\n        lastClaimed[user] = block.timestamp;\\n        \\n        emit DividendsClaimed(msg.sender, amount);\\n    }\\n\\n    /*\\n    * @dev Claims all outsanding divs for user\\n    */\\n    function autoClaim(address user) private {\\n        uint256 claimAmount = getClaimAmount(user);\\n        if(claimAmount > 0){\\n            claim(user, claimAmount);\\n        }\\n    }\\n\\n    /*\\n    * @dev Gets the number of days since specified time\\n    */\\n    function getElapsedDays(uint256 startTime) \\n        private\\n        view\\n        returns(uint256)\\n    {\\n        uint256 totalTimeElapsed = block.timestamp.sub(startTime);\\n        if(totalTimeElapsed < daySeconds){\\n            return 0;\\n        }\\n        return totalTimeElapsed.div(daySeconds);\\n    }\\n\\n    /*\\n    * @dev Gets amount of outstanding dividends for specific tier\\n    */\\n    function getOutstandingDividends(\\n        uint256 stakedAmount,\\n        uint256 rate,\\n        uint256 lastClaimDate,\\n        uint256 startTime,\\n        uint256 stakePeriodDays\\n    )\\n        private\\n        view\\n        returns(uint256)\\n    {\\n        if(stakedAmount > 0) {\\n            uint256 elapsedDays = getElapsedDays(startTime);\\n            uint256 daysToClaim = getElapsedDays(lastClaimDate);\\n\\n            if(elapsedDays > stakePeriodDays) {\\n                uint256 endDate = startTime.add(stakePeriodDays.mul(daySeconds));\\n                if(endDate < lastClaimDate){ \\n                   return 0; //Stake has finished and divs already claimed until end\\n                }\\n                else{\\n                    uint256 daysOver = getElapsedDays(endDate);\\n                    if(daysToClaim < daysOver) {\\n                        return 0;\\n                    }\\n                    //claim remainder up until last day\\n                    daysToClaim = daysToClaim.sub(daysOver);\\n                }\\n            }\\n            return  calculateDividends(\\n                stakedAmount,\\n                rate,\\n                daysToClaim\\n            );\\n        }\\n\\n        return 0;\\n    }\\n\\n    /*\\n    * @dev Calculated the amount of unclaimed dividends\\n    */\\n    function calculateDividends(\\n        uint256 stakedAmount,\\n        uint256 rate,\\n        uint256 daysToClaim\\n    )\\n        private\\n        view\\n        returns(uint256)\\n    {\\n        if(stakedAmount > 0 && daysToClaim > 0){\\n            return stakedAmount.mul(rate).mul(daysToClaim).div(rateDecimals);\\n        }\\n\\n        return 0; \\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hbscTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dev\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newInitialRate0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newInitialRate180\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newInitialRate270\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newInitialRate365\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DividendsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"TokenStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"TokenUnStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daySeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"}],\"name\":\"getClaimAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hbscAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialRate0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialRate180\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialRate270\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialRate365\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeDayLength\",\"type\":\"uint256\"}],\"name\":\"isStakeFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"reclaimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dayLength\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Stake0StartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Stake180StartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Stake270StartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Stake365StartTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token0StakedBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token180StakedBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token270StakedBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token365StakedBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total0Staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total180Staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total270Staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total365Staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dayLength\",\"type\":\"uint256\"}],\"name\":\"unStakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HBSCStake", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001a8abcfdf145379c2443eb7a6e3d127186c867db0000000000000000000000009b6139b99403845679a5c363e4e42a68c51af1fc00000000000000000000000032ac66ea2de678d2edc66486dc8cc2aa0fff82d800000000000000000000000000000000000000000000000000000000000003be000000000000000000000000000000000000000000000000000000000000059e000000000000000000000000000000000000000000000000000000000000095d00000000000000000000000000000000000000000000000000000000000012ba", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}