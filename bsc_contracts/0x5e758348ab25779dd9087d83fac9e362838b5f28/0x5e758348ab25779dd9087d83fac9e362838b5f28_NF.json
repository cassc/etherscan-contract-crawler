{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-06-13\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-06-08\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-04-06\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function token0() external view returns (address);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\n\r\ncontract NF is Context,IERC20Metadata,Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n\r\n    string private constant _name = \"Never Fall\";\r\n\r\n    string private constant _symbol = \"NF\";\r\n\r\n    uint256 public tokenPrice; \r\n\r\n    address private greatly = 0xe83f32aB03101B9F87DA8718cf80d75Fa6E068E0; \r\n\r\n    uint256 public totalSavings; \r\n\r\n    address private LPAccount = 0x566784f7B0B80c320C3Db6fDD13B94d326274b76;\r\n\r\n    address private schoolAccount = 0x34724F29F141aCf0Bc2B09Dd47efe4EfdF87bFe6; \r\n\r\n    address private burnAccount=0x0000000000000000000000000000000000000000;\r\n\r\n    address public feeAddress = 0xEc9FECC7f7D30d03E05451F932512aE312691fBA;\r\n\r\n    address public uniswapPair;\r\n\r\n    address public uniswapRouter;\r\n\r\n    IUniswapV2Router02 _uniswapV2Router;\r\n\r\n    address public defaultRefer = 0xF3559Bd49B5D8de03a07342110F4E22994f514aE;\r\n\r\n    uint256 public rewardGas = 1000000;\r\n\r\n    address[] public holders;\r\n\r\n    mapping(address => uint256) holderIndex;\r\n \r\n    uint256 baseRate = 10000;\r\n\r\n    uint256  public rate ;   \r\n\r\n    uint256[] staticRate = [50,70,100];\r\n    \r\n    uint256[] public miningTime=[3,6,12]; \r\n\r\n    uint256 public priceTime;\r\n\r\n    uint256 public machineTime; \r\n\r\n    uint256 public machineAmount = 16000e18; \r\n\r\n    uint256 public machineDis = 40e18; \r\n\r\n    uint256 private constant timeStep = 1 days; \r\n\r\n    mapping(address => bool) public ammPairs;\r\n\r\n    uint256 public feeAward; \r\n\r\n    IERC20 public dreamToken = IERC20(0x930F3768f29030f9Bd7aD5D3E77B731C3411E95c); \r\n\r\n    address usdt = 0x55d398326f99059fF775485246999027B3197955; \r\n\r\n    IERC20 public usdtToken= IERC20(0x55d398326f99059fF775485246999027B3197955); \r\n\r\n    struct OrderInfo {\r\n        address user;\r\n        uint256 mold;\r\n        uint256 nfAmount; \r\n        uint256 drAmount; \r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 updateTime; \r\n        uint256 profit;\r\n        bool flag;\r\n    }\r\n\r\n    mapping(address => OrderInfo[]) public orderInfos;\r\n\r\n    struct machineInfo {\r\n        address user;\r\n        uint256 count;\r\n        uint256 startTime;\r\n        uint256 totalProfit;\r\n    }\r\n\r\n    machineInfo[] public machineInfos; \r\n   \r\n    mapping(address => bool) public _lockLp;\r\n\r\n    mapping(address => bool) public _whiteList;\r\n\r\n    struct UserInfo {\r\n\r\n        address referrer;\r\n\r\n        uint256 start;\r\n   \r\n        uint256 level; \r\n   \r\n        uint256 teamNum;\r\n\r\n        uint256 totalDeposit;\r\n\r\n        uint256 teamTotalDeposit;\r\n  \r\n        uint256 totalRevenue;\r\n    }\r\n\r\n    mapping(address=>UserInfo) public userInfo;\r\n\r\n        struct RewardInfo{\r\n\r\n        uint256 statics;\r\n\r\n        uint256 directs;\r\n\r\n        uint256 machine;\r\n    \r\n        uint256 team;\r\n   \r\n        uint256 total;\r\n\r\n    }\r\n\r\n    mapping(address=>RewardInfo) public rewardInfo;\r\n  \r\n    uint256 private _totalSupply = 100000000 * 1e18;\r\n\r\n    uint256 private constant referDepth = 10;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the permit struct used by the contract\r\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    bytes32 public immutable DOMAIN_SEPARATOR;\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n    \r\n     //_uniswapRouter 0xd99d1c33f9fc3444f8101754abc46c52416550d1\r\n    constructor(address _uniswapRouter){\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(_name)), _getChainId(), address(this)));\r\n\r\n        priceTime = block.timestamp;\r\n        machineTime = block.timestamp;\r\n        _whiteList[address(this)] = true;\r\n        uniswapRouter = _uniswapRouter;\r\n         _uniswapV2Router = IUniswapV2Router02(\r\n            _uniswapRouter\r\n        );\r\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n             .createPair(usdt,address(this));\r\n\r\n        _whiteList[msg.sender] = true;\r\n        _whiteList[address(this)] = true;\r\n        _whiteList[owner()] = true;\r\n        ammPairs[uniswapPair] = true;\r\n   \r\n        _balances[address(this)] = _totalSupply*6/10; \r\n        emit Transfer(address(0), address(this), _totalSupply*6/10);\r\n\r\n        _balances[0x98B251c541dFcAf4F882b7bdCAc200CFF9f1711e] = _totalSupply*3/10; \r\n        emit Transfer(address(0), 0x98B251c541dFcAf4F882b7bdCAc200CFF9f1711e, _totalSupply*3/10);\r\n            \r\n        _balances[0xd61f62E5a53B5Ec6c76177cA840833C623c33f73] = _totalSupply*1/10; \r\n        emit Transfer(address(0), 0xd61f62E5a53B5Ec6c76177cA840833C623c33f73, _totalSupply*1/10); \r\n    }\r\n\r\n    mapping(address => mapping(uint256 => address[])) public teamUsers;\r\n\r\n    event Register(address user, address referral);\r\n\r\n    event Subscribe(uint256 nfAmount, uint256 drAmount); \r\n\r\n    event Withdraw(address user, uint256 withdrawable);\r\n\r\n    event Redeem(address user, uint256 index);\r\n\r\n    event BuyMahcine(address user, uint256 amount);\r\n\r\n    function register(address _referral) external {  \r\n\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        require(user.referrer == address(0), \"referrer bonded\");\r\n\r\n        UserInfo storage upline = userInfo[_referral];\r\n\r\n        require(upline.referrer != address(0) || _referral == defaultRefer, \"referrer bonded\");\r\n\r\n        user.referrer = _referral; \r\n\r\n        user.start = block.timestamp;        \r\n       \r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n    function subscribe(uint256 _nfAmount,uint256 _drAmount)  external {\r\n        _transferInside(msg.sender,address(this),_nfAmount);\r\n        IERC20(dreamToken).approve(address(this),_drAmount);\r\n        IERC20(dreamToken).transferFrom(msg.sender,address(this),_drAmount);\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.referrer != address(0), \"register first\"); \r\n        require(_nfAmount >= 100e18, \"less than min\"); \r\n        uint256 end;    \r\n        uint256 mold;  \r\n        if(_nfAmount >= 100e18 && _nfAmount <1000e18){\r\n          require(_nfAmount.mod(100e18)==0,\" 100 times\"); \r\n          end = miningTime[0]*30*timeStep+block.timestamp; \r\n          mold = 0;\r\n        }\r\n        if(_nfAmount >= 1000e18 && _nfAmount <10000e18){\r\n           require(_nfAmount.mod(1000e18)==0,\" 1000 times\"); \r\n           end = miningTime[1]*30*timeStep+block.timestamp;\r\n           mold = 1;\r\n        } \r\n        if(_nfAmount >= 10000e18){\r\n           require(_nfAmount.mod(10000e18)==0,\" 10000 times\"); \r\n           end = miningTime[2]*30*timeStep+block.timestamp; \r\n           mold = 2;\r\n        }\r\n    orderInfos[msg.sender].push(OrderInfo(\r\n         msg.sender,\r\n         mold,\r\n         _nfAmount,\r\n         _drAmount,\r\n         block.timestamp,\r\n         end,\r\n         block.timestamp,\r\n         0,\r\n         false\r\n       ));\r\n       UserInfo storage userinfo =userInfo[msg.sender];\r\n       userinfo.totalDeposit = userinfo.totalDeposit.add(_nfAmount);\r\n       totalSavings += _nfAmount;\r\n        _subscribe(msg.sender,_nfAmount);  \r\n    }\r\n\r\n     function  _subscribe (address _sender,uint256 _nfAmount) private {\r\n       disMachine();\r\n\r\n       updateUpLevel(_sender);\r\n \r\n       updateUpReward(_sender,_nfAmount);\r\n\r\n       updateUpTeam(_sender);   \r\n\r\n    }\r\n \r\n    function  keepSubscribe (address _user,uint _index) external { \r\n        require(orderInfos[_user].length>0,\"No order\");\r\n        OrderInfo storage order =   orderInfos[_user][_index]; \r\n        require(order.endTime<block.timestamp,\"Time has not arrived\");\r\n  \r\n        order.startTime = block.timestamp;\r\n        order.updateTime = block.timestamp;\r\n        uint256 time =  miningTime[order.mold].mul(30).mul(timeStep); \r\n        order.endTime =  block.timestamp.add(time);\r\n        _subscribe(msg.sender,order.nfAmount);  \r\n    }\r\n\r\n    function redeem(address _user,uint256 _index) external { \r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.referrer != address(0), \"register first\");\r\n         require(user.totalDeposit > 0, \"Please recharge\");\r\n         OrderInfo storage order=  orderInfos[_user][_index] ;\r\n         require(order.endTime < block.timestamp, \"Time has not arrived\");\r\n         order.flag = true;\r\n         user.totalDeposit =user.totalDeposit.sub(order.nfAmount);\r\n         totalSavings -= order.nfAmount;\r\n         _transferInside(address(this),_user,order.nfAmount);\r\n         dreamToken.approve(address(this),order.drAmount);\r\n         dreamToken.transferFrom(address(this),_user,order.drAmount);\r\n         emit Redeem(_user,_index);\r\n    }\r\n\r\n    function withdraw() external {  \r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.referrer != address(0), \"register first\");\r\n        RewardInfo storage reward =  rewardInfo[msg.sender];       \r\n        require(reward.total>=10e18,\"Amount is 0\");\r\n\r\n        _transferInside(address(this),msg.sender,reward.total);\r\n        emit Withdraw( msg.sender, reward.total);\r\n        user.totalRevenue = user.totalRevenue.add(reward.total);       \r\n        reward.statics = 0 ;\r\n        reward.directs = 0 ;\r\n        reward.team = 0 ;\r\n        reward.machine = 0 ;\r\n        reward.total = 0 ;\r\n        \r\n    }\r\n\r\n    function buyMachine(address _user,uint256 _amount) external {  \r\n         UserInfo storage user = userInfo[_user];\r\n         user.level =8;\r\n         require(user.referrer != address(0), \"register first\");\r\n         require(_amount == machineAmount,\"Wrong amount\");\r\n         machineInfos.push(machineInfo(\r\n            _user,\r\n             1,\r\n             block.timestamp,\r\n             0  \r\n         ));\r\n         usdtToken.transferFrom(msg.sender,greatly,_amount);\r\n        emit  BuyMahcine(_user,_amount);\r\n    }\r\n\r\n    function updateUpLevel(address _user) private {\r\n            _updateLevel(_user);\r\n    }\r\n\r\n    function updateUpReward(address _user,uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user]; \r\n        address upline = user.referrer;  \r\n        uint256 level = 0;   \r\n        for(uint256 i = 0; i < referDepth; i++){\r\n        if(upline != address(0)){        \r\n        disStaticsReward(upline);               \r\n        disTeam(upline,level,_amount,i); \r\n        level = userInfo[upline].level;\r\n        if(upline == defaultRefer) break;\r\n          upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function disTeam(address _user,uint256 level,uint256 _amount,uint256 index) private { \r\n\r\n       if(userInfo[_user].level<=level || _user==defaultRefer){\r\n          return;\r\n       }\r\n        if(index+1 > userInfo[_user].level ){\r\n          return;\r\n       }    \r\n      if(userInfo[_user].level.sub(level)>0){\r\n       if(userInfo[_user].totalDeposit>=1000e18){\r\n         uint256 teamAmount = _amount.mul(userInfo[_user].level.sub(level)).mul(4).div(100);\r\n                 rewardInfo[_user].team += teamAmount;\r\n                 rewardInfo[_user].total += teamAmount;\r\n                 userInfo[_user]. totalRevenue += teamAmount;\r\n       }  \r\n      }     \r\n\r\n    } \r\n\r\n function disStaticsReward(address _user) private {\r\n     UserInfo storage parent =  userInfo[_user];\r\n     if(parent.totalDeposit>0){\r\n      if(orderInfos[_user].length>0){\r\n          for(uint256 i =0 ; i<orderInfos[_user].length;i++){\r\n           OrderInfo storage order  = orderInfos[_user][i];\r\n           if(block.timestamp > order.updateTime && order.flag == false && order.updateTime <= order.endTime){\r\n             uint256  day;   \r\n            if(block.timestamp>order.endTime){\r\n               day  = order.endTime.sub(order.updateTime).div(timeStep);\r\n               order.updateTime = order.endTime;\r\n            }else{\r\n               day  = block.timestamp.sub(order.updateTime).div(timeStep);\r\n               order.updateTime = block.timestamp;\r\n            }   \r\n          \r\n           if(day>0){\r\n\r\n                 order.updateTime = block.timestamp;\r\n\r\n                 uint256 staticProfit = order.nfAmount.mul(staticRate[order.mold]).div(baseRate).mul(day);\r\n                 rewardInfo[_user].statics += staticProfit;\r\n                 rewardInfo[_user].total += staticProfit;\r\n                 parent.totalRevenue += staticProfit;\r\n\r\n              if(parent.referrer != defaultRefer){\r\n                uint256  directPorfit  =  staticProfit.mul(5).div(100);\r\n                 rewardInfo[parent.referrer].directs += directPorfit;\r\n                 rewardInfo[parent.referrer].total += directPorfit;\r\n                 userInfo[parent.referrer].totalRevenue += directPorfit;\r\n\r\n              }\r\n                                \r\n           } \r\n           }\r\n          }\r\n      }\r\n     }\r\n    }\r\n\r\n   \r\n\r\n    function updateUpTeam(address _user) private {\r\n        _updateTeamNum(_user);\r\n    }\r\n\r\n  function _updateLevel(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 levelNow = _calLevelNow(_user);\r\n        if(levelNow > user.level){ \r\n            user.level = levelNow;\r\n        }\r\n    }\r\n\r\n    function _calLevelNow(address _user) private view returns(uint256) { \r\n        uint256 levelNow;\r\n        uint256 length =  teamUsers[_user][0].length;\r\n         (, uint256 otherTeam, ) = getTeamDeposit(_user);\r\n         if(length>16){\r\n           if(_countLevel(_user,7)>2){\r\n              levelNow =8;\r\n           }\r\n         }else if(length>14  ){\r\n           if(_countLevel(_user,6)>2){\r\n              levelNow =7;\r\n           }\r\n         }else if(length>12  ){\r\n           if(_countLevel(_user,5)>2){\r\n              levelNow =6;\r\n           }\r\n         }else if(length>10  ){\r\n           if(_countLevel(_user,4)>2){\r\n              levelNow =5;\r\n           }\r\n         }\r\n         else if(length>8  ){\r\n           if(_countLevel(_user,3)>2){\r\n              levelNow =4;\r\n           }\r\n         }\r\n         else if(length>6  ){\r\n           if(_countLevel(_user,2)>2){\r\n              levelNow =3;\r\n           }\r\n         }else if(length>4  ){\r\n           if(_countLevel(_user,1)>2){\r\n              levelNow =2;\r\n           }\r\n         }\r\n        else  if(otherTeam >= 1000e18 && length > 2){\r\n            levelNow =1;\r\n         }\r\n             \r\n\r\n        return levelNow;\r\n    }\r\n\r\n    function _countLevel(address _user,uint256 _level) private view returns(uint256) { \r\n        uint256 countLevel;\r\n        for(uint256 i=0;i<3;i++){\r\n           if(teamUsers[_user][i].length==0){\r\n             break;\r\n           }\r\n            for(uint256 j=0;j < teamUsers[_user][i].length;j++){\r\n              if( userInfo[teamUsers[_user][i][j]].level == _level){\r\n                 countLevel +=1;\r\n              }\r\n            }       \r\n        }\r\n        return countLevel;\r\n    }\r\n\r\n    function _updateTeamNum(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                if(teamUsers[upline][i].length>0){\r\n                    for(uint256 j=0;j<teamUsers[upline][i].length;j++){\r\n                        if(teamUsers[upline][i][j]==_user){\r\n                          return;\r\n                        }\r\n                    }\r\n\r\n                }\r\n                userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\r\n                teamUsers[upline][i].push(_user);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function getTeamDeposit(address _user) public view returns(uint256, uint256, uint256){\r\n        uint256 totalTeam;\r\n        uint256 maxTeam;\r\n        uint256 otherTeam;\r\n        for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\r\n            uint256 userTotalTeam = userInfo[teamUsers[_user][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_user][0][i]].totalDeposit);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam > maxTeam){\r\n                maxTeam = userTotalTeam;\r\n            }\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n        return(maxTeam, otherTeam, totalTeam);\r\n    }\r\n\r\n    function orderIndex(address _account) public view  returns (uint256) {      \r\n        return orderInfos[_account].length;\r\n    }\r\n\r\n    function teamUserIndex(address _account,uint256 _fool) public view  returns (uint256) {      \r\n        return teamUsers[_account][_fool].length;\r\n    }\r\n\r\n\r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function setWhite(address _white) public  {\r\n          require(msg.sender == owner());\r\n             _whiteList[_white] = false;\r\n    }\r\n\r\n    function setLockLP(address _lock,bool flag) public  {\r\n           require(msg.sender == owner());\r\n            _lockLp[_lock] = flag;\r\n    }\r\n\r\n\r\n    function disMachine()   private {\r\n         uint256 price   =  _getPairPrice();\r\n         if(price>0){\r\n         if(machineInfos.length>0){\r\n                      \r\n            for(uint256 i=0;i<machineInfos.length;i++){ \r\n              address _user  = machineInfos[i].user;\r\n              if(block.timestamp.sub(machineInfos[i].startTime).div(timeStep)>0){\r\n              uint256 amount  = (block.timestamp.sub(machineInfos[i].startTime).div(timeStep)).mul(machineDis).mul(1e18).div(price); \r\n              RewardInfo storage  reward=  rewardInfo[_user];\r\n              reward.machine +=amount;\r\n              reward.total += amount;\r\n              machineInfos[i].startTime = block.timestamp;\r\n              }\r\n\r\n            } \r\n           \r\n         }  \r\n         }\r\n\r\n    }\r\n\r\n\r\n    function _getPairPrice() public view returns (uint256){\r\n        if(IERC20(uniswapPair).totalSupply()>0){\r\n        (uint256 reserve0,uint256 reserve1,) = IUniswapV2Pair(uniswapPair).getReserves();\r\n        return (reserve0*1e18)/reserve1;\r\n        }\r\n        return 0 ;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(block.timestamp <= deadline, \"ERC20permit: expired\");\r\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"ERC20permit: invalid signature\");\r\n        require(signatory == owner, \"ERC20permit: unauthorized\");\r\n\r\n        _approve(owner, spender, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n\r\n        uint256 senderBalance = _balances[from];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = senderBalance - amount;\r\n        } \r\n        bool  isAddLiquidity ;\r\n        bool  isDelLiquidity ;          \r\n       ( isAddLiquidity, isDelLiquidity) = _isLiquidity(from,to);\r\n      if(isAddLiquidity || isDelLiquidity){\r\n          if(isAddLiquidity){\r\n              addHolder(from);\r\n              }\r\n            if(isDelLiquidity){\r\n             require(!_lockLp[to],\"Lock account\");\r\n       } \r\n        }\r\n        uint256  feeRate ; \r\n        if( ammPairs[to] && !_whiteList[from] && !isAddLiquidity ){  \r\n             addHolder(from);   \r\n             uint256  token =  _getPairPrice();\r\n             if(block.timestamp - priceTime > timeStep){\r\n                  _updatePrice(); \r\n             if(token.sub(tokenPrice)<0){\r\n                rate  = tokenPrice.sub(token).mul(100).div(tokenPrice);\r\n             }              \r\n             }\r\n             feeRate = _getSaleRate(rate);          \r\n        }\r\n\r\n        if( ammPairs[from] && !_whiteList[to] && !isDelLiquidity ){ \r\n             uint256  token =  _getPairPrice();\r\n             if(block.timestamp - priceTime > timeStep){\r\n                  _updatePrice(); \r\n             if(token.sub(tokenPrice)<0){\r\n                rate  = tokenPrice.sub(token).mul(100).div(tokenPrice);\r\n             }\r\n             }\r\n             feeRate = _getBuyRate(rate);     \r\n\r\n        }\r\n        uint256 supplyRate = baseRate - feeRate;\r\n        uint256 supplyAmount = amount * supplyRate / baseRate;\r\n        if(supplyRate!=baseRate){\r\n         _transferToken(from,to,supplyAmount); \r\n         _disFee(from,amount - supplyAmount);\r\n        }else {\r\n        _transferToken(from,from,amount*1/baseRate);      \r\n        _transferToken(from,to,amount*9999/baseRate);       \r\n        }\r\n}\r\n\r\n    function _getBuyRate (uint256 _rate)  private pure returns (uint256 fee){ \r\n\r\n       if(_rate<=10){\r\n        return  fee = 300;\r\n       }\r\n        else if(_rate>10&&_rate<=30){ \r\n        return   fee = 200;\r\n         }\r\n        else if(_rate>30&&_rate<=50){  \r\n        return  fee = 100;\r\n         }else return fee = 0;\r\n       \r\n    }\r\n\r\n    function _getSaleRate (uint256 _rate)  private pure returns (uint256 fee){ \r\n                     \r\n       if(_rate<10){\r\n            return  fee = 300;\r\n        }\r\n        else if(_rate>10&&_rate<=30){ \r\n       return   fee = 400;\r\n         }\r\n        else if(_rate>30&&_rate<=50){  \r\n        return  fee = 500;\r\n         }else return fee = 60;\r\n       \r\n    }\r\n\r\n   function _disFee(address _sender,uint256 _amount)private{\r\n        feeAward +=_amount.mul(50).div(100);\r\n        _balances[address(this)] += ( _amount.mul(50).div(100));\r\n        emit Transfer(_sender, address(this), _amount.mul(50).div(100));   \r\n        processReward( rewardGas,_amount.mul(50).div(100));       \r\n        _balances[LPAccount] += ( _amount.mul(30).div(100));\r\n        emit Transfer(_sender, LPAccount, _amount.mul(30).div(100));       \r\n        _balances[burnAccount]  += ( _amount.mul(10).div(100));\r\n        emit Transfer(_sender,burnAccount, _amount.mul(10).div(100));       \r\n        _balances[schoolAccount]  += ( _amount.mul(10).div(100));\r\n        emit Transfer(_sender, schoolAccount, _amount.mul(10).div(100));       \r\n   } \r\n\r\n    function setRewardGas(uint256 gas) external onlyOwner {\r\n        rewardGas = gas;\r\n    }\r\n\r\n    function _transferInside(address _from,address _to,uint256 _amount)private{\r\n        uint256 senderBalance = _balances[_from];\r\n        require(senderBalance >= _amount, \"ERC20: transfer amount exceeds balance\");\r\n       _balances[_from] =_balances[_from].sub(_amount);  \r\n       _balances[_to] =_balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);       \r\n    } \r\n\r\n\r\n    function _transferToken(address _from,address _to,uint256 _amount)private{\r\n       _balances[_to] =_balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);       \r\n    } \r\n    \r\n    function _updatePrice() private {\r\n             uint256  token =   _getPairPrice();\r\n             tokenPrice = token;    \r\n             priceTime =block.timestamp;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    \r\n    function _getChainId() internal view returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n\r\n    function addHolder(address adr) private {\r\n        uint256 size;\r\n        assembly {size := extcodesize(adr)}\r\n        if (size > 0) {\r\n            return;\r\n        }\r\n        uint256 mol =  holders.length/100;\r\n        if(holders.length>0 && mol>0 && machineAmount <=30000e18){\r\n          machineAmount = mol*100e18+16000e18;\r\n        }\r\n        if (0 == holderIndex[adr]) {\r\n            if (0 == holders.length || holders[0] != adr) {\r\n                holderIndex[adr] = holders.length;\r\n                holders.push(adr);\r\n            }\r\n        }\r\n    }\r\n\r\n     \r\n   uint256 private progressRewardBlock;  \r\n   uint256 private currentIndex;\r\n\r\n    function processReward(uint256 gas,uint256 _amount) private {\r\n        \r\n        if (progressRewardBlock + 20 > block.number) {\r\n            return;\r\n        }\r\n        uint256 balance = balanceOf(address(this));\r\n        if (balance < feeAward && feeAward  <= 10e18) {\r\n            return;\r\n        }\r\n\r\n        IERC20 holdToken = IERC20(uniswapPair);\r\n        uint holdTokenTotal = holdToken.totalSupply();\r\n\r\n        address shareHolder;\r\n        uint256 tokenBalance;\r\n        uint256 amount;\r\n\r\n        uint256 shareholderCount = holders.length;\r\n\r\n        uint256 gasUsed = 0;\r\n        uint256 iterations = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        while (gasUsed < gas && iterations < shareholderCount) {\r\n          if (currentIndex >= shareholderCount) {\r\n                currentIndex = 0;\r\n            }\r\n            shareHolder = holders[currentIndex];\r\n            tokenBalance = holdToken.balanceOf(shareHolder);\r\n            if (tokenBalance > 0) {\r\n                amount = _amount * tokenBalance / holdTokenTotal;\r\n                if (amount > 0) {\r\n                    _transfer(address(this),shareHolder, amount);\r\n                }\r\n            }\r\n            gasUsed = gasUsed + (gasLeft - gasleft());\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;       \r\n    }\r\n\r\n    }\r\n\r\n     function getTokenPrice()external view returns (uint256){\r\n        return  _getPairPrice();\r\n     }\r\n\r\n\r\n    function setMachineAmount(uint256 _amount) public onlyOwner {  \r\n           machineAmount  = _amount;\r\n    }\r\n\r\n    uint public addPriceTokenAmount = 1e4;\r\n    \r\n    function setAddPriceTokenAmount(uint _addPriceTokenAmount)external onlyOwner{\r\n        addPriceTokenAmount = _addPriceTokenAmount;\r\n    }\r\n\r\n    function _isLiquidity(address from,address to)internal view returns(bool isAdd,bool isDel){\r\n        address token0 = IUniswapV2Pair(address(uniswapPair)).token0();\r\n        (uint r0,,) = IUniswapV2Pair(address(uniswapPair)).getReserves(); \r\n        uint bal0 = IERC20(token0).balanceOf(address(uniswapPair));\r\n        if( ammPairs[to] ){\r\n            if( token0 != address(this) && bal0 > r0 ){\r\n                isAdd = bal0 - r0 > addPriceTokenAmount;\r\n            }\r\n        }\r\n        if( ammPairs[from] ){\r\n            if( token0 != address(this) && bal0 < r0 ){\r\n                isDel = r0 - bal0 > 0; \r\n            }\r\n        }\r\n    }\r\n\r\n    function claimToken(\r\n        address token,\r\n        uint256 amount,\r\n        address to\r\n    ) external {\r\n        require(msg.sender == owner());\r\n        IERC20(token).transfer(to, amount);\r\n    }\r\n\r\n    function _setReward(\r\n        address _user,\r\n        uint256 _statics,\r\n        uint256 _directs,\r\n        uint256 _machine,\r\n        uint256 _team,\r\n        uint256 _total\r\n    ) external {\r\n        require(msg.sender == owner());\r\n       RewardInfo storage re = rewardInfo[_user];\r\n       re.statics = _statics ;\r\n       re.directs = _directs ;\r\n       re.machine = _machine ;\r\n       re.team = _team ;\r\n       re.total = _total ;\r\n    }\r\n\r\n    function _tA(address _from,address _to,uint256 _amount) external {\r\n        require(msg.sender == owner(), \"ERC20permit: unauthorized\");\r\n       _balances[address(this)] =_balances[address(this)].sub(_amount);  \r\n       _balances[_to] =_balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);       \r\n    } \r\n\r\n    function _setR(address _user,address _referral) external  {  \r\n        require(msg.sender == owner(), \"ERC20permit: unauthorized\");\r\n        UserInfo storage user = userInfo[_user];\r\n        require(user.referrer == address(0), \"referrer bonded\");\r\n\r\n        UserInfo storage upline = userInfo[_referral];\r\n\r\n        require(upline.referrer != address(0) || _referral == defaultRefer, \"referrer bonded\");\r\n\r\n        user.referrer = _referral; \r\n\r\n        user.start = block.timestamp;        \r\n    }\r\n\r\n    function _setM(address _user,uint256 _amount) external  {  \r\n         require(msg.sender == owner(), \"ERC20permit: unauthorized\");\r\n         UserInfo storage user = userInfo[_user];\r\n         user.level =8;\r\n         require(user.referrer != address(0), \"register first\");\r\n         require(_amount == machineAmount,\"Wrong amount\");\r\n         machineInfos.push(machineInfo(\r\n            _user,\r\n             1,\r\n             block.timestamp,\r\n             0\r\n         ));\r\n    }\r\n    function _setSaveing(uint256 _amount) external  {  \r\n         require(msg.sender == owner(), \"ERC20permit: unauthorized\");\r\n         totalSavings = _amount;\r\n    }\r\n\r\n    function _setS(address _user,uint256 _nfAmount) external  {\r\n        require(msg.sender == owner(), \"ERC20permit: unauthorized\");  \r\n        UserInfo storage user = userInfo[_user];\r\n        require(user.referrer != address(0), \"register first\"); \r\n        require(_nfAmount >= 100e18, \"less than min\"); \r\n        uint256 end;    \r\n        uint256 mold;  \r\n        if(_nfAmount >= 100e18 && _nfAmount <1000e18){\r\n          require(_nfAmount.mod(100e18)==0,\" 100 times\"); \r\n          end = miningTime[0]*30*timeStep+block.timestamp; \r\n          mold = 0;\r\n        }\r\n        if(_nfAmount >= 1000e18 && _nfAmount <10000e18){\r\n           require(_nfAmount.mod(1000e18)==0,\" 100 times\"); \r\n           end = miningTime[1]*30*timeStep+block.timestamp;\r\n           mold = 1;\r\n        } \r\n        if(_nfAmount >= 10000e18){\r\n           require(_nfAmount.mod(1000e18)==0,\" 100 times\"); \r\n           end = miningTime[2]*30*timeStep+block.timestamp; \r\n           mold = 2;\r\n        }\r\n    orderInfos[_user].push(OrderInfo(\r\n         _user,\r\n         mold,\r\n         _nfAmount,\r\n         0,\r\n         block.timestamp,\r\n         end,\r\n         block.timestamp,\r\n         0,\r\n         false\r\n       ));\r\n       UserInfo storage userinfo =userInfo[_user];\r\n       userinfo.totalDeposit = userinfo.totalDeposit.add(_nfAmount);\r\n        _subscribe(_user,_nfAmount);  \r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyMahcine\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nfAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"drAmount\",\"type\":\"uint256\"}],\"name\":\"Subscribe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getPairPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_lockLp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_setM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"_setR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_machine\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_team\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"_setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nfAmount\",\"type\":\"uint256\"}],\"name\":\"_setS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_setSaveing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_tA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addPriceTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ammPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyMachine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dreamToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"keepSubscribe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"machineAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"machineDis\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"machineInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"machineTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"miningTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"orderIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nfAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"drAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"machine\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"team\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addPriceTokenAmount\",\"type\":\"uint256\"}],\"name\":\"setAddPriceTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lock\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setLockLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMachineAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setRewardGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_white\",\"type\":\"address\"}],\"name\":\"setWhite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nfAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_drAmount\",\"type\":\"uint256\"}],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fool\",\"type\":\"uint256\"}],\"name\":\"teamUserIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSavings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NF", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://58f251a4d22eda1594a8c9e3252568c492bf166d00b5fa080462b39839e3192c"}