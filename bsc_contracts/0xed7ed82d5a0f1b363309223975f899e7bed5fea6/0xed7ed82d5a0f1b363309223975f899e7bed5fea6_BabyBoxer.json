{"SourceCode": "{\"BabyBoxer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\nimport \\\"BEP20Base.sol\\\";\\nimport \\\"Ownable.sol\\\";\\nimport \\\"ISwapV2.sol\\\";\\nimport \\\"IEcosystem.sol\\\";\\n\\npragma solidity ^0.8.6;\\n\\ncontract BabyBoxer is BEP20Base, Ownable {\\n    mapping(address =\\u003e uint256) private _rOwned;\\n    mapping(address =\\u003e uint256) private _oOwned;\\n    mapping(address =\\u003e Index) private _excludeList;\\n    uint256 private _rTotal;\\n    address[] private _excludeListStorage;\\n    Swap[] private _swapQueue;\\n    bool private _inSwap;\\n    address[] private _sellPath;\\n    address private constant _swapRouterAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E; \\n    address private constant _deadAddress = 0x000000000000000000000000000000000000dEaD;\\n    address public constant ecosystemAddress = 0x05Bb50D8c1D4061630563AD63e72Fe6d0229427c;\\n    address public constant _marketingAddress = 0x77Cd27Af9B668A6065B171a5354C1cF209011bAb;\\n    ISwapRouterV2 public swapRouter;\\n    address public swapPair;\\n\\n    event AddedToExcludeList(address account);\\n    event RemovedFromExcludeList(address account);\\n    event Claim(address account, uint256 accumulatedAmount);\\n    event EcosystemContribution(uint256 amount);\\n    event MarketingContribution(uint256 amount);\\n    event LiquidityContribution(\\n        uint256 amount,\\n        uint256 swappedAmount,\\n        uint256 receivedBNB\\n    );\\n\\n    struct Index {\\n        bool contains;\\n        uint256 index;\\n    }\\n    struct RValues {\\n        uint256 rAmount;\\n        uint256 rTransferAmount;\\n        uint256 rReflectionFee;\\n        uint256 rOtherFees;\\n    }\\n    struct TValues {\\n        uint256 tTransferAmount;\\n        uint256 tReflectionFee;\\n        uint256 tOtherFees;\\n    }\\n    struct Values {\\n        uint256 rAmount;\\n        uint256 rTransferAmount;\\n        uint256 rReflectionFee;\\n        uint256 rOtherFees;\\n        uint256 tTransferAmount;\\n        uint256 tReflectionFee;\\n        uint256 tOtherFees;\\n    }\\n    struct Swap {\\n        uint256 id;\\n        uint256 amount;\\n    }\\n\\n    modifier lockSwap {\\n        _inSwap = true;\\n        _;\\n        _inSwap = false;\\n    }\\n\\n    constructor() BEP20Base(\\\"BabyBoxer\\\", \\\"BBoxer\\\", 9, 888888888888888 * 10**9) {\\n        ISwapRouterV2 _swapRouter = ISwapRouterV2(_swapRouterAddress);\\n        swapRouter = _swapRouter;\\n        swapPair = ISwapV2Factory(_swapRouter.factory()).createPair(\\n            address(this),\\n            _swapRouter.WETH()\\n        );\\n        _sellPath = [address(this), _swapRouter.WETH()];\\n\\n        addToExcludeList(_marketingAddress);\\n        addToExcludeList(ecosystemAddress);\\n        addToExcludeList(address(this));\\n        addToExcludeList(_deadAddress);\\n        addToExcludeList(_msgSender());\\n\\n        _rTotal = ~uint256(0) - (~uint256(0) % (888888888888888 * 10**9));\\n        _rOwned[_msgSender()] += _rTotal;\\n        _balances[_msgSender()] += 888888888888888 * 10**9;\\n        emit Transfer(address(0), _msgSender(), 888888888888888 * 10**9);\\n    }\\n\\n    receive() external payable {}\\n\\n    function balanceOf(address account)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        if (isExcluded(account)) return _balances[account];\\n        return _tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    function isExcluded(address account) public view returns (bool) {\\n        return _excludeList[account].contains;\\n    }\\n\\n    function addToExcludeList(address account) public onlyOwner {\\n        require(!isExcluded(account), \\\"BEP20: Account is not excluded\\\");\\n        require(account != swapPair, \\\"BEP20: You can\\u0027t exclude swap pair\\\");\\n        require(\\n            account != _swapRouterAddress,\\n            \\\"BEP20: You can\\u0027t exclude swap router\\\"\\n        );\\n        require(_excludeListStorage.length \\u003c= 10, \\\"BEP20: You can\\u0027t exclude more than 10 addresses\\\");\\n\\n        _excludeListStorage.push(account);\\n        _excludeList[account].contains = true;\\n        _excludeList[account].index = _excludeListStorage.length - 1;\\n        if (_rOwned[account] \\u003e 0) {\\n            _balances[account] = _tokenFromReflection(_rOwned[account]);\\n        }\\n        emit AddedToExcludeList(account);\\n    }\\n\\n    function removeFromExcludeList(address account) public onlyOwner {\\n        require(isExcluded(account), \\\"BEP20: Account is excluded\\\");\\n        require(\\n            account != address(this),\\n            \\\"You can\\u0027t remove contract address from exclude list\\\"\\n        );\\n        require(\\n            account != _deadAddress,\\n            \\\"You can\\u0027t remove dead address from exclude list\\\"\\n        );\\n        require(\\n            account != ecosystemAddress,\\n            \\\"BEP20: You can\\u0027t remove bridge ecosystem from exclude list\\\"\\n        );\\n\\n        _excludeList[_excludeListStorage[_excludeListStorage.length - 1]]\\n        .index = _excludeList[account].index;\\n        _excludeListStorage[_excludeList[account].index] = _excludeListStorage[\\n            _excludeListStorage.length - 1\\n        ];\\n        _excludeListStorage.pop();\\n        _excludeList[account].contains = false;\\n        _balances[account] = 0;\\n        emit RemovedFromExcludeList(account);\\n    }\\n\\n    function getAccumulatedAmount(address account)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return balanceOf(account) - _oOwned[account];\\n    }\\n\\n    function claimAccumulatedAmount(address[] memory path) public lockSwap {\\n        uint256 accumulatedAmount = getAccumulatedAmount(_msgSender());\\n        require(\\n            accumulatedAmount \\u003e 0,\\n            \\\"BEP20: accumulated amount must be greater than 0\\\"\\n        );\\n\\n        _oOwned[_msgSender()] = balanceOf(_msgSender());\\n        _transfer(_msgSender(), address(this), accumulatedAmount);\\n        _swapContractTokensForBNB(_msgSender(), path, accumulatedAmount);\\n        emit Claim(_msgSender(), accumulatedAmount);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual override {\\n        require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n        require(amount \\u003e 0, \\\"BEP20: amount must be greater than 0\\\");\\n\\n        if (sender != swapPair \\u0026\\u0026 !_inSwap) {\\n            uint256 contractBalance = balanceOf(address(this));\\n            if (contractBalance \\u003e 0) {\\n                _swapAndDistribute(contractBalance);\\n            }\\n        }\\n\\n        bool takeFee = !(isExcluded(sender) || isExcluded(recipient));\\n        Values memory values = _getValues(amount, takeFee);\\n\\n        if (isExcluded(sender))\\n            if (isExcluded(recipient))\\n                _transferBothExcluded(sender, recipient, amount, values);\\n            else _transferFromExcluded(sender, recipient, amount, values);\\n        else if (isExcluded(recipient))\\n            _transferToExcluded(sender, recipient, values);\\n        else _transferStandard(sender, recipient, values);\\n\\n        if (amount \\u003c= _oOwned[sender]) _oOwned[sender] -= amount;\\n        else _oOwned[sender] = 0;\\n        _oOwned[recipient] += values.tTransferAmount;\\n\\n        if (takeFee) _distributeFees(values);\\n    }\\n\\n    function _swapAndDistribute(uint256 amount) private lockSwap {\\n        if (_swapQueue.length == 0) {\\n            uint256 ecosystemFee = amount / 2;\\n            uint256 marketingFee = amount / 4;\\n            uint256 liquidityFee = amount / 4;\\n\\n            if (!IEcosystem(ecosystemAddress).isWhitelisted(address(this))) {\\n                liquidityFee += ecosystemFee;\\n                ecosystemFee = 0;\\n            } else {\\n                _swapQueue.push(Swap(1, ecosystemFee));\\n            }\\n            _swapQueue.push(Swap(2, marketingFee));\\n            _swapQueue.push(Swap(3, liquidityFee));\\n        }\\n\\n        Swap memory currentSwap = _swapQueue[_swapQueue.length - 1];\\n        if (currentSwap.id == 1) // ecosystem swap\\n        {\\n            _swapContractTokensForBNB(ecosystemAddress, _sellPath, currentSwap.amount);\\n            emit EcosystemContribution(currentSwap.amount);\\n        } else if (currentSwap.id == 2) // marketing swap\\n        {\\n            _swapContractTokensForBNB(_marketingAddress, _sellPath, currentSwap.amount);\\n            emit MarketingContribution(currentSwap.amount);\\n        } else if (currentSwap.id == 3) // liquidity swap\\n        {\\n            uint256 half = currentSwap.amount / 2;\\n            uint256 initialBalance = address(this).balance;\\n            _swapContractTokensForBNB(address(this), _sellPath, half);\\n            uint256 receivedBNB = address(this).balance - initialBalance;\\n            _approve(address(this), _swapRouterAddress, half);\\n            swapRouter.addLiquidityETH{value: receivedBNB}(\\n                address(this),\\n                half,\\n                0,\\n                0,\\n                address(0),\\n                block.timestamp\\n            );\\n            emit LiquidityContribution(currentSwap.amount, half, receivedBNB);\\n        }\\n        _swapQueue.pop();\\n    }\\n\\n    function _swapContractTokensForBNB(address recipient, address[] memory path, uint256 amount)\\n        private\\n    {\\n        _approve(address(this), _swapRouterAddress, amount);\\n        swapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0, // slippage is unavoidable\\n            path,\\n            recipient,\\n            block.timestamp + 5 minutes\\n        );\\n    }\\n\\n    function _transferStandard(\\n        address sender,\\n        address recipient,\\n        Values memory values\\n    ) private {\\n        _rOwned[sender] -= values.rAmount;\\n        _rOwned[recipient] += values.rTransferAmount;\\n        emit Transfer(sender, recipient, values.tTransferAmount);\\n    }\\n\\n    function _transferToExcluded(\\n        address sender,\\n        address recipient,\\n        Values memory values\\n    ) private {\\n        _rOwned[sender] -= values.rAmount;\\n        _balances[recipient] += values.tTransferAmount;\\n        _rOwned[recipient] += values.rTransferAmount;\\n        emit Transfer(sender, recipient, values.tTransferAmount);\\n    }\\n\\n    function _transferFromExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount,\\n        Values memory values\\n    ) private {\\n        _balances[sender] -= tAmount;\\n        _rOwned[sender] -= values.rAmount;\\n        _rOwned[recipient] += values.rTransferAmount;\\n        emit Transfer(sender, recipient, values.tTransferAmount);\\n    }\\n\\n    function _transferBothExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount,\\n        Values memory values\\n    ) private {\\n        _balances[sender] -= tAmount;\\n        _rOwned[sender] -= values.rAmount;\\n        _balances[recipient] += values.tTransferAmount;\\n        _rOwned[recipient] += values.rTransferAmount;\\n        emit Transfer(sender, recipient, values.tTransferAmount);\\n    }\\n\\n    function _getValues(uint256 tAmount, bool deductReflectionFee)\\n        private\\n        view\\n        returns (Values memory)\\n    {\\n        TValues memory tValues = _getTValues(tAmount, deductReflectionFee);\\n        RValues memory rValues = _getRValues(\\n            tAmount,\\n            tValues.tReflectionFee,\\n            tValues.tOtherFees\\n        );\\n\\n        return\\n            Values(\\n                rValues.rAmount,\\n                rValues.rTransferAmount,\\n                rValues.rReflectionFee,\\n                rValues.rOtherFees,\\n                tValues.tTransferAmount,\\n                tValues.tReflectionFee,\\n                tValues.tOtherFees\\n            );\\n    }\\n\\n    function _getTValues(uint256 tAmount, bool deductReflectionFee)\\n        private\\n        pure\\n        returns (TValues memory)\\n    {\\n        if (!deductReflectionFee) return TValues(tAmount, 0, 0);\\n\\n        uint256 tReflectionFee = (tAmount * 2) / 100;\\n        uint256 tOtherFees = (tAmount * 8) / 100;\\n        uint256 tTransferAmount = tAmount - tReflectionFee - tOtherFees;\\n        return TValues(tTransferAmount, tReflectionFee, tOtherFees);\\n    }\\n\\n    function _getRValues(\\n        uint256 tAmount,\\n        uint256 tReflectionFee,\\n        uint256 tOtherFees\\n    ) private view returns (RValues memory) {\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rReflectionFee = tReflectionFee * currentRate;\\n        uint256 rOtherFees = tOtherFees * currentRate;\\n        uint256 rTransferAmount = rAmount - rReflectionFee - rOtherFees;\\n        return RValues(rAmount, rTransferAmount, rReflectionFee, rOtherFees);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        uint256 rSupply = _rTotal;\\n        uint256 tSupply = _totalSupply;\\n        for (uint256 i = 0; i \\u003c _excludeListStorage.length; i++) {\\n            if (\\n                _rOwned[_excludeListStorage[i]] \\u003e rSupply ||\\n                _balances[_excludeListStorage[i]] \\u003e tSupply\\n            ) return _rTotal / _totalSupply;\\n            rSupply -= _rOwned[_excludeListStorage[i]];\\n            tSupply -= _balances[_excludeListStorage[i]];\\n        }\\n        if (rSupply \\u003c _rTotal / _totalSupply) return _rTotal / _totalSupply;\\n        return rSupply / tSupply;\\n    }\\n\\n    function _tokenFromReflection(uint256 rAmount)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        require(\\n            rAmount \\u003c= _rTotal,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    function _distributeFees(Values memory values) private {\\n        _rTotal -= values.rReflectionFee;\\n        _rOwned[address(this)] += values.rOtherFees;\\n        _balances[address(this)] += values.tOtherFees;\\n    }\\n}\\n\"},\"BEP20Base.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\nimport \\\"IBEP20.sol\\\";\\nimport \\\"Context.sol\\\";\\n\\npragma solidity ^0.8.6;\\n\\nabstract contract BEP20Base is Context, IBEP20 {\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal _allowances;\\n    mapping(address =\\u003e uint256) internal _balances;\\n    string internal _name;\\n    string internal _symbol;\\n    uint8 internal _decimals;\\n    uint256 internal _totalSupply;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        uint256 totalSupply_\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n        _totalSupply = totalSupply_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(\\n            currentAllowance \\u003e= subtractedValue,\\n            \\\"BEP20: decreased allowance below zero\\\"\\n        );\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(\\n            currentAllowance \\u003e= amount,\\n            \\\"BEP20: transfer amount exceeds allowance\\\"\\n        );\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n        require(amount \\u003e 0, \\\"BEP20: amount must be greater than 0\\\");\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(\\n            senderBalance \\u003e= amount,\\n            \\\"BEP20: transfer amount exceeds balance\\\"\\n        );\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\n/**\\n * @dev Interface of the BEP20 standard.\\n */\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\"},\"IEcosystem.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\ninterface IEcosystem {\\n    function isWhitelisted(address token) external returns (bool);\\n}\"},\"ISwapV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\ninterface ISwapV2Factory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\\ninterface ISwapRouterV2 {\\n    function WETH() external pure returns (address);\\n\\n    function factory() external pure returns (address);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\nimport \\\"Context.sol\\\";\\n\\npragma solidity ^0.8.6;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddedToExcludeList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accumulatedAmount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EcosystemContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swappedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedBNB\",\"type\":\"uint256\"}],\"name\":\"LiquidityContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MarketingContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedFromExcludeList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addToExcludeList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"claimAccumulatedAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ecosystemAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccumulatedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeFromExcludeList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BabyBoxer", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://16f5aff981b7d0a037d764a04dae3718863a735e62228e1930ddb04d2bca8a5c"}