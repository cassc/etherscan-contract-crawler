{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWithdrawNFTByAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IWithdrawNFTByAdmin {\\n    function transferNftEmergency(address _receiver, uint256 _nftId) external;\\n\\n    function transferMultiNftsEmergency(address[] memory _receivers, uint256[] memory _nftIds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWithdrawTokenByAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IWithdrawTokenByAdmin {\\n    function recoverLostBNB() external;\\n\\n    function withdrawTokenEmergency(address _token, uint256 _amount) external;\\n\\n    function withdrawTokenEmergencyFrom(address _from, address _to, address _currency, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LowGasSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.0;\\n\\n/// @title Optimized overflow and underflow safe math operations\\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\\nlibrary LowGasSafeMath {\\n    /// @notice Returns x + y, reverts if sum overflows uint256\\n    /// @param x The augend\\n    /// @param y The addend\\n    /// @return z The sum of x and y\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x);\\n    }\\n\\n    /// @notice Returns x - y, reverts if underflows\\n    /// @param x The minuend\\n    /// @param y The subtrahend\\n    /// @return z The difference of x and y\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x);\\n    }\\n\\n    /// @notice Returns x * y, reverts if overflows\\n    /// @param x The multiplicand\\n    /// @param y The multiplier\\n    /// @return z The product of x and y\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(x == 0 || (z = x * y) / x == y);\\n    }\\n\\n    /// @notice Returns x + y, reverts if overflows or underflows\\n    /// @param x The augend\\n    /// @param y The addend\\n    /// @return z The sum of x and y\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x + y) >= x == (y >= 0));\\n    }\\n\\n    /// @notice Returns x - y, reverts if overflows or underflows\\n    /// @param x The minuend\\n    /// @param y The subtrahend\\n    /// @return z The difference of x and y\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x - y) <= x == (y >= 0));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2 ** 255);\\n        z = int256(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/market/IMarketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IMarketplace {\\n    event Buy(address seller, address buyer, uint256 nftId);\\n    event Sell(address seller, address buyer, uint256 nftId);\\n    event ErrorLog(bytes message);\\n\\n    function buyByCurrency(uint256 _nftId, uint256 _refCode) external;\\n\\n    function buyByToken(uint256 _nftId, uint256 _refCode) external;\\n\\n    function getActiveMemberForAccount(address _wallet) external view returns (uint256);\\n\\n    function getReferredNftValueForAccount(address _wallet) external view returns (uint256);\\n\\n    function getNftCommissionEarnedForAccount(address _wallet) external view returns (uint256);\\n\\n    function getNftSaleValueForAccountInUsdDecimal(address _wallet) external view returns (uint256);\\n\\n    function getF1ListForAccount(address _wallet) external view returns (address[] memory);\\n\\n    function getTeamNftSaleValueForAccountInUsdDecimal(address _wallet) external view returns (uint256);\\n\\n    function updateReferralData(address _user, uint256 _refCode) external;\\n\\n    function possibleChangeReferralData(address _wallet) external returns (bool);\\n\\n    function checkValidRefCodeAdvance(address _user, uint256 _refCode) external view returns (bool);\\n\\n    function genReferralCodeForAccount() external returns (uint256);\\n\\n    function getReferralCodeForAccount(address _wallet) external view returns (uint256);\\n\\n    function getReferralAccountForAccount(address _user) external view returns (address);\\n\\n    function getReferralAccountForAccountExternal(address _user) external view returns (address);\\n\\n    function getAccountForReferralCode(uint256 _refCode) external view returns (address);\\n\\n    function getMaxEarnableCommission(address _user) external view returns (uint256);\\n\\n    function getTotalCommissionEarned(address _user) external view returns (uint256);\\n\\n    function getCommissionLimit(address _user) external view returns (uint256);\\n\\n    function getNftPaymentType(uint256 _nftId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/market/IMarketplaceMigrate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IMarketplaceMigrate {\\n    function updateUserRefCodeOnlyOwner(address[] calldata _user, uint256[] calldata _refCode) external;\\n\\n    function updateNftCommissionEarnedOnlyOwner(\\n        address[] calldata _user,\\n        uint256[] calldata _commissionEarned\\n    ) external;\\n\\n    function updateNftSaleValueOnlyOwner(address[] calldata _users, uint256[] calldata _nftSaleValues) external;\\n\\n    function updateUserF1ListOnlyOwner(address _user, address[] memory _f1Users) external;\\n\\n    function updateNftPaymentTypeOnlyOwner(uint256[] calldata _nftIds, bool[] calldata _paymentTypes) external;\\n\\n    function updateUserRefParentOnlyOwner(address[] calldata _users, address[] calldata _parents) external;\\n}\\n\"\r\n    },\r\n    \"contracts/market/IMarketplaceSetting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IMarketplaceSetting {\\n    function allowBuyNftByCurrency(bool _activePayByCurrency) external;\\n\\n    function allowBuyNftByToken(bool _activePayByToken) external;\\n\\n    function setSystemWallet(address _newSystemWallet) external;\\n\\n    function setSaleWalletAddress(address _saleAddress) external;\\n\\n    function setOracleAddress(address _oracleAddress) external;\\n\\n    function setStakingAddress(address _stakingAddress) external;\\n\\n    function setCurrencyAddress(address _currency) external;\\n\\n    function setTokenAddress(address _token) external;\\n\\n    function setNftAddress(address _nft) external;\\n\\n    function setContractOwner(address _newContractOwner) external;\\n\\n    function setTypePayCommission(bool _typePayCommission) external;\\n\\n    function setCommissionPercent(uint256 _percent) external;\\n\\n    function setMaxCommissionDefault(uint256 _maxCommissionDefault) external;\\n\\n    function setCommissionMultipleTime(uint256 _commissionMultipleTime) external;\\n\\n    function setSaleStart(uint256 _newSaleStart) external;\\n\\n    function setSaleEnd(uint256 _newSaleEnd) external;\\n\\n    function setSalePercent(uint8 _nftTier, uint32 _newSalePercent) external;\\n}\\n\"\r\n    },\r\n    \"contracts/market/Marketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport \\\"../libraries/LowGasSafeMath.sol\\\";\\nimport \\\"../libraries/SafeCast.sol\\\";\\nimport \\\"./IMarketplace.sol\\\";\\nimport \\\"./IMarketplaceMigrate.sol\\\";\\nimport \\\"./IMarketplaceSetting.sol\\\";\\nimport \\\"../interfaces/IWithdrawTokenByAdmin.sol\\\";\\nimport \\\"../interfaces/IWithdrawNFTByAdmin.sol\\\";\\nimport \\\"../nft/IHREANFT.sol\\\";\\nimport \\\"../oracle/IOracle.sol\\\";\\nimport \\\"../stake/IStaking.sol\\\";\\n\\ncontract Marketplace is\\n    IMarketplace,\\n    Ownable,\\n    ERC721Holder,\\n    IWithdrawTokenByAdmin,\\n    IWithdrawNFTByAdmin,\\n    IMarketplaceMigrate,\\n    IMarketplaceSetting\\n{\\n    using LowGasSafeMath for uint256;\\n    using SafeCast for uint256;\\n\\n    uint256 public constant TOKEN_DECIMAL = 1e18;\\n    bool public constant PAYMENT_TYPE_TOKEN = false;\\n    bool public constant PAYMENT_TYPE_USDT = true;\\n\\n    address public nft;\\n    address public token;\\n    address public currency;\\n    address public oracleContract;\\n    address public stakingContract;\\n    address public systemWallet;\\n    address public saleWallet = 0xe3C6c3b651348aC36B138AEeAcFdfCB6962BF906;\\n    address private contractOwner;\\n\\n    // for network stats\\n    mapping(address => uint256) private nftCommissionEarned;\\n    mapping(address => uint256) private nftSaleValue;\\n    mapping(address => address[]) private userF1List;\\n\\n    mapping(uint256 => address) private referralCodeUser; // refCode => user\\n    mapping(address => uint256) private userReferralCode; // user => refCode\\n    mapping(address => address) private userRefParent; // user => parent\\n\\n    mapping(uint256 => bool) private nftPaymentType;\\n\\n    uint256 private saleStart = 1691625600; // 2023-08-10 00:00:00\\n    uint256 private saleEnd = 1692143999; // 2023-08-15 23:59:59\\n    mapping(uint8 => uint32) private salePercent; // Percent * 100, ex: 100 = 1%\\n\\n    uint256 private commissionBuyPercent = 0; // Percent * 100, ex: 100 = 1%\\n    uint256 private maxCommissionDefault = 500000000000000000000; // 500$\\n    uint256 private commissionMultipleTime = 5; // 5 x totalStakedAmount\\n\\n    bool private allowBuyByCurrency = true; // default allow\\n    bool private allowBuyByToken = true; // default true\\n    bool private typePayCom = true; // false is pay com by token, true is pay com by usdt\\n    bool private unlocked = true;\\n\\n    constructor(address _nft, address _token, address _oracle, address _systemWallet, address _currency) {\\n        nft = _nft;\\n        token = _token;\\n        currency = _currency;\\n        oracleContract = _oracle;\\n        systemWallet = _systemWallet;\\n        contractOwner = _msgSender();\\n        initDefaultReferral();\\n    }\\n\\n    modifier checkOwner() {\\n        require(owner() == _msgSender() || contractOwner == _msgSender(), \\\"MARKETPLACE: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier lock() {\\n        require(unlocked == true, \\\"MARKETPLACE: Locked\\\");\\n        unlocked = false;\\n        _;\\n        unlocked = true;\\n    }\\n\\n    modifier isAcceptBuyByCurrency() {\\n        require(allowBuyByCurrency, \\\"MARKETPLACE: Only accept payment in token\\\");\\n        _;\\n    }\\n\\n    modifier isAcceptBuyByToken() {\\n        require(allowBuyByToken, \\\"MARKETPLACE: Only accept payment in currency\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev init default referral as system wallet\\n     */\\n    function initDefaultReferral() internal {\\n        uint256 systemRefCode = 1000;\\n        userReferralCode[systemWallet] = systemRefCode;\\n        referralCodeUser[systemRefCode] = systemWallet;\\n    }\\n\\n    function getCurrentSalePercent(uint8 nftTier) internal view returns (uint256) {\\n        if (block.timestamp >= saleStart && block.timestamp < saleEnd) {\\n            return salePercent[nftTier];\\n        }\\n\\n        return 0;\\n    }\\n\\n    function updateNetworkData(address _buyer, uint256 _totalValueUsdWithDecimal) internal {\\n        uint256 currentNftSaleValue = nftSaleValue[_buyer];\\n        nftSaleValue[_buyer] = currentNftSaleValue + _totalValueUsdWithDecimal;\\n    }\\n\\n    /**\\n     * @dev buyByCurrency function\\n     * @param _nftId NFT ID want to buy\\n     * @param _refCode referral code of ref account\\n     */\\n    function buyByCurrency(uint256 _nftId, uint256 _refCode) external override isAcceptBuyByCurrency lock {\\n        updateReferralData(msg.sender, _refCode);\\n        uint256 totalValueUsdWithDecimal = IHREANFT(nft).getNftPriceUsd(_nftId) * TOKEN_DECIMAL;\\n        uint8 nftTier = IHREANFT(nft).getNftTier(_nftId);\\n        uint256 saleValueUsdWithDecimal = 0;\\n        {\\n            uint256 currentSale = getCurrentSalePercent(nftTier);\\n            if (currentSale > 0) {\\n                saleValueUsdWithDecimal = (totalValueUsdWithDecimal * currentSale) / 10000;\\n            }\\n        }\\n\\n        uint256 payValueUsdWithDecimal = totalValueUsdWithDecimal - saleValueUsdWithDecimal;\\n        pay(currency, payValueUsdWithDecimal);\\n\\n        // Transfer nft from marketplace to buyer\\n        IHREANFT(nft).safeTransferFrom(address(this), msg.sender, _nftId, \\\"\\\");\\n        nftPaymentType[_nftId] = PAYMENT_TYPE_USDT;\\n        emit Buy(address(this), msg.sender, _nftId);\\n\\n        updateNetworkData(msg.sender, totalValueUsdWithDecimal);\\n        address refAddress = getReferralAccountForAccount(msg.sender);\\n        payReferralCommissions(refAddress, totalValueUsdWithDecimal);\\n    }\\n\\n    /**\\n     * @dev buyByToken function\\n     * @param _nftId NFT ID want to buy\\n     * @param _refCode referral code of ref account\\n     */\\n    function buyByToken(uint256 _nftId, uint256 _refCode) external override isAcceptBuyByToken lock {\\n        updateReferralData(msg.sender, _refCode);\\n        uint256 totalValueUsdWithDecimal = IHREANFT(nft).getNftPriceUsd(_nftId) * TOKEN_DECIMAL;\\n        uint8 nftTier = IHREANFT(nft).getNftTier(_nftId);\\n        uint256 totalValueInTokenWithDecimal = IOracle(oracleContract).convertUsdBalanceDecimalToTokenDecimal(\\n            totalValueUsdWithDecimal\\n        );\\n\\n        uint256 saleValueInTokenWithDecimal = 0;\\n        {\\n            uint256 currentSale = getCurrentSalePercent(nftTier);\\n            if (currentSale > 0) {\\n                saleValueInTokenWithDecimal = (totalValueInTokenWithDecimal * currentSale) / 10000;\\n            }\\n        }\\n\\n        uint256 payValueTokenWithDecimal = totalValueInTokenWithDecimal - saleValueInTokenWithDecimal;\\n        pay(token, payValueTokenWithDecimal);\\n\\n        // Transfer nft from marketplace to buyer\\n        IHREANFT(nft).safeTransferFrom(address(this), msg.sender, _nftId, \\\"\\\");\\n        nftPaymentType[_nftId] = PAYMENT_TYPE_TOKEN;\\n        emit Buy(address(this), msg.sender, _nftId);\\n\\n        updateNetworkData(msg.sender, totalValueUsdWithDecimal);\\n        address refAddress = getReferralAccountForAccount(msg.sender);\\n        payReferralCommissions(refAddress, totalValueUsdWithDecimal);\\n    }\\n\\n    function pay(address payToken, uint256 payValueTokenWithDecimal) internal {\\n        require(\\n            IERC20(payToken).balanceOf(msg.sender) >= payValueTokenWithDecimal,\\n            \\\"MARKETPLACE: Not enough balance to buy NFTs\\\"\\n        );\\n        require(\\n            IERC20(payToken).allowance(msg.sender, address(this)) >= payValueTokenWithDecimal,\\n            \\\"MARKETPLACE: Must approve first\\\"\\n        );\\n        require(\\n            IERC20(payToken).transferFrom(msg.sender, saleWallet, payValueTokenWithDecimal),\\n            \\\"MARKETPLACE: Transfer to MARKETPLACE failed\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev get children of an address\\n     */\\n    function countChildrenUsers(address _wallet) public view returns (uint256) {\\n        address[] memory f1User = userF1List[_wallet];\\n        uint256 k = f1User.length;\\n\\n        for (uint256 i = 0; i < f1User.length; i++) {\\n            k += countChildrenUsers(f1User[i]);\\n        }\\n\\n        return k;\\n    }\\n\\n    /**\\n     * @dev generate a referral code for user (internal function)\\n     * @param _user user wallet address\\n     */\\n    function generateReferralCode(address _user) internal {\\n        uint256 salt = 1;\\n        uint256 refCode = generateRandomCode(salt, _user);\\n        while (referralCodeUser[refCode] != address(0) || refCode < 1001) {\\n            salt++;\\n            refCode = generateRandomCode(salt, _user);\\n        }\\n        userReferralCode[_user] = refCode;\\n        referralCodeUser[refCode] = _user;\\n    }\\n\\n    /**\\n     * @dev generate a random code for ref\\n     */\\n    function generateRandomCode(uint256 _salt, address _wallet) internal view returns (uint256) {\\n        bytes32 randomHash = keccak256(abi.encodePacked(block.timestamp, _wallet, _salt));\\n        return uint256(randomHash) % 1000000;\\n    }\\n\\n    /**\\n     * @dev the function pay commission(default 3%) to referral account\\n     */\\n    function payReferralCommissions(address _receiver, uint256 _amountUsdDecimal) internal {\\n        uint256 commissionAmountInUsdDecimal = (_amountUsdDecimal * commissionBuyPercent) / 10000;\\n        if (commissionAmountInUsdDecimal <= 0) {\\n            return;\\n        }\\n\\n        uint256 maxEarn = getMaxEarnableCommission(_receiver);\\n        if (maxEarn < commissionAmountInUsdDecimal) {\\n            commissionAmountInUsdDecimal = maxEarn;\\n        }\\n\\n        if (commissionAmountInUsdDecimal <= 0) {\\n            return;\\n        }\\n\\n        uint256 currentCommissionEarned = nftCommissionEarned[_receiver];\\n        nftCommissionEarned[_receiver] = currentCommissionEarned + commissionAmountInUsdDecimal;\\n\\n        if (typePayCom == PAYMENT_TYPE_USDT) {\\n            IERC20(currency).transfer(_receiver, commissionAmountInUsdDecimal);\\n        } else {\\n            uint256 commissionAmountInTokenDecimal = IOracle(oracleContract).convertUsdBalanceDecimalToTokenDecimal(\\n                commissionAmountInUsdDecimal\\n            );\\n            IERC20(token).transfer(_receiver, commissionAmountInTokenDecimal);\\n        }\\n    }\\n\\n    function getActiveMemberForAccount(address _wallet) external view override returns (uint256) {\\n        return userF1List[_wallet].length;\\n    }\\n\\n    function getReferredNftValueForAccount(address _wallet) external view override returns (uint256) {\\n        uint256 nftValue = 0;\\n        address[] memory f1Users = userF1List[_wallet];\\n        for (uint256 i = 0; i < f1Users.length; i++) {\\n            nftValue += nftSaleValue[f1Users[i]];\\n        }\\n\\n        return nftValue;\\n    }\\n\\n    function getNftCommissionEarnedForAccount(address _wallet) external view override returns (uint256) {\\n        return nftCommissionEarned[_wallet];\\n    }\\n\\n    /**\\n     * @dev get NFT sale value\\n     */\\n    function getNftSaleValueForAccountInUsdDecimal(address _wallet) external view override returns (uint256) {\\n        return nftSaleValue[_wallet];\\n    }\\n\\n    /**\\n     * @dev get children of an address\\n     */\\n    function getF1ListForAccount(address _wallet) external view override returns (address[] memory) {\\n        return userF1List[_wallet];\\n    }\\n\\n    /**\\n     * @dev get Team NFT sale value\\n     */\\n    function getTeamNftSaleValueForAccountInUsdDecimal(address _wallet) external view override returns (uint256) {\\n        uint256 teamNftValue = getChildrenNftSaleValueInUsdDecimal(_wallet);\\n        return teamNftValue;\\n    }\\n\\n    function getChildrenNftSaleValueInUsdDecimal(address _wallet) internal view returns (uint256) {\\n        uint256 nftValue = 0;\\n        uint256 f1Count = userF1List[_wallet].length;\\n        for (uint256 i = 0; i < f1Count; i++) {\\n            address f1 = userF1List[_wallet][i];\\n            nftValue += nftSaleValue[f1];\\n            nftValue += getChildrenNftSaleValueInUsdDecimal(f1);\\n        }\\n\\n        return nftValue;\\n    }\\n\\n    /**\\n     * @dev update referral data function\\n     * @param _refCode referral code of ref account\\n     */\\n    function updateReferralData(address _user, uint256 _refCode) public override {\\n        require(_user == _msgSender() || stakingContract == _msgSender(), \\\"MARKETPLACE: caller is not the input user\\\");\\n        require(systemWallet != _msgSender(), \\\"MARKETPLACE: system wallet can't update ref data\\\");\\n\\n        if (possibleChangeReferralData(_user)) {\\n            require(checkValidRefCodeAdvance(_user, _refCode), \\\"MARKETPLACE: Cheat ref detected\\\");\\n            _updateReferralData(_user, _refCode);\\n        }\\n    }\\n\\n    function _updateReferralData(address _user, uint256 _refCode) internal {\\n        address refAddress = getAccountForReferralCode(_refCode);\\n        userRefParent[_user] = refAddress;\\n\\n        if (userReferralCode[_user] == 0) {\\n            generateReferralCode(_user);\\n        }\\n\\n        userF1List[refAddress].push(_user);\\n    }\\n\\n    /**\\n     * @dev check possible to change referral data for a user\\n     * @param _user user wallet address\\n     */\\n    function possibleChangeReferralData(address _user) public view override returns (bool) {\\n        return userRefParent[_user] == address(0);\\n    }\\n\\n    function checkValidRefCodeAdvance(address _user, uint256 _refCode) public view override returns (bool) {\\n        address parentUser = getAccountForReferralCode(_refCode);\\n        if (parentUser == systemWallet) {\\n            return true;\\n        }\\n\\n        while (parentUser != address(0)) {\\n            if (_user == parentUser) {\\n                return false;\\n            }\\n\\n            parentUser = userRefParent[parentUser];\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev generate referral code for an account\\n     */\\n    function genReferralCodeForAccount() external override returns (uint256) {\\n        require(userReferralCode[msg.sender] == 0, \\\"MARKETPLACE: Account already have the ref code\\\");\\n        generateReferralCode(msg.sender);\\n        return userReferralCode[msg.sender];\\n    }\\n\\n    /**\\n     * @dev get referral code for an account\\n     * @param _user user wallet address\\n     */\\n    function getReferralCodeForAccount(address _user) external view override returns (uint256) {\\n        return userReferralCode[_user];\\n    }\\n\\n    /**\\n     * @dev the function return referral address for specified address\\n     */\\n    function getReferralAccountForAccount(address _user) public view override returns (address) {\\n        address refWallet = userRefParent[_user];\\n        if (refWallet == address(0)) {\\n            refWallet = systemWallet;\\n        }\\n        return refWallet;\\n    }\\n\\n    /**\\n     * @dev the function return referral address for specified address (without system)\\n     */\\n    function getReferralAccountForAccountExternal(address _user) public view override returns (address) {\\n        return userRefParent[_user];\\n    }\\n\\n    /**\\n     * @dev get account for referral code\\n     * @param _refCode refCode\\n     */\\n    function getAccountForReferralCode(uint256 _refCode) public view override returns (address) {\\n        address refAddress = referralCodeUser[_refCode];\\n        if (refAddress == address(0)) {\\n            refAddress = systemWallet;\\n        }\\n        return refAddress;\\n    }\\n\\n    function getMaxEarnableCommission(address _user) public view override returns (uint256) {\\n        uint256 maxEarn = getCommissionLimit(_user);\\n        uint256 earned = getTotalCommissionEarned(_user);\\n        if (maxEarn <= earned) {\\n            return 0;\\n        }\\n\\n        return maxEarn - earned;\\n    }\\n\\n    function getTotalCommissionEarned(address _user) public view override returns (uint256) {\\n        uint256 earned = nftCommissionEarned[_user];\\n        if (stakingContract != address(0)) {\\n            earned += IStaking(stakingContract).getTotalStakingCommissionEarned(_user);\\n        }\\n\\n        return earned;\\n    }\\n\\n    function getCommissionLimit(address _user) public view override returns (uint256) {\\n        uint256 maxEarn = maxCommissionDefault;\\n        uint256 defaultMax = maxCommissionDefault;\\n        {\\n            if (stakingContract != address(0)) {\\n                uint256 stakeMaxValue = IStaking(stakingContract).getTotalStakeAmountUSDWithDecimal(_user);\\n                maxEarn = stakeMaxValue * commissionMultipleTime;\\n                if (maxEarn < defaultMax) {\\n                    maxEarn = defaultMax;\\n                }\\n            }\\n        }\\n\\n        return maxEarn;\\n    }\\n\\n    function getNftPaymentType(uint256 _nftId) external view override returns (bool) {\\n        return nftPaymentType[_nftId];\\n    }\\n\\n    // Setting\\n    function allowBuyNftByCurrency(bool _activePayByCurrency) external override checkOwner {\\n        allowBuyByCurrency = _activePayByCurrency;\\n    }\\n\\n    function allowBuyNftByToken(bool _activePayByToken) external override checkOwner {\\n        allowBuyByToken = _activePayByToken;\\n    }\\n\\n    function setOracleAddress(address _oracleAddress) external override checkOwner {\\n        oracleContract = _oracleAddress;\\n    }\\n\\n    function setStakingAddress(address _stakingAddress) external override checkOwner {\\n        stakingContract = _stakingAddress;\\n    }\\n\\n    /**\\n     * @dev the function to update system wallet. Only owner can do this action\\n     */\\n    function setSystemWallet(address _newSystemWallet) external override checkOwner {\\n        systemWallet = _newSystemWallet;\\n        initDefaultReferral();\\n    }\\n\\n    function setSaleWalletAddress(address _saleAddress) external override checkOwner {\\n        require(_saleAddress != address(0), \\\"MARKETPLACE: Invalid Sale address\\\");\\n        saleWallet = _saleAddress;\\n    }\\n\\n    function setContractOwner(address _newContractOwner) external override checkOwner {\\n        contractOwner = _newContractOwner;\\n    }\\n\\n    function setCurrencyAddress(address _currency) external override checkOwner {\\n        currency = _currency;\\n    }\\n\\n    function setTokenAddress(address _token) external override checkOwner {\\n        token = _token;\\n    }\\n\\n    function setNftAddress(address _nft) external override checkOwner {\\n        nft = _nft;\\n    }\\n\\n    /**\\n     * @dev set type pay com(token or currency)\\n     *\\n     * false is pay com by token\\n     * true is pay com by usdt\\n     */\\n    function setTypePayCommission(bool _typePayCommission) external override checkOwner {\\n        typePayCom = _typePayCommission;\\n    }\\n\\n    function setCommissionPercent(uint256 _percent) external override checkOwner {\\n        commissionBuyPercent = _percent;\\n    }\\n\\n    function setMaxCommissionDefault(uint256 _maxCommissionDefault) external override checkOwner {\\n        maxCommissionDefault = _maxCommissionDefault;\\n    }\\n\\n    function setCommissionMultipleTime(uint256 _commissionMultipleTime) external override checkOwner {\\n        commissionMultipleTime = _commissionMultipleTime;\\n    }\\n\\n    function setSaleStart(uint256 _newSaleStart) external override checkOwner {\\n        saleStart = _newSaleStart;\\n    }\\n\\n    function setSaleEnd(uint256 _newSaleEnd) external override checkOwner {\\n        require(_newSaleEnd >= saleStart, \\\"MARKETPLACE: Time ending must greater than time beginning\\\");\\n        saleEnd = _newSaleEnd;\\n    }\\n\\n    function setSalePercent(uint8 _nftTier, uint32 _newSalePercent) external override checkOwner {\\n        salePercent[_nftTier] = _newSalePercent;\\n    }\\n\\n    // Migrate\\n    function updateUserRefCodeOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _refCodes\\n    ) external override checkOwner {\\n        require(_users.length == _refCodes.length, \\\"MARKETPLACE: _users and _refCodes must be same size\\\");\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            userReferralCode[_users[index]] = _refCodes[index];\\n            referralCodeUser[_refCodes[index]] = _users[index];\\n        }\\n    }\\n\\n    function updateNftCommissionEarnedOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _commissionEarneds\\n    ) external override checkOwner {\\n        require(\\n            _users.length == _commissionEarneds.length,\\n            \\\"MARKETPLACE: _users and _commissionEarneds must be same size\\\"\\n        );\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            nftCommissionEarned[_users[index]] = _commissionEarneds[index];\\n        }\\n    }\\n\\n    function updateNftSaleValueOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _nftSaleValues\\n    ) external override checkOwner {\\n        require(_users.length == _nftSaleValues.length, \\\"MARKETPLACE: _nftIds and _paymentTypes must be same size\\\");\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            nftSaleValue[_users[index]] = _nftSaleValues[index];\\n        }\\n    }\\n\\n    function updateUserF1ListOnlyOwner(address _user, address[] calldata _f1Users) external override checkOwner {\\n        userF1List[_user] = _f1Users;\\n        for (uint32 index = 0; index < _f1Users.length; index++) {\\n            userRefParent[_f1Users[index]] = _user;\\n        }\\n    }\\n\\n    function updateNftPaymentTypeOnlyOwner(\\n        uint256[] calldata _nftIds,\\n        bool[] calldata _paymentTypes\\n    ) external override checkOwner {\\n        require(_nftIds.length == _paymentTypes.length, \\\"MARKETPLACE: _nftIds and _paymentTypes must be same size\\\");\\n        for (uint32 index = 0; index < _nftIds.length; index++) {\\n            nftPaymentType[_nftIds[index]] = _paymentTypes[index];\\n        }\\n    }\\n\\n    function updateUserRefParentOnlyOwner(\\n        address[] calldata _users,\\n        address[] calldata _parents\\n    ) external override checkOwner {\\n        require(_users.length == _parents.length, \\\"MARKETPLACE: _users and _parents must be same size\\\");\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            userRefParent[_users[index]] = _parents[index];\\n        }\\n    }\\n\\n    // Withdraw token\\n    function recoverLostBNB() external override checkOwner {\\n        address payable recipient = payable(msg.sender);\\n        recipient.transfer(address(this).balance);\\n    }\\n\\n    function withdrawTokenEmergency(address _token, uint256 _amount) external override checkOwner {\\n        IERC20(_token).transfer(msg.sender, _amount);\\n    }\\n\\n    function withdrawTokenEmergencyFrom(\\n        address _from,\\n        address _to,\\n        address _token,\\n        uint256 _amount\\n    ) external override checkOwner {\\n        IERC20(_token).transferFrom(_from, _to, _amount);\\n    }\\n\\n    function transferNftEmergency(address _receiver, uint256 _nftId) public override checkOwner {\\n        IHREANFT(nft).safeTransferFrom(address(this), _receiver, _nftId, \\\"\\\");\\n    }\\n\\n    function transferMultiNftsEmergency(\\n        address[] calldata _receivers,\\n        uint256[] calldata _nftIds\\n    ) external override checkOwner {\\n        require(_receivers.length == _nftIds.length, \\\"MARKETPLACE: _receivers and _nftIds must be same size\\\");\\n        for (uint256 index = 0; index < _nftIds.length; index++) {\\n            transferNftEmergency(_receivers[index], _nftIds[index]);\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/nft/IHREANFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IHREANFT is IERC721 {\\n    function getNftPriceUsd(uint256 _nftId) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function getNftTier(uint256 _nftId) external view returns (uint8);\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IOracle {\\n    function convertUsdBalanceDecimalToTokenDecimal(uint256 _balanceUsdDecimal) external view returns (uint256);\\n\\n    function setUsdtAmount(uint256 _usdtAmount) external;\\n\\n    function setTokenAmount(uint256 _tokenAmount) external;\\n\\n    function setMinTokenAmount(uint256 _tokenAmount) external;\\n\\n    function setMaxTokenAmount(uint256 _tokenAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/stake/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IStaking {\\n    struct StakedNFT {\\n        address stakerAddress;\\n        uint256 startTime;\\n        uint256 unlockTime;\\n        uint256 lastClaimTime;\\n        uint256[] nftIds;\\n        uint256 totalValueStakeUsd;\\n        uint256 totalClaimedAmountUsdWithDecimal;\\n        uint256 totalRewardAmountUsdWithDecimal;\\n        uint32 apy;\\n        bool isUnstaked;\\n    }\\n\\n    event Staked(uint256 id, address indexed staker, uint256 indexed nftID, uint256 unlockTime, uint32 apy);\\n    event Unstaked(uint256 id, address indexed staker, uint256 indexed nftID);\\n    event Claimed(uint256 id, address indexed staker, uint256 claimAmount);\\n\\n    function getStakeApyForTier(uint8 _nftTier) external returns (uint32);\\n\\n    function getTotalCrewInvestment(address _wallet) external returns (uint256);\\n\\n    function getTeamStakingValue(address _wallet) external returns (uint256);\\n\\n    function getMaxEarnableCommission(address _user) external view returns (uint256);\\n\\n    function getTotalCommissionEarned(address _user) external view returns (uint256);\\n\\n    function getReferredStakedValue(address _wallet) external returns (uint256);\\n\\n    function getReferredStakedValueFull(address _wallet) external returns (uint256);\\n\\n    function getCurrentProfitLevel(address _wallet) external view returns (uint8);\\n\\n    function getProfitCommissionUnclaimed(address _wallet) external view returns (uint256);\\n\\n    function getProfitCommissionUnclaimedWithDeep(address _wallet, uint8 _deep) external view returns (uint256);\\n\\n    function getStakingCommissionEarned(address _wallet) external view returns (uint256);\\n\\n    function getProfitCommissionEarned(address _wallet) external view returns (uint256);\\n\\n    function getDirectCommissionEarned(address _wallet) external view returns (uint256);\\n\\n    function getTotalStakingCommissionEarned(address _wallet) external view returns (uint256);\\n\\n    function getTotalStakeAmountUSD(address _staker) external view returns (uint256);\\n\\n    function getTotalStakeAmountUSDWithDecimal(address _staker) external view returns (uint256);\\n\\n    function getTotalStakeAmountUSDWithoutDecimal(address _staker) external view returns (uint256);\\n\\n    function stake(uint256[] memory _nftIds, uint256 _refCode) external;\\n\\n    function unstake(uint256 _stakeId) external;\\n\\n    function claim(uint256 _stakeId) external;\\n\\n    function claimAll(uint256[] memory _stakeIds) external;\\n\\n    function getDetailOfStake(uint256 _stakeId) external view returns (StakedNFT memory);\\n\\n    function possibleUnstake(uint256 _stakeId) external view returns (bool);\\n\\n    function claimableForStakeInUsdWithDecimal(uint256 _stakeId) external view returns (uint256);\\n\\n    function rewardUnstakeInTokenWithDecimal(uint256 _stakeId) external view returns (uint256);\\n\\n    function estimateValueUsdForListNft(uint256[] memory _nftIds) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_systemWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"ErrorLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PAYMENT_TYPE_TOKEN\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMENT_TYPE_USDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_DECIMAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_activePayByCurrency\",\"type\":\"bool\"}],\"name\":\"allowBuyNftByCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_activePayByToken\",\"type\":\"bool\"}],\"name\":\"allowBuyNftByToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refCode\",\"type\":\"uint256\"}],\"name\":\"buyByCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refCode\",\"type\":\"uint256\"}],\"name\":\"buyByToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refCode\",\"type\":\"uint256\"}],\"name\":\"checkValidRefCodeAdvance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"countChildrenUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genReferralCodeForAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refCode\",\"type\":\"uint256\"}],\"name\":\"getAccountForReferralCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getActiveMemberForAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getCommissionLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getF1ListForAccount\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxEarnableCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getNftCommissionEarnedForAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getNftPaymentType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getNftSaleValueForAccountInUsdDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getReferralAccountForAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getReferralAccountForAccountExternal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getReferralCodeForAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getReferredNftValueForAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getTeamNftSaleValueForAccountInUsdDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTotalCommissionEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"possibleChangeReferralData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverLostBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commissionMultipleTime\",\"type\":\"uint256\"}],\"name\":\"setCommissionMultipleTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setCommissionPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newContractOwner\",\"type\":\"address\"}],\"name\":\"setContractOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"setCurrencyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxCommissionDefault\",\"type\":\"uint256\"}],\"name\":\"setMaxCommissionDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"}],\"name\":\"setNftAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"name\":\"setOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSaleEnd\",\"type\":\"uint256\"}],\"name\":\"setSaleEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_nftTier\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_newSalePercent\",\"type\":\"uint32\"}],\"name\":\"setSalePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSaleStart\",\"type\":\"uint256\"}],\"name\":\"setSaleStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_saleAddress\",\"type\":\"address\"}],\"name\":\"setSaleWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingAddress\",\"type\":\"address\"}],\"name\":\"setStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSystemWallet\",\"type\":\"address\"}],\"name\":\"setSystemWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_typePayCommission\",\"type\":\"bool\"}],\"name\":\"setTypePayCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftIds\",\"type\":\"uint256[]\"}],\"name\":\"transferMultiNftsEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"transferNftEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_commissionEarneds\",\"type\":\"uint256[]\"}],\"name\":\"updateNftCommissionEarnedOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"_paymentTypes\",\"type\":\"bool[]\"}],\"name\":\"updateNftPaymentTypeOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftSaleValues\",\"type\":\"uint256[]\"}],\"name\":\"updateNftSaleValueOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refCode\",\"type\":\"uint256\"}],\"name\":\"updateReferralData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_f1Users\",\"type\":\"address[]\"}],\"name\":\"updateUserF1ListOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_refCodes\",\"type\":\"uint256[]\"}],\"name\":\"updateUserRefCodeOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_parents\",\"type\":\"address[]\"}],\"name\":\"updateUserRefParentOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenEmergencyFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Marketplace", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000eb5ac83d637c7c788ae5db5b42d274c6810c15b9000000000000000000000000e5e0ebb9982ccb9c6e46efee69cbe02ddeb6fcdd0000000000000000000000000a165c14e00ba2f5904e48cb7528dec363bb44ea0000000000000000000000000ff52635f23af2f47b4d0b6492768f32f194dcc200000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}