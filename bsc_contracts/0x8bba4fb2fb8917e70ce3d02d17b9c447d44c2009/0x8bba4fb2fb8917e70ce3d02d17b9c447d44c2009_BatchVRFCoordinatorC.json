{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/vrf/BatchVRFCoordinatorContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./VRFTypes.sol\\\";\\n\\n/**\\n * @title BatchVRFCoordinatorV2\\n * @notice The BatchVRFCoordinatorV2 contract acts as a proxy to write many random responses to the\\n *   provided VRFCoordinatorV2 contract efficiently in a single transaction.\\n */\\ncontract BatchVRFCoordinatorContract {\\n  VRFCoordinatorV2 public immutable COORDINATOR;\\n\\n  event ErrorReturned(uint256 indexed requestId, string reason);\\n  event RawErrorReturned(uint256 indexed requestId, bytes lowLevelData);\\n  event PatchFulfillSuccess(address leaderAddress);\\n  event CallGetSwitchStatusErrorReturned(string reason);\\n  event CallGetSwitchStatusRawErrorReturned(bytes lowLevelData);\\n  event CallGetNodeAuthStatusErrorReturned(string reason);\\n  event CallGetNodeAuthStatusRawErrorReturned(bytes lowLevelData);\\n  error NoAuthFulfillRandomWords(address node);\\n  constructor(address coordinatorAddr) {\\n    COORDINATOR = VRFCoordinatorV2(coordinatorAddr);\\n  }\\n\\n  /**\\n   * @notice fulfills multiple randomness requests with the provided proofs and commitments.\\n   * @param proofs the randomness proofs generated by the VRF provider.\\n   * @param rcs the request commitments corresponding to the randomness proofs.\\n   */\\n  function fulfillRandomWords(VRFTypes.Proof[] memory proofs, VRFTypes.RequestCommitment[] memory rcs ) external checkNodeAccess(msg.sender) {\\n    require(proofs.length == rcs.length, \\\"input array arg lengths mismatch\\\");\\n    for (uint256 i = 0; i < proofs.length; i++) {\\n      try COORDINATOR.fulfillRandomWords(proofs[i], rcs[i]) returns (\\n        uint96 /* payment */\\n      ) {\\n        continue;\\n      } catch Error(string memory reason) {\\n        uint256 requestId = getRequestIdFromProof(proofs[i]);\\n        emit ErrorReturned(requestId, reason);\\n      } catch (bytes memory lowLevelData) {\\n        uint256 requestId = getRequestIdFromProof(proofs[i]);\\n        emit RawErrorReturned(requestId, lowLevelData);\\n      }\\n    }\\n    emit PatchFulfillSuccess(msg.sender);\\n  }\\n\\n  /**\\n   * @notice Returns the proving key hash associated with this public key.\\n   * @param publicKey the key to return the hash of.\\n   */\\n  function hashOfKey(uint256[2] memory publicKey) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(publicKey));\\n  }\\n\\n  /**\\n   * @notice Returns the request ID of the request associated with the given proof.\\n   * @param proof the VRF proof provided by the VRF oracle.\\n   */\\n  function getRequestIdFromProof(VRFTypes.Proof memory proof) internal pure returns (uint256) {\\n    bytes32 keyHash = hashOfKey(proof.pk);\\n    return uint256(keccak256(abi.encode(keyHash, proof.seed)));\\n  }\\n\\n  /**\\n   * @notice check if node has access\\n    */\\n  modifier checkNodeAccess(address node) {\\n    try COORDINATOR.getNodesWhiteListSwitchStatus() returns ( bool nodesWhiteListSwitchStatus ) {\\n      try COORDINATOR.getNodeAccessStatus(node) returns ( bool PermissionOrNot ) {\\n        if(nodesWhiteListSwitchStatus && !PermissionOrNot){\\n          revert NoAuthFulfillRandomWords(node);\\n        }\\n        _;\\n      } catch Error(string memory reason) {\\n        emit CallGetNodeAuthStatusErrorReturned(reason);\\n      } catch (bytes memory lowLevelData) {\\n        emit CallGetNodeAuthStatusRawErrorReturned(lowLevelData);\\n      }\\n    } catch Error(string memory reason) {\\n      emit CallGetSwitchStatusErrorReturned(reason);\\n    } catch (bytes memory lowLevelData) {\\n      emit CallGetSwitchStatusRawErrorReturned(lowLevelData);\\n    }\\n  }\\n}\\n\\ninterface VRFCoordinatorV2 {\\n  function fulfillRandomWords(VRFTypes.Proof memory proof, VRFTypes.RequestCommitment memory rc)\\n    external\\n    returns (uint96);\\n  function getNodeAccessStatus(address node) external view returns (bool);\\n  function getNodesWhiteListSwitchStatus() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/vrf/VRFTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/**\\n * @title VRFTypes\\n * @notice The VRFTypes library is a collection of types that is required to fulfill VRF requests\\n * \\ton-chain. They must be ABI-compatible with the types used by the coordinator contracts.\\n */\\nlibrary VRFTypes {\\n  // ABI-compatible with VRF.Proof.\\n  // This proof is used for VRF V2.\\n  struct Proof {\\n    uint256[2] pk;\\n    uint256[2] gamma;\\n    uint256 c;\\n    uint256 s;\\n    uint256 seed;\\n    address uWitness;\\n    uint256[2] cGammaWitness;\\n    uint256[2] sHashWitness;\\n    uint256 zInv;\\n  }\\n\\n  // ABI-compatible with VRFCoordinatorV2.RequestCommitment.\\n  // This is only used for VRF V2.\\n  struct RequestCommitment {\\n    uint64 blockNum;\\n    uint64 subId;\\n    uint32 callbackGasLimit;\\n    uint32 numWords;\\n    address sender;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coordinatorAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"NoAuthFulfillRandomWords\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"CallGetNodeAuthStatusErrorReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lowLevelData\",\"type\":\"bytes\"}],\"name\":\"CallGetNodeAuthStatusRawErrorReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"CallGetSwitchStatusErrorReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lowLevelData\",\"type\":\"bytes\"}],\"name\":\"CallGetSwitchStatusRawErrorReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ErrorReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"leaderAddress\",\"type\":\"address\"}],\"name\":\"PatchFulfillSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lowLevelData\",\"type\":\"bytes\"}],\"name\":\"RawErrorReturned\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COORDINATOR\",\"outputs\":[{\"internalType\":\"contract VRFCoordinatorV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"pk\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"gamma\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uWitness\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"cGammaWitness\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"sHashWitness\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"zInv\",\"type\":\"uint256\"}],\"internalType\":\"struct VRFTypes.Proof[]\",\"name\":\"proofs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"internalType\":\"struct VRFTypes.RequestCommitment[]\",\"name\":\"rcs\",\"type\":\"tuple[]\"}],\"name\":\"fulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BatchVRFCoordinatorContract", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000009632ade542f12114f5e5ad4d6f8e47fb993955da", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}