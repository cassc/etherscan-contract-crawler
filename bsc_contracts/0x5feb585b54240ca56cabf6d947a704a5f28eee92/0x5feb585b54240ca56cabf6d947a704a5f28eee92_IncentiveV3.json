{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0 ;\r\n\r\ninterface IERC20 {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\ninterface IPledgeContract {\r\n    function queryNodeIndex(address _nodeAddr) external view returns(uint256);\r\n}\r\n\r\ninterface Isenator{\r\n    function getExecuter() external view returns (address);\r\n    function isSenator(address user) external view returns (bool);\r\n}\r\n\r\ninterface IEfficacyContract {\r\n    function verfiyParams(address[2] calldata addrs,uint256[2] calldata uints,bytes32 code, bytes32 digest) external view returns(bool);\r\n}\r\n\r\ninterface IIncentive {\r\n    function withdrawToken(address[2] calldata addrs,uint256[2] calldata uints,bytes32 code,uint8[] calldata vs,bytes32[] calldata rssMetadata) external;\r\n}\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Initializable{\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init_unchained() internal initializer {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract  IncentiveV3  is Initializable,Ownable,IIncentive {\r\n    IPledgeContract public pledgeContract;\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    bool public pause;\r\n    mapping(address => uint256) public nonce;\r\n    mapping(address => uint256) public withdrawSums;\r\n    mapping(address => mapping(uint256 => uint256)) public withdrawAmounts;\r\n    IEfficacyContract public efficacyContract;\r\n    address public exector;\r\n    uint256 public threshold;\r\n    mapping(uint256 => uint256) public withdrawLimit;\r\n    uint256 public signNum;\r\n    address public senator;\r\n    address public exectorTwo;\r\n    uint256 public lastExecuteTime;\r\n    address public lastExector;\r\n    event WithdrawToken(address indexed _userAddr, uint256 _nonce, uint256 _amount);\r\n    mapping(address => bool) public isBlacklisted;\r\n    mapping(address => bool) public approval1;\r\n    mapping(address => bool) public approval2;\r\n    event AddedToBlacklist(address indexed _address);\r\n    event DeleteToBlacklist(address indexed _address);\r\n    event ApprovalReceived(address indexed _address, address indexed _approver);\r\n\r\n    struct Data {\r\n        address userAddr;\r\n        address contractAddr;\r\n        uint256 amount;\r\n        uint256 expiration;\r\n    }\r\n\r\n    struct Sig {\r\n        /* v parameter */\r\n        uint8 v;\r\n        /* r parameter */\r\n        bytes32 r;\r\n        /* s parameter */\r\n        bytes32 s;\r\n    }\r\n\r\n    modifier onlyGuard() {\r\n        require(!pause, \"IncentiveContracts: The system is suspended\");\r\n        _;\r\n    }\r\n\r\n    function init(address _pledgeContract) external initializer{\r\n        __Ownable_init_unchained();\r\n        __Incentive_init_unchained(_pledgeContract);\r\n    }\r\n    \r\n    function __Incentive_init_unchained(address _pledgeContract) internal initializer{\r\n        require(_pledgeContract != address(0), \"_pledgeContract address cannot be 0\");\r\n        pledgeContract = IPledgeContract(_pledgeContract);\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainId\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(uint256 chainId,address verifyingContract)'),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    receive() payable external{\r\n\r\n    }\r\n\r\n    function  updatePause(bool _sta) external onlyOwner{\r\n        pause = _sta;\r\n    }\r\n\r\n    function  updateSenator(address _senator) external onlyOwner{\r\n        senator = _senator;\r\n    }\r\n\r\n    function  updateThreshold(uint256 _threshold) external onlyOwner{\r\n        threshold = _threshold;\r\n    }\r\n\r\n    function  updateSignNum(uint256 _signNum) external onlyOwner{\r\n        require(_signNum > 18, \"IncentiveContracts: parameter error\");\r\n        signNum = _signNum;\r\n    }\r\n\r\n    function  updateExector(uint256 _index, address _exector) external onlyOwner{\r\n        if(_index ==1){\r\n            exector = _exector;\r\n        }else {\r\n            exectorTwo = _exector;\r\n        }\r\n        \r\n    }\r\n\r\n    function close() external{\r\n        require(exector == msg.sender || exectorTwo == msg.sender, \"IncentiveContracts: not exector\");\r\n        if (lastExector == address(0) || lastExector == msg.sender) {\r\n            lastExector = msg.sender;\r\n            lastExecuteTime = block.timestamp;\r\n        } else if (block.timestamp - lastExecuteTime <= 2 days) {\r\n            pause = true;\r\n        } else {\r\n            lastExector = msg.sender;\r\n            lastExecuteTime = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function approveBlacklisting(address[] calldata addrs) external {\r\n        require(exector == msg.sender || exectorTwo == msg.sender, \"IncentiveContracts: not exector\");\r\n        address addr;\r\n        for (uint i=0; i<addrs.length; i++){\r\n            addr = addrs[i];\r\n            if (msg.sender == exector) {\r\n                approval1[addr] = true;\r\n            } else if (msg.sender == exectorTwo) {\r\n                approval2[addr] = true;\r\n            }\r\n            emit ApprovalReceived(addr, msg.sender);\r\n\r\n            if (approval1[addr] && approval2[addr]) {\r\n                isBlacklisted[addr] = true;\r\n                emit AddedToBlacklist(addr);\r\n            }\r\n        }\r\n    }\r\n\r\n    function cancelBlacklisting(address[] calldata addrs) external onlyOwner{\r\n        for (uint i=0; i<addrs.length; i++){\r\n            isBlacklisted[addrs[i]] = false;\r\n            emit DeleteToBlacklist(addrs[i]);\r\n        }\r\n    }\r\n\r\n    function  updateEfficacyContract(address _addr) external onlyOwner{\r\n        efficacyContract = IEfficacyContract(_addr);\r\n    }\r\n\r\n    /**\r\n    * @notice A method to the user withdraw revenue.\r\n    * The extracted proceeds are signed by at least 11 PAGERANK servers, in order to withdraw successfully\r\n    */\r\n    function withdrawToken(\r\n        address[2] calldata addrs,\r\n        uint256[2] calldata uints,\r\n        bytes32 code,\r\n        uint8[] calldata vs,\r\n        bytes32[] calldata rssMetadata\r\n    )\r\n        override\r\n        external\r\n        onlyGuard\r\n    {\r\n        require(addrs[0] == msg.sender, \"IncentiveContracts: Signing users are not the same as trading users\");\r\n        require(!isBlacklisted[msg.sender], \"IncentiveContracts: invalid address\");\r\n        require( block.timestamp<= uints[1], \"IncentiveContracts: The transaction exceeded the time limit\");\r\n        uint256 len = vs.length;\r\n        uint256 counter;\r\n        uint256 _nonce = nonce[addrs[0]]++;\r\n        require(len*2 == rssMetadata.length, \"IncentiveContracts: Signature parameter length mismatch\");\r\n        require(verfylimit(uints[0]),\"Extraction limit exceeded\");\r\n        uint256[] memory arr = new uint256[](len);\r\n        bytes32 digest = getDigest(Data( addrs[0], addrs[1], uints[0], uints[1]), _nonce);\r\n        require(efficacyContract.verfiyParams(addrs, uints, code, digest), \"IncentiveContracts: code error\");\r\n        for (uint256 i = 0; i < len; i++) {\r\n            (bool result, address signAddr) = verifySign(\r\n                digest,\r\n                Sig(vs[i], rssMetadata[i*2], rssMetadata[i*2+1])\r\n            );\r\n            arr[i] = uint256(uint160(signAddr));\r\n            if (result){\r\n                counter++;\r\n            }\r\n        }\r\n        uint256 _signNum = (signNum != 0) ? signNum : 18;\r\n        require(\r\n            counter >= _signNum,\r\n            \"The number of signed accounts did not reach the minimum threshold\"\r\n        );\r\n        require(areElementsUnique(arr), \"IncentiveContracts: Signature parameter not unique\");\r\n        withdrawSums[addrs[0]] +=  uints[0];\r\n        withdrawAmounts[addrs[0]][_nonce] =  uints[0];\r\n        IERC20  token = IERC20(addrs[1]);\r\n        require(\r\n            token.transfer(addrs[0],uints[0]),\r\n            \"Token transfer failed\"\r\n        );\r\n        emit WithdrawToken(addrs[0], _nonce, uints[0]);\r\n    }\r\n    \r\n    function verifySign(bytes32 _digest,Sig memory _sig) internal view returns (bool, address)  {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 hash = keccak256(abi.encodePacked(prefix, _digest));\r\n        address _accessAccount = ecrecover(hash, _sig.v, _sig.r, _sig.s);\r\n        bool result = Isenator(senator).isSenator(_accessAccount);\r\n        address executer = Isenator(senator).getExecuter();\r\n        if(!result && executer == _accessAccount)result=true;\r\n        return (result, _accessAccount);\r\n    }\r\n\r\n    function verfylimit(uint256 amount) internal returns (bool) {\r\n        uint256 day = block.timestamp/86400;\r\n        withdrawLimit[day] += amount;\r\n        return threshold > withdrawLimit[day];\r\n    }\r\n\r\n    function areElementsUnique(uint256[] memory arr) internal pure returns (bool) {\r\n        for(uint i = 0; i < arr.length - 1; i++) {\r\n            for(uint j = i + 1; j < arr.length; j++) {\r\n                if (arr[i] == arr[j]) {\r\n                    return false; \r\n                }\r\n            }\r\n        }\r\n        return true; \r\n    }\r\n\r\n    function getDigest(Data memory _data, uint256 _nonce) internal view returns(bytes32 digest){\r\n        digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(_data.userAddr, _data.contractAddr,  _data.amount, _data.expiration, _nonce))\r\n            )\r\n        );\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddedToBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approver\",\"type\":\"address\"}],\"name\":\"ApprovalReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"DeleteToBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approval1\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approval2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"approveBlacklisting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"cancelBlacklisting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"efficacyContract\",\"outputs\":[{\"internalType\":\"contract IEfficacyContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exectorTwo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pledgeContract\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastExector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastExecuteTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pledgeContract\",\"outputs\":[{\"internalType\":\"contract IPledgeContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"senator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"updateEfficacyContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_exector\",\"type\":\"address\"}],\"name\":\"updateExector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_sta\",\"type\":\"bool\"}],\"name\":\"updatePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_senator\",\"type\":\"address\"}],\"name\":\"updateSenator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_signNum\",\"type\":\"uint256\"}],\"name\":\"updateSignNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"updateThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawSums\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"addrs\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"uints\",\"type\":\"uint256[2]\"},{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"},{\"internalType\":\"uint8[]\",\"name\":\"vs\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"rssMetadata\",\"type\":\"bytes32[]\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "IncentiveV3", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://855d75a781379b1f2a973c9855fce803253fc89c1b9f710608929554744aa5d6"}