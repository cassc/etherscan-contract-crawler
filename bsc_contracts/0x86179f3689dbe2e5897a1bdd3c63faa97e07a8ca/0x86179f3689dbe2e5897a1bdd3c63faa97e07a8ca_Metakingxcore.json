{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary SafeMath {\r\n   \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n   \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n   \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    \r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface levelcorePlan {\r\n    function newuseractive(address _UserAddress, address _referAddress,uint levels) external;\r\n    function transfersecondlvl(address userAddress, uint amount,uint levels) external;\r\n    function transfertoken(address useraddress,address referAddress, uint amount) external;\r\n    function getuseraddress(address _user) external view returns(address[] memory );\r\n}\r\n\r\n\r\n\r\ncontract Metakingxcore  {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public contractOwner;\r\n    address public rewardwallet;\r\n    IERC20 public depositToken;\r\n    uint public BASIC_PRICE;\r\n    address public id1;\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public userIds;\r\n    mapping(uint256 => uint) public levelPrice;\r\n    mapping(uint => address) public idToAddress;\r\n\r\n    uint256 public LAST_LEVEL;\r\n    uint public lastUserId;\r\n    address lastReinvestAddress;\r\n    address public levelplanAddress;\r\n    uint public XcoreAndLevelContractTotAmount;\r\n\r\n    struct User {\r\n        uint id;\r\n        address referrer;\r\n        bool exists;   \r\n        uint amount;\r\n        uint usercycles;\r\n        mapping(uint256 => bool) activeX6Levels;\r\n        mapping(uint256 => mapping(uint256 => X6)) x6Matrix;\r\n        mapping(uint256 => X3) x3Matrix;\r\n        uint8 userlevels;\r\n        mapping(uint256 => uint8) cycles;\r\n        mapping(uint256 => uint256) userEarnAmount;\r\n        mapping(uint256 => uint256) totalTeamMembers;\r\n    }\r\n\r\n    struct X3 {\r\n        address currentReferrer;\r\n        address[] referrals;\r\n        bool blocked;\r\n        uint reinvestCount;\r\n    }\r\n\r\n\r\n    struct X6 {\r\n        address currentReferrer;\r\n        firstrefValue[] firstLevelReferrals;\r\n        secondrefValue[] secondLevelReferrals;\r\n        uint128 reinvestCount;\r\n        uint256 currentReferrerIndex;\r\n        bool blocked;\r\n        address closedPart;\r\n    }\r\n\r\n    struct firstrefValue {\r\n        address refAddress;\r\n        uint refId;\r\n        uint timestamp;\r\n        uint level;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct secondrefValue {\r\n        address refAddress;\r\n        uint refId;\r\n        uint timestamp;\r\n        uint level;\r\n        uint256 amount;\r\n    }\r\n\r\n    modifier onlyContractOwner() { \r\n        require(msg.sender == contractOwner, \"onlyOwner\"); \r\n        _; \r\n    }\r\n\r\n\r\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\r\n    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);\r\n    event NewUserPlace(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint8 place);\r\n    event MissedEthReceive(address indexed receiver, address indexed from, uint256 level);\r\n    event ReleasedETH(address indexed from, address indexed to, uint256 level, uint value);\r\n    event StoredETH(address indexed from, address indexed to, uint256 level, uint value);\r\n    event SentExtraEthDividends(address indexed from, address indexed receiver, uint8 matrix, uint8 level);\r\n    event MissedEthReceive(address indexed receiver, address indexed from, uint8 matrix, uint8 level);\r\n\r\n    constructor(address _ownerAddress, \r\n        IERC20 _depositTokenAddress,\r\n        address _levelplanAddress,\r\n        address _rewardwallet) public {\r\n        BASIC_PRICE = 15e18;\r\n        LAST_LEVEL = 12;\r\n\r\n        levelPrice[1] = BASIC_PRICE;\r\n        levelPrice[2] = 30e18;\r\n        levelPrice[3] = 100e18;\r\n        levelPrice[4] = 200e18;\r\n        levelPrice[5] = 300e18;\r\n        levelPrice[6] = 500e18;\r\n        levelPrice[7] = 1000e18;\r\n        levelPrice[8] = 1500e18;\r\n        levelPrice[9] = 2500e18;\r\n        levelPrice[10] = 5000e18;\r\n        \r\n        id1 = _ownerAddress;\r\n        \r\n        User memory user = User({\r\n            id: 1,\r\n            referrer: address(0),\r\n            exists: true,\r\n            amount:0,\r\n            userlevels:1,\r\n            usercycles:1\r\n        });\r\n        \r\n        users[_ownerAddress] = user;\r\n        idToAddress[1] = _ownerAddress;\r\n        \r\n        for (uint256 i = 1; i <= LAST_LEVEL; i++) {\r\n            users[_ownerAddress].activeX6Levels[i] = true;\r\n        }\r\n        \r\n        userIds[1] = _ownerAddress;\r\n\r\n        lastUserId = 2;\r\n\r\n        depositToken = _depositTokenAddress;\r\n        contractOwner = msg.sender;\r\n        levelplanAddress = _levelplanAddress;\r\n        rewardwallet = _rewardwallet;\r\n    }\r\n\r\n    function ownerchange(address _AdminAddress) external onlyContractOwner() {\r\n        id1 = _AdminAddress;\r\n    }\r\n\r\n    function userlevelactive(address _user,uint _level) external onlyContractOwner() {\r\n        users[_user].activeX6Levels[_level] = true;\r\n    }\r\n\r\n    function ActivelevelChange(address _UserAddress,address _referAddress) external onlyContractOwner() {\r\n        require(!isUserExists(_UserAddress), \"user exists\");\r\n        User memory user = User({\r\n            id: lastUserId,\r\n            referrer: _referAddress,\r\n            exists: true,\r\n            amount:0,\r\n            userlevels:1,\r\n            usercycles:1\r\n        });\r\n        \r\n        users[_UserAddress] = user;\r\n        idToAddress[lastUserId] = _UserAddress;\r\n        userIds[lastUserId] = _UserAddress;\r\n        for (uint256 i = 1; i <= LAST_LEVEL; i++) {\r\n            users[_UserAddress].activeX6Levels[i] = true;\r\n        }\r\n        lastUserId++;\r\n    }\r\n\r\n    function newuserAdd(address _useraddr,address _referaddr, uint _level) external {\r\n        require(!isUserExists(_useraddr), \"user exists\");\r\n        User memory user = User({\r\n            id: lastUserId,\r\n            referrer: _referaddr,\r\n            exists: true,\r\n            amount:0,\r\n            userlevels:1,\r\n            usercycles:1\r\n        });\r\n        \r\n        users[_useraddr] = user;\r\n        idToAddress[lastUserId] = _useraddr;\r\n        userIds[lastUserId] = _useraddr;\r\n        for (uint256 i = 1; i <= _level; i++) {\r\n            users[_useraddr].activeX6Levels[i] = true;\r\n        }\r\n        lastUserId++;\r\n        uint8 lvlNumber = users[_referaddr].userlevels;\r\n        updateuserX6Referrer(_useraddr, _referaddr, users[_useraddr].userlevels ,users[_referaddr].cycles[lvlNumber]);\r\n    }\r\n\r\n\r\n    function updateuserX6Referrer(address user,address refer,uint levels, uint cycles) internal {\r\n        uint rewardpercent = (levelPrice[1] * 10)/100;\r\n        uint usrrewardsprn = levelPrice[1] - rewardpercent;\r\n        uint refersamount = ((usrrewardsprn/2) * 50 )/100;\r\n        if (users[refer].x6Matrix[levels][cycles].firstLevelReferrals.length < 3) {\r\n            firstrefValue memory newReferralfirst = firstrefValue({\r\n                refAddress: user,\r\n                refId: users[user].id,\r\n                timestamp:block.timestamp,\r\n                level:levels,\r\n                amount:refersamount\r\n            });\r\n            users[refer].x6Matrix[levels][cycles].firstLevelReferrals.push(newReferralfirst);\r\n            //set current level\r\n            users[user].x6Matrix[levels][cycles].currentReferrer = refer;\r\n        }\r\n        else if (users[refer].x6Matrix[levels][cycles].secondLevelReferrals.length < 9) {\r\n            secondrefValue memory newReferralsecond = secondrefValue({\r\n                refAddress: user,\r\n                refId: users[user].id,\r\n                timestamp:block.timestamp,\r\n                level:levels,\r\n                amount:refersamount\r\n            });\r\n            users[refer].x6Matrix[levels][cycles].secondLevelReferrals.push(newReferralsecond);\r\n            users[refer].userEarnAmount[levels] = users[refer].userEarnAmount[levels] + ((levelPrice[levels]/2) * 50 )/100;\r\n            users[refer].totalTeamMembers[levels] = users[refer].totalTeamMembers[levels]+1;\r\n        }\r\n    }\r\n\r\n\r\n    function buyNewLevelFor(address userAddress, uint8 level) external {\r\n        _buyNewLevel(userAddress, level);\r\n    }\r\n\r\n    function registrationFor(address userAddress, address referrerAddress) external returns(uint256,address) {\r\n        (uint256 id,address refer) = registration(userAddress, referrerAddress);\r\n        return (id,refer);   \r\n    }\r\n\r\n    function registrationExt(address userAddress, address referrerAddress) external  {\r\n        require(userAddress != referrerAddress ,\"Not a valid address\");\r\n        registration(userAddress,referrerAddress);\r\n    }\r\n\r\n    function usercompletelevel(address _userAddress, uint8 level) external view returns(bool)  {\r\n        bool active = users[_userAddress].activeX6Levels[level];\r\n        return active;\r\n    }\r\n\r\n    function finduplineReferrer(address userAddress, uint256 level) public view returns(address) {\r\n        while (true) {\r\n           address referrer = users[userAddress].referrer;\r\n            if(referrer == id1) {\r\n                return id1;\r\n            }\r\n            if (users[referrer].activeX6Levels[level]) {\r\n                return users[userAddress].referrer;\r\n            }\r\n            if(referrer == address(0)) {\r\n                return id1;\r\n            }\r\n            userAddress = referrer;\r\n        }\r\n        return id1;\r\n    }\r\n\r\n\r\n    function _buyNewLevel(address _userAddress, uint8 level) internal {\r\n        require(isUserExists(_userAddress), \"user is not exists. Register first.\");\r\n        address freeX6Referrer = finduplineReferrer(_userAddress, level);  \r\n\r\n        uint rewardpercent = (levelPrice[level] * 10)/100;\r\n        uint usrrewardsprn = levelPrice[level] - rewardpercent;\r\n        uint refersamount = ((usrrewardsprn/2) * 50 )/100;\r\n\r\n        depositToken.safeTransferFrom(_userAddress,rewardwallet, rewardpercent);\r\n        depositToken.safeTransferFrom(_userAddress,levelplanAddress, usrrewardsprn/2);\r\n    \r\n        XcoreAndLevelContractTotAmount = XcoreAndLevelContractTotAmount + levelPrice[level];\r\n        levelcorePlan(levelplanAddress).transfersecondlvl(_userAddress,usrrewardsprn/2,level);\r\n        \r\n        require(level > 1 && level <= LAST_LEVEL, \"invalid level\");\r\n       \r\n        require(users[_userAddress].activeX6Levels[level-1], \"buy previous level first\");\r\n        require(!users[_userAddress].activeX6Levels[level], \"level already activated\"); \r\n        uint8 cycleNum = users[_userAddress].cycles[level];\r\n\r\n        if (users[_userAddress].x6Matrix[level-1][cycleNum].blocked) {\r\n            users[_userAddress].x6Matrix[level-1][cycleNum].blocked = false;\r\n        }\r\n            \r\n        users[_userAddress].activeX6Levels[level] = true;\r\n        updateX6Referrer(_userAddress, freeX6Referrer, level, cycleNum, refersamount);\r\n    }\r\n\r\n\r\n\r\n    function registration(address userAddress,address referrerAddress) private returns(uint ,address) {\r\n        XcoreAndLevelContractTotAmount = XcoreAndLevelContractTotAmount + BASIC_PRICE;\r\n         \r\n        require(!isUserExists(userAddress), \"user exists\");\r\n        User memory user = User({\r\n            id: lastUserId,\r\n            referrer: referrerAddress,\r\n            exists: true,\r\n            amount:BASIC_PRICE,\r\n            userlevels:1,\r\n            usercycles:1\r\n        });\r\n        users[userAddress] = user;\r\n\r\n        idToAddress[lastUserId] = userAddress;\r\n        users[userAddress].activeX6Levels[1] = true;\r\n\r\n        uint rewardpercent = (levelPrice[1] * 10)/100;\r\n        uint usrrewardsprn = levelPrice[1] - rewardpercent;\r\n\r\n        depositToken.safeTransferFrom(userAddress,rewardwallet, rewardpercent);\r\n        depositToken.safeTransferFrom(userAddress,levelplanAddress, usrrewardsprn/2);\r\n        levelcorePlan(levelplanAddress).transfertoken(userAddress,referrerAddress,usrrewardsprn/2);\r\n        uint refersamount = ((usrrewardsprn/2) * 50 )/100;\r\n\r\n        lastUserId++;\r\n        uint8 lvlNumber = users[referrerAddress].userlevels;\r\n        uint8 level = users[userAddress].userlevels;\r\n        users[referrerAddress].userEarnAmount[level] = users[referrerAddress].userEarnAmount[level] + refersamount;\r\n        users[referrerAddress].totalTeamMembers[level] = users[referrerAddress].totalTeamMembers[level]+1;\r\n        \r\n        address freeX6Referrer = finduplineReferrer(userAddress, level);\r\n        updateX6Referrer(userAddress, freeX6Referrer, users[userAddress].userlevels ,users[referrerAddress].cycles[lvlNumber], refersamount);\r\n        emit Registration(userAddress, freeX6Referrer, users[userAddress].id, users[referrerAddress].id);\r\n        return (users[userAddress].id,users[userAddress].referrer);\r\n    }\r\n\r\n\r\n    function getcycles(address useraddress,uint levels) public view returns(uint) {\r\n        return users[useraddress].cycles[levels];\r\n    }\r\n\r\n\r\n    function userlevsl(address useraddress) public view returns(uint) {\r\n        return users[useraddress].userlevels;\r\n    }\r\n\r\n\r\n    function returnusrearn(address _userAddress,uint8 level) public view returns(uint,uint) {\r\n        uint amts = users[_userAddress].userEarnAmount[level];\r\n        uint Teammembers = users[_userAddress].totalTeamMembers[level];\r\n        return (amts,Teammembers);\r\n    }\r\n    \r\n\r\n    function updateX6Referrer(address userAddress, address referrerAddress, uint8 level, uint8 cycles, uint256 refersamount) private {\r\n        if (users[referrerAddress].x6Matrix[level][cycles].firstLevelReferrals.length < 3) {\r\n            firstrefValue memory newReferralfirst = firstrefValue({\r\n                refAddress: userAddress,\r\n                refId: users[userAddress].id,\r\n                timestamp:block.timestamp,\r\n                level:level,\r\n                amount:refersamount\r\n            });\r\n            users[referrerAddress].x6Matrix[level][cycles].firstLevelReferrals.push(newReferralfirst);\r\n            //set current level\r\n            users[userAddress].x6Matrix[level][cycles].currentReferrer = referrerAddress;\r\n            if (referrerAddress == id1) {\r\n                return sendETHDividends(userAddress,referrerAddress,level);\r\n            }\r\n            return sendETHDividends(userAddress,referrerAddress, level);\r\n        }\r\n        updateX6ReferrerSecondLevel(userAddress, referrerAddress, level, cycles,refersamount);\r\n    }\r\n\r\n\r\n    function updateX6ReferrerSecondLevel(address userAddress, address referrerAddress, uint8 level, uint8 cycles, uint256 refersamount) private {\r\n        uint secondreflength = users[referrerAddress].x6Matrix[level][cycles].secondLevelReferrals.length;\r\n        if (users[referrerAddress].x6Matrix[level][cycles].secondLevelReferrals.length < 9) {\r\n            secondrefValue memory newReferralsecond = secondrefValue({\r\n                refAddress: userAddress,\r\n                refId: users[userAddress].id,\r\n                timestamp:block.timestamp,\r\n                level:level,\r\n                amount:refersamount\r\n            });\r\n            users[referrerAddress].x6Matrix[level][cycles].secondLevelReferrals.push(newReferralsecond);\r\n            users[referrerAddress].userEarnAmount[level] = users[referrerAddress].userEarnAmount[level] + ((levelPrice[level]/2) * 50 )/100;\r\n            users[referrerAddress].totalTeamMembers[level] = users[referrerAddress].totalTeamMembers[level]+1;\r\n            address refers = findspilloveradr(referrerAddress,secondreflength);\r\n            return sendETHDividends(userAddress,refers, level);\r\n        }\r\n\r\n        if(users[referrerAddress].activeX6Levels[level]) {\r\n            users[referrerAddress].cycles[level]++;\r\n        }\r\n\r\n        if (referrerAddress != id1) {\r\n            address freeReferrerAddress = finduplineReferrer(userAddress,level+1);\r\n            updateX6Referrer(userAddress, freeReferrerAddress, level,users[freeReferrerAddress].cycles[level], refersamount);\r\n        } \r\n        if(referrerAddress == id1) {\r\n            updateX6Referrer(userAddress, referrerAddress, level,users[referrerAddress].cycles[level],refersamount); \r\n        }\r\n    }\r\n\r\n\r\n    function findspilloveradr(address referrerAddress,uint secondreflength) internal view returns (address) {\r\n        address[] memory directref = directreferral(referrerAddress);\r\n        for(uint i=0; i < 4; i++) {\r\n            if (secondreflength < 3) {\r\n                return directref[0];\r\n            }\r\n            if(secondreflength < 6) {\r\n                if(secondreflength > 2) {\r\n                    return directref[1];\r\n                } \r\n            }\r\n            if(secondreflength > 5) {\r\n                return directref[2];\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function sendETHDividends(address userAddress,address referrerAddress, uint8 level) internal {\r\n        address uplineref = users[referrerAddress].referrer;\r\n        uint rewardpercent = (levelPrice[level] * 10)/100;\r\n        uint usrrewardsprn = levelPrice[level] - rewardpercent;\r\n\r\n        uint refersamount = ((usrrewardsprn/2) * 50 )/100;\r\n        if(uplineref != address(0) && uplineref != userAddress) {\r\n            depositToken.safeTransferFrom(msg.sender,referrerAddress, refersamount);\r\n            depositToken.safeTransferFrom(msg.sender,uplineref, refersamount);\r\n        }\r\n        else {\r\n            depositToken.safeTransferFrom(msg.sender,id1, usrrewardsprn/2);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function isUserExists(address user) public view returns (bool) {\r\n        return (users[user].id != 0);\r\n    }\r\n\r\n    function usersX6Matrix(address userAddress, uint8 level, uint8 cycles) public view returns(address, firstrefValue[] memory, secondrefValue[] memory,uint,uint) {\r\n        return (\r\n            users[userAddress].x6Matrix[level][cycles].currentReferrer,\r\n            users[userAddress].x6Matrix[level][cycles].firstLevelReferrals,\r\n            users[userAddress].x6Matrix[level][cycles].secondLevelReferrals,\r\n            users[userAddress].userlevels,\r\n            users[userAddress].cycles[level]);\r\n    }\r\n\r\n    function getFirstLevelReferral(address _referrer, uint256 index,uint level, uint cycles) public view returns (address) {\r\n        firstrefValue storage referral = users[_referrer].x6Matrix[level][cycles].firstLevelReferrals[index];\r\n        return (referral.refAddress);\r\n    }\r\n\r\n    function getSecondLevelReferral(address _referrer, uint256 index,uint level, uint cycles) public view returns (address) {\r\n        secondrefValue storage referral = users[_referrer].x6Matrix[level][cycles].secondLevelReferrals[index];\r\n        return (referral.refAddress);\r\n    }\r\n\r\n\r\n\r\n    function changelevelplnaddress(address _levelplanAddress) external onlyContractOwner() {\r\n        levelplanAddress = _levelplanAddress;\r\n    }\r\n\r\n\r\n    function withdrawLostTokens(address tokenAddress) public onlyContractOwner() {\r\n        if (tokenAddress == address(0)) {\r\n            payable(contractOwner).transfer(address(this).balance);\r\n        } else {\r\n            IERC20(tokenAddress).transfer(contractOwner, IERC20(tokenAddress).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function changeRewardWallet(address _rewardWallet) external onlyContractOwner() {\r\n        rewardwallet = _rewardWallet;\r\n    }\r\n\r\n\r\n    function directreferral(address _userAddress) public view returns(address[] memory) {\r\n        uint ids = users[_userAddress].id;\r\n        address[] memory directReferrals = new address[](lastUserId - ids-1);\r\n        uint256 count = 0;\r\n\r\n        for(uint256 i = ids+1; i < lastUserId; i++) {\r\n           address refaddr = idToAddress[i];\r\n            if(users[refaddr].referrer == _userAddress) {\r\n                    directReferrals[count] = refaddr;\r\n                    count++;\r\n            }\r\n        }\r\n        address[] memory actualReferrals = new address[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            actualReferrals[i] = directReferrals[i];\r\n        }\r\n        return actualReferrals;\r\n    }\r\n\r\n\r\n    function getBronzerank(address _userAddress) public view returns(address[] memory) {\r\n        uint ids = users[_userAddress].id;\r\n        address[] memory directReferrals = new address[](lastUserId - ids-1);\r\n        uint256 count = 0;\r\n\r\n        for(uint256 i = ids+1; i < lastUserId; i++) {\r\n           address refaddr = idToAddress[i];\r\n           if(users[refaddr].referrer == _userAddress) {\r\n                directReferrals[count] = refaddr;\r\n                count++;\r\n           }\r\n        }\r\n        address[] memory actualReferrals = new address[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            actualReferrals[i] = directReferrals[i];\r\n        }\r\n        return actualReferrals;\r\n    }\r\n\r\n    function getindirectref(address _userAddress) public view returns(address[] memory) {\r\n        uint ids = users[_userAddress].id;\r\n        address[] memory Referraladdr = new address[](lastUserId - ids-1);\r\n        uint256 count = 0;\r\n        while (ids < lastUserId) {\r\n            address[] memory directRefferrals = getBronzerank(idToAddress[ids]);\r\n            for (uint i = 0; i < directRefferrals.length; i++) {\r\n                Referraladdr[count] = directRefferrals[i];\r\n                count++;\r\n            }\r\n            ids++;\r\n        }\r\n        address[] memory actualReferrals = new address[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            actualReferrals[i] = Referraladdr[i];\r\n        }\r\n        return actualReferrals;\r\n    }\r\n\r\n    function getsilverrank(address _userAddress) public  view returns(address[] memory) {\r\n        address[] memory getalladdr = getindirectref(_userAddress);\r\n        address[] memory getsilveraddress = new address[](getalladdr.length);\r\n        \r\n        uint silverCount = 0;\r\n        for(uint i=0; i< getalladdr.length; i++) {\r\n            address[] memory getrefbronze = getBronzerank(getalladdr[i]);\r\n            if(getrefbronze.length > 4 ) {\r\n                getsilveraddress[i] = getalladdr[i];\r\n                silverCount++;\r\n            }\r\n        }\r\n        address[] memory actualReferrals = new address[](silverCount);\r\n        for (uint256 i = 0; i < silverCount; i++) {\r\n            actualReferrals[i] = getsilveraddress[i];\r\n        }\r\n        return actualReferrals;\r\n    }\r\n\r\n    function goldrank(address _userAddress) public view returns(address[] memory) {\r\n        address[] memory getalladdr = getindirectref(_userAddress);\r\n        address[] memory getgoldaddress = new address[](getalladdr.length);\r\n        uint goldCount = 0;\r\n        if(getalladdr.length >= 100 && users[_userAddress].activeX6Levels[5]) {\r\n            for(uint i=0; i < getalladdr.length; i++) {\r\n                address[] memory getrefbronze = getsilverrank(getalladdr[i]);\r\n                if(getrefbronze.length > 2 ) {\r\n                    getgoldaddress[i] = getalladdr[i]; \r\n                    goldCount++;\r\n                }\r\n            }\r\n        }\r\n        address[] memory actualReferrals = new address[](goldCount);\r\n        for (uint256 i = 0; i < goldCount; i++) {\r\n            actualReferrals[i] = getgoldaddress[i];\r\n        }\r\n        return actualReferrals;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_depositTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_levelplanAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardwallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"MissedEthReceive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"MissedEthReceive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"place\",\"type\":\"uint8\"}],\"name\":\"NewUserPlace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentReferrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReleasedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SentExtraEthDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"StoredETH\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_UserAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referAddress\",\"type\":\"address\"}],\"name\":\"ActivelevelChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASIC_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAST_LEVEL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"XcoreAndLevelContractTotAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"buyNewLevelFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardWallet\",\"type\":\"address\"}],\"name\":\"changeRewardWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_levelplanAddress\",\"type\":\"address\"}],\"name\":\"changelevelplnaddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"directreferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"finduplineReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getBronzerank\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycles\",\"type\":\"uint256\"}],\"name\":\"getFirstLevelReferral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycles\",\"type\":\"uint256\"}],\"name\":\"getSecondLevelReferral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"levels\",\"type\":\"uint256\"}],\"name\":\"getcycles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getindirectref\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getsilverrank\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"goldrank\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"id1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"levelplanAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"newuserAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_AdminAddress\",\"type\":\"address\"}],\"name\":\"ownerchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"registrationExt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"registrationFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"returnusrearn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardwallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userIds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usercompletelevel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"userlevelactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"userlevsl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usercycles\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"userlevels\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cycles\",\"type\":\"uint8\"}],\"name\":\"usersX6Matrix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"refAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Metakingxcore.firstrefValue[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"refAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Metakingxcore.secondrefValue[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Metakingxcore", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007983bd8d7ce4394747517681659790cf595c470900000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000005c83b99bc04ace46c9bb0994f06ae514b86e3e24000000000000000000000000f9b123d1665b56acdae4296d59e7ab0e3d2387dc", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://61c49a74ece23a7fe3e30d2ceadbf16971ffc53c1395e7f64096bb6cfec5fa87"}