{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract WealthMe {\r\nusing SafeMath for uint256;\r\n\r\n    address public owner;\r\n    address public defaultReferrer = 0xD29B7fc082Ae829ad51fF8AD1F393464E14f0739;\r\n    uint256 public constant PERCENT_DIVIDER = 10000;\r\n    uint256 public constant TIME_STEP = 24 hours;\r\n    uint256 public constant packPrice = 0.25 ether;\r\n    uint256 public constant Team_FEE = 1000; // 10%\r\n    uint256 public constant BoostNum = 1000; // 1 Boost Pack have 1000 positions\r\n\r\n    struct Pack {\r\n        uint256 packId;\r\n        uint256 dailyInterest;\r\n        uint256 rewardDays;\r\n        uint256 boost;\r\n        uint256 totalWithdrawn;\r\n        uint256 checkpoint;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    struct Partners {\r\n        address referrer; // Upline address\r\n        uint256 subNum; // 1 Level downline total amount\r\n        address[] subOrdinates; // List of 1 level downline\r\n        uint256 generations; // Record generations for 10 levels\r\n    }\r\n\r\n    struct User {\r\n        uint256 totalInvested;\r\n        uint256 totalWithdrawn;\r\n        uint256 boostInterest;\r\n        Pack[] packs;\r\n    }\r\n\r\n    struct SubordinateInfo {\r\n        address walletAddress;\r\n        User user;\r\n    }\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint256 => Pack) public packs;\r\n    mapping(address => Partners) public partners;\r\n    uint256 public packCounter;\r\n    uint256 public totalUsers;\r\n    uint256 public totalBoostPurchased; // Records the total number of boost purchased, not the amount\r\n    bool private isWithdrawing;\r\n\r\n    event PackPurchased(address indexed user, uint256 packId, uint256 value);\r\n    event PackUpgraded(address indexed user, uint256 packId, uint256 boost);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event BoostPurchased(\r\n        address indexed user,\r\n        uint256 boostAmount\r\n    );\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function purchasePacks(\r\n        uint256 numPacks,\r\n        address referrer\r\n    ) external payable {\r\n        require(numPacks > 0, \"Number of packs must be greater than 0\");\r\n        require(msg.value >= numPacks.mul(packPrice), \"Insufficient ETH sent\");\r\n\r\n        User storage user = users[msg.sender];\r\n\r\n        if (user.totalInvested == 0) {\r\n            totalUsers++;\r\n        }\r\n\r\n        uint256 generations = calculateGenerations(referrer); // Calculate the generations of the referrer\r\n        recordReferral(msg.sender, referrer, msg.value, generations);\r\n\r\n        uint256 startPackId = packCounter.add(1);\r\n        uint256 endPackId = startPackId.add(numPacks).sub(1);\r\n\r\n        for (uint256 i = startPackId; i <= endPackId; i++) {\r\n            packs[i] = Pack({\r\n                packId: i,\r\n                dailyInterest: 150,\r\n                rewardDays: 100,\r\n                boost: 0,\r\n                totalWithdrawn: 0,\r\n                checkpoint: block.timestamp,\r\n                unlockTime: block.timestamp\r\n            });\r\n\r\n            user.packs.push(packs[i]);\r\n            packCounter = packCounter.add(1);\r\n        }\r\n\r\n        user.totalInvested = user.totalInvested.add(numPacks.mul(packPrice));\r\n\r\n        uint256 teamFee = msg.value.mul(Team_FEE).div(PERCENT_DIVIDER);\r\n        (bool teamFeeSuccess, ) = owner.call{value: teamFee}(\"\");\r\n        require(teamFeeSuccess, \"Team fee transfer failed\");\r\n\r\n        emit PackPurchased(msg.sender, startPackId, msg.value);\r\n    }\r\n\r\n    function calculateGenerations(\r\n        address referrer\r\n    ) internal view returns (uint256) {\r\n        uint256 generations = 0;\r\n        address currentReferrer = referrer;\r\n        while (currentReferrer != address(0) && generations < 10) {\r\n            currentReferrer = partners[currentReferrer].referrer;\r\n            generations = generations.add(1);\r\n        }\r\n        return generations;\r\n    }\r\n\r\n    function recordReferral(\r\n        address sender,\r\n        address referrer,\r\n        uint256 value,\r\n        uint256 generations\r\n    ) internal {\r\n        uint256 boostValue = value.mul(4).div(1e16);\r\n        if (partners[sender].referrer == address(0)) {\r\n            if (referrer != address(0) && referrer != sender && users[referrer].totalInvested > 0) {\r\n                partners[sender].referrer = referrer;\r\n                partners[referrer].subOrdinates.push(sender);\r\n                partners[referrer].subNum = partners[referrer].subNum.add(1);\r\n                partners[sender].generations = generations; // Record the generations of the referrer\r\n\r\n                // Update boostInterest\r\n                address currentReferrer = referrer;\r\n                for (uint256 i = 0; i < generations; i++) {\r\n                    uint256 boostInterest = boostValue.mul(100 - (i.mul(10))).div(100);\r\n                    users[currentReferrer].boostInterest = users[currentReferrer].boostInterest.add(boostInterest);\r\n                    currentReferrer = partners[currentReferrer].referrer;\r\n\r\n                    if (currentReferrer == address(0)) {\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                partners[sender].referrer = defaultReferrer;\r\n                partners[defaultReferrer].generations = generations; // Record the generations of the referrer\r\n\r\n                // Update boostInterest\r\n                address currentReferrer = defaultReferrer;\r\n                for (uint256 i = 0; i < generations; i++) {\r\n                    uint256 boostInterest = boostValue.mul(100 - (i.mul(10))).div(100);\r\n                    users[currentReferrer].boostInterest = users[currentReferrer].boostInterest.add(boostInterest);\r\n                    currentReferrer = partners[currentReferrer].referrer;\r\n\r\n                    if (currentReferrer == address(0)) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            address ref = partners[sender].referrer;\r\n            // Update boostInterest\r\n            address currentReferrer = ref;\r\n            for (uint256 i = 0; i < partners[sender].generations; i++) {\r\n                uint256 boostInterest = boostValue.mul(100 - (i.mul(10))).div(100);\r\n                users[currentReferrer].boostInterest = users[currentReferrer].boostInterest.add(boostInterest);\r\n                currentReferrer = partners[currentReferrer].referrer;\r\n\r\n                if (currentReferrer == address(0)) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getSubOrdinates(address userAddress) public view returns (address[] memory) {\r\n        return partners[userAddress].subOrdinates;\r\n    }\r\n\r\n    // Get 10 Levels Count\r\n    function getSubordinateStats(\r\n        address userAddress\r\n    ) public view returns (uint256[] memory, uint256[] memory, uint256[] memory) {\r\n        uint256[] memory walletCounts = new uint256[](10);\r\n        uint256[] memory packCounts = new uint256[](10);\r\n        uint256[] memory withdrawalAmounts = new uint256[](10);\r\n\r\n        getSubordinateStatsRecursive(\r\n            userAddress,\r\n            0,\r\n            walletCounts,\r\n            packCounts,\r\n            withdrawalAmounts\r\n        );\r\n\r\n        return (walletCounts, packCounts, withdrawalAmounts);\r\n    }\r\n\r\n    function getSubordinateStatsRecursive(\r\n        address userAddress,\r\n        uint256 level,\r\n        uint256[] memory walletCounts,\r\n        uint256[] memory packCounts,\r\n        uint256[] memory withdrawalAmounts\r\n    ) internal view {\r\n        require(level < 10, \"Exceeded maximum recursion depth\");\r\n        address[] memory subOrdinates = getSubOrdinates(userAddress);\r\n\r\n        for (uint256 i = 0; i < subOrdinates.length; i++) {\r\n            address subordinate = subOrdinates[i];\r\n\r\n            walletCounts[level]++;\r\n            packCounts[level] += users[subordinate].packs.length;\r\n            withdrawalAmounts[level] += users[subordinate].totalWithdrawn;\r\n\r\n            if (level < 9) {\r\n                getSubordinateStatsRecursive(\r\n                    subordinate,\r\n                    level + 1,\r\n                    walletCounts,\r\n                    packCounts,\r\n                    withdrawalAmounts\r\n                );\r\n            }\r\n        }\r\n    }\r\n    // end\r\n\r\n    function buyBoost(uint256 boostAmount) external payable {\r\n        require(boostAmount > 0, \"Boost amount must be greater than 0\");\r\n        require(msg.value >= boostAmount.mul(packPrice), \"Insufficient ETH sent\");\r\n\r\n        uint256 totalBoost = boostAmount.mul(BoostNum);\r\n        users[msg.sender].boostInterest = users[msg.sender].boostInterest.add(totalBoost);\r\n        users[msg.sender].totalInvested = users[msg.sender].totalInvested.add(boostAmount.mul(packPrice));\r\n\r\n        totalBoostPurchased = totalBoostPurchased.add(boostAmount); // Records the total number of boost purchased\r\n        emit BoostPurchased(msg.sender, totalBoost);\r\n    }\r\n\r\n    function upgradePack(uint256 packId) external {\r\n        require(packId <= packCounter, \"Invalid packId\");\r\n        //require(users[msg.sender].boostInterest > 0, \"No boost interest available\");\r\n\r\n        bool isPackOwned = false;\r\n        for (uint256 i = 0; i < users[msg.sender].packs.length; i++) {\r\n            if (users[msg.sender].packs[i].packId == packId) {\r\n                isPackOwned = true;\r\n                break;\r\n            }\r\n        }\r\n        require(isPackOwned, \"You do not own this pack\");\r\n        require(packs[packId].totalWithdrawn == 0, \"Withdrawn packs cannot be upgraded\");\r\n\r\n        Pack storage pack = packs[packId];\r\n\r\n        if (users[msg.sender].boostInterest > 0) {\r\n            pack.boost = pack.boost.add(users[msg.sender].boostInterest);\r\n            users[msg.sender].boostInterest = 0;\r\n        }\r\n\r\n        uint256 packIdElapsed = packCounter.add(totalBoostPurchased).add(pack.boost).sub(packId);\r\n\r\n        if (packIdElapsed > 300000) {\r\n            pack.dailyInterest = 200000;\r\n            pack.rewardDays = 300;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 250000) {\r\n            pack.dailyInterest = 160000;\r\n            pack.rewardDays = 300;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 200000) {\r\n            pack.dailyInterest = 120000;\r\n            pack.rewardDays = 200;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 160000) {\r\n            pack.dailyInterest = 80000;\r\n            pack.rewardDays = 200;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 120000) {\r\n            pack.dailyInterest = 50000;\r\n            pack.rewardDays = 200;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 80000) {\r\n            pack.dailyInterest = 28000;\r\n            pack.rewardDays = 200;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 50000) {\r\n            pack.dailyInterest = 10000;\r\n            pack.rewardDays = 200;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 20000) {\r\n            pack.dailyInterest = 3200;\r\n            pack.rewardDays = 200;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 10000) {\r\n            pack.dailyInterest = 1600;\r\n            pack.rewardDays = 200;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 5000) {\r\n            pack.dailyInterest = 800;\r\n            pack.rewardDays = 200;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 2000) {\r\n            pack.dailyInterest = 600;\r\n            pack.rewardDays = 100;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 1000) {\r\n            pack.dailyInterest = 400;\r\n            pack.rewardDays = 100;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 500) {\r\n            pack.dailyInterest = 300;\r\n            pack.rewardDays = 100;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 200) {\r\n            pack.dailyInterest = 250;\r\n            pack.rewardDays = 100;\r\n            pack.unlockTime = block.timestamp;\r\n        } else if (packIdElapsed > 75) {\r\n            pack.dailyInterest = 200;\r\n            pack.rewardDays = 100;\r\n            pack.unlockTime = block.timestamp;\r\n        }\r\n        for (uint256 i = 0; i < users[msg.sender].packs.length; i++) {\r\n            if (users[msg.sender].packs[i].packId == packId) {\r\n                users[msg.sender].packs[i] = pack;\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit PackUpgraded(msg.sender, packId, users[msg.sender].boostInterest);\r\n    }\r\n\r\n    function calculateEarnings(uint256 packId) public view returns (uint256) {\r\n        Pack storage pack = packs[packId];\r\n        uint256 timePassed = block.timestamp.sub(pack.checkpoint);\r\n        return timePassed.mul(packPrice).mul(pack.dailyInterest).div(PERCENT_DIVIDER).div(TIME_STEP);\r\n    }\r\n\r\n    function calculateUserEarnings(address userAddress) external view returns (uint256) {\r\n        User storage user = users[userAddress];\r\n        uint256 totalEarnings = 0;\r\n        for (uint256 i = 0; i < user.packs.length; i++) {\r\n            totalEarnings = totalEarnings.add(calculateEarnings(user.packs[i].packId));\r\n        }\r\n        return totalEarnings;\r\n    }\r\n\r\n    function withdrawPackEarnings(uint256 packId) external {\r\n        require(!isWithdrawing, \"Withdrawal in progress\");\r\n        isWithdrawing = true;\r\n        User storage user = users[msg.sender];\r\n        require(user.packs.length > 0, \"No investment packs owned\");\r\n        \r\n        bool isPackOwned = false;\r\n        uint256 earnings = 0;\r\n\r\n        for (uint256 i = 0; i < user.packs.length; i++) {\r\n            if (user.packs[i].packId == packId) {\r\n                isPackOwned = true;\r\n                earnings = calculateEarnings(packId);\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(isPackOwned, \"You do not own this pack\");\r\n\r\n        packs[packId].totalWithdrawn = packs[packId].totalWithdrawn.add(earnings);\r\n        packs[packId].checkpoint = block.timestamp;\r\n        user.totalWithdrawn = user.totalWithdrawn.add(earnings);\r\n\r\n        uint256 contractBalance = address(this).balance;\r\n        uint256 taxRate = calculateTaxRate(contractBalance);\r\n        uint256 taxAmount = earnings.mul(taxRate).div(100);\r\n        uint256 netEarnings = earnings.sub(taxAmount);\r\n\r\n        // Boost rewards can also be claimed by the referrer during withdrawal\r\n        if (netEarnings > 0 && contractBalance >= netEarnings) {\r\n            address currentReferrer = partners[msg.sender].referrer;\r\n            for (uint256 i = 0; i < partners[msg.sender].generations; i++) {\r\n                uint256 boostValue = netEarnings.mul(4).div(1e16);\r\n                uint256 boostInterest = boostValue.mul(100 - (i * 10)).div(100); // Calculate boostInterest based on generations\r\n                users[currentReferrer].boostInterest = users[currentReferrer].boostInterest.add(boostInterest);\r\n                currentReferrer = partners[currentReferrer].referrer;\r\n            }\r\n\r\n            (bool success, ) = msg.sender.call{value: netEarnings}(\"\");\r\n            require(success, \"Transfer failed\");\r\n        }\r\n        isWithdrawing = false;\r\n    }\r\n\r\n    function withdrawEarnings() external {\r\n        require(!isWithdrawing, \"Withdrawal in progress\");\r\n        isWithdrawing = true;\r\n        User storage user = users[msg.sender];\r\n        require(user.packs.length > 0, \"No investment packs owned\");\r\n        \r\n        uint256 totalEarnings = 0;\r\n        for (uint256 i = 0; i < user.packs.length; i++) {\r\n            uint256 packId = user.packs[i].packId;\r\n            uint256 earnings = calculateEarnings(packId);\r\n            totalEarnings = totalEarnings.add(earnings);\r\n            packs[packId].totalWithdrawn = packs[packId].totalWithdrawn.add(earnings);\r\n            packs[packId].checkpoint = block.timestamp;\r\n        }\r\n        user.totalWithdrawn = user.totalWithdrawn.add(totalEarnings);\r\n\r\n        uint256 contractBalance = address(this).balance;\r\n        uint256 taxRate = calculateTaxRate(contractBalance);\r\n        uint256 taxAmount = totalEarnings.mul(taxRate).div(100);\r\n        uint256 netEarnings = totalEarnings.sub(taxAmount);\r\n\r\n        // Boost rewards can also be claimed by the referrer during withdrawal\r\n        if (netEarnings > 0 && contractBalance >= netEarnings) {\r\n            address currentReferrer = partners[msg.sender].referrer;\r\n            for (uint256 i = 0; i < partners[msg.sender].generations; i++) {\r\n                uint256 boostValue = netEarnings.mul(4).div(1e16);\r\n                uint256 boostInterest = boostValue.mul(100 - (i * 10)).div(100); // Calculate boostInterest based on generations\r\n                users[currentReferrer].boostInterest = users[currentReferrer].boostInterest.add(boostInterest);\r\n                currentReferrer = partners[currentReferrer].referrer;\r\n            }\r\n\r\n            (bool success, ) = msg.sender.call{value: netEarnings}(\"\");\r\n            require(success, \"Transfer failed\");\r\n        }\r\n        isWithdrawing = false;\r\n    }\r\n\r\n    function calculateTaxRate(\r\n        uint256 contractBalance\r\n    ) internal pure returns (uint256) {\r\n        if (contractBalance < 100 ether) {\r\n            return 50; // 50% tax\r\n        } else if (contractBalance < 300 ether) {\r\n            return 40; // 40% tax\r\n        } else if (contractBalance < 600 ether) {\r\n            return 30; // 30% tax\r\n        } else if (contractBalance < 1000 ether) {\r\n            return 20; // 20% tax\r\n        } else if (contractBalance < 2000 ether) {\r\n            return 10; // 10% tax\r\n        } else {\r\n            return 0; // No tax\r\n        }\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    \r\n    function getUserPackAttributes(address userAddress) external view returns (Pack[] memory) {\r\n        User storage user = users[userAddress];\r\n        Pack[] memory userPacks = new Pack[](user.packs.length);\r\n\r\n        for (uint256 i = 0; i < user.packs.length; i++) {\r\n            userPacks[i] = user.packs[i];\r\n        }\r\n\r\n        return userPacks;\r\n    }\r\n\r\n\r\n    function getUserInfo(address userAddress) external view returns (User memory) {\r\n        return users[userAddress];\r\n    }\r\n\r\n    function getUserSubordinatesInfo(address userAddress) external view returns (SubordinateInfo[] memory) {\r\n        address[] memory subordinates = partners[userAddress].subOrdinates;\r\n        SubordinateInfo[] memory subordinateInfoList = new SubordinateInfo[](subordinates.length);\r\n\r\n        for (uint256 i = 0; i < subordinates.length; i++) {\r\n            address walletAddress = subordinates[i];\r\n            User memory user = users[walletAddress];\r\n            subordinateInfoList[i] = SubordinateInfo(walletAddress, user);\r\n        }\r\n\r\n        return subordinateInfoList;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostAmount\",\"type\":\"uint256\"}],\"name\":\"BoostPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PackPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"}],\"name\":\"PackUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BoostNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Team_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boostAmount\",\"type\":\"uint256\"}],\"name\":\"buyBoost\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"}],\"name\":\"calculateEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"calculateUserEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getSubOrdinates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getSubordinateStats\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostInterest\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"internalType\":\"struct WealthMe.Pack[]\",\"name\":\"packs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct WealthMe.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserPackAttributes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"internalType\":\"struct WealthMe.Pack[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserSubordinatesInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostInterest\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"internalType\":\"struct WealthMe.Pack[]\",\"name\":\"packs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct WealthMe.User\",\"name\":\"user\",\"type\":\"tuple\"}],\"internalType\":\"struct WealthMe.SubordinateInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"packCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"packPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"packs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generations\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numPacks\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"purchasePacks\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBoostPurchased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"}],\"name\":\"upgradePack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostInterest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"}],\"name\":\"withdrawPackEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WealthMe", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1687d15093d4e0a0fc8b3251176a47b5234e2cff6cb50fa5149e778aa604e130"}