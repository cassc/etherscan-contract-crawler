{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract WinOOWin {\r\n    uint128 FEE;\r\n    uint Deposit_Keeper;\r\n    uint MIN_DEPOSIT = 100000000000000; //0.0001\r\n\r\n    address  HOLDER ;\r\n    address  OWNER;\r\n    address  ORACLE;\r\n    address[] _p_1;\r\n\r\n    bool withdraw_able;\r\n\r\n    string private ID_OFN;\r\n\r\n    mapping(uint => uint) WithAble;\r\n    mapping(uint =>  mapping(uint => bool) ) Commitment;\r\n    mapping(uint =>  mapping(uint => bool) ) DrawOver;\r\n    mapping(uint =>  mapping(uint => uint)) CommitmentTimestampExpiration;\r\n    mapping(uint => mapping(uint => mapping(address => uint))) Pool;\r\n    mapping(uint => mapping(uint => mapping(address => uint))) PoolWinner;\r\n    event Deposit(uint256 commitment, uint timestamp);\r\n    event Withdraw(uint256 commitment, uint timestamp);\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == OWNER,\r\n            \"Only the owner is allowed to make this request\"\r\n        );\r\n        _;\r\n    }\r\n    modifier onlyOracle() {\r\n        require(\r\n            msg.sender == ORACLE,\r\n            \"Only the owner is allowed to make this request\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(string memory _s,address _h, address _oracle) {\r\n        withdraw_able = false;\r\n        FEE = 1000; //10%\r\n        ID_OFN = _s;\r\n        ORACLE = _oracle;\r\n        HOLDER = _h;\r\n        OWNER = msg.sender;\r\n    }\r\n\r\n    function depozit_p_1(\r\n        uint256 _commitment,\r\n        uint _amount,\r\n        uint _p\r\n    ) public payable {\r\n        if (Commitment[_commitment][_p] == false) {\r\n            revert(\"unvalidated Commitment\");\r\n        }\r\n        if (CommitmentTimestampExpiration[_commitment][_p]  < block.timestamp) {\r\n            revert(\"unvalidated time\");\r\n        }\r\n\r\n        if (msg.value < _amount) {\r\n            revert(\"unvalidated _amount\");\r\n        }\r\n        if (Pool[_commitment][_p][msg.sender] > 1) {\r\n            revert(\"You already joined\");\r\n        }\r\n        if (MIN_DEPOSIT > _amount) {\r\n            revert(\"Less than min\");\r\n        }\r\n        withdraw_able = true;\r\n\r\n        uint ParticipationFEE = (_amount * FEE) / 10000;\r\n        uint Total = _amount - ParticipationFEE;\r\n\r\n        (bool _s_1, ) = payable(HOLDER).call{value: ParticipationFEE}(\"\");\r\n\r\n        Deposit_Keeper += _amount;\r\n        Pool[_commitment][_p][msg.sender] = Total;\r\n\r\n        withdraw_able = false;\r\n        emit Deposit(_commitment, block.timestamp);\r\n    }\r\n\r\n    function depozit_p_1ByOracle(\r\n        uint256 _commitment,\r\n        uint _amount,\r\n        address receipt,\r\n        bytes memory otp,\r\n        uint _p\r\n    ) public payable onlyOracle {\r\n        if (!signatureCheker(receipt, otp)) {\r\n            revert(\"It is not valid signature ! \");\r\n        }\r\n        if (Commitment[_commitment][_p]  == false) {\r\n            revert(\"unvalidated Commitment\");\r\n        }\r\n        if (CommitmentTimestampExpiration[_commitment][_p]  < block.timestamp) {\r\n            revert(\"unvalidated time\");\r\n        }\r\n\r\n        if (msg.value < _amount) {\r\n            revert(\"unvalidated _amount\");\r\n        }\r\n        if (Pool[_commitment][_p][receipt] > 1) {\r\n            revert(\"You already joined\");\r\n        }\r\n        if (MIN_DEPOSIT > _amount) {\r\n            revert(\"Less than min\");\r\n        }\r\n        withdraw_able = true;\r\n\r\n        uint ParticipationFEE = (_amount * FEE) / 10000;\r\n        uint Total = _amount - ParticipationFEE;\r\n\r\n        (bool _s_1, ) = payable(HOLDER).call{value: ParticipationFEE}(\"\");\r\n\r\n        Deposit_Keeper += _amount;\r\n        Pool[_commitment][_p][receipt] = Total;\r\n\r\n        withdraw_able = false;\r\n        emit Deposit(_commitment, block.timestamp);\r\n    }\r\n\r\n    function getAmountPoolUser(\r\n        address _ask,\r\n        uint256 _commitment,\r\n        uint _p\r\n    ) external view returns (uint) {\r\n        return Pool[_commitment][_p][_ask];\r\n    }\r\n\r\n    function Mywithdraw(\r\n        address receipt,\r\n        bytes memory otp,\r\n        uint256 _commitment,\r\n        uint _p\r\n    ) external {\r\n        if (withdraw_able) {\r\n            revert(\"You are not Allowed to make this request\");\r\n        }\r\n        withdraw_able = true;\r\n        if (DrawOver[_commitment][_p]  == false) {\r\n            revert(\"Commitment is duplicate\");\r\n        }\r\n        if (Commitment[_commitment][_p]  == false) {\r\n            revert(\"Commitment is unvalidated\");\r\n        }\r\n\r\n        if (!signatureCheker(receipt, otp)) {\r\n            revert(\"It is not valid signature ! \");\r\n        }\r\n        if (PoolWinner[_commitment][_p][msg.sender] <= 0) {\r\n            revert(\"It is not valid number ! \");\r\n        }\r\n        if (PoolWinner[_commitment][_p][msg.sender] > address(this).balance) {\r\n            revert(\"It is not valid number ! \");\r\n        }\r\n\r\n        (bool _s_1, ) = payable(receipt).call{\r\n            value: PoolWinner[_commitment][_p][msg.sender]\r\n        }(\"\");\r\n        delete PoolWinner[_commitment][_p][msg.sender];\r\n\r\n        withdraw_able = false;\r\n        emit Withdraw(_commitment, block.timestamp);\r\n    }\r\n\r\n    function WhitdrawByOracle(\r\n       address siginer,\r\n        address receipt,\r\n        bytes memory otp, //\r\n        uint256 _Gasfee,\r\n        uint256 _commitment,\r\n        uint _p\r\n    ) external onlyOracle {\r\n        if (withdraw_able) {\r\n            revert(\"You are not Allowed to make this request\");\r\n        }\r\n        withdraw_able = true;\r\n        if (DrawOver[_commitment][_p] == false) {\r\n            revert(\"Commitment is duplicate\");\r\n        }\r\n        if (Commitment[_commitment][_p] == false) {\r\n            revert(\"Commitment is unvalidated\");\r\n        }\r\n        if (PoolWinner[_commitment][_p][siginer] <= 0) {\r\n            revert(\"It is not valid number ! \");\r\n        }\r\n        if (!signatureCheker(receipt, otp)) {\r\n            revert(\"It is not valid signature ! \");\r\n        }\r\n        if (PoolWinner[_commitment][_p][siginer] > address(this).balance) {\r\n            revert(\"It is not valid number ! \");\r\n        }\r\n\r\n        uint receipt_recive = PoolWinner[_commitment][_p][siginer] - _Gasfee;\r\n        delete PoolWinner[_commitment][_p][siginer];\r\n        (bool _s_1, ) = payable(receipt).call{value: receipt_recive}(\"\");\r\n        (bool _s_2, ) = payable(msg.sender).call{value: _Gasfee}(\"\");\r\n\r\n        withdraw_able = false;\r\n\r\n        emit Withdraw(_commitment, block.timestamp);\r\n    }\r\n\r\n    function setPutFee(uint128 _commision) public onlyOwner returns (bool) {\r\n        if (_commision > 4000) //~ 20%\r\n        {\r\n            revert(\"The number of fee can't be greater than 10%\");\r\n        }\r\n        if (_commision < 50) //~ 0.5%\r\n        {\r\n            revert(\"The number of fee can't be lower than 0.5%\");\r\n        }\r\n        FEE = _commision;\r\n        return true;\r\n    }\r\n\r\n    function updateSlot(uint256 _c,uint _p) external onlyOracle {\r\n        // if (!Commitment[_c][_p] ) {\r\n        //     revert(\"Commitment is duplicate\");\r\n        // }\r\n        // if (!DrawOver[_c][_p] ) {\r\n        //     revert(\"Commitment is duplicate\");\r\n        // }\r\n        if( CommitmentTimestampExpiration[_c][_p] > block.timestamp){\r\n              revert(\"Time Expire is still active \");\r\n        }\r\n\r\n        Commitment[_c][_p]  = true;\r\n        DrawOver[_c][_p]  = false;\r\n        CommitmentTimestampExpiration[_c][_p]  = block.timestamp + 23 hours;\r\n    }\r\n\r\n        function creatNewSlot(uint256 _c,uint _p) external onlyOracle {\r\n        if (Commitment[_c][_p] ) {\r\n            revert(\"Commitment is duplicate\");\r\n        }\r\n        if (DrawOver[_c][_p] ) {\r\n            revert(\"Commitment is duplicate\");\r\n        }\r\n\r\n        Commitment[_c][_p]  = true;\r\n        DrawOver[_c] [_p] = false;\r\n        CommitmentTimestampExpiration[_c][_p]  = block.timestamp + 23 hours;\r\n    }\r\n\r\n    function InjectionWinner(\r\n        uint[] memory _amounts,\r\n        address[] memory _addresses,\r\n        uint256 _c,\r\n        uint _p\r\n    ) external onlyOracle {\r\n        if (DrawOver[_c][_p]) {\r\n            revert(\"Commitment is duplicate\");\r\n        }\r\n        if (Commitment[_c][_p] == false) {\r\n            revert(\"Commitment is unvalidated\");\r\n        }\r\n\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            if (_addresses[i] != address(0)) {\r\n                PoolWinner[_c][_p][_addresses[i]] = _amounts[i];\r\n            }\r\n        }\r\n\r\n        DrawOver[_c][_p] = true;\r\n    }\r\n\r\n    function getMessageHash(address adr) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(ID_OFN, adr));\r\n    }\r\n\r\n    function getEthSignedMessageHash(\r\n        bytes32 _messageHash\r\n    ) public pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    _messageHash\r\n                )\r\n            );\r\n    }\r\n\r\n    function signatureCheker(\r\n        address adr,\r\n        bytes memory signature\r\n    ) internal view returns (bool) {\r\n        bytes32 messageHash = getMessageHash(adr);\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        return recoverSigner(ethSignedMessageHash, signature) == msg.sender;\r\n    }\r\n\r\n    function recoverSigner(\r\n        bytes32 _ethSignedMessageHash,\r\n        bytes memory _signature\r\n    ) internal pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = Signature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function Signature(\r\n        bytes memory sig\r\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n\r\n            s := mload(add(sig, 64))\r\n\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n\r\n    function Emergency() external {\r\n        if (msg.sender != HOLDER) {\r\n            revert();\r\n        }\r\n\r\n        (bool success, ) = payable(msg.sender).call{\r\n            value: address(this).balance\r\n        }(\"\");\r\n    }\r\n\r\n    function encode(\r\n        address _account,\r\n        string memory _t\r\n    ) public pure returns (bytes memory) {\r\n        return (abi.encode(_account, _t));\r\n    }\r\n\r\n    function decode(\r\n        bytes memory data\r\n    ) public pure returns (address _account, string memory _number) {\r\n        (_account, _number) = abi.decode(data, (address, string));\r\n    }\r\n\r\n    function message(\r\n        address to,\r\n        bytes memory _f\r\n    ) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"WINOOWIN_2024_\", to, _f));\r\n    }\r\n\r\n    function signatureOracel(\r\n        address siginer,\r\n        address to,\r\n        bytes[2] memory signature\r\n    ) internal view returns (bool) {\r\n        bytes32 messageHash = message(to, signature[1]);\r\n\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        (address _account, ) = decode(signature[1]);\r\n        if (_account != to) {\r\n            revert(\"It is not address! \");\r\n        }\r\n\r\n        return (recoverSigner(ethSignedMessageHash, signature[0]) == siginer);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_s\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_h\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Emergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_c\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"InjectionWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receipt\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"otp\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"Mywithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"siginer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receipt\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"otp\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_Gasfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"WhitdrawByOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_c\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"creatNewSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"decode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_number\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"depozit_p_1\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receipt\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"otp\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"depozit_p_1ByOracle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_t\",\"type\":\"string\"}],\"name\":\"encode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ask\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"getAmountPoolUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_f\",\"type\":\"bytes\"}],\"name\":\"message\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_commision\",\"type\":\"uint128\"}],\"name\":\"setPutFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_c\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WinOOWin", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000017492fa0721f8c32f44053c2013afb89b7735fbc00000000000000000000000072b0dd7b09e727423116fa8ae6ef1ed2a4db966c000000000000000000000000000000000000000000000000000000000000000e5454595968683839373233402123000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://62f9ebecaed0f84a6c078e7beb03e59f6af50212c5e8806b9cedb0b3948597a6"}