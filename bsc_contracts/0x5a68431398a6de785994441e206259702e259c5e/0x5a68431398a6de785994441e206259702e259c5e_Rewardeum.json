{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/Rewardeum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL - @DrGorilla_md (Tg/Twtr)\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\n\\n/// @title Rewardeum - Main contract\\n/// @author DrGorilla_md (Twtr/Tg)\\n/// @notice ERC20 compliant token with taxes on transfer, funding a double reward pool system:\\n/// - Reward pool\\n/// - Reserve\\n/// Every user can claim every 24h a reward, based on the share of the total supply owned. The token\\n/// claimed is either BNB or any other available token (from a curated list).\\n/// An additional incentive mechanism (the \\\"Vault\\\") offer extra reward on chosen claimable tokens.\\n/// @dev this contract is custodial for BNB and $reum (swapped for BNB in batches), custom token \\n/// are swapped as needed. Main contract act as a proxy for the vault (via IVault) which is redeployed\\n/// for new offers. Tickers are stored in bytes32 for gas optim (frontend integration via web3.utils.hexToAscii and asciiToHex)\\n\\ninterface IVault {\\n  function claim(uint256 claimable, address dest, bytes32 ticker) external returns (uint256 claim_consumed);\\n}\\n\\n/// @dev part of erc20 but not part of erc20 ...\\ninterface IDec {\\n  function decimals() external view returns (uint8);\\n}\\n\\ncontract Rewardeum is IERC20 {\\n\\n  struct past_tx {\\n    uint256 cum_sell;\\n    uint256 last_sell;\\n    uint256 reward_buffer;\\n    uint256 last_claim;\\n  }\\n\\n  struct smartpool_struct {\\n    uint256 BNB_reward;\\n    uint256 BNB_reserve;\\n    uint256 BNB_prev_reward;\\n    uint256 token_reserve;\\n  }\\n\\n  struct prop_balances {\\n    uint256 reward_pool;\\n    uint256 liquidity_pool;\\n  }\\n\\n  struct taxesRates {\\n    uint8 dev;\\n    uint8 market;\\n    uint8 balancer;\\n    uint8 reserve;\\n  }\\n\\n  mapping (address => uint256) private _balances;\\n  mapping (address => past_tx) private _last_tx;\\n  mapping (address => mapping (address => uint256)) private _allowances;\\n  mapping (address => bool) private excluded;\\n  mapping (address => bool) public isOwner;\\n  mapping (address => bool) public banned;\\n  \\n// ---- custom claim ----\\n  mapping (bytes32 => address) public available_tokens;\\n  mapping (bytes32 => uint256) public custom_claimed;\\n  mapping (bytes32 => address) public combined_offer;\\n  mapping (address => uint256) public min_received; // % min received or 100-max slippage\\n\\n// ---- tokenomic ----\\n  uint private _decimals = 9;\\n  uint private _totalSupply = 10**15 * 10**_decimals;\\n  uint8[4] public selling_taxes_rates = [2, 5, 10, 20];\\n  uint16[3] public selling_taxes_tranches = [200, 500, 1000]; // % and div by 10000 0.012% -0.025% -(...)\\n\\n// ---- balancer ----\\n  uint private pcs_pool_to_circ_ratio = 10;\\n  uint public swap_for_liquidity_threshold = 10**13 * 10**_decimals; //1%\\n  uint public swap_for_reward_threshold = 10**13 * 10**_decimals;\\n  uint public swap_for_reserve_threshold = 10**13 * 10**_decimals;\\n\\n// ---- smartpool ----\\n  uint public last_smartpool_check;\\n  uint public smart_pool_freq = 1 days;\\n  uint public excess_rate = 200;\\n  uint public minor_fill = 2;\\n  uint public resplenish_factor = 100;\\n  uint public spike_threshold = 120;\\n  uint public shock_absorber = 0;\\n\\n// ---- claim ----\\n  uint public claim_periodicity = 1 days;\\n  uint private claim_ratio = 80;\\n  uint public gas_flat_fee = 0.000361 ether;\\n  uint public total_claimed;\\n  uint8[5] public claiming_taxes_rates = [2, 5, 10, 20, 30];\\n  uint128[2] public gas_waiver_limits = [0.0001 ether, 0.0005 ether];\\n\\n  uint256 public startPublicSale;\\n\\n  bool public circuit_breaker;\\n  bool private inSwapBool;\\n\\n  string private _name = \\\"Rewardeum\\\";\\n  string private _symbol = \\\"REUM\\\";\\n\\n  bytes32[] public tickers_claimable;\\n  bytes32[] public current_offers;\\n\\n  address public LP_recipient;\\n  address public devWallet;\\n  address public mktWallet;\\n  address presaleContract;\\n  address private WETH;\\n\\n  IVault public main_vault;\\n  IUniswapV2Pair public pair;\\n  IUniswapV2Router02 private router;\\n\\n  prop_balances private balancer_balances;\\n  smartpool_struct public smart_pool_balances;\\n  taxesRates public taxes = taxesRates({dev: 1, market: 1, balancer: 5, reserve: 8});\\n\\n  event TaxRatesChanged();\\n  event SwapForBNB(string status);\\n  event SwapForCustom(string status);\\n  event Claimed(bytes32 ticker, uint256 claimable, uint256 tax, bool gas_waiver);\\n  event BalancerPools(uint256 reward_liq_pool, uint256 reward_token_pool);\\n  event RewardTaxChanged();\\n  event AddLiq(string status);\\n  event BalancerReset(uint256 new_reward_token_pool, uint256 new_reward_liq_pool);\\n  event Smartpool(uint256 reward, uint256 reserve, uint256 prev_reward);\\n  event SmartpoolOverride(uint256 new_reward, uint256 new_reserve);\\n  event AddClaimableToken(bytes32 ticker, address token);\\n  event RemoveClaimableToken(bytes32 ticker);\\n  event TransferBNB(address, uint256);\\n\\n  modifier inSwap {\\n    inSwapBool = true;\\n    _;\\n    inSwapBool = false;\\n  }\\n\\n  modifier onlyOwner {\\n    require(isOwner[msg.sender], \\\"Ownable: caller is not an owner\\\");\\n    _;\\n  }\\n\\n  constructor (address _router) {\\n\\n    router = IUniswapV2Router02(_router);\\n    WETH = router.WETH();\\n    IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\\n    pair = IUniswapV2Pair(factory.createPair(address(this), router.WETH()));\\n\\n    LP_recipient = address(0x000000000000000000000000000000000000dEaD); //LP token: burn\\n    devWallet = address(0x000000000000000000000000000000000000dEaD);\\n    mktWallet = address(0x000000000000000000000000000000000000dEaD);\\n\\n    excluded[msg.sender] = true;\\n    excluded[address(this)] = true;\\n    excluded[devWallet] = true;\\n    excluded[mktWallet] = true;\\n\\n    isOwner[msg.sender] = true;\\n\\n    circuit_breaker = true; //ERC20 behavior by default/presale\\n\\n// -- standard custom claims --\\n    available_tokens[0x5245554d00000000000000000000000000000000000000000000000000000000] = address(this); //\\\"REUM\\\"\\n    min_received[address(this)] = 83;\\n    tickers_claimable.push(\\\"REUM\\\"); //will get stored as bytes32 too\\n\\n    available_tokens[0x57424e4200000000000000000000000000000000000000000000000000000000] = address(WETH);\\n    min_received[WETH] = 95;\\n    tickers_claimable.push(\\\"WBNB\\\");\\n\\n    available_tokens[0x4254434200000000000000000000000000000000000000000000000000000000] = address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\\n    min_received[address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c)] = 95;\\n    tickers_claimable.push(\\\"BTCB\\\");\\n\\n    available_tokens[0x4554480000000000000000000000000000000000000000000000000000000000] = address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\\n    min_received[address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8)] = 95;\\n    tickers_claimable.push(\\\"ETH\\\");\\n\\n    available_tokens[0x4255534400000000000000000000000000000000000000000000000000000000] = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\\n    min_received[address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)] = 95;\\n    tickers_claimable.push(\\\"BUSD\\\");\\n\\n    available_tokens[0x5553445400000000000000000000000000000000000000000000000000000000] = address(0x55d398326f99059fF775485246999027B3197955);\\n    min_received[address(0x55d398326f99059fF775485246999027B3197955)] = 95;\\n    tickers_claimable.push(\\\"USDT\\\");\\n\\n// -- limited offer at launch --\\n    available_tokens[0x4144410000000000000000000000000000000000000000000000000000000000] = address(0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47);\\n    min_received[address(0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47)] = 95;\\n    tickers_claimable.push(\\\"ADA\\\");\\n\\n    available_tokens[0x43616b6500000000000000000000000000000000000000000000000000000000] = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\\n    min_received[address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82)] = 95;\\n    tickers_claimable.push(\\\"Cake\\\");\\n\\n    available_tokens[0x5852500000000000000000000000000000000000000000000000000000000000] = address(0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE);\\n    min_received[address(0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE)] = 95;\\n    tickers_claimable.push(\\\"XRP\\\");\\n\\n    available_tokens[0x444f540000000000000000000000000000000000000000000000000000000000] = address(0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402);\\n    min_received[address(0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402)] = 95;\\n    tickers_claimable.push(\\\"DOT\\\");\\n\\n    available_tokens[0x444f474500000000000000000000000000000000000000000000000000000000] = address(0xbA2aE424d960c26247Dd6c32edC70B295c744C43);\\n    min_received[address(0xbA2aE424d960c26247Dd6c32edC70B295c744C43)] = 95;\\n    tickers_claimable.push(\\\"DOGE\\\");\\n\\n    _balances[msg.sender] = _totalSupply;\\n    emit Transfer(address(0), msg.sender, _totalSupply);\\n  }\\n\\n  function decimals() public view returns (uint256) {\\n        return _decimals;\\n  }\\n  function name() public view returns (string memory) {\\n      return _name;\\n  }\\n  function symbol() public view returns (string memory) {\\n      return _symbol;\\n  }\\n  function totalSupply() public view virtual override returns (uint256) {\\n      return _totalSupply;\\n  }\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n      return _balances[account];\\n  }\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n      _transfer(msg.sender, recipient, amount);\\n      return true;\\n  }\\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n      return _allowances[owner][spender];\\n  }\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n      _approve(msg.sender, spender, amount);\\n      return true;\\n  }\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n      _transfer(sender, recipient, amount);\\n\\n      uint256 currentAllowance = _allowances[sender][msg.sender];\\n      require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n      unchecked {\\n        _approve(sender, msg.sender, currentAllowance - amount);\\n      }\\n      return true;\\n  }\\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n      _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\n      return true;\\n  }\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n      uint256 currentAllowance = _allowances[msg.sender][spender];\\n      require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n      unchecked {\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\n      }\\n      return true;\\n  }\\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\\n      require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n      require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n      _allowances[owner][spender] = amount;\\n      emit Approval(owner, spender, amount);\\n  }\\n\\n\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n      require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n      \\n      uint256 senderBalance = _balances[sender];\\n      require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n\\n      uint256 sell_tax;\\n      uint256 dev_tax;\\n      uint256 mkt_tax;\\n      uint256 balancer_amount;\\n      uint256 contribution;\\n      \\n      if(!inSwapBool && excluded[sender] == false && excluded[recipient] == false && circuit_breaker == false) {\\n\\n        if(block.number <= startPublicSale + 5 && recipient == address(pair)) banned[msg.sender] = true;\\n        require(!banned[msg.sender], \\\"Early dump loose the game\\\");\\n      \\n        (uint112 _reserve0, uint112 _reserve1,) = pair.getReserves(); // returns reserve0, reserve1, timestamp last tx\\n        if(address(this) != pair.token0()) { // 0 := iBNB\\n          (_reserve0, _reserve1) = (_reserve1, _reserve0);\\n        }\\n        \\n      // ----  Sell tax & timestamp update ----\\n        if(recipient == address(pair)) {\\n          \\n          sell_tax = sellingTax(sender, amount, _reserve0); //will update the balancer/timestamps too\\n        }\\n\\n      // ----  Smart pool funding & check ----\\n        contribution = amount* taxes.reserve / 100;\\n        smart_pool_balances.token_reserve += contribution;\\n        if(last_smartpool_check < block.timestamp + smart_pool_freq) smartPoolCheck();\\n        \\n      // ------ \\\"flexible\\\"/dev&marketing taxes -------\\n        dev_tax = amount  * taxes.dev / 100;\\n        mkt_tax = amount * taxes.market / 100;\\n\\n      // ------ balancer tax  ------\\n        balancer_amount = amount * taxes.balancer / 100;\\n        balancer(balancer_amount, _reserve0);\\n\\n      // ----- reward buffer -----\\n        if(_balances[recipient] != 0) {\\n          _last_tx[recipient].reward_buffer += amount - sell_tax - dev_tax - mkt_tax - balancer_amount - contribution;\\n        } else {\\n          _last_tx[recipient].reward_buffer = 0;\\n        }\\n\\n      //every extra token are collected into address(this), the balancer then split them\\n      //between pool and reward, using the appropriate struct\\n        _balances[address(this)] += sell_tax + balancer_amount + contribution;\\n        _balances[devWallet] += dev_tax;\\n        _balances[mktWallet] += mkt_tax;\\n\\n      }\\n      //else, by default:\\n      //  sell_tax = 0;\\n      //  dev_tax = 0;\\n      //  balancer_amount = 0;\\n      //  contribution to smart pool = 0;\\n\\n      if(_balances[recipient] == 0) _last_tx[recipient].last_claim = block.timestamp;\\n\\n      _balances[sender] = senderBalance - amount;\\n      _balances[recipient] += amount - sell_tax - dev_tax - mkt_tax - balancer_amount - contribution;\\n      \\n      emit Transfer(sender, recipient, amount- sell_tax - dev_tax - mkt_tax - balancer_amount - contribution);\\n      emit Transfer(sender, address(this), sell_tax);\\n      emit Transfer(sender, address(this), balancer_amount);\\n      emit Transfer(sender, devWallet, dev_tax);\\n      emit Transfer(sender, mktWallet, mkt_tax);\\n  }\\n\\n  /// @dev take a selling tax if transfer from a non-excluded address or from the pair contract exceed\\n  /// the thresholds defined in selling_taxes_thresholds on a 24h floating window\\n  function sellingTax(address sender, uint256 amount, uint256 pool_balance) internal returns(uint256 sell_tax) {\\n\\n    if(block.timestamp > _last_tx[sender].last_sell + 1 days) {\\n      _last_tx[sender].cum_sell = 0; // a.k.a The Virgin\\n\\n    } else {\\n      uint16[3] memory _tax_tranches = selling_taxes_tranches;\\n\\n      uint256 new_cum_sum = amount+ _last_tx[sender].cum_sell;\\n\\n      if(new_cum_sum > pool_balance * _tax_tranches[2] / 10**4) sell_tax = amount * selling_taxes_rates[3] / 100;\\n      else if(new_cum_sum > pool_balance * _tax_tranches[1] / 10**4) sell_tax = amount * selling_taxes_rates[2] / 100;\\n      else if(new_cum_sum > pool_balance * _tax_tranches[0] / 10**4) sell_tax = amount * selling_taxes_rates[1] / 100;\\n      else sell_tax = amount * selling_taxes_rates[0] / 100;\\n    }\\n\\n    _last_tx[sender].cum_sell = _last_tx[sender].cum_sell + amount;\\n    _last_tx[sender].last_sell = block.timestamp;\\n\\n    smart_pool_balances.token_reserve += sell_tax; //sell tax goes in the dynamic reward pool\\n\\n    return sell_tax;\\n  }\\n\\n\\n  /// @dev take the balancer taxe as input, split it between reward and liq subpools\\n  ///    according to pool condition -> circ-pool/circ supply closer to one implies\\n  ///    priority to the reward pool. Threshold for swap checks in elif to avoid charging multiple swap on one transfer.\\n  /// @param amount new amount assigned to the balancer\\n  /// @param pool_balance reserve amount returned from the pair contract\\n  function balancer(uint256 amount, uint256 pool_balance) internal {\\n\\n      address DEAD = address(0x000000000000000000000000000000000000dEaD);\\n      uint256 unwght_circ_supply = totalSupply() - _balances[DEAD];\\n\\n      uint256 circ_supply = (pool_balance < unwght_circ_supply * pcs_pool_to_circ_ratio / 100) ? unwght_circ_supply * pcs_pool_to_circ_ratio / 100 : pool_balance;\\n\\n      balancer_balances.liquidity_pool += ((amount * (circ_supply - pool_balance)) * 10**9 / circ_supply) / 10**9;\\n      balancer_balances.reward_pool += ((amount * pool_balance) * 10**9 / circ_supply) / 10**9;\\n\\n      prop_balances memory _balancer_balances = balancer_balances;\\n\\n      if(_balancer_balances.reward_pool >= swap_for_reward_threshold) {\\n        uint256 BNB_balance_before = address(this).balance;\\n        uint256 token_out = swapForBNB(swap_for_reward_threshold, address(this)); //returns 0 if fail\\n        balancer_balances.reward_pool -= token_out; \\n        smart_pool_balances.BNB_reward += address(this).balance - BNB_balance_before;\\n      }\\n\\n      else if(smart_pool_balances.token_reserve >= swap_for_reserve_threshold) {\\n        uint256 BNB_balance_before = address(this).balance;\\n        uint256 token_out = swapForBNB(swap_for_reserve_threshold, address(this)); //returns 0 if fail\\n        smart_pool_balances.token_reserve -= token_out; \\n        smart_pool_balances.BNB_reserve += address(this).balance - BNB_balance_before;\\n      }\\n\\n      else if(_balancer_balances.liquidity_pool >= swap_for_liquidity_threshold) {\\n        uint256 token_out = addLiquidity(swap_for_liquidity_threshold); //returns 0 if fail\\n        balancer_balances.liquidity_pool -= token_out;\\n      }\\n\\n      emit BalancerPools(_balancer_balances.liquidity_pool, _balancer_balances.reward_pool);\\n  }\\n\\n  /// @dev when triggered, will swap and provide liquidity\\n  /// BNBfromSwap being the difference between before and after the swap, slippage\\n  /// will result in extra-BNB for the reward pool (free money for the guys:)\\n  function addLiquidity(uint256 token_amount) internal inSwap returns (uint256) {\\n    uint256 smart_pool_balance = address(this).balance;\\n\\n    address[] memory route = new address[](2);\\n    route[0] = address(this);\\n    route[1] = router.WETH();\\n\\n    if(allowance(address(this), address(router)) < token_amount) {\\n      _allowances[address(this)][address(router)] = ~uint256(0);\\n      emit Approval(address(this), address(router), ~uint256(0));\\n    }\\n    \\n    //odd numbers management -> half is smaller than amount.min(half)\\n    uint256 half = token_amount / 2;\\n    \\n    try router.swapExactTokensForETHSupportingFeeOnTransferTokens(half, 0, route, address(this), block.timestamp) {\\n      uint256 BNB_from_Swap = address(this).balance - smart_pool_balance;\\n\\n        try router.addLiquidityETH{value: BNB_from_Swap}(address(this), half, 0, 0, LP_recipient, block.timestamp) {\\n          emit AddLiq(\\\"addLiq: ok\\\");\\n          return (token_amount / 2) * 2;\\n        } catch {\\n          emit AddLiq(\\\"addLiq:liq fail\\\");\\n          return 0;\\n        }\\n\\n    } catch {\\n      emit AddLiq(\\\"addLiq:swap fail\\\");\\n      return 0;\\n    }\\n  }\\n\\n  /// @notice compute and return the available reward of the user, based on his token holding and the reward pool balance\\n  /// @return the tupple (net reward, tax paid, eligible for a \\\"gas waiver\\\")\\n  function computeReward() public view returns(uint256, uint256 tax_to_pay, bool gas_waiver) {\\n\\n    past_tx memory sender_last_tx = _last_tx[msg.sender];\\n\\n    //one claim max every 24h\\n    if (sender_last_tx.last_claim + claim_periodicity > block.timestamp) return (0, 0, false);\\n\\n    uint256 balance_without_buffer = sender_last_tx.reward_buffer >= _balances[msg.sender] ? 0 : _balances[msg.sender] - sender_last_tx.reward_buffer;\\n\\n    // no more linear increase/ \\\"on-off\\\" only\\n    uint256 _nom = balance_without_buffer * smart_pool_balances.BNB_reward * claim_ratio;\\n    uint256 _denom = totalSupply() * 100; //100 from claim ratio\\n    uint256 gross_reward_in_BNB = _nom / _denom;\\n\\n    tax_to_pay = taxOnClaim(gross_reward_in_BNB);\\n    if(tax_to_pay == gas_flat_fee) return(gross_reward_in_BNB + tax_to_pay, 0, true);\\n    return (gross_reward_in_BNB - tax_to_pay, tax_to_pay, false);\\n  }\\n\\n  /// @dev Compute the tax on claimed reward - labelled in BNB\\n  function taxOnClaim(uint256 amount) internal view returns(uint256 tax){\\n    if(amount <= gas_waiver_limits[1] && amount >= gas_waiver_limits[0]) return gas_flat_fee;\\n\\n    if(amount > 2 ether) return amount * claiming_taxes_rates[4] / 100;\\n    if(amount > 1.50 ether) return amount * claiming_taxes_rates[3] / 100;\\n    if(amount > 1 ether) return amount * claiming_taxes_rates[2] / 100;\\n    if(amount > 0.5 ether) return amount * claiming_taxes_rates[1] / 100;\\n    if(amount > 0.01 ether) return amount * claiming_taxes_rates[0] / 100;\\n    //if <0.01\\n    return 0;\\n  }\\n\\n  /// @dev tax goes to the smartpool reserve\\n  function claimReward(bytes32 ticker) external {\\n    (uint256 claimable, uint256 tax, bool gas_waiver) = computeReward();\\n    require(claimable > 0, \\\"Claim: 0\\\");\\n\\n    address dest_token = available_tokens[ticker];\\n    require(dest_token != address(0), \\\"Claim: invalid dest token\\\");\\n\\n    smart_pool_balances.BNB_reward -= (claimable+tax);\\n    smart_pool_balances.BNB_reserve += tax;\\n\\n    _last_tx[msg.sender].reward_buffer = 0;\\n    _last_tx[msg.sender].last_claim = block.timestamp;\\n\\n    custom_claimed[ticker]++;\\n    total_claimed += claimable;\\n              \\n    if(last_smartpool_check < block.timestamp + smart_pool_freq) smartPoolCheck();\\n\\n    if(dest_token == WETH) safeTransferETH(msg.sender, claimable);\\n    else if(dest_token == address(main_vault)) {\\n      uint256 claim_consumed = main_vault.claim(claimable, msg.sender, ticker); //multiple bonuses -> same vault address, ticker passed to get the correct one in vault contract\\n      if(combined_offer[ticker] != address(0)) {\\n        swapForCustom(claimable - claim_consumed, msg.sender, combined_offer[ticker]);\\n      }\\n    }\\n    else swapForCustom(claimable, msg.sender, dest_token);\\n\\n    emit Claimed(ticker, claimable, tax, gas_waiver);\\n  }\\n\\n  function smartPoolCheck() internal {\\n    smartpool_struct memory _smart_pool_bal = smart_pool_balances;\\n\\n    if(_smart_pool_bal.BNB_reserve > _smart_pool_bal.BNB_reward * excess_rate / 100) {\\n      smart_pool_balances.BNB_reward += _smart_pool_bal.BNB_reserve * minor_fill / 100;\\n      smart_pool_balances.BNB_reserve -= _smart_pool_bal.BNB_reserve * minor_fill / 100;\\n    }\\n\\n    if(_smart_pool_bal.BNB_reward <= _smart_pool_bal.BNB_prev_reward) {\\n      uint256 delta_reward = _smart_pool_bal.BNB_prev_reward - _smart_pool_bal.BNB_reward;\\n      if (_smart_pool_bal.BNB_reserve >= delta_reward) {\\n        smart_pool_balances.BNB_reward += delta_reward * resplenish_factor / 100;\\n        smart_pool_balances.BNB_reserve -= delta_reward * resplenish_factor / 100;\\n      }\\n    }\\n    if(_smart_pool_bal.BNB_reward > _smart_pool_bal.BNB_prev_reward * spike_threshold / 100) {\\n      uint256 delta_reward = _smart_pool_bal.BNB_reward - _smart_pool_bal.BNB_prev_reward;\\n      smart_pool_balances.BNB_reward -= delta_reward * shock_absorber / 100;\\n      smart_pool_balances.BNB_reserve += delta_reward * shock_absorber / 100;\\n    }\\n    \\n    smart_pool_balances.BNB_prev_reward = _smart_pool_bal.BNB_reward;\\n    last_smartpool_check = block.timestamp;\\n\\n    emit Smartpool(smart_pool_balances.BNB_reward, smart_pool_balances.BNB_reserve, smart_pool_balances.BNB_prev_reward);\\n\\n  }\\n\\n  function swapForBNB(uint256 token_amount, address receiver) internal inSwap returns (uint256) {\\n    address[] memory route = new address[](2);\\n    route[0] = address(this);\\n    route[1] = WETH;\\n\\n    if(allowance(address(this), address(router)) < token_amount) {\\n      _allowances[address(this)][address(router)] = ~uint256(0);\\n      emit Approval(address(this), address(router), ~uint256(0));\\n    }\\n\\n    uint256 theo_amount_received;\\n    try router.getAmountsOut(token_amount, route) returns (uint256[] memory out) {\\n      theo_amount_received = out[1];\\n    }\\n    catch Error(string memory _err) {\\n      revert(_err);\\n    }\\n\\n    uint256 min_to_receive = theo_amount_received * min_received[route[1]] / 100;\\n\\n    try router.swapExactTokensForETHSupportingFeeOnTransferTokens(token_amount, min_to_receive, route, receiver, block.timestamp) {\\n      emit SwapForBNB(\\\"Swap success\\\");\\n      return token_amount;\\n    }\\n    catch Error(string memory _err) {\\n      emit SwapForBNB(_err);\\n      return 0;\\n    }\\n  }\\n\\n  function swapForCustom(uint256 amount, address receiver, address dest_token) internal inSwap returns (uint256) {\\n    address wbnb = WETH;\\n\\n    if(dest_token == wbnb) {\\n      return swapForBNB(amount, receiver);\\n    } else {\\n      address[] memory route = new address[](2);\\n      route[0] = wbnb;\\n      route[1] = dest_token;\\n\\n      uint256 bal_before = IERC20(dest_token).balanceOf(receiver);\\n      uint256 theo_amount_received;\\n      try router.getAmountsOut(amount, route) returns (uint256[] memory out) {\\n        theo_amount_received = out[1];\\n      }\\n      catch Error(string memory _err) {\\n        revert(_err);\\n      }\\n\\n      uint256 min_to_receive = theo_amount_received * min_received[dest_token] / 100;\\n\\n      try router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(min_to_receive, route, receiver, block.timestamp) {\\n        emit SwapForCustom(\\\"SwapForToken: success\\\");\\n        uint256 received = IERC20(dest_token).balanceOf(receiver) - bal_before;\\n        return received;\\n      } catch Error(string memory _err) {\\n        revert(_err);\\n      }\\n    }\\n  }\\n\\n  /// @notice Check if invalid token listed as custom claim\\n  /// @dev validate all custom addresses by using symbol() from ierc20\\n  function validateCustomTickers() external view returns (string memory) {\\n    for(uint i = 0; i < tickers_claimable.length; i++) {\\n      if(available_tokens[tickers_claimable[i]] != address(main_vault) &&\\n        keccak256(abi.encodePacked(ERC20(available_tokens[tickers_claimable[i]]).symbol()))\\n        != keccak256(abi.encodePacked(bytes32ToString(tickers_claimable[i]))))\\n        return(bytes32ToString(tickers_claimable[i]));\\n    }\\n    return \\\"Validate: passed\\\";\\n  }\\n\\n  function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\\n    uint8 i = 0;\\n    while(i < 32 && _bytes32[i] != 0) {\\n        i++;\\n    }\\n    bytes memory bytesArray = new bytes(i);\\n    for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\\n        bytesArray[i] = _bytes32[i];\\n    }\\n    return string(bytesArray);\\n  }\\n\\n  function safeTransferETH(address to, uint value) internal {\\n      (bool success,) = payable(to).call{value: value}(new bytes(0));\\n      require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n      emit TransferBNB(to, value);\\n  }\\n\\n  /// @dev fallback in order to receive BNB from swapToBNB\\n  receive () external payable {}\\n\\n// ------------- Indiv addresses management -----------------\\n\\n  function excludeFromTaxes(address adr) external onlyOwner {\\n    require(!excluded[adr], \\\"already excluded\\\");\\n    excluded[adr] = true;\\n  }\\n\\n  function includeInTaxes(address adr) external onlyOwner {\\n    require(excluded[adr], \\\"already taxed\\\");\\n    excluded[adr] = false;\\n  }\\n\\n  function isExcluded(address adr) external view returns (bool){\\n    return excluded[adr];\\n  }\\n\\n  function lastTxStatus(address adr) external view returns (past_tx memory) {\\n    return _last_tx[adr];\\n  }\\n\\n// ---------- In case of emergency, break the glass -------------\\n\\n  /// @dev will bypass all the taxes and act as erc20.\\n  ///     pools & balancer balances will remain untouched\\n  function setCircuitBreaker(bool status) external onlyOwner {\\n    circuit_breaker = status;\\n  }\\n\\n  /// @notice if token accumulated in contract, trigger a swap of all of them\\n  function forceSwapForReward() external onlyOwner {\\n    uint256 BNB_balance_before = address(this).balance;\\n    uint256 token_out = swapForBNB(balancer_balances.reward_pool, address(this)); //returns 0 if fail\\n    balancer_balances.reward_pool -= token_out; \\n    smart_pool_balances.BNB_reward += address(this).balance - BNB_balance_before;\\n  }\\n\\n  function forceSmartpoolCheck() external onlyOwner {\\n    smartPoolCheck();\\n  }\\n\\n  /// @dev set the reward (BNB) pool balance, rest of the contract's balance is the reserve\\n  /// will mostly (hopefully) be used only on first cycle\\n  function smartpoolOverride(uint256 reward) external onlyOwner {\\n    require(address(this).balance >= reward, \\\"SPOverride: inf to contract balance\\\");\\n    smart_pool_balances.BNB_reserve = address(this).balance - reward;\\n    smart_pool_balances.BNB_reward = reward;\\n    emit SmartpoolOverride(reward, address(this).balance - reward);\\n  }\\n\\n  function resetBalancer() external onlyOwner {\\n    uint256 _contract_balance = _balances[address(this)];\\n    balancer_balances.reward_pool = _contract_balance / 2;\\n    balancer_balances.liquidity_pool = _contract_balance / 2;\\n    emit BalancerReset(balancer_balances.reward_pool, balancer_balances.liquidity_pool);\\n  }\\n\\n//  --------------  setters ---------------------\\n\\n  /// @dev only called by presale contract, set the beginning of public trading\\n  function setBlockPublicSale(uint256 _block_number) external {\\n    require(msg.sender == presaleContract, \\\"Non auth\\\");\\n    startPublicSale = _block_number;\\n  }\\n\\n  function setPresaleContract(address _adr) external onlyOwner {\\n    presaleContract = _adr;\\n  }\\n\\n  /// @dev Vaults are deployed on a per-use basis/this is a proxy to them\\n  function setVault(address new_vault) external onlyOwner {\\n    main_vault = IVault(new_vault);\\n  }\\n\\n  /// @notice add custom token to claim\\n  /// @param new_token address of the custom claim token contract\\n  /// @param ticker in bytes32\\n  /// @param _min_received_percents to set the max slippage\\n  function addClaimable(address new_token, bytes32 ticker, uint256 _min_received_percents) public onlyOwner {\\n    available_tokens[ticker] = new_token;\\n    tickers_claimable.push(ticker);\\n    min_received[new_token] = _min_received_percents;\\n    emit AddClaimableToken(ticker, new_token);\\n  }\\n\\n  function removeClaimable(bytes32 ticker) public onlyOwner {\\n    require(combined_offer[ticker] == address(0), \\\"Combined Offer\\\");\\n    delete available_tokens[ticker];\\n    delete custom_claimed[ticker];\\n\\n    bytes32[] memory _tickers_claimable = tickers_claimable;\\n    for(uint i=0; i<_tickers_claimable.length; i++) {\\n      if(_tickers_claimable[i] == ticker) {\\n        tickers_claimable[i] = _tickers_claimable[tickers_claimable.length - 1];\\n        break;\\n      }\\n    }\\n    tickers_claimable.pop();\\n    emit RemoveClaimableToken(ticker);\\n  }\\n\\n  function addCombinedOffer(address new_token, bytes32 ticker, uint256 _min_received_percents) external onlyOwner {\\n    require(available_tokens[ticker] == address(0), \\\"Remove single offer\\\");\\n    require(address(main_vault) != address(0), \\\"Vault not set\\\");\\n    combined_offer[ticker] = new_token;\\n    current_offers.push(ticker);\\n    addClaimable(address(main_vault), ticker, _min_received_percents);\\n  }\\n\\n  function removeCombinedOffer(bytes32 ticker) external onlyOwner {\\n    delete combined_offer[ticker];\\n\\n    bytes32[] memory _current_offers = current_offers;\\n    for(uint i=0; i<_current_offers.length; i++) {\\n      if(_current_offers[i] == ticker) {\\n        current_offers[i] = _current_offers[current_offers.length - 1];\\n        break;\\n      }\\n    }\\n    current_offers.pop();\\n    removeClaimable(ticker);\\n  }\\n\\n  /// @dev default = burned\\n  function setLPRecipient(address _LP_recipient) external onlyOwner {\\n    LP_recipient = _LP_recipient;\\n  }\\n\\n  function setDevWallet(address _devWallet) external onlyOwner {\\n    devWallet = _devWallet;\\n  }\\n\\n  function setMarketingWallet(address _mktWallet) external onlyOwner {\\n    mktWallet = _mktWallet;\\n  }\\n\\n  function setTaxRates(uint8 _dev, uint8 _market, uint8 _balancer, uint8 _reserve) external onlyOwner {\\n    taxes.dev = _dev;\\n    taxes.market = _market;\\n    taxes.balancer = _balancer;\\n    taxes.reserve = _reserve;\\n  }\\n\\n  function setSwapFor_Liq_Threshold(uint128 threshold_in_token) external onlyOwner {\\n    swap_for_liquidity_threshold = threshold_in_token * 10**_decimals;\\n  }\\n\\n  function setSwapFor_Reward_Threshold(uint128 threshold_in_token) external onlyOwner {\\n    swap_for_reward_threshold = threshold_in_token * 10**_decimals;\\n  }\\n\\n  function setSwapFor_Reserve_Threshold(uint128 threshold_in_token) external onlyOwner {\\n    swap_for_reserve_threshold = threshold_in_token * 10**_decimals;\\n  }\\n\\n  function setSellingTaxesTranches(uint16[3] memory new_tranches) external onlyOwner {\\n    selling_taxes_tranches = new_tranches;\\n    emit TaxRatesChanged();\\n  }\\n\\n  function setSellingTaxesrates(uint8[4] memory new_amounts) external onlyOwner {\\n    selling_taxes_rates = new_amounts;\\n    emit TaxRatesChanged();\\n  }\\n\\n  function setSmartpoolVar(uint8 _excess_rate, uint8 _minor_fill, uint8 _resplenish_factor, uint32 _freq_check) external onlyOwner {\\n    excess_rate = _excess_rate;\\n    minor_fill = _minor_fill;\\n    resplenish_factor = _resplenish_factor;\\n    smart_pool_freq = _freq_check;\\n  }\\n  \\n  function setRewardTaxesTranches(uint8 _pcs_pool_to_circ_ratio) external onlyOwner {\\n    pcs_pool_to_circ_ratio = _pcs_pool_to_circ_ratio;\\n  }\\n\\n  function setMaxSlippage(address token, uint256 new_max) external onlyOwner {\\n    min_received[token] = new_max;\\n  }\\n\\n  function setClaimingTaxesRates(uint8[5] memory new_tranches) external onlyOwner {\\n    claiming_taxes_rates = new_tranches;\\n  }\\n\\n  function setClaimingPeriodicity(uint new_period) external onlyOwner {\\n    claim_periodicity = new_period;\\n  }\\n\\n  function addOwner(address _new) external onlyOwner {\\n    require(!isOwner[_new], \\\"Already owner\\\");\\n    isOwner[_new] = true;\\n  }\\n\\n  function removeOwner(address _adr) external onlyOwner {\\n    require(isOwner[_adr], \\\"Not an owner\\\");\\n    isOwner[_adr] = false;\\n  }\\n\\n// ---------- frontend ---------------\\n  function getCurrentOffers() external view returns (bytes32[] memory) {\\n    return current_offers;\\n  }\\n\\n  function getCurrentClaimable() external view returns (bytes32[] memory) {\\n    return tickers_claimable;\\n  }\\n\\n  function endOfWaitingTime() external view returns (uint256) {\\n    return _last_tx[msg.sender].last_claim + claim_periodicity;\\n  } \\n\\n  /// @notice returns quote as number of token received for amount BNB\\n  /// @dev returns 0 for non-claimable tokens\\n  function getQuote(bytes32 ticker) external view returns (uint256 amount, uint8 dec) {\\n    address wbnb = WETH;\\n    (amount,,) = computeReward();\\n\\n    //combined offer ?\\n    address dest_token = available_tokens[ticker] == address(main_vault) ? combined_offer[ticker] : available_tokens[ticker];\\n    if(available_tokens[ticker] == address(0)) return (0, 0);\\n    if(available_tokens[ticker] == wbnb) return (amount, 18);\\n\\n    address[] memory route = new address[](2);\\n    route[0] = wbnb;\\n    route[1] = dest_token;\\n\\n    try IDec(dest_token).decimals() returns (uint8 _dec) {\\n        dec = _dec;\\n      } catch {\\n        dec=18;\\n      } //yeah, could've been part of ERC20...\\n\\n    try router.getAmountsOut(amount, route) returns (uint256[] memory out) {\\n      return (out[1], dec);\\n    } catch {\\n      return (0,0);\\n    }\\n  }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"AddClaimableToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"name\":\"AddLiq\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_liq_pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_token_pool\",\"type\":\"uint256\"}],\"name\":\"BalancerPools\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_reward_token_pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_reward_liq_pool\",\"type\":\"uint256\"}],\"name\":\"BalancerReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"gas_waiver\",\"type\":\"bool\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"}],\"name\":\"RemoveClaimableToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RewardTaxChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prev_reward\",\"type\":\"uint256\"}],\"name\":\"Smartpool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_reserve\",\"type\":\"uint256\"}],\"name\":\"SmartpoolOverride\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"name\":\"SwapForBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"name\":\"SwapForCustom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TaxRatesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TransferBNB\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LP_recipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_min_received_percents\",\"type\":\"uint256\"}],\"name\":\"addClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_min_received_percents\",\"type\":\"uint256\"}],\"name\":\"addCombinedOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"available_tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"banned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circuit_breaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim_periodicity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claiming_taxes_rates\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"combined_offer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"computeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tax_to_pay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"gas_waiver\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"current_offers\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"custom_claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endOfWaitingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excess_rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"excludeFromTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceSmartpoolCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceSwapForReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gas_flat_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gas_waiver_limits\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentClaimable\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentOffers\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"}],\"name\":\"getQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"dec\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"includeInTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"lastTxStatus\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"cum_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward_buffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_claim\",\"type\":\"uint256\"}],\"internalType\":\"struct Rewardeum.past_tx\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_smartpool_check\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"main_vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"min_received\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minor_fill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mktWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"}],\"name\":\"removeClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ticker\",\"type\":\"bytes32\"}],\"name\":\"removeCombinedOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetBalancer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resplenish_factor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"selling_taxes_rates\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"selling_taxes_tranches\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_block_number\",\"type\":\"uint256\"}],\"name\":\"setBlockPublicSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setCircuitBreaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_period\",\"type\":\"uint256\"}],\"name\":\"setClaimingPeriodicity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[5]\",\"name\":\"new_tranches\",\"type\":\"uint8[5]\"}],\"name\":\"setClaimingTaxesRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devWallet\",\"type\":\"address\"}],\"name\":\"setDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_LP_recipient\",\"type\":\"address\"}],\"name\":\"setLPRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mktWallet\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"new_max\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"setPresaleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pcs_pool_to_circ_ratio\",\"type\":\"uint8\"}],\"name\":\"setRewardTaxesTranches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[3]\",\"name\":\"new_tranches\",\"type\":\"uint16[3]\"}],\"name\":\"setSellingTaxesTranches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[4]\",\"name\":\"new_amounts\",\"type\":\"uint8[4]\"}],\"name\":\"setSellingTaxesrates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_excess_rate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_minor_fill\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_resplenish_factor\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_freq_check\",\"type\":\"uint32\"}],\"name\":\"setSmartpoolVar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"threshold_in_token\",\"type\":\"uint128\"}],\"name\":\"setSwapFor_Liq_Threshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"threshold_in_token\",\"type\":\"uint128\"}],\"name\":\"setSwapFor_Reserve_Threshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"threshold_in_token\",\"type\":\"uint128\"}],\"name\":\"setSwapFor_Reward_Threshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_dev\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_market\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_balancer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_reserve\",\"type\":\"uint8\"}],\"name\":\"setTaxRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shock_absorber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smart_pool_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"BNB_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"BNB_reserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"BNB_prev_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token_reserve\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smart_pool_freq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"smartpoolOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spike_threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPublicSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_for_liquidity_threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_for_reserve_threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_for_reward_threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"dev\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"market\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"balancer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"reserve\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tickers_claimable\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validateCustomTickers\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Rewardeum", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}