{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0; \r\n\r\ncontract owned\r\n{\r\n    address internal owner;\r\n    address internal newOwner;\r\n    address public signer;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        signer = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlySigner {\r\n        require(msg.sender == signer, 'caller must be signer');\r\n        _;\r\n    }\r\n\r\n\r\n    function changeSigner(address _signer) public onlyOwner {\r\n        signer = _signer;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n interface tokenInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n    function balanceOf(address _user) external view returns(uint);\r\n }\r\n\r\n\r\ncontract Better_X is owned {\r\n\r\n    // Replace below address with main token token\r\n    address public tokenAddress;\r\n\r\n    uint maxDownLimit = 2;\r\n    uint public startTime = block.timestamp;\r\n\r\n    uint public lastIDCount = 0;\r\n    uint public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint parentID;\r\n        uint referrerID;\r\n        uint directCount;\r\n        uint levelBought;\r\n        address[] parent;\r\n        address[] referral;\r\n    }\r\n\r\n\r\n    \r\n    mapping(uint => uint) public priceOfLevel;\r\n\r\n    mapping(uint => uint) public autoPoolDist;\r\n\r\n    struct autoPool\r\n    {\r\n        uint userID;\r\n        uint autoPoolParent;\r\n    }\r\n    mapping(uint => autoPool[]) public autoPoolLevel;  // users lavel records under auto pool scheme\r\n    mapping(address => mapping(uint => uint[])) public autoPoolIndex; //to find index of user inside auto pool\r\n    uint[10] public nextMemberFillIndex;  // which auto pool index is in top of queue to fill in \r\n    uint[10] public nextMemberFillBox;   // 3 downline to each, so which downline need to fill in\r\n\r\n    mapping(uint => autoPool[]) public X3PoolLevel;  // users lavel records under auto pool scheme\r\n    mapping(address => mapping(uint => uint[])) public X3PoolIndex; //to find index of user inside auto pool\r\n    uint[10] public X3FillIndex;  // which auto pool index is in top of queue to fill in \r\n    uint[10] public X3FillBox;   // 3 downline to each, so which downline need to fill in\r\n\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint => address payable) public userAddressByID;\r\n\r\n    uint directRefIncome = 40000; // 40%\r\n    uint communityIncome = 2000; // 2% to each level = 20%\r\n    uint x3Income = 20000; // 20%\r\n    uint autoPoolIncome = 2000; // 2% to each level = 20%\r\n\r\n    event regLevelEv(address indexed _userWallet, uint indexed _userID, uint indexed _parentID, uint _time, address _refererWallet, uint _referrerID);\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(address indexed _fromuser, address indexed _touser, uint _level, uint _amount, uint _pkg, uint _time, uint _flag);\r\n\r\n    event updateAutoPoolEv(uint timeNow,uint autoPoolLevelIndex,uint userIndexInAutoPool, address user, uint parentID);\r\n    event autoPoolPayEv(uint timeNow,address paidTo,uint paidForLevel, uint paidAmount, address paidAgainst, uint pkg);\r\n    event X3PoolPayEv(address paidTo,uint paidForLevel, uint paidAmount, address paidAgainst, uint pkg, address mainUser);\r\n    event updateX3PoolEv(uint timeNow,uint autoPoolLevelIndex,uint userIndexInAutoPool, address user, uint parentId);\r\n\r\n    function initialize(address payable ownerAddress, address payable ID1address) public onlyOwner {\r\n        owner = ownerAddress;\r\n\r\n        emit OwnershipTransferred(address(0), owner);\r\n        address payable ownerWallet = ID1address;\r\n\r\n        uint pow = 10 ** 18;\r\n\r\n        priceOfLevel[1] = 25 * (pow);\r\n        priceOfLevel[2] = 50 * (pow);\r\n        priceOfLevel[3] = 100 * (pow);\r\n        priceOfLevel[4] = 250 * (pow);\r\n        priceOfLevel[5] = 500 * (pow);\r\n        priceOfLevel[6] = 1000 * (pow);\r\n        priceOfLevel[7] = 1500 * (pow);\r\n        priceOfLevel[8] = 2500 * (pow);\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            parentID: 1,\r\n            referrerID: 1,\r\n            directCount: 31,\r\n            levelBought: 8,  \r\n            referral: new address[](0),\r\n            parent: new address[](0)\r\n        });\r\n        userInfos[ownerWallet] = UserInfo;\r\n        userAddressByID[lastIDCount] = ownerWallet;\r\n\r\n        autoPool memory temp;\r\n        for (uint a = 0 ; a < 10; a++)\r\n        {\r\n           temp.userID = lastIDCount;  \r\n           autoPoolLevel[a].push(temp);\r\n         \r\n           autoPoolIndex[ownerWallet][a].push(0);\r\n        }\r\n\r\n        autoPool memory temp2;\r\n        for (uint a = 0 ; a < 10; a++)\r\n        {\r\n           temp2.userID = lastIDCount;  \r\n           X3PoolLevel[a].push(temp2);\r\n         \r\n           X3PoolIndex[ownerWallet][a].push(0);\r\n        }\r\n\r\n        emit regLevelEv(ownerWallet, 1, 0, block.timestamp, address(this), 0);\r\n\r\n    }\r\n\r\n\r\n    function regUser(uint _referrerID) public returns(bool) \r\n    {\r\n\r\n        //this saves gas while using this multiple times\r\n        address msgSender = msg.sender; \r\n        uint pID = _referrerID;\r\n\r\n        \r\n        address origRef = userAddressByID[_referrerID];\r\n\r\n\r\n        //checking all conditions\r\n        require(!userInfos[msgSender].joined, 'User exist');\r\n\r\n        uint _lastIDCount = lastIDCount; \r\n        if(!(pID > 0 && pID <= _lastIDCount)) pID = defaultRefID;\r\n\r\n        address pidAddress = userAddressByID[pID];\r\n        if(userInfos[pidAddress].parent.length >= maxDownLimit ) pID = userInfos[findFreeReferrer(pidAddress)].id;\r\n\r\n\r\n        uint prc = priceOfLevel[1];\r\n        //transferring tokens from smart user to smart contract for level 1\r\n        tokenInterface(tokenAddress).transferFrom(msgSender, address(this), prc);\r\n        \r\n        //direct payment\r\n        tokenInterface(tokenAddress).transfer(origRef, ((prc * 32000 / 100000)*90)/100 );\r\n       // tokenInterface(tokenAddress).transfer(owner, ((prc * 32000 / 100000)*10)/100 );\r\n       emit paidForLevelEv(msgSender, origRef, 1, (prc * 32000 / 100000), prc, block.timestamp, 1);\r\n        \r\n        //emit regLevelEv(msgSender, lID, pID, block.timestamp,userAddressByID[_referrerID], _referrerID );\r\n        //update variables\r\n        userInfo memory UserInfo;\r\n        _lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: _lastIDCount,\r\n            parentID: pID,\r\n            referrerID: _referrerID,\r\n            directCount: 0,\r\n            levelBought: 1,             \r\n            referral: new address[](0),\r\n            parent: new address[](0)\r\n        });\r\n\r\n        userInfos[msgSender] = UserInfo;\r\n        userAddressByID[_lastIDCount] = payable(msgSender);\r\n\r\n\r\n        userInfos[userAddressByID[pID]].parent.push(msgSender);\r\n        \r\n\r\n\r\n        \r\n        userInfos[origRef].directCount++;\r\n        userInfos[origRef].referral.push(msgSender);\r\n\r\n\r\n        lastIDCount = _lastIDCount;\r\n        require(skiptPart(msgSender,_lastIDCount,pID,_referrerID,prc),\"split part failed\");\r\n        return true;\r\n    }\r\n    function regUser_own(uint _referrerID, address _user) public onlyOwner returns(bool) \r\n    {\r\n\r\n        //this saves gas while using this multiple times\r\n        address msgSender = _user;  \r\n        uint pID = _referrerID;\r\n\r\n        \r\n        address origRef = userAddressByID[_referrerID];\r\n\r\n\r\n        //checking all conditions\r\n        require(!userInfos[msgSender].joined, 'User exist');\r\n\r\n        uint _lastIDCount = lastIDCount; \r\n        if(!(pID > 0 && pID <= _lastIDCount)) pID = defaultRefID;\r\n\r\n        address pidAddress = userAddressByID[pID];\r\n        if(userInfos[pidAddress].parent.length >= maxDownLimit ) pID = userInfos[findFreeReferrer(pidAddress)].id;\r\n\r\n\r\n        uint prc = priceOfLevel[1];\r\n        //transferring tokens from smart user to smart contract for level 1\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), prc);\r\n        \r\n        //direct payment\r\n        tokenInterface(tokenAddress).transfer(origRef, ((prc * 32000 / 100000)*90)/100 );\r\n       // tokenInterface(tokenAddress).transfer(owner, ((prc * 32000 / 100000)*10)/100 );\r\n       emit paidForLevelEv(msgSender, origRef, 1, (prc * 32000 / 100000), prc, block.timestamp, 1);\r\n        \r\n        //emit regLevelEv(msgSender, lID, pID, block.timestamp,userAddressByID[_referrerID], _referrerID );\r\n        //update variables\r\n        userInfo memory UserInfo;\r\n        _lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: _lastIDCount,\r\n            parentID: pID,\r\n            referrerID: _referrerID,\r\n            directCount: 0,\r\n            levelBought: 1,             \r\n            referral: new address[](0),\r\n            parent: new address[](0)\r\n        });\r\n\r\n        userInfos[msgSender] = UserInfo;\r\n        userAddressByID[_lastIDCount] = payable(msgSender);\r\n\r\n\r\n        userInfos[userAddressByID[pID]].parent.push(msgSender);\r\n        \r\n\r\n\r\n        \r\n        userInfos[origRef].directCount++;\r\n        userInfos[origRef].referral.push(msgSender);\r\n\r\n\r\n        lastIDCount = _lastIDCount;\r\n        require(skiptPart(msgSender,_lastIDCount,pID,_referrerID,prc),\"split part failed\");\r\n        return true;\r\n    }\r\n\r\n    function skiptPart(address msgSender, uint lID, uint pID, uint _referrerID, uint prc) internal returns(bool)\r\n    {\r\n        require(payForLevel(1, msgSender),\"pay for level fail\");\r\n        emit regLevelEv(msgSender, lID, pID, block.timestamp,userAddressByID[_referrerID], _referrerID );\r\n        emit levelBuyEv(msgSender, 1, prc, block.timestamp);\r\n        require(updateNPayAutoPool(1,msgSender),\"auto pool update fail\"); \r\n        require(updateNPayX3Pool(1,msgSender),\"X3 pool update fail\");  \r\n        flushRemaining();      \r\n        return true;\r\n    }\r\n\r\n    function buyLevel(uint _level) public returns(bool){\r\n\r\n        require(userInfos[msg.sender].levelBought + 1 == _level, \"buy previous level first\");\r\n\r\n        //this saves gas while using this multiple times\r\n        address msgSender = msg.sender;   \r\n        \r\n        \r\n        //checking conditions\r\n        require(userInfos[msgSender].joined, 'User not exist'); \r\n\r\n        require(_level > 1 && _level <= 10, 'Incorrect level');\r\n        \r\n        //transfer tokens\r\n        uint prc = priceOfLevel[_level];\r\n        tokenInterface(tokenAddress).transferFrom(msgSender, address(this), prc);\r\n        userInfos[msg.sender].levelBought = _level;\r\n        address origRef = userAddressByID[userInfos[msgSender].referrerID];\r\n\r\n        //direct payment\r\n        if(userInfos[origRef].levelBought >= _level)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(origRef, ((prc * directRefIncome / 100000)*90)/100 );\r\n            emit paidForLevelEv(msgSender, origRef, 1, (prc * directRefIncome / 100000), prc, block.timestamp, 1);\r\n        }\r\n        else \r\n        {\r\n            tokenInterface(tokenAddress).transfer(owner, ((prc * directRefIncome / 100000)*90)/100 );\r\n            emit paidForLevelEv(msgSender, owner, 1, (prc * directRefIncome / 100000), prc, block.timestamp, 1);\r\n        }\r\n        \r\n\r\n        require(payForLevel(_level, msgSender),\"pay for level fail\");\r\n        emit levelBuyEv(msgSender, _level, priceOfLevel[_level] , block.timestamp);\r\n        require(updateNPayAutoPool(_level,msgSender),\"auto pool update fail\");\r\n        require(updateNPayX3Pool(_level,msgSender),\"X3 pool update fail\");  \r\n        flushRemaining();\r\n        return true;\r\n    }\r\n\r\n    function buyLevel_own(uint _level, address _user) public onlyOwner returns(bool){\r\n\r\n        require(userInfos[_user].levelBought + 1 == _level, \"buy previous level first\");\r\n\r\n        //this saves gas while using this multiple times\r\n        address msgSender = _user;   \r\n        \r\n        \r\n        //checking conditions\r\n        require(userInfos[msgSender].joined, 'User not exist'); \r\n\r\n        require(_level > 1 && _level <= 10, 'Incorrect level');\r\n        \r\n        //transfer tokens\r\n        uint prc = priceOfLevel[_level];\r\n        tokenInterface(tokenAddress).transferFrom( msg.sender, address(this), prc);\r\n        userInfos[msgSender].levelBought = _level;\r\n        address origRef = userAddressByID[userInfos[msgSender].referrerID];\r\n\r\n        //direct payment\r\n        if(userInfos[origRef].levelBought >= _level)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(origRef, ((prc * directRefIncome / 100000)*90)/100 );\r\n            emit paidForLevelEv(msgSender, origRef, 1, (prc * directRefIncome / 100000), prc, block.timestamp, 1);\r\n        }\r\n        else \r\n        {\r\n            tokenInterface(tokenAddress).transfer(owner, ((prc * directRefIncome / 100000)*90)/100 );\r\n            emit paidForLevelEv(msgSender, owner, 1, (prc * directRefIncome / 100000), prc, block.timestamp, 1);\r\n        }\r\n        \r\n\r\n        require(payForLevel(_level, msgSender),\"pay for level fail\");\r\n        emit levelBuyEv(msgSender, _level, priceOfLevel[_level] , block.timestamp);\r\n        require(updateNPayAutoPool(_level,msgSender),\"auto pool update fail\");\r\n        require(updateNPayX3Pool(_level,msgSender),\"X3 pool update fail\");  \r\n        flushRemaining();\r\n        return true;\r\n    }\r\n    \r\n\r\n\r\n    function payForLevel(uint _level, address _user) internal returns (bool){\r\n        address referer;\r\n        uint amt = priceOfLevel[_level] * communityIncome / 100000;\r\n\r\n        referer = userAddressByID[userInfos[_user].referrerID];\r\n        for(uint i=0; i < 10; i++)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(referer, (amt*90)/100);\r\n            //tokenInterface(tokenAddress).transfer(owner, (amt*10)/100 );\r\n            emit paidForLevelEv(_user, referer, i+1, amt, priceOfLevel[_level], block.timestamp, 2);\r\n            referer = userAddressByID[userInfos[referer].referrerID];\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n    function flushRemaining() internal returns(bool)\r\n    {\r\n        uint bal = tokenInterface(tokenAddress).balanceOf(address(this));\r\n        if (bal > 0) tokenInterface(tokenAddress).transfer(owner, bal);\r\n        return true;\r\n    }\r\n\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n        uint _limit = maxDownLimit;\r\n        if(userInfos[_user].parent.length < _limit ) return _user;\r\n\r\n        address[] memory referrals = new address[](126);\r\n\r\n        uint j;\r\n        for(j=0;j<_limit;j++)\r\n        {\r\n            referrals[j] = userInfos[_user].parent[j];\r\n        }\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n\r\n\r\n            if(userInfos[referrals[i]].parent.length == _limit) {\r\n\r\n                if(j < 62) {\r\n                    \r\n                    for(uint k=0;k< _limit;k++)\r\n                    {\r\n                        referrals[j] = userInfos[referrals[i]].parent[k];\r\n                        j++;\r\n                    }\r\n\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function updateNPayAutoPool(uint _level,address _user) internal returns (bool)\r\n    {\r\n        uint a = _level -1;\r\n        uint len = autoPoolLevel[a].length;\r\n        autoPool memory temp;\r\n        temp.userID = userInfos[_user].id;\r\n        uint idx = nextMemberFillIndex[a];\r\n        uint pid = idx;\r\n        temp.autoPoolParent = idx;       \r\n        autoPoolLevel[a].push(temp);        \r\n        \r\n\r\n        address payable usr = userAddressByID[autoPoolLevel[a][idx].userID];\r\n\r\n        if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n\r\n        uint amt = priceOfLevel[_level] * autoPoolIncome / 100000;\r\n        uint pkgg = priceOfLevel[_level];\r\n        for(uint i=0;i<10;i++)\r\n        {\r\n\r\n            tokenInterface(tokenAddress).transfer(usr, (amt*90)/100);\r\n           // tokenInterface(tokenAddress).transfer(owner, (amt*10)/100);\r\n            emit autoPoolPayEv(block.timestamp, usr, i+1, amt, _user, pkgg);\r\n            idx = autoPoolLevel[a][idx].autoPoolParent; \r\n            usr = userAddressByID[autoPoolLevel[a][idx].userID];\r\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n        }\r\n\r\n        if(nextMemberFillBox[a] == 0)\r\n        {\r\n            nextMemberFillBox[a] = 1;\r\n        }   \r\n        else\r\n        {\r\n            nextMemberFillIndex[a]++;\r\n            nextMemberFillBox[a] = 0;\r\n        }\r\n        autoPoolIndex[_user][_level - 1].push(len);\r\n        emit updateAutoPoolEv(block.timestamp, _level, len, _user, pid);\r\n        \r\n        return true;\r\n    }\r\n\r\n\r\n    function updateNPayX3Pool(uint _level,address _user) internal returns (bool)\r\n    {\r\n        uint a = _level -1;\r\n        uint len = X3PoolLevel[a].length;\r\n        autoPool memory temp;\r\n        temp.userID = userInfos[_user].id;\r\n        uint idx = X3FillIndex[a];\r\n        temp.autoPoolParent = idx;       \r\n        X3PoolLevel[a].push(temp); \r\n\r\n        uint place;       \r\n\r\n        bool recycle = false;\r\n        if(X3FillBox[a] == 0)\r\n        {\r\n            X3FillBox[a] = 1;\r\n        }   \r\n        else if (X3FillBox[a] == 1)\r\n        {\r\n            X3FillBox[a] = 2;\r\n            place = 1;\r\n        }\r\n        else\r\n        {\r\n            X3FillIndex[a]++;\r\n            X3FillBox[a] = 0;\r\n            place = 2;\r\n            recycle = true;\r\n        }\r\n\r\n        address payable usr = userAddressByID[X3PoolLevel[a][idx].userID];\r\n        if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n\r\n        if(recycle == false)\r\n        {\r\n\r\n\r\n\r\n            uint amt = priceOfLevel[_level] * x3Income / 100000;            \r\n            uint pkgg = priceOfLevel[_level];\r\n\r\n            if (_level == 1) amt = amt * 4 / 5;\r\n\r\n            if (place == 0 ) \r\n            {\r\n                tokenInterface(tokenAddress).transfer(usr, (amt*90)/100);\r\n                emit X3PoolPayEv(usr, 1, amt, _user, pkgg, usr);\r\n            }\r\n            else if (place == 1 ) \r\n            {\r\n                address usr2 = userAddressByID[userInfos[usr].referrerID];\r\n                for(uint i=0;i<5;i++)\r\n                {\r\n                    if(userInfos[usr2].levelBought >= _level) break;\r\n                     usr2 = userAddressByID[userInfos[usr2].referrerID];\r\n                }\r\n\r\n                if(userInfos[usr2].levelBought >= _level)\r\n                {\r\n                    tokenInterface(tokenAddress).transfer(usr2, (amt*90)/100);\r\n                    emit X3PoolPayEv( usr2, 2, amt, _user, pkgg, usr);                    \r\n                }\r\n                else \r\n                {\r\n                    tokenInterface(tokenAddress).transfer(owner, (amt*90)/100);\r\n                    emit X3PoolPayEv( owner, 2, amt, _user, pkgg, usr); \r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        X3PoolIndex[_user][_level - 1].push(len);\r\n        emit updateX3PoolEv(block.timestamp, _level, len, _user,idx);\r\n        if(recycle == true) updateNPayX3Pool(_level,usr);\r\n        return true;\r\n    }\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].referral;\r\n    }\r\n\r\n\r\n\r\n    function viewUsersOfParent(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].parent;\r\n    }\r\n\r\n\r\n    \r\n    function indexLength(uint _level) public view returns(uint)\r\n    {\r\n        if(!(_level > 0  || _level < 11)) return 0;\r\n        return X3PoolLevel[_level - 1].length;\r\n    }  \r\n\r\n    \r\n    function changetokenaddress(address newtokenaddress) onlyOwner public returns(string memory){\r\n        tokenAddress = newtokenaddress;\r\n        return(\"token address updated successfully\");\r\n    }\r\n    \r\n\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidForLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidAgainst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pkg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mainUser\",\"type\":\"address\"}],\"name\":\"X3PoolPayEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidForLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidAgainst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pkg\",\"type\":\"uint256\"}],\"name\":\"autoPoolPayEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"levelBuyEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_fromuser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_touser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_pkg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_flag\",\"type\":\"uint256\"}],\"name\":\"paidForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_parentID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_refererWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"regLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"autoPoolLevelIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userIndexInAutoPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentID\",\"type\":\"uint256\"}],\"name\":\"updateAutoPoolEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"autoPoolLevelIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userIndexInAutoPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"}],\"name\":\"updateX3PoolEv\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"X3FillBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"X3FillIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"X3PoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"X3PoolLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"autoPoolParent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"autoPoolDist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"autoPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"autoPoolLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"autoPoolParent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"buyLevel_own\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"changeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newtokenaddress\",\"type\":\"address\"}],\"name\":\"changetokenaddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"indexLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"ID1address\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"regUser_own\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parentID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBought\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUsersOfParent\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Better_X", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://726341ac1d6d2742e3a518ad0b399759c3b82dd19160a235fdc5f4bc3594d874"}