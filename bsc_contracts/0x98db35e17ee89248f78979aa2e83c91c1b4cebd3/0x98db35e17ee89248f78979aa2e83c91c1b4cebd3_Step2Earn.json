{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface Token{\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) ;\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    }\r\ncontract Step2Earn\r\n    {\r\n\r\n        struct allInvestments{\r\n\r\n            uint investedAmount;\r\n            uint expire_Time;\r\n            uint DepositTime;  \r\n            uint investmentNum;\r\n            uint unstakeTime;\r\n            bool unstake;\r\n            uint category;\r\n\r\n\r\n        }\r\n        struct ref_data{\r\n            uint reward;\r\n            uint count;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \r\n        }\r\n\r\n        struct Data{\r\n\r\n            mapping(uint=>allInvestments) investment;\r\n            address[] hisReferrals;\r\n            address referralFrom;\r\n            mapping(uint=>ref_data) referralLevel;\r\n            uint reward;\r\n            uint noOfInvestment;\r\n            uint totalInvestment;\r\n            uint totalWithdraw_reward;\r\n            bool investBefore;\r\n            uint stakeTime;\r\n            uint TotalReferrals_earning;\r\n        }\r\n        \r\n        uint public minimum_investment=10000000000000000000;\r\n        uint public buying_price=20000000000000000;\r\n        uint public selling_price=15000000000000000;\r\n\r\n\r\n        address public Token_address=0xcC143Bf065D91FBBCe858D76E823B65c2045d7d3;\r\n        address public usdt_address=0x55d398326f99059fF775485246999027B3197955;\r\n\r\n        address public owner=0x9177cBd62A910cD69909070cfC34cC6a6B924406;\r\n        address public marketing_add=0x4Be52B7FA0906f235a3AcA29B05E76562B3fdb8A;\r\n\r\n        uint public totalbusiness; \r\n        uint public investmentPeriod=334 days;\r\n        uint  divider=60 minutes;\r\n\r\n        \r\n\r\n        mapping(uint=>uint) public category_percentage;\r\n        mapping(address=>Data) public user;\r\n        uint[] public arr=[50000000000000000,50000000000000000,50000000000000000,50000000000000000];\r\n\r\n\r\n\r\n     constructor()\r\n     \r\n     {\r\n\r\n\r\n        for(uint i=0;i<4;i++)\r\n        {\r\n            category_percentage[i]=arr[i];\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n         function sendRewardToReferrals(address investor,uint _investedAmount)  internal  //this is the freferral function to transfer the reawards to referrals\r\n        { \r\n\r\n            address temp = investor;       \r\n            uint64[5] memory percentage = [5 ether,4 ether,3 ether,2 ether,1 ether];\r\n\r\n            for(uint i=0;i<5;i++)\r\n            {\r\n                \r\n                if(user[temp].referralFrom!=address(0))\r\n                {\r\n                    if(i==0)\r\n                    {\r\n                        \r\n                    }\r\n\r\n                    temp=user[temp].referralFrom;\r\n                    uint reward1 = (percentage[i] * _investedAmount)/100000000000000000000;\r\n\r\n                    user[temp].TotalReferrals_earning+=reward1 ;                  \r\n                    user[temp].referralLevel[i].reward+=reward1;\r\n                    user[temp].referralLevel[i].count++;\r\n\r\n\r\n                } \r\n                else{\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function define_category(uint amount) pure internal returns(uint){\r\n            if(amount>=10000000000000000000 && amount<100000000000000000000)\r\n            {\r\n                return 0;\r\n            }\r\n            else if(amount>=100000000000000000000 && amount<1000000000000000000000)\r\n            {\r\n                return 1;\r\n\r\n            }\r\n            else if(amount>=1000000000000000000000 && amount<10000000000000000000000)\r\n            {\r\n                return 2;\r\n\r\n            }\r\n            else if(amount>=10000000000000000000000)\r\n            {\r\n                return 3;\r\n\r\n            }\r\n            \r\n            return 100;\r\n        }\r\n\r\n       function BuyToken(uint token,address _referral) external  returns(bool)\r\n       {\r\n            require(Token(usdt_address).allowance(msg.sender,address(this))>=((buying_price * token)/10**18));\r\n\r\n            require(Token(usdt_address).balanceOf(msg.sender)>=((buying_price * token)/10**18));\r\n            \r\n            Token(Token_address).transfer(msg.sender,token);\r\n\r\n            uint amount50= ((((buying_price * token)/(10**18))*(50*10**18))/(100*10**18));\r\n            uint amount30= ((((buying_price * token)/(10**18))*(30*10**18))/(100*10**18));\r\n            uint amount20= ((((buying_price * token)/(10**18))*(20*10**18))/(100*10**18));\r\n\r\n            Token(usdt_address).transferFrom(msg.sender,address(this),amount50);\r\n            Token(usdt_address).transferFrom(msg.sender,owner,amount20);\r\n            Token(usdt_address).transferFrom(msg.sender,marketing_add,amount30);\r\n\r\n\r\n\r\n\r\n                if(_referral==address(0) || _referral==msg.sender)                                         //checking that investor comes from the referral link or not\r\n                {\r\n\r\n                    user[msg.sender].referralFrom = address(0);\r\n                }\r\n                else\r\n                {\r\n                   \r\n                    user[msg.sender].referralFrom = _referral;\r\n                    user[_referral].hisReferrals.push(msg.sender);\r\n                    sendRewardToReferrals(msg.sender,((buying_price * token)/10**18));      //with this function, sending the reward to the all 12 parent referrals\r\n\r\n                    \r\n                }\r\n\r\n\r\n\r\n            return true;\r\n       }\r\n\r\n       function SellToken(uint token) external  returns(bool)\r\n       {\r\n           require(Token(Token_address).allowance(msg.sender,address(this))>=token);\r\n\r\n            require(Token(Token_address).balanceOf(msg.sender)>=token);\r\n            \r\n            Token(usdt_address).transfer(msg.sender,((selling_price * token)/10**18));\r\n            Token(Token_address).transferFrom(msg.sender,address(this),token);\r\n            return true;\r\n       }\r\n       \r\n\r\n\r\n       function invest(uint _investedamount) external  returns(bool)\r\n       {\r\n            require(_investedamount>=minimum_investment,\"you cant invest less than minimumum investment\");\r\n\r\n            require(Token(Token_address).balanceOf(msg.sender)>=_investedamount,\"you dont have enough usdt\");\r\n            require(Token(Token_address).allowance(msg.sender,address(this))>=_investedamount,\"kindly appprove the USDT\");\r\n\r\n            Token(Token_address).transferFrom(msg.sender,address(this),_investedamount);\r\n\r\n            uint num = user[msg.sender].noOfInvestment;\r\n            user[msg.sender].investment[num].investedAmount =_investedamount;\r\n            user[msg.sender].investment[num].category= define_category(_investedamount);\r\n            user[msg.sender].investment[num].DepositTime=block.timestamp;\r\n            user[msg.sender].investment[num].expire_Time=block.timestamp + investmentPeriod ;  // 60 days\r\n            user[msg.sender].investment[num].investmentNum=num;\r\n            user[msg.sender].totalInvestment+=_investedamount;\r\n            user[msg.sender].noOfInvestment++;\r\n            totalbusiness+=_investedamount;\r\n\r\n            return true;\r\n        }\r\n\r\n        function getReward() view public returns(uint){ //this function is get the total reward balance of the investor\r\n            uint totalReward;\r\n            uint depTime;\r\n            uint rew;\r\n            uint temp = user[msg.sender].noOfInvestment;\r\n            for( uint i = 0;i < temp;i++)\r\n            {   \r\n                if(user[msg.sender].investment[i].expire_Time >block.timestamp)\r\n                {\r\n                    if(!user[msg.sender].investment[i].unstake)\r\n                    {\r\n                        depTime =block.timestamp - user[msg.sender].investment[i].DepositTime;\r\n                       \r\n\r\n                    }\r\n                    else{\r\n\r\n                        depTime =user[msg.sender].investment[i].unstakeTime - user[msg.sender].investment[i].DepositTime;\r\n\r\n                    }\r\n                }\r\n                else{\r\n\r\n                    if(!user[msg.sender].investment[i].unstake)\r\n                    {\r\n                        depTime =user[msg.sender].investment[i].expire_Time - user[msg.sender].investment[i].DepositTime;\r\n\r\n                    }\r\n                    else{\r\n                        if(user[msg.sender].investment[i].unstakeTime > user[msg.sender].investment[i].expire_Time)\r\n                        {\r\n                            depTime =user[msg.sender].investment[i].expire_Time - user[msg.sender].investment[i].DepositTime;\r\n\r\n                        }\r\n                        else{\r\n\r\n                            depTime =user[msg.sender].investment[i].unstakeTime - user[msg.sender].investment[i].DepositTime;\r\n\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n          \r\n                depTime=depTime/divider; //1 day\r\n\r\n                if(depTime>0)\r\n                {\r\n                    rew  = ((user[msg.sender].investment[i].investedAmount)*category_percentage[user[msg.sender].investment[i].category])/100000000000000000000;\r\n\r\n                    totalReward += depTime * rew;\r\n\r\n                }\r\n            }\r\n            totalReward += user[msg.sender].TotalReferrals_earning;\r\n\r\n            totalReward -= user[msg.sender].totalWithdraw_reward;\r\n\r\n            return totalReward;\r\n        }\r\n\r\n\r\n        function get_Total_Earning() view public returns(uint){ //this function is get the total reward balance of the investor\r\n            uint totalReward;\r\n            uint depTime;\r\n            uint rew;\r\n            uint temp = user[msg.sender].noOfInvestment;\r\n            for( uint i = 0;i < temp;i++)\r\n            {   \r\n                if(user[msg.sender].investment[i].expire_Time >block.timestamp)\r\n                {\r\n                    if(!user[msg.sender].investment[i].unstake)\r\n                    {\r\n                        depTime =block.timestamp - user[msg.sender].investment[i].DepositTime;\r\n                       \r\n\r\n                    }\r\n                    else{\r\n\r\n                        depTime =user[msg.sender].investment[i].unstakeTime - user[msg.sender].investment[i].DepositTime;\r\n\r\n                    }\r\n                }\r\n                else{\r\n\r\n                    if(!user[msg.sender].investment[i].unstake)\r\n                    {\r\n                        depTime =user[msg.sender].investment[i].expire_Time - user[msg.sender].investment[i].DepositTime;\r\n\r\n                    }\r\n                    else{\r\n                        if(user[msg.sender].investment[i].unstakeTime > user[msg.sender].investment[i].expire_Time)\r\n                        {\r\n                            depTime =user[msg.sender].investment[i].expire_Time - user[msg.sender].investment[i].DepositTime;\r\n\r\n                        }\r\n                        else{\r\n\r\n                            depTime =user[msg.sender].investment[i].unstakeTime - user[msg.sender].investment[i].DepositTime;\r\n\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n          \r\n                depTime=depTime/divider; //1 day\r\n                if(depTime>0)\r\n                {\r\n                    rew  = ((user[msg.sender].investment[i].investedAmount)*category_percentage[user[msg.sender].investment[i].category])/100000000000000000000;\r\n\r\n                    totalReward += depTime * rew;\r\n\r\n                }\r\n            }\r\n                totalReward += user[msg.sender].TotalReferrals_earning;\r\n\r\n\r\n            return totalReward;\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        function getReward(address _investor) view public returns(uint){ //this function is get the total reward balance of the investor\r\n            uint totalReward;\r\n            uint depTime;\r\n            uint rew;\r\n            uint temp = user[_investor].noOfInvestment;\r\n            for( uint i = 0;i < temp;i++)\r\n            {   \r\n                if(user[_investor].investment[i].expire_Time >block.timestamp)\r\n                {\r\n                    if(!user[_investor].investment[i].unstake)\r\n                    {\r\n                        depTime =block.timestamp - user[_investor].investment[i].DepositTime;\r\n\r\n                    }\r\n                    else{\r\n\r\n                        depTime =user[_investor].investment[i].unstakeTime - user[_investor].investment[i].DepositTime;\r\n\r\n                    }\r\n                }\r\n                else{\r\n\r\n                    if(!user[_investor].investment[i].unstake)\r\n                    {\r\n                        depTime =user[_investor].investment[i].expire_Time - user[_investor].investment[i].DepositTime;\r\n\r\n                    }\r\n                    else{\r\n                        if(user[_investor].investment[i].unstakeTime > user[_investor].investment[i].expire_Time)\r\n                        {\r\n                            depTime =user[_investor].investment[i].expire_Time - user[_investor].investment[i].DepositTime;\r\n\r\n                        }\r\n                        else{\r\n\r\n                            depTime =user[_investor].investment[i].unstakeTime - user[_investor].investment[i].DepositTime;\r\n\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n          \r\n                depTime=depTime/divider; //1 day\r\n\r\n                if(depTime>0)\r\n                {\r\n                    rew  = ((user[_investor].investment[i].investedAmount)*category_percentage[user[_investor].investment[i].category])/100000000000000000000;\r\n\r\n                    totalReward += depTime * rew;\r\n\r\n                }\r\n            }\r\n            totalReward += user[_investor].TotalReferrals_earning;\r\n\r\n            totalReward -= user[_investor].totalWithdraw_reward;\r\n\r\n\r\n            return totalReward;\r\n        }\r\n\r\n\r\n\r\n        function getReward_perInvestment(uint i) view public returns(uint){ //this function is get the total reward balance of the investor\r\n            uint totalReward;\r\n            uint depTime;\r\n            uint rew;\r\n  \r\n            if(user[msg.sender].investment[i].expire_Time >block.timestamp)\r\n            {\r\n                if(!user[msg.sender].investment[i].unstake)\r\n                {\r\n                    depTime =block.timestamp - user[msg.sender].investment[i].DepositTime;\r\n                    \r\n                }\r\n                else{\r\n\r\n                    depTime =user[msg.sender].investment[i].unstakeTime - user[msg.sender].investment[i].DepositTime;\r\n\r\n                }\r\n            }\r\n            else{\r\n\r\n                if(!user[msg.sender].investment[i].unstake)\r\n                {\r\n                    depTime =user[msg.sender].investment[i].expire_Time - user[msg.sender].investment[i].DepositTime;\r\n\r\n                }\r\n                else{\r\n                    if(user[msg.sender].investment[i].unstakeTime > user[msg.sender].investment[i].expire_Time)\r\n                    {\r\n                        depTime =user[msg.sender].investment[i].expire_Time - user[msg.sender].investment[i].DepositTime;\r\n\r\n                    }\r\n                    else{\r\n\r\n                        depTime =user[msg.sender].investment[i].unstakeTime - user[msg.sender].investment[i].DepositTime;\r\n\r\n                    }\r\n\r\n\r\n                }\r\n\r\n            }\r\n          \r\n            depTime=depTime/divider; //1 day\r\n            if(depTime>0)\r\n            {\r\n                rew  = ((user[msg.sender].investment[i].investedAmount)*category_percentage[user[msg.sender].investment[i].category])/100000000000000000000;\r\n\r\n                totalReward += depTime * rew;\r\n\r\n            }\r\n            \r\n            return totalReward;\r\n        }\r\n\r\n\r\n        function withdrawReward(uint _amount) external returns (bool success){\r\n            // require(_amount>=10000000000000000000,\"you can't withdraw less than 8 usdt\");         //ensuring that if the investor have rewards to withdraw\r\n\r\n            uint Total_reward = getReward(msg.sender);\r\n            require(Total_reward>=_amount,\"you dont have rewards to withdrawn\");         //ensuring that if the investor have rewards to withdraw\r\n        \r\n            Token(Token_address).transfer(msg.sender,_amount);             // transfering the reward to investor             \r\n            user[msg.sender].totalWithdraw_reward+=_amount;\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n\r\n       function change_minimum_investment(uint _inv) external returns(bool){\r\n           require(msg.sender==owner,\"only owner can do this\");\r\n           require(_inv > 0,\"value should be greater than 0\");\r\n           minimum_investment=_inv;\r\n           return true;\r\n\r\n        }\r\n\r\n\r\n        function change_investmentPeriod(uint _period) external returns(bool){\r\n           require(msg.sender==owner,\"only owner can do this\");\r\n           require(_period > 0,\"value should be greater than 0\");\r\n           investmentPeriod=_period * 1 days;\r\n           return true;\r\n\r\n        } \r\n\r\n\r\n        function getTotalInvestment() public view returns(uint) {   //this function is to get the total investment of the ivestor\r\n            \r\n            return user[msg.sender].totalInvestment;\r\n\r\n        }\r\n\r\n        function getAllinvestments() public view returns (allInvestments[] memory) { //this function will return the all investments of the investor and withware date\r\n            uint num = user[msg.sender].noOfInvestment;\r\n            uint temp;\r\n            uint currentIndex;\r\n            \r\n            for(uint i=0;i<num;i++)\r\n            {\r\n               if( user[msg.sender].investment[i].investedAmount > 0  ){\r\n                   temp++;\r\n               }\r\n\r\n            }\r\n         \r\n            allInvestments[] memory Invested =  new allInvestments[](temp) ;\r\n\r\n            for(uint i=0;i<num;i++)\r\n            {\r\n               if( user[msg.sender].investment[i].investedAmount > 0 ){\r\n                 //allInvestments storage currentitem=user[msg.sender].investment[i];\r\n                   Invested[currentIndex]=user[msg.sender].investment[i];\r\n                   currentIndex++;\r\n               }\r\n\r\n            }\r\n            return Invested;\r\n\r\n        }\r\n\r\n        function referralLevel_earning() public view returns( uint[] memory arr1 )\r\n        {\r\n            uint[] memory referralLevels_reward=new uint[](5);\r\n            for(uint i=0;i<5;i++)\r\n            {\r\n                if(user[msg.sender].referralLevel[i].reward>0)\r\n                {\r\n                    referralLevels_reward[i] = user[msg.sender].referralLevel[i].reward;\r\n\r\n\r\n                }\r\n                else{\r\n\r\n                    referralLevels_reward[i] = 0;\r\n\r\n                }\r\n\r\n\r\n            }\r\n            return referralLevels_reward ;\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        function referralLevel_count() public view returns( uint[] memory _arr )\r\n        {\r\n            uint[] memory referralLevels_reward=new uint[](5);\r\n            for(uint i=0;i<5;i++)\r\n            {\r\n                if(user[msg.sender].referralLevel[i].reward>0)\r\n                {\r\n                    referralLevels_reward[i] = user[msg.sender].referralLevel[i].count;\r\n\r\n\r\n                }\r\n                else{\r\n                    referralLevels_reward[i] = 0;\r\n\r\n                }\r\n\r\n\r\n            }\r\n            return referralLevels_reward ;\r\n\r\n\r\n        }\r\n\r\n\r\n        function TotalReferrals() public view returns(uint){ // this function is to get the total number of referrals \r\n            return (user[msg.sender].hisReferrals).length;\r\n        }\r\n        function TotalReferrals_inside(address investor) internal view returns(uint){ // this function is to get the total number of referrals \r\n            return (user[investor].hisReferrals).length;\r\n        }\r\n\r\n        function ReferralsList() public view returns(address[] memory){ //this function is to get the all investors list with there account number\r\n           return user[msg.sender].hisReferrals;\r\n        }\r\n\r\n        function get_total_ref_earning() public view returns(uint){ //this function is to get the all investors list with there account number\r\n           return user[msg.sender].TotalReferrals_earning;\r\n        }\r\n\r\n\r\n\r\n  \r\n        function transferOwnership(address _owner)  public\r\n        {\r\n            require(msg.sender==owner,\"only Owner can call this function\");\r\n            owner = _owner;\r\n        }\r\n\r\n        function total_withdraw_reaward() view public returns(uint){\r\n\r\n\r\n            uint Temp = user[msg.sender].totalWithdraw_reward;\r\n\r\n            return Temp;\r\n            \r\n\r\n        }\r\n        function get_currTime() public view returns(uint)\r\n        {\r\n            return block.timestamp;\r\n        }\r\n        function withdrawStep(uint _amount)  public\r\n        {\r\n            require(msg.sender==owner,\"only Owner can call this function\");\r\n            uint bal = Token(Token_address).balanceOf(address(this));\r\n            require(bal>=_amount,\"you dont have funds\");\r\n\r\n            Token(Token_address).transfer(owner,_amount); \r\n        }\r\n        function withdrawUsdt(uint _amount)  public\r\n        {\r\n            require(msg.sender==owner,\"only Owner can call this function\");\r\n            uint bal = Token(usdt_address).balanceOf(address(this));\r\n            require(bal>=_amount,\"you dont have funds\");\r\n\r\n            Token(usdt_address).transfer(owner,_amount); \r\n        }\r\n        function get_Contract_Funds() view public returns(uint) \r\n        {\r\n            require(msg.sender==owner,\"only Owner can call this function\");\r\n            uint bal = Token(Token_address).balanceOf(address(this)); \r\n\r\n            return bal;\r\n        }\r\n        function get_InvExp_Date(uint _num) public view returns(uint)\r\n        {\r\n            return user[msg.sender].investment[_num].expire_Time;\r\n        }\r\n       function cal(uint token) public view returns(uint)\r\n        {\r\n            return ((buying_price * token)/10**18);\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"BuyToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReferralsList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"SellToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buying_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"cal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"category_percentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"change_investmentPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inv\",\"type\":\"uint256\"}],\"name\":\"change_minimum_investment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllinvestments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"investedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expire_Time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DepositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"}],\"internalType\":\"struct Step2Earn.allInvestments[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getReward_perInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_Contract_Funds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"get_InvExp_Date\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_Total_Earning\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_currTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_total_ref_earning\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investedamount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investmentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing_add\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimum_investment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralLevel_count\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_arr\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralLevel_earning\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"arr1\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selling_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_withdraw_reaward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalbusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referralFrom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noOfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdraw_reward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"investBefore\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalReferrals_earning\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Step2Earn", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://256e62c275d73015a3e23fddda0edde5bff182c88d3ce94a1086c739ed55d2da"}