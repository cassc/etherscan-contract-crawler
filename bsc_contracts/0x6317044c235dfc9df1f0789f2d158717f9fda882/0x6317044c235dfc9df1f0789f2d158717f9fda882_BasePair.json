{"SourceCode": "{\"BaseFactory.sol\":{\"content\":\"/**\\n * @title Base Factory\\n * @dev BaseFactory.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nimport \\\"./BasePair.sol\\\";\\nimport \\\"./IBaseFactory.sol\\\";\\n\\ncontract BaseFactory is IBaseFactory {\\n    bool public isPaused;\\n    address public owner;\\n    address public pendingOwner;\\n    address public admin;\\n    address public feeAmountOwner;\\n\\n    uint256 public baseStableFee = 2500; // 0.04%\\n    uint256 public baseVariableFee = 333; // 0.3%\\n\\n    mapping(address =\\u003e mapping(address =\\u003e mapping(bool =\\u003e address)))\\n        public getPair;\\n    address[] public allPairs;\\n    mapping(address =\\u003e bool) public isPair; // simplified check if its a pair, given that `stable` flag might not be available in peripherals\\n\\n    address internal _temp0;\\n    address internal _temp1;\\n    bool internal _temp;\\n\\n    mapping(address =\\u003e address) public protocolAddresses; // pair =\\u003e protocolAddress\\n    address public usdfiMaker;\\n\\n    uint256 public maxGasPrice; // 1000000000 == 1 gwei\\n\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        bool stable,\\n        address pair,\\n        uint256 allPairsLength\\n    );\\n    event SetAdmins(address usdfiMaker, address feeAmountOwner, address admin);\\n    event SetProtocolAddress(address pair, address protocolAddress);\\n    event SetPause(bool statePause);\\n    event AcceptOwner(address newOwner);\\n    event SetOwner(address newPendingOwner);\\n    event SetMaxGasPrice(uint256 maxGas);\\n    event SetBaseVariableFee(uint256 fee);\\n    event SetBaseStableFee(uint256 fee);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        feeAmountOwner = msg.sender;\\n    }\\n\\n    // set the fee for all new stable-LPs\\n    // 10 max fees for LPs (10%)\\n    // 10000 min fees for LPs (0.01%)\\n    function setBaseStableFee(uint256 _fee) external {\\n        require(msg.sender == owner);\\n        require(_fee \\u003e= 10 \\u0026\\u0026 _fee \\u003c= 10000, \\\"!range\\\");\\n        baseStableFee = _fee;\\n\\n        emit SetBaseStableFee(_fee);\\n    }\\n\\n    // set the fee for all new variable-LPs\\n    // 10 max fees for LPs (10%)\\n    // 10000 min fees for LPs (0.01%)\\n    function setBaseVariableFee(uint256 _fee) external {\\n        require(msg.sender == owner);\\n        require(_fee \\u003e= 10 \\u0026\\u0026 _fee \\u003c= 10000, \\\"!range\\\");\\n        baseVariableFee = _fee;\\n\\n        emit SetBaseVariableFee(_fee);\\n    }\\n\\n    // set with which max gas swaps can be performed / 0 for stop max gas\\n    function setMaxGasPrice(uint256 _gas) external {\\n        require(msg.sender == owner, \\\"Pair: only owner or admin\\\");\\n        maxGasPrice = _gas;\\n\\n        emit SetMaxGasPrice(_gas);\\n    }\\n\\n    // return the quantity of all LPs\\n    function allPairsLength() external view returns (uint256) {\\n        return allPairs.length;\\n    }\\n\\n    // set new Owner for the Factory\\n    function setOwner(address _owner) external {\\n        require(msg.sender == owner);\\n        pendingOwner = _owner;\\n\\n        emit SetOwner(_owner);\\n    }\\n\\n    // pending owner accepts owner\\n    function acceptOwner() external {\\n        require(msg.sender == pendingOwner);\\n        owner = pendingOwner;\\n\\n        emit AcceptOwner(pendingOwner);\\n    }\\n\\n    // set the swaps on pause (only swaps)\\n    function setPause(bool _state) external {\\n        require(msg.sender == owner || msg.sender == admin);\\n        isPaused = _state;\\n\\n        emit SetPause(_state);\\n    }\\n\\n    // set the external protocol address for special fees\\n    function setProtocolAddress(address _pair, address _protocolAddress)\\n        external\\n    {\\n        require(msg.sender == owner || msg.sender == admin);\\n        protocolAddresses[_pair] = _protocolAddress;\\n\\n        emit SetProtocolAddress(_pair, _protocolAddress);\\n    }\\n\\n    // set the government admins\\n    function setAdmins(\\n        address _usdfiMaker,\\n        address _feeAmountOwner,\\n        address _admin\\n    ) external {\\n        require(msg.sender == owner || msg.sender == admin);\\n        usdfiMaker = _usdfiMaker;\\n        feeAmountOwner = _feeAmountOwner;\\n        admin = _admin;\\n\\n        emit SetAdmins(_usdfiMaker, _feeAmountOwner, _admin);\\n    }\\n\\n    // return keccak256 creationCode\\n    function pairCodeHash() external pure returns (bytes32) {\\n        return keccak256(type(BasePair).creationCode);\\n    }\\n\\n    function getInitializable()\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            bool\\n        )\\n    {\\n        return (_temp0, _temp1, _temp);\\n    }\\n\\n    // create an new LP pair\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        bool stable\\n    ) external returns (address pair) {\\n        require(tokenA != tokenB, \\\"IA\\\"); // BaseV1: IDENTICAL_ADDRESSES\\n        (address token0, address token1) = tokenA \\u003c tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"ZA\\\"); // BaseV1: ZERO_ADDRESS\\n        require(getPair[token0][token1][stable] == address(0), \\\"PE\\\"); // BaseV1: PAIR_EXISTS - single check is sufficient\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable)); // notice salt includes stable as well, 3 parameters\\n        (_temp0, _temp1, _temp) = (token0, token1, stable);\\n        pair = address(new BasePair{salt: salt}());\\n        getPair[token0][token1][stable] = pair;\\n        getPair[token1][token0][stable] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        isPair[pair] = true;\\n        emit PairCreated(token0, token1, stable, pair, allPairs.length);\\n    }\\n}\\n\"},\"BaseFees.sol\":{\"content\":\"/**\\n * @title Base Fees\\n * @dev BaseFees.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nimport \\\"./BaseFactory.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IBaseFees.sol\\\";\\n\\n// Base V1 Fees contract is used as a 1:1 pair relationship to split out fees, this ensures that the curve does not need to be modified for LP shares\\ncontract BaseFees is IBaseFees {\\n    address internal immutable factory; // Factory that created the pairs\\n    address internal immutable pair; // The pair it is bonded to\\n    address internal immutable token0; // token0 of pair, saved locally and statically for gas optimization\\n    address internal immutable token1; // Token1 of pair, saved locally and statically for gas optimization\\n\\n    uint256 public protocolFee = 0;\\n    uint256 public usdfiMakerFee = 800;\\n    uint256 public lpOwnerFee = 200;\\n\\n    event feeAmountUpdated(\\n        uint256 prevProtocolFee,\\n        uint256 indexed protocolFee,\\n        uint256 prevUsdfiMakerFee,\\n        uint256 indexed usdfiMakerFee,\\n        uint256 prevLpOwnerFee,\\n        uint256 indexed lpOwnerFee\\n    );\\n\\n    constructor(\\n        address _token0,\\n        address _token1,\\n        address _factory\\n    ) {\\n        pair = msg.sender;\\n        factory = _factory;\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length \\u003e 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\n        );\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    // Allow the pair to transfer fees to users\\n    function claimFeesFor(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external returns (uint256 claimed0, uint256 claimed1) {\\n        require(msg.sender == pair);\\n        uint256 _divisor = 1000;\\n\\n        // send X% to protocol address if protocol address exists\\n        address protocolAddress = BaseFactory(factory).protocolAddresses(pair);\\n        if (protocolAddress != address(0x0) \\u0026\\u0026 protocolFee \\u003e 0) {\\n            if (amount0 \\u003e 0)\\n                _safeTransfer(\\n                    token0,\\n                    protocolAddress,\\n                    (amount0 * protocolFee) / _divisor\\n                );\\n            if (amount1 \\u003e 0)\\n                _safeTransfer(\\n                    token1,\\n                    protocolAddress,\\n                    (amount1 * protocolFee) / _divisor\\n                );\\n        }\\n\\n        // send X% to usdfiMaker\\n        address usdfiMaker = BaseFactory(factory).usdfiMaker();\\n        if (usdfiMaker != address(0x0)) {\\n            if (amount0 \\u003e 0)\\n                _safeTransfer(\\n                    token0,\\n                    usdfiMaker,\\n                    (amount0 * usdfiMakerFee) / _divisor\\n                );\\n            if (amount1 \\u003e 0)\\n                _safeTransfer(\\n                    token1,\\n                    usdfiMaker,\\n                    (amount1 * usdfiMakerFee) / _divisor\\n                );\\n        }\\n\\n        claimed0 = (amount0 * lpOwnerFee) / _divisor;\\n        claimed1 = (amount1 * lpOwnerFee) / _divisor;\\n\\n        // send the rest to owner of LP\\n        if (amount0 \\u003e 0) _safeTransfer(token0, recipient, claimed0);\\n        if (amount1 \\u003e 0) _safeTransfer(token1, recipient, claimed1);\\n    }\\n\\n    /**\\n     * @dev Updates the fees\\n     *\\n     * - updates the share of fees attributed to the given protocol\\n     * - updates the share of fees attributed to the given buyback protocol\\n     * - updates the share of fees attributed to the given lp owner\\n     *\\n     * Can only be called by the factory\\u0027s owner (feeAmountOwner)\\n     */\\n    function setFeeAmount(\\n        uint256 _protocolFee,\\n        uint256 _usdfiMakerFee,\\n        uint256 _lpOwnerFee\\n    ) external {\\n        require(\\n            msg.sender == BaseFactory(factory).feeAmountOwner() ||\\n                msg.sender == BaseFactory(factory).admin(),\\n            \\\"Pair: only factory\\u0027s feeAmountOwner or admin\\\"\\n        );\\n        require(\\n            _protocolFee + _usdfiMakerFee + _lpOwnerFee == 1000,\\n            \\\"Pair: not 100%\\\"\\n        );\\n        require(_usdfiMakerFee \\u003e= 10, \\\"Pair: need more then 1%\\\");\\n        require(_lpOwnerFee \\u003e= 10, \\\"Pair: need more then 1%\\\");\\n\\n        uint256 prevProtocolFee = protocolFee;\\n        protocolFee = _protocolFee;\\n\\n        uint256 prevUsdfiMakerFee = usdfiMakerFee;\\n        usdfiMakerFee = _usdfiMakerFee;\\n\\n        uint256 prevLpOwnerFee = lpOwnerFee;\\n        lpOwnerFee = _lpOwnerFee;\\n\\n        emit feeAmountUpdated(\\n            prevProtocolFee,\\n            protocolFee,\\n            prevUsdfiMakerFee,\\n            usdfiMakerFee,\\n            prevLpOwnerFee,\\n            lpOwnerFee\\n        );\\n    }\\n}\\n\"},\"BasePair.sol\":{\"content\":\"/**\\n * @title Base Pair\\n * @dev BasePair.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nimport \\\"./BaseFees.sol\\\";\\nimport \\\"./IBaseCallee.sol\\\";\\nimport \\\"./IBasePair.sol\\\";\\n\\n// The base pair of pools, either stable or volatile\\ncontract BasePair is IBasePair {\\n    string public name;\\n    string public symbol;\\n    uint8 public constant decimals = 18;\\n\\n    // Used to denote stable or volatile pair, immutable since construction happens in the initialize method for CREATE2 deterministic addresses\\n    bool public immutable stable;\\n    uint256 public fee;\\n\\n    uint256 public totalSupply = 0;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    uint256 internal chainid;\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;\\n\\n    address public immutable token0;\\n    address public immutable token1;\\n    address public immutable fees;\\n    address immutable factory;\\n\\n    // Structure to capture time period observations every 30 minutes, used for local oracles\\n    struct Observation {\\n        uint256 timestamp;\\n        uint256 reserve0Cumulative;\\n        uint256 reserve1Cumulative;\\n    }\\n\\n    // Capture oracle reading every 30 minutes\\n    uint256 constant periodSize = 1800;\\n\\n    Observation[] public observations;\\n\\n    uint256 internal immutable decimals0;\\n    uint256 internal immutable decimals1;\\n\\n    uint256 public reserve0;\\n    uint256 public reserve1;\\n    uint256 public blockTimestampLast;\\n\\n    uint256 public reserve0CumulativeLast;\\n    uint256 public reserve1CumulativeLast;\\n\\n    // index0 and index1 are used to accumulate fees, this is split out from normal trades to keep the swap \\\"clean\\\"\\n    // this further allows LP holders to easily claim fees for tokens they have/staked\\n    uint256 public index0 = 0;\\n    uint256 public index1 = 0;\\n\\n    // position assigned to each LP to track their current index0 \\u0026 index1 vs the global position\\n    mapping(address =\\u003e uint256) public supplyIndex0;\\n    mapping(address =\\u003e uint256) public supplyIndex1;\\n\\n    // tracks the amount of unclaimed, but claimable tokens off of fees for token0 and token1\\n    mapping(address =\\u003e uint256) public claimable0;\\n    mapping(address =\\u003e uint256) public claimable1;\\n\\n    event Fees(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint256 reserve0, uint256 reserve1);\\n    event Claim(address indexed recipient, uint256 amount0, uint256 amount1);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n    event SetFee(uint256 newFee);\\n    event Recovered(address token, uint256 amount);\\n\\n    modifier gasThrottle() {\\n        if (BaseFactory(factory).maxGasPrice() \\u003e 0) {\\n            require(\\n                tx.gasprice \\u003c= BaseFactory(factory).maxGasPrice(),\\n                \\\"gas is too high!\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    constructor() {\\n        factory = msg.sender;\\n        (address _token0, address _token1, bool _stable) = BaseFactory(\\n            msg.sender\\n        ).getInitializable();\\n        (token0, token1, stable) = (_token0, _token1, _stable);\\n        fees = address(new BaseFees(_token0, _token1, factory));\\n        if (_stable) {\\n            name = string(\\n                abi.encodePacked(\\n                    \\\"USDFI.com Stable AMM - \\\",\\n                    IERC20(_token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC20(_token1).symbol()\\n                )\\n            );\\n            symbol = string(\\n                abi.encodePacked(\\n                    \\\"sAMM-\\\",\\n                    IERC20(_token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC20(_token1).symbol()\\n                )\\n            );\\n            fee = BaseFactory(factory).baseStableFee();\\n        } else {\\n            name = string(\\n                abi.encodePacked(\\n                    \\\"USDFI.com Volatile AMM - \\\",\\n                    IERC20(_token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC20(_token1).symbol()\\n                )\\n            );\\n            symbol = string(\\n                abi.encodePacked(\\n                    \\\"vAMM-\\\",\\n                    IERC20(_token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC20(_token1).symbol()\\n                )\\n            );\\n            fee = BaseFactory(factory).baseVariableFee();\\n        }\\n\\n        decimals0 = 10**IERC20(_token0).decimals();\\n        decimals1 = 10**IERC20(_token1).decimals();\\n\\n        observations.push(Observation(block.timestamp, 0, 0));\\n    }\\n\\n    // simple re-entrancy check\\n    uint256 internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function observationLength() external view returns (uint256) {\\n        return observations.length;\\n    }\\n\\n    function lastObservation() public view returns (Observation memory) {\\n        return observations[observations.length - 1];\\n    }\\n\\n    function metadata()\\n        external\\n        view\\n        returns (\\n            uint256 dec0,\\n            uint256 dec1,\\n            uint256 r0,\\n            uint256 r1,\\n            bool st,\\n            address t0,\\n            address t1\\n        )\\n    {\\n        return (\\n            decimals0,\\n            decimals1,\\n            reserve0,\\n            reserve1,\\n            stable,\\n            token0,\\n            token1\\n        );\\n    }\\n\\n    function tokens() external view returns (address, address) {\\n        return (token0, token1);\\n    }\\n\\n    function usdfiMaker() external view returns (address) {\\n        return BaseFactory(factory).usdfiMaker();\\n    }\\n\\n    function protocol() external view returns (address) {\\n        return BaseFactory(factory).protocolAddresses(address(this));\\n    }\\n\\n    // claim accumulated but unclaimed fees (viewable via claimable0 and claimable1)\\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1) {\\n        _updateFor(msg.sender);\\n\\n        claimed0 = claimable0[msg.sender];\\n        claimed1 = claimable1[msg.sender];\\n\\n        if (claimed0 \\u003e 0 || claimed1 \\u003e 0) {\\n            claimable0[msg.sender] = 0;\\n            claimable1[msg.sender] = 0;\\n\\n            (claimed0, claimed1) = BaseFees(fees).claimFeesFor(\\n                msg.sender,\\n                claimed0,\\n                claimed1\\n            );\\n\\n            emit Claim(msg.sender, claimed0, claimed1);\\n        }\\n    }\\n\\n    // Accrue fees on token0\\n    function _update0(uint256 amount) internal {\\n        _safeTransfer(token0, fees, amount); // transfer the fees out to BaseV1Fees\\n        uint256 _ratio = (amount * 1e18) / totalSupply; // 1e18 adjustment is removed during claim\\n        if (_ratio \\u003e 0) {\\n            index0 += _ratio;\\n        }\\n        emit Fees(msg.sender, amount, 0);\\n    }\\n\\n    // Accrue fees on token1\\n    function _update1(uint256 amount) internal {\\n        _safeTransfer(token1, fees, amount);\\n        uint256 _ratio = (amount * 1e18) / totalSupply;\\n        if (_ratio \\u003e 0) {\\n            index1 += _ratio;\\n        }\\n        emit Fees(msg.sender, 0, amount);\\n    }\\n\\n    // this function MUST be called on any balance changes, otherwise can be used to infinitely claim fees\\n    // Fees are segregated from core funds, so fees can never put liquidity at risk\\n    function _updateFor(address recipient) internal {\\n        uint256 _supplied = balanceOf[recipient]; // get LP balance of `recipient`\\n        if (_supplied \\u003e 0) {\\n            uint256 _supplyIndex0 = supplyIndex0[recipient]; // get last adjusted index0 for recipient\\n            uint256 _supplyIndex1 = supplyIndex1[recipient];\\n            uint256 _index0 = index0; // get global index0 for accumulated fees\\n            uint256 _index1 = index1;\\n            supplyIndex0[recipient] = _index0; // update user current position to global position\\n            supplyIndex1[recipient] = _index1;\\n            uint256 _delta0 = _index0 - _supplyIndex0; // see if there is any difference that need to be accrued\\n            uint256 _delta1 = _index1 - _supplyIndex1;\\n            if (_delta0 \\u003e 0) {\\n                uint256 _share = (_supplied * _delta0) / 1e18; // add accrued difference for each supplied token\\n                claimable0[recipient] += _share;\\n            }\\n            if (_delta1 \\u003e 0) {\\n                uint256 _share = (_supplied * _delta1) / 1e18;\\n                claimable1[recipient] += _share;\\n            }\\n        } else {\\n            supplyIndex0[recipient] = index0; // new users are set to the default global state\\n            supplyIndex1[recipient] = index1;\\n        }\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        returns (\\n            uint256 _reserve0,\\n            uint256 _reserve1,\\n            uint256 _blockTimestampLast\\n        )\\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint256 balance0,\\n        uint256 balance1,\\n        uint256 _reserve0,\\n        uint256 _reserve1\\n    ) internal {\\n        uint256 blockTimestamp = block.timestamp;\\n        uint256 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed \\u003e 0 \\u0026\\u0026 _reserve0 != 0 \\u0026\\u0026 _reserve1 != 0) {\\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\\n        }\\n\\n        Observation memory _point = lastObservation();\\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\\n        if (timeElapsed \\u003e periodSize) {\\n            observations.push(\\n                Observation(\\n                    blockTimestamp,\\n                    reserve0CumulativeLast,\\n                    reserve1CumulativeLast\\n                )\\n            );\\n        }\\n        reserve0 = balance0;\\n        reserve1 = balance1;\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices()\\n        public\\n        view\\n        returns (\\n            uint256 reserve0Cumulative,\\n            uint256 reserve1Cumulative,\\n            uint256 blockTimestamp\\n        )\\n    {\\n        blockTimestamp = block.timestamp;\\n        reserve0Cumulative = reserve0CumulativeLast;\\n        reserve1Cumulative = reserve1CumulativeLast;\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (\\n            uint256 _reserve0,\\n            uint256 _reserve1,\\n            uint256 _blockTimestampLast\\n        ) = getReserves();\\n        if (_blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint256 timeElapsed = blockTimestamp - _blockTimestampLast;\\n            reserve0Cumulative += _reserve0 * timeElapsed;\\n            reserve1Cumulative += _reserve1 * timeElapsed;\\n        }\\n    }\\n\\n    // gives the current twap price measured from amountIn * tokenIn gives amountOut\\n    function current(address tokenIn, uint256 amountIn)\\n        external\\n        view\\n        returns (uint256 amountOut)\\n    {\\n        Observation memory _observation = lastObservation();\\n        (\\n            uint256 reserve0Cumulative,\\n            uint256 reserve1Cumulative,\\n\\n        ) = currentCumulativePrices();\\n        if (block.timestamp == _observation.timestamp) {\\n            _observation = observations[observations.length - 2];\\n        }\\n\\n        uint256 timeElapsed = block.timestamp - _observation.timestamp;\\n        uint256 _reserve0 = (reserve0Cumulative -\\n            _observation.reserve0Cumulative) / timeElapsed;\\n        uint256 _reserve1 = (reserve1Cumulative -\\n            _observation.reserve1Cumulative) / timeElapsed;\\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\\n    }\\n\\n    // as per `current`, however allows user configured granularity, up to the full window size\\n    function quote(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 granularity\\n    ) external view returns (uint256 amountOut) {\\n        uint256[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\\n        uint256 priceAverageCumulative;\\n        for (uint256 i = 0; i \\u003c _prices.length; i++) {\\n            priceAverageCumulative += _prices[i];\\n        }\\n        return priceAverageCumulative / granularity;\\n    }\\n\\n    // returns a memory set of twap prices\\n    function prices(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points\\n    ) external view returns (uint256[] memory) {\\n        return sample(tokenIn, amountIn, points, 1);\\n    }\\n\\n    function sample(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points,\\n        uint256 window\\n    ) public view returns (uint256[] memory) {\\n        uint256[] memory _prices = new uint256[](points);\\n\\n        uint256 length = observations.length - 1;\\n        uint256 i = length - (points * window);\\n        uint256 nextIndex = 0;\\n        uint256 index = 0;\\n\\n        for (; i \\u003c length; i += window) {\\n            nextIndex = i + window;\\n            uint256 timeElapsed = observations[nextIndex].timestamp -\\n                observations[i].timestamp;\\n            uint256 _reserve0 = (observations[nextIndex].reserve0Cumulative -\\n                observations[i].reserve0Cumulative) / timeElapsed;\\n            uint256 _reserve1 = (observations[nextIndex].reserve1Cumulative -\\n                observations[i].reserve1Cumulative) / timeElapsed;\\n            _prices[index] = _getAmountOut(\\n                amountIn,\\n                tokenIn,\\n                _reserve0,\\n                _reserve1\\n            );\\n            index = index + 1;\\n        }\\n        return _prices;\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    // standard uniswap v2 implementation\\n    function mint(address to) external lock returns (uint256 liquidity) {\\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\\n        uint256 _amount0 = _balance0 - _reserve0;\\n        uint256 _amount1 = _balance1 - _reserve1;\\n\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidity = Math.min(\\n                (_amount0 * _totalSupply) / _reserve0,\\n                (_amount1 * _totalSupply) / _reserve1\\n            );\\n        }\\n        require(liquidity \\u003e 0, \\\"ILM\\\"); // BaseV1: INSUFFICIENT_LIQUIDITY_MINTED\\n        _mint(to, liquidity);\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Mint(msg.sender, _amount0, _amount1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    // standard uniswap v2 implementation\\n    function burn(address to)\\n        external\\n        lock\\n        returns (uint256 amount0, uint256 amount1)\\n    {\\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\\n        (address _token0, address _token1) = (token0, token1);\\n        uint256 _balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 _balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint256 _liquidity = balanceOf[address(this)];\\n\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = (_liquidity * _balance0) / _totalSupply; // using balances ensures proportionate distribution\\n        amount1 = (_liquidity * _balance1) / _totalSupply; // using balances ensures proportionate distribution\\n        require(amount0 \\u003e 0 \\u0026\\u0026 amount1 \\u003e 0, \\\"ILB\\\"); // BaseV1: INSUFFICIENT_LIQUIDITY_BURNED\\n        _burn(address(this), _liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        _balance0 = IERC20(_token0).balanceOf(address(this));\\n        _balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external lock gasThrottle {\\n        require(!BaseFactory(factory).isPaused());\\n        require(amount0Out \\u003e 0 || amount1Out \\u003e 0, \\\"IOA\\\"); // BaseV1: INSUFFICIENT_OUTPUT_AMOUNT\\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\\n        require(amount0Out \\u003c _reserve0 \\u0026\\u0026 amount1Out \\u003c _reserve1, \\\"IL\\\"); // BaseV1: INSUFFICIENT_LIQUIDITY\\n\\n        uint256 _balance0;\\n        uint256 _balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            (address _token0, address _token1) = (token0, token1);\\n            require(to != _token0 \\u0026\\u0026 to != _token1, \\\"IT\\\"); // BaseV1: INVALID_TO\\n            if (amount0Out \\u003e 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out \\u003e 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n            if (data.length \\u003e 0)\\n                IBaseCallee(to).hook(msg.sender, amount0Out, amount1Out, data); // callback, used for flash loans\\n            _balance0 = IERC20(_token0).balanceOf(address(this));\\n            _balance1 = IERC20(_token1).balanceOf(address(this));\\n        }\\n        uint256 amount0In = _balance0 \\u003e _reserve0 - amount0Out\\n            ? _balance0 - (_reserve0 - amount0Out)\\n            : 0;\\n        uint256 amount1In = _balance1 \\u003e _reserve1 - amount1Out\\n            ? _balance1 - (_reserve1 - amount1Out)\\n            : 0;\\n        require(amount0In \\u003e 0 || amount1In \\u003e 0, \\\"IIA\\\"); // BaseV1: INSUFFICIENT_INPUT_AMOUNT\\n        {\\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n            (address _token0, address _token1) = (token0, token1);\\n\\n            if (amount0In \\u003e 0) _update0(amount0In / fee); // accrue fees for token0 and move them out of pool\\n            if (amount1In \\u003e 0) _update1(amount1In / fee); // accrue fees for token1 and move them out of pool\\n\\n            _balance0 = IERC20(_token0).balanceOf(address(this)); // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\\n            _balance1 = IERC20(_token1).balanceOf(address(this));\\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\\n            require(_k(_balance0, _balance1) \\u003e= _k(_reserve0, _reserve1), \\\"K\\\"); // BaseV1: K\\n        }\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external lock {\\n        (address _token0, address _token1) = (token0, token1);\\n        _safeTransfer(\\n            _token0,\\n            to,\\n            IERC20(_token0).balanceOf(address(this)) - (reserve0)\\n        );\\n        _safeTransfer(\\n            _token1,\\n            to,\\n            IERC20(_token1).balanceOf(address(this)) - (reserve1)\\n        );\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        _update(\\n            IERC20(token0).balanceOf(address(this)),\\n            IERC20(token1).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\\n        return\\n            (x0 * ((((y * y) / 1e18) * y) / 1e18)) /\\n            1e18 +\\n            (((((x0 * x0) / 1e18) * x0) / 1e18) * y) /\\n            1e18;\\n    }\\n\\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\\n        return\\n            (3 * x0 * ((y * y) / 1e18)) /\\n            1e18 +\\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\\n    }\\n\\n    function _get_y(\\n        uint256 x0,\\n        uint256 xy,\\n        uint256 y\\n    ) internal pure returns (uint256) {\\n        for (uint256 i = 0; i \\u003c 255; i++) {\\n            uint256 y_prev = y;\\n            uint256 k = _f(x0, y);\\n            if (k \\u003c xy) {\\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\\n                y = y + dy;\\n            } else {\\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\\n                y = y - dy;\\n            }\\n            if (y \\u003e y_prev) {\\n                if (y - y_prev \\u003c= 1) {\\n                    return y;\\n                }\\n            } else {\\n                if (y_prev - y \\u003c= 1) {\\n                    return y;\\n                }\\n            }\\n        }\\n        return y;\\n    }\\n\\n    function getAmountOut(uint256 amountIn, address tokenIn)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\\n        amountIn -= amountIn / fee; // remove fee from amount received\\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\\n    }\\n\\n    function _getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        uint256 _reserve0,\\n        uint256 _reserve1\\n    ) internal view returns (uint256) {\\n        if (stable) {\\n            uint256 xy = _k(_reserve0, _reserve1);\\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\\n                ? (_reserve0, _reserve1)\\n                : (_reserve1, _reserve0);\\n            amountIn = tokenIn == token0\\n                ? (amountIn * 1e18) / decimals0\\n                : (amountIn * 1e18) / decimals1;\\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\\n        } else {\\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\\n                ? (_reserve0, _reserve1)\\n                : (_reserve1, _reserve0);\\n            return (amountIn * reserveB) / (reserveA + amountIn);\\n        }\\n    }\\n\\n    function _k(uint256 x, uint256 y) internal view returns (uint256) {\\n        if (stable) {\\n            uint256 _x = (x * 1e18) / decimals0;\\n            uint256 _y = (y * 1e18) / decimals1;\\n            uint256 _a = (_x * _y) / 1e18;\\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\\n            return (_a * _b) / 1e18; // x3y+y3x \\u003e= k\\n        } else {\\n            return x * y; // xy \\u003e= k\\n        }\\n    }\\n\\n    function _mint(address dst, uint256 amount) internal {\\n        _updateFor(dst); // balances must be updated on mint/burn/transfer\\n        totalSupply += amount;\\n        balanceOf[dst] += amount;\\n        emit Transfer(address(0), dst, amount);\\n    }\\n\\n    function _burn(address dst, uint256 amount) internal {\\n        _updateFor(dst);\\n        totalSupply -= amount;\\n        balanceOf[dst] -= amount;\\n        emit Transfer(dst, address(0), amount);\\n    }\\n\\n    function approve(address spender, uint256 amount) external returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline \\u003e= block.timestamp, \\\"BaseV1: EXPIRED\\\");\\n        if (chainid != block.chainid) {\\n            DOMAIN_SEPARATOR = keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                    ),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n            chainid == block.chainid;\\n        }\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner,\\n            \\\"BaseV1: INVALID_SIGNATURE\\\"\\n        );\\n        allowance[owner][spender] = value;\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function transfer(address dst, uint256 amount) external returns (bool) {\\n        _transferTokens(msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external returns (bool) {\\n        address spender = msg.sender;\\n        uint256 spenderAllowance = allowance[src][spender];\\n\\n        if (spender != src \\u0026\\u0026 spenderAllowance != type(uint256).max) {\\n            uint256 newAllowance = spenderAllowance - amount;\\n            allowance[src][spender] = newAllowance;\\n\\n            emit Approval(src, spender, newAllowance);\\n        }\\n\\n        _transferTokens(src, dst, amount);\\n        return true;\\n    }\\n\\n    function _transferTokens(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) internal {\\n        _updateFor(src); // update fee position for src\\n        _updateFor(dst); // update fee position for dst\\n\\n        balanceOf[src] -= amount;\\n        balanceOf[dst] += amount;\\n\\n        emit Transfer(src, dst, amount);\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length \\u003e 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\n        );\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    // set a new fee for the LP\\n    // 10 max fees for LPs (10%)\\n    // 10000 min fees for LPs (0.01%)\\n    function setFee(uint256 _fee) external {\\n        require(\\n            msg.sender == BaseFactory(factory).feeAmountOwner() ||\\n                msg.sender == BaseFactory(factory).admin(),\\n            \\\"Pair: only factory\\u0027s feeAmountOwner or admin\\\"\\n        );\\n        require(_fee \\u003e= 10 \\u0026\\u0026 _fee \\u003c= 10000, \\\"!range\\\");\\n        fee = _fee;\\n        emit SetFee(fee);\\n    }\\n}\\n\"},\"IBaseCallee.sol\":{\"content\":\"/**\\n * @title Interface Base Callee\\n * @dev IBaseCallee.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IBaseCallee {\\n    function hook(\\n        address sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n}\\n\"},\"IBaseFactory.sol\":{\"content\":\"/**\\n * @title Interface Base Factory\\n * @dev IBaseFactory.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IBaseFactory {\\n    function isPaused() external view returns (bool);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function admin() external view returns (address);\\n\\n    function feeAmountOwner() external view returns (address);\\n\\n    function baseStableFee() external view returns (uint256);\\n\\n    function baseVariableFee() external view returns (uint256);\\n\\n    function getPair(\\n        address token0,\\n        address token1,\\n        bool stable\\n    ) external view returns (address);\\n\\n    function allPairs(uint256 id) external view returns (address);\\n\\n    function isPair(address pair) external view returns (bool);\\n\\n    function protocolAddresses(address pair) external view returns (address);\\n\\n    function usdfiMaker() external view returns (address);\\n\\n    function maxGasPrice() external view returns (uint256);\\n\\n    function setBaseVariableFee(uint256 fee) external;\\n\\n    function setMaxGasPrice(uint256 gas) external;\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function setOwner(address owner) external;\\n\\n    function acceptOwner() external;\\n\\n    function setPause(bool state) external;\\n\\n    function setProtocolAddress(address pair, address protocolAddress) external;\\n\\n    function setAdmins(\\n        address usdfiMaker,\\n        address feeAmountOwner,\\n        address admin\\n    ) external;\\n\\n    function pairCodeHash() external pure returns (bytes32);\\n\\n    function getInitializable()\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            bool\\n        );\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        bool stable\\n    ) external returns (address pair);\\n}\\n\"},\"IBaseFees.sol\":{\"content\":\"/**\\n * @title Interface Base Fees\\n * @dev IBaseFees.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IBaseFees {\\n    function protocolFee() external view returns (uint256);\\n\\n    function usdfiMakerFee() external view returns (uint256);\\n\\n    function lpOwnerFee() external view returns (uint256);\\n\\n    function claimFeesFor(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external returns (uint256 claimed0, uint256 claimed1);\\n\\n    function setFeeAmount(\\n        uint256 protocolFee,\\n        uint256 usdfiMakerFee,\\n        uint256 lpOwnerFee\\n    ) external;\\n}\\n\"},\"IBasePair.sol\":{\"content\":\"/**\\n * @title Interface Base Pair\\n * @dev IBasePair.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IBasePair {\\n    function name() external view returns (string calldata);\\n\\n    function symbol() external view returns (string calldata);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function stable() external view returns (bool);\\n\\n    function fee() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function fees() external view returns (address);\\n\\n    function reserve0() external view returns (uint256);\\n\\n    function reserve1() external view returns (uint256);\\n\\n    function blockTimestampLast() external view returns (uint256);\\n\\n    function reserve0CumulativeLast() external view returns (uint256);\\n\\n    function reserve1CumulativeLast() external view returns (uint256);\\n\\n    function index0() external view returns (uint256);\\n\\n    function index1() external view returns (uint256);\\n\\n    function supplyIndex0(address owner) external view returns (uint256);\\n\\n    function supplyIndex1(address owner) external view returns (uint256);\\n\\n    function claimable0(address owner) external view returns (uint256);\\n\\n    function claimable1(address owner) external view returns (uint256);\\n\\n    function observationLength() external view returns (uint256);\\n\\n    function metadata()\\n        external\\n        view\\n        returns (\\n            uint256 decimals0,\\n            uint256 decimals1,\\n            uint256 reserve0,\\n            uint256 reserve1,\\n            bool stable,\\n            address token0,\\n            address token1\\n        );\\n\\n    function tokens() external view returns (address, address);\\n\\n    function usdfiMaker() external view returns (address);\\n\\n    function protocol() external view returns (address);\\n\\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint256 reserve0,\\n            uint256 reserve1,\\n            uint256 blockTimestampLast\\n        );\\n\\n    function currentCumulativePrices()\\n        external\\n        view\\n        returns (\\n            uint256 reserve0Cumulative,\\n            uint256 reserve1Cumulative,\\n            uint256 blockTimestamp\\n        );\\n\\n    function current(address tokenIn, uint256 amountIn)\\n        external\\n        view\\n        returns (uint256 amountOut);\\n\\n    function quote(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 granularity\\n    ) external view returns (uint256 amountOut);\\n\\n    function prices(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points\\n    ) external view returns (uint256[] memory);\\n\\n    function sample(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points,\\n        uint256 window\\n    ) external view returns (uint256[] memory);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to)\\n        external\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function getAmountOut(uint256 amountIn, address tokenIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function setFee(uint256 fee) external;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"/**\\n * @title Interface ERC20\\n * @dev IERC20.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n}\\n\"},\"Math.sol\":{\"content\":\"/**\\n * @title Math\\n * @dev Math.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nlibrary Math {\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimable0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimable1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"current\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentCumulativePrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestampLast\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"index0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"index1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastObservation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Cumulative\",\"type\":\"uint256\"}],\"internalType\":\"struct BasePair.Observation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dec0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dec1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"r0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"r1\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"st\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"t0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t1\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"observationLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"observations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Cumulative\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"granularity\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"name\":\"sample\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyIndex0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyIndex1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdfiMaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BasePair", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "120", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a7b8680b7ab5ef6db759cd9824aa28a97c380361c98b7c2bca1ba2efc5edbf81"}