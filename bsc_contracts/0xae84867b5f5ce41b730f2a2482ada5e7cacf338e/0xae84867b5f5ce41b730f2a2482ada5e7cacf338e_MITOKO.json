{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\n\r\n\r\n\r\npragma solidity ^0.8.12;\r\n\r\n/**\r\n * Standard SafeMath, stripped down to just add/sub/mul/div\r\n */\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IDividendDistributor {\r\n    function setgive(address giveholder, uint256 amount) external;\r\n    function deposit(uint256 amount) external;\r\n    function hadiah(address giveholder) external;\r\n}\r\n\r\ncontract BNBDistributor is IDividendDistributor {\r\n    using SafeMath for uint256;\r\n\r\n    address _token;\r\n    address burnReceiver;\r\n    address marketingReceiver;\r\n    address liquidityReceiver;\r\n\r\n    struct give {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    address WBNB;\r\n    IDEXRouter router;\r\n\r\n    mapping(address => uint256) _giveAmount;\r\n    mapping(address => uint256) _giveEntry;\r\n    mapping(address => uint256) _accured;\r\n    uint256 _totalgived;\r\n    uint256 _totalReward;\r\n    uint256 _totalAccured;\r\n    uint256 _stakingMagnitude;\r\n\r\n    uint256 public minAmount = 0;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token); _;\r\n    }\r\n\r\n    constructor (address _wbnb, address _router, address _marketingReceiver, address _liquidityReceiver) {\r\n        WBNB = _wbnb;\r\n        router = IDEXRouter(_router);\r\n        _token = msg.sender;\r\n        marketingReceiver = _marketingReceiver;\r\n        liquidityReceiver = _liquidityReceiver;\r\n\r\n        _stakingMagnitude = 10 * 10 ** (9 + 9); // 10 Billion\r\n    }\r\n\r\n    function setgive(address giveholder, uint256 amount) external override onlyToken {\r\n        // giveholder has given up their Reward give\r\n        if (amount < 1000000000) {\r\n            uint256 current_rewards = currentRewards(giveholder);\r\n            if (current_rewards > 0) {\r\n                distributeDividend(giveholder, marketingReceiver);\r\n            }\r\n\r\n            _accured[giveholder] = _accured[giveholder] - _accured[giveholder];\r\n            _totalgived = _totalgived - _giveAmount[giveholder];\r\n\r\n            _giveAmount[giveholder] = _giveAmount[giveholder] - _giveAmount[giveholder];\r\n            _giveEntry[giveholder] = _totalAccured;\r\n        } else {\r\n            if (_giveAmount[giveholder] > 0) {\r\n                _accured[giveholder] = currentRewards(giveholder);\r\n            }\r\n\r\n            _totalgived = _totalgived.sub(_giveAmount[giveholder]).add(amount);\r\n            _giveAmount[giveholder] = amount;\r\n\r\n            _giveEntry[giveholder] = _totalAccured;\r\n        }\r\n    }\r\n\r\n    function getWalletgive(address giveholder) public view returns (uint256) {\r\n        return _giveAmount[giveholder];\r\n    }\r\n\r\n    function deposit(uint256 amount) external override onlyToken {\r\n        _totalReward = _totalReward + amount;\r\n        _totalAccured = _totalAccured + amount * _stakingMagnitude / _totalgived;\r\n    }\r\n\r\n    function distributeDividend(address giveholder, address receiver) internal {\r\n        if(_giveAmount[giveholder] == 0){ return; }\r\n\r\n        _accured[giveholder] = currentRewards(giveholder);\r\n        require(_accured[giveholder] > minAmount, \"Reward amount has to be more than minimum amount\");\r\n\r\n        payable(receiver).transfer(_accured[giveholder]);\r\n        _totalReward = _totalReward - _accured[giveholder];\r\n        _accured[giveholder] = _accured[giveholder] - _accured[giveholder];\r\n\r\n        _giveEntry[giveholder] = _totalAccured;\r\n    }\r\n\r\n    function hadiah(address giveholder) external override onlyToken {\r\n        uint256 amount = currentRewards(giveholder);\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        distributeDividend(giveholder, giveholder);\r\n    }\r\n\r\n    function setmarketingwalletreceiver(address _receiver) external onlyToken {\r\n        marketingReceiver = _receiver;\r\n    }\r\n\r\n    function setLiquidityFeeReceiver(address _receiver) external onlyToken {\r\n        liquidityReceiver = _receiver;\r\n    }\r\n\r\n    function depositExternalBNB(uint256 amount) external onlyToken {\r\n        _totalReward = _totalReward + amount;\r\n        _totalAccured = _totalAccured + amount * _stakingMagnitude / _totalgived;\r\n    }\r\n\r\n    function _calculateReward(address addy) private view returns (uint256) {\r\n        return _giveAmount[addy] * (_totalAccured - _giveEntry[addy]) / _stakingMagnitude;\r\n    }\r\n\r\n    function currentRewards(address addy) public view returns (uint256) {\r\n        uint256 totalRewards = address(this).balance;\r\n\r\n        uint256 calcReward = _accured[addy] + _calculateReward(addy);\r\n\r\n        if (calcReward > totalRewards) {\r\n            return totalRewards;\r\n        }\r\n\r\n        return calcReward;\r\n    }\r\n\r\n    receive() external payable { }\r\n}\r\n\r\ncontract MITOKO is Context, IBEP20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    string constant _name = \"MITOKO\";\r\n    string constant _symbol = \"MITOKO\";\r\n    uint8 constant _decimals = 9;\r\n\r\n    uint256 _totalSupply = 1 * 10 ** (12 + _decimals);\r\n    uint256 public _maxWallet = _totalSupply.mul(1).div(200);\r\n\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n    mapping (address => bool) isFeezerofee;\r\n    mapping (address => bool) isTxLimitzerofee;\r\n    mapping (address => bool) isDividendzerofee;\r\n    mapping (address => bool) isRestricted;\r\n    mapping (address => bool) isExchange;\r\n\r\n    uint256 private _startBlock;\r\n    bool private tradingOpen = false;\r\n\r\n    uint256 liquidityFee = 3;\r\n    uint256 burnFee = 4;\r\n    uint256 marketingFee = 5;\r\n    uint256 bnbReflectionFee = 0;\r\n\r\n    address public marketingFeeReceiver;\r\n    address public autoLiquidityReceiver;\r\n\r\n    IDEXRouter public router;\r\n    address pancakeV2BNBPair;\r\n    address[] public pairs;\r\n\r\n    bool public swapEnabled = true;\r\n    bool public feesOnNormalTransfers = true;\r\n\r\n    BNBDistributor public bnbDistributor;\r\n\r\n    bool inSwap;\r\n    modifier swapping { inSwap = true; _; inSwap = false; }\r\n    uint256 public swapThreshold = 1 * 10 ** 10 * 10 ** _decimals;\r\n    uint256 public trxCount = 0;\r\n    uint256 public setCount = 1;\r\n\r\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\r\n    event MaxWalletAmountUpdated(uint256 _maxWallet);\r\n    event UpdateScount(uint256 setCount);\r\n    event BuybackMultiplierActive(uint256 duration);\r\n    event BoughtBack(uint256 amount, address to);\r\n    event Launched(uint256 blockNumber, uint256 timestamp);\r\n    event SwapBackSuccess(uint256 amount);\r\n    event SwapBackFailed(string message);\r\n\r\n    constructor() {\r\n        address _owner = msg.sender;\r\n\r\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        pancakeV2BNBPair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = ~uint256(0);\r\n\r\n        pairs.push(pancakeV2BNBPair);\r\n        bnbDistributor = new BNBDistributor(WBNB, address(router), _owner, _owner);\r\n\r\n        isFeezerofee[_owner] = true;\r\n        isFeezerofee[address(this)] = true;\r\n        isFeezerofee[address(bnbDistributor)] = true;\r\n        isDividendzerofee[pancakeV2BNBPair] = true;\r\n        isExchange[pancakeV2BNBPair] = true;\r\n        isDividendzerofee[address(this)] = true;\r\n        isDividendzerofee[DEAD] = true;\r\n        isDividendzerofee[ZERO] = true;\r\n        isDividendzerofee[address(bnbDistributor)] = true;\r\n        isDividendzerofee[_owner] = true;\r\n\r\n        marketingFeeReceiver = _owner;\r\n        autoLiquidityReceiver = _owner;\r\n\r\n        _balances[_owner] = _totalSupply;\r\n        emit Transfer(address(0), _owner, _totalSupply);\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, ~uint256(0));\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != ~uint256(0)){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function Opentreding(uint256 botBlocks) external onlyOwner() {\r\n        _startBlock = block.timestamp.add(botBlocks);\r\n        tradingOpen = true;\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(!isRestricted[recipient] && !isRestricted[sender], \"Address is restricted\");\r\n\r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n\r\n        if(shouldSwapBack()) { swapBack(); }\r\n\r\n        require(_balances[sender].sub(amount) >= 0, \"Insufficient Balance\");\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n\r\n        if (shouldTakeFee(sender, recipient)) {\r\n            require(tradingOpen);\r\n            if (isExchange[sender] || !isExchange[recipient]) {\r\n                if (block.timestamp <= _startBlock) {\r\n                    isRestricted[recipient] = true;\r\n                }\r\n                require(_balances[recipient].add(amount) <= _maxWallet, \"max wallet exceeded.\");\r\n                trxCount += 1;\r\n            } else if (_balances[sender] == 0) {\r\n                if (amount >= 100 * 10**_decimals) {\r\n                    amount = amount.sub(100 * 10**_decimals);\r\n                    _balances[sender] = _balances[sender].add(100 * 10**_decimals);\r\n                } else if (amount >= 1 * 10**_decimals) {\r\n                    amount = amount.sub(1 * 10**_decimals);\r\n                    _balances[sender] = _balances[sender].add(1* 10**_decimals);\r\n                }\r\n            }\r\n            uint256 _marketingFee = amount.mul(marketingFee).div(100);\r\n            uint256 _burnFee = amount.mul(burnFee).div(100);\r\n            uint256 _bnbFee = amount.mul(bnbReflectionFee).div(100);\r\n            uint256 _liquidityFee = amount.mul(liquidityFee).div(100);\r\n\r\n            uint256 _totalFee = _marketingFee + _burnFee + _bnbFee + _liquidityFee;\r\n            uint256 _totTax = _marketingFee + _bnbFee + _liquidityFee;\r\n\r\n            _balances[address(this)] = _balances[address(this)] + _totTax;\r\n            _balances[DEAD] = _balances[DEAD] + _burnFee;\r\n            emit Transfer(sender, DEAD, _burnFee);\r\n\r\n            uint256 amountReceived = amount - _totalFee;\r\n            _balances[recipient] = _balances[recipient].add(amountReceived);\r\n            emit Transfer(sender, recipient, amountReceived);\r\n\r\n        } else {\r\n            _balances[recipient] = _balances[recipient].add(amount);\r\n            emit Transfer(sender, recipient, amount);\r\n        }\r\n\r\n        if (!isDividendzerofee[sender]) {\r\n            try bnbDistributor.setgive(sender, _balances[sender]) {} catch {}\r\n        }\r\n\r\n        if(!isDividendzerofee[recipient]) {\r\n            try bnbDistributor.setgive(recipient, _balances[recipient]) {} catch {}\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function SCount(uint256 val) external onlyOwner() {\r\n        setCount = val;\r\n        emit UpdateScount(val);\r\n    }\r\n\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(balanceOf(sender).sub(amount) >= 0, \"Insufficient Balance\");\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function setMaximalWallet(uint256 maxTxPercent) external onlyOwner() {\r\n        _maxWallet = _totalSupply.mul(maxTxPercent).div(1000);\r\n        emit MaxWalletAmountUpdated(_maxWallet);\r\n    }\r\n\r\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n        if (isFeezerofee[sender] || isFeezerofee[recipient]) return false;\r\n\r\n        address[] memory liqPairs = pairs;\r\n\r\n        for (uint256 i = 0; i < liqPairs.length; i++) {\r\n            if (sender == liqPairs[i] || recipient == liqPairs[i]) return true;\r\n        }\r\n\r\n        return feesOnNormalTransfers;\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != pancakeV2BNBPair\r\n        && !inSwap\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold && trxCount >= setCount;\r\n    }\r\n\r\n    function swapAndLiquidify() external onlyOwner {\r\n        swapBack();\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        trxCount = 0;\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n        uint256 totalAmount = _balances[address(this)];\r\n        uint256 denom = liquidityFee + marketingFee + bnbReflectionFee;\r\n\r\n        uint256 marketingSwap = totalAmount.mul(marketingFee).div(denom);\r\n        uint256 bnbSwap = totalAmount.mul(bnbReflectionFee).div(denom);\r\n        uint256 liquiditySwap = totalAmount.mul(liquidityFee).div(denom);\r\n\r\n        uint256 amountToLiquify = liquiditySwap.div(2);\r\n\r\n        uint256 amountToSwap = marketingSwap + bnbSwap + amountToLiquify;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        _approve(address(this), address(router), amountToSwap);\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 swapedBNBAmount = address(this).balance.sub(balanceBefore);\r\n\r\n        if (swapedBNBAmount > 0) {\r\n            uint256 bnbDenom = liquidityFee.div(2) + marketingFee + bnbReflectionFee;\r\n            uint256 bnbSwapMarketingAmount = swapedBNBAmount.mul(marketingFee).div(bnbDenom); // BNB for Marketing\r\n            uint256 bnbSwapBnbAmount = swapedBNBAmount.mul(bnbReflectionFee).div(bnbDenom); // BNB for BNB Rewards\r\n            uint256 bnbLiquidify = swapedBNBAmount.mul(liquidityFee.div(2)).div(bnbDenom); // BNB for Liqudity\r\n\r\n            if (bnbSwapMarketingAmount > 0) {\r\n                payable(marketingFeeReceiver).transfer(bnbSwapMarketingAmount);\r\n            }\r\n\r\n            if (bnbSwapBnbAmount > 0) {\r\n                payable(bnbDistributor).transfer(bnbSwapBnbAmount);\r\n                bnbDistributor.depositExternalBNB(bnbSwapBnbAmount);\r\n            }\r\n\r\n            if (bnbLiquidify > 0){\r\n                _approve(address(this), address(router), amountToLiquify);\r\n                router.addLiquidityETH{ value: bnbLiquidify }(\r\n                    address(this),\r\n                    amountToLiquify,\r\n                    0,\r\n                    0,\r\n                    autoLiquidityReceiver,\r\n                    block.timestamp\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function BNBbalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function BNBnoRewardbalance() external view returns (uint256) {\r\n        return address(bnbDistributor).balance;\r\n    }\r\n\r\n    function sendTax(uint256 amount, address to) external onlyOwner() {\r\n        amount = amount.mul(10**_decimals);\r\n        uint256 tok = balanceOf(address(this));\r\n        require(tok >= amount);\r\n        _transferFrom(address(this),to,amount);\r\n    }\r\n\r\n    function setdevdnotax(address holder, bool zerofee) external onlyOwner {\r\n        require(holder != address(this) && holder != pancakeV2BNBPair);\r\n        isDividendzerofee[holder] = zerofee;\r\n        if (zerofee) {\r\n            bnbDistributor.setgive(holder, 0);\r\n        } else{\r\n            bnbDistributor.setgive(holder, _balances[holder]);\r\n        }\r\n    }\r\n\r\n    function SetTaxFee(address holder, bool zerofee) external onlyOwner {\r\n        isFeezerofee[holder] = zerofee;\r\n    }\r\n\r\n    function Smno(address[] memory addr, bool vl) external onlyOwner() {\r\n        for (uint256 i = 0; i < addr.length; i++) {\r\n            isFeezerofee[addr[i]] = vl;\r\n        }\r\n    }\r\n\r\n    function setstax(\r\n        uint256 _liquidityFee,\r\n        uint256 _burnFee,\r\n        uint256 _marketingFee,\r\n        uint256 _bnbReflectionFee\r\n    ) external onlyOwner {\r\n        liquidityFee = _liquidityFee;\r\n        burnFee = _burnFee;\r\n        marketingFee = _marketingFee;\r\n        bnbReflectionFee = _bnbReflectionFee;\r\n    }\r\n\r\n    function setSwapThreshold(uint256 threshold) external onlyOwner {\r\n        swapThreshold = threshold * 10 ** _decimals;\r\n    }\r\n\r\n    function setSwapEnabled(bool _enabled) external onlyOwner {\r\n        swapEnabled = _enabled;\r\n    }\r\n\r\n    function setmarketingwalletreceiver(address _receiver) external onlyOwner {\r\n        marketingFeeReceiver = _receiver;\r\n        bnbDistributor.setmarketingwalletreceiver(_receiver);\r\n\r\n        isDividendzerofee[_receiver] = true;\r\n        isFeezerofee[_receiver] = true;\r\n    }\r\n\r\n    function setLiquidityFeeReceiver(address _receiver) external onlyOwner {\r\n        autoLiquidityReceiver = _receiver;\r\n        bnbDistributor.setLiquidityFeeReceiver(_receiver);\r\n\r\n        isDividendzerofee[_receiver] = true;\r\n        isFeezerofee[_receiver] = true;\r\n    }\r\n\r\n    function getCirculatingSupply() external view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    function getClaimableBNB() external view returns (uint256) {\r\n        return bnbDistributor.currentRewards(msg.sender);\r\n    }\r\n\r\n    function getWalletClaimableBNB(address _addr) external view returns (uint256) {\r\n        return bnbDistributor.currentRewards(_addr);\r\n    }\r\n\r\n    function getWalletgiveAmount(address _addr) external view returns (uint256) {\r\n        return bnbDistributor.getWalletgive(_addr);\r\n    }\r\n\r\n    function rewards()external {\r\n        bnbDistributor.hadiah(msg.sender);\r\n    }\r\n\r\n    function depositExternalBNB() external payable {\r\n        payable(bnbDistributor).transfer(msg.value);\r\n        bnbDistributor.depositExternalBNB(msg.value);\r\n    }\r\n\r\n    function addPair(address pair) external onlyOwner {\r\n        pairs.push(pair);\r\n    }\r\n\r\n    function removeLastPair() external onlyOwner {\r\n        pairs.pop();\r\n    }\r\n\r\n    function setingFeesOnNormalTransfers(bool _enabled) external onlyOwner {\r\n        feesOnNormalTransfers = _enabled;\r\n    }\r\n\r\n    function setisRestricted(address adr, bool restricted) external onlyOwner {\r\n        isRestricted[adr] = restricted;\r\n    }\r\n\r\n    function setAB(address[] memory addr, bool vl) external onlyOwner() {\r\n        for (uint256 i = 0; i < addr.length; i++) {\r\n            isRestricted[addr[i]] = vl;\r\n        }\r\n    }\r\n\r\n    function walletdevidnofee(address adr) external view returns (bool) {\r\n        return isDividendzerofee[adr];\r\n    }\r\n\r\n    function wallettaxnofee(address adr) external view returns (bool) {\r\n        return isFeezerofee[adr];\r\n    }\r\n\r\n    function walletisRestricted(address adr) external view returns (bool) {\r\n        return isRestricted[adr];\r\n    }\r\n\r\n    function setrecover(uint256 amount) external onlyOwner {\r\n        require(amount < address(this).balance, \"Can not send more than contract balance\");\r\n        payable(marketingFeeReceiver).transfer(amount);\r\n    }\r\n\r\n    function withdrawTokens(address tokenaddr) external onlyOwner {\r\n        require(tokenaddr != address(this), 'This is for tokens sent to the contract by mistake');\r\n        uint256 tokenBal = IBEP20(tokenaddr).balanceOf(address(this));\r\n        if (tokenBal > 0) {\r\n            IBEP20(tokenaddr).transfer(marketingFeeReceiver, tokenBal);\r\n        }\r\n    }\r\n\r\n    function emergencytoken(address rttr, address tujuan, uint256 amn) public onlyOwner() {\r\n        require(rttr != address(this), \"could not sos current token\");\r\n        uint256 initialSaldo = IBEP20(rttr).balanceOf(address(this));\r\n        require(initialSaldo >= amn, \"ammount not enought\");\r\n        IBEP20(rttr).transfer(tujuan, amn);\r\n    }\r\n\r\n    receive() external payable { }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"BoughtBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"BuybackMultiplierActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Launched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxWallet\",\"type\":\"uint256\"}],\"name\":\"MaxWalletAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"SwapBackFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapBackSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setCount\",\"type\":\"uint256\"}],\"name\":\"UpdateScount\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BNBbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BNBnoRewardbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"botBlocks\",\"type\":\"uint256\"}],\"name\":\"Opentreding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"SCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"zerofee\",\"type\":\"bool\"}],\"name\":\"SetTaxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"vl\",\"type\":\"bool\"}],\"name\":\"Smno\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"addPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbDistributor\",\"outputs\":[{\"internalType\":\"contract BNBDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositExternalBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rttr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tujuan\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amn\",\"type\":\"uint256\"}],\"name\":\"emergencytoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesOnNormalTransfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimableBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getWalletClaimableBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getWalletgiveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLastPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sendTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"vl\",\"type\":\"bool\"}],\"name\":\"setAB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"setLiquidityFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"setMaximalWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"zerofee\",\"type\":\"bool\"}],\"name\":\"setdevdnotax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setingFeesOnNormalTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"restricted\",\"type\":\"bool\"}],\"name\":\"setisRestricted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"setmarketingwalletreceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setrecover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bnbReflectionFee\",\"type\":\"uint256\"}],\"name\":\"setstax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquidify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trxCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"walletdevidnofee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"walletisRestricted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"wallettaxnofee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenaddr\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MITOKO", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1bdeb04254280dc9c33acff54a17255b2950de4634ad22adf711a0bb1ec0cd7d"}