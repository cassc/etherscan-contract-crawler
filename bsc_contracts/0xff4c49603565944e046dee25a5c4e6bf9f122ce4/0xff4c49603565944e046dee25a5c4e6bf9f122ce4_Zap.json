{"SourceCode": "// File @openzeppelin/contracts/utils/Context.sol@v4.9.0\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File contracts/libraries/pancakeswapV3/TransferHelper.sol\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(\r\n                IERC20.transferFrom.selector,\r\n                from,\r\n                to,\r\n                value\r\n            )\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"STF\"\r\n        );\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"ST\"\r\n        );\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"SA\"\r\n        );\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"STE\");\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/external/IERC20Querier.sol\r\n\r\ninterface IERC20Querier {\r\n    function decimals() external view returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n// File contracts/interfaces/pancakeswapV3/IPancakeV3Factory.sol\r\n\r\n/// @title The interface for the PancakeSwap V3 Factory\r\n/// @notice The PancakeSwap V3 Factory facilitates creation of PancakeSwap V3 pools and control over the protocol fees\r\ninterface IPancakeV3Factory {\r\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\r\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n    /// @param tokenA The contract address of either token0 or token1\r\n    /// @param tokenB The contract address of the other token\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @return pool The pool address\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n}\r\n\r\n// File contracts/interfaces/pancakeswapV3/IPancakeV3Pool.sol\r\n\r\n/// @title The interface for a PancakeSwap V3 Pool\r\n/// @notice A PancakeSwap pool facilitates swapping and automated market making between any two assets that strictly conform\r\n/// to the ERC20 specification\r\n/// @dev The pool interface is broken up into many smaller pieces\r\ninterface IPancakeV3Pool {\r\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\r\n    /// when accessed externally.\r\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\r\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\r\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\r\n    /// boundary.\r\n    /// observationIndex The index of the last oracle observation that was written,\r\n    /// observationCardinality The current maximum number of observations stored in the pool,\r\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\r\n    /// feeProtocol The protocol fee for both tokens of the pool.\r\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\r\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\r\n    /// unlocked Whether the pool is currently locked to reentrancy\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint32 feeProtocol,\r\n            bool unlocked\r\n        );\r\n\r\n    /// @notice The first of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token0() external view returns (address);\r\n\r\n    /// @notice The second of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token1() external view returns (address);\r\n\r\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\r\n    /// @return The fee\r\n    function fee() external view returns (uint24);\r\n\r\n    /// @notice The pool tick spacing\r\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\r\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\r\n    /// This value is an int24 to avoid casting even though it is always positive.\r\n    /// @return The tick spacing\r\n    function tickSpacing() external view returns (int24);\r\n}\r\n\r\n// File contracts/libraries/PoolHelper.sol\r\n\r\nlibrary PoolHelper {\r\n    using SafeMath for uint256;\r\n\r\n    function getPoolAddress(\r\n        address pancakeswapV3FactoryAddress,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 poolFee\r\n    ) internal view returns (address poolAddress) {\r\n        return\r\n            IPancakeV3Factory(pancakeswapV3FactoryAddress).getPool(\r\n                tokenA,\r\n                tokenB,\r\n                poolFee\r\n            );\r\n    }\r\n\r\n    function getPoolInfo(\r\n        address poolAddress\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            address token0,\r\n            address token1,\r\n            uint24 poolFee,\r\n            int24 tick,\r\n            uint160 sqrtPriceX96,\r\n            uint256 decimal0,\r\n            uint256 decimal1\r\n        )\r\n    {\r\n        (sqrtPriceX96, tick, , , , , ) = IPancakeV3Pool(poolAddress).slot0();\r\n        token0 = IPancakeV3Pool(poolAddress).token0();\r\n        token1 = IPancakeV3Pool(poolAddress).token1();\r\n        poolFee = IPancakeV3Pool(poolAddress).fee();\r\n        decimal0 = IERC20Querier(token0).decimals();\r\n        decimal1 = IERC20Querier(token1).decimals();\r\n    }\r\n\r\n    /// @dev formula explanation\r\n    /*\r\n    [Original formula (without decimal precision)]\r\n    (token1 * (10^decimal1)) / (token0 * (10^decimal0)) = (sqrtPriceX96 / (2^96))^2   \r\n    tokenPrice = token1/token0 = (sqrtPriceX96 / (2^96))^2 * (10^decimal0) / (10^decimal1)\r\n\r\n    [Formula with decimal precision & decimal adjustment]\r\n    tokenPriceWithDecimalAdj = tokenPrice * (10^decimalPrecision)\r\n        = (sqrtPriceX96 * (10^decimalPrecision) / (2^96))^2 \r\n            / 10^(decimalPrecision + decimal1 - decimal0)\r\n    */\r\n    function getTokenPriceWithDecimalsByPool(\r\n        address poolAddress,\r\n        uint256 decimalPrecision\r\n    ) internal view returns (uint256 tokenPriceWithDecimals) {\r\n        (\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            uint160 sqrtPriceX96,\r\n            uint256 decimal0,\r\n            uint256 decimal1\r\n        ) = getPoolInfo(poolAddress);\r\n\r\n        // when decimalPrecision is 18,\r\n        // calculation restriction: 79228162514264337594 <= sqrtPriceX96 <= type(uint160).max\r\n        uint256 scaledPriceX96 = uint256(sqrtPriceX96)\r\n            .mul(10 ** decimalPrecision)\r\n            .div(2 ** 96);\r\n        uint256 tokenPriceWithoutDecimalAdj = scaledPriceX96.mul(\r\n            scaledPriceX96\r\n        );\r\n        uint256 decimalAdj = decimalPrecision.add(decimal1).sub(decimal0);\r\n        uint256 result = tokenPriceWithoutDecimalAdj.div(10 ** decimalAdj);\r\n        require(result > 0, \"token price too small\");\r\n        tokenPriceWithDecimals = result;\r\n    }\r\n\r\n    function getTokenDecimalAdjustment(\r\n        address token\r\n    ) internal view returns (uint256 decimalAdjustment) {\r\n        uint256 tokenDecimalStandard = 18;\r\n        uint256 decimal = IERC20Querier(token).decimals();\r\n        return tokenDecimalStandard.sub(decimal);\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/external/IWETH9.sol\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH9 {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256 amount) external;\r\n}\r\n\r\n// File contracts/interfaces/IZap.sol\r\n\r\ninterface IZap {\r\n    /// @dev get zap data\r\n    function slippageToleranceNumerator() external view returns (uint24);\r\n\r\n    function getSwapInfo(\r\n        address inputToken,\r\n        address outputToken\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bool isPathDefined,\r\n            address[] memory swapPathArray,\r\n            uint24[] memory swapTradeFeeArray\r\n        );\r\n\r\n    function getTokenExchangeRate(\r\n        address inputToken,\r\n        address outputToken\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address token0,\r\n            address token1,\r\n            uint256 tokenPriceWith18Decimals\r\n        );\r\n\r\n    function getMinimumSwapOutAmount(\r\n        address inputToken,\r\n        address outputToken,\r\n        uint256 inputAmount\r\n    ) external view returns (uint256 minimumSwapOutAmount);\r\n\r\n    /// @dev swapToken\r\n    function swapToken(\r\n        bool isBNB,\r\n        address inputToken,\r\n        address outputToken,\r\n        uint256 inputAmount,\r\n        address recipient\r\n    ) external payable returns (uint256 outputAmount);\r\n\r\n    function swapTokenWithMinimumOutput(\r\n        bool isBNB,\r\n        address inputToken,\r\n        address outputToken,\r\n        uint256 inputAmount,\r\n        uint256 minimumSwapOutAmount,\r\n        address recipient\r\n    ) external payable returns (uint256 outputAmount);\r\n}\r\n\r\n// File contracts/interfaces/IZapEvent.sol\r\n\r\ninterface IZapEvent {\r\n    event UpdateSlippageTolerance(uint24 slippageTolerance);\r\n\r\n    event UpdateSwapTradeFee(\r\n        address indexed inputToken,\r\n        address indexed outputToken,\r\n        uint24 swapTradeFee\r\n    );\r\n\r\n    event UpdateSwapPath(\r\n        address indexed inputToken,\r\n        address indexed outputToken,\r\n        address[] newSwapPath\r\n    );\r\n\r\n    event SingleSwap(\r\n        address indexed recipient,\r\n        bool isBNB,\r\n        address inputToken,\r\n        uint256 inputAmount,\r\n        address outputToken,\r\n        uint256 outputAmount,\r\n        address[] swapPath,\r\n        uint24[] swapTradeFee\r\n    );\r\n\r\n    event MultiSwap(\r\n        address indexed recipient,\r\n        bool isBNB,\r\n        address inputToken,\r\n        uint256 inputAmount,\r\n        address outputToken,\r\n        uint256 outputAmount,\r\n        address[] swapPath,\r\n        uint24[] swapTradeFee\r\n    );\r\n}\r\n\r\n// File contracts/interfaces/pancakeswapV3/ISmartRouter.sol\r\n\r\npragma abicoder v2;\r\n\r\ninterface ISmartRouter {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(\r\n        ExactInputSingleParams calldata params\r\n    ) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(\r\n        ExactInputParams calldata params\r\n    ) external payable returns (uint256 amountOut);\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param amountIn The amount of token to swap\r\n    /// @param amountOutMin The minimum amount of output that must be received\r\n    /// @param path The ordered list of tokens to swap through\r\n    /// @param to The recipient address\r\n    /// @return amountOut The amount of the received token\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to\r\n    ) external payable returns (uint256 amountOut);\r\n}\r\n\r\n// File contracts/libraries/constants/Constants.sol\r\n\r\nlibrary Constants {\r\n    /// @dev mainnet pancakeswap V3\r\n    address public constant PANCAKE_V3_FACTORY_ADDRESS =\r\n        address(0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865);\r\n    address public constant MASTER_CHEF_V3_ADDRESS =\r\n        address(0x556B9306565093C855AEA9AE92A594704c2Cd59e);\r\n    address public constant NONFUNGIBLE_POSITION_MANAGER_ADDRESS =\r\n        address(0x46A15B0b27311cedF172AB29E4f4766fbE7F4364);\r\n    address public constant SMART_ROUTER_ADDRESS =\r\n        address(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4);\r\n\r\n    /// @dev testnet pancakeswap V3\r\n    address public constant TESTNET_PANCAKE_V3_FACTORY_ADDRESS =\r\n        address(0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865);\r\n    address public constant TESTNET_MASTER_CHEF_V3_ADDRESS =\r\n        address(0x4c650FB471fe4e0f476fD3437C3411B1122c4e3B);\r\n    address public constant TESTNET_NONFUNGIBLE_POSITION_MANAGER_ADDRESS =\r\n        address(0x427bF5b37357632377eCbEC9de3626C71A5396c1);\r\n    address public constant TESTNET_SMART_ROUTER_ADDRESS =\r\n        address(0x9a489505a00cE272eAa5e07Dba6491314CaE3796);\r\n\r\n    /// @dev mainnet token address\r\n    address public constant WBNB_ADDRESS =\r\n        address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n    address public constant USDT_ADDRESS =\r\n        address(0x55d398326f99059fF775485246999027B3197955);\r\n    address public constant USDC_ADDRESS =\r\n        address(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\r\n    address public constant BTCB_ADDRESS =\r\n        address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\r\n    address public constant BUSD_ADDRESS =\r\n        address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n    address public constant CAKE_ADDRESS =\r\n        address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\r\n    address public constant ETH_ADDRESS =\r\n        address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\r\n    address public constant XRP_ADDRESS =\r\n        address(0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE);\r\n    address public constant ADA_ADDRESS =\r\n        address(0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47);\r\n    address public constant DOT_ADDRESS =\r\n        address(0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402);\r\n    address public constant RXD_ADDRESS =\r\n        address(0x92cb26ca653a51bBf916E6c3d58599CDB12e3a9F);\r\n\r\n    /// @dev testnet token address\r\n    address public constant TESTNET_WBNB_ADDRESS =\r\n        address(0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd);\r\n    address public constant TESTNET_USDT_ADDRESS =\r\n        address(0x0fB5D7c73FA349A90392f873a4FA1eCf6a3d0a96);\r\n    address public constant TESTNET_BUSD_ADDRESS =\r\n        address(0xaB1a4d4f1D656d2450692D237fdD6C7f9146e814);\r\n    address public constant TESTNET_CAKE_ADDRESS =\r\n        address(0x8d008B313C1d6C7fE2982F62d32Da7507cF43551);\r\n    address public constant TESTNET_RXD_ADDRESS =\r\n        address(0x3f83fCC8eFC9EBB56362222dD7844226870a12Ea);\r\n\r\n    /// @dev black hole address\r\n    address public constant BLACK_HOLE_ADDRESS =\r\n        address(0x000000000000000000000000000000000000dEaD);\r\n}\r\n\r\n// File contracts/libraries/constants/ZapConstants.sol\r\n\r\nlibrary ZapConstants {\r\n    /// @dev decimal precision\r\n    uint256 public constant DECIMALS_PRECISION = 18;\r\n\r\n    /// @dev denominator\r\n    uint24 public constant SLIPPAGE_TOLERANCE_DENOMINATOR = 1000000;\r\n    uint24 public constant SWAP_TRADE_FEE_DENOMINATOR = 1000000;\r\n}\r\n\r\n// File contracts/libraries/ParameterVerificationHelper.sol\r\n\r\nlibrary ParameterVerificationHelper {\r\n    function verifyNotZeroAddress(address inputAddress) internal pure {\r\n        require(inputAddress != address(0), \"input zero address\");\r\n    }\r\n\r\n    function verifyGreaterThanZero(uint256 inputNumber) internal pure {\r\n        require(inputNumber > 0, \"input 0\");\r\n    }\r\n\r\n    function verifyGreaterThanZero(int24 inputNumber) internal pure {\r\n        require(inputNumber > 0, \"input 0\");\r\n    }\r\n\r\n    function verifyGreaterThanOrEqualToZero(int24 inputNumber) internal pure {\r\n        require(inputNumber >= 0, \"input less than 0\");\r\n    }\r\n\r\n    function verifyPairTokensHaveWbnb(\r\n        address token0Address,\r\n        address token1Address,\r\n        address wbnbAddress\r\n    ) internal pure {\r\n        require(\r\n            token0Address == wbnbAddress || token1Address == wbnbAddress,\r\n            \"pair token not have WBNB\"\r\n        );\r\n    }\r\n\r\n    function verifyMsgValueEqualsInputAmount(\r\n        uint256 inputAmount\r\n    ) internal view {\r\n        require(msg.value == inputAmount, \"msg.value != inputAmount\");\r\n    }\r\n\r\n    function verifyPairTokensHaveInputToken(\r\n        address token0Address,\r\n        address token1Address,\r\n        address inputToken\r\n    ) internal pure {\r\n        require(\r\n            token0Address == inputToken || token1Address == inputToken,\r\n            \"pair token not have inputToken\"\r\n        );\r\n    }\r\n}\r\n\r\n// File contracts/ZapInitializer.sol\r\n\r\ncontract ZapInitializer {\r\n    // inputToken => outputToken => swapPath\r\n    mapping(address => mapping(address => address[])) internal swapPath;\r\n\r\n    // inputToken => outputToken => swapTradeFeeNumerator\r\n    mapping(address => mapping(address => uint24))\r\n        internal swapTradeFeeNumerator;\r\n\r\n    function initializeSwapTradeFeeNumerator(bool isTestnet) internal {\r\n        if (isTestnet) {\r\n            address WBNB = Constants.TESTNET_WBNB_ADDRESS;\r\n            address USDT = Constants.TESTNET_USDT_ADDRESS;\r\n            address BUSD = Constants.TESTNET_BUSD_ADDRESS;\r\n            address CAKE = Constants.TESTNET_CAKE_ADDRESS;\r\n\r\n            /// @dev testnet initilaization\r\n            swapTradeFeeNumerator[USDT][WBNB] = 2500;\r\n            swapTradeFeeNumerator[WBNB][USDT] = 2500;\r\n            swapTradeFeeNumerator[CAKE][WBNB] = 2500;\r\n            swapTradeFeeNumerator[WBNB][CAKE] = 2500;\r\n            swapTradeFeeNumerator[CAKE][BUSD] = 2500;\r\n            swapTradeFeeNumerator[BUSD][CAKE] = 2500;\r\n        } else {\r\n            address WBNB = Constants.WBNB_ADDRESS;\r\n            address USDT = Constants.USDT_ADDRESS;\r\n            address USDC = Constants.USDC_ADDRESS;\r\n            address BTCB = Constants.BTCB_ADDRESS;\r\n            address BUSD = Constants.BUSD_ADDRESS;\r\n            address CAKE = Constants.CAKE_ADDRESS;\r\n            address ETH = Constants.ETH_ADDRESS;\r\n            address XRP = Constants.XRP_ADDRESS;\r\n            address ADA = Constants.ADA_ADDRESS;\r\n            address DOT = Constants.DOT_ADDRESS;\r\n\r\n            /// @dev mainnet initialization trade fee 0.01%\r\n            swapTradeFeeNumerator[USDT][BUSD] = 100;\r\n            swapTradeFeeNumerator[BUSD][USDT] = 100;\r\n            swapTradeFeeNumerator[BUSD][USDC] = 100;\r\n            swapTradeFeeNumerator[USDC][BUSD] = 100;\r\n\r\n            /// @dev mainnet initialization trade fee 0.05%\r\n            swapTradeFeeNumerator[WBNB][USDT] = 500;\r\n            swapTradeFeeNumerator[WBNB][BUSD] = 500;\r\n            swapTradeFeeNumerator[USDT][WBNB] = 500;\r\n            swapTradeFeeNumerator[USDT][BTCB] = 500;\r\n            swapTradeFeeNumerator[USDT][USDC] = 500;\r\n            swapTradeFeeNumerator[BTCB][USDT] = 500;\r\n            swapTradeFeeNumerator[BTCB][BUSD] = 500;\r\n            swapTradeFeeNumerator[ETH][USDC] = 500;\r\n            swapTradeFeeNumerator[BUSD][WBNB] = 500;\r\n            swapTradeFeeNumerator[BUSD][BTCB] = 500;\r\n            swapTradeFeeNumerator[USDC][USDT] = 500;\r\n            swapTradeFeeNumerator[USDC][ETH] = 500;\r\n\r\n            /// @dev mainnet initialization trade fee 0.25%\r\n            swapTradeFeeNumerator[WBNB][BTCB] = 2500;\r\n            swapTradeFeeNumerator[WBNB][ETH] = 2500;\r\n            swapTradeFeeNumerator[CAKE][WBNB] = 2500;\r\n            swapTradeFeeNumerator[CAKE][USDT] = 2500;\r\n            swapTradeFeeNumerator[CAKE][BUSD] = 2500;\r\n            swapTradeFeeNumerator[BTCB][WBNB] = 2500;\r\n            swapTradeFeeNumerator[BTCB][ETH] = 2500;\r\n            swapTradeFeeNumerator[ETH][WBNB] = 2500;\r\n            swapTradeFeeNumerator[ETH][BTCB] = 2500;\r\n            swapTradeFeeNumerator[XRP][WBNB] = 2500;\r\n            swapTradeFeeNumerator[ADA][WBNB] = 2500;\r\n            swapTradeFeeNumerator[DOT][WBNB] = 2500;\r\n        }\r\n    }\r\n\r\n    function initializeSwapPath(bool isTestnet) internal {\r\n        if (isTestnet) {\r\n            address WBNB = Constants.TESTNET_WBNB_ADDRESS;\r\n            address USDT = Constants.TESTNET_USDT_ADDRESS;\r\n            address BUSD = Constants.TESTNET_BUSD_ADDRESS;\r\n            address CAKE = Constants.TESTNET_CAKE_ADDRESS;\r\n\r\n            /// @dev testnet initialization\r\n            swapPath[WBNB][USDT] = [WBNB, USDT];\r\n            swapPath[WBNB][BUSD] = [WBNB, CAKE, BUSD];\r\n            swapPath[WBNB][CAKE] = [WBNB, CAKE];\r\n\r\n            swapPath[USDT][WBNB] = [USDT, WBNB];\r\n            swapPath[USDT][BUSD] = [USDT, WBNB, CAKE, BUSD];\r\n            swapPath[USDT][CAKE] = [USDT, WBNB, CAKE];\r\n\r\n            swapPath[BUSD][WBNB] = [BUSD, CAKE, WBNB];\r\n            swapPath[BUSD][USDT] = [BUSD, CAKE, WBNB, USDT];\r\n            swapPath[BUSD][CAKE] = [BUSD, CAKE];\r\n\r\n            swapPath[CAKE][WBNB] = [CAKE, WBNB];\r\n            swapPath[CAKE][USDT] = [CAKE, WBNB, USDT];\r\n            swapPath[CAKE][BUSD] = [CAKE, BUSD];\r\n        } else {\r\n            address WBNB = Constants.WBNB_ADDRESS;\r\n            address USDT = Constants.USDT_ADDRESS;\r\n            address USDC = Constants.USDC_ADDRESS;\r\n            address BTCB = Constants.BTCB_ADDRESS;\r\n            address BUSD = Constants.BUSD_ADDRESS;\r\n            address CAKE = Constants.CAKE_ADDRESS;\r\n            address ETH = Constants.ETH_ADDRESS;\r\n            address XRP = Constants.XRP_ADDRESS;\r\n            address ADA = Constants.ADA_ADDRESS;\r\n            address DOT = Constants.DOT_ADDRESS;\r\n\r\n            /// @dev mainnet initialization single swap\r\n            // trade fee 0.01%\r\n            swapPath[USDT][BUSD] = [USDT, BUSD];\r\n            swapPath[BUSD][USDT] = [BUSD, USDT];\r\n            swapPath[BUSD][USDC] = [BUSD, USDC];\r\n            swapPath[USDC][BUSD] = [USDC, BUSD];\r\n\r\n            /// @dev mainnet initialization single swap\r\n            // trade fee 0.05%\r\n            swapPath[WBNB][USDT] = [WBNB, USDT];\r\n            swapPath[WBNB][BUSD] = [WBNB, BUSD];\r\n            swapPath[USDT][WBNB] = [USDT, WBNB];\r\n            swapPath[USDT][BTCB] = [USDT, BTCB];\r\n            swapPath[USDT][USDC] = [USDT, USDC];\r\n            swapPath[BTCB][USDT] = [BTCB, USDT];\r\n            swapPath[BTCB][BUSD] = [BTCB, BUSD];\r\n            swapPath[ETH][USDC] = [ETH, USDC];\r\n            swapPath[BUSD][WBNB] = [BUSD, WBNB];\r\n            swapPath[BUSD][BTCB] = [BUSD, BTCB];\r\n            swapPath[USDC][USDT] = [USDC, USDT];\r\n            swapPath[USDC][ETH] = [USDC, ETH];\r\n\r\n            /// @dev mainnet initialization single swap\r\n            // trade fee 0.25%\r\n            swapPath[WBNB][BTCB] = [WBNB, BTCB];\r\n            swapPath[WBNB][ETH] = [WBNB, ETH];\r\n            swapPath[CAKE][WBNB] = [CAKE, WBNB];\r\n            swapPath[CAKE][USDT] = [CAKE, USDT];\r\n            swapPath[CAKE][BUSD] = [CAKE, BUSD];\r\n            swapPath[BTCB][WBNB] = [BTCB, WBNB];\r\n            swapPath[BTCB][ETH] = [BTCB, ETH];\r\n            swapPath[ETH][WBNB] = [ETH, WBNB];\r\n            swapPath[ETH][BTCB] = [ETH, BTCB];\r\n            swapPath[XRP][WBNB] = [XRP, WBNB];\r\n            swapPath[ADA][WBNB] = [ADA, WBNB];\r\n            swapPath[DOT][WBNB] = [DOT, WBNB];\r\n\r\n            /// @dev mainnet initialization multi swap\r\n            swapPath[WBNB][USDC] = [WBNB, BUSD, USDC];\r\n            swapPath[CAKE][BTCB] = [CAKE, USDT, BTCB];\r\n            swapPath[CAKE][USDC] = [CAKE, BUSD, USDC];\r\n            swapPath[CAKE][ETH] = [CAKE, WBNB, ETH];\r\n            swapPath[USDT][ETH] = [USDT, USDC, ETH];\r\n            swapPath[BTCB][USDC] = [BTCB, BUSD, USDC];\r\n            swapPath[ETH][USDT] = [ETH, USDC, USDT];\r\n            swapPath[ETH][BUSD] = [ETH, USDC, BUSD];\r\n            swapPath[BUSD][ETH] = [BUSD, USDC, ETH];\r\n            swapPath[XRP][USDT] = [XRP, WBNB, USDT];\r\n            swapPath[XRP][BTCB] = [XRP, WBNB, BTCB];\r\n            swapPath[XRP][BUSD] = [XRP, WBNB, BUSD];\r\n            swapPath[XRP][USDC] = [XRP, WBNB, BUSD, USDC];\r\n            swapPath[XRP][ETH] = [XRP, WBNB, ETH];\r\n            swapPath[ADA][USDT] = [ADA, WBNB, USDT];\r\n            swapPath[ADA][BTCB] = [ADA, WBNB, BTCB];\r\n            swapPath[ADA][BUSD] = [ADA, WBNB, BUSD];\r\n            swapPath[ADA][USDC] = [ADA, WBNB, BUSD, USDC];\r\n            swapPath[ADA][ETH] = [ADA, WBNB, ETH];\r\n            swapPath[DOT][USDT] = [DOT, WBNB, USDT];\r\n            swapPath[DOT][BTCB] = [DOT, WBNB, BTCB];\r\n            swapPath[DOT][BUSD] = [DOT, WBNB, BUSD];\r\n            swapPath[DOT][USDC] = [DOT, WBNB, BUSD, USDC];\r\n            swapPath[DOT][ETH] = [DOT, WBNB, ETH];\r\n            swapPath[USDC][WBNB] = [USDC, BUSD, WBNB];\r\n            swapPath[USDC][BTCB] = [USDC, BUSD, BTCB];\r\n        }\r\n    }\r\n}\r\n\r\n// File contracts/Zap.sol\r\n\r\n/// @dev verified, public contract\r\n/// @dev ceratin functions only owner callable\r\ncontract Zap is IZap, IZapEvent, Ownable, ZapInitializer {\r\n    using SafeMath for uint256;\r\n    uint24 public override slippageToleranceNumerator;\r\n\r\n    address public PANCAKE_V3_FACTORY_ADDRESS;\r\n    address public SMART_ROUTER_ADDRESS;\r\n    address public WBNB;\r\n\r\n    constructor(bool isTestnet, uint24 _slippageToleranceNumerator) {\r\n        // initialize pre-defined swapPath and swapTradeFeeNumerator\r\n        initializeSwapTradeFeeNumerator(isTestnet);\r\n        initializeSwapPath(isTestnet);\r\n        slippageToleranceNumerator = _slippageToleranceNumerator;\r\n        if (isTestnet) {\r\n            PANCAKE_V3_FACTORY_ADDRESS = Constants\r\n                .TESTNET_PANCAKE_V3_FACTORY_ADDRESS;\r\n            SMART_ROUTER_ADDRESS = Constants.TESTNET_SMART_ROUTER_ADDRESS;\r\n            WBNB = Constants.TESTNET_WBNB_ADDRESS;\r\n        } else {\r\n            PANCAKE_V3_FACTORY_ADDRESS = Constants.PANCAKE_V3_FACTORY_ADDRESS;\r\n            SMART_ROUTER_ADDRESS = Constants.SMART_ROUTER_ADDRESS;\r\n            WBNB = Constants.WBNB_ADDRESS;\r\n        }\r\n    }\r\n\r\n    function getSwapInfo(\r\n        address inputToken,\r\n        address outputToken\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            bool isPathDefined,\r\n            address[] memory swapPathArray,\r\n            uint24[] memory swapTradeFeeArray\r\n        )\r\n    {\r\n        // parameter verification\r\n        ParameterVerificationHelper.verifyNotZeroAddress(inputToken);\r\n        ParameterVerificationHelper.verifyNotZeroAddress(outputToken);\r\n\r\n        // verify inputToken is not outputToken\r\n        require(inputToken != outputToken, \"inputToken == outputToken\");\r\n\r\n        // get swapPath\r\n        address[] memory _swapPathArray = swapPath[inputToken][outputToken];\r\n        uint256 pathLength = _swapPathArray.length;\r\n\r\n        if (pathLength >= 2) {\r\n            // statement for \"single swap path\" & \"multiple swap path\"\r\n            bool _isPathDefined = true;\r\n            uint24[] memory _swapTradeFeeArray = new uint24[](pathLength - 1);\r\n\r\n            for (uint i = 0; i < (pathLength - 1); i++) {\r\n                uint24 tradeFee = swapTradeFeeNumerator[_swapPathArray[i]][\r\n                    _swapPathArray[i + 1]\r\n                ];\r\n                if (tradeFee == 0) {\r\n                    // path not defined if tradeFee is 0\r\n                    _isPathDefined = false;\r\n                }\r\n                _swapTradeFeeArray[i] = tradeFee;\r\n            }\r\n            return (_isPathDefined, _swapPathArray, _swapTradeFeeArray);\r\n        } else {\r\n            // statement for \"path is not defined\"\r\n            return (false, new address[](0), new uint24[](0));\r\n        }\r\n    }\r\n\r\n    function setSlippageToleranceNumerator(\r\n        uint24 slippageTolerance\r\n    ) public onlyOwner {\r\n        // parameter verification\r\n        ParameterVerificationHelper.verifyGreaterThanZero(slippageTolerance);\r\n\r\n        // verify slippageTolerance is less than SLIPPAGE_TOLERANCE_DENOMINATOR\r\n        require(\r\n            slippageTolerance < ZapConstants.SLIPPAGE_TOLERANCE_DENOMINATOR,\r\n            \"slippageTolerance too big\"\r\n        );\r\n\r\n        // update slippageToleranceNumerator\r\n        slippageToleranceNumerator = slippageTolerance;\r\n\r\n        // emit UpdateSlippageTolerance event\r\n        emit UpdateSlippageTolerance(slippageTolerance);\r\n    }\r\n\r\n    function setSwapTradeFeeNumerator(\r\n        address inputToken,\r\n        address outputToken,\r\n        uint24 swapTradeFee\r\n    ) public onlyOwner {\r\n        // parameter verification\r\n        ParameterVerificationHelper.verifyNotZeroAddress(inputToken);\r\n        ParameterVerificationHelper.verifyNotZeroAddress(outputToken);\r\n        ParameterVerificationHelper.verifyGreaterThanZero(swapTradeFee);\r\n\r\n        // verify inputToken is not outputToken\r\n        require(inputToken != outputToken, \"inputToken == outputToken\");\r\n\r\n        // verify pool is exist\r\n        address poolAddress = PoolHelper.getPoolAddress(\r\n            PANCAKE_V3_FACTORY_ADDRESS,\r\n            inputToken,\r\n            outputToken,\r\n            swapTradeFee\r\n        );\r\n        require(poolAddress != address(0), \"pool not exist\");\r\n\r\n        // update swapTradeFeeNumerator\r\n        swapTradeFeeNumerator[inputToken][outputToken] = swapTradeFee;\r\n\r\n        // emit UpdateSwapTradeFee event\r\n        emit UpdateSwapTradeFee(inputToken, outputToken, swapTradeFee);\r\n    }\r\n\r\n    function setSwapPath(\r\n        address inputToken,\r\n        address outputToken,\r\n        address[] memory newSwapPath\r\n    ) public onlyOwner {\r\n        // parameter verification\r\n        ParameterVerificationHelper.verifyNotZeroAddress(inputToken);\r\n        ParameterVerificationHelper.verifyNotZeroAddress(outputToken);\r\n        uint256 pathLength = newSwapPath.length;\r\n        for (uint i = 0; i < pathLength; i++) {\r\n            ParameterVerificationHelper.verifyNotZeroAddress(newSwapPath[i]);\r\n        }\r\n\r\n        // verify inputToken is not outputToken\r\n        require(inputToken != outputToken, \"inputToken == outputToken\");\r\n\r\n        // verify input path is valid swap path\r\n        require(pathLength >= 2, \"path too short\");\r\n\r\n        // verify first token in newSwapPath is inputToken\r\n        require(newSwapPath[0] == inputToken, \"path not start from inputToken\");\r\n\r\n        // verify last token in newSwapPath is outputToken\r\n        require(\r\n            newSwapPath[(pathLength - 1)] == outputToken,\r\n            \"path not end with outputToken\"\r\n        );\r\n\r\n        // verify each swap?\uea03 fee is defined\r\n        for (uint i = 0; i < (pathLength - 1); i++) {\r\n            uint24 tradeFee = swapTradeFeeNumerator[newSwapPath[i]][\r\n                newSwapPath[i + 1]\r\n            ];\r\n            require(tradeFee != 0, \"tradefee not defined\");\r\n        }\r\n\r\n        // update Swap Path\r\n        swapPath[inputToken][outputToken] = newSwapPath;\r\n\r\n        // emit UpdateSwapPath event\r\n        emit UpdateSwapPath(inputToken, outputToken, newSwapPath);\r\n    }\r\n\r\n    function getTokenExchangeRate(\r\n        address inputToken,\r\n        address outputToken\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            address token0,\r\n            address token1,\r\n            uint256 tokenPriceWith18Decimals\r\n        )\r\n    {\r\n        // parameter verification\r\n        ParameterVerificationHelper.verifyNotZeroAddress(inputToken);\r\n        ParameterVerificationHelper.verifyNotZeroAddress(outputToken);\r\n\r\n        // verify inputToken is not outputToken\r\n        require(inputToken != outputToken, \"inputToken == outputToken\");\r\n\r\n        // verify swap trade fee is defined\r\n        uint24 tradeFee = swapTradeFeeNumerator[inputToken][outputToken];\r\n        require(tradeFee != 0, \"tradeFee not define\");\r\n\r\n        // verify pool is exist\r\n        address poolAddress = PoolHelper.getPoolAddress(\r\n            PANCAKE_V3_FACTORY_ADDRESS,\r\n            inputToken,\r\n            outputToken,\r\n            tradeFee\r\n        );\r\n        require(poolAddress != address(0), \"pool not exist\");\r\n\r\n        // query pool info\r\n        (token0, token1, , , , , ) = PoolHelper.getPoolInfo(poolAddress);\r\n\r\n        // calculate token price with 18 decimal precision\r\n        tokenPriceWith18Decimals = PoolHelper.getTokenPriceWithDecimalsByPool(\r\n            poolAddress,\r\n            ZapConstants.DECIMALS_PRECISION\r\n        );\r\n    }\r\n\r\n    function getMinimumSwapOutAmount(\r\n        address inputToken,\r\n        address outputToken,\r\n        uint256 inputAmount\r\n    ) public view override returns (uint256 minimumSwapOutAmount) {\r\n        uint256 estimateSwapOutAmount = getEstimateSwapOutAmount(\r\n            inputToken,\r\n            outputToken,\r\n            inputAmount\r\n        );\r\n\r\n        // calculate price include slippage tolerance\r\n        uint256 _minimumSwapOutAmount = estimateSwapOutAmount\r\n            .mul(\r\n                uint256(ZapConstants.SLIPPAGE_TOLERANCE_DENOMINATOR).sub(\r\n                    slippageToleranceNumerator\r\n                )\r\n            )\r\n            .div(ZapConstants.SLIPPAGE_TOLERANCE_DENOMINATOR);\r\n\r\n        minimumSwapOutAmount = _minimumSwapOutAmount;\r\n    }\r\n\r\n    function getEstimateSwapOutAmount(\r\n        address inputToken,\r\n        address outputToken,\r\n        uint256 inputAmount\r\n    ) public view returns (uint256 estimateSwapOutAmount) {\r\n        // parameter verification\r\n        ParameterVerificationHelper.verifyNotZeroAddress(inputToken);\r\n        ParameterVerificationHelper.verifyNotZeroAddress(outputToken);\r\n        ParameterVerificationHelper.verifyGreaterThanZero(inputAmount);\r\n\r\n        // variable verification\r\n        require(\r\n            slippageToleranceNumerator > 0,\r\n            \"slippageToleranceNumerator is 0\"\r\n        );\r\n\r\n        // verify inputToken is not outputToken\r\n        require(inputToken != outputToken, \"inputToken == outputToken\");\r\n\r\n        // verify swap info is defined\r\n        (\r\n            bool isPathDefined,\r\n            address[] memory swapPathArray,\r\n            uint24[] memory swapTradeFeeArray\r\n        ) = getSwapInfo(inputToken, outputToken);\r\n        require(isPathDefined == true, \"path not define\");\r\n\r\n        // get swap path length as loop end index\r\n        uint256 pathLength = swapPathArray.length;\r\n\r\n        // intput token decimal adjustment\r\n        uint256 calcAmount = inputAmount.mul(\r\n            10 ** (PoolHelper.getTokenDecimalAdjustment(inputToken))\r\n        );\r\n        // Loop calculate minimum swap out amount\r\n        for (uint i = 0; i < (pathLength - 1); i++) {\r\n            address tokenIn = swapPathArray[i];\r\n            address tokenOut = swapPathArray[i + 1];\r\n            (\r\n                address token0,\r\n                address token1,\r\n                uint256 tokenPriceWith18Decimals // (token1/token0) * 10**DECIMALS_PRECISION\r\n            ) = getTokenExchangeRate(tokenIn, tokenOut);\r\n\r\n            // deduct trade fee\r\n            calcAmount = calcAmount\r\n                .mul(\r\n                    uint256(ZapConstants.SWAP_TRADE_FEE_DENOMINATOR).sub(\r\n                        swapTradeFeeArray[i]\r\n                    )\r\n                )\r\n                .div(ZapConstants.SWAP_TRADE_FEE_DENOMINATOR);\r\n\r\n            // get swap out amount without slippage\r\n            require(tokenIn == token0 || tokenIn == token1);\r\n            if (tokenIn == token0) {\r\n                calcAmount = calcAmount.mul(tokenPriceWith18Decimals).div(\r\n                    10 ** ZapConstants.DECIMALS_PRECISION\r\n                );\r\n            } else {\r\n                calcAmount = calcAmount\r\n                    .mul(10 ** ZapConstants.DECIMALS_PRECISION)\r\n                    .div(tokenPriceWith18Decimals);\r\n            }\r\n        }\r\n\r\n        // output token decimal adjustment\r\n        estimateSwapOutAmount = calcAmount.div(\r\n            10 ** (PoolHelper.getTokenDecimalAdjustment(outputToken))\r\n        );\r\n    }\r\n\r\n    /// @notice caller need to approve inputToken to Zap contract in inputAmount amount\r\n    /// @notice be aware of sandwich attack, only for small amount swap\r\n    function swapToken(\r\n        bool isBNB,\r\n        address inputToken,\r\n        address outputToken,\r\n        uint256 inputAmount,\r\n        address recipient\r\n    ) public payable override returns (uint256 outputAmount) {\r\n        // get minimum swap out amount\r\n        uint256 minimumSwapOutAmount = getMinimumSwapOutAmount(\r\n            inputToken,\r\n            outputToken,\r\n            inputAmount\r\n        );\r\n\r\n        outputAmount = swapTokenWithMinimumOutput(\r\n            isBNB,\r\n            inputToken,\r\n            outputToken,\r\n            inputAmount,\r\n            minimumSwapOutAmount,\r\n            recipient\r\n        );\r\n    }\r\n\r\n    /// @notice caller need to approve inputToken to Zap contract in inputAmount amount\r\n    function swapTokenWithMinimumOutput(\r\n        bool isBNB,\r\n        address inputToken,\r\n        address outputToken,\r\n        uint256 inputAmount,\r\n        uint256 minimumSwapOutAmount,\r\n        address recipient\r\n    ) public payable override returns (uint256 outputAmount) {\r\n        // parameter verification\r\n        ParameterVerificationHelper.verifyNotZeroAddress(inputToken);\r\n        ParameterVerificationHelper.verifyNotZeroAddress(outputToken);\r\n        ParameterVerificationHelper.verifyNotZeroAddress(recipient);\r\n        ParameterVerificationHelper.verifyGreaterThanZero(inputAmount);\r\n\r\n        // verify inputToken is not outputToken\r\n        require(inputToken != outputToken, \"inputToken == outputToken\");\r\n\r\n        // verify swap info is defined\r\n        (\r\n            bool isPathDefined,\r\n            address[] memory swapPathArray,\r\n            uint24[] memory swapTradeFeeArray\r\n        ) = getSwapInfo(inputToken, outputToken);\r\n        require(isPathDefined == true, \"path not define\");\r\n\r\n        if (isBNB) {\r\n            // verify input BNB is the same as inputAmount\r\n            ParameterVerificationHelper.verifyMsgValueEqualsInputAmount(\r\n                inputAmount\r\n            );\r\n            require(\r\n                inputToken == WBNB,\r\n                \"input BNB must have swap path from WBNB\"\r\n            );\r\n\r\n            // prepare WBNB for swap\r\n            IWETH9(WBNB).deposit{value: inputAmount}();\r\n        } else {\r\n            // verify caller inputToken allowance is more or equal to inputAmount\r\n            require(\r\n                IERC20Querier(inputToken).allowance(\r\n                    msg.sender,\r\n                    address(this)\r\n                ) >= inputAmount,\r\n                \"allowance insufficient\"\r\n            );\r\n\r\n            // transfer inputToken in inputAmount from caller to Zap contract\r\n            TransferHelper.safeTransferFrom(\r\n                inputToken,\r\n                msg.sender,\r\n                address(this),\r\n                inputAmount\r\n            );\r\n        }\r\n\r\n        // approve inputToken to SmartRouter in inputAmount amount\r\n        TransferHelper.safeApprove(\r\n            inputToken,\r\n            SMART_ROUTER_ADDRESS,\r\n            inputAmount\r\n        );\r\n\r\n        uint256 pathLength = swapPathArray.length;\r\n        if (pathLength == 2) {\r\n            // statement for \"single swap path\", swap by exactInputSingle function\r\n            outputAmount = ISmartRouter(SMART_ROUTER_ADDRESS).exactInputSingle(\r\n                ISmartRouter.ExactInputSingleParams(\r\n                    inputToken,\r\n                    outputToken,\r\n                    swapTradeFeeArray[0],\r\n                    recipient,\r\n                    inputAmount,\r\n                    minimumSwapOutAmount,\r\n                    0\r\n                )\r\n            );\r\n            // emit SingleSwap event\r\n            emit SingleSwap(\r\n                recipient,\r\n                isBNB,\r\n                inputToken,\r\n                inputAmount,\r\n                outputToken,\r\n                outputAmount,\r\n                swapPathArray,\r\n                swapTradeFeeArray\r\n            );\r\n        } else {\r\n            // statement for \"multiple swap path\", swap by exactInput function\r\n            bytes memory path = abi.encodePacked(swapPathArray[0]);\r\n            for (uint i = 0; i < (pathLength - 1); i++) {\r\n                path = abi.encodePacked(\r\n                    path,\r\n                    swapTradeFeeArray[i],\r\n                    swapPathArray[i + 1]\r\n                );\r\n            }\r\n\r\n            outputAmount = ISmartRouter(SMART_ROUTER_ADDRESS).exactInput(\r\n                ISmartRouter.ExactInputParams(\r\n                    path,\r\n                    recipient,\r\n                    inputAmount,\r\n                    minimumSwapOutAmount\r\n                )\r\n            );\r\n            // emit MultiSwap event\r\n            emit MultiSwap(\r\n                recipient,\r\n                isBNB,\r\n                inputToken,\r\n                inputAmount,\r\n                outputToken,\r\n                outputAmount,\r\n                swapPathArray,\r\n                swapTradeFeeArray\r\n            );\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isTestnet\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"_slippageToleranceNumerator\",\"type\":\"uint24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBNB\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"swapPath\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint24[]\",\"name\":\"swapTradeFee\",\"type\":\"uint24[]\"}],\"name\":\"MultiSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBNB\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"swapPath\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint24[]\",\"name\":\"swapTradeFee\",\"type\":\"uint24[]\"}],\"name\":\"SingleSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"slippageTolerance\",\"type\":\"uint24\"}],\"name\":\"UpdateSlippageTolerance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newSwapPath\",\"type\":\"address[]\"}],\"name\":\"UpdateSwapPath\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"swapTradeFee\",\"type\":\"uint24\"}],\"name\":\"UpdateSwapTradeFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PANCAKE_V3_FACTORY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SMART_ROUTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"getEstimateSwapOutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"estimateSwapOutAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"getMinimumSwapOutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumSwapOutAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"}],\"name\":\"getSwapInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPathDefined\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"swapPathArray\",\"type\":\"address[]\"},{\"internalType\":\"uint24[]\",\"name\":\"swapTradeFeeArray\",\"type\":\"uint24[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"}],\"name\":\"getTokenExchangeRate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceWith18Decimals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"slippageTolerance\",\"type\":\"uint24\"}],\"name\":\"setSlippageToleranceNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"newSwapPath\",\"type\":\"address[]\"}],\"name\":\"setSwapPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"swapTradeFee\",\"type\":\"uint24\"}],\"name\":\"setSwapTradeFeeNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slippageToleranceNumerator\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBNB\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"swapToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBNB\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSwapOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"swapTokenWithMinimumOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Zap", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001388", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://391f6e3e5ad8bbb277f6235974c68a90a6125f47f8867ea9e072d14bccf87db1"}