{"SourceCode": "pragma solidity >=0.6.6;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        if (b == 0){\r\n            return a;\r\n        }\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function token0() external view returns (address);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IChiToken {\r\n    function freeUpTo(uint256 value) external returns (uint256 freed);\r\n    function mint(uint256 value) external;\r\n}\r\n\r\ncontract FengshuAllRouter {\r\n    using SafeMath for uint;\r\n\r\n    struct TradeOrdered {\r\n        address[] _targetPath;\r\n        address _targetRouter;\r\n        uint _targetAmountIn;\r\n        address tokenA;\r\n        address tokenB;\r\n        uint tradeType;\r\n    }\r\n\r\n    address public immutable DEV;\r\n    \r\n    address payable private administrator;\r\n    \r\n    mapping(address => bool) private whiteList;\r\n\r\n    IChiToken constant chiToken = IChiToken(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    \r\n                                            \r\n    receive() external payable {}\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == DEV, \"admin: wut do you try?\");\r\n        _;\r\n    }\r\n\r\n    modifier gasTokenRefund {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        chiToken.freeUpTo((21000 + gasStart - gasleft() + 16 * msg.data.length + 14154) / 41947);\r\n    }\r\n    \r\n    constructor() public {\r\n        DEV = administrator = msg.sender;\r\n        whiteList[msg.sender] = true;\r\n    }\r\n\r\n    function mintChiToken(uint256 amount) external virtual onlyAdmin {\r\n        chiToken.mint(amount);\r\n    }\r\n\r\n    function sendTokenBack(address token, uint256 amount) external virtual onlyAdmin {\r\n        IERC20(token).transfer(DEV, amount);\r\n    }\r\n    \r\n    function sendTokenBackAll(address token) external virtual onlyAdmin {\r\n        IERC20(token).transfer(DEV, IERC20(token).balanceOf(address(this)));\r\n    }\r\n    \r\n    function sendBnbBack() external virtual onlyAdmin {\r\n        administrator.transfer(address(this).balance);\r\n    }\r\n    \r\n    function setWhite(address account) external virtual onlyAdmin {\r\n        whiteList[account] = true;\r\n    }\r\n    \r\n    function balanceOf(address _token, address tokenOwner) public view returns (uint balance) {\r\n      return IERC20(_token).balanceOf(tokenOwner);\r\n    }\r\n    \r\n    function decimals(address _token) public view returns (uint8 decimal) {\r\n      return IERC20(_token).decimals();\r\n    }\r\n    \r\n    function getAmountsOut(address _router, uint amountIn, address[] memory path) public view returns (uint[] memory amounts) {\r\n        return IUniswapV2Router02(_router).getAmountsOut(amountIn, path);\r\n    }\r\n    \r\n    function getAmountOut(address _router, uint amountIn, uint reserveIn, uint reserveOut) public pure returns (uint amountOut) {\r\n        return IUniswapV2Router02(_router).getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsIn(address _router, uint amountOut, address[] memory path) public view returns (uint[] memory amounts) {\r\n        return IUniswapV2Router02(_router).getAmountsIn(amountOut, path);\r\n    }\r\n    \r\n    function getAmountIn(address _router, uint amountOut, uint reserveIn, uint reserveOut) public pure returns (uint amountIn) {\r\n        return IUniswapV2Router02(_router).getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n    \r\n    function getPair(address _router, address tokenA, address tokenB) public view returns (address pair){\r\n        IUniswapV2Factory _uniswapV2Factory = IUniswapV2Factory(IUniswapV2Router02(_router).factory());\r\n        return _uniswapV2Factory.getPair(tokenA, tokenB);\r\n    }\r\n    \r\n    function getReserves(address _router, address tokenA, address tokenB) public view returns (uint _reserveInput, uint _reserveOutput) {\r\n        address _uniswapV2Pair = getPair(_router, tokenA, tokenB);\r\n        IUniswapV2Pair uniswapV2Pair = IUniswapV2Pair(_uniswapV2Pair);\r\n        address token0 = uniswapV2Pair.token0();\r\n        (uint reserve0, uint reserve1,) = uniswapV2Pair.getReserves();\r\n        (uint reserveIn, uint reserveOut) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        return (reserveIn,reserveOut);\r\n    }\r\n \r\n    //\u83b7\u53d6\u4ea4\u6613\u4e70\u5165\u5356\u51fa\u540e\u7684\u6da8\u5e45\u6216\u8005\u8dcc\u5e45\uff08\u767e\u5206\u6bd4\uff09(tokenA:bnb || usdt || busd    tokenB:token)\r\n    function getTradePriceImpact(address[] memory _targetPath, address _targetRouter, uint _targetAmountIn, address tokenA, address tokenB, uint tradeType) public view returns (uint _priceImpact){\r\n        uint beforePrice = getTokenPrice(_targetRouter, tokenA, tokenB);\r\n        //\u4f7f\u7528\u7ed3\u6784\u4f53\uff0c\u89e3\u51b3stack too deep\u9519\u8bef\r\n        TradeOrdered memory tradeOrdered;\r\n        tradeOrdered._targetPath = _targetPath;\r\n        tradeOrdered._targetRouter = _targetRouter;\r\n        tradeOrdered._targetAmountIn = _targetAmountIn;\r\n        tradeOrdered.tokenA = tokenA;\r\n        tradeOrdered.tokenB = tokenB;\r\n        tradeOrdered.tradeType = tradeType;\r\n\r\n        (uint reserveIn, uint reserveOut) = getReserves(tradeOrdered._targetRouter, tradeOrdered.tokenA, tradeOrdered.tokenB);\r\n        uint input = 1000000000000000;//bnb || busd || usdt\r\n        uint tokenDecimals = uint(IERC20(tradeOrdered.tokenB).decimals());\r\n        uint amountOut2;\r\n        uint buyOrSell = 0;//\u4e70\u8fd8\u662f\u5356 0\uff1a\u4e70 1\uff1a\u5356\r\n        uint afterPrice = 0;\r\n        if(tradeOrdered._targetPath[0] == tradeOrdered.tokenB){\r\n            //\u5356\u5355\r\n            buyOrSell = 1;\r\n            //tradeType 0:  \u8f93\u5165\u5356\u51fa\u4ee3\u5e01\u6570 \u6765\u83b7\u53d6bnb  1\uff1a\u8f93\u5165\u80fd\u83b7\u5f97\u7684bnb\u6570  \u6765\u5356\u51fa\u4ee3\u5e01\r\n            if(tradeOrdered.tradeType == 0){\r\n                uint amountOut = getAmountOut(tradeOrdered._targetRouter, tradeOrdered._targetAmountIn, reserveOut, reserveIn);\r\n                amountOut2 = getAmountOut(tradeOrdered._targetRouter, input, reserveIn.sub(amountOut), reserveOut.add(tradeOrdered._targetAmountIn));\r\n            }else{\r\n                //\u8fd9\u91cc\u4f20\u53c2\u7684_amountIn \u5b9e\u9645\u4e0a\u662famountOut \u6ce8:\u8fd9\u4e2aamountOut\u662f\u8def\u5f84\u6700\u7ec8\u83b7\u53d6\u7684\u4ee3\u5e01\u7684\u6570\u91cf\r\n                uint amountOut = tradeOrdered._targetAmountIn;\r\n                uint[] memory amounts = getAmountsIn(tradeOrdered._targetRouter, amountOut, tradeOrdered._targetPath);//0: \u662f\u4f20\u5165token\u6570\u91cf 1\uff1atoken \u6362\u53d6[1]\u4ee3\u5e01 \u7684\u6570\u91cf\r\n                amountOut2 = getAmountOut(tradeOrdered._targetRouter, input, reserveIn.sub(amounts[1]), reserveOut.add(amounts[0]));\r\n            }\r\n        }else if(tradeOrdered._targetPath[tradeOrdered._targetPath.length - 1] == tradeOrdered.tokenB){\r\n            //\u4e70\u5355\r\n            //tradeType 0:  \u8f93\u5165\u8d2d\u4e70(bnb || usdt || busd) \u6570\u91cf \u6765\u83b7\u53d6\u4ee3\u5e01  1\uff1a\u8f93\u5165\u80fd\u83b7\u5f97\u7684\u4ee3\u5e01\u6570  \u6765\u4e70\u5165\u4ee3\u5e01\r\n            if(tradeOrdered.tradeType == 0){\r\n                uint[] memory amounts = getAmountsOut(tradeOrdered._targetRouter, tradeOrdered._targetAmountIn, tradeOrdered._targetPath);\r\n                amountOut2 = getAmountOut(tradeOrdered._targetRouter, input, reserveIn.add(amounts[tradeOrdered._targetPath.length - 2]), reserveOut.sub(amounts[tradeOrdered._targetPath.length - 1]));\r\n            }else{\r\n                //\u8fd9\u91cc\u4f20\u53c2\u7684_amountIn \u5b9e\u9645\u4e0a\u662famountOut \u6ce8:\u8fd9\u4e2aamountOut\u662f\u8def\u5f84\u6700\u7ec8\u83b7\u53d6\u7684\u4ee3\u5e01\u7684\u6570\u91cf\r\n                uint amountOut = tradeOrdered._targetAmountIn;\r\n                uint[] memory amounts = getAmountsIn(tradeOrdered._targetRouter, amountOut, tradeOrdered._targetPath);\r\n                amountOut2 = getAmountOut(tradeOrdered._targetRouter, input, reserveIn.add(amounts[tradeOrdered._targetPath.length - 2]), reserveOut.sub(amountOut));\r\n            }\r\n        } \r\n        if(tokenDecimals < 18){\r\n            afterPrice = input.mul(10 ** 18).div(amountOut2.mul(10 ** (18 - tokenDecimals)));\r\n        }else{\r\n            afterPrice = input.mul(10 ** 18).div(amountOut2);\r\n        }\r\n        return buyOrSell == 0 ? afterPrice.sub(beforePrice).mul(10000).div(beforePrice) : (beforePrice.sub(afterPrice).mul(10000).div(beforePrice));\r\n    }\r\n\r\n    //\u83b7\u53d6\u5f53\u524d\u4ee3\u5e01\u7684\u4ef7\u683c (tokenA:bnb || usdt || busd  tokenB:token)\r\n    function getTokenPrice(address _router, address tokenA, address tokenB) public view returns (uint _price){\r\n        uint reserveInput = 1000000000000000;\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = tokenA;\r\n        _path[1] = tokenB;\r\n        uint[] memory amounts = getAmountsOut(_router, reserveInput, _path);\r\n        uint tokenDecimals = uint(IERC20(tokenB).decimals());\r\n        uint price = 0;\r\n        if(tokenDecimals < 18){\r\n             price = reserveInput.mul(10 ** 18).div(amounts[1].mul(10 ** (18 - tokenDecimals)));\r\n        }else{\r\n             price = reserveInput.mul(10 ** 18).div(amounts[1]);\r\n        }\r\n        return price;\r\n    }\r\n\r\n    //\u68c0\u67e5\u4ee3\u5e01\u4e70\u5356\u7a0e\r\n    function checkHoneypots(address _router, address tokenA, address tokenB, uint amountIn) external virtual {\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = tokenA;\r\n        _path[1] = tokenB;\r\n        uint[] memory amounts = getAmountsOut(_router, amountIn, _path);\r\n        uint buyExpectedOut = amounts[1];\r\n        testBuy(_router, tokenA, tokenB, amountIn);\r\n        uint buyActualOut = IERC20(tokenB).balanceOf(address(this));\r\n        //sell\r\n        uint beforeBnb = IERC20(tokenA).balanceOf(address(this));\r\n        address[] memory _path2 = new address[](2);\r\n        _path2[0] = tokenB;\r\n        _path2[1] = tokenA;\r\n        uint[] memory amounts2 = getAmountsOut(_router, buyActualOut, _path2);\r\n        uint sellExpectedOut = amounts2[1];\r\n        testSellAll(_router, tokenB, tokenA);\r\n        uint afterBnb = IERC20(tokenA).balanceOf(address(this));\r\n        uint sellActualOut = afterBnb.sub(beforeBnb);\r\n        require(1!=1,string(abi.encodePacked(\"printTax:\", uint2str(buyExpectedOut), \"-\", uint2str(buyActualOut), \"-\", uint2str(sellExpectedOut), \"-\", uint2str(sellActualOut))));\r\n    }\r\n\r\n    function fastBuyCheckHoneypots(address _router, address tokenA, address tokenB, uint amountIn, uint taxFee) external virtual gasTokenRefund{\r\n        require(whiteList[msg.sender], \"not on the white list\");\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = tokenA;\r\n        _path[1] = tokenB;\r\n        uint[] memory amounts = getAmountsOut(_router, amountIn, _path);\r\n        uint buyExpectedOut = amounts[1];\r\n        //buy\r\n        address pairAddress = getPair(_router, tokenA, tokenB);\r\n        TransferHelper.safeTransfer(tokenA, pairAddress, amountIn);\r\n        address token0 = tokenA < tokenB ? tokenA : tokenB;\r\n        (uint amount0Out, uint amount1Out) = tokenA == token0 ? (uint(0), amounts[1]) : (amounts[1], uint(0));\r\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n        //check buyTax\r\n        uint buyActualOut = IERC20(tokenB).balanceOf(address(this));\r\n        require(buyActualOut >= buyExpectedOut.sub(buyExpectedOut.mul(taxFee).div(10**2)), \"buy tax too big\");\r\n        //sell\r\n        uint sellToken = buyActualOut.div(100);//\u5356\u51fa\u767e\u5206\u4e4b1\r\n        //\u81ea\u5df1\u8f6c\u7ed9\u81ea\u5df1\u9a8c\u8bc1\u662f\u5426\u88ab\u62c9\u9ed1\u4ee5\u53ca\u9a8c\u8bc1\u7a0e(\u6709\u4e9b\u5e01\u8f6c\u8d26\u4f1a\u6263\u7a0e)\r\n        TransferHelper.safeTransfer(tokenB, address(this), sellToken);\r\n        require(sellToken.mul(taxFee).div(10**2) >= buyActualOut.sub(IERC20(tokenB).balanceOf(address(this))), \"sell tax too big\");\r\n    }\r\n\r\n    function fastBuy(address _router, address tokenA, address tokenB, uint amountIn) external virtual gasTokenRefund{\r\n        require(whiteList[msg.sender], \"not on the white list\");\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = tokenA;\r\n        _path[1] = tokenB;\r\n        uint[] memory amounts = getAmountsOut(_router, amountIn, _path);\r\n        address pairAddress = getPair(_router, tokenA, tokenB);\r\n        TransferHelper.safeTransfer(tokenA, pairAddress, amountIn);\r\n        address token0 = tokenA < tokenB ? tokenA : tokenB;\r\n        (uint amount0Out, uint amount1Out) = tokenA == token0 ? (uint(0), amounts[1]) : (amounts[1], uint(0));\r\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    function fastSell(address _router, address tokenA, address tokenB, uint amountIn) external virtual gasTokenRefund{\r\n        require(whiteList[msg.sender], \"not on the white list\");\r\n        require(IERC20(tokenA).balanceOf(address(this)) > 0, \"token not buy\");\r\n        address pairAddress = getPair(_router, tokenA, tokenB);\r\n        TransferHelper.safeTransfer(tokenA, pairAddress, amountIn);\r\n        (uint reserveInput, uint reserveOutput) = getReserves(_router, tokenA, tokenB);\r\n        uint amountInput = IERC20(tokenA).balanceOf(address(pairAddress)).sub(reserveInput);\r\n        uint amountOutput = getAmountOut(_router, amountInput, reserveInput, reserveOutput); \r\n        address token0 = tokenA < tokenB ? tokenA : tokenB;\r\n        (uint amount0Out, uint amount1Out) = tokenA == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    function fastSellAll(address _router, address tokenA, address tokenB) external virtual gasTokenRefund{\r\n        require(whiteList[msg.sender], \"not on the white list\");\r\n        uint256 balance = IERC20(tokenA).balanceOf(address(this));\r\n        require(balance > 0, \"token not buy\");\r\n        address pairAddress = getPair(_router, tokenA, tokenB);\r\n        TransferHelper.safeTransfer(tokenA, pairAddress, balance);\r\n        (uint reserveInput, uint reserveOutput) = getReserves(_router, tokenA, tokenB);\r\n        uint amountInput = IERC20(tokenA).balanceOf(address(pairAddress)).sub(reserveInput);\r\n        uint amountOutput = getAmountOut(_router, amountInput, reserveInput, reserveOutput); \r\n        address token0 = tokenA < tokenB ? tokenA : tokenB;\r\n        (uint amount0Out, uint amount1Out) = tokenA == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    function testBuy(address _router, address tokenA, address tokenB, uint amountIn) internal virtual {\r\n        address token0 = tokenA < tokenB ? tokenA : tokenB;\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = tokenA;\r\n        _path[1] = tokenB;\r\n        address pairAddress = getPair(_router, tokenA, tokenB);\r\n        uint[] memory amounts = getAmountsOut(_router, amountIn, _path);\r\n        TransferHelper.safeTransfer(tokenA, pairAddress, amountIn);\r\n        (uint amount0Out, uint amount1Out) = tokenA == token0 ? (uint(0), amounts[1]) : (amounts[1], uint(0));\r\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    function testSellAll(address _router, address tokenA, address tokenB) internal virtual {\r\n        uint256 balance = IERC20(tokenA).balanceOf(address(this));\r\n        require(balance > 0, \"token not buy\");\r\n        address token0 = tokenA < tokenB ? tokenA : tokenB;\r\n        address pairAddress = getPair(_router, tokenA, tokenB);\r\n        TransferHelper.safeTransfer(tokenA, pairAddress, balance);\r\n        (uint reserveInput, uint reserveOutput) = getReserves(_router, tokenA, tokenB);\r\n        uint amountInput = IERC20(tokenA).balanceOf(address(pairAddress)).sub(reserveInput);\r\n        uint amountOutput = getAmountOut(_router, amountInput, reserveInput, reserveOutput); \r\n        (uint amount0Out, uint amount1Out) = tokenA == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n  \r\n    //------------------calcTool----------------------\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DEV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"checkHoneypots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"decimal\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"fastBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxFee\",\"type\":\"uint256\"}],\"name\":\"fastBuyCheckHoneypots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"fastSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"fastSellAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserveInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targetPath\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_targetRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_targetAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tradeType\",\"type\":\"uint256\"}],\"name\":\"getTradePriceImpact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceImpact\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintChiToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendBnbBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendTokenBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sendTokenBackAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setWhite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FengshuAllRouter", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c92b50535536e91dbcedecae56b9d38623b921dcdcf48bdd36b42982e3e716fa"}