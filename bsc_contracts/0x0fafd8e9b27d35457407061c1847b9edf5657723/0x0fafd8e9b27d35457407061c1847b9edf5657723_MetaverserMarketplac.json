{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/MetaverserMarketplaceV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\r\\n\\r\\ncontract MetaverserMarketplaceV2 is ReentrancyGuard {\\r\\n    constructor(address _MTVT, address _NFT) {\\r\\n        // Open the marketplace\\r\\n        isClosed = false;\\r\\n\\r\\n        // Set MTVT address\\r\\n        MTVT = _MTVT;\\r\\n\\r\\n        // Set NFT address\\r\\n        NFT = _NFT;\\r\\n\\r\\n        // Add admins\\r\\n        isAdmin[msg.sender] = true;\\r\\n        emit AdminSet(msg.sender, true);\\r\\n\\r\\n        // 0 index is used to represent null listing\\r\\n        listings[0] = Listing(address(0), 0, 0, 0, false, 0);\\r\\n        emit ListingCreated(0, address(0), 0, 0, 0);\\r\\n    }\\r\\n\\r\\n    // Structs\\r\\n\\r\\n    struct Listing {\\r\\n        address seller;\\r\\n        uint256 listId;\\r\\n        uint256 tokenId;\\r\\n        uint256 price;\\r\\n        bool active;\\r\\n        uint256 expiryDate;\\r\\n    }\\r\\n\\r\\n    // Storage\\r\\n\\r\\n    bool public isClosed;\\r\\n\\r\\n    address public immutable MTVT;\\r\\n    address public immutable NFT;\\r\\n\\r\\n    mapping(uint256 => Listing) private listings;\\r\\n    mapping(address => uint256[]) private sellerListings;\\r\\n    mapping(uint256 => bool) private isListed;\\r\\n\\r\\n    mapping(address => bool) private isAdmin;\\r\\n    uint256 public nextListingId = 1;\\r\\n\\r\\n    uint256 public totalRoyaltyAmount;\\r\\n    mapping(address => uint256) royaltyAmounts;\\r\\n\\r\\n    // Modifiers\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(\\r\\n            isAdmin[msg.sender],\\r\\n            \\\"Marketplace: Only admin can call this function\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // External functions\\r\\n\\r\\n    // Function to list a token for sale\\r\\n    // @dev _expiryDate is optional (0 means no expiry date)\\r\\n    function listForSale(\\r\\n        uint256 _tokenId,\\r\\n        uint256 _price,\\r\\n        uint256 _expiryDate\\r\\n    ) external {\\r\\n        require(!isClosed, \\\"Marketplace: Marketplace is closed\\\");\\r\\n        require(\\r\\n            IERC721(NFT).ownerOf(_tokenId) == msg.sender,\\r\\n            \\\"Marketplace: You are not the owner\\\"\\r\\n        );\\r\\n        require(\\r\\n            IERC721(NFT).isApprovedForAll(msg.sender, address(this)) ||\\r\\n                IERC721(NFT).getApproved(_tokenId) == address(this),\\r\\n            \\\"Marketplace: Approve first\\\"\\r\\n        );\\r\\n        require(\\r\\n            _expiryDate >= block.timestamp || _expiryDate == 0,\\r\\n            \\\"Marketplace: Invalid expiry date\\\"\\r\\n        );\\r\\n        require(!isListed[_tokenId], \\\"Marketplace: Token already listed!\\\");\\r\\n\\r\\n        listings[nextListingId] = Listing(\\r\\n            msg.sender,\\r\\n            nextListingId,\\r\\n            _tokenId,\\r\\n            _price,\\r\\n            true,\\r\\n            (_expiryDate == 0 ? type(uint256).max : _expiryDate)\\r\\n        );\\r\\n\\r\\n        sellerListings[msg.sender].push(nextListingId);\\r\\n        isListed[_tokenId] = true;\\r\\n\\r\\n        emit ListingCreated(\\r\\n            nextListingId,\\r\\n            msg.sender,\\r\\n            _price,\\r\\n            _expiryDate,\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        nextListingId++;\\r\\n    }\\r\\n\\r\\n    // Function to buy a listed token\\r\\n    // @dev prior approval is required for the marketplace contract to spend MTVT on behalf of the buyer\\r\\n    // @dev respects erc2981 royalty standard\\r\\n    function buy(uint256 _listingId) external nonReentrant {\\r\\n        require(!isClosed, \\\"Marketplace: Marketplace is closed\\\");\\r\\n        Listing storage listing = listings[_listingId];\\r\\n        require(\\r\\n            listing.expiryDate > block.timestamp,\\r\\n            \\\"Marketplace: Listing expired\\\"\\r\\n        );\\r\\n        require(_isValid(_listingId), \\\"Marketplace: Invalid listing\\\");\\r\\n        require(\\r\\n            listing.price <= IERC20(MTVT).balanceOf(msg.sender),\\r\\n            \\\"Marketplace: Insufficient funds\\\"\\r\\n        );\\r\\n\\r\\n        IERC721(NFT).safeTransferFrom(\\r\\n            listing.seller,\\r\\n            msg.sender,\\r\\n            listing.tokenId\\r\\n        );\\r\\n\\r\\n        (address royaltyReceiver, uint256 royaltyAmount) = IERC2981(NFT)\\r\\n            .royaltyInfo(listing.tokenId, listing.price);\\r\\n\\r\\n        if (royaltyReceiver != address(0) && royaltyAmount > 0) {\\r\\n            totalRoyaltyAmount += royaltyAmount;\\r\\n            royaltyAmounts[royaltyReceiver] += royaltyAmount;\\r\\n            IERC20(MTVT).transferFrom(\\r\\n                msg.sender,\\r\\n                royaltyReceiver,\\r\\n                royaltyAmount\\r\\n            );\\r\\n            IERC20(MTVT).transferFrom(\\r\\n                msg.sender,\\r\\n                listing.seller,\\r\\n                listing.price - royaltyAmount\\r\\n            );\\r\\n        } else {\\r\\n            IERC20(MTVT).transferFrom(\\r\\n                msg.sender,\\r\\n                listing.seller,\\r\\n                listing.price\\r\\n            );\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < sellerListings[listing.seller].length; i++) {\\r\\n            if (sellerListings[listing.seller][i] == _listingId) {\\r\\n                sellerListings[listing.seller][i] = sellerListings[\\r\\n                    listing.seller\\r\\n                ][sellerListings[listing.seller].length - 1];\\r\\n                sellerListings[listing.seller].pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        listing.active = false;\\r\\n        isListed[listing.tokenId] = false;\\r\\n\\r\\n        emit ListingBought(\\r\\n            _listingId,\\r\\n            msg.sender,\\r\\n            listing.seller,\\r\\n            listing.price,\\r\\n            listing.tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deleteListing(uint256 _listingId) external nonReentrant {\\r\\n        require(!isClosed, \\\"Marketplace: Marketplace is closed\\\");\\r\\n        Listing storage listing = listings[_listingId];\\r\\n        require(\\r\\n            listing.seller == msg.sender,\\r\\n            \\\"Marketplace: You are not the seller\\\"\\r\\n        );\\r\\n        listings[_listingId].active = false;\\r\\n\\r\\n        for (uint256 i = 0; i < sellerListings[msg.sender].length; i++) {\\r\\n            if (sellerListings[msg.sender][i] == _listingId) {\\r\\n                sellerListings[msg.sender][i] = sellerListings[msg.sender][\\r\\n                    sellerListings[msg.sender].length - 1\\r\\n                ];\\r\\n                sellerListings[msg.sender].pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        isListed[listing.tokenId] = false;\\r\\n\\r\\n        emit ListingDeleted(_listingId);\\r\\n    }\\r\\n\\r\\n    function changeExpiryDate(\\r\\n        uint256 _listingId,\\r\\n        uint256 _newExpiryDate\\r\\n    ) external {\\r\\n        require(!isClosed, \\\"Marketplace: Marketplace is closed\\\");\\r\\n        Listing storage listing = listings[_listingId];\\r\\n        require(listing.seller == msg.sender, \\\"Marketplace: Not your listing\\\");\\r\\n        require(\\r\\n            _newExpiryDate >= block.timestamp,\\r\\n            \\\"Marketplace: Invalid new expiry date\\\"\\r\\n        );\\r\\n        require(_isValid(_listingId), \\\"Marketplace: Invalid listing\\\");\\r\\n        listing.expiryDate = _newExpiryDate;\\r\\n\\r\\n        emit ExpiryDateChanged(_listingId, _newExpiryDate);\\r\\n    }\\r\\n\\r\\n    function changePrice(uint256 _listingId, uint256 _newPrice) external {\\r\\n        require(!isClosed, \\\"Marketplace: Marketplace is closed\\\");\\r\\n        Listing storage listing = listings[_listingId];\\r\\n        require(listing.seller == msg.sender, \\\"Marketplace: Not your listing\\\");\\r\\n        require(_isValid(_listingId), \\\"Marketplace: Invalid listing\\\");\\r\\n        listing.price = _newPrice;\\r\\n\\r\\n        emit PriceChanged(_listingId, _newPrice);\\r\\n    }\\r\\n\\r\\n    // Admin functions\\r\\n\\r\\n    function setAdmin(address _admin, bool _isAdmin) external onlyAdmin {\\r\\n        require(isAdmin[_admin] != _isAdmin, \\\"Marketplace: Invalid input\\\");\\r\\n        isAdmin[_admin] = _isAdmin;\\r\\n\\r\\n        emit AdminSet(_admin, _isAdmin);\\r\\n    }\\r\\n\\r\\n    function closeMarketplace() external onlyAdmin {\\r\\n        require(!isClosed, \\\"Marketplace: Marketplace is already closed\\\");\\r\\n        isClosed = true;\\r\\n    }\\r\\n\\r\\n    function openMarketplace() external onlyAdmin {\\r\\n        require(isClosed, \\\"Marketplace: Marketplace is already open\\\");\\r\\n        isClosed = false;\\r\\n    }\\r\\n\\r\\n    // View functions\\r\\n\\r\\n    function getAllListings() external view returns (uint256[] memory) {\\r\\n        uint256[] memory validListings = new uint256[](nextListingId - 1);\\r\\n        uint256 validListingCount = 0;\\r\\n\\r\\n        for (uint256 i = 1; i < nextListingId; i++) {\\r\\n            if (_isValid(i)) {\\r\\n                validListings[validListingCount] = i;\\r\\n                validListingCount++;\\r\\n            }\\r\\n            if (gasleft() < 10000) {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256[] memory result = new uint256[](validListingCount);\\r\\n        for (uint256 i = 0; i < validListingCount; i++) {\\r\\n            result[i] = validListings[i];\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getAllListingsBySeller(\\r\\n        address _seller\\r\\n    ) external view returns (Listing[] memory) {\\r\\n        uint256[] memory validListings = new uint256[](\\r\\n            sellerListings[_seller].length\\r\\n        );\\r\\n        uint256 validListingCount = 0;\\r\\n\\r\\n        for (uint256 i = 0; i < sellerListings[_seller].length; i++) {\\r\\n            uint256 listingId = sellerListings[_seller][i];\\r\\n            if (_isValid(listingId)) {\\r\\n                validListings[validListingCount] = listingId;\\r\\n                validListingCount++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Listing[] memory result = new Listing[](validListingCount);\\r\\n        for (uint256 i = 0; i < validListingCount; i++) {\\r\\n            result[i] = _getListingById(validListings[i]);\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getListingByIds(\\r\\n        uint256[] calldata _listingIds\\r\\n    ) external view returns (Listing[] memory) {\\r\\n        Listing[] memory result = new Listing[](_listingIds.length);\\r\\n\\r\\n        for (uint256 i = 0; i < _listingIds.length; i++) {\\r\\n            result[i] = _getListingById(_listingIds[i]);\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getListingByRanges(\\r\\n        uint256 _from,\\r\\n        uint256 _to\\r\\n    ) external view returns (Listing[] memory) {\\r\\n        Listing[] memory validListings = new Listing[](_to - _from + 1);\\r\\n        uint256 validListingCount = 0;\\r\\n\\r\\n        for (uint256 i = _from; i <= _to; i++) {\\r\\n            if (_isValid(i)) {\\r\\n                validListings[validListingCount] = _getListingById(i);\\r\\n                validListingCount++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Listing[] memory result = new Listing[](validListingCount);\\r\\n\\r\\n        for (uint256 i = 0; i < validListingCount; i++) {\\r\\n            result[i] = validListings[i];\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getListingById(\\r\\n        uint256 _listingId\\r\\n    ) external view returns (Listing memory) {\\r\\n        return _getListingById(_listingId);\\r\\n    }\\r\\n\\r\\n    function getRoyaltyAmount(\\r\\n        address _receiver\\r\\n    ) external view returns (uint256) {\\r\\n        return royaltyAmounts[_receiver];\\r\\n    }\\r\\n\\r\\n    // Internal view functions\\r\\n\\r\\n    function _getListingById(\\r\\n        uint256 _listingId\\r\\n    ) internal view returns (Listing memory) {\\r\\n        Listing memory listing = listings[_listingId];\\r\\n        return listing;\\r\\n    }\\r\\n\\r\\n    function _isValid(uint256 listingId) internal view returns (bool) {\\r\\n        Listing memory listing = listings[listingId];\\r\\n        IERC721 token = IERC721(NFT);\\r\\n\\r\\n        return ((token.getApproved(listing.tokenId) == address(this) ||\\r\\n            token.isApprovedForAll(listing.seller, address(this))) &&\\r\\n            token.ownerOf(listing.tokenId) == listing.seller &&\\r\\n            listing.active &&\\r\\n            listing.expiryDate > block.timestamp);\\r\\n    }\\r\\n\\r\\n    // Events\\r\\n\\r\\n    event ListingCreated(\\r\\n        uint256 indexed listingId,\\r\\n        address indexed seller,\\r\\n        uint256 price,\\r\\n        uint256 expiryDate,\\r\\n        uint256 tokenId\\r\\n    );\\r\\n\\r\\n    event ListingDeleted(uint256 indexed listingId);\\r\\n\\r\\n    event ListingBought(\\r\\n        uint256 indexed listingId,\\r\\n        address indexed buyer,\\r\\n        address indexed seller,\\r\\n        uint256 price,\\r\\n        uint256 tokenId\\r\\n    );\\r\\n\\r\\n    event ExpiryDateChanged(uint256 indexed listingId, uint256 newExpiryDate);\\r\\n\\r\\n    event PriceChanged(uint256 indexed listingId, uint256 newPrice);\\r\\n\\r\\n    event AdminSet(address indexed admin, bool isAdmin);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_MTVT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"AdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExpiryDate\",\"type\":\"uint256\"}],\"name\":\"ExpiryDateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ListingBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ListingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"}],\"name\":\"ListingDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MTVT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_listingId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_listingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newExpiryDate\",\"type\":\"uint256\"}],\"name\":\"changeExpiryDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_listingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"changePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeMarketplace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_listingId\",\"type\":\"uint256\"}],\"name\":\"deleteListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllListings\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"getAllListingsBySeller\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetaverserMarketplaceV2.Listing[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_listingId\",\"type\":\"uint256\"}],\"name\":\"getListingById\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetaverserMarketplaceV2.Listing\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_listingIds\",\"type\":\"uint256[]\"}],\"name\":\"getListingByIds\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetaverserMarketplaceV2.Listing[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getListingByRanges\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetaverserMarketplaceV2.Listing[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"getRoyaltyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryDate\",\"type\":\"uint256\"}],\"name\":\"listForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextListingId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openMarketplace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRoyaltyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MetaverserMarketplaceV2", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b92c5e0135a510a4a3a8803f143d2cb085bbaf73000000000000000000000000c8cfe3c271aff0419f1bcad88b2b8264462e7bee", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}