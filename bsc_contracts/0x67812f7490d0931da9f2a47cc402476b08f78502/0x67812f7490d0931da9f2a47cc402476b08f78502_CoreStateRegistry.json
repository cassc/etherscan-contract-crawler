{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.23;\r\n\r\n/// @dev contains all the common struct and enums used for data communication between chains.\r\n\r\n/// @dev There are two transaction types in Superform Protocol\r\nenum TransactionType {\r\n    DEPOSIT,\r\n    WITHDRAW\r\n}\r\n\r\n/// @dev Message types can be INIT, RETURN (for successful Deposits) and FAIL (for failed withdraws)\r\nenum CallbackType {\r\n    INIT,\r\n    RETURN,\r\n    FAIL\r\n}\r\n\r\n/// @dev Payloads are stored, updated (deposits) or processed (finalized)\r\nenum PayloadState {\r\n    STORED,\r\n    UPDATED,\r\n    PROCESSED\r\n}\r\n\r\n/// @dev contains all the common struct used for interchain token transfers.\r\nstruct LiqRequest {\r\n    /// @dev generated data\r\n    bytes txData;\r\n    /// @dev input token for deposits, desired output token on target liqDstChainId for withdraws. Must be set for\r\n    /// txData to be updated on destination for withdraws\r\n    address token;\r\n    /// @dev intermediary token on destination. Relevant for xChain deposits where a destination swap is needed for\r\n    /// validation purposes\r\n    address interimToken;\r\n    /// @dev what bridge to use to move tokens\r\n    uint8 bridgeId;\r\n    /// @dev dstChainId = liqDstchainId for deposits. For withdraws it is the target chain id for where the underlying\r\n    /// is to be delivered\r\n    uint64 liqDstChainId;\r\n    /// @dev currently this amount is used as msg.value in the txData call.\r\n    uint256 nativeAmount;\r\n}\r\n\r\n/// @dev main struct that holds required multi vault data for an action\r\nstruct MultiVaultSFData {\r\n    // superformids must have same destination. Can have different underlyings\r\n    uint256[] superformIds;\r\n    uint256[] amounts; // on deposits, amount of token to deposit on dst, on withdrawals, superpositions to burn\r\n    uint256[] outputAmounts; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\r\n    uint256[] maxSlippages;\r\n    LiqRequest[] liqRequests; // if length = 1; amount = sum(amounts) | else  amounts must match the amounts being sent\r\n    bytes permit2data;\r\n    bool[] hasDstSwaps;\r\n    bool[] retain4626s; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\r\n    address receiverAddress;\r\n    /// this address must always be an EOA otherwise funds may be lost\r\n    address receiverAddressSP;\r\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\r\n    bytes extraFormData; // extraFormData\r\n}\r\n\r\n/// @dev main struct that holds required single vault data for an action\r\nstruct SingleVaultSFData {\r\n    // superformids must have same destination. Can have different underlyings\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 outputAmount; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\r\n    uint256 maxSlippage;\r\n    LiqRequest liqRequest; // if length = 1; amount = sum(amounts)| else  amounts must match the amounts being sent\r\n    bytes permit2data;\r\n    bool hasDstSwap;\r\n    bool retain4626; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\r\n    address receiverAddress;\r\n    /// this address must always be an EOA otherwise funds may be lost\r\n    address receiverAddressSP;\r\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\r\n    bytes extraFormData; // extraFormData\r\n}\r\n\r\n/// @dev overarching struct for multiDst requests with multi vaults\r\nstruct MultiDstMultiVaultStateReq {\r\n    uint8[][] ambIds;\r\n    uint64[] dstChainIds;\r\n    MultiVaultSFData[] superformsData;\r\n}\r\n\r\n/// @dev overarching struct for single cross chain requests with multi vaults\r\nstruct SingleXChainMultiVaultStateReq {\r\n    uint8[] ambIds;\r\n    uint64 dstChainId;\r\n    MultiVaultSFData superformsData;\r\n}\r\n\r\n/// @dev overarching struct for multiDst requests with single vaults\r\nstruct MultiDstSingleVaultStateReq {\r\n    uint8[][] ambIds;\r\n    uint64[] dstChainIds;\r\n    SingleVaultSFData[] superformsData;\r\n}\r\n\r\n/// @dev overarching struct for single cross chain requests with single vaults\r\nstruct SingleXChainSingleVaultStateReq {\r\n    uint8[] ambIds;\r\n    uint64 dstChainId;\r\n    SingleVaultSFData superformData;\r\n}\r\n\r\n/// @dev overarching struct for single direct chain requests with single vaults\r\nstruct SingleDirectSingleVaultStateReq {\r\n    SingleVaultSFData superformData;\r\n}\r\n\r\n/// @dev overarching struct for single direct chain requests with multi vaults\r\nstruct SingleDirectMultiVaultStateReq {\r\n    MultiVaultSFData superformData;\r\n}\r\n\r\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\r\n/// @dev realize that receiverAddressSP is not passed, only needed on source chain to mint\r\nstruct InitMultiVaultData {\r\n    uint256 payloadId;\r\n    uint256[] superformIds;\r\n    uint256[] amounts;\r\n    uint256[] outputAmounts;\r\n    uint256[] maxSlippages;\r\n    LiqRequest[] liqData;\r\n    bool[] hasDstSwaps;\r\n    bool[] retain4626s;\r\n    address receiverAddress;\r\n    bytes extraFormData;\r\n}\r\n\r\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\r\nstruct InitSingleVaultData {\r\n    uint256 payloadId;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 outputAmount;\r\n    uint256 maxSlippage;\r\n    LiqRequest liqData;\r\n    bool hasDstSwap;\r\n    bool retain4626;\r\n    address receiverAddress;\r\n    bytes extraFormData;\r\n}\r\n\r\n/// @dev struct for Emergency Queue\r\nstruct QueuedWithdrawal {\r\n    address receiverAddress;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n    uint256 srcPayloadId;\r\n    bool isProcessed;\r\n}\r\n\r\n/// @dev all statuses of the timelock payload\r\nenum TimelockStatus {\r\n    UNAVAILABLE,\r\n    PENDING,\r\n    PROCESSED\r\n}\r\n\r\n/// @dev holds information about the timelock payload\r\nstruct TimelockPayload {\r\n    uint8 isXChain;\r\n    uint64 srcChainId;\r\n    uint256 lockedTill;\r\n    InitSingleVaultData data;\r\n    TimelockStatus status;\r\n}\r\n\r\n/// @dev struct that contains the type of transaction, callback flags and other identification, as well as the vaults\r\n/// data in params\r\nstruct AMBMessage {\r\n    uint256 txInfo; // tight packing of  TransactionType txType,  CallbackType flag  if multi/single vault, registry id,\r\n        // srcSender and srcChainId\r\n    bytes params; // decoding txInfo will point to the right datatype of params. Refer PayloadHelper.sol\r\n}\r\n\r\n/// @dev struct that contains the information required for broadcasting changes\r\nstruct BroadcastMessage {\r\n    bytes target;\r\n    bytes32 messageType;\r\n    bytes message;\r\n}\r\n\r\n/// @dev struct that contains info on returned data from destination\r\nstruct ReturnMultiData {\r\n    uint256 payloadId;\r\n    uint256[] superformIds;\r\n    uint256[] amounts;\r\n}\r\n\r\n/// @dev struct that contains info on returned data from destination\r\nstruct ReturnSingleData {\r\n    uint256 payloadId;\r\n    uint256 superformId;\r\n    uint256 amount;\r\n}\r\n\r\n/// @dev struct that contains the data on the fees to pay to the AMBs\r\nstruct AMBExtraData {\r\n    uint256[] gasPerAMB;\r\n    bytes[] extraDataPerAMB;\r\n}\r\n\r\n/// @dev struct that contains the data on the fees to pay to the AMBs on broadcasts\r\nstruct BroadCastAMBExtraData {\r\n    uint256[] gasPerDst;\r\n    bytes[] extraDataPerDst;\r\n}\r\n\r\n/// @title IBaseStateRegistry\r\n/// @dev Interface for BaseStateRegistry\r\n/// @author ZeroPoint Labs\r\ninterface IBaseStateRegistry {\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a cross-chain payload is received in the state registry\r\n    event PayloadReceived(uint64 indexed srcChainId, uint64 indexed dstChainId, uint256 indexed payloadId);\r\n\r\n    /// @dev is emitted when a cross-chain proof is received in the state registry\r\n    /// NOTE: comes handy if quorum required is more than 0\r\n    event ProofReceived(bytes indexed proof);\r\n\r\n    /// @dev is emitted when a payload id gets updated\r\n    event PayloadUpdated(uint256 indexed payloadId);\r\n\r\n    /// @dev is emitted when a payload id gets processed\r\n    event PayloadProcessed(uint256 indexed payloadId);\r\n\r\n    /// @dev is emitted when the super registry address is updated\r\n    event SuperRegistryUpdated(address indexed superRegistry);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows users to read the total payloads received by the registry\r\n    function payloadsCount() external view returns (uint256);\r\n\r\n    /// @dev allows user to read the payload state\r\n    /// uint256 payloadId_ is the unique payload identifier allocated on the destination chain\r\n    function payloadTracking(uint256 payloadId_) external view returns (PayloadState payloadState_);\r\n\r\n    /// @dev allows users to read the bytes payload_ stored per payloadId_\r\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\r\n    /// @return payloadBody_ the crosschain data received\r\n    function payloadBody(uint256 payloadId_) external view returns (bytes memory payloadBody_);\r\n\r\n    /// @dev allows users to read the uint256 payloadHeader stored per payloadId_\r\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\r\n    /// @return payloadHeader_ the crosschain header received\r\n    function payloadHeader(uint256 payloadId_) external view returns (uint256 payloadHeader_);\r\n\r\n    /// @dev allows users to read the ambs that delivered the payload id\r\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\r\n    /// @return ambIds_ is the identifier of ambs that delivered the message and proof\r\n    function getMessageAMB(uint256 payloadId_) external view returns (uint8[] memory ambIds_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows core contracts to send payload to a destination chain.\r\n    /// @param srcSender_ is the caller of the function (used for gas refunds).\r\n    /// @param ambIds_ is the identifier of the arbitrary message bridge to be used\r\n    /// @param dstChainId_ is the internal chainId used throughout the protocol\r\n    /// @param message_ is the crosschain payload to be sent\r\n    /// @param extraData_ defines all the message bridge related overrides\r\n    /// NOTE: dstChainId_ is mapped to message bridge's destination id inside it's implementation contract\r\n    /// NOTE: ambIds_ are superform assigned unique identifier for arbitrary message bridges\r\n    function dispatchPayload(\r\n        address srcSender_,\r\n        uint8[] memory ambIds_,\r\n        uint64 dstChainId_,\r\n        bytes memory message_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable;\r\n\r\n    /// @dev allows state registry to receive messages from message bridge implementations\r\n    /// @param srcChainId_ is the superform chainId from which the payload is dispatched/sent\r\n    /// @param message_ is the crosschain payload received\r\n    /// NOTE: Only {IMPLEMENTATION_CONTRACT} role can call this function.\r\n    function receivePayload(uint64 srcChainId_, bytes memory message_) external;\r\n\r\n    /// @dev allows privileged actors to process cross-chain payloads\r\n    /// @param payloadId_ is the identifier of the cross-chain payload\r\n    /// NOTE: Only {CORE_STATE_REGISTRY_PROCESSOR_ROLE} role can call this function\r\n    /// NOTE: this should handle reverting the state on source chain in-case of failure\r\n    /// (or) can implement scenario based reverting like in coreStateRegistry\r\n    function processPayload(uint256 payloadId_) external payable;\r\n}\r\n\r\n/// @title IAmbImplementation\r\n/// @dev Interface for arbitrary message bridge (AMB) implementations\r\n/// @author ZeroPoint Labs\r\ninterface IAmbImplementation {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    event ChainAdded(uint64 indexed superChainId);\r\n    event AuthorizedImplAdded(uint64 indexed superChainId, address indexed authImpl);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the gas fees estimation in native tokens\r\n    /// @notice not all AMBs will have on-chain estimation for which this function will return 0\r\n    /// @param dstChainId_ is the identifier of the destination chain\r\n    /// @param message_ is the cross-chain message\r\n    /// @param extraData_ is any amb-specific information\r\n    /// @return fees is the native_tokens to be sent along the transaction\r\n    function estimateFees(\r\n        uint64 dstChainId_,\r\n        bytes memory message_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 fees);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows state registry to send message via implementation.\r\n    /// @param srcSender_ is the caller (used for gas refunds)\r\n    /// @param dstChainId_ is the identifier of the destination chain\r\n    /// @param message_ is the cross-chain message to be sent\r\n    /// @param extraData_ is message amb specific override information\r\n    function dispatchPayload(\r\n        address srcSender_,\r\n        uint64 dstChainId_,\r\n        bytes memory message_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable;\r\n\r\n    /// @dev allows for the permissionless calling of the retry mechanism for encoded data\r\n    /// @param data_ is the encoded retry data (different per AMB implementation)\r\n    function retryPayload(bytes memory data_) external payable;\r\n}\r\n\r\n/// @title IQuorumManager\r\n/// @dev Interface for QuorumManager\r\n/// @author ZeroPoint Labs\r\ninterface IQuorumManager {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                           //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev emitted when a new quorum is set for a specific chain\r\n    /// @param srcChainId the chain id from which the message (payload) is sent\r\n    /// @param quorum the minimum number of message bridges required for processing\r\n    event QuorumSet(uint64 indexed srcChainId, uint256 indexed quorum);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the required quorum for the srcChain & dstChain\r\n    /// @param srcChainId_ is the chain id from which the message (payload) is sent\r\n    /// @return quorum_ the minimum number of message bridges required for processing\r\n    function getRequiredMessagingQuorum(uint64 srcChainId_) external view returns (uint256 quorum_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows inheriting contracts to set the messaging quorum for a specific sender chain\r\n    /// @notice quorum is the number of extra ambs a message proof must go through and be validated\r\n    /// @param srcChainId_ is the chain id from which the message (payload) is sent\r\n    /// @param quorum_ the minimum number of message bridges required for processing\r\n    /// NOTE: overriding child contracts should handle the sender validation & setting of message quorum\r\n    function setRequiredMessagingQuorum(uint64 srcChainId_, uint256 quorum_) external;\r\n}\r\n\r\n/// @title ISuperRegistry\r\n/// @dev Interface for SuperRegistry\r\n/// @author Zeropoint Labs\r\ninterface ISuperRegistry {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev emitted when permit2 is set.\r\n    event SetPermit2(address indexed permit2);\r\n\r\n    /// @dev is emitted when an address is set.\r\n    event AddressUpdated(\r\n        bytes32 indexed protocolAddressId, uint64 indexed chainId, address indexed oldAddress, address newAddress\r\n    );\r\n\r\n    /// @dev is emitted when a new token bridge is configured.\r\n    event SetBridgeAddress(uint256 indexed bridgeId, address indexed bridgeAddress);\r\n\r\n    /// @dev is emitted when a new bridge validator is configured.\r\n    event SetBridgeValidator(uint256 indexed bridgeId, address indexed bridgeValidator);\r\n\r\n    /// @dev is emitted when a new amb is configured.\r\n    event SetAmbAddress(uint8 indexed ambId_, address indexed ambAddress_, bool indexed isBroadcastAMB_);\r\n\r\n    /// @dev is emitted when a new state registry is configured.\r\n    event SetStateRegistryAddress(uint8 indexed registryId_, address indexed registryAddress_);\r\n\r\n    /// @dev is emitted when a new delay is configured.\r\n    event SetDelay(uint256 indexed oldDelay_, uint256 indexed newDelay_);\r\n\r\n    /// @dev is emitted when a new vault limit is configured\r\n    event SetVaultLimitPerDestination(uint64 indexed chainId_, uint256 indexed vaultLimit_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev gets the deposit rescue delay\r\n    function delay() external view returns (uint256);\r\n\r\n    /// @dev returns the permit2 address\r\n    function PERMIT2() external view returns (address);\r\n\r\n    /// @dev returns the id of the superform router module\r\n    function SUPERFORM_ROUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform factory module\r\n    function SUPERFORM_FACTORY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform transmuter\r\n    function SUPER_TRANSMUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform paymaster contract\r\n    function PAYMASTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform payload helper contract\r\n    function PAYMENT_HELPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry module\r\n    function CORE_STATE_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the timelock form state registry module\r\n    function TIMELOCK_STATE_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcast state registry module\r\n    function BROADCAST_REGISTRY() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the super positions module\r\n    function SUPER_POSITIONS() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the super rbac module\r\n    function SUPER_RBAC() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the payload helper module\r\n    function PAYLOAD_HELPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the dst swapper keeper\r\n    function DST_SWAPPER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the emergency queue\r\n    function EMERGENCY_QUEUE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the superform receiver\r\n    function SUPERFORM_RECEIVER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the payment admin keeper\r\n    function PAYMENT_ADMIN() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry processor keeper\r\n    function CORE_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcast registry processor keeper\r\n    function BROADCAST_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the timelock form state registry processor keeper\r\n    function TIMELOCK_REGISTRY_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_UPDATER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_RESCUER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function CORE_REGISTRY_DISPUTER() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater keeper\r\n    function DST_SWAPPER_PROCESSOR() external view returns (bytes32);\r\n\r\n    /// @dev gets the address of a contract on current chain\r\n    /// @param id_ is the id of the contract\r\n    function getAddress(bytes32 id_) external view returns (address);\r\n\r\n    /// @dev gets the address of a contract on a target chain\r\n    /// @param id_ is the id of the contract\r\n    /// @param chainId_ is the chain id of that chain\r\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view returns (address);\r\n\r\n    /// @dev gets the address of a bridge\r\n    /// @param bridgeId_ is the id of a bridge\r\n    /// @return bridgeAddress_ is the address of the form\r\n    function getBridgeAddress(uint8 bridgeId_) external view returns (address bridgeAddress_);\r\n\r\n    /// @dev gets the address of a bridge validator\r\n    /// @param bridgeId_ is the id of a bridge\r\n    /// @return bridgeValidator_ is the address of the form\r\n    function getBridgeValidator(uint8 bridgeId_) external view returns (address bridgeValidator_);\r\n\r\n    /// @dev gets the address of a amb\r\n    /// @param ambId_ is the id of a bridge\r\n    /// @return ambAddress_ is the address of the form\r\n    function getAmbAddress(uint8 ambId_) external view returns (address ambAddress_);\r\n\r\n    /// @dev gets the id of the amb\r\n    /// @param ambAddress_ is the address of an amb\r\n    /// @return ambId_ is the identifier of an amb\r\n    function getAmbId(address ambAddress_) external view returns (uint8 ambId_);\r\n\r\n    /// @dev gets the address of the registry\r\n    /// @param registryId_ is the id of the state registry\r\n    /// @return registryAddress_ is the address of the state registry\r\n    function getStateRegistry(uint8 registryId_) external view returns (address registryAddress_);\r\n\r\n    /// @dev gets the id of the registry\r\n    /// @notice reverts if the id is not found\r\n    /// @param registryAddress_ is the address of the state registry\r\n    /// @return registryId_ is the id of the state registry\r\n    function getStateRegistryId(address registryAddress_) external view returns (uint8 registryId_);\r\n\r\n    /// @dev gets the safe vault limit\r\n    /// @param chainId_ is the id of the remote chain\r\n    /// @return vaultLimitPerDestination_ is the safe number of vaults to deposit\r\n    /// without hitting out of gas error\r\n    function getVaultLimitPerDestination(uint64 chainId_) external view returns (uint256 vaultLimitPerDestination_);\r\n\r\n    /// @dev helps validate if an address is a valid state registry\r\n    /// @param registryAddress_ is the address of the state registry\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidStateRegistry(address registryAddress_) external view returns (bool valid_);\r\n\r\n    /// @dev helps validate if an address is a valid amb implementation\r\n    /// @param ambAddress_ is the address of the amb implementation\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidAmbImpl(address ambAddress_) external view returns (bool valid_);\r\n\r\n    /// @dev helps validate if an address is a valid broadcast amb implementation\r\n    /// @param ambAddress_ is the address of the broadcast amb implementation\r\n    /// @return valid_ a flag indicating if its valid.\r\n    function isValidBroadcastAmbImpl(address ambAddress_) external view returns (bool valid_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev sets the deposit rescue delay\r\n    /// @param delay_ the delay in seconds before the deposit rescue can be finalized\r\n    function setDelay(uint256 delay_) external;\r\n\r\n    /// @dev sets the permit2 address\r\n    /// @param permit2_ the address of the permit2 contract\r\n    function setPermit2(address permit2_) external;\r\n\r\n    /// @dev sets the safe vault limit\r\n    /// @param chainId_ is the remote chain identifier\r\n    /// @param vaultLimit_ is the max limit of vaults per transaction\r\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external;\r\n\r\n    /// @dev sets a new address on a specific chain.\r\n    /// @param id_ the identifier of the address on that chain\r\n    /// @param newAddress_ the new address on that chain\r\n    /// @param chainId_ the chain id of that chain\r\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) external;\r\n\r\n    /// @dev allows admin to set the bridge address for an bridge id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param bridgeId_         represents the bridge unique identifier.\r\n    /// @param bridgeAddress_    represents the bridge address.\r\n    /// @param bridgeValidator_  represents the bridge validator address.\r\n    function setBridgeAddresses(\r\n        uint8[] memory bridgeId_,\r\n        address[] memory bridgeAddress_,\r\n        address[] memory bridgeValidator_\r\n    )\r\n        external;\r\n\r\n    /// @dev allows admin to set the amb address for an amb id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param ambId_         represents the bridge unique identifier.\r\n    /// @param ambAddress_    represents the bridge address.\r\n    /// @param isBroadcastAMB_ represents whether the amb implementation supports broadcasting\r\n    function setAmbAddress(\r\n        uint8[] memory ambId_,\r\n        address[] memory ambAddress_,\r\n        bool[] memory isBroadcastAMB_\r\n    )\r\n        external;\r\n\r\n    /// @dev allows admin to set the state registry address for an state registry id.\r\n    /// @notice this function operates in an APPEND-ONLY fashion.\r\n    /// @param registryId_    represents the state registry's unique identifier.\r\n    /// @param registryAddress_    represents the state registry's address.\r\n    function setStateRegistryAddress(uint8[] memory registryId_, address[] memory registryAddress_) external;\r\n}\r\n\r\nlibrary Error {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  CONFIGURATION ERRORS                    //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown in protocol setup\r\n\r\n    /// @dev thrown if chain id exceeds max(uint64)\r\n    error BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\r\n\r\n    /// @dev thrown if not possible to revoke a role in broadcasting\r\n    error CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\r\n\r\n    /// @dev thrown if not possible to revoke last admin\r\n    error CANNOT_REVOKE_LAST_ADMIN();\r\n\r\n    /// @dev thrown if trying to set again pseudo immutables in super registry\r\n    error DISABLED();\r\n\r\n    /// @dev thrown if rescue delay is not yet set for a chain\r\n    error DELAY_NOT_SET();\r\n\r\n    /// @dev thrown if get native token price estimate in paymentHelper is 0\r\n    error INVALID_NATIVE_TOKEN_PRICE();\r\n\r\n    /// @dev thrown if wormhole refund chain id is not set\r\n    error REFUND_CHAIN_ID_NOT_SET();\r\n\r\n    /// @dev thrown if wormhole relayer is not set\r\n    error RELAYER_NOT_SET();\r\n\r\n    /// @dev thrown if a role to be revoked is not assigned\r\n    error ROLE_NOT_ASSIGNED();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  AUTHORIZATION ERRORS                    //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown if functions cannot be called\r\n\r\n    /// COMMON AUTHORIZATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if caller is not address(this), internal call\r\n    error INVALID_INTERNAL_CALL();\r\n\r\n    /// @dev thrown if msg.sender is not a valid amb implementation\r\n    error NOT_AMB_IMPLEMENTATION();\r\n\r\n    /// @dev thrown if msg.sender is not an allowed broadcaster\r\n    error NOT_ALLOWED_BROADCASTER();\r\n\r\n    /// @dev thrown if msg.sender is not broadcast amb implementation\r\n    error NOT_BROADCAST_AMB_IMPLEMENTATION();\r\n\r\n    /// @dev thrown if msg.sender is not broadcast state registry\r\n    error NOT_BROADCAST_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not core state registry\r\n    error NOT_CORE_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not emergency admin\r\n    error NOT_EMERGENCY_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not emergency queue\r\n    error NOT_EMERGENCY_QUEUE();\r\n\r\n    /// @dev thrown if msg.sender is not minter\r\n    error NOT_MINTER();\r\n\r\n    /// @dev thrown if msg.sender is not minter state registry\r\n    error NOT_MINTER_STATE_REGISTRY_ROLE();\r\n\r\n    /// @dev thrown if msg.sender is not paymaster\r\n    error NOT_PAYMASTER();\r\n\r\n    /// @dev thrown if msg.sender is not payment admin\r\n    error NOT_PAYMENT_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not protocol admin\r\n    error NOT_PROTOCOL_ADMIN();\r\n\r\n    /// @dev thrown if msg.sender is not state registry\r\n    error NOT_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not super registry\r\n    error NOT_SUPER_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not superform router\r\n    error NOT_SUPERFORM_ROUTER();\r\n\r\n    /// @dev thrown if msg.sender is not a superform\r\n    error NOT_SUPERFORM();\r\n\r\n    /// @dev thrown if msg.sender is not superform factory\r\n    error NOT_SUPERFORM_FACTORY();\r\n\r\n    /// @dev thrown if msg.sender is not timelock form\r\n    error NOT_TIMELOCK_SUPERFORM();\r\n\r\n    /// @dev thrown if msg.sender is not timelock state registry\r\n    error NOT_TIMELOCK_STATE_REGISTRY();\r\n\r\n    /// @dev thrown if msg.sender is not user or disputer\r\n    error NOT_VALID_DISPUTER();\r\n\r\n    /// @dev thrown if the msg.sender is not privileged caller\r\n    error NOT_PRIVILEGED_CALLER(bytes32 role);\r\n\r\n    /// STATE REGISTRY AUTHORIZATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev layerzero adapter specific error, thrown if caller not layerzero endpoint\r\n    error CALLER_NOT_ENDPOINT();\r\n\r\n    /// @dev hyperlane adapter specific error, thrown if caller not hyperlane mailbox\r\n    error CALLER_NOT_MAILBOX();\r\n\r\n    /// @dev wormhole relayer specific error, thrown if caller not wormhole relayer\r\n    error CALLER_NOT_RELAYER();\r\n\r\n    /// @dev thrown if src chain sender is not valid\r\n    error INVALID_SRC_SENDER();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  INPUT VALIDATION ERRORS                 //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown if input variables are not valid\r\n\r\n    /// COMMON INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if there is an array length mismatch\r\n    error ARRAY_LENGTH_MISMATCH();\r\n\r\n    /// @dev thrown if payload id does not exist\r\n    error INVALID_PAYLOAD_ID();\r\n\r\n    /// @dev error thrown when msg value should be zero in certain payable functions\r\n    error MSG_VALUE_NOT_ZERO();\r\n\r\n    /// @dev thrown if amb ids length is 0\r\n    error ZERO_AMB_ID_LENGTH();\r\n\r\n    /// @dev thrown if address input is address 0\r\n    error ZERO_ADDRESS();\r\n\r\n    /// @dev thrown if amount input is 0\r\n    error ZERO_AMOUNT();\r\n\r\n    /// @dev thrown if value input is 0\r\n    error ZERO_INPUT_VALUE();\r\n\r\n    /// SUPERFORM ROUTER INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if the vaults data is invalid\r\n    error INVALID_SUPERFORMS_DATA();\r\n\r\n    /// @dev thrown if receiver address is not set\r\n    error RECEIVER_ADDRESS_NOT_SET();\r\n\r\n    /// SUPERFORM FACTORY INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if a form is not ERC165 compatible\r\n    error ERC165_UNSUPPORTED();\r\n\r\n    /// @dev thrown if a form is not form interface compatible\r\n    error FORM_INTERFACE_UNSUPPORTED();\r\n\r\n    /// @dev error thrown if form implementation address already exists\r\n    error FORM_IMPLEMENTATION_ALREADY_EXISTS();\r\n\r\n    /// @dev error thrown if form implementation id already exists\r\n    error FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\r\n\r\n    /// @dev thrown if a form does not exist\r\n    error FORM_DOES_NOT_EXIST();\r\n\r\n    /// @dev thrown if form id is larger than max uint16\r\n    error INVALID_FORM_ID();\r\n\r\n    /// @dev thrown if superform not on factory\r\n    error SUPERFORM_ID_NONEXISTENT();\r\n\r\n    /// @dev thrown if same vault and form implementation is used to create new superform\r\n    error VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\r\n\r\n    /// FORM INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if in case of no txData, if liqData.token != vault.asset()\r\n    /// in case of txData, if token output of swap != vault.asset()\r\n    error DIFFERENT_TOKENS();\r\n\r\n    /// @dev thrown if the amount in direct withdraw is not correct\r\n    error DIRECT_WITHDRAW_INVALID_LIQ_REQUEST();\r\n\r\n    /// @dev thrown if the amount in xchain withdraw is not correct\r\n    error XCHAIN_WITHDRAW_INVALID_LIQ_REQUEST();\r\n\r\n    /// LIQUIDITY BRIDGE INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev error thrown when txData selector of lifi bridged is a blacklisted selector\r\n    error BLACKLISTED_SELECTOR();\r\n\r\n    /// @dev thrown if a certain action of the user is not allowed given the txData provided\r\n    error INVALID_ACTION();\r\n\r\n    /// @dev thrown if in deposits, the liqDstChainId doesn't match the stateReq dstChainId\r\n    error INVALID_DEPOSIT_LIQ_DST_CHAIN_ID();\r\n\r\n    /// @dev thrown if index is invalid\r\n    error INVALID_INDEX();\r\n\r\n    /// @dev thrown if the chain id in the txdata is invalid\r\n    error INVALID_TXDATA_CHAIN_ID();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to a destination call present\r\n    error INVALID_TXDATA_NO_DESTINATIONCALL_ALLOWED();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to wrong receiver\r\n    error INVALID_TXDATA_RECEIVER();\r\n\r\n    /// @dev thrown if the validation of bridge txData fails due to wrong token\r\n    error INVALID_TXDATA_TOKEN();\r\n\r\n    /// @dev thrown if txData is not present (in case of xChain actions)\r\n    error NO_TXDATA_PRESENT();\r\n\r\n    /// STATE REGISTRY INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if payload is being updated with final amounts length different than amounts length\r\n    error DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\r\n\r\n    /// @dev thrown if payload is being updated with tx data length different than liq data length\r\n    error DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\r\n\r\n    /// @dev thrown if keeper update final token is different than the vault underlying\r\n    error INVALID_UPDATE_FINAL_TOKEN();\r\n\r\n    /// @dev thrown if broadcast finality for wormhole is invalid\r\n    error INVALID_BROADCAST_FINALITY();\r\n\r\n    /// @dev thrown if amb id is not valid leading to an address 0 of the implementation\r\n    error INVALID_BRIDGE_ID();\r\n\r\n    /// @dev thrown if chain id involved in xchain message is invalid\r\n    error INVALID_CHAIN_ID();\r\n\r\n    /// @dev thrown if payload update amount isn't equal to dst swapper amount\r\n    error INVALID_DST_SWAP_AMOUNT();\r\n\r\n    /// @dev thrown if message amb and proof amb are the same\r\n    error INVALID_PROOF_BRIDGE_ID();\r\n\r\n    /// @dev thrown if order of proof AMBs is incorrect, either duplicated or not incrementing\r\n    error INVALID_PROOF_BRIDGE_IDS();\r\n\r\n    /// @dev thrown if rescue data lengths are invalid\r\n    error INVALID_RESCUE_DATA();\r\n\r\n    /// @dev thrown if delay is invalid\r\n    error INVALID_TIMELOCK_DELAY();\r\n\r\n    /// @dev thrown if amounts being sent in update payload mean a negative slippage\r\n    error NEGATIVE_SLIPPAGE();\r\n\r\n    /// @dev thrown if slippage is outside of bounds\r\n    error SLIPPAGE_OUT_OF_BOUNDS();\r\n\r\n    /// SUPERPOSITION INPUT VALIDATION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if src senders mismatch in state sync\r\n    error SRC_SENDER_MISMATCH();\r\n\r\n    /// @dev thrown if src tx types mismatch in state sync\r\n    error SRC_TX_TYPE_MISMATCH();\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  EXECUTION ERRORS                        //\r\n    //////////////////////////////////////////////////////////////\r\n    ///@notice errors thrown due to function execution logic\r\n\r\n    /// COMMON EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if the swap in a direct deposit resulted in insufficient tokens\r\n    error DIRECT_DEPOSIT_SWAP_FAILED();\r\n\r\n    /// @dev thrown if payload is not unique\r\n    error DUPLICATE_PAYLOAD();\r\n\r\n    /// @dev thrown if native tokens fail to be sent to superform contracts\r\n    error FAILED_TO_SEND_NATIVE();\r\n\r\n    /// @dev thrown if allowance is not correct to deposit\r\n    error INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\r\n\r\n    /// @dev thrown if contract has insufficient balance for operations\r\n    error INSUFFICIENT_BALANCE();\r\n\r\n    /// @dev thrown if native amount is not at least equal to the amount in the request\r\n    error INSUFFICIENT_NATIVE_AMOUNT();\r\n\r\n    /// @dev thrown if payload cannot be decoded\r\n    error INVALID_PAYLOAD();\r\n\r\n    /// @dev thrown if payload status is invalid\r\n    error INVALID_PAYLOAD_STATUS();\r\n\r\n    /// @dev thrown if payload type is invalid\r\n    error INVALID_PAYLOAD_TYPE();\r\n\r\n    /// LIQUIDITY BRIDGE EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if we try to decode the final swap output token in a xChain liquidity bridging action\r\n    error CANNOT_DECODE_FINAL_SWAP_OUTPUT_TOKEN();\r\n\r\n    /// @dev thrown if liquidity bridge fails for erc20 or native tokens\r\n    error FAILED_TO_EXECUTE_TXDATA(address token);\r\n\r\n    /// @dev thrown if asset being used for deposit mismatches in multivault deposits\r\n    error INVALID_DEPOSIT_TOKEN();\r\n\r\n    /// STATE REGISTRY EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if bridge tokens haven't arrived to destination\r\n    error BRIDGE_TOKENS_PENDING();\r\n\r\n    /// @dev thrown if withdrawal tx data cannot be updated\r\n    error CANNOT_UPDATE_WITHDRAW_TX_DATA();\r\n\r\n    /// @dev thrown if rescue passed dispute deadline\r\n    error DISPUTE_TIME_ELAPSED();\r\n\r\n    /// @dev thrown if message failed to reach the specified level of quorum needed\r\n    error INSUFFICIENT_QUORUM();\r\n\r\n    /// @dev thrown if broadcast payload is invalid\r\n    error INVALID_BROADCAST_PAYLOAD();\r\n\r\n    /// @dev thrown if broadcast fee is invalid\r\n    error INVALID_BROADCAST_FEE();\r\n\r\n    /// @dev thrown if retry fees is less than required\r\n    error INVALID_RETRY_FEE();\r\n\r\n    /// @dev thrown if broadcast message type is wrong\r\n    error INVALID_MESSAGE_TYPE();\r\n\r\n    /// @dev thrown if payload hash is invalid during `retryMessage` on Layezero implementation\r\n    error INVALID_PAYLOAD_HASH();\r\n\r\n    /// @dev thrown if update payload function was called on a wrong payload\r\n    error INVALID_PAYLOAD_UPDATE_REQUEST();\r\n\r\n    /// @dev thrown if a state registry id is 0\r\n    error INVALID_REGISTRY_ID();\r\n\r\n    /// @dev thrown if a form state registry id is 0\r\n    error INVALID_FORM_REGISTRY_ID();\r\n\r\n    /// @dev thrown if trying to finalize the payload but the withdraw is still locked\r\n    error LOCKED();\r\n\r\n    /// @dev thrown if payload is already updated (during xChain deposits)\r\n    error PAYLOAD_ALREADY_UPDATED();\r\n\r\n    /// @dev thrown if payload is already processed\r\n    error PAYLOAD_ALREADY_PROCESSED();\r\n\r\n    /// @dev thrown if payload is not in UPDATED state\r\n    error PAYLOAD_NOT_UPDATED();\r\n\r\n    /// @dev thrown if rescue is still in timelocked state\r\n    error RESCUE_LOCKED();\r\n\r\n    /// @dev thrown if rescue is already proposed\r\n    error RESCUE_ALREADY_PROPOSED();\r\n\r\n    /// @dev thrown if payload hash is zero during `retryMessage` on Layezero implementation\r\n    error ZERO_PAYLOAD_HASH();\r\n\r\n    /// DST SWAPPER EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if process dst swap is tried for processed payload id\r\n    error DST_SWAP_ALREADY_PROCESSED();\r\n\r\n    /// @dev thrown if indices have duplicates\r\n    error DUPLICATE_INDEX();\r\n\r\n    /// @dev thrown if failed dst swap is already updated\r\n    error FAILED_DST_SWAP_ALREADY_UPDATED();\r\n\r\n    /// @dev thrown if indices are out of bounds\r\n    error INDEX_OUT_OF_BOUNDS();\r\n\r\n    /// @dev thrown if failed swap token amount is 0\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP();\r\n\r\n    /// @dev thrown if failed swap token amount is not 0 and if token balance is less than amount (non zero)\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_TOKEN_BALANCE();\r\n\r\n    /// @dev thrown if failed swap token amount is not 0 and if native amount is less than amount (non zero)\r\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_NATIVE_BALANCE();\r\n\r\n    /// @dev forbid xChain deposits with destination swaps without interim token set (for user protection)\r\n    error INVALID_INTERIM_TOKEN();\r\n\r\n    /// @dev thrown if dst swap output is less than minimum expected\r\n    error INVALID_SWAP_OUTPUT();\r\n\r\n    /// FORM EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if try to forward 4626 share from the superform\r\n    error CANNOT_FORWARD_4646_TOKEN();\r\n\r\n    /// @dev thrown in KYCDAO form if no KYC token is present\r\n    error NO_VALID_KYC_TOKEN();\r\n\r\n    /// @dev thrown in forms where a certain functionality is not allowed or implemented\r\n    error NOT_IMPLEMENTED();\r\n\r\n    /// @dev thrown if form implementation is PAUSED, users cannot perform any action\r\n    error PAUSED();\r\n\r\n    /// @dev thrown if shares != deposit output or assets != redeem output when minting SuperPositions\r\n    error VAULT_IMPLEMENTATION_FAILED();\r\n\r\n    /// @dev thrown if withdrawal tx data is not updated\r\n    error WITHDRAW_TOKEN_NOT_UPDATED();\r\n\r\n    /// @dev thrown if withdrawal tx data is not updated\r\n    error WITHDRAW_TX_DATA_NOT_UPDATED();\r\n\r\n    /// @dev thrown when redeeming from vault yields zero collateral\r\n    error WITHDRAW_ZERO_COLLATERAL();\r\n\r\n    /// PAYMENT HELPER EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if chainlink is reporting an improper price\r\n    error CHAINLINK_MALFUNCTION();\r\n\r\n    /// @dev thrown if chainlink is reporting an incomplete round\r\n    error CHAINLINK_INCOMPLETE_ROUND();\r\n\r\n    /// @dev thrown if feed decimals is not 8\r\n    error CHAINLINK_UNSUPPORTED_DECIMAL();\r\n\r\n    /// EMERGENCY QUEUE EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if emergency withdraw is not queued\r\n    error EMERGENCY_WITHDRAW_NOT_QUEUED();\r\n\r\n    /// @dev thrown if emergency withdraw is already processed\r\n    error EMERGENCY_WITHDRAW_PROCESSED_ALREADY();\r\n\r\n    /// SUPERPOSITION EXECUTION ERRORS\r\n    /// ---------------------------------------------------------\r\n\r\n    /// @dev thrown if uri cannot be updated\r\n    error DYNAMIC_URI_FROZEN();\r\n\r\n    /// @dev thrown if tx history is not found while state sync\r\n    error TX_HISTORY_NOT_FOUND();\r\n}\r\n\r\n/// @dev generates proof for amb message and bytes encoded message\r\nlibrary ProofLib {\r\n    function computeProof(AMBMessage memory message_) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(message_));\r\n    }\r\n\r\n    function computeProofBytes(AMBMessage memory message_) internal pure returns (bytes memory) {\r\n        return abi.encode(keccak256(abi.encode(message_)));\r\n    }\r\n\r\n    function computeProof(bytes memory message_) internal pure returns (bytes32) {\r\n        return keccak256(message_);\r\n    }\r\n\r\n    function computeProofBytes(bytes memory message_) internal pure returns (bytes memory) {\r\n        return abi.encode(keccak256(message_));\r\n    }\r\n}\r\n\r\n/// @title BaseStateRegistry\r\n/// @dev Contract module that allows inheriting contracts to implement crosschain messaging & processing mechanisms.\r\n/// @dev this is a lightweight version that allows only dispatching and receiving crosschain\r\n/// @dev payloads (messages). Inheriting children contracts have the flexibility to define their own processing\r\n/// mechanisms.\r\n/// @author Zeropoint Labs\r\nabstract contract BaseStateRegistry is IBaseStateRegistry {\r\n    \r\n    using ProofLib for AMBMessage;\r\n    using ProofLib for bytes;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                         CONSTANTS                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    ISuperRegistry public immutable superRegistry;\r\n    uint64 public immutable CHAIN_ID;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                     STATE VARIABLES                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    uint256 public payloadsCount;\r\n\r\n    /// @dev stores received payload after assigning them an unique identifier upon receiving\r\n    mapping(uint256 => bytes) public payloadBody;\r\n\r\n    /// @dev stores received payload's header (txInfo)\r\n    mapping(uint256 => uint256) public payloadHeader;\r\n\r\n    /// @dev stores a proof's quorum\r\n    mapping(bytes32 => uint256) public messageQuorum;\r\n\r\n    /// @dev maps payloads to their current status\r\n    mapping(uint256 => PayloadState) public payloadTracking;\r\n\r\n    /// @dev maps payloads to the amb ids that delivered them\r\n    mapping(uint256 => uint8[]) internal msgAMBs;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                       MODIFIERS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev inheriting contracts should override this function based on functionality\r\n    modifier onlySender() virtual {\r\n        _;\r\n    }\r\n\r\n    /// @dev ensures that only added AMB implementations are accepted\r\n    modifier onlyValidAmbImplementation() {\r\n        if (!superRegistry.isValidAmbImpl(msg.sender)) {\r\n            revert Error.NOT_AMB_IMPLEMENTATION();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                      CONSTRUCTOR                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    constructor(ISuperRegistry superRegistry_) {\r\n        if (block.chainid > type(uint64).max) {\r\n            revert Error.BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\r\n        }\r\n\r\n        CHAIN_ID = uint64(block.chainid);\r\n        superRegistry = superRegistry_;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @inheritdoc IBaseStateRegistry\r\n    function getMessageAMB(uint256 payloadId_) external view override returns (uint8[] memory) {\r\n        return msgAMBs[payloadId_];\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @inheritdoc IBaseStateRegistry\r\n    function dispatchPayload(\r\n        address srcSender_,\r\n        uint8[] memory ambIds_,\r\n        uint64 dstChainId_,\r\n        bytes memory message_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable\r\n        override\r\n        onlySender\r\n    {\r\n        _dispatchPayload(srcSender_, ambIds_, dstChainId_, message_, extraData_);\r\n    }\r\n\r\n    /// @inheritdoc IBaseStateRegistry\r\n    function receivePayload(uint64 srcChainId_, bytes memory message_) external override onlyValidAmbImplementation {\r\n        AMBMessage memory data = abi.decode(message_, (AMBMessage));\r\n\r\n        /// @dev proofHash will always be 32 bytes length due to keccak256\r\n        if (data.params.length == 32) {\r\n            bytes32 proofHash = abi.decode(data.params, (bytes32));\r\n            ++messageQuorum[proofHash];\r\n\r\n            emit ProofReceived(data.params);\r\n        } else {\r\n            /// @dev if message, store header and body of it\r\n            ++payloadsCount;\r\n\r\n            payloadHeader[payloadsCount] = data.txInfo;\r\n            (msgAMBs[payloadsCount], payloadBody[payloadsCount]) = abi.decode(data.params, (uint8[], bytes));\r\n\r\n            emit PayloadReceived(srcChainId_, CHAIN_ID, payloadsCount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBaseStateRegistry\r\n    function processPayload(uint256 payloadId_) external payable virtual override;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  INTERNAL FUNCTIONS                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    function _dispatchPayload(\r\n        address srcSender_,\r\n        uint8[] memory ambIds_,\r\n        uint64 dstChainId_,\r\n        bytes memory message_,\r\n        bytes memory extraData_\r\n    )\r\n        internal\r\n    {\r\n        AMBMessage memory data = abi.decode(message_, (AMBMessage));\r\n        uint256 len = ambIds_.length;\r\n\r\n        if (len == 0) {\r\n            revert Error.ZERO_AMB_ID_LENGTH();\r\n        }\r\n\r\n        /// @dev revert here if quorum requirements might fail on the remote chain\r\n        if (len - 1 < _getQuorum(dstChainId_)) {\r\n            revert Error.INSUFFICIENT_QUORUM();\r\n        }\r\n\r\n        AMBExtraData memory d = abi.decode(extraData_, (AMBExtraData));\r\n\r\n        _getAMBImpl(ambIds_[0]).dispatchPayload{ value: d.gasPerAMB[0] }(\r\n            srcSender_,\r\n            dstChainId_,\r\n            abi.encode(AMBMessage(data.txInfo, abi.encode(ambIds_, data.params))),\r\n            d.extraDataPerAMB[0]\r\n        );\r\n\r\n        if (len > 1) {\r\n            data.params = message_.computeProofBytes();\r\n\r\n            /// @dev i starts from 1 since 0 is primary amb id which dispatches the message itself\r\n            for (uint8 i = 1; i < len; ++i) {\r\n                if (ambIds_[i] == ambIds_[0]) {\r\n                    revert Error.INVALID_PROOF_BRIDGE_ID();\r\n                }\r\n\r\n                if (i - 1 != 0 && ambIds_[i] <= ambIds_[i - 1]) {\r\n                    revert Error.INVALID_PROOF_BRIDGE_IDS();\r\n                }\r\n\r\n                /// @dev proof is dispatched in the form of a payload\r\n                _getAMBImpl(ambIds_[i]).dispatchPayload{ value: d.gasPerAMB[i] }(\r\n                    srcSender_, dstChainId_, abi.encode(data), d.extraDataPerAMB[i]\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev returns the required quorum for the src chain id from super registry\r\n    /// @param chainId_ is the src chain id\r\n    /// @return the quorum configured for the chain id\r\n    function _getQuorum(uint64 chainId_) internal view returns (uint256) {\r\n        return IQuorumManager(address(superRegistry)).getRequiredMessagingQuorum(chainId_);\r\n    }\r\n\r\n    /// @dev returns the amb id for address\r\n    function _getAmbAddress(uint8 id_) internal view returns (address amb) {\r\n        return superRegistry.getAmbAddress(id_);\r\n    }\r\n\r\n    function _getAMBImpl(uint8 id_) internal view returns (IAmbImplementation ambImplementation) {\r\n        ambImplementation = IAmbImplementation(_getAmbAddress(id_));\r\n    }\r\n}\r\n\r\n/// @title ICoreStateRegistry\r\n/// @dev Interface for CoreStateRegistry\r\n/// @author ZeroPoint Labs\r\ninterface ICoreStateRegistry {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev holds all information about a failed deposit mapped to a payload id\r\n    /// @param superformIds is an array of failing superform ids\r\n    /// @param settlementToken is an array of tokens to be refunded for the failing superform\r\n    /// @param amounts is an array of amounts of settlementToken to be refunded\r\n    /// @param receiverAddress is the users refund address\r\n    /// @param lastProposedTime indicates the rescue proposal timestamp\r\n    struct FailedDeposit {\r\n        uint256[] superformIds;\r\n        address[] settlementToken;\r\n        uint256[] amounts;\r\n        bool[] settleFromDstSwapper;\r\n        address receiverAddress;\r\n        uint256 lastProposedTimestamp;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when any deposit fails\r\n    event FailedXChainDeposits(uint256 indexed payloadId);\r\n\r\n    /// @dev is emitted when a rescue is proposed for failed deposits in a payload\r\n    event RescueProposed(\r\n        uint256 indexed payloadId,\r\n        uint256[] indexed superformIds,\r\n        uint256[] indexed proposedAmount,\r\n        uint256 proposedTime\r\n    );\r\n\r\n    /// @dev is emitted when an user disputed his refund amounts\r\n    event RescueDisputed(uint256 indexed payloadId);\r\n\r\n    /// @dev is emitted when deposit rescue is finalized\r\n    event RescueFinalized(uint256 indexed payloadId);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows users to read the superformIds that failed in a specific payloadId_\r\n    /// @param payloadId_ is the identifier of the cross-chain payload.\r\n    /// @return superformIds is the identifiers of superforms in the payloadId that got failed.\r\n    /// @return amounts is the amounts of refund tokens issues\r\n    /// @return lastProposedTime is the refund proposed time\r\n    function getFailedDeposits(uint256 payloadId_)\r\n        external\r\n        view\r\n        returns (uint256[] memory superformIds, uint256[] memory amounts, uint256 lastProposedTime);\r\n\r\n    /// @dev used internally for try/catching\r\n    /// @param finalAmount_ is the final amount of tokens received\r\n    /// @param amount_ is the indicated amount of tokens to be received\r\n    /// @param maxSlippage_ is the amount of acceptable slippage for the transaction\r\n    function validateSlippage(uint256 finalAmount_, uint256 amount_, uint256 maxSlippage_)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows accounts with {CORE_STATE_REGISTRY_UPDATER_ROLE} to modify a received cross-chain deposit payload.\r\n    /// @param payloadId_ is the identifier of the cross-chain payload to be updated.\r\n    /// @param finalTokens_ is the token received by the core state registry.\r\n    /// @param finalAmounts_ is the amount to be updated.\r\n    /// NOTE: amounts cannot be updated beyond user specified safe slippage limit.\r\n    function updateDepositPayload(\r\n        uint256 payloadId_,\r\n        address[] calldata finalTokens_,\r\n        uint256[] calldata finalAmounts_\r\n    )\r\n        external;\r\n\r\n    /// @dev allows accounts with {CORE_STATE_REGISTRY_UPDATER_ROLE} to modify a received cross-chain withdraw payload.\r\n    /// @param payloadId_  is the identifier of the cross-chain payload to be updated.\r\n    /// @param txData_ is the transaction data to be updated.\r\n    function updateWithdrawPayload(uint256 payloadId_, bytes[] calldata txData_) external;\r\n\r\n    /// @dev allows accounts with {CORE_STATE_REGISTRY_PROCESSOR_ROLE} to rescue tokens on failed deposits\r\n    /// @param payloadId_ is the identifier of the cross-chain payload.\r\n    /// @param proposedAmounts_ is the array of proposed rescue amounts.\r\n    function proposeRescueFailedDeposits(uint256 payloadId_, uint256[] memory proposedAmounts_) external;\r\n\r\n    /// @dev allows refund receivers to challenge their final receiving token amounts on failed deposits\r\n    /// @param payloadId_ is the identifier of the cross-chain payload\r\n    /// @notice should challenge within the delay window configured on SuperRegistry\r\n    function disputeRescueFailedDeposits(uint256 payloadId_) external;\r\n\r\n    /// @dev allows anyone to settle refunds for unprocessed/failed deposits past the challenge period\r\n    /// @param payloadId_ is the identifier of the cross-chain payload\r\n    function finalizeRescueFailedDeposits(uint256 payloadId_) external;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC-165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC-20 standard as defined in the ERC.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\r\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\r\n */\r\ninterface IERC4626 is IERC20, IERC20Metadata {\r\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\r\n}\r\n\r\n/// @title IBaseForm\r\n/// @dev Interface for BaseForm\r\n/// @author ZeroPoint Labs\r\ninterface IBaseForm is IERC165 {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                           //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a new vault is added by the admin.\r\n    event VaultAdded(uint256 indexed id, IERC4626 indexed vault);\r\n\r\n    /// @dev is emitted when a payload is processed by the destination contract.\r\n    event Processed(\r\n        uint64 indexed srcChainID,\r\n        uint64 indexed dstChainId,\r\n        uint256 indexed srcPayloadId,\r\n        uint256 amount,\r\n        address vault\r\n    );\r\n\r\n    /// @dev is emitted when an emergency withdrawal is processed\r\n    event EmergencyWithdrawalProcessed(address indexed refundAddress, uint256 indexed amount);\r\n\r\n    /// @dev is emitted when dust is forwarded to the paymaster\r\n    event FormDustForwardedToPaymaster(address indexed token, uint256 indexed amount);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @notice get Superform name of the ERC20 vault representation\r\n    /// @return The ERC20 name\r\n    function superformYieldTokenName() external view returns (string memory);\r\n\r\n    /// @notice get Superform symbol of the ERC20 vault representation\r\n    /// @return The ERC20 symbol\r\n    function superformYieldTokenSymbol() external view returns (string memory);\r\n\r\n    /// @notice get the state registry id associated with the vault\r\n    function getStateRegistryId() external view returns (uint8);\r\n\r\n    /// @notice Returns the vault address\r\n    /// @return The address of the vault\r\n    function getVaultAddress() external view returns (address);\r\n\r\n    /// @notice Returns the vault address\r\n    /// @return The address of the vault asset\r\n    function getVaultAsset() external view returns (address);\r\n\r\n    /// @notice Returns the name of the vault.\r\n    /// @return The name of the vault\r\n    function getVaultName() external view returns (string memory);\r\n\r\n    /// @notice Returns the symbol of a vault.\r\n    /// @return The symbol associated with a vault\r\n    function getVaultSymbol() external view returns (string memory);\r\n\r\n    /// @notice Returns the number of decimals in a vault for accounting purposes\r\n    /// @return The number of decimals in the vault balance\r\n    function getVaultDecimals() external view returns (uint256);\r\n\r\n    /// @notice Returns the amount of underlying tokens each share of a vault is worth.\r\n    /// @return The pricePerVaultShare value\r\n    function getPricePerVaultShare() external view returns (uint256);\r\n\r\n    /// @notice Returns the amount of vault shares owned by the form.\r\n    /// @return The form's vault share balance\r\n    function getVaultShareBalance() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of underlying managed in the ERC4626 vault\r\n    function getTotalAssets() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of unredeemed vault shares in circulation\r\n    function getTotalSupply() external view returns (uint256);\r\n\r\n    /// @notice get the total amount of assets received if shares are actually redeemed\r\n    /// @notice https://eips.ethereum.org/EIPS/eip-4626\r\n    function getPreviewPricePerVaultShare() external view returns (uint256);\r\n\r\n    /// @dev API may need to know state of funds deployed\r\n    function previewDepositTo(uint256 assets_) external view returns (uint256);\r\n\r\n    /// @notice positionBalance() -> .vaultIds&destAmounts\r\n    /// @return how much of an asset + interest (accrued) is to withdraw from the Vault\r\n    function previewWithdrawFrom(uint256 assets_) external view returns (uint256);\r\n\r\n    /// @dev API may need to know state of funds deployed\r\n    function previewRedeemFrom(uint256 shares_) external view returns (uint256);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev process same chain id deposits\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @return shares  The amount of vault shares received\r\n    function directDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 shares);\r\n\r\n    /// @dev process same chain id deposits\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @param srcChainId_ The chain id of the source chain\r\n    /// @return shares  The amount of vault shares received\r\n    /// @dev is shares is `0` then no further action/acknowledgement needs to be sent\r\n    function xChainDepositIntoVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        external\r\n        returns (uint256 shares);\r\n\r\n    /// @dev process withdrawal of asset from a vault\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @return assets  The amount of assets received\r\n    function directWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_\r\n    )\r\n        external\r\n        returns (uint256 assets);\r\n\r\n    /// @dev process withdrawal of asset from a vault\r\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\r\n    /// @param srcSender_ The address of the sender of the transaction\r\n    /// @param srcChainId_ The chain id of the source chain\r\n    /// @return assets The amount of assets received\r\n    function xChainWithdrawFromVault(\r\n        InitSingleVaultData memory singleVaultData_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        external\r\n        returns (uint256 assets);\r\n\r\n    /// @dev process withdrawal of shares if form is paused\r\n    /// @param receiverAddress_ The address to refund the shares to\r\n    /// @param amount_ The amount of vault shares to refund\r\n    function emergencyWithdraw(address receiverAddress_, uint256 amount_) external;\r\n\r\n    /// @dev moves all dust in the contract to Paymaster contract\r\n    /// @param token_ The address of the token to forward\r\n    function forwardDustToPaymaster(address token_) external;\r\n}\r\n\r\n/// @title Bridge Validator Interface\r\n/// @dev Interface all Bridge Validators must follow\r\n/// @author Zeropoint Labs\r\ninterface IBridgeValidator {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    struct ValidateTxDataArgs {\r\n        bytes txData;\r\n        uint64 srcChainId;\r\n        uint64 dstChainId;\r\n        uint64 liqDstChainId;\r\n        bool deposit;\r\n        address superform;\r\n        address receiverAddress;\r\n        address liqDataToken;\r\n        address liqDataInterimToken;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev validates the receiver of the liquidity request\r\n    /// @param txData_ is the txData of the cross chain deposit\r\n    /// @param receiver_ is the address of the receiver to validate\r\n    /// @return valid_ if the address is valid\r\n    function validateReceiver(bytes calldata txData_, address receiver_) external pure returns (bool valid_);\r\n\r\n    /// @dev validates the txData of a cross chain deposit\r\n    /// @param args_ the txData arguments to validate in txData\r\n    /// @return hasDstSwap if the txData contains a destination swap\r\n    function validateTxData(ValidateTxDataArgs calldata args_) external view returns (bool hasDstSwap);\r\n\r\n    /// @dev decodes the txData and returns the amount of input token on source\r\n    /// @param txData_ is the txData of the cross chain deposit\r\n    /// @param genericSwapDisallowed_ true if generic swaps are disallowed\r\n    /// @return amount_ the amount expected\r\n    function decodeAmountIn(\r\n        bytes calldata txData_,\r\n        bool genericSwapDisallowed_\r\n    )\r\n        external\r\n        pure\r\n        returns (uint256 amount_);\r\n\r\n    /// @dev decodes neccesary information for processing swaps on the destination chain\r\n    /// @param txData_ is the txData to be decoded\r\n    /// @return token_ is the address of the token\r\n    /// @return amount_ the amount expected\r\n    function decodeDstSwap(bytes calldata txData_) external pure returns (address token_, uint256 amount_);\r\n\r\n    /// @dev decodes the final output token address (for only direct chain actions!)\r\n    /// @param txData_ is the txData to be decoded\r\n    /// @return token_ the address of the token\r\n    function decodeSwapOutputToken(bytes calldata txData_) external pure returns (address token_);\r\n}\r\n\r\n/// @title IDstSwapper\r\n/// @dev Interface for DstSwapper\r\n/// @author Zeropoint Labs\r\ninterface IDstSwapper {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    struct FailedSwap {\r\n        address interimToken;\r\n        uint256 amount;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when the super registry is updated.\r\n    event SuperRegistryUpdated(address indexed superRegistry);\r\n\r\n    /// @dev is emitted when a dst swap transaction is processed\r\n    event SwapProcessed(\r\n        uint256 indexed payloadId, uint256 indexed index, uint256 indexed bridgeId, uint256 finalAmount\r\n    );\r\n\r\n    /// @dev is emitted when a dst swap fails and intermediary tokens are sent to CoreStateRegistry for rescue\r\n    event SwapFailed(\r\n        uint256 indexed payloadId, uint256 indexed index, address indexed intermediaryToken, uint256 amount\r\n    );\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @notice returns the swapped amounts (if dst swap is successful)\r\n    /// @param payloadId_ is the id of payload\r\n    /// @param index_ represents the index in the payload (0 for single vault payload)\r\n    /// @return amount is the amount forwarded to core state registry after the swap\r\n    function swappedAmount(uint256 payloadId_, uint256 index_) external view returns (uint256 amount);\r\n\r\n    /// @notice returns the interim amounts (if dst swap is failing)\r\n    /// @param payloadId_ is the id of payload\r\n    /// @param index_ represents the index in the payload (0 for single vault payload)\r\n    /// @return interimToken is the token that is to be refunded\r\n    /// @return amount is the amount of interim token to be refunded\r\n    function getPostDstSwapFailureUpdatedTokenAmount(\r\n        uint256 payloadId_,\r\n        uint256 index_\r\n    )\r\n        external\r\n        view\r\n        returns (address interimToken, uint256 amount);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @notice will process dst swap through a liquidity bridge\r\n    /// @param payloadId_ represents the id of the payload\r\n    /// @param bridgeId_ represents the id of liquidity bridge used\r\n    /// @param txData_ represents the transaction data generated by liquidity bridge API.\r\n    function processTx(uint256 payloadId_, uint8 bridgeId_, bytes calldata txData_) external;\r\n\r\n    /// @notice will process dst swaps in batch through a liquidity bridge\r\n    /// @param payloadId_ represents the array of payload ids used\r\n    /// @param indices_ represents the index of the superformid in the payload\r\n    /// @param bridgeIds_ represents the array of ids of liquidity bridges used\r\n    /// @param txDatas_  represents the array of transaction data generated by liquidity bridge API\r\n    function batchProcessTx(\r\n        uint256 payloadId_,\r\n        uint256[] calldata indices_,\r\n        uint8[] calldata bridgeIds_,\r\n        bytes[] calldata txDatas_\r\n    )\r\n        external;\r\n\r\n    /// @notice updates the amounts of intermediary tokens stuck because of failing dst swap\r\n    /// @param payloadId_ represents the id of the payload\r\n    /// @param interimToken_ is the intermediary token that cannot be swapped to the vault underlying\r\n    /// @param amount_ is the amount of the intermediary token\r\n    function updateFailedTx(uint256 payloadId_, address interimToken_, uint256 amount_) external;\r\n\r\n    /// @notice updates the amounts of intermediary tokens stuck because of failing dst swap in batch\r\n    /// @param payloadId_ represents the id of the payload\r\n    /// @param indices_ represents the failing indices in the payload\r\n    /// @param interimTokens_ is the list of intermediary tokens that cannot be swapped\r\n    /// @param amounts_ are the amount of intermediary tokens that need to be refunded to the user\r\n    function batchUpdateFailedTx(\r\n        uint256 payloadId_,\r\n        uint256[] calldata indices_,\r\n        address[] calldata interimTokens_,\r\n        uint256[] calldata amounts_\r\n    )\r\n        external;\r\n\r\n    /// @notice is a privileged function that allows Core State Registry to process refunds\r\n    /// @param user_ is the final refund receiver of the interimToken_\r\n    /// @param interimToken_ is the refund token\r\n    /// @param amount_ is the refund amount\r\n    function processFailedTx(address user_, address interimToken_, uint256 amount_) external;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC-165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev The `account` is missing a role.\r\n     */\r\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\r\n\r\n    /**\r\n     * @dev The caller of a function is not the expected one.\r\n     *\r\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\r\n     */\r\n    error AccessControlBadConfirmation();\r\n\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `callerConfirmation`.\r\n     */\r\n    function renounceRole(bytes32 role, address callerConfirmation) external;\r\n}\r\n\r\n/// @title ISuperRBAC\r\n/// @dev Interface for SuperRBAC\r\n/// @author Zeropoint Labs\r\ninterface ISuperRBAC is IAccessControl {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    struct InitialRoleSetup {\r\n        address admin;\r\n        address emergencyAdmin;\r\n        address paymentAdmin;\r\n        address csrProcessor;\r\n        address tlProcessor;\r\n        address brProcessor;\r\n        address csrUpdater;\r\n        address srcVaaRelayer;\r\n        address dstSwapper;\r\n        address csrRescuer;\r\n        address csrDisputer;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when superRegistry is set\r\n    event SuperRegistrySet(address indexed superRegistry);\r\n\r\n    /// @dev is emitted when an admin is set for a role\r\n    event RoleAdminSet(bytes32 role, bytes32 adminRole);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the id of the protocol admin role\r\n    function PROTOCOL_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the emergency admin role\r\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the payment admin role\r\n    function PAYMENT_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcaster role\r\n    function BROADCASTER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry processor role\r\n    function CORE_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the timelock state registry processor role\r\n    function TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the broadcast state registry processor role\r\n    function BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry updater role\r\n    function CORE_STATE_REGISTRY_UPDATER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the dst swapper role\r\n    function DST_SWAPPER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry rescuer role\r\n    function CORE_STATE_REGISTRY_RESCUER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of the core state registry rescue disputer role\r\n    function CORE_STATE_REGISTRY_DISPUTER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns the id of wormhole vaa relayer role\r\n    function WORMHOLE_VAA_RELAYER_ROLE() external view returns (bytes32);\r\n\r\n    /// @dev returns whether the given address has the protocol admin role\r\n    /// @param admin_ the address to check\r\n    function hasProtocolAdminRole(address admin_) external view returns (bool);\r\n\r\n    /// @dev returns whether the given address has the emergency admin role\r\n    /// @param admin_ the address to check\r\n    function hasEmergencyAdminRole(address admin_) external view returns (bool);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev updates the super registry address\r\n    function setSuperRegistry(address superRegistry_) external;\r\n\r\n    /// @dev configures a new role in superForm\r\n    /// @param role_ the role to set\r\n    /// @param adminRole_ the admin role to set as admin\r\n    function setRoleAdmin(bytes32 role_, bytes32 adminRole_) external;\r\n\r\n    /// @dev revokes the role_ from superRegistryAddressId_ on all chains\r\n    /// @param role_ the role to revoke\r\n    /// @param extraData_ amb config if broadcasting is required\r\n    /// @param superRegistryAddressId_ the super registry address id\r\n    function revokeRoleSuperBroadcast(\r\n        bytes32 role_,\r\n        bytes memory extraData_,\r\n        bytes32 superRegistryAddressId_\r\n    )\r\n        external\r\n        payable;\r\n\r\n    /// @dev allows sync of global roles from different chains using broadcast registry\r\n    /// @notice may not work for all roles\r\n    function stateSyncBroadcast(bytes memory data_) external;\r\n}\r\n\r\n/// @title ISuperformFactory\r\n/// @dev Interface for SuperformFactory\r\n/// @author ZeroPoint Labs\r\ninterface ISuperformFactory {\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                         CONSTANTS                        //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    enum PauseStatus {\r\n        NON_PAUSED,\r\n        PAUSED\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev emitted when a new formImplementation is entered into the factory\r\n    /// @param formImplementation is the address of the new form implementation\r\n    /// @param formImplementationId is the id of the formImplementation\r\n    /// @param formStateRegistryId is any additional state registry id of the formImplementation\r\n    event FormImplementationAdded(\r\n        address indexed formImplementation, uint256 indexed formImplementationId, uint8 indexed formStateRegistryId\r\n    );\r\n\r\n    /// @dev emitted when a new Superform is created\r\n    /// @param formImplementationId is the id of the form implementation\r\n    /// @param vault is the address of the vault\r\n    /// @param superformId is the id of the superform\r\n    /// @param superform is the address of the superform\r\n    event SuperformCreated(\r\n        uint256 indexed formImplementationId, address indexed vault, uint256 indexed superformId, address superform\r\n    );\r\n\r\n    /// @dev emitted when a new SuperRegistry is set\r\n    /// @param superRegistry is the address of the super registry\r\n    event SuperRegistrySet(address indexed superRegistry);\r\n\r\n    /// @dev emitted when a form implementation is paused\r\n    /// @param formImplementationId is the id of the form implementation\r\n    /// @param paused is the new paused status\r\n    event FormImplementationPaused(uint256 indexed formImplementationId, PauseStatus indexed paused);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the number of forms\r\n    /// @return forms_ is the number of forms\r\n    function getFormCount() external view returns (uint256 forms_);\r\n\r\n    /// @dev returns the number of superforms\r\n    /// @return superforms_ is the number of superforms\r\n    function getSuperformCount() external view returns (uint256 superforms_);\r\n\r\n    /// @dev returns the address of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return formImplementation_ is the address of the form implementation\r\n    function getFormImplementation(uint32 formImplementationId_) external view returns (address formImplementation_);\r\n\r\n    /// @dev returns the form state registry id of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return stateRegistryId_ is the additional state registry id of the form\r\n    function getFormStateRegistryId(uint32 formImplementationId_) external view returns (uint8 stateRegistryId_);\r\n\r\n    /// @dev returns the paused status of form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @return paused_ is the current paused status of the form formImplementationId_\r\n    function isFormImplementationPaused(uint32 formImplementationId_) external view returns (bool paused_);\r\n\r\n    /// @dev returns the address of a superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return superform_ is the address of the superform\r\n    /// @return formImplementationId_ is the id of the form implementation\r\n    /// @return chainId_ is the chain id\r\n    function getSuperform(uint256 superformId_)\r\n        external\r\n        pure\r\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_);\r\n\r\n    /// @dev returns if an address has been added to a Form\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return isSuperform_ bool if it exists\r\n    function isSuperform(uint256 superformId_) external view returns (bool isSuperform_);\r\n\r\n    /// @dev Reverse query of getSuperform, returns all superforms for a given vault\r\n    /// @param vault_ is the address of a vault\r\n    /// @return superformIds_ is the id of the superform\r\n    /// @return superforms_ is the address of the superform\r\n    function getAllSuperformsFromVault(address vault_)\r\n        external\r\n        view\r\n        returns (uint256[] memory superformIds_, address[] memory superforms_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev allows an admin to add a Form implementation to the factory\r\n    /// @param formImplementation_ is the address of a form implementation\r\n    /// @param formImplementationId_ is the id of the form implementation (generated off-chain and equal in all chains)\r\n    /// @param formStateRegistryId_ is the id of any additional state registry for that form\r\n    /// @dev formStateRegistryId_ 1 is default for all form implementations, pass in formStateRegistryId_ only if an\r\n    /// additional state registry is required\r\n    function addFormImplementation(\r\n        address formImplementation_,\r\n        uint32 formImplementationId_,\r\n        uint8 formStateRegistryId_\r\n    )\r\n        external;\r\n\r\n    /// @dev To add new vaults to Form implementations, fusing them together into Superforms\r\n    /// @param formImplementationId_ is the form implementation we want to attach the vault to\r\n    /// @param vault_ is the address of the vault\r\n    /// @return superformId_ is the id of the created superform\r\n    /// @return superform_ is the address of the created superform\r\n    function createSuperform(\r\n        uint32 formImplementationId_,\r\n        address vault_\r\n    )\r\n        external\r\n        returns (uint256 superformId_, address superform_);\r\n\r\n    /// @dev to synchronize superforms added to different chains using broadcast registry\r\n    /// @param data_ is the cross-chain superform id\r\n    function stateSyncBroadcast(bytes memory data_) external payable;\r\n\r\n    /// @dev allows an admin to change the status of a form\r\n    /// @param formImplementationId_ is the id of the form implementation\r\n    /// @param status_ is the new status\r\n    /// @param extraData_ is optional & passed when broadcasting of status is needed\r\n    function changeFormImplementationPauseStatus(\r\n        uint32 formImplementationId_,\r\n        PauseStatus status_,\r\n        bytes memory extraData_\r\n    )\r\n        external\r\n        payable;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\r\n\r\n/**\r\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\r\n     *\r\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\r\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\r\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\r\n     * reentrancy guards when interacting with untrusted contracts.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\r\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\r\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\r\n     * reentrancy guards when interacting with untrusted contracts.\r\n     *\r\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `values` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC1155A is IERC1155 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Event emitted when single id approval is set\r\n    event ApprovalForOne(address indexed owner, address indexed spender, uint256 id, uint256 amount);\r\n    event TransmutedBatchToERC20(address user, uint256[] ids, uint256[] amounts);\r\n    event TransmutedBatchToERC1155A(address user, uint256[] ids, uint256[] amounts);\r\n    event TransmutedToERC20(address user, uint256 id, uint256 amount);\r\n    event TransmutedToERC1155A(address user, uint256 id, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n    /// @dev for batch operations, if there is a length mismatch\r\n    error LENGTH_MISMATCH();\r\n\r\n    /// @dev operator is not an owner of ids or not enough of allowance, or is not approvedForAll\r\n    error NOT_AUTHORIZED();\r\n\r\n    /// @dev if allowance is lower than amount for the operation\r\n    error NOT_ENOUGH_ALLOWANCE();\r\n\r\n    /// @dev Thrown when AERC20 was already registered\r\n    error AERC20_ALREADY_REGISTERED();\r\n\r\n    /// @dev Thrown when AERC20 was not registered\r\n    error AERC20_NOT_REGISTERED();\r\n\r\n    /// @dev allowance amount cannot be decreased below zero\r\n    error DECREASED_ALLOWANCE_BELOW_ZERO();\r\n\r\n    /// @dev address is 0\r\n    error ZERO_ADDRESS();\r\n\r\n    /// @dev forbids transfers to address 0\r\n    error TRANSFER_TO_ADDRESS_ZERO();\r\n\r\n    /// @dev forbids registering a saErc20 if no associated erc1155a has been minted yet first\r\n    error ID_NOT_MINTED_YET();\r\n    /*//////////////////////////////////////////////////////////////\r\n                              SINGLE APPROVE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Public function for setting single id approval\r\n    /// @dev Notice `owner` param, it will always be msg.sender, see _setApprovalForOne()\r\n    function setApprovalForOne(address spender, uint256 id, uint256 amount) external;\r\n\r\n    /// @notice Public getter for existing single id approval\r\n    /// @dev Re-adapted from ERC20\r\n    function allowance(address owner, address spender, uint256 id) external returns (uint256);\r\n\r\n    /// @notice Public function for increasing single id approval amount\r\n    /// @dev Re-adapted from ERC20\r\n    function increaseAllowance(address spender, uint256 id, uint256 addedValue) external returns (bool);\r\n\r\n    /// @notice Public function for decreasing single id approval amount\r\n    /// @dev Re-adapted from ERC20\r\n    function decreaseAllowance(address spender, uint256 id, uint256 subtractedValue) external returns (bool);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              MULTI APPROVE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Public function for setting multiple id approval\r\n    /// @dev extension of sigle id approval\r\n    function setApprovalForMany(address spender, uint256[] memory ids, uint256[] memory amounts) external;\r\n\r\n    /// @notice Public function for increasing multiple id approval amount at once\r\n    /// @dev extension of single id increase allowance\r\n    function increaseAllowanceForMany(\r\n        address spender,\r\n        uint256[] memory ids,\r\n        uint256[] memory addedValues\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    /// @notice Public function for decreasing multiple id approval amount at once\r\n    /// @dev extension of single id decrease allowance\r\n    function decreaseAllowanceForMany(\r\n        address spender,\r\n        uint256[] memory ids,\r\n        uint256[] memory subtractedValues\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    AERC20 AND TRANSMUTE LOGIC \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Function set to virtual so that implementing protocols may introduce RBAC here or perform other changes\r\n    /// @notice payable to allow any implementing cross-chain protocol to be paid for fees for relaying this action to\r\n    /// various chain\r\n    /// @param id of the ERC1155 to create a ERC20 for\r\n    function registerAERC20(uint256 id) external payable returns (address);\r\n\r\n    /// @notice Use transmuteBatchToERC20 to transmute multiple ERC1155 ids into separate ERC20\r\n    /// Easier to transmute to 1155A than to transmute back to aErc20 because of ERC1155 beauty!\r\n    /// @param onBehalfOf address of the user on whose behalf this transmutation is happening\r\n    /// @param ids ids of the ERC1155A to transmute\r\n    /// @param amounts amounts of the ERC1155A to transmute\r\n    function transmuteBatchToERC20(address onBehalfOf, uint256[] memory ids, uint256[] memory amounts) external;\r\n\r\n    /// @notice Use transmuteBatchToERC1155A to transmute multiple ERC20 ids into separate ERC1155\r\n    /// @param onBehalfOf address of the user on whose behalf this transmutation is happening\r\n    /// @param ids ids of the ERC20 to transmute\r\n    /// @param amounts amounts of the ERC20 to transmute\r\n    function transmuteBatchToERC1155A(address onBehalfOf, uint256[] memory ids, uint256[] memory amounts) external;\r\n\r\n    /// @param onBehalfOf address of the user on whose behalf this transmutation is happening\r\n    /// @param id id of the ERC20s to transmute to aErc20\r\n    /// @param amount amount of the ERC20s to transmute to aErc20\r\n    function transmuteToERC20(address onBehalfOf, uint256 id, uint256 amount) external;\r\n\r\n    /// @param onBehalfOf address of the user on whose behalf this transmutation is happening\r\n    /// @param id id of the ERC20s to transmute to erc1155\r\n    /// @param amount amount of the ERC20s to transmute to erc1155\r\n    function transmuteToERC1155A(address onBehalfOf, uint256 id, uint256 amount) external;\r\n\r\n    /// @notice Public getter for the address of the aErc20 token for a given ERC1155 id\r\n    /// @param id id of the ERC1155 to get the aErc20 token address for\r\n    /// @return aERC20 address of the aErc20 token for the given ERC1155 id\r\n    function getERC20TokenAddress(uint256 id) external view returns (address aERC20);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                METADATA \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Compute return string from baseURI set for this contract and unique vaultId\r\n    function uri(uint256 id) external view returns (string memory);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            SUPPLY GETTERS \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Public getter for existing single id total supply\r\n    function totalSupply(uint256 id) external view returns (uint256);\r\n\r\n    /// @notice Public getter to know if a token id exists\r\n    /// @dev determines based on total supply for the id\r\n    function exists(uint256 id) external view returns (bool);\r\n\r\n    /// @dev handy helper to check if a AERC20 is registered\r\n    /// @param id of the ERC1155 to check if a AERC20 exists for\r\n    function aERC20Exists(uint256 id) external view returns (bool);\r\n}\r\n\r\n/// @title ISuperPositions\r\n/// @dev Interface for SuperPositions\r\n/// @author Zeropoint Labs\r\ninterface ISuperPositions is IERC1155A {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          STRUCTS                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    struct TxHistory {\r\n        uint256 txInfo;\r\n        address receiverAddressSP;\r\n    }\r\n    \r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev is emitted when a dynamic uri is updated\r\n    event DynamicURIUpdated(string indexed oldURI, string indexed newURI, bool indexed frozen);\r\n\r\n    /// @dev is emitted when a cross-chain transaction is completed.\r\n    event Completed(uint256 indexed txId);\r\n\r\n    /// @dev is emitted when a aErc20 token is registered\r\n    event AERC20TokenRegistered(uint256 indexed tokenId, address indexed tokenAddress);\r\n\r\n    /// @dev is emitted when a tx info is saved\r\n    event TxHistorySet(uint256 indexed payloadId, uint256 txInfo, address indexed receiverAddress);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the payload header and the receiver address for a tx id on the source chain\r\n    /// @param txId_ is the identifier of the transaction issued by superform router\r\n    /// @return txInfo is the header of the payload\r\n    /// @return receiverAddressSP is the address of the receiver of superPositions\r\n    function txHistory(uint256 txId_) external view returns (uint256 txInfo, address receiverAddressSP);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev saves the message being sent together with the associated id formulated in a router\r\n    /// @param payloadId_ is the id of the message being saved\r\n    /// @param txInfo_ is the header of the AMBMessage of the transaction being saved\r\n    /// @param receiverAddressSP_ is the address of the receiver of superPositions\r\n    function updateTxHistory(uint256 payloadId_, uint256 txInfo_, address receiverAddressSP_) external;\r\n\r\n    /// @dev allows minter to mint shares on source\r\n    /// @param receiverAddress_ is the beneficiary of shares\r\n    /// @param id_ is the id of the shares\r\n    /// @param amount_ is the amount of shares to mint\r\n    function mintSingle(address receiverAddress_, uint256 id_, uint256 amount_) external;\r\n\r\n    /// @dev allows minter to mint shares on source in batch\r\n    /// @param receiverAddress_ is the beneficiary of shares\r\n    /// @param ids_ are the ids of the shares\r\n    /// @param amounts_ are the amounts of shares to mint\r\n    function mintBatch(address receiverAddress_, uint256[] memory ids_, uint256[] memory amounts_) external;\r\n\r\n    /// @dev allows superformRouter to burn shares on source\r\n    /// @notice burn is done optimistically by the router in the beginning of the withdraw transactions\r\n    /// @notice in case the withdraw tx fails on the destination, shares are reminted through stateSync\r\n    /// @param srcSender_ is the address of the sender\r\n    /// @param id_ is the id of the shares\r\n    /// @param amount_ is the amount of shares to burn\r\n    function burnSingle(address srcSender_, uint256 id_, uint256 amount_) external;\r\n\r\n    /// @dev allows burner to burn shares on source in batch\r\n    /// @param srcSender_ is the address of the sender\r\n    /// @param ids_ are the ids of the shares\r\n    /// @param amounts_ are the amounts of shares to burn\r\n    function burnBatch(address srcSender_, uint256[] memory ids_, uint256[] memory amounts_) external;\r\n\r\n    /// @dev allows state registry contract to mint shares on source\r\n    /// @param data_ is the received information to be processed.\r\n    /// @return srcChainId_ is the decoded srcChainId.\r\n    function stateMultiSync(AMBMessage memory data_) external returns (uint64 srcChainId_);\r\n\r\n    /// @dev allows state registry contract to mint shares on source\r\n    /// @param data_ is the received information to be processed.\r\n    /// @return srcChainId_ is the decoded srcChainId.\r\n    function stateSync(AMBMessage memory data_) external returns (uint64 srcChainId_);\r\n\r\n    /// @dev sets the dynamic uri for NFT\r\n    /// @param dynamicURI_ is the dynamic uri of the NFT\r\n    /// @param freeze_ is to prevent updating the metadata once migrated to IPFS\r\n    function setDynamicURI(string memory dynamicURI_, bool freeze_) external;\r\n\r\n    /// @dev allows to create sERC0 using broadcast state registry\r\n    /// @param data_ is the crosschain payload\r\n    function stateSyncBroadcast(bytes memory data_) external payable;\r\n}\r\n\r\n/// @title IPaymentHelper\r\n/// @dev Interface for PaymentHelper\r\n/// @author ZeroPoint Labs\r\ninterface IPaymentHelper {\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                           STRUCTS                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @param nativeFeedOracle is the native price feed oracle\r\n    /// @param gasPriceOracle is the gas price oracle\r\n    /// @param swapGasUsed is the swap gas params\r\n    /// @param updateGasUsed is the update gas params\r\n    /// @param depositGasUsed is the deposit per vault gas on the chain\r\n    /// @param withdrawGasUsed is the withdraw per vault gas on the chain\r\n    /// @param defaultNativePrice is the native price on the specified chain\r\n    /// @param defaultGasPrice is the gas price on the specified chain\r\n    /// @param dstGasPerByte is the gas per size of data on the specified chain\r\n    /// @param ackGasCost is the gas cost for processing acknowledgements on src chain\r\n    /// @param timelockCost is the extra cost for processing timelocked payloads\r\n    /// @param emergencyCost is the extra cost for processing emergency payloads\r\n    struct PaymentHelperConfig {\r\n        address nativeFeedOracle;\r\n        address gasPriceOracle;\r\n        uint256 swapGasUsed;\r\n        uint256 updateGasUsed;\r\n        uint256 depositGasUsed;\r\n        uint256 withdrawGasUsed;\r\n        uint256 defaultNativePrice;\r\n        uint256 defaultGasPrice;\r\n        uint256 dstGasPerByte;\r\n        uint256 ackGasCost;\r\n        uint256 timelockCost;\r\n        uint256 emergencyCost;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                          EVENTS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    event ChainConfigUpdated(uint64 indexed chainId_, uint256 indexed configType_, bytes indexed config_);\r\n    event ChainConfigAdded(uint64 chainId_, PaymentHelperConfig config_);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns the amb overrides & gas to be used\r\n    /// @param dstChainId_ is the unique dst chain identifier\r\n    /// @param ambIds_ is the identifiers of arbitrary message bridges to be used\r\n    /// @param message_ is the encoded cross-chain payload\r\n    function calculateAMBData(\r\n        uint64 dstChainId_,\r\n        uint8[] calldata ambIds_,\r\n        bytes memory message_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 totalFees, bytes memory extraData);\r\n\r\n    /// @dev returns the amb overrides & gas to be used\r\n    /// @return extraData the amb specific override information\r\n    function getRegisterTransmuterAMBData() external view returns (bytes memory extraData);\r\n\r\n    /// @dev returns the gas fees estimation in native tokens if we send message through a combination of AMBs\r\n    /// @param ambIds_ is the identifier of different AMBs\r\n    /// @param dstChainId_ is the identifier of the destination chain\r\n    /// @param message_ is the cross-chain message\r\n    /// @param extraData_ is any amb-specific information\r\n    /// @return ambFees is the native_tokens to be sent along the transaction for all the ambIds_ included\r\n    function estimateAMBFees(\r\n        uint8[] memory ambIds_,\r\n        uint64 dstChainId_,\r\n        bytes memory message_,\r\n        bytes[] memory extraData_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 ambFees, uint256[] memory);\r\n\r\n    /// @dev estimates the gas fees for multiple destination and multi vault operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateMultiDstMultiVault(\r\n        MultiDstMultiVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for multiple destination and single vault operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateMultiDstSingleVault(\r\n        MultiDstSingleVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for single destination and multi vault operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateSingleXChainMultiVault(\r\n        SingleXChainMultiVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for single destination and single vault operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateSingleXChainSingleVault(\r\n        SingleXChainSingleVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for same chain operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateSingleDirectSingleVault(\r\n        SingleDirectSingleVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\r\n\r\n    /// @dev estimates the gas fees for multiple same chain operation\r\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\r\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\r\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\r\n    /// @return srcAmount is the gas expense on source chain in native tokens\r\n    /// @return totalAmount is the native_tokens to be sent along the transaction\r\n    function estimateSingleDirectMultiVault(\r\n        SingleDirectMultiVaultStateReq calldata req_,\r\n        bool isDeposit_\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev admin can configure a remote chain for first time\r\n    /// @param chainId_ is the identifier of new chain id\r\n    /// @param config_ is the chain config\r\n    function addRemoteChain(uint64 chainId_, PaymentHelperConfig calldata config_) external;\r\n\r\n    /// @dev admin can specifically configure/update certain configuration of a remote chain\r\n    /// @param chainId_ is the remote chain's identifier\r\n    /// @param configType_ is the type of config from 1 -> 6\r\n    /// @param config_ is the encoded new configuration\r\n    function updateRemoteChain(uint64 chainId_, uint256 configType_, bytes memory config_) external;\r\n\r\n    /// @dev admin updates config for register transmuter amb params\r\n    /// @param extraDataForTransmuter_ is the broadcast extra data\r\n    function updateRegisterAERC20Params(bytes memory extraDataForTransmuter_) external;\r\n}\r\n\r\nlibrary DataLib {\r\n    function packTxInfo(\r\n        uint8 txType_,\r\n        uint8 callbackType_,\r\n        uint8 multi_,\r\n        uint8 registryId_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 txInfo)\r\n    {\r\n        txInfo = uint256(txType_);\r\n        txInfo |= uint256(callbackType_) << 8;\r\n        txInfo |= uint256(multi_) << 16;\r\n        txInfo |= uint256(registryId_) << 24;\r\n        txInfo |= uint256(uint160(srcSender_)) << 32;\r\n        txInfo |= uint256(srcChainId_) << 192;\r\n    }\r\n\r\n    function decodeTxInfo(uint256 txInfo_)\r\n        internal\r\n        pure\r\n        returns (uint8 txType, uint8 callbackType, uint8 multi, uint8 registryId, address srcSender, uint64 srcChainId)\r\n    {\r\n        txType = uint8(txInfo_);\r\n        callbackType = uint8(txInfo_ >> 8);\r\n        multi = uint8(txInfo_ >> 16);\r\n        registryId = uint8(txInfo_ >> 24);\r\n        srcSender = address(uint160(txInfo_ >> 32));\r\n        srcChainId = uint64(txInfo_ >> 192);\r\n    }\r\n\r\n    /// @dev returns the vault-form-chain pair of a superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return superform_ is the address of the superform\r\n    /// @return formImplementationId_ is the form id\r\n    /// @return chainId_ is the chain id\r\n    function getSuperform(uint256 superformId_)\r\n        internal\r\n        pure\r\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_)\r\n    {\r\n        superform_ = address(uint160(superformId_));\r\n        formImplementationId_ = uint32(superformId_ >> 160);\r\n        chainId_ = uint64(superformId_ >> 192);\r\n\r\n        if (chainId_ == 0) {\r\n            revert Error.INVALID_CHAIN_ID();\r\n        }\r\n    }\r\n\r\n    /// @dev returns the vault-form-chain pair of an array of superforms\r\n    /// @param superformIds_  array of superforms\r\n    /// @return superforms_ are the address of the vaults\r\n    function getSuperforms(uint256[] memory superformIds_) internal pure returns (address[] memory superforms_) {\r\n        uint256 len = superformIds_.length;\r\n        superforms_ = new address[](len);\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            (superforms_[i],,) = getSuperform(superformIds_[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev returns the destination chain of a given superform\r\n    /// @param superformId_ is the id of the superform\r\n    /// @return chainId_ is the chain id\r\n    function getDestinationChain(uint256 superformId_) internal pure returns (uint64 chainId_) {\r\n        chainId_ = uint64(superformId_ >> 192);\r\n\r\n        if (chainId_ == 0) {\r\n            revert Error.INVALID_CHAIN_ID();\r\n        }\r\n    }\r\n\r\n    /// @dev generates the superformId\r\n    /// @param superform_ is the address of the superform\r\n    /// @param formImplementationId_ is the type of the form\r\n    /// @param chainId_ is the chain id on which the superform is deployed\r\n    function packSuperform(\r\n        address superform_,\r\n        uint32 formImplementationId_,\r\n        uint64 chainId_\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 superformId_)\r\n    {\r\n        superformId_ = uint256(uint160(superform_));\r\n        superformId_ |= uint256(formImplementationId_) << 160;\r\n        superformId_ |= uint256(chainId_) << 192;\r\n    }\r\n}\r\n\r\n/// @dev library to cast single values into array for streamlining helper functions\r\n/// @notice not gas optimized, suggested for usage only in view/pure functions\r\nlibrary ArrayCastLib {\r\n    function castLiqRequestToArray(LiqRequest memory value_) internal pure returns (LiqRequest[] memory values) {\r\n        values = new LiqRequest[](1);\r\n\r\n        values[0] = value_;\r\n    }\r\n\r\n    function castBoolToArray(bool value_) internal pure returns (bool[] memory values) {\r\n        values = new bool[](1);\r\n\r\n        values[0] = value_;\r\n    }\r\n\r\n    function castToMultiVaultData(InitSingleVaultData memory data_)\r\n        internal\r\n        pure\r\n        returns (InitMultiVaultData memory castedData_)\r\n    {\r\n        uint256[] memory superformIds = new uint256[](1);\r\n        superformIds[0] = data_.superformId;\r\n\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = data_.amount;\r\n\r\n        uint256[] memory outputAmounts = new uint256[](1);\r\n        outputAmounts[0] = data_.outputAmount;\r\n\r\n        uint256[] memory maxSlippage = new uint256[](1);\r\n        maxSlippage[0] = data_.maxSlippage;\r\n\r\n        LiqRequest[] memory liqData = new LiqRequest[](1);\r\n        liqData[0] = data_.liqData;\r\n\r\n        castedData_ = InitMultiVaultData(\r\n            data_.payloadId,\r\n            superformIds,\r\n            amounts,\r\n            outputAmounts,\r\n            maxSlippage,\r\n            liqData,\r\n            castBoolToArray(data_.hasDstSwap),\r\n            castBoolToArray(data_.retain4626),\r\n            data_.receiverAddress,\r\n            data_.extraFormData\r\n        );\r\n    }\r\n}\r\n\r\n/// @dev library to validate slippage updation\r\nlibrary PayloadUpdaterLib {\r\n    function validateSlippage(\r\n        uint256 newAmount_,\r\n        uint256 maxAmount_,\r\n        uint256 slippage_\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool valid_)\r\n    {\r\n        /// @dev args validation\r\n        if (newAmount_ > maxAmount_) {\r\n            revert Error.NEGATIVE_SLIPPAGE();\r\n        }\r\n\r\n        uint256 minAmount = (maxAmount_ * (10_000 - slippage_)) / 10_000;\r\n\r\n        /// @dev amount must fall within the slippage bounds\r\n        if (newAmount_ < minAmount) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function validateLiqReq(LiqRequest memory req_) internal pure {\r\n        /// revert if token is address(0) -> user wants settlement without any liq data\r\n        /// revert if token is not address(0) and txData is already present\r\n        if (req_.token == address(0) || req_.txData.length != 0) {\r\n            revert Error.CANNOT_UPDATE_WITHDRAW_TX_DATA();\r\n        }\r\n    }\r\n\r\n    function validatePayloadUpdate(\r\n        uint256 txInfo_,\r\n        uint8 txType_,\r\n        PayloadState currentPayloadState_,\r\n        uint8 isMulti_\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        (uint256 txType, uint256 callbackType, uint8 multi,,,) = DataLib.decodeTxInfo(txInfo_);\r\n\r\n        if (!(txType == txType_ && callbackType == uint256(CallbackType.INIT))) {\r\n            revert Error.INVALID_PAYLOAD_UPDATE_REQUEST();\r\n        }\r\n\r\n        if (currentPayloadState_ != PayloadState.STORED) {\r\n            revert Error.PAYLOAD_ALREADY_UPDATED();\r\n        }\r\n\r\n        if (multi != isMulti_) {\r\n            revert Error.INVALID_PAYLOAD_UPDATE_REQUEST();\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n *\r\n * ==== Security Considerations\r\n *\r\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\r\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\r\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\r\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\r\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\r\n * generally recommended is:\r\n *\r\n * ```solidity\r\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\r\n *     doThing(..., value);\r\n * }\r\n *\r\n * function doThing(..., uint256 value) public {\r\n *     token.safeTransferFrom(msg.sender, address(this), value);\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\r\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\r\n * {SafeERC20-safeTransferFrom}).\r\n *\r\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\r\n * contracts should have entry points that don't rely on permit.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     *\r\n     * CAUTION: See Security Considerations above.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC-20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Indicates a failed `decreaseAllowance` request.\r\n     */\r\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        forceApprove(token, spender, oldAllowance + value);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\r\n     * value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\r\n        unchecked {\r\n            uint256 currentAllowance = token.allowance(address(this), spender);\r\n            if (currentAllowance < requestedDecrease) {\r\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\r\n            }\r\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\r\n    }\r\n}\r\n\r\n/// @title CoreStateRegistry\r\n/// @dev Enables communication between Superform core contracts deployed on all supported networks\r\n/// @author Zeropoint Labs\r\ncontract CoreStateRegistry is BaseStateRegistry, ICoreStateRegistry {\r\n    using SafeERC20 for IERC20;\r\n    using DataLib for uint256;\r\n    using ProofLib for AMBMessage;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                     STATE VARIABLES                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev just stores the superformIds that failed in a specific payload id\r\n    mapping(uint256 payloadId => FailedDeposit) failedDeposits;\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                       MODIFIERS                          //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    modifier onlySender() override {\r\n        if (msg.sender != _getAddress(keccak256(\"SUPERFORM_ROUTER\"))) revert Error.NOT_SUPERFORM_ROUTER();\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                      CONSTRUCTOR                         //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    constructor(ISuperRegistry superRegistry_) BaseStateRegistry(superRegistry_) { }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL VIEW FUNCTIONS                     //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @inheritdoc ICoreStateRegistry\r\n    function getFailedDeposits(uint256 payloadId_)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256[] memory superformIds, uint256[] memory amounts, uint256 lastProposedTime)\r\n    {\r\n        FailedDeposit storage failedDeposit = failedDeposits[payloadId_];\r\n        superformIds = failedDeposit.superformIds;\r\n        amounts = failedDeposit.amounts;\r\n        lastProposedTime = failedDeposit.lastProposedTimestamp;\r\n    }\r\n\r\n    /// @inheritdoc ICoreStateRegistry\r\n    function validateSlippage(uint256 finalAmount_, uint256 amount_, uint256 maxSlippage_) public view returns (bool) {\r\n        // only internal transaction\r\n        if (msg.sender != address(this)) {\r\n            revert Error.INVALID_INTERNAL_CALL();\r\n        }\r\n\r\n        return PayloadUpdaterLib.validateSlippage(finalAmount_, amount_, maxSlippage_);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //              EXTERNAL WRITE FUNCTIONS                    //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @inheritdoc ICoreStateRegistry\r\n    function updateDepositPayload(\r\n        uint256 payloadId_,\r\n        address[] calldata finalTokens_,\r\n        uint256[] calldata finalAmounts_\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n    {\r\n        /// @dev validates the caller\r\n        _onlyAllowedCaller(keccak256(\"CORE_STATE_REGISTRY_UPDATER_ROLE\"));\r\n\r\n        /// @dev validates the payload id\r\n        _validatePayloadId(payloadId_);\r\n\r\n        (uint256 prevPayloadHeader, bytes memory prevPayloadBody, bytes32 prevPayloadProof,,, uint8 isMulti,,,) =\r\n            _getPayload(payloadId_);\r\n\r\n        PayloadUpdaterLib.validatePayloadUpdate(\r\n            prevPayloadHeader, uint8(TransactionType.DEPOSIT), payloadTracking[payloadId_], isMulti\r\n        );\r\n\r\n        PayloadState finalState;\r\n        if (isMulti != 0) {\r\n            (prevPayloadBody, finalState) =\r\n                _updateMultiDeposit(payloadId_, prevPayloadBody, finalAmounts_, finalTokens_);\r\n        } else {\r\n            (prevPayloadBody, finalState) =\r\n                _updateSingleDeposit(payloadId_, prevPayloadBody, finalAmounts_[0], finalTokens_[0]);\r\n        }\r\n\r\n        /// @dev updates the payload proof\r\n        _updatePayload(payloadId_, prevPayloadProof, prevPayloadBody, prevPayloadHeader, finalState);\r\n\r\n        /// @dev if payload is processed at this stage then it is failing\r\n        if (finalState == PayloadState.PROCESSED) {\r\n            emit PayloadProcessed(payloadId_);\r\n            emit FailedXChainDeposits(payloadId_);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ICoreStateRegistry\r\n    function updateWithdrawPayload(uint256 payloadId_, bytes[] calldata txData_) external virtual override {\r\n        /// @dev validates the caller\r\n        _onlyAllowedCaller(keccak256(\"CORE_STATE_REGISTRY_UPDATER_ROLE\"));\r\n\r\n        /// @dev validates the payload id\r\n        _validatePayloadId(payloadId_);\r\n\r\n        (\r\n            uint256 prevPayloadHeader,\r\n            bytes memory prevPayloadBody,\r\n            bytes32 prevPayloadProof,\r\n            ,\r\n            ,\r\n            uint8 isMulti,\r\n            ,\r\n            ,\r\n            uint64 srcChainId\r\n        ) = _getPayload(payloadId_);\r\n\r\n        /// @dev validate payload update\r\n        PayloadUpdaterLib.validatePayloadUpdate(\r\n            prevPayloadHeader, uint8(TransactionType.WITHDRAW), payloadTracking[payloadId_], isMulti\r\n        );\r\n        prevPayloadBody = _updateWithdrawPayload(prevPayloadBody, srcChainId, txData_, isMulti);\r\n\r\n        /// @dev updates the payload proof\r\n        _updatePayload(payloadId_, prevPayloadProof, prevPayloadBody, prevPayloadHeader, PayloadState.UPDATED);\r\n\r\n        emit PayloadUpdated(payloadId_);\r\n    }\r\n\r\n    /// @inheritdoc BaseStateRegistry\r\n    function processPayload(uint256 payloadId_) external payable virtual override {\r\n        /// @dev validates the caller\r\n        _onlyAllowedCaller(keccak256(\"CORE_STATE_REGISTRY_PROCESSOR_ROLE\"));\r\n\r\n        /// @dev validates the payload id\r\n        _validatePayloadId(payloadId_);\r\n\r\n        if (payloadTracking[payloadId_] == PayloadState.PROCESSED) {\r\n            revert Error.PAYLOAD_ALREADY_PROCESSED();\r\n        }\r\n\r\n        PayloadState initialState = payloadTracking[payloadId_];\r\n        /// @dev sets status as processed to prevent re-entrancy\r\n        payloadTracking[payloadId_] = PayloadState.PROCESSED;\r\n\r\n        (\r\n            uint256 payloadHeader_,\r\n            bytes memory payloadBody_,\r\n            ,\r\n            uint8 txType,\r\n            uint8 callbackType,\r\n            uint8 isMulti,\r\n            ,\r\n            address srcSender,\r\n            uint64 srcChainId\r\n        ) = _getPayload(payloadId_);\r\n\r\n        AMBMessage memory message_ = AMBMessage(payloadHeader_, payloadBody_);\r\n\r\n        /// @dev mint superPositions for successful deposits or remint for failed withdraws\r\n        if (callbackType == uint256(CallbackType.RETURN) || callbackType == uint256(CallbackType.FAIL)) {\r\n            ISuperPositions superPositions = ISuperPositions(_getAddress(keccak256(\"SUPER_POSITIONS\")));\r\n            isMulti == 1 ? superPositions.stateMultiSync(message_) : superPositions.stateSync(message_);\r\n        } else if (callbackType == uint8(CallbackType.INIT)) {\r\n            /// @dev for initial payload processing\r\n            bytes memory returnMessage;\r\n\r\n            if (txType == uint8(TransactionType.WITHDRAW)) {\r\n                returnMessage = isMulti == 1\r\n                    ? _multiWithdrawal(payloadId_, payloadBody_, srcSender, srcChainId)\r\n                    : _singleWithdrawal(payloadId_, payloadBody_, srcSender, srcChainId);\r\n            } else if (txType == uint8(TransactionType.DEPOSIT)) {\r\n                if (initialState != PayloadState.UPDATED) {\r\n                    revert Error.PAYLOAD_NOT_UPDATED();\r\n                }\r\n\r\n                returnMessage = isMulti == 1\r\n                    ? _multiDeposit(payloadId_, payloadBody_, srcSender, srcChainId)\r\n                    : _singleDeposit(payloadId_, payloadBody_, srcSender, srcChainId);\r\n            }\r\n\r\n            _processAck(payloadId_, srcChainId, returnMessage);\r\n        } else {\r\n            revert Error.INVALID_PAYLOAD_TYPE();\r\n        }\r\n\r\n        emit PayloadProcessed(payloadId_);\r\n    }\r\n\r\n    /// @inheritdoc ICoreStateRegistry\r\n    function proposeRescueFailedDeposits(uint256 payloadId_, uint256[] calldata proposedAmounts_) external override {\r\n        /// @dev validates the caller\r\n        _onlyAllowedCaller(keccak256(\"CORE_STATE_REGISTRY_RESCUER_ROLE\"));\r\n\r\n        /// @dev validates the payload id\r\n        _validatePayloadId(payloadId_);\r\n\r\n        FailedDeposit storage failedDeposits_ = failedDeposits[payloadId_];\r\n\r\n        if (failedDeposits_.superformIds.length == 0 || failedDeposits_.superformIds.length != proposedAmounts_.length)\r\n        {\r\n            revert Error.INVALID_RESCUE_DATA();\r\n        }\r\n\r\n        if (failedDeposits_.lastProposedTimestamp != 0) {\r\n            revert Error.RESCUE_ALREADY_PROPOSED();\r\n        }\r\n\r\n        /// @dev should set this value to dstSwapper.failedSwap().amount for interim rescue\r\n        failedDeposits[payloadId_].amounts = proposedAmounts_;\r\n        failedDeposits[payloadId_].lastProposedTimestamp = block.timestamp;\r\n\r\n        (,, uint8 multi,,,) = DataLib.decodeTxInfo(payloadHeader[payloadId_]);\r\n\r\n        address receiverAddress;\r\n        if (multi == 1) {\r\n            receiverAddress = abi.decode(payloadBody[payloadId_], (InitMultiVaultData)).receiverAddress;\r\n        } else {\r\n            receiverAddress = abi.decode(payloadBody[payloadId_], (InitSingleVaultData)).receiverAddress;\r\n        }\r\n\r\n        failedDeposits[payloadId_].receiverAddress = receiverAddress;\r\n        emit RescueProposed(payloadId_, failedDeposits_.superformIds, proposedAmounts_, block.timestamp);\r\n    }\r\n\r\n    /// @inheritdoc ICoreStateRegistry\r\n    function disputeRescueFailedDeposits(uint256 payloadId_) external override {\r\n        /// @dev validates the payload id\r\n        _validatePayloadId(payloadId_);\r\n\r\n        FailedDeposit storage failedDeposits_ = failedDeposits[payloadId_];\r\n\r\n        /// @dev the msg sender should be the refund address (or) the disputer\r\n        if (\r\n            !(\r\n                msg.sender == failedDeposits_.receiverAddress\r\n                    || _hasRole(keccak256(\"CORE_STATE_REGISTRY_DISPUTER_ROLE\"), msg.sender)\r\n            )\r\n        ) {\r\n            revert Error.NOT_VALID_DISPUTER();\r\n        }\r\n\r\n        /// @dev the timelock is already elapsed to dispute\r\n        if (\r\n            failedDeposits_.lastProposedTimestamp == 0\r\n                || block.timestamp > failedDeposits_.lastProposedTimestamp + _getDelay()\r\n        ) {\r\n            revert Error.DISPUTE_TIME_ELAPSED();\r\n        }\r\n\r\n        /// @dev just can reset last proposed time here, since amounts should be updated again to\r\n        /// pass the lastProposedTimestamp zero check in finalize\r\n        failedDeposits[payloadId_].lastProposedTimestamp = 0;\r\n\r\n        emit RescueDisputed(payloadId_);\r\n    }\r\n\r\n    /// @inheritdoc ICoreStateRegistry\r\n    /// @notice is an open function & can be executed by anyone\r\n    function finalizeRescueFailedDeposits(uint256 payloadId_) external override {\r\n        /// @dev validates the payload id\r\n        _validatePayloadId(payloadId_);\r\n\r\n        FailedDeposit storage failedDeposits_ = failedDeposits[payloadId_];\r\n\r\n        /// @dev the timelock is elapsed\r\n        if (\r\n            failedDeposits_.lastProposedTimestamp == 0\r\n                || block.timestamp <= failedDeposits_.lastProposedTimestamp + _getDelay()\r\n        ) {\r\n            revert Error.RESCUE_LOCKED();\r\n        }\r\n\r\n        /// @dev set to zero to prevent re-entrancy\r\n        failedDeposits_.lastProposedTimestamp = 0;\r\n\r\n        uint256 len = failedDeposits_.amounts.length;\r\n        for (uint256 i; i < len; ++i) {\r\n            /// @dev refunds the amount to user specified refund address\r\n            if (failedDeposits_.settleFromDstSwapper[i]) {\r\n                IDstSwapper(_getAddress(keccak256(\"DST_SWAPPER\"))).processFailedTx(\r\n                    failedDeposits_.receiverAddress, failedDeposits_.settlementToken[i], failedDeposits_.amounts[i]\r\n                );\r\n            } else {\r\n                IERC20(failedDeposits_.settlementToken[i]).safeTransfer(\r\n                    failedDeposits_.receiverAddress, failedDeposits_.amounts[i]\r\n                );\r\n            }\r\n        }\r\n\r\n        delete failedDeposits[payloadId_];\r\n        emit RescueFinalized(payloadId_);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //                  INTERNAL FUNCTIONS                      //\r\n    //////////////////////////////////////////////////////////////\r\n\r\n    /// @dev returns vault asset from superform\r\n    function _getVaultAsset(address superform_) internal view returns (address) {\r\n        return IBaseForm(superform_).getVaultAsset();\r\n    }\r\n\r\n    /// @dev returns if superform is valid\r\n    function _isSuperform(uint256 superformId_) internal view returns (bool) {\r\n        return ISuperformFactory(_getAddress(keccak256(\"SUPERFORM_FACTORY\"))).isSuperform(superformId_);\r\n    }\r\n\r\n    /// @dev returns a superformAddress\r\n    function _getSuperform(uint256 superformId_) internal pure returns (address superform) {\r\n        (superform,,) = superformId_.getSuperform();\r\n    }\r\n\r\n    /// @dev returns if an address has a specific role\r\n    function _hasRole(bytes32 id_, address addressToCheck_) internal view returns (bool) {\r\n        return ISuperRBAC(_getAddress(keccak256(\"SUPER_RBAC\"))).hasRole(id_, addressToCheck_);\r\n    }\r\n\r\n    /// @dev returns the registry address for id\r\n    function _getStateRegistryId(address registryAddress_) internal view returns (uint8 id) {\r\n        return superRegistry.getStateRegistryId(registryAddress_);\r\n    }\r\n\r\n    /// @dev returns the address from super registry\r\n    function _getAddress(bytes32 id_) internal view returns (address) {\r\n        return superRegistry.getAddress(id_);\r\n    }\r\n\r\n    /// @dev returns the current timelock delay\r\n    function _getDelay() internal view returns (uint256) {\r\n        uint256 delay = superRegistry.delay();\r\n        if (delay == 0) {\r\n            revert Error.DELAY_NOT_SET();\r\n        }\r\n        return delay;\r\n    }\r\n\r\n    function _validatePayloadId(uint256 payloadId_) internal view {\r\n        if (payloadId_ > payloadsCount) {\r\n            revert Error.INVALID_PAYLOAD_ID();\r\n        }\r\n    }\r\n\r\n    function _onlyAllowedCaller(bytes32 role_) internal view {\r\n        if (!_hasRole(role_, msg.sender)) revert Error.NOT_PRIVILEGED_CALLER(role_);\r\n    }\r\n\r\n    /// @dev retrieves information associated with the payload and validates quorum\r\n    function _getPayload(uint256 payloadId_)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 payloadHeader_,\r\n            bytes memory payloadBody_,\r\n            bytes32 payloadProof,\r\n            uint8 txType,\r\n            uint8 callbackType,\r\n            uint8 isMulti,\r\n            uint8 registryId,\r\n            address srcSender,\r\n            uint64 srcChainId\r\n        )\r\n    {\r\n        payloadHeader_ = payloadHeader[payloadId_];\r\n        payloadBody_ = payloadBody[payloadId_];\r\n        payloadProof = AMBMessage(payloadHeader_, payloadBody_).computeProof();\r\n        (txType, callbackType, isMulti, registryId, srcSender, srcChainId) = payloadHeader_.decodeTxInfo();\r\n\r\n        /// @dev the number of valid proofs (quorum) must be equal or larger to the required messaging quorum\r\n        if (messageQuorum[payloadProof] < _getQuorum(srcChainId)) {\r\n            revert Error.INSUFFICIENT_QUORUM();\r\n        }\r\n    }\r\n\r\n    /// @dev helper function to update multi vault deposit payload\r\n    function _updateMultiDeposit(\r\n        uint256 payloadId_,\r\n        bytes memory prevPayloadBody_,\r\n        uint256[] calldata finalAmounts_,\r\n        address[] calldata finalToken_\r\n    )\r\n        internal\r\n        returns (bytes memory newPayloadBody_, PayloadState finalState_)\r\n    {\r\n        InitMultiVaultData memory multiVaultData = abi.decode(prevPayloadBody_, (InitMultiVaultData));\r\n\r\n        uint256 arrLen = finalAmounts_.length;\r\n        /// @dev compare number of vaults to update with provided finalAmounts length\r\n        if (multiVaultData.amounts.length != arrLen) {\r\n            revert Error.DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\r\n        }\r\n\r\n        uint256 validLen;\r\n        for (uint256 i; i < arrLen; ++i) {\r\n            if (finalAmounts_[i] == 0) {\r\n                revert Error.ZERO_AMOUNT();\r\n            }\r\n\r\n            if (_getVaultAsset(_getSuperform(multiVaultData.superformIds[i])) != finalToken_[i]) {\r\n                revert Error.INVALID_UPDATE_FINAL_TOKEN();\r\n            }\r\n\r\n            /// @dev observe not consuming the second return value\r\n            (multiVaultData.amounts[i],, validLen) = _updateAmount(\r\n                IDstSwapper(_getAddress(keccak256(\"DST_SWAPPER\"))),\r\n                multiVaultData.hasDstSwaps[i],\r\n                payloadId_,\r\n                i,\r\n                finalAmounts_[i],\r\n                multiVaultData.superformIds[i],\r\n                multiVaultData.amounts[i],\r\n                multiVaultData.maxSlippages[i],\r\n                finalState_,\r\n                validLen\r\n            );\r\n        }\r\n\r\n        /// @dev validLen > 0 for the cases where there was at least one deposit update that had valid slippage\r\n        /// @dev (v1: passedSlippage, v2: failedSlippage, v3: passedSlippage)\r\n        /// @dev final vaults: (v1, v3) / PayloadState.UPDATED\r\n        /// @dev if validLen is 0 then Payload is marked as processed and can be extracted via rescue\r\n        if (validLen != 0) {\r\n            uint256[] memory finalSuperformIds = new uint256[](validLen);\r\n            uint256[] memory finalAmounts = new uint256[](validLen);\r\n            uint256[] memory outputAmounts = new uint256[](validLen);\r\n            uint256[] memory maxSlippage = new uint256[](validLen);\r\n            bool[] memory hasDstSwaps = new bool[](validLen);\r\n            bool[] memory retain4626s = new bool[](validLen);\r\n\r\n            uint256 currLen;\r\n            for (uint256 i; i < arrLen; ++i) {\r\n                if (multiVaultData.amounts[i] != 0) {\r\n                    finalSuperformIds[currLen] = multiVaultData.superformIds[i];\r\n                    finalAmounts[currLen] = multiVaultData.amounts[i];\r\n                    outputAmounts[currLen] = multiVaultData.outputAmounts[i];\r\n                    maxSlippage[currLen] = multiVaultData.maxSlippages[i];\r\n                    hasDstSwaps[currLen] = multiVaultData.hasDstSwaps[i];\r\n                    retain4626s[currLen] = multiVaultData.retain4626s[i];\r\n\r\n                    ++currLen;\r\n                }\r\n            }\r\n\r\n            multiVaultData.superformIds = finalSuperformIds;\r\n            multiVaultData.amounts = finalAmounts;\r\n            multiVaultData.outputAmounts = outputAmounts;\r\n            multiVaultData.maxSlippages = maxSlippage;\r\n            multiVaultData.hasDstSwaps = hasDstSwaps;\r\n            multiVaultData.retain4626s = retain4626s;\r\n            finalState_ = PayloadState.UPDATED;\r\n        } else {\r\n            finalState_ = PayloadState.PROCESSED;\r\n        }\r\n        newPayloadBody_ = abi.encode(multiVaultData);\r\n    }\r\n\r\n    /// @dev helper function to update single vault deposit payload\r\n    function _updateSingleDeposit(\r\n        uint256 payloadId_,\r\n        bytes memory prevPayloadBody_,\r\n        uint256 finalAmount_,\r\n        address finalToken_\r\n    )\r\n        internal\r\n        returns (bytes memory newPayloadBody_, PayloadState finalState_)\r\n    {\r\n        InitSingleVaultData memory singleVaultData = abi.decode(prevPayloadBody_, (InitSingleVaultData));\r\n\r\n        if (finalAmount_ == 0) {\r\n            revert Error.ZERO_AMOUNT();\r\n        }\r\n\r\n        if (_getVaultAsset(_getSuperform(singleVaultData.superformId)) != finalToken_) {\r\n            revert Error.INVALID_UPDATE_FINAL_TOKEN();\r\n        }\r\n\r\n        /// @dev observe not consuming the third return value\r\n        (singleVaultData.amount, finalState_,) = _updateAmount(\r\n            IDstSwapper(_getAddress(keccak256(\"DST_SWAPPER\"))),\r\n            singleVaultData.hasDstSwap,\r\n            payloadId_,\r\n            0,\r\n            finalAmount_,\r\n            singleVaultData.superformId,\r\n            singleVaultData.amount,\r\n            singleVaultData.maxSlippage,\r\n            finalState_,\r\n            0\r\n        );\r\n\r\n        newPayloadBody_ = abi.encode(singleVaultData);\r\n    }\r\n\r\n    function _updateAmount(\r\n        IDstSwapper dstSwapper,\r\n        bool hasDstSwap_,\r\n        uint256 payloadId_,\r\n        uint256 index_,\r\n        uint256 finalAmount_,\r\n        uint256 superformId_,\r\n        uint256 amount_,\r\n        uint256 maxSlippage_,\r\n        PayloadState finalState_,\r\n        uint256 validLen_\r\n    )\r\n        internal\r\n        returns (uint256, PayloadState, uint256)\r\n    {\r\n        bool failedSwapQueued;\r\n        if (hasDstSwap_) {\r\n            if (dstSwapper.swappedAmount(payloadId_, index_) != finalAmount_) {\r\n                (address interimToken, uint256 amount) =\r\n                    dstSwapper.getPostDstSwapFailureUpdatedTokenAmount(payloadId_, index_);\r\n\r\n                if (amount != finalAmount_) {\r\n                    revert Error.INVALID_DST_SWAP_AMOUNT();\r\n                } else {\r\n                    failedSwapQueued = true;\r\n                    failedDeposits[payloadId_].superformIds.push(superformId_);\r\n                    failedDeposits[payloadId_].settlementToken.push(interimToken);\r\n                    failedDeposits[payloadId_].settleFromDstSwapper.push(true);\r\n\r\n                    /// @dev sets amount to zero and will mark the payload as PROCESSED\r\n                    amount_ = 0;\r\n                    finalState_ = PayloadState.PROCESSED;\r\n                }\r\n            }\r\n        }\r\n\r\n        /// @dev validate payload update\r\n        /// @dev validLen may only be increased here in the case where slippage for the update is valid\r\n        /// @notice we enter this if condition only if there is a valid dstSwap OR if there is just bridging to this\r\n        /// contract\r\n        if (!failedSwapQueued) {\r\n            /// if the slippage is within allowed amount && the superform id also exists\r\n            try this.validateSlippage(finalAmount_, amount_, maxSlippage_) returns (bool valid) {\r\n                /// @dev in case of a valid slippage check we update the amount to finalAmount_\r\n                if (valid) {\r\n                    amount_ = finalAmount_;\r\n                    /// @dev Mark the payload as UPDATED\r\n                    finalState_ = PayloadState.UPDATED;\r\n                }\r\n            } catch {\r\n                /// @dev in case of negative slippage we don't update the amount in the user request to the amount\r\n                /// provided by the keeper\r\n                /// @notice it remains as the original amount supplied by the user in the original state request\r\n                /// @notice This means than any difference from the amount provided by the keepeer to the user supplied\r\n                /// amount will be collected in this contract and remain here\r\n                /// @notice we consider this to also be validSlippage = true\r\n                /// @dev Mark the payload as UPDATED\r\n                finalState_ = PayloadState.UPDATED;\r\n            }\r\n\r\n            if (!(_isSuperform(superformId_) && finalState_ == PayloadState.UPDATED)) {\r\n                failedDeposits[payloadId_].superformIds.push(superformId_);\r\n\r\n                address asset;\r\n                try IBaseForm(_getSuperform(superformId_)).getVaultAsset() returns (address asset_) {\r\n                    asset = asset_;\r\n                } catch {\r\n                    /// @dev if its error, we just consider asset as zero address\r\n                }\r\n                /// @dev if superform is invalid, try catch will fail and asset pushed is address (0)\r\n                /// @notice this means that if a user tries to game the protocol with an invalid superformId, the funds\r\n                /// bridged over that failed will be stuck here\r\n                /// @notice assets can still be spoofed with any vault.asset(), hence this is done via permissioned role\r\n                failedDeposits[payloadId_].settlementToken.push(asset);\r\n                failedDeposits[payloadId_].settleFromDstSwapper.push(false);\r\n\r\n                /// @dev sets amount to zero and will mark the payload as PROCESSED (overriding the previous memory\r\n                /// settings)\r\n                amount_ = 0;\r\n                finalState_ = PayloadState.PROCESSED;\r\n            } else {\r\n                ++validLen_;\r\n            }\r\n        }\r\n\r\n        return (amount_, finalState_, validLen_);\r\n    }\r\n\r\n    /// @dev helper function to update multi vault withdraw payload\r\n    function _updateWithdrawPayload(\r\n        bytes memory prevPayloadBody_,\r\n        uint64 srcChainId_,\r\n        bytes[] calldata txData_,\r\n        uint8 multi\r\n    )\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        InitMultiVaultData memory multiVaultData;\r\n        InitSingleVaultData memory singleVaultData;\r\n        if (multi == 1) {\r\n            multiVaultData = abi.decode(prevPayloadBody_, (InitMultiVaultData));\r\n        } else {\r\n            singleVaultData = abi.decode(prevPayloadBody_, (InitSingleVaultData));\r\n            multiVaultData = ArrayCastLib.castToMultiVaultData(singleVaultData);\r\n        }\r\n\r\n        if (multiVaultData.liqData.length != txData_.length) {\r\n            revert Error.DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\r\n        }\r\n\r\n        multiVaultData = _updateTxData(txData_, multiVaultData, srcChainId_, CHAIN_ID);\r\n\r\n        if (multi == 0) {\r\n            singleVaultData.liqData.txData = multiVaultData.liqData[0].txData;\r\n            return abi.encode(singleVaultData);\r\n        }\r\n\r\n        return abi.encode(multiVaultData);\r\n    }\r\n\r\n    /// @dev validates the incoming update data\r\n    function _updateTxData(\r\n        bytes[] calldata txData_,\r\n        InitMultiVaultData memory multiVaultData_,\r\n        uint64 srcChainId_,\r\n        uint64 dstChainId_\r\n    )\r\n        internal\r\n        view\r\n        returns (InitMultiVaultData memory)\r\n    {\r\n        uint256 len = multiVaultData_.liqData.length;\r\n        IBaseForm superform;\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            if (txData_[i].length != 0 && multiVaultData_.liqData[i].txData.length == 0) {\r\n                superform = IBaseForm(_getSuperform(multiVaultData_.superformIds[i]));\r\n\r\n                /// @dev for withdrawals the payload update can happen on core state registry (for normal forms)\r\n                /// and also can happen in timelock state registry (for timelock form)\r\n\r\n                /// @notice this check validates if the state registry is eligible to update tx data for the\r\n                /// corresponding superform\r\n                if (superform.getStateRegistryId() == _getStateRegistryId(address(this))) {\r\n                    PayloadUpdaterLib.validateLiqReq(multiVaultData_.liqData[i]);\r\n\r\n                    IBridgeValidator bridgeValidator =\r\n                        IBridgeValidator(superRegistry.getBridgeValidator(multiVaultData_.liqData[i].bridgeId));\r\n\r\n                    bridgeValidator.validateTxData(\r\n                        IBridgeValidator.ValidateTxDataArgs(\r\n                            txData_[i],\r\n                            dstChainId_,\r\n                            srcChainId_,\r\n                            multiVaultData_.liqData[i].liqDstChainId,\r\n                            false,\r\n                            address(superform),\r\n                            multiVaultData_.receiverAddress,\r\n                            _getVaultAsset(address(superform)),\r\n                            address(0)\r\n                        )\r\n                    );\r\n\r\n                    if (\r\n                        !PayloadUpdaterLib.validateSlippage(\r\n                            bridgeValidator.decodeAmountIn(txData_[i], false),\r\n                            superform.previewRedeemFrom(multiVaultData_.amounts[i]),\r\n                            multiVaultData_.maxSlippages[i]\r\n                        )\r\n                    ) {\r\n                        revert Error.SLIPPAGE_OUT_OF_BOUNDS();\r\n                    }\r\n\r\n                    multiVaultData_.liqData[i].txData = txData_[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        return multiVaultData_;\r\n    }\r\n\r\n    function _multiWithdrawal(\r\n        uint256 payloadId_,\r\n        bytes memory payload_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        InitMultiVaultData memory multiVaultData = abi.decode(payload_, (InitMultiVaultData));\r\n\r\n        bool errors;\r\n        uint256 len = multiVaultData.superformIds.length;\r\n        address superformFactory = _getAddress(keccak256(\"SUPERFORM_FACTORY\"));\r\n\r\n        for (uint256 i; i < len; ++i) {\r\n            // @dev validates if superformId exists on factory\r\n            if (!ISuperformFactory(superformFactory).isSuperform(multiVaultData.superformIds[i])) {\r\n                revert Error.SUPERFORM_ID_NONEXISTENT();\r\n            }\r\n\r\n            /// @dev Store destination payloadId_ & index in extraFormData (tbd: 1-step flow doesnt need this)\r\n            try IBaseForm(_getSuperform(multiVaultData.superformIds[i])).xChainWithdrawFromVault(\r\n                InitSingleVaultData({\r\n                    payloadId: multiVaultData.payloadId,\r\n                    superformId: multiVaultData.superformIds[i],\r\n                    amount: multiVaultData.amounts[i],\r\n                    outputAmount: multiVaultData.outputAmounts[i],\r\n                    maxSlippage: multiVaultData.maxSlippages[i],\r\n                    liqData: multiVaultData.liqData[i],\r\n                    hasDstSwap: false,\r\n                    retain4626: false,\r\n                    receiverAddress: multiVaultData.receiverAddress,\r\n                    extraFormData: abi.encode(payloadId_, i)\r\n                }),\r\n                srcSender_,\r\n                srcChainId_\r\n            ) {\r\n                /// @dev marks the indexes that don't require a callback re-mint of shares (successful\r\n                /// withdraws)\r\n                multiVaultData.amounts[i] = 0;\r\n            } catch {\r\n                /// @dev detect if there is at least one failed withdraw\r\n                errors = true;\r\n            }\r\n        }\r\n\r\n        /// @dev if at least one error happens, the shares will be re-minted for the affected superformIds\r\n        if (errors) {\r\n            return _multiReturnData(\r\n                srcSender_,\r\n                multiVaultData.payloadId,\r\n                TransactionType.WITHDRAW,\r\n                CallbackType.FAIL,\r\n                multiVaultData.superformIds,\r\n                multiVaultData.amounts\r\n            );\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    function _multiDeposit(\r\n        uint256 payloadId_,\r\n        bytes memory payload_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        InitMultiVaultData memory multiVaultData = abi.decode(payload_, (InitMultiVaultData));\r\n\r\n        address[] memory superforms = DataLib.getSuperforms(multiVaultData.superformIds);\r\n\r\n        IERC20 underlying;\r\n        uint256 numberOfVaults = multiVaultData.superformIds.length;\r\n        bool fulfilment;\r\n        bool errors;\r\n        for (uint256 i; i < numberOfVaults; ++i) {\r\n            /// @dev if updating the deposit payload fails because of slippage, multiVaultData.amounts[i] is set to 0\r\n            /// @dev this means that this amount was already added to the failedDeposits state variable and should not\r\n            /// be re-added (or processed here)\r\n            if (multiVaultData.amounts[i] != 0) {\r\n                underlying = IERC20(_getVaultAsset(superforms[i]));\r\n\r\n                if (underlying.balanceOf(address(this)) >= multiVaultData.amounts[i]) {\r\n                    underlying.safeIncreaseAllowance(superforms[i], multiVaultData.amounts[i]);\r\n                    LiqRequest memory emptyRequest;\r\n\r\n                    /// @notice  If a given deposit fails, we are minting 0 SPs back on source (slight gas waste)\r\n                    try IBaseForm(superforms[i]).xChainDepositIntoVault(\r\n                        InitSingleVaultData({\r\n                            payloadId: multiVaultData.payloadId,\r\n                            superformId: multiVaultData.superformIds[i],\r\n                            amount: multiVaultData.amounts[i],\r\n                            outputAmount: multiVaultData.outputAmounts[i],\r\n                            maxSlippage: multiVaultData.maxSlippages[i],\r\n                            liqData: emptyRequest,\r\n                            hasDstSwap: false,\r\n                            retain4626: multiVaultData.retain4626s[i],\r\n                            receiverAddress: multiVaultData.receiverAddress,\r\n                            extraFormData: multiVaultData.extraFormData\r\n                        }),\r\n                        srcSender_,\r\n                        srcChainId_\r\n                    ) returns (uint256 shares) {\r\n                        if (shares != 0 && !multiVaultData.retain4626s[i]) {\r\n                            fulfilment = true;\r\n                            /// @dev marks the indexes that require a callback mint of shares (successful)\r\n                            multiVaultData.amounts[i] = shares;\r\n                        } else {\r\n                            multiVaultData.amounts[i] = 0;\r\n                        }\r\n                    } catch {\r\n                        /// @dev cleaning unused approval\r\n                        underlying.safeDecreaseAllowance(superforms[i], multiVaultData.amounts[i]);\r\n\r\n                        /// @dev if any deposit fails, we mark errors as true and add it to failedDepositSuperformIds\r\n                        /// mapping for future rescuing\r\n                        errors = true;\r\n\r\n                        failedDeposits[payloadId_].superformIds.push(multiVaultData.superformIds[i]);\r\n\r\n                        /// @dev clearing multiVaultData.amounts so that in case that fulfillment is true these amounts\r\n                        /// are not minted\r\n                        multiVaultData.amounts[i] = 0;\r\n                        failedDeposits[payloadId_].settlementToken.push(_getVaultAsset(superforms[i]));\r\n                        failedDeposits[payloadId_].settleFromDstSwapper.push(false);\r\n                    }\r\n                } else {\r\n                    revert Error.BRIDGE_TOKENS_PENDING();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (errors) {\r\n            emit FailedXChainDeposits(payloadId_);\r\n        }\r\n\r\n        /// @dev issue superPositions if at least one vault deposit passed\r\n        if (fulfilment) {\r\n            return _multiReturnData(\r\n                srcSender_,\r\n                multiVaultData.payloadId,\r\n                TransactionType.DEPOSIT,\r\n                CallbackType.RETURN,\r\n                multiVaultData.superformIds,\r\n                multiVaultData.amounts\r\n            );\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    function _singleWithdrawal(\r\n        uint256 payloadId_,\r\n        bytes memory payload_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        InitSingleVaultData memory singleVaultData = abi.decode(payload_, (InitSingleVaultData));\r\n        singleVaultData.extraFormData = abi.encode(payloadId_, 0);\r\n\r\n        if (!_isSuperform(singleVaultData.superformId)) {\r\n            revert Error.SUPERFORM_ID_NONEXISTENT();\r\n        }\r\n\r\n        /// @dev Withdraw from superform\r\n        try IBaseForm(_getSuperform(singleVaultData.superformId)).xChainWithdrawFromVault(\r\n            singleVaultData, srcSender_, srcChainId_\r\n        ) {\r\n            // Handle the case when the external call succeeds\r\n        } catch {\r\n            // Handle the case when the external call reverts for whatever reason\r\n            /// https://solidity-by-example.org/try-catch/\r\n            return _singleReturnData(\r\n                srcSender_,\r\n                singleVaultData.payloadId,\r\n                TransactionType.WITHDRAW,\r\n                CallbackType.FAIL,\r\n                singleVaultData.superformId,\r\n                singleVaultData.amount\r\n            );\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    function _singleDeposit(\r\n        uint256 payloadId_,\r\n        bytes memory payload_,\r\n        address srcSender_,\r\n        uint64 srcChainId_\r\n    )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        InitSingleVaultData memory singleVaultData = abi.decode(payload_, (InitSingleVaultData));\r\n\r\n        address superform_ = _getSuperform(singleVaultData.superformId);\r\n        address vaultAsset = _getVaultAsset(superform_);\r\n        IERC20 underlying = IERC20(vaultAsset);\r\n\r\n        if (underlying.balanceOf(address(this)) >= singleVaultData.amount) {\r\n            underlying.safeIncreaseAllowance(superform_, singleVaultData.amount);\r\n\r\n            /// @dev deposit to superform\r\n            try IBaseForm(superform_).xChainDepositIntoVault(singleVaultData, srcSender_, srcChainId_) returns (\r\n                uint256 shares\r\n            ) {\r\n                if (shares != 0 && !singleVaultData.retain4626) {\r\n                    return _singleReturnData(\r\n                        srcSender_,\r\n                        singleVaultData.payloadId,\r\n                        TransactionType.DEPOSIT,\r\n                        CallbackType.RETURN,\r\n                        singleVaultData.superformId,\r\n                        shares\r\n                    );\r\n                }\r\n            } catch {\r\n                /// @dev cleaning unused approval\r\n                underlying.safeDecreaseAllowance(superform_, singleVaultData.amount);\r\n\r\n                /// @dev if any deposit fails, add it to failedDepositSuperformIds mapping for future rescuing\r\n                failedDeposits[payloadId_].superformIds.push(singleVaultData.superformId);\r\n                failedDeposits[payloadId_].settlementToken.push(vaultAsset);\r\n                failedDeposits[payloadId_].settleFromDstSwapper.push(false);\r\n\r\n                emit FailedXChainDeposits(payloadId_);\r\n            }\r\n        } else {\r\n            revert Error.BRIDGE_TOKENS_PENDING();\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    function _processAck(uint256 payloadId_, uint64 srcChainId_, bytes memory returnMessage_) internal {\r\n        /// @dev if deposits succeeded or some withdrawal failed, dispatch a callback\r\n        if (returnMessage_.length != 0) {\r\n            uint8[] memory ambIds = msgAMBs[payloadId_];\r\n\r\n            (, bytes memory extraData) = IPaymentHelper(_getAddress(keccak256(\"PAYMENT_HELPER\"))).calculateAMBData(\r\n                srcChainId_, ambIds, returnMessage_\r\n            );\r\n\r\n            _dispatchPayload(msg.sender, ambIds, srcChainId_, returnMessage_, extraData);\r\n        }\r\n    }\r\n\r\n    /// @notice depositSync and withdrawSync internal method for sending message back to the source chain\r\n    function _multiReturnData(\r\n        address srcSender_,\r\n        uint256 payloadId_,\r\n        TransactionType txType,\r\n        CallbackType returnType_,\r\n        uint256[] memory superformIds_,\r\n        uint256[] memory amounts_\r\n    )\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        /// @dev Send Data to Source to issue superform positions (failed withdraws and successful deposits)\r\n        return abi.encode(\r\n            AMBMessage(\r\n                DataLib.packTxInfo(\r\n                    uint8(txType), uint8(returnType_), 1, _getStateRegistryId(address(this)), srcSender_, CHAIN_ID\r\n                ),\r\n                abi.encode(ReturnMultiData(payloadId_, superformIds_, amounts_))\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice depositSync and withdrawSync internal method for sending message back to the source chain\r\n    function _singleReturnData(\r\n        address srcSender_,\r\n        uint256 payloadId_,\r\n        TransactionType txType,\r\n        CallbackType returnType_,\r\n        uint256 superformId_,\r\n        uint256 amount_\r\n    )\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        /// @dev Send Data to Source to issue superform positions (failed withdraws and successful deposits)\r\n        return abi.encode(\r\n            AMBMessage(\r\n                DataLib.packTxInfo(\r\n                    uint8(txType), uint8(returnType_), 0, _getStateRegistryId(address(this)), srcSender_, CHAIN_ID\r\n                ),\r\n                abi.encode(ReturnSingleData(payloadId_, superformId_, amount_))\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev calls the function to update the proof during payload update\r\n    function _updatePayload(\r\n        uint256 payloadId_,\r\n        bytes32 prevPayloadProof,\r\n        bytes memory newPayloadBody,\r\n        uint256 prevPayloadHeader,\r\n        PayloadState finalState\r\n    )\r\n        internal\r\n    {\r\n        bytes32 newPayloadProof = AMBMessage(prevPayloadHeader, newPayloadBody).computeProof();\r\n        if (newPayloadProof != prevPayloadProof) {\r\n            messageQuorum[newPayloadProof] = messageQuorum[prevPayloadProof];\r\n\r\n            delete messageQuorum[prevPayloadProof];\r\n        }\r\n\r\n        payloadBody[payloadId_] = newPayloadBody;\r\n        payloadTracking[payloadId_] = finalState;\r\n\r\n        emit PayloadUpdated(payloadId_);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"superRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BLOCK_CHAIN_ID_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BRIDGE_TOKENS_PENDING\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CANNOT_UPDATE_WITHDRAW_TX_DATA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DELAY_NOT_SET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DISPUTE_TIME_ELAPSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_QUORUM\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_CHAIN_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_DST_SWAP_AMOUNT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_INTERNAL_CALL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAYLOAD_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAYLOAD_TYPE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAYLOAD_UPDATE_REQUEST\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PROOF_BRIDGE_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PROOF_BRIDGE_IDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_RESCUE_DATA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_UPDATE_FINAL_TOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NEGATIVE_SLIPPAGE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_AMB_IMPLEMENTATION\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"NOT_PRIVILEGED_CALLER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_SUPERFORM_ROUTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_VALID_DISPUTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PAYLOAD_ALREADY_PROCESSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PAYLOAD_ALREADY_UPDATED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PAYLOAD_NOT_UPDATED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RESCUE_ALREADY_PROPOSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RESCUE_LOCKED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SLIPPAGE_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SUPERFORM_ID_NONEXISTENT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedDecrease\",\"type\":\"uint256\"}],\"name\":\"SafeERC20FailedDecreaseAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_AMB_ID_LENGTH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_AMOUNT\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"FailedXChainDeposits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"PayloadProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"PayloadReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"PayloadUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"ProofReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"RescueDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"RescueFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"proposedAmount\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposedTime\",\"type\":\"uint256\"}],\"name\":\"RescueProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"superRegistry\",\"type\":\"address\"}],\"name\":\"SuperRegistryUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"srcSender_\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"ambIds_\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId_\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData_\",\"type\":\"bytes\"}],\"name\":\"dispatchPayload\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"disputeRescueFailedDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"finalizeRescueFailedDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"getFailedDeposits\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastProposedTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"getMessageAMB\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"messageQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payloadBody\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payloadHeader\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payloadTracking\",\"outputs\":[{\"internalType\":\"enum PayloadState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payloadsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"processPayload\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"proposedAmounts_\",\"type\":\"uint256[]\"}],\"name\":\"proposeRescueFailedDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId_\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"}],\"name\":\"receivePayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superRegistry\",\"outputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"finalTokens_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"finalAmounts_\",\"type\":\"uint256[]\"}],\"name\":\"updateDepositPayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"txData_\",\"type\":\"bytes[]\"}],\"name\":\"updateWithdrawPayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"finalAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage_\",\"type\":\"uint256\"}],\"name\":\"validateSlippage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CoreStateRegistry", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b97612a25491e34f5fd11d521c14a042eca039fa", "EVMVersion": "paris", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5f8e02f5045b9d11962c15541fab5a48f45e7b85bb3acb511fb6e8545737aa47"}