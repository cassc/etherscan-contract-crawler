{"SourceCode": "// SPDX-License-Identifier: Apache-2.0//\r\n //*Submitted for verification at BscScan.com on 2023-18-11\r\n//*/\r\n\r\n//                                                                       \r\n//   [==]==========|======================================================|>       \r\n //_______  _______  _        ______   _______  _       \r\n//(  ____ \\(  ___  )( \\      (  __  \\ (  ____ \\( (    /|\r\n//| (    \\/| (   ) || (      | (  \\  )| (    \\/|  \\  ( |\r\n//| |      | |   | || |      | |   ) || (__    |   \\ | |\r\n//| | ____ | |   | || |      | |   | ||  __)   | (\\ \\) |\r\n//| | \\_  )| |   | || |      | |   ) || (      | | \\   |\r\n//| (___) || (___) || (____/\\| (__/  )| (____/\\| )  \\  |\r\n//(_______)(_______)(_______/(______/ (_______/|/    )_)\r\n                                                      \r\n// _______  _______  _______  _______                   \r\n//(  ____ )(  ____ \\(  ____ )(  ____ \\                  \r\n//| (    )|| (    \\/| (    )|| (    \\/                  \r\n//| (____)|| (__    | (____)|| (__                      \r\n//|  _____)|  __)   |  _____)|  __)                     \r\n//| (      | (      | (      | (                        \r\n//| )      | (____/\\| )      | (____/\\                  \r\n//|/       (_______/|/       (_______/                  \r\n                                                      \r\n/// [==]==========|======================================================|>\r\n\r\n/// https://t.me/BSCGoldenPepe\r\n// \r\n//\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function name() external view returns (string memory);\r\n  function getOwner() external view returns (address);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface IPancakeERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\ninterface IPancakeRouter01 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = valueIndex;\r\n            set._values.pop();\r\n            delete set._indexes[value];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n//Contract\r\ncontract GPEPE is IBEP20, Ownable {\r\n    using Address for address;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    EnumerableSet.AddressSet private _excluded;\r\n    EnumerableSet.AddressSet private _excludedFromStaking;\r\n\r\n    string private constant _name = 'Golden Pepe';  \r\n    string private constant _symbol = 'GPEPE';    \r\n    uint8 private constant _decimals = 18;\r\n    uint256 public constant _totalSupply= 1000000000 * 10**_decimals;\r\n    uint256 public _circulatingSupply=_totalSupply;    \r\n    uint8 private constant MaxWalletDivider=50; //2% = 20,000,000\r\n    uint16 private constant SellLimitDivider=50; //2% = 20,000,000\r\n    uint8 public constant MaxTax=20;        //This is the max tax that can be set by a user - prevents honeypot\r\n    //tax distribution\r\n    uint8 private _devTax=20;\r\n    uint8 private _burnTax=0;\r\n    uint8 private _marketingTax=40;\r\n    uint8 private _liquidityTax=25;\r\n    uint8 private _stakingTax=0;  \r\n    uint8 private _buyBackTax=15; \r\n    //buy, sell and transfer tax\r\n    uint8 private _buyTax=10;\r\n    uint8 private _sellTax=10;\r\n    uint8 private _transferTax=15;\r\n    //starting reward split percentages\r\n    uint8 private _MainRewardSplit=50;\r\n    uint8 private _MiscRewardSplit=50;\r\n    uint256 public  MaxWallet;\r\n    uint256 public  sellLimit;\r\n    address public MarketingWallet;     //This wallet has authorization and access to marketing funds\r\n    address private Developer;      //This is set to deployer and has access to developer funds\r\n    address public BurnAddress=0x000000000000000000000000000000000000dEaD;  //address used for burns\r\n    \r\n    //TestNet\r\n    //address private constant PancakeRouter=0x40d058503Ba7061131182E8e8B86C290f6B256a0;\r\n    //MainNet\r\n    address private constant PancakeRouter=0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    address public MainReward=0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47;   //change this address to desired reward token\r\n    address public MiscReward=0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;   //Only MiscReward can be changed to BNB\r\n\r\n    address private _pancakePairAddress; \r\n    IPancakeRouter02 private  _pancakeRouter;\r\n\r\n    //authorized: owner, marketing, Developer\r\n    modifier authorized() {\r\n        require(_authorized(msg.sender), \"Caller not authorized\");\r\n        _;\r\n    }\r\n    function _authorized(address addr) private view returns (bool){\r\n        return addr==owner()||addr==MarketingWallet||addr==Developer;\r\n    }\r\n\r\n//constructor\r\n    constructor () {\r\n        _pancakeRouter = IPancakeRouter02(PancakeRouter);\r\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\r\n        _addToken(msg.sender,_totalSupply);\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n        \r\n        \r\n        //set MarketingWallet and Developer as deployer by default\r\n        MarketingWallet=msg.sender;\r\n        Developer=msg.sender;\r\n        \r\n        sellLimit=_totalSupply/SellLimitDivider;\r\n        MaxWallet=_totalSupply/MaxWalletDivider;\r\n        \r\n        _excluded.add(msg.sender);\r\n        _excluded.add(MarketingWallet);\r\n        _excluded.add(Developer);    \r\n        _excluded.add(address(this));\r\n        _excludedFromStaking.add(address(this));\r\n        _excludedFromStaking.add(BurnAddress);\r\n        _excludedFromStaking.add(address(_pancakeRouter));\r\n        _excludedFromStaking.add(_pancakePairAddress);\r\n        _approve(address(this), address(_pancakeRouter), type(uint256).max);        \r\n    }\r\n    function allowance(address _owner, address spender) external view override returns (uint256) {\r\n        return _allowances[_owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"Approve from zero\");\r\n        require(spender != address(0), \"Approve to zero\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"<0 allowance\");\r\n\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    } \r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }    \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"Transfer > allowance\");\r\n\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n/////////////////////////////   CLAIMS  /////////////////////////////////////////\r\n\r\n    //claim reward token - differentiates between main/misc\r\n    event OnWithdrawToken(uint256 amount, address token, address recipient);\r\n    function claimToken(address addr, address token, uint256 payableAmount) private{\r\n        require(!_isWithdrawing);\r\n        _isWithdrawing=true;\r\n        uint256 amount;\r\n        if(isExcludedFromStaking(addr)){\r\n            if(token==MainReward){\r\n                amount=toBePaidMain[addr];\r\n                toBePaidMain[addr]=0;\r\n            } else{\r\n                amount=toBePaidMisc[addr];\r\n                toBePaidMisc[addr]=0;\r\n            }\r\n        }\r\n        else{\r\n            if(token==MainReward){\r\n                uint256 newAmount=_newDividentsOf(addr, true);\r\n                alreadyPaidMain[addr] = mainRewardShare * _balances[addr];\r\n                amount=toBePaidMain[addr]+newAmount;\r\n                toBePaidMain[addr]=0;\r\n            } else {\r\n                uint256 newAmount=_newDividentsOf(addr, false);\r\n                alreadyPaidMisc[addr] = miscRewardShare * _balances[addr];\r\n                amount=toBePaidMisc[addr]+newAmount;\r\n                toBePaidMisc[addr]=0;                \r\n            }\r\n        }\r\n        if(amount==0&&payableAmount==0){\r\n            _isWithdrawing=false;\r\n            return;\r\n        }\r\n\r\n        totalPayouts+=amount;\r\n        amount+=payableAmount;\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = token;\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n        0,\r\n        path,\r\n        addr,\r\n        block.timestamp);\r\n        \r\n        emit OnWithdrawToken(amount,token, addr);\r\n        _isWithdrawing=false;\r\n    }\r\n    \r\n    //ClaimMainReward token\r\n    function ClaimMainReward() public {\r\n        claimToken(msg.sender,MainReward,0);\r\n    }\r\n    \r\n    //ClaimMiscReward differentiates between BNB or another rewardToken\r\n    function ClaimMiscReward() public {\r\n        if(MiscReward==_pancakeRouter.WETH()){\r\n            _claimBNBTo(msg.sender,msg.sender,getDividents(msg.sender, false));\r\n        } else {claimToken(msg.sender,MiscReward,0);}\r\n    }    \r\n    \r\n    //function to claim BNB if misc reward set to BNB\r\n    event OnClaimBNB(address AddressFrom,address AddressTo, uint256 amount);    \r\n    function _claimBNBTo(address from, address to,uint256 amountWei) private{\r\n        require(!_isWithdrawing);\r\n        {require(amountWei!=0,\"=0\");        \r\n        _isWithdrawing=true;\r\n        _subtractDividents(from, amountWei);\r\n        totalPayouts+=amountWei;\r\n        (bool sent,) =to.call{value: (amountWei)}(\"\");\r\n        require(sent,\"withdraw failed\");}\r\n        _isWithdrawing=false;\r\n        emit OnClaimBNB(from,to,amountWei);\r\n    }   \r\n    \r\n    function _subtractDividents(address addr,uint256 amount) private{\r\n        if(amount==0) return;\r\n        require(amount<=getDividents(addr, false),\"exceeds divident\");\r\n\r\n        if(_excludedFromStaking.contains(addr)){\r\n            toBePaidMisc[addr]-=amount;\r\n        }\r\n        else{\r\n            uint256 newAmount=_newDividentsOf(addr, false);\r\n            alreadyPaidMisc[addr] = miscRewardShare * _balances[addr];\r\n            toBePaidMisc[addr]+=newAmount;\r\n            toBePaidMisc[addr]-=amount;\r\n        }\r\n    }   \r\n    \r\n    function getDividents(address addr, bool main) private view returns (uint256){\r\n        if(main){\r\n            if(isExcludedFromStaking(addr)) return toBePaidMain[addr];\r\n            return _newDividentsOf(addr, true)+toBePaidMain[addr];\r\n        } else{\r\n            if(isExcludedFromStaking(addr)) return toBePaidMisc[addr];\r\n            return _newDividentsOf(addr, false)+toBePaidMisc[addr];            \r\n        }\r\n    }\r\n    \r\n    //gets balance of claimable MainReward\r\n    function getMainBalance(address addr) public view returns (uint256){\r\n        uint256 amount=getDividents(addr, true);\r\n        return amount;\r\n    }\r\n\r\n    //gets balance of claimable MiscReward\r\n    function getMiscBalance(address addr) public view returns (uint256){\r\n        uint256 amount=getDividents(addr, false);\r\n        return amount;\r\n    }    \r\n    \r\n    //Switch reward to new token. Cannot set newReward BNB to prevent claim function from breaking.\r\n    event OnChangeMainReward (address NewMainReward);\r\n    function ChangeMainReward(address newReward) public authorized{\r\n        require(newReward != _pancakeRouter.WETH(), \"newReward cannot be BNB\");\r\n        MainReward=newReward;\r\n        emit OnChangeMainReward(newReward);\r\n    }\r\n    \r\n    //Switch reward to new token. Only Misc reward can be changed to bnb\r\n    event OnChangeMiscReward (address NewMiscReward);\r\n    function ChangeMiscReward(address newReward) public authorized{\r\n        MiscReward=newReward;\r\n        emit OnChangeMiscReward(newReward);\r\n    }\r\n    \r\n/////////////////////////////   LP LOCK  ///////////////////////////////////////// \r\n\r\n//OnlyOwner has control of LP functions\r\n    uint256 private _liquidityUnlockTime;\r\n\r\n    //Prolongs LP lock time    \r\n    event ExtendLiquidityLock(uint256 extendedLockTime);\r\n    function LockLiquidityTokens(uint256 lockTimeInSeconds) public onlyOwner{\r\n        _lockLiquidityTokens(lockTimeInSeconds+block.timestamp);\r\n        emit ExtendLiquidityLock(lockTimeInSeconds);\r\n    }\r\n    function _lockLiquidityTokens(uint256 newUnlockTime) private{\r\n        // require new unlock time to be longer than old one\r\n        require(newUnlockTime>_liquidityUnlockTime);\r\n        _liquidityUnlockTime=newUnlockTime;\r\n    }\r\n\r\n    //Impossible to release LP unless LP lock time is zero\r\n    function ReleaseLP() public onlyOwner {\r\n        require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        IPancakeERC20 liquidityToken = IPancakeERC20(_pancakePairAddress);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n            liquidityToken.transfer(msg.sender, amount);\r\n    }\r\n\r\n    //Impossible to remove LP unless lock time is zero\r\n    function RemoveLP() public onlyOwner {\r\n        require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        _liquidityUnlockTime=block.timestamp;\r\n        IPancakeERC20 liquidityToken = IPancakeERC20(_pancakePairAddress);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n        liquidityToken.approve(address(_pancakeRouter),amount);\r\n        _pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            address(this),\r\n            amount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n            );\r\n        (bool sent,) =msg.sender.call{value: (address(this).balance)}(\"\");\r\n        require(sent);            \r\n    }\r\n    \r\n    //Can only be called when LP lock time is zero. Recovers any stuck BNB in the contract\r\n    function RecoverBNB() public onlyOwner {\r\n        require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        _liquidityUnlockTime=block.timestamp;\r\n        (bool sent,) =msg.sender.call{value: (address(this).balance)}(\"\");\r\n        require(sent);\r\n    }\r\n    \r\n/////////////////////////////   STAKING REWARDS  /////////////////////////////////////////\r\n    bool private _isWithdrawing;\r\n    uint256 private constant DistributionMultiplier = 2**64;\r\n    uint256 private _totalShares=_totalSupply;\r\n    uint256 private mainRewardShare;\r\n    uint256 private miscRewardShare;\r\n    uint256 public totalRewards;\r\n    uint256 public totalPayouts;\r\n    uint256 public MarketingBalance;\r\n    uint256 public DevBalance;\r\n    uint256 public BuyBackBalance;    \r\n    uint16 public AutoLPThreshold=50;\r\n    mapping(address => uint256) private alreadyPaidMain;\r\n    mapping(address => uint256) private toBePaidMain;    \r\n    mapping(address => uint256) private alreadyPaidMisc;\r\n    mapping(address => uint256) private toBePaidMisc;    \r\n    \r\n    //update contract token swap percentage\r\n    event onUpdateLPThreshold(uint16 newThreshold);\r\n    function UpdateAutoLPThreshold(uint16 Threshold) public authorized{\r\n        require(Threshold>0,\"Threshold needs to be more than 0\");\r\n        require(Threshold<=50,\"Threshold needs to be below 50\");\r\n        AutoLPThreshold=Threshold;\r\n        emit onUpdateLPThreshold(Threshold);\r\n    }\r\n    \r\n    //Manual contract token swap for LP and BNB\r\n    function CreateLPandBNB(uint16 PermilleOfPancake, bool ignoreLimits) public authorized{\r\n    _swapContractToken(PermilleOfPancake, ignoreLimits);\r\n    }    \r\n    \r\n    function getTotalShares() public view returns (uint256){\r\n        return _totalShares-_totalSupply;\r\n    }\r\n\r\n    function isExcludedFromStaking(address addr) public view returns (bool){\r\n        return _excludedFromStaking.contains(addr);\r\n    }\r\n\r\n    function _addToken(address addr, uint256 amount) private {\r\n        uint256 newAmount=_balances[addr]+amount;\r\n        \r\n        if(isExcludedFromStaking(addr)){\r\n           _balances[addr]=newAmount;\r\n           return;\r\n        }\r\n        _totalShares+=amount;\r\n        uint256 mainPayment=_newDividentsOf(addr, true);\r\n        uint256 miscPayment=_newDividentsOf(addr, false);\r\n        _balances[addr]=newAmount;\r\n        alreadyPaidMain[addr] = mainRewardShare * newAmount;\r\n        toBePaidMain[addr]+=mainPayment;\r\n        alreadyPaidMisc[addr] = miscRewardShare * newAmount;\r\n        toBePaidMisc[addr]+=miscPayment; \r\n        _balances[addr]=newAmount;\r\n    }\r\n\r\n    function _removeToken(address addr, uint256 amount) private {\r\n        uint256 newAmount=_balances[addr]-amount;\r\n        \r\n        if(isExcludedFromStaking(addr)){\r\n           _balances[addr]=newAmount;\r\n           return;\r\n        }\r\n        _totalShares-=amount;\r\n        uint256 mainPayment=_newDividentsOf(addr, true);\r\n        uint256 miscPayment=_newDividentsOf(addr, false);\r\n        _balances[addr]=newAmount;\r\n        alreadyPaidMain[addr] = mainRewardShare * newAmount;\r\n        toBePaidMain[addr]+=mainPayment;\r\n        alreadyPaidMisc[addr] = miscRewardShare * newAmount;\r\n        toBePaidMisc[addr]+=miscPayment; \r\n    }\r\n    \r\n    function _newDividentsOf(address staker, bool main) private view returns (uint256) {\r\n        if(main){\r\n        uint256 fullPayout = mainRewardShare * _balances[staker];\r\n        if(fullPayout<alreadyPaidMain[staker]) return 0;\r\n        return (fullPayout - alreadyPaidMain[staker]) / DistributionMultiplier;}  \r\n        else{\r\n        uint256 fullPayout = miscRewardShare * _balances[staker];\r\n        if(fullPayout<alreadyPaidMisc[staker]) return 0;\r\n        return (fullPayout - alreadyPaidMisc[staker]) / DistributionMultiplier;}        \r\n    }\r\n\r\n    //This deals with splitting the taxes\r\n    function _distributeStake(uint256 BNBamount,bool newStakingReward) private {\r\n        uint256 MarketingSplit = (BNBamount * _marketingTax) / 100;\r\n        uint256 DevSplit = (BNBamount * _devTax) / 100;\r\n        uint256 BuyBackSplit = (BNBamount * _buyBackTax) / 100;        \r\n        uint256 amount = BNBamount - (MarketingSplit+DevSplit+BuyBackSplit);\r\n        uint256 MainAmount = (amount * _MainRewardSplit) / 100;\r\n        uint256 MiscAmount = (amount * _MiscRewardSplit) / 100;\r\n       MarketingBalance+=MarketingSplit;\r\n       DevBalance+=DevSplit;\r\n       BuyBackBalance+=BuyBackSplit; \r\n        if (amount > 0) {\r\n            if(newStakingReward){\r\n                totalRewards += amount;\r\n            }\r\n            uint256 totalShares=getTotalShares();\r\n            if (totalShares == 0) {\r\n                MarketingBalance += amount;\r\n            }else{\r\n                mainRewardShare += ((MainAmount * DistributionMultiplier) / totalShares);\r\n                miscRewardShare += ((MiscAmount * DistributionMultiplier) / totalShares);\r\n            }\r\n        }\r\n    }\r\n\r\n    uint256 public totalLPBNB;\r\n    bool private _isSwappingContractModifier;\r\n    modifier lockTheSwap {\r\n        _isSwappingContractModifier = true;\r\n        _;\r\n        _isSwappingContractModifier = false;\r\n    }\r\n\r\n    function _swapContractToken(uint16 permilleOfPancake,bool ignoreLimits) private lockTheSwap{\r\n        require(permilleOfPancake<=500);\r\n        uint256 contractBalance=_balances[address(this)];\r\n        uint16 totalTax=_liquidityTax+_stakingTax+_marketingTax+_devTax+_buyBackTax;\r\n        if(totalTax==0) return;\r\n\r\n        uint256 tokenToSwap=_balances[_pancakePairAddress]*permilleOfPancake/1000;\r\n        if(tokenToSwap>sellLimit&&!ignoreLimits) tokenToSwap=sellLimit;\r\n        \r\n        bool NotEnoughToken=contractBalance<tokenToSwap;\r\n        if(NotEnoughToken){\r\n            if(ignoreLimits)\r\n                tokenToSwap=contractBalance;\r\n            else return;\r\n        }\r\n        if(_allowances[address(this)][address(_pancakeRouter)]<tokenToSwap)\r\n            _approve(address(this), address(_pancakeRouter), type(uint256).max);        \r\n        uint256 tokenForLiquidity=(tokenToSwap*_liquidityTax)/totalTax;\r\n        uint256 remainingToken= tokenToSwap-tokenForLiquidity;\r\n        uint256 liqToken=tokenForLiquidity/2;\r\n        uint256 liqBNBToken=tokenForLiquidity-liqToken;\r\n        uint256 swapToken=liqBNBToken+remainingToken;\r\n        uint256 initialBNBBalance = address(this).balance;\r\n        _swapTokenForBNB(swapToken);\r\n        uint256 newBNB=(address(this).balance - initialBNBBalance);\r\n        uint256 liqBNB = (newBNB*liqBNBToken)/swapToken;\r\n        _addLiquidity(liqToken, liqBNB);\r\n        uint256 distributeBNB=(address(this).balance - initialBNBBalance);\r\n        _distributeStake(distributeBNB,true);\r\n    }\r\n    \r\n    function _swapTokenForBNB(uint256 amount) private {\r\n        _approve(address(this), address(_pancakeRouter), amount);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _pancakeRouter.WETH();\r\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _addLiquidity(uint256 tokenamount, uint256 bnbamount) private {\r\n        totalLPBNB+=bnbamount;\r\n        try _pancakeRouter.addLiquidityETH{value: bnbamount}(\r\n            address(this),\r\n            tokenamount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        ){}\r\n        catch{}\r\n    }\r\n \r\n    //switch contract auto sells on and off\r\n    bool private manualSwap;\r\n    function ManualBNBSwap(bool manual) public authorized{\r\n        manualSwap=manual;\r\n    }   \r\n/////////////////////////////   TRANSFERS  /////////////////////////////////////////\r\n\r\n    function _calculateFee(uint256 amount, uint8 tax, uint8 taxPercent) private pure returns (uint256) {\r\n        return (amount*tax*taxPercent) / 10000;\r\n    }\r\n    \r\n    function _feelessTransfer(address sender, address recipient, uint256 amount) private{\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"Transfer exceeds balance\");\r\n        _removeToken(sender,amount);\r\n        _addToken(recipient, amount);\r\n        if(recipient==BurnAddress){\r\n            _circulatingSupply-=amount;\r\n        }\r\n        emit Transfer(sender,recipient,amount);\r\n    }  \r\n\r\n    function _taxedTransfer(address sender, address recipient, uint256 amount,bool isBuy,bool isSell) private{\r\n        uint256 recipientBalance = _balances[recipient];\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"Transfer exceeds balance\");\r\n\r\n        uint8 tax;\r\n        if(isSell){\r\n            require(amount<=sellLimit,\"Dump protection\");\r\n             tax=_sellTax;\r\n\r\n        } else if(isBuy){\r\n            if(amount<=10**(_decimals)) claimToken(recipient,MainReward,0);   //buy less than 1 token to ClaimRewardToken         \r\n            require(recipientBalance+amount<=MaxWallet,\"whale protection\");\r\n            tax=_buyTax;\r\n\r\n        } else {\r\n            if(amount<=10**(_decimals)){    //transfer less than 1 token to ClaimBNB\r\n                if(MiscReward==_pancakeRouter.WETH()){\r\n                    _claimBNBTo(msg.sender,msg.sender,getDividents(msg.sender, false));\r\n                } else {claimToken(msg.sender,MiscReward,0);}\r\n                return;}\r\n            require(recipientBalance+amount<=MaxWallet,\"whale protection\");            \r\n            tax=_transferTax;\r\n        }     \r\n        if((sender!=_pancakePairAddress)&&(!manualSwap)&&(!_isSwappingContractModifier)&&isSell)\r\n            _swapContractToken(AutoLPThreshold,false);\r\n        uint256 tokensToBeBurnt=_calculateFee(amount, tax, _burnTax);\r\n        uint256 contractToken=_calculateFee(amount, tax, _stakingTax+_liquidityTax+_marketingTax+_devTax+_buyBackTax);\r\n        uint256 taxedAmount=amount-(tokensToBeBurnt+contractToken);\r\n        _removeToken(sender,amount);\r\n       _addToken(address(this), contractToken);\r\n       _circulatingSupply-=tokensToBeBurnt;\r\n        _addToken(recipient, taxedAmount);\r\n        emit Transfer(sender,recipient,taxedAmount);\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) private{\r\n        require(sender != address(0), \"Transfer from zero\");\r\n        require(recipient != address(0), \"Transfer to zero\");\r\n        bool isExcluded = (_excluded.contains(sender) || _excluded.contains(recipient));\r\n\r\n        bool isContractTransfer=(sender==address(this) || recipient==address(this));\r\n        address pancakeRouter=address(_pancakeRouter);\r\n        bool isLiquidityTransfer = ((sender == _pancakePairAddress && recipient == pancakeRouter) \r\n        || (recipient == _pancakePairAddress && sender == pancakeRouter));\r\n        bool isSell=recipient==_pancakePairAddress|| recipient == pancakeRouter;\r\n        bool isBuy=sender==_pancakePairAddress|| sender == pancakeRouter;\r\n\r\n        if(isContractTransfer || isLiquidityTransfer || isExcluded){\r\n            _feelessTransfer(sender, recipient, amount);\r\n        }\r\n        else{ \r\n            _taxedTransfer(sender,recipient,amount,isBuy,isSell);                  \r\n        }\r\n    }\r\n\r\n    //Buy back function that burns the bought tokens immediately\r\n    event Buyback(uint256 BuybackAmount);\r\n    function TriggerBuyBack(uint256 amount) public authorized{\r\n        require(amount<=BuyBackBalance, \"Amount exceeds BuyBackBalance!\");\r\n        BuyBackBalance-=amount;\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = address(this);\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n        0,\r\n        path,\r\n        BurnAddress,\r\n        block.timestamp);  \r\n        emit Buyback(amount);\r\n    }\r\n    \r\n    //burning can be done via direct transfer to BurnAddress. Burn function gives transparency\r\n    event onBurnTokens(uint256 TokensBurnt);\r\n    function BurnTokens (uint256 amount) public{\r\n        uint256 convertedAmount = amount * 10**_decimals;\r\n        uint256 senderBalance = _balances[msg.sender];\r\n        require(senderBalance >= convertedAmount, \"Burn amount exceed user's balance\");\r\n        _removeToken(msg.sender,convertedAmount);\r\n        _addToken(BurnAddress, convertedAmount);\r\n        _circulatingSupply-=convertedAmount;\r\n        emit Transfer(msg.sender,BurnAddress,convertedAmount);\r\n        emit onBurnTokens(convertedAmount);\r\n    }\r\n    \r\n    //Withdraw all bnb in DevBalance\r\n    function WithdrawAllDev() public authorized{\r\n        uint256 amount=DevBalance;\r\n        DevBalance=0;\r\n        (bool sent,) =Developer.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    } \r\n    \r\n    //Withdraw desired amount in wei\r\n    function WithdrawDev(uint256 amount) public authorized{\r\n        require(amount<=DevBalance);\r\n        DevBalance-=amount;\r\n        (bool sent,) =Developer.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    } \r\n\r\n    //Withdraw all bnb in MarketingBalance\r\n    function WithdrawAllMarketing() public authorized{\r\n        uint256 amount=MarketingBalance;\r\n        MarketingBalance=0;\r\n        (bool sent,) =MarketingWallet.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    } \r\n    \r\n    //Withdraw desired amount in wei\r\n    function WithdrawMarketing(uint256 amount) public authorized{\r\n        require(amount<=MarketingBalance);\r\n        MarketingBalance-=amount;\r\n        (bool sent,) =MarketingWallet.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    }     \r\n/////////////////////////////   ADDRESS SETTINGS  /////////////////////////////////////////\r\n\r\n    //Excludes an account from being able to receive rewards- exists to exclude address such as dead, pair, contract etc.\r\n    event OnExcludeFromStaking(address excludedAddress);\r\n    function ExcludeFromStaking(address addr) public authorized{\r\n        require(!isExcludedFromStaking(addr));\r\n        _totalShares-=_balances[addr];\r\n        uint256 newDividentsMain=_newDividentsOf(addr, true);\r\n        uint256 newDividentsMisc=_newDividentsOf(addr, false);        \r\n        alreadyPaidMain[addr]=_balances[addr]*mainRewardShare;\r\n        alreadyPaidMisc[addr]=_balances[addr]*miscRewardShare;        \r\n        toBePaidMain[addr]+=newDividentsMain;\r\n        toBePaidMisc[addr]+=newDividentsMisc;        \r\n        _excludedFromStaking.add(addr);\r\n        emit OnExcludeFromStaking(addr);\r\n    }    \r\n\r\n    //gives any wallet the ability to include themselves in staking if they were excluded\r\n    function IncludeMeToStaking() public{\r\n        require(isExcludedFromStaking(msg.sender));\r\n        _totalShares+=_balances[msg.sender];\r\n        _excludedFromStaking.remove(msg.sender);\r\n        alreadyPaidMain[msg.sender]=_balances[msg.sender]*mainRewardShare;\r\n        alreadyPaidMisc[msg.sender]=_balances[msg.sender]*miscRewardShare; \r\n    }\r\n    event OnIncludeToStaking(address includedAddress);\r\n    function IncludeToStaking(address addr) public authorized{\r\n        require(isExcludedFromStaking(addr));\r\n        _totalShares+=_balances[addr];\r\n        _excludedFromStaking.remove(addr);\r\n        alreadyPaidMain[addr]=_balances[addr]*mainRewardShare;\r\n        alreadyPaidMisc[addr]=_balances[addr]*miscRewardShare; \r\n        emit OnIncludeToStaking(addr);\r\n    }\r\n\r\n    //onlyOwner can change MarketingWallet\r\n    event UpdateMarketingWallet(address newMarketingWallet);\r\n    function SetMarketingWallet(address addr) public onlyOwner{\r\n        address prevMarketing=MarketingWallet;\r\n        _excluded.remove(prevMarketing);\r\n        MarketingWallet=addr;\r\n        _excluded.add(MarketingWallet);\r\n        emit UpdateMarketingWallet(addr);\r\n    }\r\n\r\n    //onlyOwner can change DevWallet\r\n    event UpdateDevWallet(address newDevWallet);\r\n    function SetDevWallet(address addr) public onlyOwner{\r\n        address prevDev=Developer;\r\n        _excluded.remove(prevDev);\r\n        Developer=addr;\r\n        _excluded.add(Developer);\r\n        emit UpdateDevWallet(addr);\r\n    }\r\n    \r\n    //exclude account from taxes - exists to exclude address such as presale address etc.\r\n    event AccountExcluded(address account);\r\n    function ExcludeAccountFromFees(address account) public authorized {\r\n        _excluded.add(account);\r\n        emit AccountExcluded(account);\r\n    }\r\n    \r\n    event AccountIncluded(address account);\r\n    function IncludeAccountToFees(address account) public authorized {\r\n        _excluded.remove(account);\r\n        emit AccountIncluded(account);\r\n    }    \r\n\r\n\r\n/////////////////////////////   SETTINGS  /////////////////////////////////////////\r\n\r\n\r\n    //total of tax percentages must equal 100.\r\n    event OnUpdateTaxes(uint8 burnTaxes, uint8 buybackTaxes, uint8 devTaxes, uint8 marketingTaxes, uint8 liquidityTaxes, uint8 stakingTaxes,uint8 buyTax, uint8 sellTax, uint8 transferTax);\r\n    function UpdateTaxes(uint8 burnTaxes, uint8 buybackTaxes, uint8 devTaxes, uint8 marketingTaxes, uint8 liquidityTaxes, uint8 stakingTaxes,uint8 buyTax, uint8 sellTax, uint8 transferTax) public authorized{\r\n        uint8 totalTax=liquidityTaxes+stakingTaxes+marketingTaxes+burnTaxes+buybackTaxes+devTaxes;\r\n        \r\n        //buy and sell tax can never be higher than MaxTax set at beginning of contract\r\n        //this prevents owner from setting ridiculous tax or turning contract into honeypot\r\n        require(totalTax==100, \"marketing+liq+staking needs to equal 100%\");\r\n        require(buyTax<=MaxTax&&sellTax<=MaxTax,\"taxes higher than max tax\");\r\n        require(transferTax<=50,\"transferTax higher than max transferTax\");\r\n        _burnTax=burnTaxes;\r\n        _buyBackTax=buybackTaxes;\r\n        _devTax=devTaxes;\r\n        _marketingTax=marketingTaxes;\r\n        _liquidityTax=liquidityTaxes;\r\n        _stakingTax=stakingTaxes;\r\n        _buyTax=buyTax;\r\n        _sellTax=sellTax;\r\n        _transferTax=transferTax;\r\n        emit OnUpdateTaxes(burnTaxes,buybackTaxes,devTaxes,marketingTaxes,liquidityTaxes,stakingTaxes,buyTax,sellTax,transferTax);\r\n    }\r\n\r\n    //total split percentages must equal 100\r\n    event OnUpdateRewardSplit (uint8 NewMainSplit, uint8 NewMiscSplit);\r\n    function UpdateRewardSplit (uint8 MainSplit, uint8 MiscSplit) public authorized{\r\n        uint8 totalSplit=MainSplit+MiscSplit;\r\n        require(totalSplit==100, 'MainSplit+MiscSplit needs to equal 100%');\r\n        _MainRewardSplit=MainSplit;\r\n        _MiscRewardSplit=MiscSplit;\r\n        emit OnUpdateRewardSplit(MainSplit,MiscSplit);\r\n    }\r\n    \r\n    event OnUpdateLimits(uint256 newMaxWallet, uint256 newSellLimit);\r\n    function UpdateLimits(uint256 newMaxWallet, uint256 newSellLimit) public authorized{\r\n        //Calculates the target Limits based on supply\r\n        uint256 targetMaxWallet=_totalSupply/MaxWalletDivider;\r\n        uint256 targetSellLimit=_totalSupply/SellLimitDivider;\r\n        \r\n        //MaxWallet and sellLimit can never be lower than original limits - this prevents honeypot\r\n        require((newMaxWallet>=targetMaxWallet), \r\n        \"newMaxWallet needs to be at least target\");\r\n        require((newSellLimit>=targetSellLimit), \r\n        \"newSellLimit needs to be at least target\");\r\n\r\n        MaxWallet = newMaxWallet;\r\n        sellLimit = newSellLimit;    \r\n        emit OnUpdateLimits(newMaxWallet,newSellLimit);\r\n    }\r\n\r\n/////////////////////////////   DISPLAY INFO  /////////////////////////////////////////\r\n    function getOwner() external view override returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _circulatingSupply;\r\n    }\r\n    \r\n    function getLimits() public view returns(uint256 balance, uint256 sell){\r\n        return(MaxWallet/10, sellLimit/10);\r\n    }  \r\n    \r\n    function getLiquidityUnlockInSeconds() public view returns (uint256){\r\n        if(block.timestamp<_liquidityUnlockTime){\r\n            return _liquidityUnlockTime-block.timestamp;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getTaxes() public view returns(uint256 burnTax, uint256 buybackTax, uint256 devTax, uint256 marketingTax, uint256 liquidityTax,uint256 rewardsTax, uint256 buyTax, uint256 sellTax, uint256 transferTax){\r\n        return (_burnTax, _buyBackTax, _devTax, _marketingTax,_liquidityTax,_stakingTax,_buyTax,_sellTax,_transferTax);\r\n    }   \r\n    \r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountExcluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountIncluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BuybackAmount\",\"type\":\"uint256\"}],\"name\":\"Buyback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extendedLockTime\",\"type\":\"uint256\"}],\"name\":\"ExtendLiquidityLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewMainReward\",\"type\":\"address\"}],\"name\":\"OnChangeMainReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewMiscReward\",\"type\":\"address\"}],\"name\":\"OnChangeMiscReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"AddressFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"AddressTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OnClaimBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"excludedAddress\",\"type\":\"address\"}],\"name\":\"OnExcludeFromStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"includedAddress\",\"type\":\"address\"}],\"name\":\"OnIncludeToStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxWallet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSellLimit\",\"type\":\"uint256\"}],\"name\":\"OnUpdateLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"NewMainSplit\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"NewMiscSplit\",\"type\":\"uint8\"}],\"name\":\"OnUpdateRewardSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"burnTaxes\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"buybackTaxes\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"devTaxes\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"marketingTaxes\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"liquidityTaxes\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"stakingTaxes\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"transferTax\",\"type\":\"uint8\"}],\"name\":\"OnUpdateTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"OnWithdrawToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDevWallet\",\"type\":\"address\"}],\"name\":\"UpdateDevWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"UpdateMarketingWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TokensBurnt\",\"type\":\"uint256\"}],\"name\":\"onBurnTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newThreshold\",\"type\":\"uint16\"}],\"name\":\"onUpdateLPThreshold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AutoLPThreshold\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BurnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyBackBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReward\",\"type\":\"address\"}],\"name\":\"ChangeMainReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReward\",\"type\":\"address\"}],\"name\":\"ChangeMiscReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimMainReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimMiscReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"PermilleOfPancake\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"CreateLPandBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DevBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeAccountFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ExcludeFromStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IncludeAccountToFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IncludeMeToStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"IncludeToStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockTimeInSeconds\",\"type\":\"uint256\"}],\"name\":\"LockLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MainReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"manual\",\"type\":\"bool\"}],\"name\":\"ManualBNBSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxTax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MiscReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RecoverBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReleaseLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RemoveLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"SetDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"SetMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TriggerBuyBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"Threshold\",\"type\":\"uint16\"}],\"name\":\"UpdateAutoLPThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellLimit\",\"type\":\"uint256\"}],\"name\":\"UpdateLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"MainSplit\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"MiscSplit\",\"type\":\"uint8\"}],\"name\":\"UpdateRewardSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"burnTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buybackTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"devTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketingTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidityTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"stakingTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"transferTax\",\"type\":\"uint8\"}],\"name\":\"UpdateTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawAllDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawAllMarketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawMarketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityUnlockInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getMainBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getMiscBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burnTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buybackTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferTax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isExcludedFromStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLPBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GPEPE", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b8595524b84152875dae7462ac1ea97e9ce4d5f2de2a3aa2445f5e62fb9083be"}