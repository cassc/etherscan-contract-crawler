{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Auth is Context{\r\n    address owner;\r\n    mapping (address => bool) private authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender)); _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender)); _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n        emit Authorized(adr);\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n        emit Unauthorized(adr);\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n    event Authorized(address adr);\r\n    event Unauthorized(address adr);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ILibero is IERC20 {\r\n    function getCirculatingSupply() external view returns (uint256);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"zero address\");\r\n        require(recipient != address(0), \"zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"zero address\");\r\n        require(spender != address(0), \"zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _setupDecimals(uint8 decimals_) internal virtual {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IDexPair {\r\n    function sync() external;\r\n}\r\n\r\n\r\ninterface IAutoLiquidityTreasury {\r\n    function autoLiquidify(address _sourceToken, address _pairWithToken, address _dexToken, address _dexRouter) external;\r\n}\r\n\r\ninterface ITreasury {\r\n    function updateRewards() external;\r\n}\r\n\r\ncontract LiberaToken is ERC20, Auth, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant MAX_SUPPLY = 50 * 10**6 * 10**18;\r\n    uint256 private constant MAX_TAX = 5000;\r\n\r\n    bool private swapping;\r\n    \r\n    IDEXRouter public dexRouter;\r\n    address public dexPair;\r\n\r\n    address public constant LIBERO = 0x0DFCb45EAE071B3b846E220560Bbcdd958414d78;\r\n    address private constant deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    address public busdToken = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address public liquidityToken;\r\n    address public dexToken = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address public marketingWallet;\r\n\r\n    address public reserveTreasury;\r\n    address public taxTreasury;\r\n    ITreasury public nukeTreasury;\r\n    ITreasury public busdTreasury;\r\n    \r\n\r\n    bool public isNotMigrating = false;     \r\n\r\n    bool public isFeesOnNormalTransfers = true;\r\n    uint256 public normalTransferFee = 1000;\r\n    uint256 public totalSellFees = 1600;\r\n    uint256 public liquidityFee = 100;\r\n    uint256 public busdDividendFee = 175;\r\n    uint256 public marketingFee = 50;\r\n    uint256 public treasuryFee = 150;\r\n    uint256 public rewardBuyerFee = 25;\r\n    uint256 public totalBuyFees = liquidityFee + busdDividendFee + marketingFee + treasuryFee + rewardBuyerFee;\r\n\r\n    uint256 public maxSellTransactionAmount = 50000 * 10**18;\r\n    uint256 public swapTokensAtAmount = 2000 * 10 ** 18;\r\n\r\n    mapping (address => bool) private isExcludedFromFees;\r\n    mapping (address => bool) public automatedMarketMakerPairs;\r\n    mapping (address => bool) public blacklistFrom;\r\n    mapping (address => bool) public blacklistTo;\r\n    mapping (address => uint256) public nextSellTax;\r\n    address[] private _markerPairs;\r\n    mapping (address => uint256) public lpNukeBuildup;\r\n\r\n    /** Nuke Config **/\r\n    bool public lpNukeEnabled = true;\r\n    uint256 public nukePercentPerSell = 2500;\r\n    uint256 public nukePercentToBurn = 5000;\r\n    uint256 public minNukeAmount = 1000 * 10**18;    \r\n    uint256 public totalNuked;\r\n    bool public autoNuke = true;\r\n\r\n    /** Reward Biggest Buyer **/\r\n    bool public isRewardBiggestBuyer = true;\r\n    uint256 public biggestBuyerPeriod = 3600;\r\n    uint256 public immutable launchTime = block.timestamp;\r\n    uint256 public  totalBiggestBuyerPaid;\r\n    mapping(uint256 => address) public biggestBuyer;\r\n    mapping(uint256 => uint256) public biggestBuyerAmount;\r\n    mapping(uint256 => uint256) public biggestBuyerPaid;\r\n\r\n    /** Breaker Config **/\r\n    bool public isBreakerEnable = true;\r\n    bool public breakerOnSellOnly = false;\r\n    int public taxBreakerCheck;\r\n    uint256 public breakerPeriod = 3600; // 1 hour\r\n    int public breakerPercent = 200; // activate at 2%\r\n    uint256 public breakerBuyFee = 400;  // buy fee 4%\r\n    uint256 public breakerSellFee = 2500; // sell fee 25%\r\n    uint public circuitBreakerFlag;\r\n    uint public circuitBreakerTime;\r\n    uint private timeBreakerCheck;\r\n\r\n    /** Auto Liquidity **/\r\n    IAutoLiquidityTreasury public autoLiquidityTreasury;\r\n    bool public autoLiquidityCall = true;\r\n\r\n    receive() external payable {}\r\n    constructor() ERC20(\"Libera.Financial\", \"LIBERA\") Auth(msg.sender) {    \r\n        //Biswap Router\r\n        IDEXRouter _dexRouter = IDEXRouter(0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8);\r\n        \r\n        address _dexPair = IDEXFactory(_dexRouter.factory()).createPair(address(this), dexToken);\r\n\r\n        setDexRouter(address(_dexRouter), _dexPair, dexToken);\r\n\r\n        excludeFromFees(address(this), true);\r\n        excludeFromFees(owner, true);\r\n        excludeFromFees(deadAddress,true);\r\n\r\n        setMarketingWallet(0x770BdD792f6471EB28cBccD4F193BB26e8B5B07E);\r\n        setTaxTreasury(0x4Dfa03c64ABd96359B77E7cCa8219B451C19f27E);\r\n        \r\n        setReserveTreasury(0xd01c6969C7Dc0B086f118bA3B4D926Da73acA2c7);        \r\n        setNukeTreasury(0x5f791D180126871aE3174db38fcdd28800CcBd77);\r\n        setBusdTreasury(0xa267AFb36DAb3C97082863431Aff7F88edbCaE29);\r\n        setLiquidityParams(0xF0f14634971C43d872d1cF1785195C0Ce1000a9d,autoLiquidityCall,busdToken);\r\n\r\n        _mint(msg.sender, MAX_SUPPLY);       \r\n    }\r\n\r\n   /***** Token Feature *****/\r\n    function circulatingSupply() public view returns (uint256) {\r\n        return totalSupply().sub(balanceOf(address(deadAddress))).sub(balanceOf(reserveTreasury));\r\n    }\r\n\r\n    function getPeriod() public view returns (uint256) {\r\n        uint256 secondsSinceLaunch = block.timestamp - launchTime;\r\n        return 1 + (secondsSinceLaunch / biggestBuyerPeriod);\r\n    }\r\n\r\n    function manualNukeLpTokens(address _lpAddress, uint256 _percent) external onlyOwner {\r\n        require(automatedMarketMakerPairs[_lpAddress] == true, \"Invalid lpAddress\");\r\n        require(_percent <= 1000, 'Cannot burn more than 10% dex balance');\r\n        _nukeFromLp(_lpAddress, (balanceOf(_lpAddress) * _percent) / 10000);\r\n    }\r\n    function nukeLpTokenFromBuildup() external authorized {\r\n        _nukeLpTokenFromBuildup();\r\n    }\r\n    function _nukeLpTokenFromBuildup() internal {\r\n        if(lpNukeEnabled){\r\n            for(uint i = 0; i < _markerPairs.length; i++){\r\n\r\n                uint256 nukeAmount = lpNukeBuildup[_markerPairs[i]];\r\n\r\n                if(nukeAmount > minNukeAmount){\r\n                    uint256 maxBuildUp = balanceOf(_markerPairs[i]).mul(1000).div(10000);\r\n\r\n                    if(nukeAmount > maxBuildUp){\r\n                        nukeAmount = maxBuildUp;\r\n                    }\r\n\r\n                    _nukeFromLp(_markerPairs[i], nukeAmount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _nukeFromLp(address lpAddress, uint256 amount) internal{\r\n\r\n        if (amount>0) {\r\n            lpNukeBuildup[lpAddress] = 0;\r\n            totalNuked = totalNuked + amount;\r\n            uint256 nukeToBurn = amount.mul(nukePercentToBurn).div(10000);\r\n            if (nukeToBurn>0) {\r\n                super._transfer(lpAddress, deadAddress, nukeToBurn);\r\n            }\r\n            if (amount > nukeToBurn) {\r\n                super._transfer(lpAddress, address(nukeTreasury), amount - nukeToBurn);          \r\n                nukeTreasury.updateRewards();\r\n            }\r\n\r\n            IDexPair pair = IDexPair(lpAddress);\r\n\r\n            try pair.sync() {\r\n                }\r\n            catch Error (string memory reason) {\r\n                    emit SyncLpErrorEvent(lpAddress, reason);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function payBiggestBuyer(uint256 _hour) external authorized {\r\n        _checkAndPayBiggestBuyer(_hour);\r\n    }\r\n\r\n    function setNextSellTax(address account, uint256 sellTax) public authorized {\r\n        require(sellTax < MAX_TAX, \"Tax too high\");\r\n        nextSellTax[account] = sellTax;\r\n    }\r\n\r\n    function excludeFromFees(address account, bool _status) public onlyOwner {\r\n        //require(isExcludedFromFees[account] != _status, \"Already excluded\");\r\n        isExcludedFromFees[account] = _status;\r\n        emit ExcludeFromFees(account, _status);\r\n    }\r\n\r\n    function checkIsExcludedFromFees(address _account) external view returns (bool) {\r\n        return(isExcludedFromFees[_account]);\r\n    }   \r\n\r\n    function setBotBlacklist(address account, bool _statusFrom, bool _statusTo) public onlyOwner {        \r\n        //require(_isContract(account), \"Only contract\");\r\n        require(account != address(dexRouter), \"Not block dexRouter\");\r\n        require(account != dexPair, \"Not block dexPair\");      \r\n\r\n        blacklistFrom[account] = _statusFrom;\r\n        blacklistTo[account] = _statusTo;\r\n\r\n        emit BotBlacklist(account, _statusFrom, _statusTo);\r\n    }\r\n\r\n    function setDexRouter(address _dexRouter, address _dexPair, address _dexToken) public onlyOwner {\r\n        dexRouter = IDEXRouter(_dexRouter);\r\n        dexPair = _dexPair;\r\n        dexToken = _dexToken;\r\n\r\n        setAutomatedMarketMakerPair(dexPair, true);\r\n\r\n        _approve(address(this), address(dexRouter), 2**256 - 1);\r\n\r\n        //approve for owner, not quite necessary\r\n        approve(address(dexRouter), 2**256 - 1);        \r\n\r\n        //liquidity making outside of contract, so this is not needed any more\r\n        //IERC20(busdToken).approve(address(dexRouter), 2**256 - 1);\r\n    }\r\n\r\n    function setAutomatedMarketMakerPair(address _dexPair, bool _status) public authorized {\r\n        automatedMarketMakerPairs[_dexPair] = _status;\r\n\r\n        if(_status){\r\n            _markerPairs.push(_dexPair);\r\n        }else{\r\n            require(_markerPairs.length >= 1, \"Required 1 pair\");\r\n            require( _dexPair != dexPair, \"Cannot remove dexPair\");\r\n            for (uint256 i = 0; i < _markerPairs.length; i++) {\r\n                if (_markerPairs[i] == _dexPair) {\r\n                    _markerPairs[i] = _markerPairs[_markerPairs.length - 1];\r\n                    _markerPairs.pop();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit SetAutomatedMarketMakerPair(_dexPair, _status);\r\n    }\r\n\r\n    function setMaxSell(uint256 _amount) external onlyOwner {\r\n        require(_amount >= 10**18,\"Too small\");\r\n        maxSellTransactionAmount = _amount;\r\n    }\r\n\r\n    function setMarketingWallet(address _newAddress) public onlyOwner {\r\n        excludeFromFees(_newAddress, true);\r\n        marketingWallet = _newAddress;\r\n    }\r\n\r\n    function setTaxTreasury(address _newAddress) public onlyOwner {\r\n        excludeFromFees(_newAddress, true);\r\n        taxTreasury = _newAddress;\r\n    }\r\n\r\n    function setNukeTreasury(address _newAddress) public onlyOwner {\r\n        excludeFromFees(_newAddress, true);\r\n        nukeTreasury = ITreasury(_newAddress);\r\n    }\r\n\r\n    function setBusdTreasury(address _newAddress) public onlyOwner {\r\n        excludeFromFees(_newAddress, true);\r\n        busdTreasury = ITreasury(_newAddress);\r\n    }\r\n\r\n    function setReserveTreasury(address _newAddress) public onlyOwner {\r\n        excludeFromFees(_newAddress, true);\r\n        reserveTreasury = _newAddress;\r\n    }\r\n\r\n    function setSwapTokensAtAmount(uint256 _amount) external onlyOwner {\r\n        swapTokensAtAmount = _amount;\r\n    }\r\n\r\n    function setIsNotMigrating(bool _status) external onlyOwner {\r\n        require(isNotMigrating != _status, \"Not changed\");\r\n        isNotMigrating = _status;\r\n    }\r\n\r\n    function setTokenFees(\r\n        uint256 _liquidityFee,\r\n        uint256 _busdDividendFee,\r\n        uint256 _marketingFee,\r\n        uint256 _treasuryFee,\r\n        uint256 _rewardBuyerFee,\r\n        uint256 _totalSellFees\r\n    ) external onlyOwner {\r\n        uint256 _totalBuyFees = _liquidityFee + _busdDividendFee + _marketingFee + _treasuryFee + _rewardBuyerFee;\r\n\r\n        require(_totalBuyFees <= MAX_TAX, \"Buy fee too high\");\r\n        require(_totalSellFees <= MAX_TAX, \"Sell fee too high\");\r\n\r\n        liquidityFee = _liquidityFee;\r\n        busdDividendFee = _busdDividendFee;\r\n        marketingFee = _marketingFee;\r\n        treasuryFee = _treasuryFee;\r\n        totalBuyFees = _totalBuyFees;\r\n        rewardBuyerFee = _rewardBuyerFee;\r\n\r\n        totalSellFees = _totalSellFees;\r\n    }\r\n\r\n    function setFeesOnNormalTransfers(bool _status, uint256 _normalTransferFee) external onlyOwner {\r\n        isFeesOnNormalTransfers = _status;\r\n        normalTransferFee = _normalTransferFee;\r\n    }\r\n\r\n    function setLpNukeEnabled(bool _status, uint256 _percent, bool _auto, uint256 _minNukeAmount, uint256 _nukePercentToBurn) external onlyOwner {\r\n        \r\n        require(_percent <= 10000, '_percent Cannot be more than 100%');\r\n        require(_nukePercentToBurn <= 10000, '_nukePercentToBurn Cannot be more than 100%');\r\n\r\n        lpNukeEnabled = _status;\r\n        autoNuke = _auto;\r\n        nukePercentPerSell = _percent;\r\n        nukePercentToBurn  = _nukePercentToBurn;\r\n        minNukeAmount = _minNukeAmount;\r\n\r\n        if(!lpNukeEnabled){\r\n            for(uint i = 0; i < _markerPairs.length; i++){\r\n                lpNukeBuildup[_markerPairs[i]] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsRewardBiggestBuyer(bool _status, uint256 _biggestBuyerPeriod) external onlyOwner {\r\n        require(_biggestBuyerPeriod >= 300, \"Period too small\");\r\n        isRewardBiggestBuyer = _status;\r\n        biggestBuyerPeriod = _biggestBuyerPeriod;\r\n    }\r\n\r\n    /***** Internal Functions *****/\r\n    function _isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal override {\r\n        require((from != address(0)) && (to != address(0)), \"zero address\");\r\n\r\n        bool excludedAccount = isExcludedFromFees[from] || isExcludedFromFees[to];\r\n\r\n        require(isNotMigrating || excludedAccount, \"Trading not started\");\r\n        require((!blacklistFrom[from] && !blacklistTo[to]) || excludedAccount , \"Transfer failed\");\r\n        bool isSelling = automatedMarketMakerPairs[to];\r\n        bool isBuying = automatedMarketMakerPairs[from];\r\n        if (isSelling && !excludedAccount) {\r\n            require(amount <= maxSellTransactionAmount, \"Sell amount too big\");\r\n        }\r\n\r\n        if (\r\n            !isBuying && !excludedAccount && !swapping\r\n        ) {\r\n            \r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n            if (contractTokenBalance >= swapTokensAtAmount) {\r\n                swapping = true;\r\n\r\n                uint256 totalBnbFee = marketingFee.add(treasuryFee).add(rewardBuyerFee);\r\n\r\n                if(totalBnbFee > 0){\r\n                    uint256 swapTokens = contractTokenBalance.mul(totalBnbFee).div(totalBuyFees);\r\n\r\n                    uint256 beforeAmount = address(this).balance;\r\n                    _swapTokensForBNB(swapTokens, address(this));\r\n                    uint256 increaseAmount = address(this).balance.sub(beforeAmount);\r\n\r\n                    if(increaseAmount > 0){\r\n                        uint256 marketingAmount = increaseAmount.mul(marketingFee).div(totalBnbFee);\r\n                        uint256 treasuryAmount = increaseAmount.mul(treasuryFee).div(totalBnbFee);\r\n\r\n                        if(marketingAmount > 0){\r\n                            _transferBNBToWallet(payable(marketingWallet), marketingAmount);\r\n                        }\r\n\r\n                        if(treasuryAmount > 0){\r\n                            _transferBNBToWallet(payable(taxTreasury), treasuryAmount);                            \r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(liquidityFee > 0){\r\n                    _swapAndLiquify(contractTokenBalance.mul(liquidityFee).div(totalBuyFees));\r\n                }\r\n\r\n                if(busdDividendFee > 0){\r\n                    uint256 feeAmount = contractTokenBalance.mul(busdDividendFee).div(totalBuyFees);\r\n\r\n                    _swapTokensForBusd(feeAmount, address(busdTreasury));\r\n                    busdTreasury.updateRewards();\r\n                }\r\n\r\n                swapping = false;\r\n            }\r\n\r\n        }\r\n\r\n        if(isBreakerEnable && (to == dexPair || from == dexPair) && !excludedAccount ){\r\n            if (!breakerOnSellOnly) {\r\n                _accuTaxSystem(amount,isBuying);\r\n            } else if (to == dexPair) {\r\n                _accuTaxSystem(amount,false);\r\n            }\r\n        }\r\n\r\n        if(!swapping && !excludedAccount) {\r\n            uint256 fees = amount.mul(totalBuyFees).div(10000);\r\n\r\n            if(isSelling) {\r\n                if(nextSellTax[from] > 0){\r\n                    fees = amount.mul(nextSellTax[from]).div(10000);\r\n                    nextSellTax[from] = 0;\r\n                }else if(isBreakerEnable && circuitBreakerFlag == 2){\r\n                    fees = amount.mul(breakerSellFee).div(10000);\r\n                }else{\r\n                    fees = amount.mul(totalSellFees).div(10000);\r\n                }\r\n            }else if(isBuying){\r\n                if(isBreakerEnable && circuitBreakerFlag == 2){\r\n                    fees = amount.mul(breakerBuyFee).div(10000);\r\n                }\r\n            }else{\r\n                if(isFeesOnNormalTransfers){\r\n                    fees = amount.mul(normalTransferFee).div(10000);\r\n                }else{\r\n                    fees = 0;\r\n                }\r\n            }\r\n\r\n            if(fees > 0){\r\n                amount = amount.sub(fees);\r\n                super._transfer(from, address(this), fees);\r\n            }\r\n        }\r\n\r\n        super._transfer(from, to, amount);\r\n\r\n        if(isRewardBiggestBuyer){\r\n            uint256 _periodAfterLaunch = getPeriod();\r\n\r\n            if(isBuying && !_isContract(to)){\r\n                if (amount > biggestBuyerAmount[_periodAfterLaunch]) {\r\n                    biggestBuyer[_periodAfterLaunch] = to;\r\n                    biggestBuyerAmount[_periodAfterLaunch] = amount;\r\n                }\r\n            }\r\n\r\n            _checkAndPayBiggestBuyer(_periodAfterLaunch);\r\n        }\r\n\r\n        if (lpNukeEnabled && isSelling && from != address(this) && !excludedAccount) {\r\n            lpNukeBuildup[to] += amount.mul(nukePercentPerSell).div(10000);\r\n        }\r\n        if (autoNuke && !swapping && lpNukeEnabled && !isSelling && !isBuying){\r\n            _nukeLpTokenFromBuildup();\r\n        }\r\n\r\n    }\r\n\r\n    function _swapAndLiquify(uint256 contractTokenBalance) private {\r\n            super._transfer(address(this),address(autoLiquidityTreasury), contractTokenBalance);\r\n            if (autoLiquidityCall) {\r\n                try autoLiquidityTreasury.autoLiquidify(address(this), liquidityToken, dexToken, address(dexRouter)) {\r\n                    }\r\n                catch Error (string memory reason) {\r\n                        emit AutoLpErrorEvent(reason);\r\n                }\r\n            }\r\n    }\r\n\r\n    function _swapTokensForBNB(uint256 tokenAmount, address receiver) private {\r\n        address[] memory path;\r\n        if (dexToken != dexRouter.WETH()) {\r\n            path = new address[](3);\r\n            path[0] = address(this);\r\n            path[1] = dexToken;\r\n            path[2] = dexRouter.WETH();\r\n        } else {\r\n            path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = dexRouter.WETH();\r\n        }\r\n\r\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            receiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _swapTokensForBusd(uint256 tokenAmount, address receiver) private {\r\n        address[] memory path;\r\n        \r\n        if (dexToken == busdToken) {\r\n            path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = busdToken;\r\n        } else {\r\n            path = new address[](3);\r\n            path[0] = address(this);\r\n            path[1] = dexToken;\r\n            path[2] = busdToken;\r\n        }\r\n\r\n        dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            receiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _transferBNBToWallet(address payable recipient, uint256 amount) private {\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    function _checkAndPayBiggestBuyer(uint256 _currentPeriod) private {\r\n        uint256 _prevPeriod = _currentPeriod - 1;\r\n        if (\r\n            _currentPeriod > 1 &&\r\n            biggestBuyerAmount[_prevPeriod] > 0 &&\r\n            biggestBuyerPaid[_prevPeriod] == 0\r\n        ) {\r\n            uint256 _rewardAmount = address(this).balance;\r\n            if (_rewardAmount > 0) {\r\n                _transferBNBToWallet(payable(biggestBuyer[_prevPeriod]), _rewardAmount);\r\n                totalBiggestBuyerPaid = totalBiggestBuyerPaid + _rewardAmount; \r\n                biggestBuyerPaid[_prevPeriod] = _rewardAmount;\r\n\r\n                emit PayBiggestBuyer(biggestBuyer[_prevPeriod], _prevPeriod, _rewardAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _deactivateCircuitBreaker() internal {\r\n        // 1 is false, 2 is true\r\n        circuitBreakerFlag = 1;\r\n        taxBreakerCheck = 1;\r\n        timeBreakerCheck = block.timestamp.sub(1);        \r\n    }\r\n\r\n    function _activateCircuitBreaker() internal {\r\n        // 1 is false, 2 is true\r\n        circuitBreakerFlag = 2;\r\n        circuitBreakerTime = block.timestamp;\r\n        emit CircuitBreakerActivated();\r\n    }\r\n\r\n    function setFeesOnBreaker(bool _isBreakerEnable, bool _breakerOnSellOnly, uint256 _breakerPeriod, int _breakerPercent, \r\n            uint256 _breakerBuyFee, uint256 _breakerSellFee) external onlyOwner {\r\n        require(_breakerBuyFee <= MAX_TAX, \"Buy fee too high\");\r\n        require(_breakerSellFee <= MAX_TAX, \"Sell fee too high\");\r\n\r\n        isBreakerEnable = _isBreakerEnable;\r\n        breakerOnSellOnly = _breakerOnSellOnly;\r\n        //reset flag if isBreakerEnable disabled\r\n        if (!isBreakerEnable) {\r\n            _deactivateCircuitBreaker();\r\n        }\r\n        breakerPeriod = _breakerPeriod;\r\n        breakerPercent = _breakerPercent;\r\n\r\n        breakerBuyFee = _breakerBuyFee;\r\n        breakerSellFee = _breakerSellFee;\r\n    }\r\n\r\n    function _accuTaxSystem(uint amount, bool isBuy) internal {\r\n        uint r1 = balanceOf(dexPair);\r\n\r\n        if (circuitBreakerFlag == 2) {\r\n            if (circuitBreakerTime + breakerPeriod < block.timestamp) {\r\n                _deactivateCircuitBreaker();\r\n            }\r\n        }\r\n\r\n        int _taxBreakerCheck = taxBreakerCheck;\r\n        uint _timeBreakerCheck = timeBreakerCheck;\r\n\r\n        uint timeDiffGlobal = block.timestamp.sub(_timeBreakerCheck);\r\n        int priceChange = int(_getPriceChange(r1, amount));\r\n        if (isBuy) {\r\n            priceChange = -priceChange;\r\n        }\r\n        if (timeDiffGlobal < breakerPeriod) {\r\n                _taxBreakerCheck = _taxBreakerCheck + priceChange;          \r\n        } else {\r\n            _taxBreakerCheck = priceChange;\r\n            _timeBreakerCheck = block.timestamp;\r\n        }\r\n\r\n        if (breakerPercent < _taxBreakerCheck) {\r\n            _activateCircuitBreaker();\r\n        }\r\n\r\n        taxBreakerCheck = _taxBreakerCheck;\r\n        timeBreakerCheck = _timeBreakerCheck;\r\n    }\r\n\r\n    function _getPriceChange(uint r1, uint x) internal pure returns (uint) {\r\n        uint x_ = x.mul(9975); // pcs fee\r\n        uint r1_ = r1.mul(10000);\r\n        uint nume = r1.mul(r1_).mul(10000); // to make it based on 10000 multi\r\n        uint deno = r1.add(x).mul(r1_.add(x_));\r\n        uint priceChange = nume / deno;\r\n        priceChange = (uint(10000).sub(priceChange)).div(2);\r\n\r\n        return priceChange;\r\n    }\r\n\r\n    function setLiquidityParams(address _autoLiquidityTreasury, bool _autoLiquidityCall, address _liquidityToken) public onlyOwner  {\r\n        excludeFromFees(_autoLiquidityTreasury,true);\r\n        autoLiquidityTreasury = IAutoLiquidityTreasury(_autoLiquidityTreasury);\r\n        autoLiquidityCall = _autoLiquidityCall;\r\n        liquidityToken = _liquidityToken;\r\n    }\r\n\r\n    function retrieveTokens(address _token) external onlyOwner {\r\n        //require(_token != address(this),\"Cannot retrieve self-token\");\r\n        uint256 amount = IERC20(_token).balanceOf(address(this));\r\n\r\n        require(IERC20(_token).transfer(msg.sender, amount), \"Transfer failed\");\r\n    }\r\n\r\n    function retrieveBNB() external onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n\r\n        (bool success,) = payable(msg.sender).call{ value: amount }(\"\");\r\n        require(success, \"Failed to retrieve BNB\");\r\n    }\r\n\r\n    event CircuitBreakerActivated();\r\n    event PayBiggestBuyer(address indexed account, uint256 indexed period, uint256 amount);\r\n    event ExcludeFromFees(address indexed account, bool isExcluded);\r\n    event BotBlacklist(address indexed account, bool isBlockedFrom, bool isBlockedTo);\r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiqudity);\r\n    event SyncLpErrorEvent(address lpPair, string reason);\r\n    event AutoLpErrorEvent(string reason);    \r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"AutoLpErrorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBlockedFrom\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBlockedTo\",\"type\":\"bool\"}],\"name\":\"BotBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CircuitBreakerActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayBiggestBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpPair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"SyncLpErrorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LIBERO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityTreasury\",\"outputs\":[{\"internalType\":\"contract IAutoLiquidityTreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoNuke\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"biggestBuyer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"biggestBuyerAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"biggestBuyerPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"biggestBuyerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklistFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklistTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"breakerBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"breakerOnSellOnly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"breakerPercent\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"breakerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"breakerSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdDividendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdTreasury\",\"outputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"checkIsExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circuitBreakerFlag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circuitBreakerTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBreakerEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFeesOnNormalTransfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNotMigrating\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRewardBiggestBuyer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpNukeBuildup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpNukeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"manualNukeLpTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minNukeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextSellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"normalTransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nukeLpTokenFromBuildup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nukePercentPerSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nukePercentToBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nukeTreasury\",\"outputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hour\",\"type\":\"uint256\"}],\"name\":\"payBiggestBuyer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieveBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBuyerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexPair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_statusFrom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_statusTo\",\"type\":\"bool\"}],\"name\":\"setBotBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setBusdTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dexPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dexToken\",\"type\":\"address\"}],\"name\":\"setDexRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isBreakerEnable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_breakerOnSellOnly\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_breakerPeriod\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_breakerPercent\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_breakerBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_breakerSellFee\",\"type\":\"uint256\"}],\"name\":\"setFeesOnBreaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_normalTransferFee\",\"type\":\"uint256\"}],\"name\":\"setFeesOnNormalTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setIsNotMigrating\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_biggestBuyerPeriod\",\"type\":\"uint256\"}],\"name\":\"setIsRewardBiggestBuyer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityTreasury\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_autoLiquidityCall\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_liquidityToken\",\"type\":\"address\"}],\"name\":\"setLiquidityParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_auto\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minNukeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nukePercentToBurn\",\"type\":\"uint256\"}],\"name\":\"setLpNukeEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMaxSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellTax\",\"type\":\"uint256\"}],\"name\":\"setNextSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setNukeTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setReserveTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setTaxTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_busdDividendFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardBuyerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalSellFees\",\"type\":\"uint256\"}],\"name\":\"setTokenFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxBreakerCheck\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBiggestBuyerPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNuked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LiberaToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "25000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bc3834b39de40e6a9f0e420ed1a81c9f247a50ff68bdd73db32ac9fe3b8aa91d"}