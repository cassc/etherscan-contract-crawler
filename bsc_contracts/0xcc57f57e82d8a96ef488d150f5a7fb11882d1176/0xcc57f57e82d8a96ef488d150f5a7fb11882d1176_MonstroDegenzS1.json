{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MonstroDegenzS1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n// Interface for ContractChecker\\r\\ninterface IContractChecker {\\r\\n    function executeDataCheck(string calldata checkName, address wallet) external view returns (uint256);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title MonstroDegenzS1\\r\\n * @dev A smart contract for handling deposits, claims, reinvestments, and referrals in a DeFi system.\\r\\n */\\r\\ncontract MonstroDegenzS1 is Ownable {\\r\\n    IContractChecker public contractChecker; // ContractChecker\\r\\n\\r\\n    bool public depositsAndReinvestsPaused = false;\\r\\n    modifier whenNotPaused() {\\r\\n        require(!depositsAndReinvestsPaused, \\\"Deposits and reinvests are paused\\\");\\r\\n        _;\\r\\n    }\\t\\r\\n\\r\\n    // Events\\r\\n    event ClaimEvent(address indexed user, uint256 amount);\\r\\n    event DepositEvent(address indexed user, uint256 amount);\\r\\n    event DepositsAndReinvestsToggled(bool paused);\\r\\n    event ReferralEvent(address indexed referrer, address indexed referee, uint256 amount);\\r\\n    event ReinvestEvent(address indexed user, uint256 amount);\\r\\n    event CashbackPercentSet(address indexed user, uint256 percent);\\r\\n\\r\\n    // Payable Wallets\\r\\n\\taddress payable public walletTeam;\\r\\n\\taddress payable public walletMarketing;\\r\\n\\taddress payable public walletFarmz;\\r\\n\\taddress payable public walletGenesis;\\r\\n\\r\\n\\t// Constants\\r\\n\\tuint256 public constant BASE_RATE = 200;\\r\\n\\tuint256 public constant MAX_BONUS_PERSONAL = 200;\\r\\n\\tuint256 public constant MAX_BONUS_NFT = 200;\\r\\n\\tuint256 public constant DEPOSIT_SHARE_MAIN = 50;\\r\\n\\tuint256 public constant DEPOSIT_SHARE_FARMZ = 30;\\r\\n\\tuint256 public constant DEPOSIT_SHARE_REFER = 20;\\r\\n\\tuint256 public constant CLAIM_TAX_TEAM = 4;\\r\\n\\tuint256 public constant CLAIM_TAX_GENESIS = 1;\\r\\n\\r\\n\\t// Struct to hold referral tier information\\r\\n\\tstruct ReferralTier {\\r\\n\\t    uint256 value; // The BNB value for the tier\\r\\n\\t    uint256 percentage; // The referral percentage for the tier\\r\\n\\t}\\r\\n\\r\\n\\t// Array to hold referral tiers\\r\\n\\tReferralTier[] public referralTiers;\\r\\n\\r\\n\\t// Struct to hold nft boost information\\r\\n\\tstruct NFTBoost {\\r\\n\\t    uint256 boost;\\r\\n        string functionName;\\r\\n\\t}\\r\\n\\r\\n\\t// Array to hold nft boosts\\r\\n\\tNFTBoost[] public nftBoosts;\\r\\n\\r\\n\\t// Struct to hold reinvestment multiplier information\\r\\n    struct ReinvestmentMultiplier {\\r\\n        uint256 percentage; // The reinvestment percentage\\r\\n        uint256 multiplier; // The bonus multiplier\\r\\n    }\\r\\n\\r\\n    // Array to hold reinvestment multipliers\\r\\n    ReinvestmentMultiplier[] public reinvestmentMultipliers;\\r\\n\\r\\n    // Define a struct to hold the global statistics\\r\\n\\tstruct GlobalStats {\\r\\n\\t    uint256 globalDeposits;\\r\\n\\t    uint256 globalClaimed;\\r\\n\\t    uint256 liquidity;\\r\\n\\t    uint256 marketing;\\r\\n\\t    uint256 farming;\\r\\n\\t}\\r\\n\\r\\n    // Wallet Info struct\\r\\n    struct WalletInfo {\\r\\n        uint256 lastAction;\\r\\n        uint256 maxPayout;\\r\\n        uint256 cashbackPercent; // Percent of referral reward to give back to referral\\r\\n        address referAddress; // Who referred this account\\r\\n        uint256 invites; // How many wallets this account referred\\r\\n        uint256 totalInvested;\\r\\n        uint256 totalClaimed;\\r\\n        uint256 totalReferred;\\r\\n        uint256 totalReferReceived; // Total referral rewards earned by this wallet\\r\\n        uint256 totalCashback; // Total cashback received by this wallet\\r\\n    }\\r\\n\\r\\n    // Mapping to store wallet data\\r\\n    mapping(address => WalletInfo) public walletData;\\r\\n\\r\\n    uint256 public globalDeposits;\\r\\n\\t  uint256 public globalClaimed;\\r\\n\\r\\n    /**\\r\\n     * @dev Constructor function to initialize the contract with ContractChecker address and payable wallets.\\r\\n     * @param _contractCheckerAddress The address of the ContractChecker contract.\\r\\n     * @param _walletTeam The address of the Team wallet.\\r\\n     * @param _walletMarketing The address of the Marketing wallet.\\r\\n     * @param _walletFarmz The address of the Farmz wallet.\\r\\n     * @param _walletGenesis The address of the Genesis wallet.\\r\\n     */\\r\\n    constructor(\\r\\n        address _contractCheckerAddress,\\r\\n        address payable _walletTeam,\\r\\n        address payable _walletMarketing,\\r\\n        address payable _walletFarmz,\\r\\n        address payable _walletGenesis\\r\\n    ) {\\r\\n        contractChecker = IContractChecker(_contractCheckerAddress);\\r\\n\\r\\n        // Initialize referral tiers in constructor with values and percentages\\r\\n        referralTiers.push(ReferralTier(0e18, 5));\\r\\n        referralTiers.push(ReferralTier(20e18, 7));\\r\\n        referralTiers.push(ReferralTier(60e18, 9));\\r\\n        referralTiers.push(ReferralTier(200e18, 11));\\r\\n        referralTiers.push(ReferralTier(400e18, 14));\\r\\n        referralTiers.push(ReferralTier(1000e18, 16));\\r\\n        referralTiers.push(ReferralTier(2000e18, 18));\\r\\n        referralTiers.push(ReferralTier(4000e18, 20));\\r\\n\\r\\n        // Initialize NFT boosts with corresponding functions\\r\\n        nftBoosts.push(NFTBoost(25, \\\"partner\\\"));\\r\\n        nftBoosts.push(NFTBoost(25, \\\"lazarusPit\\\"));\\r\\n        nftBoosts.push(NFTBoost(25, \\\"monstroFarmz\\\"));\\r\\n        nftBoosts.push(NFTBoost(50, \\\"monstroCastle\\\"));\\r\\n        nftBoosts.push(NFTBoost(75, \\\"monstroMonstro\\\"));\\r\\n        nftBoosts.push(NFTBoost(100, \\\"monstroVault\\\"));\\r\\n        nftBoosts.push(NFTBoost(150, \\\"monstroKingdom\\\"));\\r\\n\\r\\n        // Initialize reinvestment multipliers\\r\\n        reinvestmentMultipliers.push(ReinvestmentMultiplier(25, 200));\\r\\n        reinvestmentMultipliers.push(ReinvestmentMultiplier(50, 250));\\r\\n        reinvestmentMultipliers.push(ReinvestmentMultiplier(75, 300));\\r\\n        reinvestmentMultipliers.push(ReinvestmentMultiplier(100, 400));\\r\\n\\r\\n        // Initialize payable wallets\\r\\n        walletTeam = _walletTeam;\\r\\n        walletMarketing = _walletMarketing;\\r\\n        walletFarmz = _walletFarmz;\\r\\n        walletGenesis = _walletGenesis;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows users to make a deposit in BNB.\\r\\n     * @param referrer The address of the referrer.\\r\\n     */\\r\\n\\tfunction deposit(address referrer) public payable whenNotPaused {\\r\\n\\t    require(msg.value > 0, \\\"Deposit amount must be greater than zero\\\");\\r\\n\\r\\n\\t    WalletInfo storage user = walletData[msg.sender];\\r\\n\\r\\n\\t    // Check if this is their first deposit and if a valid referrer exists to attach\\r\\n\\t    if (user.totalInvested == 0 && referrer != msg.sender && referrer != address(0)) {\\r\\n\\t        user.referAddress = referrer;\\r\\n\\t        walletData[referrer].invites += 1;\\r\\n\\t    }\\r\\n\\r\\n\\t    // Force a claim\\r\\n\\t    claim();\\t\\r\\n\\r\\n\\t    // Call the private _deposit function to handle the deposit logic\\r\\n\\t    _deposit(msg.value, 150);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n     * @dev Allows users to claim accumulated rewards in BNB.\\r\\n     */\\r\\n    function claim() public {\\r\\n      uint256 claimableAmount = calculateClaimableAmount(msg.sender);\\r\\n\\r\\n\\t    if (claimableAmount > 0) {\\r\\n        _claim(claimableAmount);\\r\\n      }\\r\\n\\t}\\r\\n \\r\\n\\t/**\\r\\n     * @dev Allows users to reinvest their earnings in BNB.\\r\\n     * @param reinvestPercent The percentage of earnings to reinvest.\\r\\n     */\\r\\n\\tfunction reinvest(uint256 reinvestPercent) public whenNotPaused {\\r\\n\\t    uint256 multiplier = getReinvestmentMultiplierAndCheckValidity(reinvestPercent);\\r\\n\\t    uint256 claimableAmount = calculateClaimableAmount(msg.sender);\\r\\n\\r\\n\\t    require(claimableAmount > 0, \\\"No claimable amount available for reinvestment\\\");\\r\\n\\r\\n\\t    uint256 reinvestmentAmount = (claimableAmount * reinvestPercent) / 100;\\r\\n\\r\\n\\t    // Call the private _deposit function to handle the reinvestment\\r\\n\\t    _deposit(reinvestmentAmount, multiplier);\\r\\n\\r\\n\\t    // Call the private _claim function to claim any remaining earnings\\r\\n\\t    uint256 remainingClaimable = claimableAmount - reinvestmentAmount;\\r\\n\\t    if (remainingClaimable > 0) {\\r\\n\\t        _claim(remainingClaimable);\\r\\n\\t    }\\r\\n\\r\\n\\t    emit ReinvestEvent(msg.sender, reinvestmentAmount);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n     * @dev Allows users to set their cashback percentage.\\r\\n     * @param percent The cashback percentage to set.\\r\\n     */\\r\\n\\tfunction setCashbackPercent(uint256 percent) public {\\r\\n\\t    require(percent >= 0 && percent <= 100, \\\"Cashback percentage must be between 0% and 100%\\\");\\r\\n\\t    walletData[msg.sender].cashbackPercent = percent;\\r\\n\\r\\n\\t    emit CashbackPercentSet(msg.sender, percent);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n     * @dev Emergency function to pause any deposits or reinvests.\\r\\n     * Only the owner can call this function.\\r\\n     */\\r\\n\\tfunction toggleDepositsAndReinvests() public onlyOwner {\\r\\n        depositsAndReinvestsPaused = !depositsAndReinvestsPaused;\\r\\n\\r\\n        emit DepositsAndReinvestsToggled(depositsAndReinvestsPaused);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n\\t   * @dev Calculates the NFT boost for a given wallet.\\r\\n\\t   * @param wallet The wallet address to calculate the NFT boost for.\\r\\n\\t   * @return The NFT boost percentage for the wallet.\\r\\n\\t   */\\r\\n\\tfunction calculateNFTBoost(address wallet) public view returns (uint256) {\\r\\n\\t    uint256 boost = 0;\\r\\n\\r\\n\\t    // Loop through NFT boosts and apply them\\r\\n\\t    for (uint i = 0; i < nftBoosts.length; i++) {\\r\\n\\t        uint256 boostAmount = 0;\\r\\n\\r\\n\\t        // Use executeDataCheck with the correct check name\\r\\n\\t        boostAmount = contractChecker.executeDataCheck(nftBoosts[i].functionName, wallet);\\r\\n\\r\\n\\t        if (boostAmount > 0) {\\r\\n\\t            boost += nftBoosts[i].boost;\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\r\\n\\t    // Apply maximum rate limit\\r\\n\\t    if (boost > MAX_BONUS_NFT) {\\r\\n\\t        boost = MAX_BONUS_NFT;\\r\\n\\t    }\\r\\n\\r\\n\\t    return boost;\\r\\n\\t}\\r\\n   \\r\\n\\t/**\\r\\n\\t * @dev Calculates the personal boost based on the total investment in BNB for a wallet.\\r\\n\\t * @param wallet The wallet address to calculate the personal boost for.\\r\\n\\t * @return The personal boost percentage for the wallet.\\r\\n\\t */\\r\\n\\tfunction calculatePersonalBoost(address wallet) public view returns (uint256) {\\r\\n\\t\\tWalletInfo storage user = walletData[wallet];\\r\\n\\t\\tuint256 personalBoost = user.totalInvested / 5e18 * 10;\\r\\n\\r\\n\\t    // Apply maximum rate limit for personal boost\\r\\n\\t    if (personalBoost > MAX_BONUS_PERSONAL) {\\r\\n\\t        personalBoost = MAX_BONUS_PERSONAL;\\r\\n\\t    }\\r\\n\\r\\n\\t    return personalBoost;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Calculates the total daily payout rate for a wallet, including NFT and personal boosts.\\r\\n\\t * @param wallet The wallet address to calculate the payout rate for.\\r\\n\\t * @return The total daily payout rate for the wallet.\\r\\n\\t */\\r\\n\\tfunction calculateTotalPayoutRate(address wallet) public view returns (uint256) {\\r\\n\\t    uint256 nftBoost = calculateNFTBoost(wallet);\\r\\n\\t    uint256 personalBoost = calculatePersonalBoost(wallet);\\r\\n\\r\\n\\t    uint256 totalPayoutRate = BASE_RATE + nftBoost + personalBoost;\\r\\n\\r\\n\\t    return totalPayoutRate;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Calculates the current available amount to claim or reinvest for a wallet.\\r\\n\\t * @param wallet The wallet address to calculate the claimable amount for.\\r\\n\\t * @return The claimable amount in BNB.\\r\\n\\t */\\r\\n\\tfunction calculateClaimableAmount(address wallet) public view returns (uint256) {\\r\\n\\t    WalletInfo storage user = walletData[wallet];\\r\\n\\r\\n\\t    // Ensure that the user has some deposited value\\r\\n\\t    if (user.totalInvested == 0) {\\r\\n\\t        return 0;\\r\\n\\t    }\\r\\n\\r\\n\\t    // Calculate the time difference (in seconds) since the last action\\r\\n\\t    uint256 timeElapsed = block.timestamp - user.lastAction;\\r\\n\\r\\n\\t    // Fetch the daily rate using calculateTotalPayoutRate function\\r\\n\\t    uint256 dailyRate = calculateTotalPayoutRate(wallet);\\r\\n\\r\\n\\t    // Calculate the claimable amount\\r\\n\\t    uint256 claimableAmount = user.totalInvested * dailyRate * timeElapsed / (10000 * 86400);\\r\\n\\r\\n\\t    // Check if the claimable amount is greater than zero\\r\\n\\t    if (claimableAmount == 0) {\\r\\n\\t        return 0;\\r\\n\\t    }\\r\\n\\r\\n\\t    // Calculate the remaining payout for the wallet\\r\\n\\t    uint256 remainingPayout = getRemainingPayout(wallet);\\r\\n\\r\\n\\t    // Check if the claim amount is greater than the remaining payout\\r\\n\\t    if (claimableAmount > remainingPayout) {\\r\\n\\t        claimableAmount = remainingPayout;\\r\\n\\t    }\\r\\n\\r\\n\\t    // Ensure there is enough balance in the contract\\r\\n\\t    if (address(this).balance < claimableAmount) {\\r\\n\\t        claimableAmount = address(this).balance;\\r\\n\\t    }\\r\\n\\r\\n\\t    return claimableAmount;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Gets the reinvestment multiplier for a given percentage and checks its validity.\\r\\n\\t * @param percentage The reinvestment percentage to look up.\\r\\n\\t * @return The bonus multiplier corresponding to the reinvestment percentage.\\r\\n\\t * @notice This function is used to retrieve the bonus multiplier associated with a specific reinvestment percentage.\\r\\n\\t * It ensures that the provided reinvestment percentage is valid.\\r\\n\\t */\\r\\n\\tfunction getReinvestmentMultiplierAndCheckValidity(uint256 percentage) public view returns (uint256) {\\r\\n\\t    for (uint256 i = 0; i < reinvestmentMultipliers.length; i++) {\\r\\n\\t        if (percentage == reinvestmentMultipliers[i].percentage) {\\r\\n\\t            return reinvestmentMultipliers[i].multiplier;\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\t    revert(\\\"Invalid reinvestment percentage: Percentage not found in allowed reinvestment percentages\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Retrieves the referral tier percentage for a given address.\\r\\n\\t * @param wallet The wallet address to get the referral tier percentage for.\\r\\n\\t * @return The referral tier percentage for the wallet.\\r\\n\\t */\\r\\n\\tfunction getReferralTier(address wallet) public view returns (uint256) {\\r\\n\\t    uint256 totalReferredAmount = walletData[wallet].totalReferred;\\r\\n\\t    uint256 referralTier = 0;\\r\\n\\r\\n\\t    for (uint256 i = 0; i < referralTiers.length; i++) {\\r\\n\\t        if (totalReferredAmount >= referralTiers[i].value) {\\r\\n\\t            referralTier = referralTiers[i].percentage;\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\r\\n\\t    return referralTier;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Gets the remaining payout for a wallet.\\r\\n\\t * @param wallet The wallet address to get the remaining payout for.\\r\\n\\t * @return The remaining payout amount in BNB.\\r\\n\\t */\\r\\n\\tfunction getRemainingPayout(address wallet) public view returns (uint256) {\\r\\n\\t    WalletInfo storage user = walletData[wallet];\\r\\n\\t    return user.maxPayout - user.totalClaimed;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Retrieves global statistics as a struct containing deposit, claimed, liquidity, marketing, and farming values.\\r\\n\\t * @return The global statistics struct.\\r\\n\\t */\\r\\n\\tfunction getGlobalStats() public view returns (GlobalStats memory) {\\r\\n\\t    uint256 liquidity = (globalDeposits / 2) - globalClaimed; // 50% of deposits - claimed\\r\\n\\t    uint256 marketing = (globalDeposits * 20) / 100; // 20% of deposits\\r\\n\\t    uint256 farming = (globalDeposits * 30) / 100; // 30% of deposits\\r\\n\\r\\n\\t    GlobalStats memory stats;\\r\\n\\t    stats.globalDeposits = globalDeposits;\\r\\n\\t    stats.globalClaimed = globalClaimed;\\r\\n\\t    stats.liquidity = liquidity;\\r\\n\\t    stats.marketing = marketing;\\r\\n\\t    stats.farming = farming;\\r\\n\\r\\n\\t    return stats;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Handles referral logic and transfers referral rewards.\\r\\n\\t * @param amount The deposit amount for which referrals are calculated.\\r\\n\\t * @param referrer The address of the referrer.\\r\\n\\t * @notice This function calculates and transfers referral rewards, cashbacks, and marketing shares\\r\\n\\t * based on the provided deposit amount and referrer address.\\r\\n\\t */\\r\\n\\tfunction _handleReferralLogic(uint256 amount, address referrer) private {\\r\\n\\t    if (referrer != address(0)) {\\r\\n\\t        // Increment referrer's total referred as its used in calculating referral tier\\r\\n\\t        walletData[referrer].totalReferred += amount;\\r\\n\\r\\n\\t        // Get the referral percentage based on the referrer's tier\\r\\n\\t        uint256 referralPercentage = getReferralTier(referrer);\\r\\n\\r\\n\\t        // Calculate the total referral payout\\r\\n\\t        uint256 referralPayout = (amount * referralPercentage) / 100;\\r\\n\\r\\n\\t        // Calculate the cashback amount\\r\\n\\t        uint256 cashbackAmount = 0;\\r\\n\\t        if (walletData[referrer].cashbackPercent > 0) {\\r\\n\\t            cashbackAmount = (referralPayout * walletData[referrer].cashbackPercent) / 100;\\r\\n\\t        }\\r\\n\\r\\n\\t        // Calculate net referral payout after cashback\\r\\n\\t        uint256 netReferralPayout = referralPayout - cashbackAmount;\\r\\n\\r\\n\\t\\t\\t// Check if net referral payout is greater than zero before transferring\\r\\n\\t\\t\\tif (netReferralPayout > 0) {\\r\\n\\t\\t\\t    // Transfer the net referral payout to the referrer\\r\\n\\t\\t\\t    payable(referrer).transfer(netReferralPayout);\\r\\n\\r\\n\\t\\t\\t    // Increment total rewards received\\r\\n\\t\\t\\t    walletData[referrer].totalReferReceived += netReferralPayout;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t        // Transfer the cashback amount to the depositor\\r\\n\\t        if (cashbackAmount > 0) {\\r\\n\\t            payable(msg.sender).transfer(cashbackAmount);\\r\\n\\r\\n\\t            // Increment cashback for msg.sender\\r\\n\\t            walletData[msg.sender].totalCashback += cashbackAmount;\\r\\n\\t        }\\r\\n\\r\\n\\t        // Calculate the remaining amount after referral and cashback\\r\\n\\t        uint256 remainingAmount = (amount * DEPOSIT_SHARE_REFER) / 100 - netReferralPayout - cashbackAmount;\\r\\n\\r\\n\\t        // Check if remaining amount is greater than zero before transferring it to marketing\\r\\n\\t        if (remainingAmount > 0) {\\r\\n\\t            payable(walletMarketing).transfer(remainingAmount);\\r\\n\\t        }\\r\\n\\r\\n\\t        emit ReferralEvent(referrer, msg.sender, amount);\\r\\n\\r\\n\\t    } else {\\r\\n\\t        // If there's no referrer, transfer defined share in full to marketing wallet\\r\\n\\t        uint256 marketingAmount = (amount * DEPOSIT_SHARE_REFER) / 100;\\r\\n\\t        payable(walletMarketing).transfer(marketingAmount);\\r\\n\\t    }\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Handles the deposit logic and transfers shares to appropriate wallets.\\r\\n\\t * @param amount The deposit amount in BNB.\\r\\n\\t * @param multiplier The bonus multiplier for the deposit.\\r\\n\\t * @notice This function handles the deposit process, calculates shares, transfers funds\\r\\n\\t * to marketing, farmz, and the contract, and updates user's wallet information.\\r\\n\\t */\\r\\n\\tfunction _deposit(uint256 amount, uint256 multiplier) private {\\r\\n\\t    WalletInfo storage user = walletData[msg.sender];\\r\\n\\r\\n\\t    // Handle referral logic\\r\\n\\t    _handleReferralLogic(amount, user.referAddress);\\r\\n\\r\\n\\t    // Update user's wallet info\\r\\n\\t    user.lastAction = block.timestamp;\\r\\n\\t    user.maxPayout += amount * multiplier / 100;\\r\\n\\t    user.totalInvested += amount;\\r\\n\\r\\n\\t    // Increment globalDeposits\\r\\n\\t    globalDeposits += amount;\\r\\n\\r\\n\\t    // Calculate and pay farming wallet\\r\\n\\t    uint256 farmzShare = (amount * DEPOSIT_SHARE_FARMZ) / 100;\\r\\n\\t    payable(walletFarmz).transfer(farmzShare);\\r\\n\\r\\n\\t    emit DepositEvent(msg.sender, amount);\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Handles the claim logic, taxes, and transfers accumulated rewards.\\r\\n\\t * @param claimableAmount The amount of BNB that can be claimed.\\r\\n\\t * @notice This function calculates and transfers rewards to users, deducts taxes, and updates user's wallet information.\\r\\n\\t */\\r\\n\\tfunction _claim(uint256 claimableAmount) private {\\r\\n\\t    WalletInfo storage user = walletData[msg.sender];\\r\\n\\r\\n\\t    // Calculate taxes\\r\\n\\t    uint256 teamTax = (claimableAmount * CLAIM_TAX_TEAM) / 100;\\r\\n\\t    uint256 genesisTax = (claimableAmount * CLAIM_TAX_GENESIS) / 100;\\r\\n\\t    uint256 netAmount = claimableAmount - teamTax - genesisTax;\\r\\n\\r\\n\\t    // Update user's wallet info\\r\\n\\t    user.lastAction = block.timestamp;\\r\\n\\t    user.totalClaimed += netAmount;\\r\\n\\r\\n\\t    // Increment globalClaimed\\r\\n\\t    globalClaimed += claimableAmount;\\r\\n\\r\\n\\t    // Transfer taxes\\r\\n\\t    payable(walletTeam).transfer(teamTax);\\r\\n\\t    payable(walletGenesis).transfer(genesisTax);\\r\\n\\r\\n\\t    // Transfer net amount to user\\r\\n\\t    payable(msg.sender).transfer(netAmount);\\r\\n\\r\\n\\t    emit ClaimEvent(msg.sender, netAmount);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractCheckerAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_walletTeam\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_walletMarketing\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_walletFarmz\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_walletGenesis\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"CashbackPercentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"DepositsAndReinvestsToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReinvestEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIM_TAX_GENESIS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIM_TAX_TEAM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_SHARE_FARMZ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_SHARE_MAIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_SHARE_REFER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BONUS_NFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BONUS_PERSONAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"calculateClaimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"calculateNFTBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"calculatePersonalBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"calculateTotalPayoutRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractChecker\",\"outputs\":[{\"internalType\":\"contract IContractChecker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositsAndReinvestsPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"globalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"globalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"farming\",\"type\":\"uint256\"}],\"internalType\":\"struct MonstroDegenzS1.GlobalStats\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getReferralTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"getReinvestmentMultiplierAndCheckValidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getRemainingPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftBoosts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"functionName\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralTiers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reinvestPercent\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reinvestmentMultipliers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setCashbackPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDepositsAndReinvests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastAction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cashbackPercent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"invites\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferred\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCashback\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletFarmz\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletGenesis\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletMarketing\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletTeam\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MonstroDegenzS1", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ab38f0535d53bed6d74d514ef521264cb18a414a0000000000000000000000000ccd0930b070602ded69938bb9de052c5e8d99d50000000000000000000000002d87b09e9622c26304ff8b0de3c40a3f59df6968000000000000000000000000dbe214c863d6b2ecf5d79012e5d03aab09c57e2800000000000000000000000023f49dd783c43e185c57adb9e65046011d614b0d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}