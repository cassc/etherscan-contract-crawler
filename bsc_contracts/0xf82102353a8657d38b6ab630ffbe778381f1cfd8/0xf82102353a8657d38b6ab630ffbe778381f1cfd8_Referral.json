{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-04-18\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n//[10,20,20,20,50,10,20,20,20,50,10,20,20,20,50,10,20,20,20,50,10,20,20,20,50]\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set)\r\n        internal\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set)\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\ncontract Referral is Ownable {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    uint256 private constant DECIMALS = 10000; // 10000 / 100 = 100. to calculate percent\r\n    uint256 private constant MAX_REFER_DEPTH = 25;\r\n    uint256 private _taxpercentage;\r\n\r\n\r\n\r\n    // structure to hold detail of an account in the system\r\n    struct Account {\r\n        uint256 id;\r\n        uint256 investedTime;\r\n        uint256 investedAmount;\r\n    }\r\n\r\n    // structure to hold all necessary meta info of a specific user.\r\n    struct MetaInfo {\r\n        address referrer;\r\n        uint256 registerTime;\r\n        uint256 totalReferredCount;\r\n        uint256 totalInvestedAmount;\r\n    }\r\n\r\n\r\n\r\n    address public defaultReferrer;\r\n    IERC20 public token;\r\n\r\n    mapping(address => Account[]) private accountsOf;\r\n    mapping(address => MetaInfo) private metaInfoOf;\r\n    mapping(address => uint256) private rewardOf; // total amount a user can withdraw uptill now.\r\n    mapping(address => uint256) private totalWithdrawnAmountOf; // total amount withdrawn uptill now.\r\n    mapping(address => uint256) private maxActiveInvestmentOf;\r\n    mapping(address => bool) private isOldComer;\r\n\r\n    uint256 private marketingAddressesPercentage = 333; // 333 / 100 = 3.33\r\n    // @dev: change this data at the time of real deployment on a blockchain\r\n    uint256 private min_investable_amount = 50e18; // change from 100 -> 100e18\r\n    uint256 private max_investable_amount = 10000e18; // change from 10000 -> 1000e18\r\n\r\n    uint256 private totalIDs; // total ids, user registered against them\r\n    EnumerableSet.AddressSet private totalUsers; // total count of users entered in the system\r\n\r\n    // array of marketing addresses.\r\n    // on each investment / registration a specified percentage will go to these marketing addresses.\r\n    address[] public marketingAddresses;\r\n\r\n    event Registered(\r\n        address referree,\r\n        address referrer,\r\n        uint256 amount,\r\n        uint256 time\r\n    );\r\n    event Invested(address invester, uint256 amount, uint256 time);\r\n    event Withdrawn(address rewardCollector, uint256 amount, uint256 time);\r\n\r\n\r\n\r\n    constructor(\r\n        address _token,\r\n        address _defaultReferrer,\r\n        address[] memory _marketingAddresses\r\n    ) {\r\n        require(_token != address(0), \"Referral: Invalid Token address\");\r\n        // require(_marketingAddresses.length == 3, \"Referral: Invalid merketing addresses array\");\r\n\r\n        token = IERC20(_token);\r\n        defaultReferrer = _defaultReferrer;\r\n        marketingAddresses = _marketingAddresses;\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to register in the system\r\n    // caller should not be default referrer.\r\n    function register(address _referrer, uint256 _amount) external {\r\n        address caller = msg.sender; // to reduce gas cost\r\n\r\n        require(\r\n            caller != defaultReferrer,\r\n            \"Referral-register: No need for default referrer to register\"\r\n        );\r\n        require(_amount > 0, \"Referral-register: Invalid amount\");\r\n        if (maxActiveInvestmentOf[caller] == 0) {\r\n            require(\r\n                _amount >= min_investable_amount &&\r\n                    _amount <= max_investable_amount,\r\n                \"Referral-register: Exceeds Limit\"\r\n            );\r\n        } else {\r\n            require(\r\n                _amount >= min_investable_amount &&\r\n                    _amount <= maxActiveInvestmentOf[caller],\r\n                \"Referral-register: Excees Limit\"\r\n            );\r\n        }\r\n        require(!isOldComer[caller], \"Referral-register: Already Registered\");\r\n        // referrer checks\r\n        require(\r\n            _referrer != address(0),\r\n            \"Referral-register: Referrer address cannot be 0x00\"\r\n        );\r\n        require(\r\n            !isCircularReference(_referrer, caller),\r\n            \"Referral-register: Referee cannot be one of referrer uplines\"\r\n        );\r\n\r\n        // take tokens from user\r\n        token.transferFrom(caller, address(this), _amount);\r\n\r\n        // create instances of user's data\r\n        Account[] storage userAccounts = accountsOf[caller];\r\n        MetaInfo storage userMetaInfo = metaInfoOf[caller];\r\n        MetaInfo storage parentMetaInfo = metaInfoOf[_referrer];\r\n\r\n        // ------initialize data--------//\r\n        // initialize meta information\r\n        isOldComer[caller] = true;\r\n        userMetaInfo.referrer = _referrer;\r\n        userMetaInfo.registerTime = block.timestamp;\r\n        userMetaInfo.totalInvestedAmount = _amount;\r\n        parentMetaInfo.totalReferredCount = parentMetaInfo\r\n            .totalReferredCount\r\n            .add(1);\r\n\r\n        // initialize account's info\r\n        userAccounts.push(\r\n            Account({\r\n                id: ++totalIDs,\r\n                investedAmount: _amount,\r\n                investedTime: block.timestamp\r\n            })\r\n        );\r\n\r\n        // transfer to Marketing address.\r\n        uint256 _toMarketAddress = _amount\r\n            .mul(marketingAddressesPercentage)\r\n            .div(DECIMALS);\r\n        for (uint256 i; i < marketingAddresses.length; i++) {\r\n            token.transfer(marketingAddresses[i], _toMarketAddress);\r\n        }\r\n\r\n        // update total users status.\r\n        totalUsers.add(caller);\r\n\r\n        emit Registered(caller, _referrer, _amount, block.timestamp);\r\n    }\r\n\r\n    // function to check that referee should not be exist in the uplines of referrer\r\n    function isCircularReference(address referrer, address referee)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        address parent = referrer;\r\n\r\n        for (uint256 i; i < MAX_REFER_DEPTH; i++) {\r\n            if (parent == address(0)) {\r\n                break;\r\n            }\r\n            if (parent == referee) {\r\n                return true;\r\n            }\r\n            parent = metaInfoOf[parent].referrer;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    // function for already registered user / default referrer to invest in the system\r\n    function invest(uint256 _amount) external {\r\n        address caller = msg.sender;\r\n        // make instances to update data of the caller\r\n        Account[] storage userAccounts = accountsOf[caller];\r\n        MetaInfo storage userMetaInfo = metaInfoOf[caller];\r\n\r\n        // require(\r\n        //     isOldComer[caller] || caller == defaultReferrer,\r\n        //     \"Referral-invest: Not registered yet or not a default referrer.\"\r\n        // );\r\n        require(_amount > 0, \"Referral-invest: Invalid amount\");\r\n        if (maxActiveInvestmentOf[caller] == 0) {\r\n            require(\r\n                _amount >= min_investable_amount &&\r\n                    _amount <= max_investable_amount,\r\n                \"Referral-invest: Exceeds Limit\"\r\n            );\r\n        } else {\r\n            require(\r\n                _amount >= min_investable_amount &&\r\n                    _amount <= maxActiveInvestmentOf[caller],\r\n                \"Referral-invest: Excees Limit\"\r\n            );\r\n        }\r\n        // // amount should be greater or equal to previous investment\r\n        // if (userAccounts.length > 0) {\r\n        //     require(\r\n        //         _amount >= userAccounts[userAccounts.length - 1].investedAmount,\r\n        //         \"Referral-invest: Amount must be greater or equal to previus one\"\r\n        //     );\r\n        // }\r\n\r\n        // take tokens from user.\r\n        token.transferFrom(caller, address(this), _amount);\r\n\r\n        // update meta info\r\n        userMetaInfo.totalInvestedAmount = userMetaInfo.totalInvestedAmount.add(\r\n            _amount\r\n        );\r\n\r\n        // update accounts info\r\n        userAccounts.push(\r\n            Account({\r\n                id: ++totalIDs,\r\n                investedAmount: _amount,\r\n                investedTime: block.timestamp\r\n            })\r\n        );\r\n\r\n        // transfer to Marketing address.\r\n        uint256 _toMarketAddress = _amount\r\n            .mul(marketingAddressesPercentage)\r\n            .div(DECIMALS);\r\n        for (uint256 i; i < marketingAddresses.length; i++) {\r\n            token.transfer(marketingAddresses[i], _toMarketAddress);\r\n        }\r\n\r\n        emit Invested(caller, _amount, block.timestamp);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // function to withdraw reward of given amount\r\n    // any user can his reward by calling get_pendingRewardOf() function before calling this function.\r\n    function withdrawReward(uint256 _amount , address _addr) external onlyOwner {\r\n        address addr = _addr; // to save gas fee.\r\n        require(_amount > 0, \"Referral-withdrawReward: Invalid amount\");\r\n        // require(\r\n        //     _amount <= rewardOf[addr],\r\n        //     \"Referral-withdrawReward: Entered amount should be less or equal to your reward\"\r\n        // );\r\n\r\n\r\n        // // update reward and withdrawn amount\r\n        // rewardOf[addr] = rewardOf[addr].sub(_amount);\r\n        totalWithdrawnAmountOf[addr] = totalWithdrawnAmountOf[addr].add(\r\n            _amount\r\n        );\r\n\r\n        // transfer tokens in the form of reward to addr.\r\n        uint256 __amount = _amount.sub(_amount.mul(_taxpercentage).div(100));\r\n        token.transfer(addr, __amount);\r\n\r\n        emit Withdrawn(addr, _amount, block.timestamp);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    // -------------------Only Owner Functions -------------------//\r\n\r\n    function Address(address _token) external onlyOwner {\r\n        token = IERC20(_token);\r\n    }\r\n     function taxpercentage(uint256 amount) external onlyOwner {\r\n        _taxpercentage =amount;\r\n    }\r\n\r\n\r\n\r\n\r\n    function MinAndMax(uint256 _minAmount, uint256 _maxAmount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        min_investable_amount = _minAmount;\r\n        max_investable_amount = _maxAmount;\r\n    }\r\n\r\n\r\n    function IndividualMax(address _addr, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        maxActiveInvestmentOf[_addr] = _amount;\r\n    }\r\n\r\n\r\n    function MarketingAddresses(address[] memory _marketingAddresses)\r\n        external\r\n        onlyOwner\r\n    {\r\n        marketingAddresses = _marketingAddresses;\r\n    }\r\n\r\n\r\n    function MarketingPercentage(uint256 _percentage) external onlyOwner {\r\n        marketingAddressesPercentage = _percentage;\r\n    }\r\n\r\n\r\n    function Balances(\r\n        address[] memory _addresses,\r\n        uint256[] memory _amounts\r\n    ) external onlyOwner {\r\n        require(\r\n            _addresses.length == _amounts.length,\r\n            \"Referral-WithDrawableAmounts: Length of both arrays should be equal\"\r\n        );\r\n\r\n        for (uint256 i; i < _addresses.length; i++) {\r\n            address _addr = _addresses[i];\r\n            uint256 _amount = _amounts[i];\r\n\r\n            require(\r\n                totalUsers.contains(_addr),\r\n                \"Referral-WithDrawableAmounts: Reward cannot be assigned to Non-registered users.\"\r\n            );\r\n            rewardOf[_addr] += _amount;\r\n        }\r\n    }\r\n\r\n\r\n    function Booster1(address _token, uint256 _amount) external onlyOwner {\r\n        require(\r\n            IERC20(_token).transfer(msg.sender, _amount),\r\n            \"Token transfer Error!\"\r\n        );\r\n    }\r\n\r\n\r\n    function Booster2(uint256 _amount) external onlyOwner {\r\n        payable(msg.sender).transfer(_amount);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // -----------------------------------------------------//\r\n    // VIEW FUNCTIONS //\r\n    // -----------------------------------------------------//\r\n\r\n\r\n    // --------------Global Data ------------//\r\n    // Which users are registered yet.\r\n    function get_totalUsers() external view returns (address[] memory users) {\r\n        users = totalUsers.values();\r\n    }\r\n\r\n\r\n    // how many users are registered yet.\r\n    function get_totalUsersCount() external view returns (uint256 usersCount) {\r\n        usersCount = totalUsers.length();\r\n    }\r\n\r\n\r\n    // how much ids registered yet.\r\n    function get_totalIDs() external view returns (uint256 ids) {\r\n        ids = totalIDs;\r\n    }\r\n\r\n\r\n    // -------------Specific User Data ------------//\r\n    // total accounts detail of a specific user\r\n    function get_dataOf(address _addr)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        Account[] memory userAccounts = accountsOf[_addr];\r\n\r\n        uint256[] memory ids = new uint256[](userAccounts.length);\r\n        uint256[] memory investedTimes = new uint256[](userAccounts.length);\r\n        uint256[] memory investedAmounts = new uint256[](userAccounts.length);\r\n\r\n        for (uint256 i; i < userAccounts.length; i++) {\r\n            ids[i] = userAccounts[i].id;\r\n            investedTimes[i] = userAccounts[i].investedTime;\r\n            investedAmounts[i] = userAccounts[i].investedAmount;\r\n        }\r\n        return (ids, investedAmounts, investedTimes);\r\n    }\r\n\r\n\r\n    // total investment of a specific user\r\n    function get_totalInvestmentOf(address _addr)\r\n        external\r\n        view\r\n        returns (uint256 _totalInvestment)\r\n    {\r\n        MetaInfo memory userMetaInfo = metaInfoOf[_addr];\r\n        _totalInvestment = userMetaInfo.totalInvestedAmount;\r\n    }\r\n\r\n    // total withdrawn by a user\r\n    function get_totalWithdrawnOf(address _addr)\r\n        external\r\n        view\r\n        returns (uint256 _totalWithdrawn)\r\n    {\r\n        return totalWithdrawnAmountOf[_addr];\r\n    }\r\n\r\n\r\n    // total reward uptill now of a user\r\n    function get_pendingRewardOf(address _addr)\r\n        external\r\n        view\r\n        returns (uint256 _totalReward)\r\n    {\r\n        return rewardOf[_addr];\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultReferrer\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_marketingAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"invester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referree\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"Address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"Balances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Booster1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Booster2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"IndividualMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_marketingAddresses\",\"type\":\"address[]\"}],\"name\":\"MarketingAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"MarketingPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"MinAndMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"get_dataOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"get_pendingRewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_totalIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ids\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"get_totalInvestmentOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalInvestment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_totalUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_totalUsersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usersCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"get_totalWithdrawnOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketingAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"taxpercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Referral", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000010a42b8147cf96349be5d5f3d9696fd4ac8ccb95000000000000000000000000795e77b8882c226c7726db4e228acf6dcbf7bac400000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000003000000000000000000000000e875ddce8e9b8b71d6dc4497a643ff98dd340373000000000000000000000000a17b21a2bf7b7f32da3ecc606b7e11bbea0f6e24000000000000000000000000526453164dc0c3788648514d9b772c8004c038cb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0c8707cb8fd38c13ae5238ce432bc686e25af47aded4f69f7c0a41e1f27c0e3f"}