{"SourceCode": "{\"Binamon.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\r\\n\\r\\nimport \\\"./BMON.sol\\\";\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n      *\\r\\n      * Requirements:\\r\\n      *\\r\\n      * - `from` cannot be the zero address.\\r\\n      * - `to` cannot be the zero address.\\r\\n      * - `tokenId` token must exist and be owned by `from`.\\r\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n      *\\r\\n      * Emits a {Transfer} event.\\r\\n      */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Metadata is IERC721 {\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n// Type definitions\\r\\nstruct BinamonType {\\r\\n    uint256 _class;\\r\\n    string _hash;\\r\\n    string _name;\\r\\n    string _extra;\\r\\n    string _info;\\r\\n}\\r\\n\\r\\nstruct BinamonToken {\\r\\n    uint256 _type;\\r\\n    uint256 _attack;\\r\\n    uint256 _hornpower;\\r\\n    string _element;\\r\\n}\\r\\n\\r\\n// Binamon main smart contract\\r\\n\\r\\ncontract Binamon/* is IERC721*/ {\\r\\n    \\r\\n    // Contract owner\\r\\n    address private _owner;\\r\\n    \\r\\n    // Token name\\r\\n    string private _name;\\r\\n\\r\\n    // Token symbol\\r\\n    string private _symbol;\\r\\n    \\r\\n    \\r\\n    // ERC721 data\\r\\n\\r\\n    // Mapping from token ID to owner address\\r\\n    mapping (uint256 =\\u003e address) private owners;\\r\\n    \\r\\n    // Trusted users list\\r\\n    mapping (address =\\u003e bool) private _isTrusted;\\r\\n    \\r\\n    // Mapping owner address to token count\\r\\n    mapping (address =\\u003e uint256) private balances;\\r\\n\\r\\n    // Mapping from token ID to approved address\\r\\n    mapping (uint256 =\\u003e address) private tokenApprovals;\\r\\n\\r\\n    // Mapping from owner to operator approvals\\r\\n    mapping (address =\\u003e mapping (address =\\u003e bool)) private operatorApprovals;\\r\\n    \\r\\n    \\r\\n    // Binamon specific data\\r\\n    \\r\\n    // Frequency values\\r\\n    uint256[11] private classFreqs;\\r\\n    uint256[11] private attackFreqs;\\r\\n    uint256[9] private hornpowerFreqs;\\r\\n    uint256[5] private elementFreqs;\\r\\n    \\r\\n    // Elements\\r\\n    string[6] private elements;\\r\\n        \\r\\n    // BMON Contract\\r\\n    address payable private bmonAddress;\\r\\n    BMON private bmonContract;\\r\\n    \\r\\n    // Current booster price\\r\\n    uint256 private boosterPrice;\\r\\n    \\r\\n    // Token types and tokens\\r\\n    uint256 private typeCount;\\r\\n    uint256 private tokenCount;\\r\\n    mapping (uint256 =\\u003e BinamonType) private types;\\r\\n    mapping (uint256 =\\u003e uint256[]) private typesByClass;\\r\\n    mapping (uint256 =\\u003e BinamonToken) private tokens;\\r\\n    \\r\\n    \\r\\n    // Events\\r\\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n    \\r\\n    // Ownership check\\r\\n    modifier isOwner() {\\r\\n        require(msg.sender == _owner, \\\"Caller is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    // Trusted users check\\r\\n    modifier isTrusted {\\r\\n        require(_isTrusted[msg.sender] || msg.sender == _owner, \\\"Caller is not trusted\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Initializes the contract by setting a `name` and a `symbol` to the token collection.\\r\\n    constructor () {\\r\\n        _name = \\u0027Binamon NFT Collection\\u0027;\\r\\n        _symbol = \\u0027BMONC\\u0027;\\r\\n        _owner = msg.sender;\\r\\n        bmonAddress = payable(address(0));\\r\\n        boosterPrice = 1000000000000000000; // 1 BMON by default\\r\\n        typeCount = 0;\\r\\n        tokenCount = 0;\\r\\n        \\r\\n        classFreqs = [uint(10), uint(25), uint(50), uint(1000), uint(2000), uint(4000), uint(6000), uint(8000), uint(10000), uint(15000), uint(20000)]; // the rest remains for class 1\\r\\n        attackFreqs = [uint(10), uint(25), uint(50), uint(100), uint(200), uint(400), uint(600), uint(800), uint(1000), uint(1500), uint(2000)]; // the rest remains for attack 1\\r\\n        hornpowerFreqs = [uint(10), uint(20), uint(30), uint(50), uint(60), uint(80), uint(100), uint(150), uint(200)]; // the rest remains for hornpower 1\\r\\n        elementFreqs = [uint(10), uint(40), uint(150), uint(200), uint(250)]; // the rest remains for element 1\\r\\n        elements = [\\\"Forest\\\", \\\"Water\\\", \\\"Fire\\\", \\\"Light\\\", \\\"Psiquic\\\", \\\"Quantum\\\"];\\r\\n        \\r\\n        emit Transfer(address(0), msg.sender, 0); // Dummy event for BSCScan to recognize token\\r\\n    }\\r\\n\\r\\n    // Changes contract owner\\r\\n    function changeOwner(address newOwner) public isOwner {\\r\\n        _owner = newOwner;\\r\\n        emit OwnerSet(_owner, newOwner);\\r\\n    }\\r\\n\\r\\n    // Returns contract owner\\r\\n    function getOwner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    \\r\\n    // Adds a trusted user\\r\\n    function addTrusted(address user) public isOwner {\\r\\n        _isTrusted[user] = true;\\r\\n    }\\r\\n\\r\\n    // Removes a trusted user    \\r\\n    function removeTrusted(address user) public isOwner {\\r\\n        _isTrusted[user] = false;\\r\\n    }\\r\\n    \\r\\n    // Changes BMON contract address\\r\\n    function changeBMONAddress(address newAddress) public isTrusted {\\r\\n        bmonAddress = payable(newAddress);\\r\\n        bmonContract = BMON(bmonAddress);\\r\\n    }\\r\\n\\r\\n    // Returns BMON contract address\\r\\n    function getBMONAddress() public view returns (address) {\\r\\n        return bmonAddress;\\r\\n    }\\r\\n    \\r\\n    // Returns current ticket price\\r\\n    function getBoosterPrice() public view returns (uint256) {\\r\\n        return boosterPrice;\\r\\n    }\\r\\n    \\r\\n    // Returns current ticket price\\r\\n    function setBoosterPrice(uint256 newPrice) public isTrusted {\\r\\n        boosterPrice = newPrice;\\r\\n    }\\r\\n\\r\\n    // Returns token name\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    // Returns token symbol\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    \\r\\n    // Mandatory and optional ERC721 methods\\r\\n    \\r\\n    // Gets file URI for a token\\r\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\r\\n        require(exists(tokenId), \\\"URI query for nonexistent token\\\");\\r\\n\\r\\n        string memory baseURI = \\\"https://ipfs.io/ipfs/\\\";\\r\\n        return string(abi.encodePacked(baseURI, tokenId));\\r\\n    }\\r\\n\\r\\n    // Verifies token existance\\r\\n    function exists(uint256 tokenId) private view returns (bool) {\\r\\n        return owners[tokenId] != address(0);\\r\\n    }\\r\\n    \\r\\n    // Returns total supply\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return tokenCount;\\r\\n    }\\r\\n\\r\\n    // Returns token by its index\\r\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\r\\n        require(index \\u003c tokenCount, \\\"Index is out of range\\\");\\r\\n        return index + 1; // We just number them starting from 1\\r\\n    }\\r\\n\\r\\n    // Returns owner\\u0027s token by its index\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\r\\n        require(index \\u003c balanceOf(owner), \\\"Index is out of range\\\");\\r\\n        \\r\\n        uint256 current = 0;\\r\\n        for (uint256 i = 0; i \\u003c tokenCount; i++) {\\r\\n            if (owners[i+1] == owner) {\\r\\n                if (current == index) return i+1;\\r\\n                current += 1;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    // Returns owner\\u0027s token by its index\\r\\n    function tokenDetails(uint256 tokenId) public view returns (BinamonToken memory token, BinamonType memory type_) {\\r\\n        require(exists(tokenId), \\\"Details query for nonexistent token\\\");\\r\\n        return (tokens[tokenId], types[tokens[tokenId]._type]);\\r\\n    }\\r\\n    \\r\\n    // Returns balance - ERC721\\r\\n    function balanceOf(address owner) public view returns (uint256) {\\r\\n        require(owner != address(0), \\\"Balance query for the zero address\\\");\\r\\n        return balances[owner];\\r\\n    }\\r\\n\\r\\n    // Returns owner of a token - ERC721\\r\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\r\\n        address owner = owners[tokenId];\\r\\n        require(owner != address(0), \\\"Owner query for nonexistent token\\\");\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    // Approves token - ERC721\\r\\n    function approve(address to, uint256 tokenId) public {\\r\\n        address owner = ownerOf(tokenId);\\r\\n        require(to != owner, \\\"Approval to current owner\\\");\\r\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \\\"Approve caller is neither owner nor approved for all\\\");\\r\\n\\r\\n        tokenApprovals[tokenId] = to;\\r\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\r\\n    }\\r\\n\\r\\n    // Approval query - ERC721\\r\\n    function getApproved(uint256 tokenId) public view returns (address) {\\r\\n        require(exists(tokenId), \\\"Approved query for nonexistent token\\\");\\r\\n\\r\\n        return tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    // Sets approval for all - ERC721\\r\\n    function setApprovalForAll(address operator, bool approved) public {\\r\\n        require(operator != msg.sender, \\\"Trying to approve the caller\\\");\\r\\n\\r\\n        operatorApprovals[msg.sender][operator] = approved;\\r\\n        emit ApprovalForAll(msg.sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    // Checks approval for all - ERC721\\r\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\r\\n        return operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    // Checks approval - ERC721\\r\\n    function isApprovedOrOwner(address spender, uint256 tokenId) private view returns (bool) {\\r\\n        require(exists(tokenId), \\\"Operator query for nonexistent token\\\");\\r\\n        address owner = ownerOf(tokenId);\\r\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\r\\n    }\\r\\n\\r\\n    // Transfers token from another address - ERC721\\r\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\r\\n        require(isApprovedOrOwner(msg.sender, tokenId), \\\"Transfer caller is neither owner nor approved\\\");\\r\\n\\r\\n        transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    // Safe transfer - ERC721\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\r\\n        require(isApprovedOrOwner(msg.sender, tokenId), \\\"Transfer caller is neither owner nor approved\\\");\\r\\n        transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    // Safe transfer with data - ERC721\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) public {\\r\\n        require(isApprovedOrOwner(msg.sender, tokenId), \\\"Transfer caller is neither owner nor approved\\\");\\r\\n        \\r\\n        // In Binamon we don\\u0027t use any data, just transfer token\\r\\n        transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    // Transfers - ERC721\\r\\n    function transfer(address from, address to, uint256 tokenId) private {\\r\\n        require(ownerOf(tokenId) == from, \\\"Transfer of token that is not owned\\\");\\r\\n        require(to != address(0), \\\"Transfer to the zero address\\\");\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        approve(address(0), tokenId);\\r\\n\\r\\n        balances[from] -= 1;\\r\\n        balances[to] += 1;\\r\\n        owners[tokenId] = to;\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    // Binamon specific methods\\r\\n    \\r\\n    // Returns total types\\r\\n    function totalTypes() public view returns (uint256) {\\r\\n        return typeCount;\\r\\n    }\\r\\n\\r\\n    // Returns class name by its index\\r\\n    function typeByIndex(uint256 index) public view returns (BinamonType memory) {\\r\\n        require(index \\u003c typeCount, \\\"Index is out of range\\\");\\r\\n        return types[index + 1];\\r\\n    }\\r\\n    \\r\\n    // RNG, on-chain timestamp based\\r\\n    function random(uint256 modulo, uint256 salt) private view returns (uint256) {\\r\\n        return uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp - 47 * salt, block.difficulty, msg.sender))) % modulo;\\r\\n    }\\r\\n    \\r\\n    // Selects random class\\r\\n    function randomClass(uint256 salt) private view returns (uint256) {\\r\\n        // Class frequencies\\r\\n        uint256 number = random(100000, salt);\\r\\n        \\r\\n        uint256 border = 0;\\r\\n        for (uint8 i = 0; i \\u003c 11; i++) {\\r\\n            border += classFreqs[i];\\r\\n            if (number \\u003c border) return 12 - i;\\r\\n        }\\r\\n        \\r\\n        return 1;\\r\\n    }\\r\\n    \\r\\n    // Selects random attack\\r\\n    function randomAttack(uint256 salt) private view returns (uint256) {\\r\\n        // Attack frequencies\\r\\n        uint256 number = random(10000, salt);\\r\\n        \\r\\n        uint256 border = 0;\\r\\n        for (uint8 i = 0; i \\u003c 11; i++) {\\r\\n            border += attackFreqs[i];\\r\\n            if (number \\u003c border) return 12 - i;\\r\\n        }\\r\\n        \\r\\n        return 1;\\r\\n    }\\r\\n    \\r\\n    // Selects random hornpower\\r\\n    function randomHornpower(uint256 salt) private view returns (uint256) {\\r\\n        // Hornpower frequencies\\r\\n        uint256 number = random(1000, salt);\\r\\n        \\r\\n        uint256 border = 0;\\r\\n        for (uint8 i = 0; i \\u003c 9; i++) {\\r\\n            border += hornpowerFreqs[i];\\r\\n            if (number \\u003c border) return 10 - i;\\r\\n        }\\r\\n        \\r\\n        return 1;\\r\\n    }\\r\\n    \\r\\n    // Selects random element\\r\\n    function randomElement(uint256 salt) private view returns (uint256) {\\r\\n        uint256 number = random(1000, salt);\\r\\n        \\r\\n        uint256 border = 0;\\r\\n        for (uint8 i = 0; i \\u003c 5; i++) {\\r\\n            border += elementFreqs[i];\\r\\n            if (number \\u003c border) return 5 - i;\\r\\n        }\\r\\n        \\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    // Selects random type of class\\r\\n    function randomTypeOfClass(uint256 class, uint256 salt) private view returns (uint256) {\\r\\n        require(typesByClass[class].length \\u003e 0, \\\"No Binamons for choosen class\\\");\\r\\n        \\r\\n        uint256 index = random(typesByClass[class].length, salt);\\r\\n        return typesByClass[class][index];\\r\\n    }\\r\\n    \\r\\n    // Adds a Binamon type (admin method)\\r\\n    function addNewType(uint256 class, string memory hash, string memory name_, string memory extra, string memory info) public isTrusted {\\r\\n        typeCount += 1; // We want type IDs to start from 1\\r\\n        \\r\\n        BinamonType memory type_;\\r\\n        type_._class = class;\\r\\n        type_._hash = hash;\\r\\n        type_._name = name_;\\r\\n        type_._extra = extra;\\r\\n        type_._info = info;\\r\\n        \\r\\n        types[typeCount] = type_;\\r\\n        typesByClass[class].push(typeCount);\\r\\n    }\\r\\n    \\r\\n    // Buys and generates a boost\\r\\n    function buyBooster() public {\\r\\n        require(bmonContract.boosterBuyingAllowance(msg.sender), \\\"User account is not approved for buying Binamons\\\");\\r\\n        require(bmonContract.balanceOf(msg.sender) \\u003e= boosterPrice, \\\"Not enough BMON to buy a booster\\\");\\r\\n        \\r\\n        if (bmonContract.transferFrom(msg.sender, _owner, boosterPrice) == true) {\\r\\n            \\r\\n            // We don\\u0027t use loop here because EVM hates loops and randomly throws error - we just repeat code 3 times\\r\\n            \\r\\n            tokenCount += 1; // We don\\u0027t want any valid tokenId to be zero\\r\\n            uint256 tokenId = tokenCount;\\r\\n            balances[msg.sender] += 1;\\r\\n            owners[tokenId] = msg.sender;\\r\\n                \\r\\n            // Set random stats for the new token\\r\\n            BinamonToken memory token;\\r\\n            uint256 class = randomClass(1);\\r\\n            token._type = randomTypeOfClass(class, 2);\\r\\n            token._attack = randomAttack(3);\\r\\n            token._hornpower = randomHornpower(4);\\r\\n            token._element = elements[randomElement(5)];\\r\\n    \\r\\n            tokens[tokenId] = token;\\r\\n            emit Transfer(address(0), msg.sender, tokenId);\\r\\n            \\r\\n            tokenCount += 1; // We don\\u0027t want any valid tokenId to be zero\\r\\n            uint256 tokenId2 = tokenCount;\\r\\n            balances[msg.sender] += 1;\\r\\n            owners[tokenId2] = msg.sender;\\r\\n                \\r\\n            // Set random stats for the new token\\r\\n            BinamonToken memory token2;\\r\\n            uint256 class2 = randomClass(6);\\r\\n            token2._type = randomTypeOfClass(class2, 7);\\r\\n            token2._attack = randomAttack(8);\\r\\n            token2._hornpower = randomHornpower(9);\\r\\n            token2._element = elements[randomElement(10)];\\r\\n    \\r\\n            tokens[tokenId2] = token2;\\r\\n            emit Transfer(address(0), msg.sender, tokenId2);\\r\\n            \\r\\n            tokenCount += 1; // We don\\u0027t want any valid tokenId to be zero\\r\\n            uint256 tokenId3 = tokenCount;\\r\\n            balances[msg.sender] += 1;\\r\\n            owners[tokenId3] = msg.sender;\\r\\n                \\r\\n            // Set random stats for the new token\\r\\n            BinamonToken memory token3;\\r\\n            uint256 class3 = randomClass(11);\\r\\n            token3._type = randomTypeOfClass(class3, 12);\\r\\n            token3._attack = randomAttack(13);\\r\\n            token3._hornpower = randomHornpower(14);\\r\\n            token3._element = elements[randomElement(15)];\\r\\n    \\r\\n            tokens[tokenId3] = token3;\\r\\n            emit Transfer(address(0), msg.sender, tokenId3);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // Mints an NFT of custom characteristics\\r\\n    function mint(uint256 type_, uint256 attack, uint256 hornpower, string memory element) public isTrusted {\\r\\n        require(type_ \\u003e 0 \\u0026\\u0026 type_ \\u003c= typeCount, \\\"Trying to mint nonexistent type of token\\\");\\r\\n        \\r\\n        tokenCount += 1; // We don\\u0027t want any valid tokenId to be zero\\r\\n        uint256 tokenId = tokenCount;\\r\\n        balances[msg.sender] += 1;\\r\\n        owners[tokenId] = msg.sender;\\r\\n            \\r\\n        BinamonToken memory token;\\r\\n        token._type = type_;\\r\\n        token._attack = attack;\\r\\n        token._hornpower = hornpower;\\r\\n        token._element = element;\\r\\n            \\r\\n        tokens[tokenId] = token;\\r\\n        emit Transfer(address(0), msg.sender, tokenId);\\r\\n    }\\r\\n    \\r\\n    // ERC165 Interface discovery\\r\\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\\r\\n        return interfaceId == type(IERC721).interfaceId\\r\\n            || interfaceId == type(IERC721Metadata).interfaceId\\r\\n            || interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n    \\r\\n}\\r\\n\\r\\n\"},\"BMON.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\r\\n\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\ninterface IERC20 {\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n    address private _previousOwner;\\r\\n    uint256 private _lockTime;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    \\r\\n    constructor () {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract BMON is IERC20, Ownable {\\r\\n\\r\\n    string private constant _name = \\\"Binamon\\\";\\r\\n    string private constant _symbol = \\\"BMON\\\";\\r\\n    uint8 private constant _decimals = 18;  \\r\\n    uint256 private _totalSupply = 300 * 10**6 * 10**18;\\r\\n    \\r\\n    address public seedAndPresale;\\r\\n\\r\\n    mapping(address =\\u003e uint256) private balances;\\r\\n    mapping(address =\\u003e mapping (address =\\u003e uint256)) private allowed;\\r\\n    mapping(address =\\u003e address) private boosterBuyingAllowed;\\r\\n    \\r\\n    // listing restrictions\\r\\n    uint256 private restrictionLiftTime;\\r\\n    uint256 private maxRestrictionAmount = 300 * 10**6 * 10**18;\\r\\n    mapping (address =\\u003e bool) private isWhitelisted;\\r\\n    mapping (address =\\u003e uint256) private lastTx;\\r\\n    // end restrictions\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    enum State {\\r\\n        Locked,\\r\\n        Restricted, // Bot protection for liquidity pool\\r\\n        Unlocked\\r\\n    }\\r\\n    State public state;\\r\\n    \\r\\n    constructor() {  \\r\\n        state = State.Locked;\\r\\n        balances[msg.sender] = _totalSupply;\\r\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\r\\n    }  \\r\\n    \\r\\n    function name() public pure returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public pure returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n    \\r\\n    function totalSupply() public override view returns (uint256) {\\r\\n\\t    return _totalSupply;\\r\\n    }\\r\\n    \\r\\n    function balanceOf(address tokenOwner) public override view returns (uint256) {\\r\\n        return balances[tokenOwner];\\r\\n    }\\r\\n\\r\\n    function transfer(address receiver, uint256 numTokens) public override launchRestrict(msg.sender, receiver, numTokens) returns (bool) {\\r\\n        require(numTokens \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        require(numTokens \\u003c= balances[msg.sender]);\\r\\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\\r\\n        balances[receiver] = balances[receiver].add(numTokens);\\r\\n        emit Transfer(msg.sender, receiver, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\\r\\n        allowed[msg.sender][delegate] = numTokens;\\r\\n        emit Approval(msg.sender, delegate, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address delegate) public override view returns (uint256) {\\r\\n        return allowed[owner][delegate];\\r\\n    }\\r\\n\\r\\n    function transferFrom(address owner, address receiver, uint256 numTokens) public override launchRestrict(owner, receiver, numTokens) returns (bool) {\\r\\n        require(numTokens \\u003c= balances[owner]);    \\r\\n        require(boosterBuyingAllowed[owner] == msg.sender || numTokens \\u003c= allowed[owner][msg.sender]);\\r\\n    \\r\\n        balances[owner] = balances[owner].sub(numTokens);\\r\\n        if (boosterBuyingAllowed[owner] != msg.sender) {\\r\\n            allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\\r\\n            balances[receiver] = balances[receiver].add(numTokens);\\r\\n            emit Transfer(owner, receiver, numTokens);\\r\\n        } else {\\r\\n            _totalSupply = _totalSupply.sub(numTokens);\\r\\n            emit Transfer(owner, address(0), numTokens);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function boosterBuyingAllowance(address owner) public view returns (bool) {\\r\\n        return boosterBuyingAllowance(owner, msg.sender);\\r\\n    }\\r\\n    \\r\\n    function boosterBuyingAllowance(address owner, address delegate) public view returns (bool) {\\r\\n        if (boosterBuyingAllowed[owner] == delegate) return true;\\r\\n        else return false;\\r\\n    }\\r\\n    \\r\\n    function allowBuyingBoosters(address bmonc) public returns (bool) {\\r\\n        boosterBuyingAllowed[msg.sender] = bmonc;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function setSeedAndPresale(address seedAndPresale_) public onlyOwner() {\\r\\n        seedAndPresale = seedAndPresale_;\\r\\n    }\\r\\n    \\r\\n    modifier ownerOrPresale {\\r\\n        require(owner() == msg.sender || seedAndPresale == msg.sender, \\\"Cannot burn tokens\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    function burn(uint256 numTokens) public ownerOrPresale() returns(bool) {\\r\\n        require(numTokens \\u003c= balances[msg.sender]);\\r\\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\\r\\n        _totalSupply = _totalSupply.sub(numTokens);\\r\\n        emit Transfer(msg.sender, address(0), numTokens);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // Security from bots\\r\\n\\r\\n    // enable/disable works only once, token never returns to Locked\\r\\n    function setBotProtection(bool enable) public onlyOwner() {\\r\\n        if (enable \\u0026\\u0026 state == State.Locked) state = State.Restricted;\\r\\n        if (!enable) state = State.Unlocked;\\r\\n    }\\r\\n\\r\\n    function setRestrictionAmount(uint256 amount) public onlyOwner() {\\r\\n        maxRestrictionAmount = amount;\\r\\n    }\\r\\n\\r\\n    function whitelistAccount(address account) public onlyOwner() {\\r\\n        isWhitelisted[account] = true;\\r\\n    }\\r\\n\\r\\n    modifier launchRestrict(address sender, address recipient, uint256 amount) {\\r\\n        if (state == State.Locked) {\\r\\n            require(sender == owner() || sender == seedAndPresale || isWhitelisted[sender], \\\"Tokens are locked\\\");\\r\\n        }\\r\\n        if (state == State.Restricted) {\\r\\n            require(amount \\u003c= maxRestrictionAmount, \\\"BMON: amount greater than max limit in restricted mode\\\");\\r\\n            if (!isWhitelisted[sender] \\u0026\\u0026 !isWhitelisted[recipient]) {\\r\\n                require(lastTx[sender].add(60) \\u003c= block.timestamp \\u0026\\u0026 lastTx[recipient].add(60) \\u003c= block.timestamp, \\\"BMON: only one tx/min in restricted mode\\\");\\r\\n                lastTx[sender] = block.timestamp;\\r\\n                lastTx[recipient] = block.timestamp;\\r\\n            } else if (!isWhitelisted[recipient]) {\\r\\n                require(lastTx[recipient].add(60) \\u003c= block.timestamp, \\\"BMON: only one tx/min in restricted mode\\\");\\r\\n                lastTx[recipient] = block.timestamp;\\r\\n            } else if (!isWhitelisted[sender]) {\\r\\n                require(lastTx[sender].add(60) \\u003c= block.timestamp, \\\"BMON: only one tx/min in restricted mode\\\");\\r\\n                lastTx[sender] = block.timestamp;\\r\\n            }\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Bot security end\\r\\n}\\r\\n\\r\\ncontract BMONSeedAndPreSale is Ownable {\\r\\n\\r\\n    uint256 constant public SEED_MAX_BUY = 5 ether;\\r\\n    uint256 constant public SEED_MIN_BUY = 1 ether;\\r\\n    uint256 constant public SEED_PRICE = 0.0000283 ether;\\r\\n    uint256 constant public SEED_TOKENS = 53 * 10**6 * 10**18;\\r\\n    \\r\\n    uint256 constant public PRESALE_MAX_BUY = 5 ether;\\r\\n    uint256 constant public PRESALE_MIN_BUY = 1 ether;\\r\\n    uint256 constant public PRESALE_PRICE = 0.00003846 ether;\\r\\n    uint256 constant public PRESALE_TOKENS = 65 * 10**6 * 10**18;\\r\\n    \\r\\n    uint256 constant public SEED_DURATION = 24 hours;\\r\\n    uint256 constant public DELAY_BEFORE_PRESALE = 21 hours;\\r\\n    uint256 constant public PRESALE_DURATION = 24 hours;\\r\\n\\r\\n    BMON public token;\\r\\n    address public benificiary;\\r\\n    uint256 public startTime;\\r\\n    \\r\\n    // Sales\\r\\n    mapping (address =\\u003e uint256) public salesAtSeed;\\r\\n    mapping (address =\\u003e uint256) public salesAtPresale;\\r\\n    uint256 public totalSeedTokensSold;\\r\\n    uint256 public totalPresaleTokensSold;\\r\\n    uint256 public totalSeedBnbCollected;\\r\\n    uint256 public totalPresaleBnbCollected;\\r\\n\\r\\n    enum State {\\r\\n        Pending,\\r\\n        Seed,\\r\\n        Delay,\\r\\n        Presale,\\r\\n        Completed\\r\\n    }\\r\\n    \\r\\n    constructor(address token_, address beneficiary_) {\\r\\n        token = BMON(token_);\\r\\n        benificiary = beneficiary_;\\r\\n    }\\r\\n    \\r\\n    function setStartTime(uint256 time) public onlyOwner() {\\r\\n        startTime = time;\\r\\n    }\\r\\n    \\r\\n    receive() external payable {\\r\\n        buyTokens();\\r\\n    }\\r\\n    \\r\\n    function getState() public view returns(State) {\\r\\n        if (block.timestamp \\u003c startTime) return State.Pending;\\r\\n        else if (block.timestamp \\u003e= startTime \\u0026\\u0026 block.timestamp \\u003c startTime + SEED_DURATION) {\\r\\n            if (totalSeedTokensSold * 100 \\u003e= 99 * SEED_TOKENS) return State.Delay;\\r\\n            else return State.Seed;\\r\\n        }\\r\\n        else if (block.timestamp \\u003e= startTime + SEED_DURATION \\u0026\\u0026 block.timestamp \\u003c startTime + SEED_DURATION + DELAY_BEFORE_PRESALE) return State.Delay;\\r\\n        else if (block.timestamp \\u003e= startTime + SEED_DURATION + DELAY_BEFORE_PRESALE \\u0026\\u0026\\r\\n                block.timestamp \\u003c startTime + SEED_DURATION + DELAY_BEFORE_PRESALE + PRESALE_DURATION) {\\r\\n            if (totalPresaleTokensSold * 100 \\u003e= 99 * PRESALE_TOKENS) return State.Completed;\\r\\n            else return State.Presale;\\r\\n        } \\r\\n        else if (block.timestamp \\u003e= startTime + SEED_DURATION + DELAY_BEFORE_PRESALE + PRESALE_DURATION) return State.Completed;\\r\\n        else return State.Completed;\\r\\n    }\\r\\n    \\r\\n    function getSalesAtSeed(address account) public view returns(uint256) {\\r\\n        return salesAtSeed[account];\\r\\n    }\\r\\n    \\r\\n    function getSalesAtPresale(address account) public view returns(uint256) {\\r\\n        return salesAtPresale[account];\\r\\n    }\\r\\n\\r\\n    function buyTokens() public payable {\\r\\n        State state = getState();\\r\\n        require(state == State.Seed || state == State.Presale, \\\"Presale is not active\\\");\\r\\n        \\r\\n        uint256 tokenAmount;\\r\\n        if (state == State.Seed) {\\r\\n            require(msg.value \\u003e= SEED_MIN_BUY \\u0026\\u0026 msg.value \\u003c= SEED_MAX_BUY, \\\"Incorrect transaction amount\\\");\\r\\n            tokenAmount = (msg.value / SEED_PRICE) * 10**18;\\r\\n            totalSeedTokensSold += tokenAmount;\\r\\n            totalSeedBnbCollected += msg.value;\\r\\n            salesAtSeed[msg.sender] += msg.value;\\r\\n            require(salesAtSeed[msg.sender] \\u003c= SEED_MAX_BUY, \\\"Buy limit exceeded for account\\\");\\r\\n            \\r\\n            token.transfer(msg.sender, tokenAmount);\\r\\n            payable(benificiary).transfer(msg.value);\\r\\n        }\\r\\n        if (state == State.Presale) {\\r\\n            require(msg.value \\u003e= PRESALE_MIN_BUY \\u0026\\u0026 msg.value \\u003c= PRESALE_MAX_BUY, \\\"Incorrect transaction amount\\\");\\r\\n            tokenAmount = (msg.value / PRESALE_PRICE) * 10**18;\\r\\n            totalPresaleTokensSold += tokenAmount;\\r\\n            totalPresaleBnbCollected += msg.value;\\r\\n            salesAtPresale[msg.sender] += msg.value;\\r\\n            require(salesAtPresale[msg.sender] \\u003c= PRESALE_MAX_BUY, \\\"Buy limit exceeded for account\\\");\\r\\n            \\r\\n            token.transfer(msg.sender, tokenAmount);\\r\\n            payable(benificiary).transfer(msg.value);\\r\\n        }\\r\\n\\r\\n        require(totalSeedTokensSold \\u003c= SEED_TOKENS \\u0026\\u0026 totalPresaleTokensSold \\u003c= PRESALE_TOKENS, \\\"Out of tokens\\\");\\r\\n    }\\r\\n    \\r\\n    function closePreSale() public onlyOwner() {\\r\\n        State state = getState();\\r\\n        require(state == State.Completed, \\\"Presale is not yet finished\\\");\\r\\n        \\r\\n        token.burn(token.balanceOf(address(this)));\\r\\n        if (address(this).balance \\u003e 0) payable(benificiary).transfer(address(this).balance);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath { \\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n      assert(b \\u003c= a);\\r\\n      return a - b;\\r\\n    }\\r\\n    \\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n      uint256 c = a + b;\\r\\n      assert(c \\u003e= a);\\r\\n      return c;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"class\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"hash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"extra\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"name\":\"addNewType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addTrusted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBooster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeBMONAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBMONAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBoosterPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"type_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"attack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hornpower\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"element\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeTrusted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setBoosterPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_attack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hornpower\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_element\",\"type\":\"string\"}],\"internalType\":\"struct BinamonToken\",\"name\":\"token\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_class\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_hash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_extra\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_info\",\"type\":\"string\"}],\"internalType\":\"struct BinamonType\",\"name\":\"type_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTypes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"typeByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_class\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_hash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_extra\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_info\",\"type\":\"string\"}],\"internalType\":\"struct BinamonType\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Binamon", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7270e6e1272fb3794f91c60d71ec8560b4e8957d9ef14247278094fd6266ac52"}