{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2021-05-18\r\n*/\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/FixedPointMath.sol\r\n\r\n//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.6.12;\r\n\r\nlibrary FixedPointMath {\r\n  uint256 public constant DECIMALS = 18;\r\n  uint256 public constant SCALAR = 10**DECIMALS;\r\n\r\n  struct uq192x64 {\r\n    uint256 x;\r\n  }\r\n\r\n  function fromU256(uint256 value) internal pure returns (uq192x64 memory) {\r\n    uint256 x;\r\n    require(value == 0 || (x = value * SCALAR) / SCALAR == value);\r\n    return uq192x64(x);\r\n  }\r\n\r\n  function maximumValue() internal pure returns (uq192x64 memory) {\r\n    return uq192x64(uint256(-1));\r\n  }\r\n\r\n  function add(uq192x64 memory self, uq192x64 memory value) internal pure returns (uq192x64 memory) {\r\n    uint256 x;\r\n    require((x = self.x + value.x) >= self.x);\r\n    return uq192x64(x);\r\n  }\r\n\r\n  function add(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\r\n    return add(self, fromU256(value));\r\n  }\r\n\r\n  function sub(uq192x64 memory self, uq192x64 memory value) internal pure returns (uq192x64 memory) {\r\n    uint256 x;\r\n    require((x = self.x - value.x) <= self.x);\r\n    return uq192x64(x);\r\n  }\r\n\r\n  function sub(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\r\n    return sub(self, fromU256(value));\r\n  }\r\n\r\n  function mul(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\r\n    uint256 x;\r\n    require(value == 0 || (x = self.x * value) / value == self.x);\r\n    return uq192x64(x);\r\n  }\r\n\r\n  function div(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\r\n    require(value != 0);\r\n    return uq192x64(self.x / value);\r\n  }\r\n\r\n  function cmp(uq192x64 memory self, uq192x64 memory value) internal pure returns (int256) {\r\n    if (self.x < value.x) {\r\n      return -1;\r\n    }\r\n\r\n    if (self.x > value.x) {\r\n      return 1;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function decode(uq192x64 memory self) internal pure returns (uint256) {\r\n    return self.x / SCALAR;\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/IDetailedERC20.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\ninterface IDetailedERC20 is IERC20 {\r\n  function name() external returns (string memory);\r\n  function symbol() external returns (string memory);\r\n  function decimals() external returns (uint8);\r\n}\r\n\r\n// File: contracts/libraries/scientist/CDP.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title CDP\r\n///\r\n/// @dev A library which provides the CDP data struct and associated functions.\r\nlibrary CDP {\r\n  using CDP for Data;\r\n  using FixedPointMath for FixedPointMath.uq192x64;\r\n  using SafeERC20 for IDetailedERC20;\r\n  using SafeMath for uint256;\r\n\r\n  struct Context {\r\n    FixedPointMath.uq192x64 collateralizationLimit;\r\n    FixedPointMath.uq192x64 accumulatedYieldWeight;\r\n  }\r\n\r\n  struct Data {\r\n    uint256 totalDeposited;\r\n    uint256 totalDebt;\r\n    uint256 totalCredit;\r\n    uint256 lastDeposit;\r\n    FixedPointMath.uq192x64 lastAccumulatedYieldWeight;\r\n  }\r\n\r\n  function update(Data storage _self, Context storage _ctx) internal {\r\n    uint256 _earnedYield = _self.getEarnedYield(_ctx);\r\n    if (_earnedYield > _self.totalDebt) {\r\n      uint256 _currentTotalDebt = _self.totalDebt;\r\n      _self.totalDebt = 0;\r\n      _self.totalCredit = _earnedYield.sub(_currentTotalDebt);\r\n    } else {\r\n      _self.totalDebt = _self.totalDebt.sub(_earnedYield);\r\n    }\r\n    _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\r\n  }\r\n\r\n  /// @dev Assures that the CDP is healthy.\r\n  ///\r\n  /// This function will revert if the CDP is unhealthy.\r\n  function checkHealth(Data storage _self, Context storage _ctx, string memory _msg) internal view {\r\n    require(_self.isHealthy(_ctx), _msg);\r\n  }\r\n\r\n  /// @dev Gets if the CDP is considered healthy.\r\n  ///\r\n  /// A CDP is healthy if its collateralization ratio is greater than the global collateralization limit.\r\n  ///\r\n  /// @return if the CDP is healthy.\r\n  function isHealthy(Data storage _self, Context storage _ctx) internal view returns (bool) {\r\n    return _ctx.collateralizationLimit.cmp(_self.getCollateralizationRatio(_ctx)) <= 0;\r\n  }\r\n\r\n  function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {\r\n    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\r\n    if (_unclaimedYield == 0) {\r\n      return _self.totalDebt;\r\n    }\r\n\r\n    uint256 _currentTotalDebt = _self.totalDebt;\r\n    if (_unclaimedYield >= _currentTotalDebt) {\r\n      return 0;\r\n    }\r\n\r\n    return _currentTotalDebt - _unclaimedYield;\r\n  }\r\n\r\n  function getUpdatedTotalCredit(Data storage _self, Context storage _ctx) internal view returns (uint256) {\r\n    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\r\n    if (_unclaimedYield == 0) {\r\n      return _self.totalCredit;\r\n    }\r\n\r\n    uint256 _currentTotalDebt = _self.totalDebt;\r\n    if (_unclaimedYield <= _currentTotalDebt) {\r\n      return 0;\r\n    }\r\n\r\n    return _self.totalCredit + (_unclaimedYield - _currentTotalDebt);\r\n  }\r\n\r\n  /// @dev Gets the amount of yield that a CDP has earned since the last time it was updated.\r\n  ///\r\n  /// @param _self the CDP to query.\r\n  /// @param _ctx  the CDP context.\r\n  ///\r\n  /// @return the amount of earned yield.\r\n  function getEarnedYield(Data storage _self, Context storage _ctx) internal view returns (uint256) {\r\n    FixedPointMath.uq192x64 memory _currentAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\r\n    FixedPointMath.uq192x64 memory _lastAccumulatedYieldWeight = _self.lastAccumulatedYieldWeight;\r\n\r\n    if (_currentAccumulatedYieldWeight.cmp(_lastAccumulatedYieldWeight) == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return _currentAccumulatedYieldWeight\r\n      .sub(_lastAccumulatedYieldWeight)\r\n      .mul(_self.totalDeposited)\r\n      .decode();\r\n  }\r\n\r\n  /// @dev Gets a CDPs collateralization ratio.\r\n  ///\r\n  /// The collateralization ratio is defined as the ratio of collateral to debt. If the CDP has zero debt then this\r\n  /// will return the maximum value of a fixed point integer.\r\n  ///\r\n  /// This function will use the updated total debt so an update before calling this function is not required.\r\n  ///\r\n  /// @param _self the CDP to query.\r\n  ///\r\n  /// @return a fixed point integer representing the collateralization ratio.\r\n  function getCollateralizationRatio(Data storage _self, Context storage _ctx)\r\n    internal view\r\n    returns (FixedPointMath.uq192x64 memory)\r\n  {\r\n    uint256 _totalDebt = _self.getUpdatedTotalDebt(_ctx);\r\n    if (_totalDebt == 0) {\r\n      return FixedPointMath.maximumValue();\r\n    }\r\n    return FixedPointMath.fromU256(_self.totalDeposited).div(_totalDebt);\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/ITransmuter.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ITransmuter  {\r\n  function distribute (address origin, uint256 amount) external;\r\n}\r\n\r\n// File: contracts/interfaces/IMintableERC20.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\ninterface IMintableERC20 is IDetailedERC20{\r\n  function mint(address _recipient, uint256 _amount) external;\r\n  function burnFrom(address account, uint256 amount) external;\r\n  function lowerHasMinted(uint256 amount)external;\r\n}\r\n\r\n// File: contracts/interfaces/IChainlink.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IChainlink {\r\n  function latestAnswer() external view returns (int256);\r\n}\r\n\r\n// File: contracts/interfaces/IVaultAdapter.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\n/// Interface for all Vault Adapter implementations.\r\ninterface IVaultAdapter {\r\n\r\n  /// @dev Gets the token that the adapter accepts.\r\n  function token() external view returns (IDetailedERC20);\r\n\r\n  /// @dev The total value of the assets deposited into the vault.\r\n  function totalValue() external view returns (uint256);\r\n\r\n  /// @dev Deposits funds into the vault.\r\n  ///\r\n  /// @param _amount  the amount of funds to deposit.\r\n  function deposit(uint256 _amount) external;\r\n\r\n  /// @dev Attempts to withdraw funds from the wrapped vault.\r\n  ///\r\n  /// The amount withdrawn to the recipient may be less than the amount requested.\r\n  ///\r\n  /// @param _recipient the recipient of the funds.\r\n  /// @param _amount    the amount of funds to withdraw.\r\n  function withdraw(address _recipient, uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/libraries/scientist/Vault.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n//\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Pool\r\n///\r\n/// @dev A library which provides the Vault data struct and associated functions.\r\nlibrary Vault {\r\n  using Vault for Data;\r\n  using Vault for List;\r\n  using SafeERC20 for IDetailedERC20;\r\n  using SafeMath for uint256;\r\n\r\n  struct Data {\r\n    IVaultAdapter adapter;\r\n    uint256 totalDeposited;\r\n  }\r\n\r\n  struct List {\r\n    Data[] elements;\r\n  }\r\n\r\n  /// @dev Gets the total amount of assets deposited in the vault.\r\n  ///\r\n  /// @return the total assets.\r\n  function totalValue(Data storage _self) internal view returns (uint256) {\r\n    return _self.adapter.totalValue();\r\n  }\r\n\r\n  /// @dev Gets the token that the vault accepts.\r\n  ///\r\n  /// @return the accepted token.\r\n  function token(Data storage _self) internal view returns (IDetailedERC20) {\r\n    return IDetailedERC20(_self.adapter.token());\r\n  }\r\n\r\n  /// @dev Deposits funds from the caller into the vault.\r\n  ///\r\n  /// @param _amount the amount of funds to deposit.\r\n  function deposit(Data storage _self, uint256 _amount) internal returns (uint256) {\r\n    // Push the token that the vault accepts onto the stack to save gas.\r\n    IDetailedERC20 _token = _self.token();\r\n\r\n    _token.safeTransfer(address(_self.adapter), _amount);\r\n    _self.adapter.deposit(_amount);\r\n    _self.totalDeposited = _self.totalDeposited.add(_amount);\r\n\r\n    return _amount;\r\n  }\r\n\r\n  /// @dev Deposits the entire token balance of the caller into the vault.\r\n  function depositAll(Data storage _self) internal returns (uint256) {\r\n    IDetailedERC20 _token = _self.token();\r\n    return _self.deposit(_token.balanceOf(address(this)));\r\n  }\r\n\r\n  /// @dev Withdraw deposited funds from the vault.\r\n  ///\r\n  /// @param _recipient the account to withdraw the tokens to.\r\n  /// @param _amount    the amount of tokens to withdraw.\r\n  function withdraw(Data storage _self, address _recipient, uint256 _amount) internal returns (uint256, uint256) {\r\n    (uint256 _withdrawnAmount, uint256 _decreasedValue) = _self.directWithdraw(_recipient, _amount);\r\n    _self.totalDeposited = _self.totalDeposited.sub(_decreasedValue);\r\n    return (_withdrawnAmount, _decreasedValue);\r\n  }\r\n\r\n  /// @dev Directly withdraw deposited funds from the vault.\r\n  ///\r\n  /// @param _recipient the account to withdraw the tokens to.\r\n  /// @param _amount    the amount of tokens to withdraw.\r\n  function directWithdraw(Data storage _self, address _recipient, uint256 _amount) internal returns (uint256, uint256) {\r\n    IDetailedERC20 _token = _self.token();\r\n\r\n    uint256 _startingBalance = _token.balanceOf(_recipient);\r\n    uint256 _startingTotalValue = _self.totalValue();\r\n\r\n    _self.adapter.withdraw(_recipient, _amount);\r\n\r\n    uint256 _endingBalance = _token.balanceOf(_recipient);\r\n    uint256 _withdrawnAmount = _endingBalance.sub(_startingBalance);\r\n\r\n    uint256 _endingTotalValue = _self.totalValue();\r\n    uint256 _decreasedValue = _startingTotalValue.sub(_endingTotalValue);\r\n\r\n    return (_withdrawnAmount, _decreasedValue);\r\n  }\r\n\r\n  /// @dev Withdraw all the deposited funds from the vault.\r\n  ///\r\n  /// @param _recipient the account to withdraw the tokens to.\r\n  function withdrawAll(Data storage _self, address _recipient) internal returns (uint256, uint256) {\r\n    return _self.withdraw(_recipient, _self.totalDeposited);\r\n  }\r\n\r\n  /// @dev Harvests yield from the vault.\r\n  ///\r\n  /// @param _recipient the account to withdraw the harvested yield to.\r\n  function harvest(Data storage _self, address _recipient) internal returns (uint256, uint256) {\r\n    if (_self.totalValue() <= _self.totalDeposited) {\r\n      return (0, 0);\r\n    }\r\n    uint256 _withdrawAmount = _self.totalValue().sub(_self.totalDeposited);\r\n    return _self.directWithdraw(_recipient, _withdrawAmount);\r\n  }\r\n\r\n  /// @dev Adds a element to the list.\r\n  ///\r\n  /// @param _element the element to add.\r\n  function push(List storage _self, Data memory _element) internal {\r\n    _self.elements.push(_element);\r\n  }\r\n\r\n  /// @dev Gets a element from the list.\r\n  ///\r\n  /// @param _index the index in the list.\r\n  ///\r\n  /// @return the element at the specified index.\r\n  function get(List storage _self, uint256 _index) internal view returns (Data storage) {\r\n    return _self.elements[_index];\r\n  }\r\n\r\n  /// @dev Gets the last element in the list.\r\n  ///\r\n  /// This function will revert if there are no elements in the list.\r\n  ///\r\n  /// @return the last element in the list.\r\n  function last(List storage _self) internal view returns (Data storage) {\r\n    return _self.elements[_self.lastIndex()];\r\n  }\r\n\r\n  /// @dev Gets the index of the last element in the list.\r\n  ///\r\n  /// This function will revert if there are no elements in the list.\r\n  ///\r\n  /// @return the index of the last element.\r\n  function lastIndex(List storage _self) internal view returns (uint256) {\r\n    uint256 _length = _self.length();\r\n    return _length.sub(1, \"Vault.List: empty\");\r\n  }\r\n\r\n  /// @dev Gets the number of elements in the list.\r\n  ///\r\n  /// @return the number of elements.\r\n  function length(List storage _self) internal view returns (uint256) {\r\n    return _self.elements.length;\r\n  }\r\n}\r\n\r\n// File: contracts/Scientist.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n//import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ERC20,removing ERC20 from the scientist\r\ncontract Scientist is  ReentrancyGuard {\r\n  using CDP for CDP.Data;\r\n  using FixedPointMath for FixedPointMath.uq192x64;\r\n  using Vault for Vault.Data;\r\n  using Vault for Vault.List;\r\n  using SafeERC20 for IMintableERC20;\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  address public constant ZERO_ADDRESS = address(0);\r\n\r\n  /// @dev Resolution for all fixed point numeric parameters which represent percents. The resolution allows for a\r\n  /// granularity of 0.01% increments.\r\n  uint256 public constant PERCENT_RESOLUTION = 10000;\r\n\r\n  /// @dev The minimum value that the collateralization limit can be set to by the governance. This is a safety rail\r\n  /// to prevent the collateralization from being set to a value which breaks the system.\r\n  ///\r\n  /// This value is equal to 100%.\r\n  ///\r\n  /// IMPORTANT: This constant is a raw FixedPointMath.uq192x64 value and assumes a resolution of 64 bits. If the\r\n  ///            resolution for the FixedPointMath library changes this constant must change as well.\r\n  uint256 public constant MINIMUM_COLLATERALIZATION_LIMIT = 1000000000000000000;\r\n\r\n  /// @dev The maximum value that the collateralization limit can be set to by the governance. This is a safety rail\r\n  /// to prevent the collateralization from being set to a value which breaks the system.\r\n  ///\r\n  /// This value is equal to 400%.\r\n  ///\r\n  /// IMPORTANT: This constant is a raw FixedPointMath.uq192x64 value and assumes a resolution of 64 bits. If the\r\n  ///            resolution for the FixedPointMath library changes this constant must change as well.\r\n  uint256 public constant MAXIMUM_COLLATERALIZATION_LIMIT = 4000000000000000000;\r\n\r\n  event GovernanceUpdated(\r\n    address governance\r\n  );\r\n\r\n  event PendingGovernanceUpdated(\r\n    address pendingGovernance\r\n  );\r\n\r\n  event SentinelUpdated(\r\n    address sentinel\r\n  );\r\n\r\n  event TransmuterUpdated(\r\n    address transmuter\r\n  );\r\n\r\n  event RewardsUpdated(\r\n    address treasury\r\n  );\r\n\r\n  event HarvestFeeUpdated(\r\n    uint256 fee\r\n  );\r\n\r\n  event CollateralizationLimitUpdated(\r\n    uint256 limit\r\n  );\r\n\r\n  event EmergencyExitUpdated(\r\n    bool status\r\n  );\r\n\r\n  event ActiveVaultUpdated(\r\n    IVaultAdapter indexed adapter\r\n  );\r\n\r\n  event FundsHarvested(\r\n    uint256 withdrawnAmount,\r\n    uint256 decreasedValue\r\n  );\r\n\r\n  event FundsRecalled(\r\n    uint256 indexed vaultId,\r\n    uint256 withdrawnAmount,\r\n    uint256 decreasedValue\r\n  );\r\n\r\n  event FundsFlushed(\r\n    uint256 amount\r\n  );\r\n\r\n  event TokensDeposited(\r\n    address indexed account,\r\n    uint256 amount\r\n  );\r\n\r\n  event TokensWithdrawn(\r\n    address indexed account,\r\n    uint256 requestedAmount,\r\n    uint256 withdrawnAmount,\r\n    uint256 decreasedValue\r\n  );\r\n\r\n  event TokensRepaid(\r\n    address indexed account,\r\n    uint256 parentAmount,\r\n    uint256 childAmount\r\n  );\r\n\r\n  event TokensLiquidated(\r\n    address indexed account,\r\n    uint256 requestedAmount,\r\n    uint256 withdrawnAmount,\r\n    uint256 decreasedValue\r\n  );\r\n\r\n  /// @dev The token that this contract is using as the parent asset.\r\n  IMintableERC20 public token;\r\n\r\n   /// @dev The token that this contract is using as the child asset.\r\n  IMintableERC20 public xtoken;\r\n\r\n  /// @dev The address of the account which currently has administrative capabilities over this contract.\r\n  address public governance;\r\n\r\n  /// @dev The address of the pending governance.\r\n  address public pendingGovernance;\r\n\r\n  /// @dev The address of the account which can initiate an emergency withdraw of funds in a vault.\r\n  address public sentinel;\r\n\r\n  /// @dev The address of the contract which will transmute synthetic tokens back into native tokens.\r\n  address public transmuter;\r\n\r\n  /// @dev The address of the contract which will receive fees.\r\n  address public rewards;\r\n\r\n  /// @dev The percent of each profitable harvest that will go to the rewards contract.\r\n  uint256 public harvestFee;\r\n\r\n  /// @dev The total amount the native token deposited into the system that is owned by external users.\r\n  uint256 public totalDeposited;\r\n\r\n  /// @dev when movemetns are bigger than this number flush is activated.\r\n  uint256 public flushActivator;\r\n\r\n  /// @dev A flag indicating if the contract has been initialized yet.\r\n  bool public initialized;\r\n\r\n  /// @dev A flag indicating if deposits and flushes should be halted and if all parties should be able to recall\r\n  /// from the active vault.\r\n  bool public emergencyExit;\r\n\r\n  /// @dev The context shared between the CDPs.\r\n  CDP.Context private _ctx;\r\n\r\n  /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either\r\n  /// create a new address or set up a proxy contract that interfaces with this contract.\r\n  mapping(address => CDP.Data) private _cdps;\r\n\r\n  /// @dev A list of all of the vaults. The last element of the list is the vault that is currently being used for\r\n  /// deposits and withdraws. Vaults before the last element are considered inactive and are expected to be cleared.\r\n  Vault.List private _vaults;\r\n\r\n  /// @dev The address of the link oracle.\r\n  address public _linkGasOracle;\r\n\r\n  /// @dev The minimum returned amount needed to be on peg according to the oracle.\r\n  uint256 public pegMinimum;\r\n  \r\n  constructor(\r\n    IMintableERC20 _token,\r\n    IMintableERC20 _xtoken,\r\n    address _governance,\r\n    address _sentinel\r\n  )\r\n    public\r\n    /*ERC20(\r\n      string(abi.encodePacked(\"Scientific \", _token.name())),\r\n      string(abi.encodePacked(\"al\", _token.symbol()))\r\n    )*/\r\n  {\r\n    require(_governance != ZERO_ADDRESS, \"Scientist: governance address cannot be 0x0.\");\r\n    require(_sentinel != ZERO_ADDRESS, \"Scientist: sentinel address cannot be 0x0.\");\r\n\r\n    token = _token;\r\n    xtoken = _xtoken;\r\n    governance = _governance;\r\n    sentinel = _sentinel;\r\n    flushActivator = 100000 ether;// change for non 18 digit tokens\r\n\r\n    //_setupDecimals(_token.decimals());\r\n    uint256 COLL_LIMIT = MINIMUM_COLLATERALIZATION_LIMIT.mul(2);\r\n    _ctx.collateralizationLimit = FixedPointMath.uq192x64(COLL_LIMIT);\r\n    _ctx.accumulatedYieldWeight = FixedPointMath.uq192x64(0);\r\n  }\r\n\r\n  /// @dev Sets the pending governance.\r\n  ///\r\n  /// This function reverts if the new pending governance is the zero address or the caller is not the current\r\n  /// governance. This is to prevent the contract governance being set to the zero address which would deadlock\r\n  /// privileged contract functionality.\r\n  ///\r\n  /// @param _pendingGovernance the new pending governance.\r\n  function setPendingGovernance(address _pendingGovernance) external onlyGov {\r\n    require(_pendingGovernance != ZERO_ADDRESS, \"Scientist: governance address cannot be 0x0.\");\r\n\r\n    pendingGovernance = _pendingGovernance;\r\n\r\n    emit PendingGovernanceUpdated(_pendingGovernance);\r\n  }\r\n\r\n  /// @dev Accepts the role as governance.\r\n  ///\r\n  /// This function reverts if the caller is not the new pending governance.\r\n  function acceptGovernance() external  {\r\n    require(msg.sender == pendingGovernance,\"sender is not pendingGovernance\");\r\n    address _pendingGovernance = pendingGovernance;\r\n    governance = _pendingGovernance;\r\n\r\n    emit GovernanceUpdated(_pendingGovernance);\r\n  }\r\n\r\n  function setSentinel(address _sentinel) external onlyGov {\r\n\r\n    require(_sentinel != ZERO_ADDRESS, \"Scientist: sentinel address cannot be 0x0.\");\r\n\r\n    sentinel = _sentinel;\r\n\r\n    emit SentinelUpdated(_sentinel);\r\n  }\r\n\r\n  /// @dev Sets the transmuter.\r\n  ///\r\n  /// This function reverts if the new transmuter is the zero address or the caller is not the current governance.\r\n  ///\r\n  /// @param _transmuter the new transmuter.\r\n  function setTransmuter(address _transmuter) external onlyGov {\r\n\r\n    // Check that the transmuter address is not the zero address. Setting the transmuter to the zero address would break\r\n    // transfers to the address because of `safeTransfer` checks.\r\n    require(_transmuter != ZERO_ADDRESS, \"Scientist: transmuter address cannot be 0x0.\");\r\n\r\n    transmuter = _transmuter;\r\n\r\n    emit TransmuterUpdated(_transmuter);\r\n  }\r\n  /// @dev Sets the flushActivator.\r\n  ///\r\n  /// @param _flushActivator the new flushActivator.\r\n  function setFlushActivator(uint256 _flushActivator) external onlyGov {\r\n    flushActivator = _flushActivator;\r\n\r\n  }\r\n\r\n  /// @dev Sets the rewards contract.\r\n  ///\r\n  /// This function reverts if the new rewards contract is the zero address or the caller is not the current governance.\r\n  ///\r\n  /// @param _rewards the new rewards contract.\r\n  function setRewards(address _rewards) external onlyGov {\r\n\r\n    // Check that the rewards address is not the zero address. Setting the rewards to the zero address would break\r\n    // transfers to the address because of `safeTransfer` checks.\r\n    require(_rewards != ZERO_ADDRESS, \"Scientist: rewards address cannot be 0x0.\");\r\n\r\n    rewards = _rewards;\r\n\r\n    emit RewardsUpdated(_rewards);\r\n  }\r\n\r\n  /// @dev Sets the harvest fee.\r\n  ///\r\n  /// This function reverts if the caller is not the current governance.\r\n  ///\r\n  /// @param _harvestFee the new harvest fee.\r\n  function setHarvestFee(uint256 _harvestFee) external onlyGov {\r\n\r\n    // Check that the harvest fee is within the acceptable range. Setting the harvest fee greater than 100% could\r\n    // potentially break internal logic when calculating the harvest fee.\r\n    require(_harvestFee <= PERCENT_RESOLUTION, \"Scientist: harvest fee above maximum.\");\r\n\r\n    harvestFee = _harvestFee;\r\n\r\n    emit HarvestFeeUpdated(_harvestFee);\r\n  }\r\n\r\n  /// @dev Sets the collateralization limit.\r\n  ///\r\n  /// This function reverts if the caller is not the current governance or if the collateralization limit is outside\r\n  /// of the accepted bounds.\r\n  ///\r\n  /// @param _limit the new collateralization limit.\r\n  function setCollateralizationLimit(uint256 _limit) external onlyGov {\r\n\r\n    require(_limit >= MINIMUM_COLLATERALIZATION_LIMIT, \"Scientist: collateralization limit below minimum.\");\r\n    require(_limit <= MAXIMUM_COLLATERALIZATION_LIMIT, \"Scientist: collateralization limit above maximum.\");\r\n\r\n    _ctx.collateralizationLimit = FixedPointMath.uq192x64(_limit);\r\n\r\n    emit CollateralizationLimitUpdated(_limit);\r\n  }\r\n  /// @dev Set oracle.\r\n  function setOracleAddress(address Oracle, uint256 peg) external onlyGov {\r\n    _linkGasOracle = Oracle;\r\n    pegMinimum = peg;\r\n  }\r\n  /// @dev Sets if the contract should enter emergency exit mode.\r\n  ///\r\n  /// @param _emergencyExit if the contract should enter emergency exit mode.\r\n  function setEmergencyExit(bool _emergencyExit) external {\r\n    require(msg.sender == governance || msg.sender == sentinel, \"\");\r\n\r\n    emergencyExit = _emergencyExit;\r\n\r\n    emit EmergencyExitUpdated(_emergencyExit);\r\n  }\r\n\r\n  /// @dev Gets the collateralization limit.\r\n  ///\r\n  /// The collateralization limit is the minimum ratio of collateral to debt that is allowed by the system.\r\n  ///\r\n  /// @return the collateralization limit.\r\n  function collateralizationLimit() external view returns (FixedPointMath.uq192x64 memory) {\r\n    return _ctx.collateralizationLimit;\r\n  }\r\n\r\n  /// @dev Initializes the contract.\r\n  ///\r\n  /// This function checks that the transmuter and rewards have been set and sets up the active vault.\r\n  ///\r\n  /// @param _adapter the vault adapter of the active vault.\r\n  function initialize(IVaultAdapter _adapter) external onlyGov {\r\n\r\n    require(!initialized, \"Scientist: already initialized\");\r\n\r\n    require(transmuter != ZERO_ADDRESS, \"Scientist: cannot initialize transmuter address to 0x0\");\r\n    require(rewards != ZERO_ADDRESS, \"Scientist: cannot initialize rewards address to 0x0\");\r\n\r\n    _updateActiveVault(_adapter);\r\n\r\n    initialized = true;\r\n  }\r\n\r\n  /// @dev Migrates the system to a new vault.\r\n  ///\r\n  /// This function reverts if the vault adapter is the zero address, if the token that the vault adapter accepts\r\n  /// is not the token that this contract defines as the parent asset, or if the contract has not yet been initialized.\r\n  ///\r\n  /// @param _adapter the adapter for the vault the system will migrate to.\r\n  function migrate(IVaultAdapter _adapter) external expectInitialized onlyGov {\r\n\r\n    _updateActiveVault(_adapter);\r\n  }\r\n\r\n  /// @dev Harvests yield from a vault.\r\n  ///\r\n  /// @param _vaultId the identifier of the vault to harvest from.\r\n  ///\r\n  /// @return the amount of funds that were harvested from the vault.\r\n  function harvest(uint256 _vaultId) external expectInitialized returns (uint256, uint256) {\r\n\r\n    Vault.Data storage _vault = _vaults.get(_vaultId);\r\n\r\n    (uint256 _harvestedAmount, uint256 _decreasedValue) = _vault.harvest(address(this));\r\n\r\n    if (_harvestedAmount > 0) {\r\n      uint256 _feeAmount = _harvestedAmount.mul(harvestFee).div(PERCENT_RESOLUTION);\r\n      uint256 _distributeAmount = _harvestedAmount.sub(_feeAmount);\r\n\r\n      FixedPointMath.uq192x64 memory _weight = FixedPointMath.fromU256(_distributeAmount).div(totalDeposited);\r\n      _ctx.accumulatedYieldWeight = _ctx.accumulatedYieldWeight.add(_weight);\r\n\r\n      if (_feeAmount > 0) {\r\n        token.safeTransfer(rewards, _feeAmount);\r\n      }\r\n\r\n      if (_distributeAmount > 0) {\r\n        _distributeToTransmuter(_distributeAmount);\r\n        \r\n        // token.safeTransfer(transmuter, _distributeAmount); previous version call\r\n      }\r\n    }\r\n\r\n    emit FundsHarvested(_harvestedAmount, _decreasedValue);\r\n\r\n    return (_harvestedAmount, _decreasedValue);\r\n  }\r\n\r\n  /// @dev Recalls an amount of deposited funds from a vault to this contract.\r\n  ///\r\n  /// @param _vaultId the identifier of the recall funds from.\r\n  ///\r\n  /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\r\n  function recall(uint256 _vaultId, uint256 _amount) external nonReentrant expectInitialized returns (uint256, uint256) {\r\n\r\n    return _recallFunds(_vaultId, _amount);\r\n  }\r\n\r\n  /// @dev Recalls all the deposited funds from a vault to this contract.\r\n  ///\r\n  /// @param _vaultId the identifier of the recall funds from.\r\n  ///\r\n  /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\r\n  function recallAll(uint256 _vaultId) external nonReentrant expectInitialized returns (uint256, uint256) {\r\n    Vault.Data storage _vault = _vaults.get(_vaultId);\r\n    return _recallFunds(_vaultId, _vault.totalDeposited);\r\n  }\r\n\r\n  /// @dev Flushes buffered tokens to the active vault.\r\n  ///\r\n  /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\r\n  /// additional funds.\r\n  ///\r\n  /// @return the amount of tokens flushed to the active vault.\r\n  function flush() external nonReentrant expectInitialized returns (uint256) {\r\n\r\n    // Prevent flushing to the active vault when an emergency exit is enabled to prevent potential loss of funds if\r\n    // the active vault is poisoned for any reason.\r\n    require(!emergencyExit, \"emergency pause enabled\");\r\n\r\n    return flushActiveVault();\r\n  }\r\n\r\n  /// @dev Internal function to flush buffered tokens to the active vault.\r\n  ///\r\n  /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\r\n  /// additional funds.\r\n  ///\r\n  /// @return the amount of tokens flushed to the active vault.\r\n  function flushActiveVault() internal returns (uint256) {\r\n\r\n    Vault.Data storage _activeVault = _vaults.last();\r\n    uint256 _depositedAmount = _activeVault.depositAll();\r\n\r\n    emit FundsFlushed(_depositedAmount);\r\n\r\n    return _depositedAmount;\r\n  }\r\n\r\n  /// @dev Deposits collateral into a CDP.\r\n  ///\r\n  /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\r\n  /// additional funds.\r\n  ///\r\n  /// @param _amount the amount of collateral to deposit.\r\n  function deposit(uint256 _amount) external nonReentrant noContractAllowed expectInitialized {\r\n\r\n    require(!emergencyExit, \"emergency pause enabled\");\r\n    \r\n    CDP.Data storage _cdp = _cdps[msg.sender];\r\n    _cdp.update(_ctx);\r\n\r\n    token.safeTransferFrom(msg.sender, address(this), _amount);\r\n    if(_amount >= flushActivator) {\r\n      flushActiveVault();\r\n    }\r\n    totalDeposited = totalDeposited.add(_amount);\r\n\r\n    _cdp.totalDeposited = _cdp.totalDeposited.add(_amount);\r\n    _cdp.lastDeposit = block.number;\r\n\r\n    emit TokensDeposited(msg.sender, _amount);\r\n  }\r\n\r\n  /// @dev Attempts to withdraw part of a CDP's collateral.\r\n  ///\r\n  /// This function reverts if a deposit into the CDP was made in the same block. This is to prevent flash loan attacks\r\n  /// on other internal or external systems.\r\n  ///\r\n  /// @param _amount the amount of collateral to withdraw.\r\n  function withdraw(uint256 _amount) external nonReentrant noContractAllowed expectInitialized returns (uint256, uint256) {\r\n\r\n    CDP.Data storage _cdp = _cdps[msg.sender];\r\n    require(block.number > _cdp.lastDeposit, \"\");\r\n\r\n    _cdp.update(_ctx);\r\n\r\n    (uint256 _withdrawnAmount, uint256 _decreasedValue) = _withdrawFundsTo(msg.sender, _amount);\r\n\r\n    _cdp.totalDeposited = _cdp.totalDeposited.sub(_decreasedValue, \"Exceeds withdrawable amount\");\r\n    _cdp.checkHealth(_ctx, \"Action blocked: unhealthy collateralization ratio\");\r\n    if(_amount >= flushActivator) {\r\n      flushActiveVault();\r\n    }\r\n    emit TokensWithdrawn(msg.sender, _amount, _withdrawnAmount, _decreasedValue);\r\n\r\n    return (_withdrawnAmount, _decreasedValue);\r\n  }\r\n\r\n  /// @dev Repays debt with the native and or synthetic token.\r\n  ///\r\n  /// An approval is required to transfer native tokens to the transmuter.\r\n  function repay(uint256 _parentAmount, uint256 _childAmount) external nonReentrant noContractAllowed onLinkCheck expectInitialized {\r\n\r\n    CDP.Data storage _cdp = _cdps[msg.sender];\r\n    _cdp.update(_ctx);\r\n\r\n    if (_parentAmount > 0) {\r\n      token.safeTransferFrom(msg.sender, address(this), _parentAmount);\r\n      _distributeToTransmuter(_parentAmount);\r\n    }\r\n\r\n    if (_childAmount > 0) {\r\n      xtoken.burnFrom(msg.sender, _childAmount);\r\n      //lower debt cause burn\r\n      xtoken.lowerHasMinted(_childAmount);\r\n    }\r\n\r\n    uint256 _totalAmount = _parentAmount.add(_childAmount);\r\n    _cdp.totalDebt = _cdp.totalDebt.sub(_totalAmount, \"\");\r\n\r\n    emit TokensRepaid(msg.sender, _parentAmount, _childAmount);\r\n  }\r\n\r\n  /// @dev Attempts to liquidate part of a CDP's collateral to pay back its debt.\r\n  ///\r\n  /// @param _amount the amount of collateral to attempt to liquidate.\r\n  function liquidate(uint256 _amount) external nonReentrant noContractAllowed onLinkCheck expectInitialized returns (uint256, uint256) {\r\n    CDP.Data storage _cdp = _cdps[msg.sender];\r\n    _cdp.update(_ctx);\r\n    \r\n    // don't attempt to liquidate more than is possible\r\n    if(_amount > _cdp.totalDebt){\r\n      _amount = _cdp.totalDebt;\r\n    }\r\n    (uint256 _withdrawnAmount, uint256 _decreasedValue) = _withdrawFundsTo(address(this), _amount);\r\n    //changed to new transmuter compatibillity \r\n    _distributeToTransmuter(_withdrawnAmount);\r\n\r\n    _cdp.totalDeposited = _cdp.totalDeposited.sub(_decreasedValue, \"\");\r\n    _cdp.totalDebt = _cdp.totalDebt.sub(_withdrawnAmount, \"\");\r\n    emit TokensLiquidated(msg.sender, _amount, _withdrawnAmount, _decreasedValue);\r\n\r\n    return (_withdrawnAmount, _decreasedValue);\r\n  }\r\n\r\n  /// @dev Mints synthetic tokens by either claiming credit or increasing the debt.\r\n  ///\r\n  /// Claiming credit will take priority over increasing the debt.\r\n  ///\r\n  /// This function reverts if the debt is increased and the CDP health check fails.\r\n  ///\r\n  /// @param _amount the amount of scientific tokens to borrow.\r\n  function mint(uint256 _amount) external nonReentrant noContractAllowed onLinkCheck expectInitialized {\r\n\r\n    CDP.Data storage _cdp = _cdps[msg.sender];\r\n    _cdp.update(_ctx);\r\n\r\n    uint256 _totalCredit = _cdp.totalCredit;\r\n\r\n    if (_totalCredit < _amount) {\r\n      uint256 _remainingAmount = _amount.sub(_totalCredit);\r\n      _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);\r\n      _cdp.totalCredit = 0;\r\n\r\n      _cdp.checkHealth(_ctx, \"Scientist: Loan-to-value ratio breached\");\r\n    } else {\r\n      _cdp.totalCredit = _totalCredit.sub(_amount);\r\n    }\r\n\r\n    xtoken.mint(msg.sender, _amount);\r\n    if(_amount >= flushActivator) {\r\n      flushActiveVault();\r\n    }\r\n  }\r\n\r\n  /// @dev Gets the number of vaults in the vault list.\r\n  ///\r\n  /// @return the vault count.\r\n  function vaultCount() external view returns (uint256) {\r\n    return _vaults.length();\r\n  }\r\n\r\n  /// @dev Get the adapter of a vault.\r\n  ///\r\n  /// @param _vaultId the identifier of the vault.\r\n  ///\r\n  /// @return the vault adapter.\r\n  function getVaultAdapter(uint256 _vaultId) external view returns (IVaultAdapter) {\r\n    Vault.Data storage _vault = _vaults.get(_vaultId);\r\n    return _vault.adapter;\r\n  }\r\n\r\n  /// @dev Get the total amount of the parent asset that has been deposited into a vault.\r\n  ///\r\n  /// @param _vaultId the identifier of the vault.\r\n  ///\r\n  /// @return the total amount of deposited tokens.\r\n  function getVaultTotalDeposited(uint256 _vaultId) external view returns (uint256) {\r\n    Vault.Data storage _vault = _vaults.get(_vaultId);\r\n    return _vault.totalDeposited;\r\n  }\r\n\r\n  /// @dev Get the total amount of collateral deposited into a CDP.\r\n  ///\r\n  /// @param _account the user account of the CDP to query.\r\n  ///\r\n  /// @return the deposited amount of tokens.\r\n  function getCdpTotalDeposited(address _account) external view returns (uint256) {\r\n    CDP.Data storage _cdp = _cdps[_account];\r\n    return _cdp.totalDeposited;\r\n  }\r\n\r\n  /// @dev Get the total amount of scientific tokens borrowed from a CDP.\r\n  ///\r\n  /// @param _account the user account of the CDP to query.\r\n  ///\r\n  /// @return the borrowed amount of tokens.\r\n  function getCdpTotalDebt(address _account) external view returns (uint256) {\r\n    CDP.Data storage _cdp = _cdps[_account];\r\n    return _cdp.getUpdatedTotalDebt(_ctx);\r\n  }\r\n\r\n  /// @dev Get the total amount of credit that a CDP has.\r\n  ///\r\n  /// @param _account the user account of the CDP to query.\r\n  ///\r\n  /// @return the amount of credit.\r\n  function getCdpTotalCredit(address _account) external view returns (uint256) {\r\n    CDP.Data storage _cdp = _cdps[_account];\r\n    return _cdp.getUpdatedTotalCredit(_ctx);\r\n  }\r\n\r\n  /// @dev Gets the last recorded block of when a user made a deposit into their CDP.\r\n  ///\r\n  /// @param _account the user account of the CDP to query.\r\n  ///\r\n  /// @return the block number of the last deposit.\r\n  function getCdpLastDeposit(address _account) external view returns (uint256) {\r\n    CDP.Data storage _cdp = _cdps[_account];\r\n    return _cdp.lastDeposit;\r\n  }\r\n  /// @dev sends tokens to the transmuter\r\n  ///\r\n  /// benefit of great nation of transmuter\r\n  function _distributeToTransmuter(uint256 amount) internal {\r\n        token.approve(transmuter,amount);\r\n        ITransmuter(transmuter).distribute(address(this),amount);\r\n        // lower debt cause of 'burn'\r\n        xtoken.lowerHasMinted(amount);\r\n  } \r\n  /// @dev Checks that parent token is on peg.\r\n  ///\r\n  /// This is used over a modifier limit of pegged interactions.\r\n  modifier onLinkCheck() {\r\n    if(pegMinimum > 0 ){\r\n      uint256 oracleAnswer = uint256(IChainlink(_linkGasOracle).latestAnswer());\r\n      require(oracleAnswer > pegMinimum, \"off peg limitation\");\r\n    }\r\n    _;\r\n  }\r\n  /// @dev Checks that caller is not a eoa.\r\n  ///\r\n  /// This is used to prevent contracts from interacting.\r\n  modifier noContractAllowed() {\r\n    require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\r\n    _;\r\n  }\r\n  /// @dev Checks that the contract is in an initialized state.\r\n  ///\r\n  /// This is used over a modifier to reduce the size of the contract\r\n  modifier expectInitialized() {\r\n    require(initialized, \"Scientist: not initialized.\");\r\n    _;\r\n  }\r\n\r\n  /// @dev Checks that the current message sender or caller is a specific address.\r\n  ///\r\n  /// @param _expectedCaller the expected caller.\r\n  function _expectCaller(address _expectedCaller) internal {\r\n    require(msg.sender == _expectedCaller, \"\");\r\n  }\r\n\r\n  /// @dev Checks that the current message sender or caller is the governance address.\r\n  ///\r\n  ///\r\n  modifier onlyGov() {\r\n    require(msg.sender == governance, \"Scientist: only governance.\");\r\n    _;\r\n  }\r\n  /// @dev Updates the active vault.\r\n  ///\r\n  /// This function reverts if the vault adapter is the zero address, if the token that the vault adapter accepts\r\n  /// is not the token that this contract defines as the parent asset, or if the contract has not yet been initialized.\r\n  ///\r\n  /// @param _adapter the adapter for the new active vault.\r\n  function _updateActiveVault(IVaultAdapter _adapter) internal {\r\n    require(_adapter != IVaultAdapter(ZERO_ADDRESS), \"Scientist: active vault address cannot be 0x0.\");\r\n    require(_adapter.token() == token, \"Scientist: token mismatch.\");\r\n\r\n    _vaults.push(Vault.Data({\r\n      adapter: _adapter,\r\n      totalDeposited: 0\r\n    }));\r\n\r\n    emit ActiveVaultUpdated(_adapter);\r\n  }\r\n\r\n  /// @dev Recalls an amount of funds from a vault to this contract.\r\n  ///\r\n  /// @param _vaultId the identifier of the recall funds from.\r\n  /// @param _amount  the amount of funds to recall from the vault.\r\n  ///\r\n  /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\r\n  function _recallFunds(uint256 _vaultId, uint256 _amount) internal returns (uint256, uint256) {\r\n    require(emergencyExit || msg.sender == governance || _vaultId != _vaults.lastIndex(), \"Scientist: not an emergency, not governance, and user does not have permission to recall funds from active vault\");\r\n\r\n    Vault.Data storage _vault = _vaults.get(_vaultId);\r\n    (uint256 _withdrawnAmount, uint256 _decreasedValue) = _vault.withdraw(address(this), _amount);\r\n\r\n    emit FundsRecalled(_vaultId, _withdrawnAmount, _decreasedValue);\r\n\r\n    return (_withdrawnAmount, _decreasedValue);\r\n  }\r\n\r\n  /// @dev Attempts to withdraw funds from the active vault to the recipient.\r\n  ///\r\n  /// Funds will be first withdrawn from this contracts balance and then from the active vault. This function\r\n  /// is different from `recallFunds` in that it reduces the total amount of deposited tokens by the decreased\r\n  /// value of the vault.\r\n  ///\r\n  /// @param _recipient the account to withdraw the funds to.\r\n  /// @param _amount    the amount of funds to withdraw.\r\n  function _withdrawFundsTo(address _recipient, uint256 _amount) internal returns (uint256, uint256) {\r\n    // Pull the funds from the buffer.\r\n    uint256 _bufferedAmount = Math.min(_amount, token.balanceOf(address(this)));\r\n\r\n    if (_recipient != address(this)) {\r\n      token.safeTransfer(_recipient, _bufferedAmount);\r\n    }\r\n\r\n    uint256 _totalWithdrawn = _bufferedAmount;\r\n    uint256 _totalDecreasedValue = _bufferedAmount;\r\n\r\n    uint256 _remainingAmount = _amount.sub(_bufferedAmount);\r\n\r\n    // Pull the remaining funds from the active vault.\r\n    if (_remainingAmount > 0) {\r\n      Vault.Data storage _activeVault = _vaults.last();\r\n      (uint256 _withdrawAmount, uint256 _decreasedValue) = _activeVault.withdraw(\r\n        _recipient,\r\n        _remainingAmount\r\n      );\r\n\r\n      _totalWithdrawn = _totalWithdrawn.add(_withdrawAmount);\r\n      _totalDecreasedValue = _totalDecreasedValue.add(_decreasedValue);\r\n    }\r\n\r\n    totalDeposited = totalDeposited.sub(_totalDecreasedValue);\r\n\r\n    return (_totalWithdrawn, _totalDecreasedValue);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IMintableERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IMintableERC20\",\"name\":\"_xtoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sentinel\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IVaultAdapter\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"ActiveVaultUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"CollateralizationLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"EmergencyExitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsFlushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decreasedValue\",\"type\":\"uint256\"}],\"name\":\"FundsHarvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decreasedValue\",\"type\":\"uint256\"}],\"name\":\"FundsRecalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"GovernanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"HarvestFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingGovernance\",\"type\":\"address\"}],\"name\":\"PendingGovernanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"RewardsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sentinel\",\"type\":\"address\"}],\"name\":\"SentinelUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decreasedValue\",\"type\":\"uint256\"}],\"name\":\"TokensLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"childAmount\",\"type\":\"uint256\"}],\"name\":\"TokensRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decreasedValue\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmuter\",\"type\":\"address\"}],\"name\":\"TransmuterUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAXIMUM_COLLATERALIZATION_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_COLLATERALIZATION_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_RESOLUTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_linkGasOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralizationLimit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPointMath.uq192x64\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flushActivator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getCdpLastDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getCdpTotalCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getCdpTotalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getCdpTotalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultAdapter\",\"outputs\":[{\"internalType\":\"contract IVaultAdapter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultTotalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVaultAdapter\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVaultAdapter\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pegMinimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"recallAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_parentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_childAmount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sentinel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setCollateralizationLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_emergencyExit\",\"type\":\"bool\"}],\"name\":\"setEmergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_flushActivator\",\"type\":\"uint256\"}],\"name\":\"setFlushActivator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_harvestFee\",\"type\":\"uint256\"}],\"name\":\"setHarvestFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"peg\",\"type\":\"uint256\"}],\"name\":\"setOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pendingGovernance\",\"type\":\"address\"}],\"name\":\"setPendingGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewards\",\"type\":\"address\"}],\"name\":\"setRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sentinel\",\"type\":\"address\"}],\"name\":\"setSentinel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmuter\",\"type\":\"address\"}],\"name\":\"setTransmuter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IMintableERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmuter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xtoken\",\"outputs\":[{\"internalType\":\"contract IMintableERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Scientist", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000000e5c2b15666eee4b66788e45cf4da0392c070fa700000000000000000000000047a14a6f2a5979570a395725f16ec2c61be026f0000000000000000000000000ea783c6f5da2993e1eeb885da66ea029bb8d2161", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8330c426535ff23c5d3387198a134a6b36695420440e96810f010d5d14ba0624"}