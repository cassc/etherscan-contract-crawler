{"SourceCode": "{\"Base.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\n    library SafeMath {//konwnsec//IERC20 \u63a5\u53e3\\r\\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n            if (a == 0) {\\r\\n                return 0; \\r\\n            }\\r\\n            uint256 c = a * b;\\r\\n            assert(c / a == b);\\r\\n            return c; \\r\\n        }\\r\\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n// assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n            uint256 c = a / b;\\r\\n// assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n            return c; \\r\\n        }\\r\\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n            assert(b \\u003c= a);\\r\\n            return a - b; \\r\\n        }\\r\\n\\r\\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n            uint256 c = a + b;\\r\\n            assert(c \\u003e= a);\\r\\n            return c; \\r\\n        }\\r\\n    }\\r\\n\\r\\n    interface Erc20Token {//konwnsec//ERC20 \u63a5\u53e3\\r\\n        function totalSupply() external view returns (uint256);\\r\\n        function balanceOf(address _who) external view returns (uint256);\\r\\n        function transfer(address _to, uint256 _value) external;\\r\\n        function allowance(address _owner, address _spender) external view returns (uint256);\\r\\n        function transferFrom(address _from, address _to, uint256 _value) external;\\r\\n        function approve(address _spender, uint256 _value) external; \\r\\n        function burnFrom(address _from, uint256 _value) external; \\r\\n        event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n        event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n        \\r\\n\\r\\n    }\\r\\n    \\r\\n    \\r\\n    interface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n    \\r\\n// \u57fa\u7c7b\u5408\u7ea6\\r\\n    contract Base {\\r\\n        using SafeMath for uint;\\r\\n        Erc20Token constant internal _eptIns = Erc20Token(0xCDAbD94A40e25E80Cd4CE1D73C8f93e368BD1069); \\r\\n        Erc20Token constant  internal TPAddr = Erc20Token(0x49f2dfe2cC250a5Ed11Ae2d823A6564A8500aD9a);\\r\\n\\r\\n        uint256 public _startTime;\\r\\n        address  _owner;\\r\\n\\r\\n        function EPT_Convert(uint256 value) internal pure returns(uint256) {\\r\\n            return value.mul(1000000000000000000);\\r\\n        }\\r\\n          function eptConvert(uint256 value) internal pure returns(uint256) {\\r\\n            return value.mul(1000000000000);\\r\\n        }\\r\\n        function pccConvert(uint256 value) internal pure returns(uint256) {\\r\\n            return value.mul(1000000000000000000); \\r\\n        }\\r\\n        modifier onlyOwner() {\\r\\n            require(msg.sender == _owner, \\\"Permission denied\\\"); _;\\r\\n        }\\r\\n        modifier isZeroAddr(address addr) {\\r\\n            require(addr != address(0), \\\"Cannot be a zero address\\\"); _; \\r\\n        }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0));\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n    receive() external payable {}  \\r\\n}\"},\"DataPlayer.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\nimport \\\"./Base.sol\\\";\\r\\n\\r\\n  \\r\\ncontract DataPlayer is Base{\\r\\n        struct InvestInfo {\\r\\n            uint256 id; \\r\\n            uint256 amount; \\r\\n            uint256 time; \\r\\n            uint256 blockHigh; \\r\\n            uint256 staticBalance; \\r\\n            uint256 endTime;\\r\\n        }\\r\\n\\r\\n        struct Player{\\r\\n            uint256 id; \\r\\n            address addr; \\r\\n            uint256 LPTime; \\r\\n            uint256 blockHigh; \\r\\n            uint256 staticBalance;\\r\\n            uint256 TBalance; \\r\\n            uint256 dynamicBalance; \\r\\n            InvestInfo[] list; \\r\\n            uint256 LP_Amount; \\r\\n            uint256 referrerId; \\r\\n            uint256 LPEndTime; \\r\\n            uint256 airdrop;\\r\\n        }\\r\\n \\r\\n    mapping(uint256 =\\u003e Player) public _playerMap; \\r\\n    mapping(address =\\u003e uint256) public _playerAddrMap; \\r\\n    uint256 public _playerCount; \\r\\n    uint256 public _staticRate = 280; \\r\\n    uint256 public newtime;\\r\\n\\r\\n    function getPlayerByAddr(address playerAddr) public view returns(uint256[] memory) { \\r\\n        uint256 id = _playerAddrMap[playerAddr];\\r\\n        Player memory player = _playerMap[id];\\r\\n         uint256[] memory temp = new uint256[](11);\\r\\n        temp[0] = player.id;\\r\\n        temp[1] = player.LPTime;\\r\\n        temp[2] = player.airdrop;\\r\\n        temp[3] = player.blockHigh;\\r\\n        temp[4] = player.staticBalance;\\r\\n        temp[5] = player.TBalance;\\r\\n        temp[6] = player.dynamicBalance;\\r\\n        temp[7] = player.LP_Amount;\\r\\n        temp[8] = player.referrerId;\\r\\n        temp[9] = player.LPEndTime;\\r\\n        temp[10] = player.blockHigh;\\r\\n        return temp; \\r\\n    }\\r\\n\\r\\n    function getlistByAddr(address playerAddr ) public view returns(uint256[] memory) { \\r\\n        uint256 id = _playerAddrMap[playerAddr];\\r\\n        Player memory player = _playerMap[id];\\r\\n        uint256[] memory temp = new uint256[](20);\\r\\n        InvestInfo[] memory investList = player.list;\\r\\n        for (uint256 i = 0; i \\u003c investList.length; i++) {\\r\\n            for (uint256 j = 0; j \\u003c 4; j++) {\\r\\n                uint256 d = i.mul(4);\\r\\n                temp[d] = player.list[i].amount;\\r\\n                temp[d+1] = player.list[i].endTime;\\r\\n                temp[d+2] = player.list[i].staticBalance;\\r\\n                temp[d+3] = player.list[i].time;\\r\\n            }\\r\\n        }\\r\\n        return temp; \\r\\n    }\\r\\n\\r\\n    function getAddrById(uint256 id) public view returns(address) {//konwnsec//\u901a\u8fc7 id \u83b7\u53d6\u73a9\u5bb6\u5730\u5740\\r\\n        return _playerMap[id].addr; \\r\\n    }\\r\\n    function getIdByAddr(address addr) public view returns(uint256) {//konwnsec//\u901a\u8fc7\u5730\u5740\u83b7\u53d6\u73a9\u5bb6 id\\r\\n        return _playerAddrMap[addr]; \\r\\n    }\\r\\n \\r\\n  function updateStaticRate(uint256 rate) public onlyOwner  {\\r\\n         _staticRate = rate;\\r\\n    }\\r\\n}\"},\"Dividends.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\nimport \\\"./DataPlayer.sol\\\";\\r\\n\\r\\n\\r\\ncontract Dividends is DataPlayer {\\r\\n    uint256 private constant  ONE_Month = 60 * 60  * 24  * 30;\\r\\n    constructor(address owner)\\r\\n    isZeroAddr(owner) public {\\r\\n        _owner = owner; \\r\\n        _startTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n     function investmentEPT(uint256 amount, address referrerAddr, uint256 Gear) public payable   {\\r\\n        require(amount \\u003e= EPT_Convert(10), \\\"Not enough input\\\");\\r\\n        _eptIns.transferFrom(msg.sender, address(this), amount);\\r\\n        registry(msg.sender,referrerAddr);\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 endTime =block.timestamp.add(Gear.mul(ONE_Month));\\r\\n        uint256 profitAmount = profitCalculation(amount,Gear);\\r\\n        InvestInfo[] memory investList = _playerMap[id].list;\\r\\n        if(investList.length \\u003c 5){\\r\\n            InvestInfo memory info = InvestInfo(id, amount, block.timestamp, block.number,profitAmount,endTime);\\r\\n            _playerMap[id].list.push(info);\\r\\n        }else{\\r\\n            uint256 index = 100;\\r\\n            for (uint256 i = 0; i \\u003c investList.length - 1; i++) {\\r\\n                if (investList[i].id == 0){\\r\\n                    index = i;\\r\\n                }\\r\\n            }\\r\\n            if (index != 100){\\r\\n                _playerMap[id].list[index].id = id;\\r\\n                _playerMap[id].list[index].amount = amount;\\r\\n                _playerMap[id].list[index].time = block.timestamp;\\r\\n                _playerMap[id].list[index].blockHigh = block.number;\\r\\n                _playerMap[id].list[index].staticBalance = profitAmount;\\r\\n                _playerMap[id].list[index].endTime = endTime;\\r\\n            }else{\\r\\n                require(index != 100, \\\"No frequency\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function profitCalculation(uint256 amount, uint256 Gear)internal    returns(uint256) {\\r\\n        uint256 profitAmount = 0;\\r\\n        uint256 proportadsion = Reduceproduction();\\r\\n        if(Gear == 1){\\r\\n            profitAmount = amount.mul(42).div(1000).mul(proportadsion).div(100);\\r\\n        }else  if(Gear == 2){\\r\\n            profitAmount = amount.mul(92).div(1000).mul(proportadsion).div(100);\\r\\n        }\\r\\n        else  if(Gear == 3){\\r\\n            profitAmount = amount.mul(150).div(1000).mul(proportadsion).div(100);\\r\\n        }\\r\\n        else  if(Gear == 6){\\r\\n            profitAmount = amount.mul(324).div(1000).mul(proportadsion).div(100);\\r\\n        }else{\\r\\n            require(false, \\\"No \\\");\\r\\n        }\\r\\n\\r\\n\\r\\n        require(profitAmount != 0, \\\"No frequency\\\");\\r\\n\\r\\n\\r\\n        return profitAmount; \\r\\n    }\\r\\n\\r\\n    \\r\\n    function Reduceproduction()public  returns(uint256)  {\\r\\n        uint256 proportion = 100;\\r\\n        newtime = block.timestamp;\\r\\n        uint256 yearTime = 365 * 24*60*60;\\r\\n        uint256 timeDifference = newtime.sub(_startTime);\\r\\n\\r\\n// 1\\r\\n        if(timeDifference \\u003e 0 \\u0026\\u0026 timeDifference \\u003c yearTime){\\r\\n            proportion = 100;\\r\\n        }  \\r\\n        // 2\\r\\n        else if(timeDifference \\u003e yearTime \\u0026\\u0026 timeDifference \\u003c yearTime*2){\\r\\n            proportion = 90;\\r\\n        }\\r\\n        // 3\\r\\n        else if(timeDifference \\u003e yearTime *2 \\u0026\\u0026 timeDifference \\u003c yearTime*3){\\r\\n            proportion = 80;\\r\\n        } \\r\\n        // 4\\r\\n        else if(timeDifference \\u003e yearTime *3 \\u0026\\u0026 timeDifference \\u003c yearTime*4){\\r\\n            proportion = 70;\\r\\n        } \\r\\n        // 5\\r\\n        else if(timeDifference \\u003e yearTime*4 \\u0026\\u0026 timeDifference \\u003c yearTime*5){\\r\\n            proportion = 60;\\r\\n        } \\r\\n        // 6\\r\\n        else if(timeDifference \\u003e yearTime*5 ){\\r\\n            proportion = 50;\\r\\n        }\\r\\n        return proportion; \\r\\n    }\\r\\n \\r\\n \\r\\n    modifier isRealPlayer() {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        require(id \\u003e 0, \\\"no this user\\\"); // \u7528\u6237\u4e0d\u5b58\u5728\\r\\n        _; \\r\\n    }\\r\\n\\r\\n    function registry(address playerAddr,address tAddr) internal isZeroAddr(playerAddr)   {\\r\\n        uint256 id = _playerAddrMap[playerAddr];\\r\\n        if (id == 0) {\\r\\n            uint256 tid = getIdByAddr(tAddr);\\r\\n            _playerCount++;\\r\\n            _playerAddrMap[playerAddr] = _playerCount; \\r\\n            _playerMap[_playerCount].id = _playerCount; \\r\\n            _playerMap[_playerCount].addr = playerAddr;\\r\\n             if (tid != 0){\\r\\n                _playerMap[_playerCount].referrerId = getIdByAddr(tAddr); \\r\\n            }else{\\r\\n                _playerMap[_playerCount].referrerId = 0; \\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function settleStatic() public  isRealPlayer  {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        InvestInfo[] memory investList = _playerMap[id].list;\\r\\n        uint256 Tid = _playerMap[id].referrerId;\\r\\n        address referrerAddr = getAddrById(Tid);\\r\\n        uint256 staticaAmount = 0;\\r\\n        uint256 referrerAmount = 0;\\r\\n        newtime = block.timestamp;\\r\\n \\r\\n        for (uint256 i = 0; i \\u003c investList.length; i++) {\\r\\n            if(block.timestamp\\u003einvestList[i].endTime){\\r\\n              staticaAmount =  staticaAmount.add(investList[i].amount).add(investList[i].staticBalance);\\r\\n              referrerAmount =  referrerAmount.add(investList[i].staticBalance.div(10));\\r\\n                delete _playerMap[id].list[i];\\r\\n             }\\r\\n        }\\r\\n            require(staticaAmount \\u003e 0, \\\" this field\\\" ); \\r\\n            if(staticaAmount \\u003e 0){\\r\\n                _eptIns.transfer(msg.sender, staticaAmount);\\r\\n            }\\r\\n            if(referrerAmount \\u003e 0){\\r\\n                if(Tid \\u003e 0){\\r\\n                    _eptIns.transfer(referrerAddr, referrerAmount);\\r\\n                }\\r\\n            }\\r\\n    }\\r\\n\\r\\n    function WithdrawalLP() public isRealPlayer   {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 LPamount = _playerMap[id].LP_Amount;\\r\\n        if(LPamount \\u003e 0){\\r\\n            if(_playerMap[id].LPEndTime != 0){\\r\\n                uint256  LPsettlementTime = block.timestamp.sub(_playerMap[id].LPEndTime);\\r\\n                require(LPsettlementTime \\u003e 60, \\\" time field\\\" ); \\r\\n                 uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(100000000).div(60);\\r\\n\\r\\n                dynamicLP_Amount = _playerMap[id].dynamicBalance.add(dynamicLP_Amount);\\r\\n                require(dynamicLP_Amount \\u003e 0, \\\" Amount field\\\" ); \\r\\n                _playerMap[id].dynamicBalance = 0;\\r\\n                _playerMap[id].LPEndTime = block.timestamp;\\r\\n                _eptIns.transfer(msg.sender, dynamicLP_Amount);\\r\\n             }\\r\\n        }\\r\\n    }\\r\\n\\r\\n     function WithdrawalAirdrop() public isRealPlayer  onlyOwner  {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 Airdrop = _playerMap[id].airdrop;\\r\\n        if(Airdrop \\u003e 0){\\r\\n            _eptIns.transfer(msg.sender, Airdrop);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function redeemLP() public isRealPlayer   {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 LPamount = _playerMap[id].LP_Amount;\\r\\n        if(LPamount \\u003e 0){\\r\\n            if(_playerMap[id].LPEndTime != 0){\\r\\n                uint256  time = _playerMap[id].LPEndTime;\\r\\n                newtime = block.timestamp;\\r\\n                uint256  LPsettlementTime = block.timestamp.sub(time);\\r\\n                if(LPsettlementTime \\u003e 60){\\r\\n                    uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(100000000).div(60);\\r\\n                    _eptIns.transfer(msg.sender, _playerMap[id].dynamicBalance.add(dynamicLP_Amount));\\r\\n                }\\r\\n                _playerMap[id].dynamicBalance = 0;\\r\\n                _playerMap[id].LPEndTime = 0;\\r\\n                _playerMap[id].LP_Amount = 0;\\r\\n                TPAddr.transfer( msg.sender, LPamount);\\r\\n             }\\r\\n        }\\r\\n    }\\r\\n                  \\r\\n    function Airdrop(address[] calldata referrerAddrs,uint256[] calldata Playerfarms)public payable  isRealPlayer  {\\r\\n        for (uint256 i=0; i\\u003creferrerAddrs.length; i++) {\\r\\n            address add = referrerAddrs[i];\\r\\n            uint256 amount = eptConvert(Playerfarms[i]);\\r\\n            uint256 id = _playerAddrMap[add];\\r\\n            require(id \\u003e 0, \\\"no this user\\\"); // \u7528\u6237\u4e0d\u5b58\u5728\\r\\n           _playerMap[id].airdrop = _playerMap[id].airdrop.add(amount);\\r\\n        }           \\r\\n    }       \\r\\n\\r\\nfunction investmentEPTUSDTLP(uint256 amount, address referrerAddr) public payable  {\\r\\n        require(amount \\u003e= eptConvert(1), \\\"Not enough input\\\");\\r\\n        registry(msg.sender,referrerAddr);\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        TPAddr.transferFrom(msg.sender, address(this), amount);\\r\\n        settlementLP(id,amount);\\r\\n    }\\r\\n\\r\\nfunction settlementLP(uint256 id,uint256 Amount) internal {\\r\\n        uint256 LPamount = _playerMap[id].LP_Amount;\\r\\n        if(LPamount \\u003e 0){\\r\\n            if(_playerMap[id].LPEndTime != 0){\\r\\n                uint256  LPsettlementTime = block.timestamp.sub(_playerMap[id].LPEndTime);\\r\\n                uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(100000000).div(60);\\r\\n                _playerMap[id].dynamicBalance = _playerMap[id].dynamicBalance.add(dynamicLP_Amount);\\r\\n                _playerMap[id].LPEndTime = block.timestamp;\\r\\n                _playerMap[id].LP_Amount = _playerMap[id].LP_Amount.add(Amount);\\r\\n            }\\r\\n            else{\\r\\n                uint256 LPsettlementTime = block.timestamp.sub(_playerMap[id].LPTime);\\r\\n                uint256 dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(100000000).div(60);\\r\\n                _playerMap[id].dynamicBalance = _playerMap[id].dynamicBalance.add(dynamicLP_Amount);\\r\\n                _playerMap[id].LPEndTime = block.timestamp;\\r\\n                _playerMap[id].LP_Amount = _playerMap[id].LP_Amount.add(Amount);\\r\\n            }\\r\\n        }else{\\r\\n                _playerMap[id].LPEndTime = block.timestamp;\\r\\n                _playerMap[id].LPTime= block.timestamp;\\r\\n                _playerMap[id].LP_Amount = Amount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n   function buy(uint256 pBalance) public payable  {\\r\\n          _eptIns.transferFrom(address(msg.sender), address(_owner), pBalance);\\r\\n     }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"referrerAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Playerfarms\",\"type\":\"uint256[]\"}],\"name\":\"Airdrop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Reduceproduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawalAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawalLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_playerAddrMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_playerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_playerMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"LPTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockHigh\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staticBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dynamicBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LP_Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LPEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_staticRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pBalance\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAddrById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getIdByAddr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getPlayerByAddr\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getlistByAddr\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrerAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Gear\",\"type\":\"uint256\"}],\"name\":\"investmentEPT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"investmentEPTUSDTLP\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newtime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settleStatic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"updateStaticRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Dividends", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000011bc5d84a7817d5ed49e3af8fac2920c33d6b598", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fe249b7fca17c4ac14010e3202046428070ec399d5c4dff894ddad4f1f42629e"}