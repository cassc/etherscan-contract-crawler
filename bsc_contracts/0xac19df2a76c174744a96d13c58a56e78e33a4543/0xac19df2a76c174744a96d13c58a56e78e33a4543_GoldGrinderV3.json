{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GoldGrinder3.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\\\";\\nimport \\\"./Safe.sol\\\";\\nimport \\\"./CasinoConfig.sol\\\";\\n\\ncontract GoldGrinderV3 is Ownable  , CasinoConfig  {\\n\\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\\n    /** base parameters **/\\n    uint128 private constant _GOLDS_TO_HIRE_1MINER = 10 days; //10% daily apr\\n    uint256 private constant _REFERRAL = 90; //% to ref\\n    uint128 private constant _PERCENTS_DIVIDER = 1000;\\n    uint256 private _devTax = 80;\\n    \\n    uint256 private _minMinersForAutoCompound;\\n\\n    uint256 private _dampeningFactor = 70;\\n\\n    uint256 private constant _COMPOUND_BONUS = 15;\\n    uint256 private constant _COMPOUND_BONUS_MAX_TIMES = 26;\\n    uint256 private constant _COMPOUND_STEP = 1 days;\\n\\n    uint128 private constant _WITHDRAWAL_TAX = 800;\\n    uint256 private constant _COMPOUND_FOR_NO_TAX_WITHDRAWAL = 6;\\n\\n    uint256 private constant _CUTOFF_STEP = 2 days;\\n    uint256 private constant _WITHDRAW_COOLDOWN = 1 days;\\n\\n    uint256 private constant CASINO_TAX = 50;\\n\\n    \\n\\n    uint256 private totalStaked;\\n    uint256 private totalUsers;\\n    uint256 private totalRefBonus;\\n\\n    uint256 private marketGolds = 100_000 * _GOLDS_TO_HIRE_1MINER;\\n    uint256 PSN = 10000;\\n    uint256 PSNH = 5000;\\n\\n    bool private _initialized;\\n\\n    /* addresses */\\n    address payable public immutable dev;\\n\\n    address public immutable safe_addr;\\n\\n    address public automator;\\n\\n\\n    IERC20 public immutable token;\\n\\n    mapping(address => bool) private hasParticipated;\\n\\n    EnumerableMap.AddressToUintMap private automations;\\n\\n    uint256 public automator_index;\\n\\n    uint88 public minAmountBet;\\n    uint88 public maxBet1k;\\n\\n    struct User {\\n        uint128 initialDeposit;\\n        uint128 userDeposit;\\n        uint128 miners;\\n        uint128 claimedGolds;\\n        uint128 referralGoldRewards;\\n        uint128 totalWithdrawn;\\n        address referrer;\\n        uint64 lastHireTime;\\n        uint24 referralsCount;\\n        uint8 dailyCompoundBonus;\\n        bet_stats stats;\\n    }\\n\\n    struct bet_stats{\\n        uint128 gamesPlayed;\\n        uint64 gamesWon;\\n        uint64 gamesLost;\\n    }\\n\\n    struct Bet {\\n        uint88 amount; \\n        address player;\\n        int8 outcome; //-1 lost 0 waiting for response 1 won\\n    }\\n\\n    mapping(address => User) public users;\\n\\n    //requestId => Bet\\n    mapping(uint256 =>Bet) public bets;\\n\\n    modifier onlyAutomator() {\\n        require(msg.sender==automator, \\\"Caller is not the automator\\\");\\n        _;\\n    }\\n\\n    modifier initialized() {\\n        require(_initialized, \\\"Contract not initialized\\\");\\n        _;\\n    }\\n\\n    constructor(address payable _dev, IERC20 _token, uint64 subscriptionId) CasinoConfig(subscriptionId) {\\n        dev = _dev;\\n        token=_token;\\n        safe_addr = address(new Safe(_token));\\n        minAmountBet = 50 ether;\\n        maxBet1k = 100; //10% of tvl\\n        _minMinersForAutoCompound = type(uint256).max; //will be updated once initialized the contract\\n\\n    }\\n\\n    function startFarm(address addr,uint128 amount) public onlyOwner {\\n        require(!_initialized, \\\"Already initialized\\\");\\n        _initialized = true;\\n        buyGold(addr,amount);\\n    }\\n\\n    function _hireMiners(address addr,bool isCompound) internal {\\n        User storage user = users[addr];\\n\\n        uint128 goldsUsed = getMyGolds(addr);\\n        uint128 goldsForCompound = goldsUsed;\\n\\n        if (isCompound) {\\n            goldsForCompound += getDailyCompoundBonus(\\n                addr,\\n                goldsForCompound\\n            );\\n            uint128 goldsUsedValue = calculateGoldSell(goldsForCompound);\\n            user.userDeposit += goldsUsedValue;\\n        }\\n\\n        if (block.timestamp - user.lastHireTime >= _COMPOUND_STEP) {\\n            if (user.dailyCompoundBonus < _COMPOUND_BONUS_MAX_TIMES) {\\n                ++user.dailyCompoundBonus;\\n            }\\n        }\\n        user.claimedGolds = goldsForCompound % _GOLDS_TO_HIRE_1MINER;\\n        user.miners += goldsForCompound / _GOLDS_TO_HIRE_1MINER;\\n        user.lastHireTime = uint64(block.timestamp);\\n\\n        marketGolds += dampenGold(goldsUsed);\\n\\n        if (!hasParticipated[addr]) {\\n            hasParticipated[addr] = true;\\n            totalUsers++;\\n        }\\n    }\\n\\n    function hireMiners() public initialized {\\n        require(!automations.contains(msg.sender), \\\"Address is autocompounded!\\\");\\n        _hireMiners(msg.sender,true);\\n    }\\n\\n    function dampenGold(uint256 amount) private view returns (uint256) {\\n        return (amount * _dampeningFactor) / 100;\\n    }\\n\\n    function sellGolds() public initialized {\\n        require(!automations.contains(msg.sender), \\\"Address is autocompounded!\\\");\\n        _sellGolds(msg.sender);\\n    }\\n\\n    function _sellGolds(address addr) internal {\\n        \\n        User storage user = users[addr];\\n        require(block.timestamp-user.lastHireTime>=_WITHDRAW_COOLDOWN, \\\"must wait 24 hours before sell\\\");\\n\\n        uint128 hasGolds = getMyGolds(addr);\\n        uint128 goldValue = calculateGoldSell(hasGolds);\\n\\n        /** \\n            if user compound < to mandatory compound days**/\\n        if (user.dailyCompoundBonus < _COMPOUND_FOR_NO_TAX_WITHDRAWAL) {\\n            goldValue -= ((goldValue * _WITHDRAWAL_TAX) / _PERCENTS_DIVIDER);\\n        } else {\\n            //set daily compound bonus count to 0 and goldValue will remain without deductions\\n            user.dailyCompoundBonus = 0;\\n        }\\n\\n        user.claimedGolds = 0;\\n        user.lastHireTime = uint64(block.timestamp);\\n        marketGolds += hasGolds;\\n\\n        if (token.balanceOf(address(this)) < goldValue) {\\n            goldValue = uint128( token.balanceOf(address(this)));\\n        }\\n\\n        uint256 goldsPayout = goldValue - payFees(goldValue);\\n        token.transfer(addr,goldsPayout);\\n        user.totalWithdrawn += uint128(goldsPayout);\\n        if (user.miners == 0) {\\n            hasParticipated[addr] = false;\\n            totalUsers--;\\n        }\\n    }\\n\\n    function buyGold(address ref, uint128 amount) public initialized {\\n         User storage user = users[msg.sender];\\n        token.transferFrom(msg.sender,address(this),amount);\\n        uint128 goldsBought = calculateGoldBuy(\\n            amount,\\n            token.balanceOf(address(this))-amount\\n        );\\n        user.userDeposit += amount;\\n        user.initialDeposit += amount;\\n        user.claimedGolds += goldsBought;\\n\\n        if (\\n            user.referrer == address(0) \\n        ) {\\n\\n            user.referrer = (ref != address(0) && ref != msg.sender) ? ref : dev ;\\n            ++users[user.referrer].referralsCount;\\n        }\\n\\n        if (user.referrer != address(0)) {\\n            address upline = user.referrer;\\n            uint256 refRewards = (amount * _REFERRAL) / _PERCENTS_DIVIDER;\\n            token.transfer(upline,refRewards);\\n\\n            users[upline].referralGoldRewards += uint128(refRewards);\\n            totalRefBonus += refRewards;\\n        }\\n\\n        uint256 goldsPayout = payFees(amount);\\n        totalStaked += amount - goldsPayout;\\n        _hireMiners(msg.sender,false);\\n    }\\n\\n    function payFees(uint256 goldValue) internal returns (uint256) {\\n        uint256 tax = (goldValue * _devTax) / _PERCENTS_DIVIDER;\\n        token.transfer(dev,tax);\\n        return tax;\\n    }\\n\\n    function getDailyCompoundBonus(address _adr, uint256 amount)\\n        public\\n        view\\n        returns (uint128)\\n    {\\n        uint256 totalBonus = users[_adr].dailyCompoundBonus * _COMPOUND_BONUS;\\n        uint256 result = (amount * totalBonus) / _PERCENTS_DIVIDER;\\n        return uint128(result);\\n    }\\n\\n    function getMinerInfo()\\n        public\\n        view\\n        returns (\\n            uint256 GOLDS_TO_HIRE_1MINER,\\n            uint256 REFERRAL,\\n            uint256 PERCENTS_DIVIDER,\\n            uint256 devTax,\\n            uint256 minMinersForAutoCompound,\\n            uint256 DAMPENING_FACTOR,\\n            uint256 COMPOUND_BONUS,\\n            uint256 COMPOUND_BONUS_MAX_TIMES,\\n            uint256 COMPOUND_STEP,\\n            uint256 WITHDRAWAL_TAX,\\n            uint256 COMPOUND_FOR_NO_TAX_WITHDRAWAL,\\n            uint256 CUTOFF_STEP,\\n            uint256 WITHDRAW_COOLDOWN\\n           \\n        )\\n    {\\n    GOLDS_TO_HIRE_1MINER = _GOLDS_TO_HIRE_1MINER;\\n    REFERRAL = _REFERRAL;\\n    PERCENTS_DIVIDER = _PERCENTS_DIVIDER;\\n    devTax = _devTax;\\n    minMinersForAutoCompound = _minMinersForAutoCompound;\\n    DAMPENING_FACTOR = _dampeningFactor;\\n    COMPOUND_BONUS = _COMPOUND_BONUS;\\n    COMPOUND_BONUS_MAX_TIMES = _COMPOUND_BONUS_MAX_TIMES;\\n    COMPOUND_STEP = _COMPOUND_STEP;\\n    WITHDRAWAL_TAX = _WITHDRAWAL_TAX;\\n    COMPOUND_FOR_NO_TAX_WITHDRAWAL = _COMPOUND_FOR_NO_TAX_WITHDRAWAL;\\n    CUTOFF_STEP = _CUTOFF_STEP;\\n    WITHDRAW_COOLDOWN = _WITHDRAW_COOLDOWN;\\n    }\\n\\n    function getUserInfo(address _adr)\\n        public\\n        view\\n        returns (\\n            uint256 _initialDeposit,\\n            uint256 _userDeposit,\\n            uint256 _miners,\\n            uint256 _golds,\\n            uint256 _claimedGolds,\\n            uint256 _lastHireTime,\\n            address _referrer,\\n            uint256 _referrals,\\n            uint256 _totalWithdrawn,\\n            uint256 _referralGoldRewards,\\n            uint256 _dailyCompoundBonus,\\n            bet_stats memory _stats\\n        )\\n    {\\n        _initialDeposit = users[_adr].initialDeposit;\\n        _userDeposit = users[_adr].userDeposit;\\n        _miners = users[_adr].miners;\\n        _golds = getMyGolds(_adr);\\n        _claimedGolds = users[_adr].claimedGolds;\\n        _lastHireTime = users[_adr].lastHireTime;\\n        _referrer = users[_adr].referrer;\\n        _referrals = users[_adr].referralsCount;\\n        _totalWithdrawn = users[_adr].totalWithdrawn;\\n        _referralGoldRewards = users[_adr].referralGoldRewards;\\n        _dailyCompoundBonus = users[_adr].dailyCompoundBonus;\\n        _stats = users[_adr].stats;\\n    }\\n \\n    function getAvailableEarnings(address _adr) public view returns (uint256) {\\n        return calculateGoldSell(getMyGolds(_adr));\\n    }\\n\\n    function calculateTrade(\\n        uint256 rt,\\n        uint256 rs,\\n        uint256 bs\\n    ) private view returns (uint256) {\\n        return (PSN * bs) / (PSNH + (PSN * rs + PSNH * rt) / rt);\\n    }\\n\\n    function calculateGoldSell(uint256 golds) public view returns (uint128) {\\n        return uint128(calculateTrade(golds, marketGolds, token.balanceOf(address(this))));\\n    }\\n\\n    function calculateGoldBuy(uint256 eth, uint256 contractBalance)\\n        public\\n        view\\n        returns (uint128)\\n    {\\n        return uint128(calculateTrade(eth, contractBalance, marketGolds));\\n    }\\n\\n    function calculateGoldBuySimple(uint256 eth) public view returns (uint256) {\\n        return calculateGoldBuy(eth, token.balanceOf(address(this)));\\n    }\\n\\n    /** How many miners and golds per day user will recieve based on USDT deposit **/\\n    function getGoldsYieldPerDay(uint256 amount)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 goldsAmount = calculateGoldBuy(amount, token.balanceOf(address(this)));\\n        uint256 miners = goldsAmount / _GOLDS_TO_HIRE_1MINER;\\n        uint256 day = 1 days;\\n        uint256 goldsPerDay = day * miners;\\n        uint256 earningsPerDay = calculateGoldSellForYield(goldsPerDay, amount);\\n        return (miners, earningsPerDay);\\n    }\\n\\n    function calculateGoldSellForYield(uint256 golds, uint256 amount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            calculateTrade(golds, marketGolds, token.balanceOf(address(this)) + amount);\\n    }\\n\\n    function getSiteInfo()\\n        public\\n        view\\n        returns (\\n            uint256 _totalStaked,\\n            uint256 _totalUsers,\\n            uint256 _totalAutoCompound,\\n            uint256 _totalRefBonus\\n        )\\n    {\\n        return (totalStaked, totalUsers, automations.length(), totalRefBonus);\\n    }\\n\\n    function getMyGolds(address addr) private view returns (uint128) {\\n        return users[addr].claimedGolds + getGoldsSinceLastHireTime(addr);\\n    }\\n\\n    function getGoldsSinceLastHireTime(address adr)\\n        public\\n        view\\n        returns (uint128)\\n    {\\n        uint256 secondsSinceLastHireTime = block.timestamp -\\n            users[adr].lastHireTime;\\n        /** get min time. **/\\n        uint256 cutoffTime = min(secondsSinceLastHireTime, _CUTOFF_STEP);\\n        uint256 secondsPassed = min(_GOLDS_TO_HIRE_1MINER, cutoffTime);\\n        return uint128(secondsPassed * users[adr].miners);\\n    }\\n\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function setDevTax(uint256 value) external onlyOwner {\\n        require(value <= 150);\\n        _devTax = value;\\n    }\\n\\n    function setMinMinersForAutoCompound(uint256 __minMinersForAutoCompound) external onlyOwner {\\n        _minMinersForAutoCompound=__minMinersForAutoCompound;\\n    }\\n\\n    function setAutomator(address _automator) external onlyOwner {\\n        automator = _automator;\\n    }\\n\\n    function getAutomationSettings(address _addr) external view returns (uint256 result){\\n        (,result) = automations.tryGet(_addr);\\n    }\\n    \\n    function enableAutocompound(uint256 lastCompoundAtDay) external initialized{\\n        require(automator_index==0, \\\"not during an autocompound\\\");\\n        require(!automations.contains(msg.sender), \\\"Address already exists!\\\");\\n        require(users[msg.sender].miners>=_minMinersForAutoCompound, \\\"Not enough miners!\\\");\\n        require(lastCompoundAtDay >= _COMPOUND_FOR_NO_TAX_WITHDRAWAL && lastCompoundAtDay <= _COMPOUND_BONUS_MAX_TIMES, \\\"sell must be after min 6 days max 26\\\"); //[6,26]\\n        automations.set(msg.sender,lastCompoundAtDay);        \\n    }\\n\\n    function disableAutocompound() external initialized{\\n        require(automator_index==0, \\\"not during an autocompound\\\");\\n        require(automations.contains(msg.sender), \\\"Address must exist!\\\");\\n        automations.remove(msg.sender);\\n    }\\n\\n    //in case there are problems with the autocompounder, to unlock the ability to remove people from autocomp\\n    function resetAutomatorIndex() external onlyOwner{\\n        automator_index = 0;\\n    }\\n\\n    function runAutomate(uint num_users) external initialized onlyAutomator {\\n        uint256 automateCount = min(automations.length(),automator_index+num_users);\\n\\n        uint256 iterations=automator_index;\\n        while(iterations < automateCount) {\\n            (address adr, uint256 lastCompoundAtDay) = automations.at(iterations);\\n                if (block.timestamp >= users[adr].lastHireTime + 1 days) {  \\n\\n                    if(users[adr].dailyCompoundBonus < lastCompoundAtDay) {\\n                        _hireMiners(adr,true);\\n                    }\\n                    else {\\n                        _sellGolds(adr);\\n                    }\\n                }\\n                unchecked{\\n                ++iterations;\\n                }\\n        }\\n        automator_index = iterations==automations.length() ? 0 : iterations;\\n    }\\n\\n    function setBetBounds(uint88 _minAmountBet,uint88 _maxBet1k) external onlyOwner{\\n        minAmountBet = _minAmountBet;\\n        maxBet1k = _maxBet1k;\\n    }\\n\\n    function setDampeningFactor(uint256 value) external onlyOwner{\\n        require(value!=0 && value<=100, \\\"invalid value\\\");\\n        _dampeningFactor = value;\\n    }\\n \\n    // Assumes the subscription is funded sufficiently.\\n    function bet(uint88 amount) external{\\n        \\n        require(amount>=minAmountBet && amount<=token.balanceOf(address(this))*maxBet1k/1000,\\\"size of the bet is not ok\\\");\\n        uint256 taxedAmount = amount*(_PERCENTS_DIVIDER-CASINO_TAX)/_PERCENTS_DIVIDER;\\n        token.transferFrom(msg.sender,safe_addr,taxedAmount);\\n        token.transferFrom(msg.sender,dev,amount-taxedAmount);\\n        // Will revert if subscription is not set and funded.\\n        uint256 requestId = COORDINATOR.requestRandomWords(\\n          keyHash,\\n          s_subscriptionId,\\n          requestConfirmations,\\n          callbackGasLimit,\\n          numWords\\n        );\\n        bets[requestId].amount = amount;\\n        bets[requestId].player = msg.sender;\\n        users[msg.sender].stats.gamesPlayed++;\\n    }\\n\\n    function fulfillRandomWords(\\n    uint256 requestId,\\n    uint256[] memory randomWords\\n  ) internal override {\\n    require(bets[requestId].outcome == 0, \\\"bet already settled\\\");\\n    uint256 randomNumber;\\n    randomNumber = randomWords[0]%100;\\n    address player = bets[requestId].player;\\n    uint256 taxedAmount = bets[requestId].amount*(_PERCENTS_DIVIDER-CASINO_TAX)/_PERCENTS_DIVIDER;\\n    if(randomNumber<30)\\n    {\\n        token.transferFrom(safe_addr,player,taxedAmount);\\n        token.transfer(player,bets[requestId].amount);\\n        bets[requestId].outcome=1; //won\\n        users[player].stats.gamesWon++;\\n\\n    }\\n    else\\n    {   \\n        token.transferFrom(safe_addr,address(this),taxedAmount);\\n        bets[requestId].outcome=-1; //lost\\n        users[player].stats.gamesLost++;\\n    }\\n    \\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableMap.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key), errorMessage));\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, key, errorMessage));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Safe.sol\": {\r\n      \"content\": \"pragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract Safe {\\n\\n    IERC20 public immutable token;\\n    address public immutable miner;\\n\\n\\n    constructor (IERC20 _token){\\n        miner = msg.sender;\\n        token = _token;\\n        approveMax();\\n    }\\n\\n    function approveMax() public{\\n        token.approve(miner,type(uint256).max);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/CasinoConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\n\\nabstract contract CasinoConfig is VRFConsumerBaseV2 {\\n  VRFCoordinatorV2Interface internal COORDINATOR;\\n\\n  uint64 immutable s_subscriptionId;\\n\\n  address constant vrfCoordinator = 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE;\\n\\n  bytes32 constant keyHash = 0x114f3da0a805b6a67d6e9cd2ec746f7028f1b7376365af575cfea3550dd1aa04;\\n\\n  uint32 constant callbackGasLimit = 100000;\\n\\n  uint16 constant requestConfirmations = 3;\\n\\n  uint32 constant numWords =  1;\\n\\n  constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    s_subscriptionId = subscriptionId;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_dev\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"automator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automator_index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint88\",\"name\":\"amount\",\"type\":\"uint88\"}],\"name\":\"bet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"internalType\":\"uint88\",\"name\":\"amount\",\"type\":\"uint88\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"int8\",\"name\":\"outcome\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"buyGold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"name\":\"calculateGoldBuy\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"calculateGoldBuySimple\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"golds\",\"type\":\"uint256\"}],\"name\":\"calculateGoldSell\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"golds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateGoldSellForYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAutocompound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastCompoundAtDay\",\"type\":\"uint256\"}],\"name\":\"enableAutocompound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getAutomationSettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"getAvailableEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getDailyCompoundBonus\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getGoldsSinceLastHireTime\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getGoldsYieldPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"GOLDS_TO_HIRE_1MINER\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"REFERRAL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PERCENTS_DIVIDER\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minMinersForAutoCompound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DAMPENING_FACTOR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"COMPOUND_BONUS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"COMPOUND_BONUS_MAX_TIMES\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"COMPOUND_STEP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"WITHDRAWAL_TAX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"COMPOUND_FOR_NO_TAX_WITHDRAWAL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CUTOFF_STEP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"WITHDRAW_COOLDOWN\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSiteInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalUsers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalAutoCompound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalRefBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_miners\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_golds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimedGolds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastHireTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referralGoldRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dailyCompoundBonus\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"gamesPlayed\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"gamesWon\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"gamesLost\",\"type\":\"uint64\"}],\"internalType\":\"struct GoldGrinderV3.bet_stats\",\"name\":\"_stats\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hireMiners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBet1k\",\"outputs\":[{\"internalType\":\"uint88\",\"name\":\"\",\"type\":\"uint88\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmountBet\",\"outputs\":[{\"internalType\":\"uint88\",\"name\":\"\",\"type\":\"uint88\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetAutomatorIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num_users\",\"type\":\"uint256\"}],\"name\":\"runAutomate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safe_addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellGolds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_automator\",\"type\":\"address\"}],\"name\":\"setAutomator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint88\",\"name\":\"_minAmountBet\",\"type\":\"uint88\"},{\"internalType\":\"uint88\",\"name\":\"_maxBet1k\",\"type\":\"uint88\"}],\"name\":\"setBetBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setDampeningFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setDevTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"__minMinersForAutoCompound\",\"type\":\"uint256\"}],\"name\":\"setMinMinersForAutoCompound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"startFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"initialDeposit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"userDeposit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"miners\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"claimedGolds\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"referralGoldRewards\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalWithdrawn\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"lastHireTime\",\"type\":\"uint64\"},{\"internalType\":\"uint24\",\"name\":\"referralsCount\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"dailyCompoundBonus\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"gamesPlayed\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"gamesWon\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"gamesLost\",\"type\":\"uint64\"}],\"internalType\":\"struct GoldGrinderV3.bet_stats\",\"name\":\"stats\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GoldGrinderV3", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a975eff0ce8c6db419748a3215b7179e20b42b7e00000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000000000000000000000000000000000000000001e2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}