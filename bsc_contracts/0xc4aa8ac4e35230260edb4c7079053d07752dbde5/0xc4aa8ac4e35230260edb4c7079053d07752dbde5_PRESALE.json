{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-08-29\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns(uint256);\r\n\tfunction balanceOf(address account) external view returns(uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns(bool);\r\n\tfunction allowance(address owner, address spender) external view returns(uint256);\r\n\tfunction approve(address spender, uint256 amount) external returns(bool);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface PANCAKEFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface PANCAKE {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    \r\n     function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n}\r\n\r\n \r\n\r\n library Address {\r\n \tfunction isContract(address account) internal view returns(bool) {\r\n \t\tbytes32 codehash;\r\n \t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n \t\tassembly {\r\n \t\t\tcodehash:= extcodehash(account)\r\n \t\t}\r\n \t\treturn (codehash != accountHash && codehash != 0x0);\r\n \t}\r\n\r\n \tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n \t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n \t\t(bool success, ) = recipient.call {\r\n \t\t\tvalue: amount\r\n \t\t}(\"\");\r\n \t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n \t}\r\n\r\n \tfunction functionCall(address target, bytes memory data) internal returns(bytes memory) {\r\n \t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n \t}\r\n\r\n \tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns(bytes memory) {\r\n \t\treturn _functionCallWithValue(target, data, 0, errorMessage);\r\n \t}\r\n\r\n \tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns(bytes memory) {\r\n \t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n \t}\r\n\r\n \tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns(bytes memory) {\r\n \t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n \t\treturn _functionCallWithValue(target, data, value, errorMessage);\r\n \t}\r\n\r\n \tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns(bytes memory) {\r\n \t\trequire(isContract(target), \"Address: call to non-contract\");\r\n \t\t(bool success, bytes memory returndata) = target.call {\r\n \t\t\tvalue: weiValue\r\n \t\t}(data);\r\n \t\tif (success) {\r\n \t\t\treturn returndata;\r\n \t\t} else {\r\n \t\t\tif (returndata.length > 0) {\r\n\r\n \t\t\t\tassembly {\r\n \t\t\t\t\tlet returndata_size:= mload(returndata)\r\n \t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n \t\t\t\t}\r\n \t\t\t} else {\r\n \t\t\t\trevert(errorMessage);\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n }\r\n\r\n\r\n\r\n abstract contract Context {\r\n \tfunction _msgSender() internal view virtual returns(address) {\r\n \t\treturn msg.sender;\r\n \t}\r\n\r\n \tfunction _msgData() internal view virtual returns(bytes memory) {\r\n \t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n \t\treturn msg.data;\r\n \t}\r\n }\r\n\r\n\r\n contract Ownable is Context {\r\n \taddress private _owner;\r\n \tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n \tconstructor(){\r\n \t\taddress msgSender = _msgSender();\r\n \t\t_owner = msgSender;\r\n \t\temit OwnershipTransferred(address(0), msgSender);\r\n \t}\r\n\r\n \tfunction owner() public view returns(address) {\r\n \t\treturn _owner;\r\n \t}\r\n \tmodifier onlyOwner() {\r\n \t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n \t\t_;\r\n \t}\r\n\r\n \tfunction renounceOwnership() public virtual onlyOwner {\r\n \t\temit OwnershipTransferred(_owner, address(0));\r\n \t\t_owner = address(0);\r\n \t}\r\n\r\n \tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n \t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n \t\temit OwnershipTransferred(_owner, newOwner);\r\n \t\t_owner = newOwner;\r\n \t}\r\n }\r\n\r\n\r\n\r\n \r\ncontract PRESALE is Ownable {\r\n  constructor(){ }\r\n\r\n address ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n address FACTORY= 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\r\n address TOKEN = 0x21be7d4B651924eA584E11bA28f08e582c399AFe;\r\n address USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n  \r\n    struct UserInfo {\r\n \t\tuint256 available;\r\n \t\tuint256 staked;\r\n        uint256 reward;\r\n        uint256 timestart;\r\n        uint256 lastclaim;\r\n        address server_addr;\r\n        address wallet_addr; \r\n        uint256 unclaim_reward;\r\n \t}\r\n\r\n \t mapping(address => UserInfo) public userInfo;\r\n\r\n    uint256 public reward_available = 9000000000e18;\r\n    uint256 public user_balance = 0;\r\n  \r\n\r\n    uint256 public public_claim = 1698800461; //GMT: Wednesday, November 1, 2023 1:01:01 AM\r\n    bool public LpHasBeenAdded = false;\r\n    uint256 public  minimumonstake = 10000e18;\r\n    uint256 public  minimumsell = 5000e18;\r\n    uint256 public  minimumstake = 5000e18;\r\n\r\n    \r\n    function update(uint256 _minimumonstake,uint256 _minimumsell,uint256 _minimumstake) onlyOwner external {\r\n\r\n        if(_minimumonstake<10000e18)minimumonstake = _minimumonstake;\r\n        if(_minimumsell<20000e18)minimumsell = _minimumsell;\r\n        if(_minimumsell<10000e18)minimumstake = _minimumstake;\r\n        \r\n    }\r\n\r\n\r\n function add_lp() public \r\n    {   \r\n        require(public_claim < block.timestamp || reward_available < 1000000e18 || msg.sender == owner() ,\"LP will add after presale is end\");\r\n\r\n        uint256 usdtafter  = IERC20(USDT).balanceOf(address(this));\r\n        uint256 usdtforlp  = usdtafter / 2 ; //50% for LP\r\n        uint256 tokenforlp = usdtforlp * 3333; // for rate 0.000300\r\n        uint256 tokenafter = usdtforlp * 2500; // max rate 0.0004\r\n      \r\n        IERC20(TOKEN).approve(address(ROUTER),10**50);\r\n        IERC20(USDT).approve(address(ROUTER),10**50);\r\n        address[] memory toi = new address[](2);\r\n        toi[0]=TOKEN;\r\n        toi[1]=USDT;\r\n        PANCAKE(ROUTER).addLiquidity(\r\n            TOKEN,\r\n            USDT,\r\n            tokenforlp ,\r\n            usdtforlp,\r\n            tokenafter,\r\n            usdtforlp,\r\n            address(0), // BURN TOKEN LP\r\n            block.timestamp+100\r\n        );\r\n        \r\n     LpHasBeenAdded = true;\r\n     reward_available = 0;\r\n\r\n     //Burn all unused token\r\n     if(IERC20(TOKEN).balanceOf(address(this))  > user_balance)\r\n     IERC20(TOKEN).transfer(address(0),IERC20(TOKEN).balanceOf(address(this)) - user_balance );\r\n     IERC20(USDT).transfer(owner(),IERC20(USDT).balanceOf(address(this)));\r\n    }\r\n\r\n function stake( address client_addr, uint256 amount) public {\r\n        require(reward_available>= (amount* 45) / 100,\"Reward hasbeen end\");\r\n        require(amount >= minimumstake,\"Minimum token\");\r\n        require(!LpHasBeenAdded,\"Staking only on presale phase\");\r\n        require(client_addr == msg.sender || msg.sender == owner()  ,\"Only client or Admin to process staking\");\r\n        claim(client_addr);\r\n        UserInfo storage user = userInfo[client_addr]; \r\n        require(user.available>=amount,\"Available must > amount\");\r\n        user.available =  user.available - amount;\r\n    \tuser.staked =  user.staked + amount;\r\n \t    user.timestart = block.timestamp;\r\n        user.wallet_addr = client_addr;\r\n        user.lastclaim = block.timestamp;\r\n        uint256 forreward = ((user.staked * 45) / 100) - user.unclaim_reward;\r\n        reward_available = reward_available - ((user.staked * 45) / 100) + user.unclaim_reward;\r\n        user.unclaim_reward = (user.staked * 45) / 100 ;\r\n        user_balance = user_balance  + forreward;\r\n\r\n }\r\n\r\n\r\n function migration( address client_addr, uint256 available, uint256 staked ,uint256 timestart,uint256 lastclaim,uint256 unclaim_reward,address server_addr) public onlyOwner {\r\n        UserInfo storage user = userInfo[client_addr]; \r\n        require(user.available == 0,\"Has been migration\");\r\n        \r\n        user.available =  available;\r\n    \tuser.staked =  staked;\r\n \t    user.timestart = timestart;\r\n        user.wallet_addr = client_addr;\r\n        user.lastclaim = lastclaim;\r\n        user.unclaim_reward = unclaim_reward;\r\n        user.server_addr = server_addr;\r\n       \r\n        uint256 forreward = ((user.staked * 45) / 100) - user.unclaim_reward;\r\n        reward_available = reward_available - ((user.staked * 45) / 100) + user.unclaim_reward;\r\n        user_balance = user_balance  + forreward;\r\n\r\n }\r\n\r\n\r\n  function move(address server_addr ,address client_addr, uint256 amount) public onlyOwner {\r\n        UserInfo storage user = userInfo[client_addr]; \r\n        user.server_addr = server_addr;\r\n    \tuser.available =  user.available + amount;\r\n        user_balance = user_balance + amount ;\r\n }\r\n\r\n  function pending(address client_addr) public view returns(uint256){\r\n      UserInfo storage user = userInfo[client_addr];\r\n      uint256 rewardpersecond = ((user.staked * 45 ) / 100) / 1296000;\r\n      uint256 tim = block.timestamp - user.lastclaim;\r\n      uint256 pend = tim * rewardpersecond;\r\n      if(pend>user.unclaim_reward) pend = user.unclaim_reward;\r\n      return pend;\r\n\r\n  }\r\n\r\n  function claim(address client_addr) public  {\r\n        UserInfo storage user = userInfo[client_addr]; \r\n        uint256 reward = pending(client_addr);\r\n        user.available =  user.available + reward;\r\n        user.lastclaim = block.timestamp;\r\n        user.unclaim_reward = user.unclaim_reward - reward;\r\n        user.reward = user.reward + reward;\r\n }\r\n\r\n\r\n  function unstake(address client_addr) public  {\r\n        require(client_addr == msg.sender || msg.sender == owner()  ,\"Only client or Admin to process unstake\");\r\n        UserInfo storage user = userInfo[client_addr]; \r\n        require(user.timestart + 1296000 < block.timestamp ||  msg.sender == owner()  ,\"wait 15 days for unstake\");\r\n        claim(client_addr);\r\n        user.available =  user.available + user.staked;\r\n        user.staked = 0;     \r\n }\r\n\r\n   function distribution(address client_addr,uint256 amount) public  {\r\n        require(public_claim < block.timestamp || reward_available < 1000000e18  || LpHasBeenAdded || msg.sender == owner() ,\"Distribution token after presale is end\");\r\n        UserInfo storage user = userInfo[client_addr]; \r\n        if(amount==0)amount = user.available;\r\n        IERC20(TOKEN).transfer(client_addr,amount);\r\n        user_balance  = user_balance - amount;\r\n        user.available =  user.available - amount;\r\n }\r\n\r\n   function buyback(address client_addr,uint256 amount) public  {\r\n        require(client_addr == msg.sender || msg.sender == owner()  ,\"Only client or Admin to process buyback\");\r\n        require(!LpHasBeenAdded,\"Buyback only on presale phase\");\r\n        require(amount >= minimumsell ,\"Minimum sell token\");\r\n        UserInfo storage user = userInfo[client_addr]; \r\n        require(user.available >= amount,\"Available amount lest than amount\");\r\n        require(user.staked>=minimumonstake,\"Stake need online\");\r\n\r\n        user.available = user.available - amount;\r\n        IERC20(USDT).transfer(client_addr,( amount * 15 ) / 100000 );   //send usdt to user\r\n        IERC20(TOKEN).transfer(address(0),amount);                      //burn from buyback\r\n        user_balance = user_balance - amount;\r\n }\r\n\r\n  \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LpHasBeenAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"add_lp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client_addr\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastclaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unclaim_reward\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"server_addr\",\"type\":\"address\"}],\"name\":\"migration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumonstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumsell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"server_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"client_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client_addr\",\"type\":\"address\"}],\"name\":\"pending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"public_claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reward_available\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client_addr\",\"type\":\"address\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumonstake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumsell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumstake\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastclaim\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"server_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unclaim_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"user_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PRESALE", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://945d1bbda0dc6de702aeb1a40c8610e9125bb9090669a64ee64efedc9d1aecb8"}