{"SourceCode": "pragma solidity ^0.5.7;\r\n\r\ncontract IRC20 {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ERC20 is IRC20 {\r\n\r\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show.\r\n    string public symbol;                 //An identifier: eg SBX\r\n\r\n    constructor(address _manager, uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol\r\n    ) public {\r\n        balances[_manager] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApproveForAll}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public;\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApproveForAll}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public;\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (address operator);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a {IERC721-safeTransfer}. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public returns (bytes4);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash =\r\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     */\r\n    function toPayable(address account)\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(account));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor() internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping(uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping(address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\r\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\r\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\r\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    constructor() public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(\r\n            owner != address(0),\r\n            \"ERC721: balance query for the zero address\"\r\n        );\r\n\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID.\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(\r\n            owner != address(0),\r\n            \"ERC721: owner query for nonexistent token\"\r\n        );\r\n\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            msg.sender == owner,\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721: approved query for nonexistent token\"\r\n        );\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address.\r\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * Requires the msg.sender to be the owner, approved, or operator.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public {\r\n        //solhint-disable-next-line max-line-length\r\n        require(\r\n            _isApprovedOrOwner(msg.sender, tokenId),\r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(from, to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists.\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID.\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721: operator query for nonexistent token\"\r\n        );\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner ||\r\n            getApproved(tokenId) == spender);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal {\r\n        require(\r\n            ownerOf(tokenId) == from,\r\n            \"ERC721: transfer of token that is not own\"\r\n        );\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * This function is deprecated.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal returns (bool) {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval =\r\n            IERC721Receiver(to).onERC721Received(\r\n                msg.sender,\r\n                from,\r\n                tokenId,\r\n                _data\r\n            );\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID.\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /*\r\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\r\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\r\n     *\r\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n    /**\r\n     * @dev Constructor function.\r\n     */\r\n    constructor () public {\r\n        // register the supported interface to conform to ERC721Enumerable via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\r\n     * @param owner address owning the tokens list to be accessed\r\n     * @param index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract.\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens.\r\n     * @param index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * @param to address the beneficiary that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the list of token IDs of the requested owner.\r\n     * @param owner address owning the tokens\r\n     * @return uint256[] List of token IDs owned by the requested address\r\n     */\r\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _ownedTokens[from].length--;\r\n\r\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\r\n        // lastTokenId, or just over the end of the array if the token was the last one).\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC721\r\n * Full ERC-721 Token with _autoMint function\r\n */\r\n\r\ncontract ERC721Full is ERC721, ERC721Enumerable {\r\n\r\n    uint256 public autoTokenId;\r\n\r\n    function exists(uint256 tokenId) public view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    function tokensOfOwner(address owner) public view returns (uint256[] memory) {\r\n        return _tokensOfOwner(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens with automatic ID\r\n     * @param to The address that will receive the minted tokens.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    \r\n    function _autoMint(address to) internal returns (uint256) {\r\n        do {\r\n            autoTokenId++;\r\n        } while(_exists(autoTokenId));\r\n        _mint(to, autoTokenId);\r\n        return autoTokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to transfer tokens\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param tokenId the token ID\r\n     */\r\n    function transfer(\r\n        address to,\r\n        uint256 tokenId\r\n    ) public {\r\n        _transferFrom(msg.sender, to, tokenId);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721NFTMarket\r\n * ERC-721 Marketplace\r\n */\r\n\r\ncontract ERC721NFTMarket is ERC721Full, ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    ERC20 token_to_pay;\r\n\r\n    // admin address, the owner of the marketplace\r\n    address admin;\r\n\r\n    address public contract_owner;\r\n\r\n    // commission rate is a value from 0 to 100\r\n    uint256 public commissionRate;\r\n\r\n    // last price sold\r\n    mapping(uint256 => uint256) public soldFor;\r\n    \r\n    // Mapping from token ID to sell price in Ether\r\n    mapping(uint256 => uint256) public sellBidPrice;\r\n\r\n    // Mapping payment address for tokenId \r\n    mapping(uint256 => address) private _wallets;\r\n\r\n    event Sale(uint256 indexed tokenId, address indexed from, address indexed to, uint256 value);\r\n    event Commission(uint256 indexed tokenId, address indexed to, uint256 value, uint256 rate, uint256 total);\r\n\r\n    event adminUpdated(address _owner, address _admin, uint256 _commissionRate);\r\n    event toSell(uint256 tokenId, uint256 price);\r\n\r\n    constructor(address _owner, address _admin, uint256 _commissionRate, ERC20 _token_to_pay) public \r\n        ERC721Full() {\r\n        admin = _admin;\r\n        contract_owner = _owner;\r\n        require(_commissionRate<=100, \"ERC721NFTMarket: Commission rate has to be between 0 and 100\");\r\n        commissionRate = _commissionRate;\r\n        token_to_pay = _token_to_pay;\r\n    }\r\n\r\n    function setToken(ERC20 _token) public onlyOwner {\r\n        token_to_pay = _token;\r\n    }\r\n    \r\n    function canSell(uint256 tokenId) public view returns (bool) {\r\n        return (ownerOf(tokenId)==msg.sender);\r\n    }\r\n\r\n    // Sell option for a fixed price\r\n    function sell(uint256 tokenId, uint256 price) public {\r\n\r\n        // onlyOwner\r\n        require(ownerOf(tokenId)==msg.sender, \"ERC721NFTMarket: Only owner can sell this item\");\r\n\r\n        // set sell price for index\r\n        sellBidPrice[tokenId] = price;\r\n\r\n        // If price is zero, means not for sale\r\n        if (price>0) {\r\n\r\n            // approve the Index to the current contract\r\n            approve(address(this), tokenId);\r\n            \r\n            // set wallet payment\r\n            _wallets[tokenId] = msg.sender;\r\n            \r\n        }\r\n\r\n        emit toSell(tokenId, price);\r\n\r\n    }\r\n\r\n    function canBuy(uint256 tokenId) public view returns (uint256) {\r\n        if (sellBidPrice[tokenId]>0 && sellBidPrice[tokenId]>0 && getApproved(tokenId) == address(this)) {\r\n            return sellBidPrice[tokenId];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // Buy option\r\n    function buy(uint256 tokenId) internal nonReentrant {\r\n        \r\n        // is on sale\r\n        require(sellBidPrice[tokenId]>0, \"ERC721NFTMarket: The collectible is not for sale\");\r\n\r\n        // transfer ownership\r\n        address owner = ownerOf(tokenId);\r\n\r\n        require(msg.sender!=owner, \"ERC721NFTMarket: The seller cannot buy his own collectible\");\r\n\r\n        // we need to call a transferFrom from this contract, which is the one with permission to sell the NFT\r\n        callOptionalReturn(this, abi.encodeWithSelector(this.transferFrom.selector, owner, msg.sender, tokenId));\r\n\r\n        // calculate amounts\r\n        uint256 amount4admin = sellBidPrice[tokenId].mul(commissionRate).div(100);\r\n        uint256 amount4owner = sellBidPrice[tokenId].sub(amount4admin);\r\n\r\n        // to owner\r\n        (bool success) = token_to_pay.transferFrom(msg.sender, _wallets[tokenId], amount4owner);\r\n        require(success, \"Transfer failed.\");\r\n\r\n        // to admin\r\n        (bool success2) = token_to_pay.transferFrom(msg.sender, admin, amount4admin);\r\n        require(success2, \"Transfer failed.\");\r\n        \r\n        soldFor[tokenId] = sellBidPrice[tokenId];\r\n        \r\n        // close the sell\r\n        sellBidPrice[tokenId] = 0;\r\n        _wallets[tokenId] = address(0);\r\n        \r\n\r\n        emit Sale(tokenId, owner, msg.sender, sellBidPrice[tokenId]);\r\n        emit Commission(tokenId, owner, sellBidPrice[tokenId], commissionRate, amount4admin);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC721 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC721: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC721: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC721: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n    // se agrego la edicion del contract_owner\r\n    function updateAdmin(address _owner, address _admin, uint256 _commissionRate) public onlyOwner {\r\n        require(_owner != address(0), \"Address should not be zero\");\r\n        require(_admin != address(0), \"Address should not be zero\");\r\n        require(_commissionRate<=100, \"the commission rate has to be lower or equal than 100\");\r\n        admin=_admin;\r\n        contract_owner = _owner;\r\n        commissionRate=_commissionRate;\r\n        emit adminUpdated(_owner, _admin, _commissionRate);\r\n    }\r\n    \r\n    // AGREGAR FUNCION UPDATE OWNER\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender==contract_owner, \"Only contract owner can do this\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Contract for Staking ERC-20 Tokens and pay interest on real time\r\n */\r\ncontract StakeContract is ERC721NFTMarket {\r\n\r\n    // safe uint256\r\n    using SafeMath for uint256;\r\n\r\n    // Annual Percentage Yield\r\n    uint8 public APY;\r\n\r\n    // minimum stake time in seconds, if the user withdraws before this time a penalty will be charged\r\n    uint256 public minimumStakeTime;\r\n\r\n    // the penalty, a number between 0 and 100\r\n    uint8 public penalty;\r\n\r\n    // penalties are collected and stored by the contract\r\n    uint256 private collectedPenalty;\r\n    \r\n    uint256 public limit;\r\n\r\n    // minimum amount of tokens to create a stake\r\n    uint256 public minimum;\r\n\r\n    // the Stake\r\n    struct Stake {\r\n        // opening timestamp\r\n        uint256 startDate;\r\n        // amount staked\r\n    \tuint256 amount;\r\n        // interest accrued, this will be available only after closing stake\r\n    \tuint256 interest;\r\n        // penalty charged, if any\r\n    \tuint256 penalty;\r\n        // closing timestamp\r\n    \tuint256 finishedDate;\r\n        // is closed or not\r\n    \tbool closed;\r\n    }\r\n\r\n    // stakes that the owner have    \r\n    mapping(address => Stake[]) public stakesOfOwner;\r\n    \r\n    // all accounts that have or have had stakes, this for the owner to be able to query stakes\r\n    address[] private ownersAccounts;\r\n    \r\n    event penaltyWithdrew(uint256 amount);\r\n    event stakeWithdrew(uint256 arrayIndex);\r\n    event stakeCreated(address user, uint256 amount, uint256 index);\r\n\r\n    // @param _apy: APY 0 to 100\r\n    // @param _mst: minimum stake time in seconds\r\n    // @param _penalty: the penalty percentage 0 to 100\r\n    // @_token: the ERC20 token to be used\r\n    constructor(uint8 _apy, uint256 _mst, uint8 _penalty, uint256 _minimum, uint256 _limit) public {\r\n        require(_apy<=100, \"APY has to be lower or equal than 100\");\r\n        require(_penalty<=100, \"Penalty has to be lower or equal than 100\");\r\n        APY = _apy;\r\n        minimumStakeTime = _mst;\r\n        penalty = _penalty;\r\n        limit = _limit;\r\n        minimum = _minimum;\r\n    }\r\n    \r\n    function stakesOfOwnerLength(address owner_address) public view returns (uint256) {\r\n        return stakesOfOwner[owner_address].length;\r\n    }\r\n\r\n    function modifyLimit(uint256 _newVal) external onlyOwner {\r\n        limit = _newVal;\r\n    }\r\n\r\n    function modifyMinimum(uint256 _newVal) external onlyOwner {\r\n        minimum = _newVal;\r\n    }\r\n    \r\n    // owner can change the basic parameters of the contract\r\n    // interest will be recalculated in real time for all accounts if changed\r\n    function modifyAnnualInterestRatePercentage(uint8 _newVal) external onlyOwner {\r\n        APY = _newVal;\r\n    }\r\n    function modifyMinimumStakeTime(uint256 _newVal) external onlyOwner {\r\n        minimumStakeTime = _newVal;\r\n    }\r\n    function modifyPenalty(uint8 _newVal) external onlyOwner {\r\n        penalty = _newVal;\r\n    }\r\n\r\n    // owner can query all stake accounts holders\r\n    function queryOwnersAccounts() external view onlyOwner returns (address[] memory) {\r\n    \treturn ownersAccounts;\r\n    }\r\n\r\n    function calculateInterest(address _ownerAccount, uint256 i) public view returns (uint256) {\r\n\r\n        // APY per year = amount * APY / 100 / seconds of the year\r\n        uint256 interest_per_year = stakesOfOwner[_ownerAccount][i].amount.mul(APY).div(100);\r\n\r\n        // number of seconds since opening date\r\n        uint256 num_seconds = block.timestamp.sub(stakesOfOwner[_ownerAccount][i].startDate);\r\n\r\n        // calculate interest by a rule of three\r\n        //  seconds of the year: 31536000 = 365*24*60*60\r\n        //  interest_per_year   -   31536000\r\n        //  interest            -   num_seconds\r\n        //  interest = num_seconds * interest_per_year / 31536000\r\n        return num_seconds.mul(interest_per_year).div(31536000);\r\n\r\n    }\r\n\r\n    function checkAvailableLimit(address _account) public view returns(uint256){\r\n        require(msg.sender==_account || msg.sender==contract_owner, \"You dont have permission\");\r\n        uint256 accumulated = 0;\r\n        for(uint256 i=0; i<stakesOfOwner[_account].length; i++){\r\n            if(!stakesOfOwner[_account][i].closed){\r\n                accumulated = accumulated.add(stakesOfOwner[_account][i].amount);    \r\n            }\r\n        }\r\n        \r\n        if(accumulated >= limit){\r\n            return 0;\r\n        }else{\r\n            return limit.sub(accumulated);\r\n        }\r\n    }\r\n    \r\n    function hasActiveStakes(address _account) public view returns(bool){\r\n        require(msg.sender==_account || msg.sender==contract_owner, \"You dont have permission\");\r\n        \r\n        if(checkAvailableLimit(_account) < limit){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    // anyone can create a stake\r\n    function createStake(uint256 amount) external {\r\n\r\n        require(amount >= minimum, \"The amount is too low\");\r\n\r\n        require(checkAvailableLimit(msg.sender) >= amount, \"The amount exceeds the available limit\");\r\n\r\n        // store the tokens of the user in the contract\r\n        // requires approve\r\n        uint256 real_amount = token_to_pay.balanceOf(address(this)); // we need to calculate real amount because of reflection\r\n\t\ttoken_to_pay.transferFrom(msg.sender, address(this), amount);\r\n        real_amount = token_to_pay.balanceOf(address(this)) - real_amount; // real_amount is the final balance received\r\n\r\n        // store the account of the staker in ownersAccounts if it doesnt exists\r\n\t\tif(stakesOfOwner[msg.sender].length == 0){\r\n\t\t    ownersAccounts.push(msg.sender);\r\n\t\t}\r\n\r\n        emit stakeCreated(msg.sender, real_amount, stakesOfOwner[msg.sender].length);\r\n\r\n        // create the stake\r\n        stakesOfOwner[msg.sender].push(Stake(block.timestamp, real_amount, 0, 0, 0, false));\r\n\r\n    }\r\n\r\n    // finalize the stake and pay interest or charge penalty accordingly\r\n    // arrayIndex: is the id of the stake to be finalized\r\n    function withdrawStake(uint256 arrayIndex) external nonReentrant {\r\n\r\n        // Stake should exists and opened\r\n        require(arrayIndex < stakesOfOwner[msg.sender].length, \"Stake does not exist\");\r\n        require(stakesOfOwner[msg.sender][arrayIndex].closed==false, \"This stake is closed\");\r\n        \r\n        // charge penalty if below minimum stake time\r\n        if(block.timestamp.sub(stakesOfOwner[msg.sender][arrayIndex].startDate) < minimumStakeTime){\r\n\r\n            // calculate penalty = amount * penalty / 100\r\n            uint256 the_penalty = stakesOfOwner[msg.sender][arrayIndex].amount.mul(penalty).div(100);\r\n\r\n            // remaining amount= amount - penaty\r\n            uint256 amountToWithdraw = stakesOfOwner[msg.sender][arrayIndex].amount.sub(the_penalty);\r\n            \r\n            // transfer remaining\r\n            token_to_pay.transfer(msg.sender, amountToWithdraw);\r\n\r\n            // penalty funds are hold by the contract, but keep the account of how much is it here\r\n            collectedPenalty = collectedPenalty.add(the_penalty);\r\n            \r\n            // store the results in the stakes array of the user\r\n            stakesOfOwner[msg.sender][arrayIndex].penalty = the_penalty;\r\n            stakesOfOwner[msg.sender][arrayIndex].finishedDate = block.timestamp;\r\n            stakesOfOwner[msg.sender][arrayIndex].closed = true;\r\n        \r\n        // pay interest if above or equal minimum stake time\r\n        }else{\r\n\r\n            // get the interest\r\n            uint256 interest = calculateInterest(msg.sender, arrayIndex);\r\n\r\n            // transfer the interest from owner account, it has to have enough funds approved\r\n            token_to_pay.transferFrom(contract_owner, msg.sender, interest);\r\n\r\n            // transfer the amount from the contract itself\r\n            token_to_pay.transfer(msg.sender, stakesOfOwner[msg.sender][arrayIndex].amount);\r\n            \r\n            // record the transaction\r\n            stakesOfOwner[msg.sender][arrayIndex].interest = interest;\r\n            stakesOfOwner[msg.sender][arrayIndex].finishedDate = block.timestamp;\r\n            stakesOfOwner[msg.sender][arrayIndex].closed = true;\r\n\r\n        }\r\n\r\n        emit stakeWithdrew(arrayIndex);\r\n    }\r\n\r\n    // owner can query and collect the penalty stored in the contract\r\n    function queryCollectedPenalty() external view onlyOwner returns (uint256) {\r\n    \treturn collectedPenalty;\r\n    }\r\n    \r\n    function withdrawPenalty() external onlyOwner nonReentrant {\r\n    \ttoken_to_pay.transfer(msg.sender, collectedPenalty);\r\n        emit penaltyWithdrew(collectedPenalty);\r\n    \tcollectedPenalty = 0;\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * The Catecoin Meme contract\r\n */\r\ncontract NFTCATE is StakeContract {\r\n    \r\n    uint256 public minimumtokensForPost;       // minimum tokens for post and register reward;\r\n    uint256 public minimumtokensForLike;       // minimum tokens for like;\r\n    uint256 public minimumtokensForComment;    // minimum tokens for like;\r\n\r\n    struct Meme {\r\n        bool is_nft;        // can be sold as NFT or not\r\n        uint256 nft_id;     // Minted NFT Id\r\n        address owner;      // the owner account and wallet to receive funds\r\n        bool enabled;       // enabled or not, if not enabled rewards are stopped // only admin can do this\r\n    }\r\n\r\n    // mapping memes for each post ID\r\n    mapping(uint256 => Meme) public memes;\r\n\r\n    // reward configuration\r\n    struct Reward {\r\n        uint256 amount_owner;   // amount of tokens to give as reward to meme owner\r\n        uint256 amount_sender;  // amount of tokens to give as reward to user\r\n        uint256 limit;          // minimum number of likes to get the reward\r\n    }\r\n\r\n    Reward public posting;\r\n\r\n    mapping(address => uint256[]) public owner_pending_posts;                  // pending post created for owner\r\n\r\n    // total pending rewards for users and owners\r\n    mapping(address => uint256) public total_pending_rewards;                  // user => total\r\n\r\n    mapping(uint256 => uint8) public post_rewards_status;                      // status: 0 cannot be claimed, 1 can be claimed, 2 already claimed\r\n\r\n    // Events\r\n    event BuyMeme(uint256 indexed post_id, address indexed from, address indexed to, uint256 value);\r\n    event Claim(address indexed user, bool like, bool comment, bool post, uint256[] posts);\r\n    event CreateMeme(address indexed user, uint256 indexed post_id, uint256 nft_id);\r\n    event changedRewards(uint256 new_posting_reward);\r\n    event changedIsNFT(uint256 _id, bool _is_nft);\r\n    event changedEnabled(uint256 _id, bool _enabled);\r\n\r\n    constructor(\r\n        address _owner, address _admin, uint256 _commissionRate, string memory name, string memory symbol, ERC20 _token_to_pay, \r\n        uint8 _apy, uint256 _mst, uint8 _penalty, uint256 _minimum, uint256 _limit\r\n    ) public\r\n        ERC721NFTMarket(_owner, _admin, _commissionRate, _token_to_pay) \r\n        StakeContract(_apy, _mst, _penalty, _minimum, _limit)\r\n    {}\r\n\r\n    function owner_pending_posts_length(address a) public view returns (uint256) {\r\n        return owner_pending_posts[a].length;\r\n    }\r\n\r\n    // set rewards parameters\r\n    function setRewards (uint256 _rewards_posting) public onlyOwner {\r\n        posting.amount_owner = _rewards_posting;\r\n        emit changedRewards(_rewards_posting);\r\n    }\r\n    \r\n    // mint and store the meme in the contract\r\n    function createMeme(uint256 _id, bool _is_nft, uint256 _sale_price) public {\r\n        // validations\r\n        require(token_to_pay.balanceOf(msg.sender) >= minimumtokensForPost, \"minimum tokens is required\");\r\n        require(memes[_id].nft_id == 0, \"this meme is already registered\");\r\n        require(hasActiveStakes(msg.sender), \"You need to have stakings to be able to post\");\r\n        // mint the token with an autoincrement id\r\n        uint256 tokenId = _autoMint(msg.sender);\r\n        // set the price of the meme\r\n        sell(tokenId, _sale_price);\r\n        //createMeme\r\n        memes[_id] = Meme(_is_nft, tokenId, msg.sender, true);\r\n        emit CreateMeme(msg.sender, _id, tokenId);\r\n    }\r\n    \r\n    function assignReward(uint256 _id) public onlyOwner {\r\n        // validations\r\n        require(memes[_id].nft_id > 0, \"this meme is not registered\");\r\n        require(post_rewards_status[_id] == 0, \"Reward is already set for claim or already claimed\");\r\n        // assign reward for posting to creator            \r\n        owner_pending_posts[memes[_id].owner].push(_id);\r\n        total_pending_rewards[memes[_id].owner] += posting.amount_owner;\r\n        post_rewards_status[_id] = 1;\r\n    }\r\n    \r\n    function removeReward(uint256 _id) public onlyOwner {\r\n        // validations\r\n        require(memes[_id].nft_id > 0, \"this meme is not registered\");\r\n        require(post_rewards_status[_id] == 1, \"Reward is not set for claim or already claimed\");\r\n        // remove reward for posting to creator            \r\n        // remove _id from owner_pending_posts\r\n        // owner_pending_posts[memes[_id].owner].push(_id);\r\n        uint256 i;\r\n        for(i=0; i<owner_pending_posts[memes[_id].owner].length; i++) {\r\n            if (owner_pending_posts[memes[_id].owner][i]==_id) break;\r\n        }\r\n        if (i < owner_pending_posts[memes[_id].owner].length) {\r\n            owner_pending_posts[memes[_id].owner][i] = owner_pending_posts[memes[_id].owner][owner_pending_posts[memes[_id].owner].length-1];\r\n            owner_pending_posts[memes[_id].owner].length --;\r\n            total_pending_rewards[memes[_id].owner] -= posting.amount_owner;   \r\n            post_rewards_status[_id] = 0;\r\n        }\r\n    }\r\n    \r\n    // change if the Meme can be sold as NFT or no\r\n    function changeIsNFT(uint256 _id, bool _is_nft) public {\r\n        // validations, only contract owner\r\n        require(memes[_id].nft_id > 0, \"this meme is not registered\");\r\n        require(msg.sender == contract_owner || msg.sender == memes[_id].owner, \"you do not have permission\");\r\n        memes[_id].is_nft = _is_nft;\r\n        emit changedIsNFT(_id, _is_nft);\r\n    }\r\n    \r\n    // the admin can ban an NFT for selling or not\r\n    function changeEnabled(uint256 _id, bool _enabled) public onlyOwner{\r\n        require(memes[_id].nft_id > 0, \"this meme is not registered\");        \r\n        memes[_id].enabled = _enabled;\r\n        emit changedEnabled(_id, _enabled);\r\n    }\r\n    \r\n    function changeMinimumtokensForPost(uint256 _newVal) public onlyOwner{\r\n        minimumtokensForPost = _newVal;\r\n    }\r\n\r\n    function changeMinimumtokensForLike(uint256 _newVal) public onlyOwner{\r\n        minimumtokensForLike = _newVal;\r\n    }\r\n\r\n    function changeMinimumtokensForComment(uint256 _newVal) public onlyOwner{\r\n        minimumtokensForComment = _newVal;\r\n    }\r\n\r\n    function ClaimMyRewards() public nonReentrant {\r\n        require(total_pending_rewards[msg.sender] > 0, \"There are no pending rewards\");\r\n        // transfer all the rewards to user\r\n        uint256 temp_pending_rewards = total_pending_rewards[msg.sender];\r\n        // reset total_pending_rewards\r\n        total_pending_rewards[msg.sender] = 0;\r\n        token_to_pay.transferFrom(contract_owner, msg.sender, temp_pending_rewards);\r\n        for(uint256 i=0; i<owner_pending_posts[msg.sender].length; i++){\r\n            post_rewards_status[i] = 2;\r\n        }\r\n        // if the user had posts as owner emit claim event and reset\r\n        if (owner_pending_posts[msg.sender].length>0) {\r\n            emit Claim(msg.sender, false, false, true, owner_pending_posts[msg.sender]);\r\n            owner_pending_posts[msg.sender].length = 0;\r\n        }\r\n    }\r\n    \r\n    function buyMeme(uint256 post_id) public {\r\n        require(memes[post_id].nft_id > 0, \"this meme is not registered\");\r\n        require(memes[post_id].is_nft && memes[post_id].enabled, \"is not available for buy\");\r\n        buy(memes[post_id].nft_id);\r\n        emit BuyMeme(post_id, memes[post_id].owner, msg.sender, sellBidPrice[memes[post_id].nft_id]);\r\n        memes[post_id].owner = msg.sender;\r\n    }\r\n   \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVal\",\"type\":\"uint256\"}],\"name\":\"modifyLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"penalty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sellBidPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPenalty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumStakeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arrayIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner_address\",\"type\":\"address\"}],\"name\":\"stakesOfOwnerLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_is_nft\",\"type\":\"bool\"}],\"name\":\"changeIsNFT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"memes\",\"outputs\":[{\"name\":\"is_nft\",\"type\":\"bool\"},{\"name\":\"nft_id\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"owner_pending_posts_length\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"canBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVal\",\"type\":\"uint256\"}],\"name\":\"modifyMinimumStakeTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"post_rewards_status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryCollectedPenalty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owner_pending_posts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_is_nft\",\"type\":\"bool\"},{\"name\":\"_sale_price\",\"type\":\"uint256\"}],\"name\":\"createMeme\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"checkAvailableLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVal\",\"type\":\"uint256\"}],\"name\":\"modifyMinimum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryOwnersAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVal\",\"type\":\"uint8\"}],\"name\":\"modifyPenalty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ClaimMyRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_commissionRate\",\"type\":\"uint256\"}],\"name\":\"updateAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"post_id\",\"type\":\"uint256\"}],\"name\":\"buyMeme\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"soldFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumtokensForPost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"changeEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVal\",\"type\":\"uint8\"}],\"name\":\"modifyAnnualInterestRatePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"canSell\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVal\",\"type\":\"uint256\"}],\"name\":\"changeMinimumtokensForPost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"total_pending_rewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakesOfOwner\",\"outputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"interest\",\"type\":\"uint256\"},{\"name\":\"penalty\",\"type\":\"uint256\"},{\"name\":\"finishedDate\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"assignReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVal\",\"type\":\"uint256\"}],\"name\":\"changeMinimumtokensForComment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"removeReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewards_posting\",\"type\":\"uint256\"}],\"name\":\"setRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumtokensForLike\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ownerAccount\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"calculateInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"hasActiveStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVal\",\"type\":\"uint256\"}],\"name\":\"changeMinimumtokensForLike\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"posting\",\"outputs\":[{\"name\":\"amount_owner\",\"type\":\"uint256\"},{\"name\":\"amount_sender\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumtokensForComment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"APY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_commissionRate\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"_token_to_pay\",\"type\":\"address\"},{\"name\":\"_apy\",\"type\":\"uint8\"},{\"name\":\"_mst\",\"type\":\"uint256\"},{\"name\":\"_penalty\",\"type\":\"uint8\"},{\"name\":\"_minimum\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"post_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BuyMeme\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"like\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"post\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"posts\",\"type\":\"uint256[]\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"post_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nft_id\",\"type\":\"uint256\"}],\"name\":\"CreateMeme\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"new_posting_reward\",\"type\":\"uint256\"}],\"name\":\"changedRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_is_nft\",\"type\":\"bool\"}],\"name\":\"changedIsNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"changedEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"penaltyWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"arrayIndex\",\"type\":\"uint256\"}],\"name\":\"stakeWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"stakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Sale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"Commission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_admin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_commissionRate\",\"type\":\"uint256\"}],\"name\":\"adminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"toSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]", "ContractName": "NFTCATE", "CompilerVersion": "v0.5.7+commit.6da8b019", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007f0c34fe8606cd7f5bad6857060ad2347596aeed0000000000000000000000007f0c34fe8606cd7f5bad6857060ad2347596aeed0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000e4fae3faa8300810c835970b9187c268f55d998f000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000028de8000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000011c37937e080000000000000000000000000000000000000000000000000004563918244f4000000000000000000000000000000000000000000000000000000000000000000074e4654434154450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000074e46544341544500000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a27f37de115c26bad6a86d11cfecc94ed43204cd9e33943e1b2699eed4a5c3f0"}