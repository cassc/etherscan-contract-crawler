{"SourceCode": "/*\r\n    SPDX-License-Identifier: MIT\r\n    A Bankteller Production\r\n    Bankroll Network\r\n    Copyright 2021\r\n*/\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract Token {\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n}\r\n\r\n\r\n/*\r\n * @dev Stack is a perpetual rewards contract the collects 8% fee on buys/sells for a dividend pool that drips 2% daily.\r\n * A 2% fee is paid instantly to token holders on buys/sells as well\r\n*/\r\n\r\n\r\ncontract BankrollNetworkStack  {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    /// @dev Only people with tokens\r\n    modifier onlyBagholders {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only people with profits\r\n    modifier onlyStronghands {\r\n        require(myDividends() > 0);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n\r\n    event onLeaderBoard(\r\n        address indexed customerAddress,\r\n        uint256 invested,\r\n        uint256 tokens,\r\n        uint256 soldTokens,\r\n        uint timestamp\r\n    );\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingeth,\r\n        uint256 tokensMinted,\r\n        uint timestamp\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethEarned,\r\n        uint timestamp\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethReinvested,\r\n        uint256 tokensMinted,\r\n        uint timestamp\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethWithdrawn,\r\n        uint timestamp\r\n    );\r\n\r\n\r\n    event onTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens,\r\n        uint timestamp\r\n    );\r\n\r\n    event onBalance(\r\n        uint256 balance,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onDonation(\r\n        address indexed from,\r\n        uint256 amount,\r\n        uint timestamp\r\n    );\r\n\r\n    // Onchain Stats!!!\r\n    struct Stats {\r\n        uint invested;\r\n        uint reinvested;\r\n        uint withdrawn;\r\n        uint rewarded;\r\n        uint contributed;\r\n        uint transferredTokens;\r\n        uint receivedTokens;\r\n        uint xInvested;\r\n        uint xReinvested;\r\n        uint xRewarded;\r\n        uint xContributed;\r\n        uint xWithdrawn;\r\n        uint xTransferredTokens;\r\n        uint xReceivedTokens;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n\r\n    /// @dev 15% dividends for token purchase\r\n    uint8 constant internal entryFee_ = 10;\r\n\r\n\r\n    /// @dev 5% dividends for token selling\r\n    uint8 constant internal exitFee_ = 10;\r\n\r\n    uint8 constant internal dripFee = 80;  //80% of fees go to drip, the rest to the Swap buyback\r\n\r\n    uint8 constant payoutRate_ = 2;\r\n\r\n    uint256 constant internal magnitude = 2 ** 64;\r\n\r\n    /*=================================\r\n     =            DATASETS            =\r\n     ================================*/\r\n\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) private tokenBalanceLedger_;\r\n    mapping(address => int256) private payoutsTo_;\r\n    mapping(address => Stats) private stats;\r\n    //on chain referral tracking\r\n    uint256 private tokenSupply_;\r\n    uint256 private profitPerShare_;\r\n    uint256 public totalDeposits;\r\n    uint256 internal lastBalance_;\r\n\r\n    uint public players;\r\n    uint public totalTxs;\r\n    uint public dividendBalance_;\r\n    uint public lastPayout;\r\n    uint public totalClaims;\r\n\r\n    uint256 public balanceInterval = 6 hours;\r\n    uint256 public distributionInterval = 2 seconds;\r\n\r\n    address public tokenAddress;\r\n\r\n    Token private token;\r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS           =\r\n    =======================================*/\r\n\r\n    constructor(address _tokenAddress) public {\r\n\r\n        tokenAddress = _tokenAddress;\r\n        token = Token(_tokenAddress);\r\n\r\n        lastPayout = now;\r\n\r\n    }\r\n\r\n\r\n    /// @dev This is how you pump pure \"drip\" dividends into the system\r\n    function donatePool(uint amount) public returns (uint256) {\r\n        require(token.transferFrom(msg.sender, address(this),amount));\r\n\r\n        dividendBalance_ += amount;\r\n\r\n        emit onDonation(msg.sender, amount,now);\r\n    }\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buy(uint buy_amount) public returns (uint256)  {\r\n        return buyFor(msg.sender, buy_amount);\r\n    }\r\n\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buyFor(address _customerAddress, uint buy_amount) public returns (uint256)  {\r\n        require(token.transferFrom(_customerAddress, address(this), buy_amount));\r\n        totalDeposits += buy_amount;\r\n        uint amount = purchaseTokens(_customerAddress, buy_amount);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n\r\n        return amount;\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * @dev Fallback function to return any TRX/ETH accidentally sent to the contract\r\n     */\r\n    function() payable public {\r\n        require(false);\r\n    }\r\n\r\n    /// @dev Converts all of caller's dividends to tokens.\r\n    function reinvest() onlyStronghands public {\r\n        // fetch dividends\r\n        uint256 _dividends = myDividends();\r\n        // retrieve ref. bonus later in the code\r\n\r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(msg.sender, _dividends);\r\n\r\n        // fire event\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens, now);\r\n\r\n        //Stats\r\n        stats[_customerAddress].reinvested = SafeMath.add(stats[_customerAddress].reinvested, _dividends);\r\n        stats[_customerAddress].xReinvested += 1;\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /// @dev Withdraws all of the callers earnings.\r\n    function withdraw() onlyStronghands public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends();\r\n\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n\r\n        // lambo delivery service\r\n        token.transfer(_customerAddress,_dividends);\r\n\r\n        //stats\r\n        stats[_customerAddress].withdrawn = SafeMath.add(stats[_customerAddress].withdrawn, _dividends);\r\n        stats[_customerAddress].xWithdrawn += 1;\r\n        totalTxs += 1;\r\n        totalClaims += _dividends;\r\n\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends, now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n\r\n    /// @dev Liquifies tokens to eth.\r\n    function sell(uint256 _amountOfTokens) onlyBagholders public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_amountOfTokens, exitFee_) / 100;\r\n        uint256 _taxedeth = SafeMath.sub(_amountOfTokens, _undividedDividends);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens + (_taxedeth * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n\r\n        //drip and buybacks\r\n        allocateFees(_undividedDividends);\r\n\r\n        // fire event\r\n        emit onTokenSell(_customerAddress, _amountOfTokens, _taxedeth, now);\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from the caller to a new holder.\r\n    *  Zero fees\r\n    */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders external returns (bool) {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested tokens\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        // withdraw all outstanding dividends first\r\n        if (myDividends() > 0) {\r\n            withdraw();\r\n        }\r\n\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n\r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);\r\n\r\n\r\n\r\n        /* Members\r\n            A player can be initialized by buying or receiving and we want to add the user ASAP\r\n         */\r\n        if (stats[_toAddress].invested == 0 && stats[_toAddress].receivedTokens == 0) {\r\n            players += 1;\r\n        }\r\n\r\n        //Stats\r\n        stats[_customerAddress].xTransferredTokens += 1;\r\n        stats[_customerAddress].transferredTokens += _amountOfTokens;\r\n        stats[_toAddress].receivedTokens += _amountOfTokens;\r\n        stats[_toAddress].xReceivedTokens += 1;\r\n        totalTxs += 1;\r\n\r\n        // fire event\r\n        emit onTransfer(_customerAddress, _toAddress, _amountOfTokens,now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        emit onLeaderBoard(_toAddress,\r\n            stats[_toAddress].invested,\r\n            tokenBalanceLedger_[_toAddress],\r\n            stats[_toAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =      HELPERS AND CALCULATORS        =\r\n    =====================================*/\r\n\r\n    /**\r\n     * @dev Method to view the current eth stored in the contract\r\n     */\r\n    function totalTokenBalance() public view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Retrieve the total token supply.\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /// @dev Retrieve the tokens owned by the caller.\r\n    function myTokens() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the dividends owned by the caller.\r\n     */\r\n    function myDividends() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return dividendsOf(_customerAddress);\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function tokenBalance(address _customerAddress) public view returns (uint256) {\r\n        return _customerAddress.balance;\r\n    }\r\n\r\n    /// @dev Retrieve the dividend balance of any single address.\r\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n\r\n\r\n    /// @dev Return the sell price of 1 individual token.\r\n    function sellPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n\r\n    }\r\n\r\n    /// @dev Return the buy price of 1 individual token.\r\n    function buyPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.add(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n    function calculateTokensReceived(uint256 _ethToSpend) public pure returns (uint256) {\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethToSpend, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_ethToSpend, _dividends);\r\n        uint256 _amountOfTokens = _taxedeth;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n    function calculateethReceived(uint256 _tokensToSell) public view returns (uint256) {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _eth = _tokensToSell;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n        return _taxedeth;\r\n    }\r\n\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address _customerAddress) public view returns (uint256[14] memory){\r\n        Stats memory s = stats[_customerAddress];\r\n        uint256[14] memory statArray = [s.invested, s.withdrawn, s.rewarded, s.contributed, s.transferredTokens, s.receivedTokens, s.xInvested, s.xRewarded, s.xContributed, s.xWithdrawn, s.xTransferredTokens, s.xReceivedTokens, s.reinvested, s.xReinvested];\r\n        return statArray;\r\n    }\r\n\r\n\r\n    function dailyEstimate(address _customerAddress) public view returns (uint256){\r\n        uint256 share = dividendBalance_.mul(payoutRate_).div(100);\r\n\r\n        return (tokenSupply_ > 0) ? share.mul(tokenBalanceLedger_[_customerAddress]).div(tokenSupply_) : 0;\r\n    }\r\n\r\n\r\n    function allocateFees(uint fee) private {\r\n        \r\n\r\n        // 1/5 paid out instantly\r\n        uint256 instant = fee.div(5); \r\n\r\n        if (tokenSupply_ > 0) {\r\n            // Apply instant divs\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (instant * magnitude) / tokenSupply_);\r\n        }\r\n\r\n        // Add 4/5 to dividend drip pools\r\n        dividendBalance_ += fee.safeSub(instant);\r\n    }\r\n\r\n    function distribute() private {\r\n\r\n        if (now.safeSub(lastBalance_) > balanceInterval) {\r\n            emit onBalance(totalTokenBalance(), now);\r\n            lastBalance_ = now;\r\n        }\r\n\r\n\r\n        if (SafeMath.safeSub(now, lastPayout) > distributionInterval && tokenSupply_ > 0) {\r\n\r\n            //A portion of the dividend is paid out according to the rate\r\n            uint256 share = dividendBalance_.mul(payoutRate_).div(100).div(24 hours);\r\n            //divide the profit by seconds in the day\r\n            uint256 profit = share * now.safeSub(lastPayout);\r\n            //share times the amount of time elapsed\r\n            dividendBalance_ = dividendBalance_.safeSub(profit);\r\n\r\n            //Apply divs\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (profit * magnitude) / tokenSupply_);\r\n\r\n            lastPayout = now;\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    /// @dev Internal function to actually purchase the tokens.\r\n    function purchaseTokens(address _customerAddress, uint256 _incomingeth) internal returns (uint256) {\r\n\r\n        /* Members */\r\n        if (stats[_customerAddress].invested == 0 && stats[_customerAddress].receivedTokens == 0) {\r\n            players += 1;\r\n        }\r\n\r\n        totalTxs += 1;\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_incomingeth, entryFee_) / 100;\r\n        uint256 _amountOfTokens = SafeMath.sub(_incomingeth, _undividedDividends);\r\n\r\n        // fire event\r\n        emit onTokenPurchase(_customerAddress, _incomingeth, _amountOfTokens, now);\r\n\r\n        // yes we know that the safemath function automatically rules out the \"greater then\" equation.\r\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\r\n\r\n\r\n        // we can't give people infinite eth\r\n        if (tokenSupply_ > 0) {\r\n            // add tokens to the pool\r\n            tokenSupply_ += _amountOfTokens;\r\n\r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        //drip and buybacks\r\n        allocateFees(_undividedDividends);\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        // really i know you think you do but you don't\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n\r\n\r\n        //Stats\r\n        stats[_customerAddress].invested += _incomingeth;\r\n        stats[_customerAddress].xInvested += 1;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /* @dev Subtracts two numbers, else returns zero */\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        if (b > a) {\r\n            return 0;\r\n        } else {\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"buy_amount\",\"type\":\"uint256\"}],\"name\":\"buyFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[14]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaims\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateethReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendBalance_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buy_amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"donatePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dailyEstimate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"invested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"soldTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onLeaderBoard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingeth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onDonation\",\"type\":\"event\"}]", "ContractName": "BankrollNetworkStack", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000190b589cf9fb8ddeabbfeae36a813ffb2a702454", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://d806abf0892fd307a1753128e425681882ab77bc344c7f117f16121a26c2c993"}