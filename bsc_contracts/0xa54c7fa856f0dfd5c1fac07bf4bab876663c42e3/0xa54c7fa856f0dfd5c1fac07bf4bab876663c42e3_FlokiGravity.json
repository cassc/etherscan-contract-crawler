{"SourceCode": "pragma solidity 0.5 .17;\n\n\n// SPDX-License-Identifier: MIT\n// Part: IERC20\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function totalSupply() external view returns(uint256);\n\n    function balanceOf(address who) external view returns(uint256);\n\n    function allowance(address owner, address spender)\n    external view returns(uint256);\n\n    function transfer(address to, uint256 value) external returns(bool);\n\n    function approve(address spender, uint256 value)\n    external returns(bool);\n\n    function transferFrom(address from, address to, uint256 value)\n    external returns(bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// Part: ILP\ninterface ILP {\n    function sync() external;\n}\n\n// Part: IUniswapV2Factory\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns(address);\n\n    function feeToSetter() external view returns(address);\n\n    function getPair(address tokenA, address tokenB) external view returns(address pair);\n\n    function allPairs(uint) external view returns(address pair);\n\n    function allPairsLength() external view returns(uint);\n\n    function createPair(address tokenA, address tokenB) external returns(address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n\n// Part: IUniswapV2Pair\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns(string memory);\n\n    function symbol() external pure returns(string memory);\n\n    function decimals() external pure returns(uint8);\n\n    function totalSupply() external view returns(uint);\n\n    function balanceOf(address owner) external view returns(uint);\n\n    function allowance(address owner, address spender) external view returns(uint);\n\n    function approve(address spender, uint value) external returns(bool);\n\n    function transfer(address to, uint value) external returns(bool);\n\n    function transferFrom(address from, address to, uint value) external returns(bool);\n\n    function DOMAIN_SEPARATOR() external view returns(bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns(bytes32);\n\n    function nonces(address owner) external view returns(uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns(uint);\n\n    function factory() external view returns(address);\n\n    function token0() external view returns(address);\n\n    function token1() external view returns(address);\n\n    function getReserves() external view returns(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns(uint);\n\n    function price1CumulativeLast() external view returns(uint);\n\n    function kLast() external view returns(uint);\n\n    function mint(address to) external returns(uint liquidity);\n\n    function burn(address to) external returns(uint amount0, uint amount1);\n\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n// Part: IUniswapV2Router02\ninterface IUniswapV2Router02 /*is IUniswapV2Router01*/ {\n\n    function factory() external pure returns(address);\n\n    function WETH() external pure returns(address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns(uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns(uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns(uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns(uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns(uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns(uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns(uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns(uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns(uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns(uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns(uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns(uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns(uint amountB);\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns(uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns(uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns(uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns(uint[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns(uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns(uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n// Part: Ownable\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n    address private _previousOwner;\n    uint256 private _lockTime;\n\n    event OwnershipRenounced(address indexed previousOwner);\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns(address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns(bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(_owner);\n        _owner = address(0);\n    }\n\n    function getUnlockTime() public view returns(uint256) {\n        return _lockTime;\n    }\n\n\n    //Locks the contract for owner\n    function lock() public onlyOwner {\n        _previousOwner = _owner;\n        _owner = address(0);\n        emit OwnershipRenounced(_owner);\n\n    }\n\n    function unlock() public {\n        require(_previousOwner == msg.sender, \"You don\u2019t have permission to unlock\");\n        require(now > _lockTime, \"Contract is locked until 7 days\");\n        emit OwnershipTransferred(_owner, _previousOwner);\n        _owner = _previousOwner;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// Part: SafeMath\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// Part: SafeMathInt\n/**\n * @title SafeMathInt\n * @dev Math operations for int256 with overflow safety checks.\n */\nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) << 255;\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\n\n    /**\n     * @dev Multiplies two int256 variables and fails on overflow.\n     */\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns(int256) {\n        int256 c = a * b;\n\n        // Detect overflow when multiplying MIN_INT256 with -1\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    /**\n     * @dev Division of two int256 variables and fails on overflow.\n     */\n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns(int256) {\n        // Prevent overflow when dividing MIN_INT256 by -1\n        require(b != -1 || a != MIN_INT256);\n\n        // Solidity already throws when dividing by 0.\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two int256 variables and fails on overflow.\n     */\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns(int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n        return c;\n    }\n\n    /**\n     * @dev Adds two int256 variables and fails on overflow.\n     */\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns(int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    /**\n     * @dev Converts to absolute value, and fails on overflow.\n     */\n    function abs(int256 a)\n    internal\n    pure\n    returns(int256) {\n        require(a != MIN_INT256);\n        return a < 0 ? -a : a;\n    }\n}\n\n// Part: ERC20Detailed\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns(string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns(string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns(uint8) {\n        return _decimals;\n    }\n}\n\n// File: FlokiGravity.sol\n/**\n * @title FlokiGravity ERC20 token\n * @dev\n *      Based on the Ampleforth & Safemoon protocol.\n */\ncontract FlokiGravity is ERC20Detailed, Ownable {\n    using SafeMath\n    for uint256;\n    using SafeMathInt\n    for int256;\n\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\n\n    event SwapEnabled(bool enabled);\n\n    event SwapAndLiquify(\n        uint256 threequarters,\n        uint256 sharedETH,\n        uint256 onequarter\n    );\n\n\n    // Used for authentication\n    address public master;\n\n    // LP atomic sync\n    address public lp;\n    ILP public lpContract;\n\n    modifier onlyMaster() {\n        require(msg.sender == master || msg.sender == address(this));\n        _;\n    }\n\n    // Only the owner can transfer tokens in the initial phase.\n    // This is allow the AMM listing to happen in an orderly fashion.\n\n    bool public initialDistributionFinished;\n\n    mapping(address => bool) allowTransfer;\n\n    modifier initialDistributionLock {\n        require(initialDistributionFinished || isOwner() || allowTransfer[msg.sender]);\n        _;\n    }\n\n    modifier validRecipient(address to) {\n        require(to != address(0x0));\n        require(to != address(this));\n        _;\n    }\n\n    uint256 private constant DECIMALS = 9;\n    uint256 private constant MAX_UINT256 = ~uint256(0);\n\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 10 ** 15 * 10 ** DECIMALS;\n\n    uint256 public transactionTax = 900;\n    uint256 public buybackLimit = 10 ** 18;\n    uint256 public buybackDivisor = 100;\n    uint256 public numTokensSellDivisor = 10000;\n\n    IUniswapV2Router02 public uniswapV2Router;\n    IUniswapV2Pair public uniswapV2Pair;\n    address public uniswapV2PairAddress;\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\n    address payable public marketingAddress;\n\n    bool inSwapAndLiquify;\n    bool public swapAndLiquifyEnabled = false;\n    bool public buyBackEnabled = false;\n\n    mapping(address => bool) private _isExcluded;\n\n    bool private privateSaleDropCompleted = false;\n\n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n\n\n    // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n    // Use the highest value that fits in a uint256 for max granularity.\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\n\n    // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n\n    uint256 public _maxTxAmount;\n    uint256 private _totalSupply;\n    uint256 private _gonsPerFragment;\n    mapping(address => uint256) private _gonBalances;\n\n    // This is denominated in Fragments, because the gons-fragments conversion might change before\n    // it's fully paid.\n    mapping(address => mapping(address => uint256)) private _allowedFragments;\n\n    constructor(address router, address payable _marketingAddress)\n    ERC20Detailed(\"FlokiGravity\", \"FLOKIG\", uint8(DECIMALS))\n    payable\n    public {\n        marketingAddress = _marketingAddress;\n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router);\n\n        uniswapV2PairAddress = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n\n        uniswapV2Router = _uniswapV2Router;\n\n        setLP(uniswapV2PairAddress);\n\n        IUniswapV2Pair _uniswapV2Pair = IUniswapV2Pair(uniswapV2PairAddress);\n\n        uniswapV2Pair = _uniswapV2Pair;\n\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n        _maxTxAmount = _totalSupply.div(200);\n        _gonBalances[msg.sender] = TOTAL_GONS;\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n\n        initialDistributionFinished = false;\n\n        //exclude owner and this contract from fee\n        _isExcluded[owner()] = true;\n        _isExcluded[address(this)] = true;\n\n        emit Transfer(address(0x0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @dev Notifies Fragments contract about a new rebase cycle.\n     * @param supplyDelta The number of new fragment tokens to add into circulation via expansion.\n     * @return The total number of fragments after the supply adjustment.\n     */\n    function rebase(uint256 epoch, int256 supplyDelta)\n    public\n    onlyMaster\n    returns(uint256) {\n        if (supplyDelta == 0) {\n            emit LogRebase(epoch, _totalSupply);\n            return _totalSupply;\n        }\n\n        if (supplyDelta < 0) {\n            _totalSupply = _totalSupply.sub(uint256(-supplyDelta));\n        } else {\n            _totalSupply = _totalSupply.add(uint256(supplyDelta));\n        }\n\n        if (_totalSupply > MAX_SUPPLY) {\n            _totalSupply = MAX_SUPPLY;\n        }\n\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n        lpContract.sync();\n\n        emit LogRebase(epoch, _totalSupply);\n        return _totalSupply;\n    }\n\n    function rebase_percentage(uint256 _percentage_base1000, bool reduce) external onlyMaster {\n\n        if (reduce) {\n            rebase(0, int(_totalSupply.div(1000).mul(_percentage_base1000)).mul(-1));\n        } else {\n            rebase(0, int(_totalSupply.div(1000).mul(_percentage_base1000)));\n        }\n\n    }\n\n\n    /**\n     * @notice Sets a new master\n     */\n    function setMaster(address _master)\n    external\n    onlyOwner\n    returns(uint256) {\n        master = _master;\n    }\n\n    /**\n     * @notice Sets contract LP address\n     */\n    function setLP(address _lp)\n    public\n    onlyOwner\n    returns(uint256) {\n        lp = _lp;\n        lpContract = ILP(_lp);\n    }\n\n    /**\n     * @return The total number of fragments.\n     */\n    function totalSupply()\n    external\n    view\n    returns(uint256) {\n        return _totalSupply;\n    }\n\n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n        swapAndLiquifyEnabled = _enabled;\n        emit SwapEnabled(_enabled);\n    }\n\n    /**\n     * @param who The address to query.\n     * @return The balance of the specified address.\n     */\n    function balanceOf(address who)\n    public\n    view\n    returns(uint256) {\n        return _gonBalances[who].div(_gonsPerFragment);\n    }\n\n    function transfer(address recipient, uint256 amount)\n    external\n    validRecipient(recipient)\n    initialDistributionLock\n    returns(bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    event Sender(address sender);\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n    external\n    validRecipient(recipient)\n    returns(bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowedFragments[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n\n    /**\n     * @dev Transfer tokens to a specified address.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     * @return True on success, false otherwise.\n     */\n    function _transfer(address from, address to, uint256 value)\n    private\n    validRecipient(to)\n    initialDistributionLock\n    returns(bool) {\n        require(from != address(0));\n        require(to != address(0));\n        require(value > 0);\n\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        uint256 numTokensSell = _totalSupply.div(numTokensSellDivisor);\n\n        bool overMinimumTokenBalance = contractTokenBalance >= numTokensSell;\n\n        if (from != owner() && to != owner()) {\n            require(value <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n        }\n\n        if (!inSwapAndLiquify && swapAndLiquifyEnabled && from != uniswapV2PairAddress) {\n            if (overMinimumTokenBalance) {\n                swapAndLiquify(numTokensSell);\n            }\n\n            uint256 balance = address(this).balance;\n            if (buyBackEnabled && balance > buybackLimit) {\n\n                buyBackTokens(buybackLimit.div(buybackDivisor));\n            }\n        }\n\n        _tokenTransfer(from, to, value);\n\n        return true;\n    }\n\n    function _tokenTransfer(address sender, address recipient, uint256 amount) private {\n\n        if (_isExcluded[sender] || _isExcluded[recipient]) {\n            _transferExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 amount) private {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(amount);\n        uint256 gonDeduct = amount.mul(_gonsPerFragment);\n        uint256 gonValue = tTransferAmount.mul(_gonsPerFragment);\n        _gonBalances[sender] = _gonBalances[sender].sub(gonDeduct);\n        _gonBalances[recipient] = _gonBalances[recipient].add(gonValue);\n        _takeFee(tFee);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _transferExcluded(address sender, address recipient, uint256 amount) private {\n        uint256 gonValue = amount.mul(_gonsPerFragment);\n        _gonBalances[sender] = _gonBalances[sender].sub(gonValue);\n        _gonBalances[recipient] = _gonBalances[recipient].add(gonValue);\n        emit Transfer(sender, recipient, amount);\n    }\n\n\n    function _getTValues(uint256 tAmount) private view returns(uint256, uint256) {\n        uint256 tFee = calculateFee(tAmount);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n\n    function calculateFee(uint256 _amount) private view returns(uint256) {\n        return _amount.mul(transactionTax).div(10000);\n    }\n\n    function _takeFee(uint256 tFee) private {\n        uint256 rFee = tFee.mul(_gonsPerFragment);\n        _gonBalances[address(this)] = _gonBalances[address(this)].add(rFee);\n\n    }\n\n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n        // split the contract balance into quarters\n        uint256 threequarters = contractTokenBalance.mul(3).div(4);\n        uint256 onequarter = contractTokenBalance.sub(threequarters);\n\n        // capture the contract's current ETH balance.\n        // this is so that we can capture exactly the amount of ETH that the\n        // swap creates, and not make the liquidity event include any ETH that\n        // has been manually sent to the contract\n        uint256 initialBalance = address(this).balance;\n\n        // swap tokens for ETH\n        swapTokensForEth(threequarters); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n\n        // how much ETH did we just swap into?\n        uint256 newBalance = address(this).balance.sub(initialBalance);\n\n        uint256 sharedETH = newBalance.div(3);\n\n        // add liquidity to uniswap\n        addLiquidity(onequarter, sharedETH);\n\n        // Transfer to marketing address\n        transferToAddressETH(marketingAddress, sharedETH);\n\n        emit SwapAndLiquify(threequarters, sharedETH, onequarter);\n\n    }\n\n    function buyBackTokens(uint256 amount) private lockTheSwap {\n        if (amount > 0) {\n            swapETHForTokens(amount);\n        }\n    }\n\n\n    function transferToAddressETH(address payable recipient, uint256 amount) private {\n        recipient.transfer(amount);\n    }\n\n    function() external payable {}\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp.add(300)\n        );\n\n    }\n\n    function swapETHForTokens(uint256 amount) private {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = uniswapV2Router.WETH();\n        path[1] = address(this);\n\n        // make the swap\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens.value(amount)(\n            0, // accept any amount of Tokens\n            path,\n            deadAddress, // Burn address\n            block.timestamp.add(300)\n        );\n    }\n\n\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // add the liquidity\n        uniswapV2Router.addLiquidityETH.value(ethAmount)(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            address(this),\n            block.timestamp.add(300)\n        );\n    }\n\n\n    /**\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\n     * This method should be used instead of approve() to avoid the double approval vulnerability\n     * described above.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n\n    function increaseAllowance(address spender, uint256 addedValue)\n    public\n    initialDistributionLock\n    returns(bool) {\n        _approve(msg.sender, spender, _allowedFragments[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n\n    function _approve(address owner, address spender, uint256 value) private {\n        require(owner != address(0));\n        require(spender != address(0));\n\n        _allowedFragments[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\n     * msg.sender. This method is included for ERC20 compatibility.\n     * increaseAllowance and decreaseAllowance should be used instead.\n     * Changing an allowance with this method brings the risk that someone may transfer both\n     * the old and the new allowance - if they are both greater than zero - if a transfer\n     * transaction is mined before the later approve() call is mined.\n     *\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n\n    function approve(address spender, uint256 value)\n    public\n    returns(bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n\n    /**\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\n     * @param owner_ The address which owns the funds.\n     * @param spender The address which will spend the funds.\n     * @return The number of tokens still available for the spender.\n     */\n    function allowance(address owner_, address spender)\n    public\n    view\n    returns(uint256) {\n        return _allowedFragments[owner_][spender];\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\n     *\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n    external\n    initialDistributionLock\n    returns(bool) {\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\n        if (subtractedValue >= oldValue) {\n            _allowedFragments[msg.sender][spender] = 0;\n        } else {\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\n        }\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n        return true;\n    }\n\n    function setInitialDistributionFinished()\n    external\n    onlyOwner {\n        initialDistributionFinished = true;\n    }\n\n    function enableTransfer(address _addr)\n    external\n    onlyOwner {\n        allowTransfer[_addr] = true;\n    }\n\n    function excludeAddress(address _addr)\n    external\n    onlyOwner {\n        _isExcluded[_addr] = true;\n    }\n\n    function includeAddress(address _addr)\n    external\n    onlyOwner {\n        _isExcluded[_addr] = false;\n    }\n\n    function burnAutoLP()\n    external\n    onlyOwner {\n        uint256 balance = uniswapV2Pair.balanceOf(address(this));\n        uniswapV2Pair.transfer(owner(), balance);\n    }\n\n    function airDrop(address[] calldata recipients, uint256[] calldata values)\n    external\n    onlyOwner {\n        require(recipients.length == values.length, \"Recipients and values must have the same length\");\n        for (uint256 i = 0; i < recipients.length; i++) {\n            _tokenTransfer(msg.sender, recipients[i], values[i]);\n        }\n    }\n\n    function setBuyBackEnabled(bool _enabled) public onlyOwner {\n        buyBackEnabled = _enabled;\n    }\n\n    function setBuyBackLimit(uint256 _buybackLimit) public onlyOwner {\n        buybackLimit = _buybackLimit;\n    }\n\n    function setBuyBackDivisor(uint256 _buybackDivisor) public onlyOwner {\n        buybackDivisor = _buybackDivisor;\n    }\n\n    function setnumTokensSellDivisor(uint256 _numTokensSellDivisor) public onlyOwner {\n        numTokensSellDivisor = _numTokensSellDivisor;\n    }\n\n    function clearStuckBalance(uint256 amountPercentage) external onlyOwner {\n        uint256 amountBNB = address(this).balance;\n        marketingAddress.transfer(amountBNB * amountPercentage / 100);\n    }\n\n    function setTransactionTax(uint256 _transactionTax) external onlyOwner {\n        require(_transactionTax <= 2000, \"Taxes cannot be above 20%\");\n        transactionTax = _transactionTax;\n    }\n\n    function setMaxTxAmount(uint256 maxTxAmount) external onlyOwner {\n        require(maxTxAmount >= _totalSupply / 1000);\n        _maxTxAmount = maxTxAmount;\n    }\n\n    function setMarketingAddress(address payable _marketingAddress) external onlyOwner {\n        marketingAddress = _marketingAddress;\n    }\n\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_marketingAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Sender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threequarters\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharedETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"onequarter\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"airDrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnAutoLP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyBackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buybackDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buybackLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"clearStuckBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"enableTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"excludeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"includeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialDistributionFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lpContract\",\"outputs\":[{\"internalType\":\"contract ILP\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTokensSellDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyDelta\",\"type\":\"int256\"}],\"name\":\"rebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentage_base1000\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"reduce\",\"type\":\"bool\"}],\"name\":\"rebase_percentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buybackDivisor\",\"type\":\"uint256\"}],\"name\":\"setBuyBackDivisor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setBuyBackEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buybackLimit\",\"type\":\"uint256\"}],\"name\":\"setBuyBackLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setInitialDistributionFinished\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"setLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_marketingAddress\",\"type\":\"address\"}],\"name\":\"setMarketingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_master\",\"type\":\"address\"}],\"name\":\"setMaster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transactionTax\",\"type\":\"uint256\"}],\"name\":\"setTransactionTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokensSellDivisor\",\"type\":\"uint256\"}],\"name\":\"setnumTokensSellDivisor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapV2PairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FlokiGravity", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000a722bb740cbeb7447da4366b0c0a813d49ed2e8d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}