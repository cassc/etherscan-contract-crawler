{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e., if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    // Additional properties for token name and decimals\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ncontract IYieldTrinityDicoverer {\r\n    IUniswapV2Pair IPairV2;\r\n    // IYieldTrinitySharedWallet SharedWallet;\r\n\r\n    address public usdt;\r\n    address public weth;\r\n    address payable public owner;\r\n    uint256 public snipFee = 3;\r\n\r\n    using SafeMath for uint256;\r\n\r\n    constructor(address _usdt, address _weth) {\r\n        usdt = _usdt;\r\n        weth = _weth;\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only the contract owner can call this function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function quotes(\r\n        address _router,\r\n        address _token1,\r\n        address _token2,\r\n        address _factory,\r\n        uint256 _amount\r\n    ) public view returns (uint256 currentPrice) {\r\n        if (!(hasLiquidity(_token1, _token2, _factory))) return 0;\r\n        (uint256 reserve0, uint256 reserve1) = tokensLiquidity(\r\n            _token1,\r\n            _token2,\r\n            _factory\r\n        );\r\n        return IUniswapV2Router02(_router).quote(_amount, reserve0, reserve1);\r\n    }\r\n\r\n    function quoteByPair(\r\n        address _router,\r\n        address _pair,\r\n        uint256 _amount,\r\n        address _factory\r\n    ) public view returns (uint256 currentQuote) {\r\n        (address _token1, address _token2) = getTokensFromPair(_pair);\r\n        if (!(hasLiquidity(_token1, _token2, _factory))) return 0;\r\n        address _fm = _token1;\r\n        address _to = _token2;\r\n        if (_token1 == weth) {\r\n            _fm = _token2;\r\n            _to = _token1;\r\n        }\r\n        return quotes(_router, _fm, _to, _factory, _amount);\r\n    }\r\n\r\n    function getPathForToken(address tokenIn, address tokenOut)\r\n        internal\r\n        pure\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n        return path;\r\n    }\r\n\r\n    function getLastPrice(\r\n        address _token1,\r\n        address _token2,\r\n        address _route,\r\n        address _factory\r\n    ) public view returns (uint256 lastRate) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = _token1;\r\n        path[1] = _token2;\r\n        if (!hasLiquidity(_token1, _token2, _factory)) return 0;\r\n        uint256[] memory amounts = IUniswapV2Router02(_route).getAmountsOut(\r\n            10**IERC20(_token1).decimals(),\r\n            path\r\n        );\r\n        return amounts[1];\r\n    }\r\n\r\n    function priceInToken(\r\n        address _token0,\r\n        address _token1,\r\n        address _router,\r\n        address _factory\r\n    ) public view returns (uint256 price) {\r\n        return\r\n            quotes(\r\n                _router,\r\n                _token0,\r\n                _token1,\r\n                _factory,\r\n                10**IERC20(_token0).decimals()\r\n            );\r\n    }\r\n\r\n    function priceInWETH(\r\n        address _token,\r\n        address _router,\r\n        address _factory\r\n    ) public view returns (uint256 price) {\r\n        return\r\n            quotes(\r\n                _router,\r\n                _token,\r\n                weth,\r\n                _factory,\r\n                10**IERC20(_token).decimals()\r\n            );\r\n    }\r\n\r\n    function priceInUSDT(\r\n        address _token,\r\n        address _router,\r\n        address _factory\r\n    ) public view returns (uint256 price) {\r\n        address pair = getPairAddress(_token, usdt, _factory);\r\n        if (pair == address(0)) return 0;\r\n        uint256 tokenPriceInWETH = priceInWETH(_token, _router, _factory);\r\n        uint256 wethPriceInUSDT = quotes(\r\n            _router,\r\n            weth,\r\n            usdt,\r\n            _factory,\r\n            uint256(10**18)\r\n        );\r\n        return (tokenPriceInWETH * wethPriceInUSDT) / 1e18;\r\n    }\r\n\r\n    function getLastPair(address _factory) public view returns (address pair) {\r\n        uint256 numPairs = IUniswapV2Factory(_factory).allPairsLength();\r\n        address lastPair = IUniswapV2Factory(_factory).allPairs(numPairs - 1);\r\n        return lastPair;\r\n    }\r\n\r\n    function predictFuturePrices(\r\n        address[] calldata routes,\r\n        address[] calldata path,\r\n        uint256 amountIn\r\n    ) external view returns (uint256[] memory prices) {\r\n        uint256[] memory _outputs = new uint256[](routes.length);\r\n        for (uint256 r = 0; r < routes.length; r++) {\r\n            _outputs[r] = _predictPrice(routes[r], path, amountIn);\r\n        }\r\n        return _outputs;\r\n    }\r\n\r\n    function _predictPrice(\r\n        address _route,\r\n        address[] memory path,\r\n        uint256 _amount\r\n    ) public view returns (uint256 price) {\r\n        uint256[] memory amountsOut = IUniswapV2Router02(_route).getAmountsOut(\r\n            _amount,\r\n            path\r\n        );\r\n        uint256 efAmtOut = (amountsOut[1] * 997) / 1000;\r\n        uint256[] memory amountsIn = IUniswapV2Router02(_route).getAmountsIn(\r\n            efAmtOut,\r\n            path\r\n        );\r\n        uint256 efAmtIn = (amountsIn[0] * 997) / 1000;\r\n        // Calculate the price increase\r\n        uint256 priceIncrease = (efAmtOut * 1e18) / efAmtIn - 1;\r\n        return priceIncrease;\r\n    }\r\n\r\n    function hasLiquidity(\r\n        address _token1,\r\n        address _token2,\r\n        address _factory\r\n    ) public view returns (bool hasliquidity) {\r\n        address pair = getPairAddress(_token1, _token2, _factory);\r\n        if (pair == address(0)) return false;\r\n        (uint112 reserve1, uint112 reserve2, ) = IUniswapV2Pair(pair)\r\n            .getReserves();\r\n        if (reserve1 == 0 || reserve2 == 0) return false;\r\n        return true;\r\n    }\r\n\r\n    function tokensLiquidity(\r\n        address _token1,\r\n        address _token2,\r\n        address _factory\r\n    ) public view returns (uint256 base, uint256 token) {\r\n        if (!hasLiquidity(_token1, _token2, _factory)) return (0, 0);\r\n        address pair = getPairAddress(_token1, _token2, _factory);\r\n        (uint256 reserve1, uint256 reserve2, ) = IUniswapV2Pair(pair)\r\n            .getReserves();\r\n        uint256 Base = reserve1;\r\n        uint256 Token = reserve2;\r\n        if (\r\n            keccak256(\r\n                abi.encodePacked(IERC20(IUniswapV2Pair(pair).token0()).symbol())\r\n            ) != keccak256(abi.encodePacked(IERC20(_token1).symbol()))\r\n        ) {\r\n            Base = reserve2;\r\n            Token = reserve1;\r\n        }\r\n        return (Base, Token);\r\n    }\r\n\r\n    function getTokenFromPair(address _pair)\r\n        public\r\n        view\r\n        returns (address tokenAddress, bool isValid)\r\n    {\r\n        address token0 = IUniswapV2Pair(_pair).token0();\r\n        address token1 = IUniswapV2Pair(_pair).token1();\r\n        if (token0 != weth) return (token0, true);\r\n        else if (token1 != weth) return (token1, true);\r\n        else return (address(0), false);\r\n    }\r\n\r\n    function getPairAddress(\r\n        address _token1,\r\n        address _token2,\r\n        address _factory\r\n    ) public view returns (address) {\r\n        return IUniswapV2Factory(_factory).getPair(_token1, _token2);\r\n    }\r\n\r\n    function getTokenPairReserves(address _pair, address _factory)\r\n        public\r\n        view\r\n        returns (uint256 token0Reserve, uint256 reserve1Reserve)\r\n    {\r\n        (address token0, address token1) = getTokensFromPair(_pair);\r\n        if (!hasLiquidity(token0, token1, _factory)) return (0, 0);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_pair)\r\n            .getReserves();\r\n        IERC20 tokenOne = IERC20(token0);\r\n        IERC20 tokenTwo = IERC20(token1);\r\n\r\n        if (tokenOne.decimals() < tokenTwo.decimals()) {\r\n            reserve0 = reserve0.mul(\r\n                10**(tokenTwo.decimals() - tokenOne.decimals())\r\n            );\r\n        } else if (tokenTwo.decimals() < tokenOne.decimals()) {\r\n            reserve1 = reserve1.mul(\r\n                10**(tokenOne.decimals() - tokenTwo.decimals())\r\n            );\r\n        }\r\n        return (reserve0, reserve1);\r\n    }\r\n\r\n    function getTokensFromPair(address _pair)\r\n        public\r\n        view\r\n        returns (address token0, address token1)\r\n    {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(_pair);\r\n        return (pair.token0(), pair.token1());\r\n    }\r\n\r\n    function getRouteOutputs(\r\n        address[] calldata routes,\r\n        address[] calldata path,\r\n        uint256 amountIn\r\n    ) public view returns (uint256[] memory outputs) {\r\n        uint256[] memory _outputs = new uint256[](routes.length);\r\n        for (uint256 r = 0; r < routes.length; r++) {\r\n            _outputs[r] = _getRouteOutput(routes[r], path, amountIn);\r\n        }\r\n        return (_outputs);\r\n    }\r\n\r\n    function _getRouteOutput(\r\n        address route,\r\n        address[] calldata path,\r\n        uint256 amountIn\r\n    ) public view returns (uint256) {\r\n        uint256[] memory dex1 = IUniswapV2Router02(route).getAmountsOut(\r\n            amountIn,\r\n            path\r\n        );\r\n        uint256 dexOneOut = dex1[path.length - 1];\r\n        return (dexOneOut);\r\n    }\r\n\r\n    function priceImpacts(\r\n        address _token0,\r\n        address _token1,\r\n        address[] memory _fatories,\r\n        uint256 amount\r\n    ) public view returns (uint256[] memory impacts) {\r\n        uint256[] memory _outputs = new uint256[](_fatories.length);\r\n        for (uint256 r = 0; r < _fatories.length; r++) {\r\n            _outputs[r] = _priceImpact(_token0, _token1, _fatories[r], amount);\r\n        }\r\n        return (_outputs);\r\n    }\r\n\r\n    function _priceImpact(\r\n        address _token0,\r\n        address _token1,\r\n        address _factory,\r\n        uint256 amount\r\n    ) public view returns (uint256 impact) {\r\n        uint256 decimals = IERC20(_token0).decimals();\r\n        (uint256 reserveA, uint256 reserveB) = tokensLiquidity(\r\n            _token0,\r\n            _token1,\r\n            _factory\r\n        );\r\n        uint256 amountWithDecimals = (amount * 10**decimals);\r\n        uint256 numerator = (amountWithDecimals * 100);\r\n        uint256 denominator = (reserveA + amountWithDecimals);\r\n        uint256 _impact = (numerator / denominator);\r\n        return _impact;\r\n    }\r\n\r\n    function _swap(\r\n        address[] memory _path,\r\n        uint256 _amountIn,\r\n        uint256 _minAmountOut,\r\n        address _router,\r\n        uint256 _deadline,\r\n        bool _isMultipath\r\n    ) public payable returns (uint256 _fee) {\r\n        IUniswapV2Router02 Router = IUniswapV2Router02(_router);\r\n        uint256 deadline = block.timestamp + _deadline;\r\n        uint256 outputAmount = _minAmountOut;\r\n        uint256 fee = (_minAmountOut * snipFee) / 100;\r\n\r\n        if (_path[0] == Router.WETH()) {\r\n            Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n                value: msg.value\r\n            }(_minAmountOut, _path, address(this), deadline);\r\n        } else if (_path[_path.length - 1] == Router.WETH()) {\r\n            IERC20(_path[0]).approve(_router, _amountIn);\r\n            _isMultipath ||\r\n                IERC20(_path[0]).transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _amountIn\r\n                );\r\n            Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                _amountIn,\r\n                _minAmountOut,\r\n                _path,\r\n                address(this),\r\n                deadline\r\n            );\r\n        } else {\r\n            IERC20(_path[0]).approve(_router, _amountIn);\r\n            _isMultipath ||\r\n                IERC20(_path[0]).transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _amountIn\r\n                );\r\n            Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                _amountIn,\r\n                _minAmountOut,\r\n                _path,\r\n                address(this),\r\n                deadline\r\n            );\r\n        }\r\n\r\n        require(outputAmount >= (_minAmountOut), \"Minoutput <\");\r\n        return fee;\r\n    }\r\n\r\n    function swap(\r\n        address[] memory _path,\r\n        uint256 _amountIn,\r\n        uint256 _minAmountOut,\r\n        address _router,\r\n        uint256 _deadline\r\n    ) public payable {\r\n        IUniswapV2Router02 Router = IUniswapV2Router02(_router);\r\n        uint256[] memory _final = new uint256[](1);\r\n        if (msg.value > 0) {} else {\r\n            _final[0] = _swap(\r\n                _path,\r\n                _amountIn,\r\n                _minAmountOut,\r\n                _router,\r\n                _deadline,\r\n                false\r\n            );\r\n\r\n            if (_path[0] == Router.WETH()) {\r\n                IERC20(_path[_path.length - 1]).transfer(\r\n                    msg.sender,\r\n                    _minAmountOut - _final[0]\r\n                );\r\n            } else if (_path[_path.length - 1] == Router.WETH()) {\r\n                payable(msg.sender).transfer(_minAmountOut - _final[0]);\r\n            }\r\n        }\r\n    }\r\n\r\n    struct locals {\r\n        address[] tradePaths;\r\n    }\r\n\r\n    function multiPathSwap(\r\n        address[] calldata _paths,\r\n        uint256[] calldata _pathLengths,\r\n        address[] calldata _routes,\r\n        uint256[] calldata _inputes,\r\n        uint256[] calldata _minOutputs,\r\n        uint256 _deadline\r\n    ) public payable {\r\n        if (msg.value > 0) {} else {\r\n            uint256[] memory _final = new uint256[](_routes.length);\r\n            uint256 _startPoint = 0;\r\n            locals memory local;\r\n            local.tradePaths = _paths;\r\n            for (uint256 index = 0; index < _routes.length; index++) {\r\n                address[] memory _path = new address[](_pathLengths[index]);\r\n                for (uint256 iPath = 0; iPath < _path.length; iPath++) {\r\n                    _path[iPath] = local.tradePaths[iPath + _startPoint];\r\n                }\r\n                _final[index] = _swap(\r\n                    _path,\r\n                    _inputes[index],\r\n                    _minOutputs[index],\r\n                    _routes[index],\r\n                    _deadline,\r\n                    true\r\n                );\r\n                _startPoint += _pathLengths[index];\r\n            }\r\n            uint256 _payable = _minOutputs[_minOutputs.length - 1].sub(\r\n                _final[_final.length - 1]\r\n            );\r\n\r\n            //Settlement\r\n            if (_paths[local.tradePaths.length - 1] == weth)\r\n                payable(msg.sender).transfer(_payable);\r\n            else\r\n                IERC20(_paths[local.tradePaths.length - 1]).transfer(\r\n                    msg.sender,\r\n                    _payable\r\n                );\r\n            delete local.tradePaths;\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function rev() external {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function setSnippingFee(uint256 _fee) public onlyOwner {\r\n        snipFee = _fee;\r\n    }\r\n\r\n    function tkn(address token) external {\r\n        IERC20(token).transfer(\r\n            msg.sender,\r\n            IERC20(token).balanceOf(address(this))\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"route\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"_getRouteOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_route\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_predictPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_priceImpact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"impact\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isMultipath\",\"type\":\"bool\"}],\"name\":\"_swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"getLastPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_route\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"getLastPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"getPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"routes\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getRouteOutputs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"outputs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"getTokenFromPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"getTokenPairReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token0Reserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Reserve\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"getTokensFromPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"hasLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasliquidity\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_paths\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_pathLengths\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_routes\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_inputes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_minOutputs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"multiPathSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"routes\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"predictFuturePrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_fatories\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"priceImpacts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"impacts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"priceInToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"priceInUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"priceInWETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"quoteByPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentQuote\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"quotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setSnippingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snipFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tkn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"tokensLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "IYieldTrinityDicoverer", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ff0a6e7e326d05425c7b8e43bc964aea4191484f3963834cfe7bdf1aaaa6cb6e"}