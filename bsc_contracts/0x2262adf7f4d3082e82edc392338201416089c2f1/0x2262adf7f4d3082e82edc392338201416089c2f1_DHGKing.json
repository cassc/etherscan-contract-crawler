{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DHGKing.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\r\\npragma solidity ^0.8.0;\\r\\ninterface IRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\r\\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\r\\n}\\r\\ninterface IFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address uniswapPair);\\r\\n}\\r\\ninterface IPair {\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n}\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    uint256 private _totalSupply;\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    constructor (string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\r\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\r\\n        return true;\\r\\n    }\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n        return true;\\r\\n    }\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n        _move(sender, recipient, amount);\\r\\n        _afterTokenTransfer(sender, recipient, amount);\\r\\n    }\\r\\n    function _move(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        uint256 senderBalance = _balances[sender];\\r\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[sender] = senderBalance - amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _balances[account] = accountBalance - amount;\\r\\n        _totalSupply -= amount;\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\r\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\r\\n}\\r\\n\\r\\nabstract contract ReentrancyGuard {\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n    uint256 private _status;\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n    modifier nonReentrant() {\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n        _status = _ENTERED;\\r\\n        _;\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract system is Ownable {\\r\\n    receive() external payable {}\\r\\n    fallback() external payable {}\\r\\n    function rescueLossToken(IERC20 token_, address _recipient) external onlyOwner {token_.transfer(_recipient, token_.balanceOf(address(this)));}\\r\\n    function rescueLossChain(address payable _recipient) external onlyOwner {_recipient.transfer(address(this).balance);}\\r\\n    function rescueLossTokenWithAmount(IERC20 token_, address _recipient, uint256 amount) external onlyOwner {token_.transfer(_recipient, amount);}\\r\\n    function rescueLossChainWithAmount(address payable _recipient, uint256 amount) external onlyOwner {_recipient.transfer(amount);}\\r\\n}\\r\\nabstract contract BotKiller is Context, Ownable {\\r\\n    mapping(address => bool) botList;\\r\\n    modifier onlyNotBot(address user) {\\r\\n        require(!botList[user], \\\"address forbid\\\");\\r\\n        _;\\r\\n    }\\r\\n    function _markBot(address addr, bool b) internal {botList[addr] = b;}\\r\\n    function markBot(address addr, bool b) public onlyOwner {_markBot(addr, b);}\\r\\n    function markBots(address[] memory addr, bool b) public onlyOwner {\\r\\n        for (uint i = 0; i < addr.length; i++) {\\r\\n            _markBot(addr[i], b);\\r\\n        }\\r\\n    }\\r\\n    function isBot(address addr) public view returns (bool) {return botList[addr];}\\r\\n}\\r\\ncontract DHGKing is ERC20, ReentrancyGuard, Ownable, system, BotKiller {\\r\\n    address public uniswapPair;\\r\\n    mapping(address => address) public relationship;\\r\\n    IRouter uniswapV2Router;\\r\\n    mapping(address => bool) private isExcludeFee;\\r\\n    bool public inSwap = true;\\r\\n    address marketAddress;\\r\\n    address liquidityAddress;\\r\\n    address returnAddress;\\r\\n    address devEthAddress;\\r\\n    address devDogeAddress;\\r\\n    address DogeContract = 0xbA2aE424d960c26247Dd6c32edC70B295c744C43;\\r\\n    address router_ = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    uint256 dogeSwapThreshold = 0.3 ether;\\r\\n    uint256 dogePrizeThreshold = 5000 ether;\\r\\n    mapping(address => bool) isInDogePrizeList;\\r\\n    address[] dogePrizeList;\\r\\n    uint256 swapThreshold = 0.3 ether;\\r\\n    uint256 divBase = 1e3;\\r\\n    bool botCheck = true;\\r\\n    uint256 limitTimeBefore;\\r\\n    uint256 limitBuyAmount = 2000 ether;\\r\\n    uint256 limitSeconds = 5 * 60;\\r\\n    uint256 burnRate = 100;\\r\\n    event DistributeDogeToken(address user, uint256 dogeAmount);\\r\\n    constructor(address[] memory addrs) ERC20(\\\"DHG King\\\", \\\"DHGKing\\\") {\\r\\n        isExcludeFee[owner()] = true;\\r\\n        isExcludeFee[router_] = true;\\r\\n        isExcludeFee[address(this)] = true;\\r\\n        initIRouter();\\r\\n        initAddrs(addrs);\\r\\n        super._mint(liquidityAddress, 5e5 ether + 5000 ether);\\r\\n        super._mint(owner(), 5e5 ether - 5000 ether);\\r\\n        _approve(address(this), address(uniswapV2Router), ~uint256(0));\\r\\n        _approve(owner(), address(uniswapV2Router), ~uint256(0));\\r\\n    }\\r\\n    function swapStart(bool b) public onlyOwner {\\r\\n        inSwap = b;\\r\\n    }\\r\\n    function closeBotCheck() public onlyOwner {\\r\\n        botCheck = false;\\r\\n    }\\r\\n    function closeBotCheckAndPause() public onlyOwner {\\r\\n        inSwap = false;\\r\\n        botCheck = false;\\r\\n    }\\r\\n    function swapStartAndBuyLimit() public onlyOwner {\\r\\n        inSwap = true;\\r\\n        limitTimeBefore = block.timestamp + limitSeconds;\\r\\n    }\\r\\n    function excludeFee(address[] memory addr, bool b) public onlyOwner {\\r\\n        for (uint i = 0; i < addr.length; i++) {\\r\\n            isExcludeFee[addr[i]] = b;\\r\\n        }\\r\\n    }\\r\\n    function initAddrs(address[] memory addrs) private {\\r\\n        excludeFee(addrs, true);\\r\\n        devDogeAddress = addrs[0];\\r\\n        devEthAddress = addrs[1];\\r\\n        marketAddress = addrs[2];\\r\\n        returnAddress = addrs[3];\\r\\n        liquidityAddress = addrs[4];\\r\\n    }\\r\\n    function initIRouter() private {\\r\\n        uniswapV2Router = IRouter(router_);\\r\\n        uniswapPair = IFactory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\\r\\n        isExcludeFee[uniswapPair] = true;\\r\\n    }\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual override onlyNotBot(from) onlyNotBot(to) {\\r\\n        uint256 feeAmount;\\r\\n        if (uniswapPair == from) {\\r\\n            require(inSwap || isExcludeFee[to], \\\"please waiting pool start\\\");\\r\\n            if (botCheck && !isExcludeFee[to]) _markBot(to, true);\\r\\n            else if (block.timestamp < limitTimeBefore) {\\r\\n                uint256 totalBalance = balanceOf(to) + amount;\\r\\n                require(totalBalance <= limitBuyAmount, \\\"exceed amount of limit\\\");\\r\\n            }\\r\\n            if (!isExcludeFee[to]) {\\r\\n                feeAmount = amount * 100 / divBase;\\r\\n                super._move(from, address(this), feeAmount);\\r\\n                handDogeFees(amount);\\r\\n            }\\r\\n        } else if (uniswapPair == to) {\\r\\n            require(inSwap || isExcludeFee[from], \\\"please waiting pool start\\\");\\r\\n            if (block.timestamp < limitTimeBefore) require(amount <= limitBuyAmount, \\\"exceed amount of 2000\\\");\\r\\n            if (!isExcludeFee[from]) {\\r\\n                bool swapped = handSwap();\\r\\n                feeAmount = amount * 100 / divBase;\\r\\n                super._move(from, address(this), feeAmount);\\r\\n                if (!swapped) distributeDogeToken();\\r\\n                handDogeFees(amount);\\r\\n            }\\r\\n        } else {\\r\\n            if (!isExcludeFee[from] && !isExcludeFee[to]) {\\r\\n                feeAmount = amount * burnRate / divBase;\\r\\n                super._move(from, 0x000000000000000000000000000000000000dEaD, feeAmount);\\r\\n            }\\r\\n        }\\r\\n        super._transfer(from, to, amount - feeAmount);\\r\\n    }\\r\\n    function distributeDogeToken() private {\\r\\n        uint256 total = balanceOf(address(this));\\r\\n        if (total == 0) return;\\r\\n        uint256 amountDesire = dogePoolTotal;\\r\\n        if (amountDesire == 0) return;\\r\\n        if (amountDesire > total) amountDesire = total;\\r\\n        (uint112 WETHAmount, uint112 TOKENAmount) = getPoolInfo();\\r\\n        if (WETHAmount * amountDesire / TOKENAmount > dogeSwapThreshold) {\\r\\n            dogePoolTotal = 0;\\r\\n            swapTokensForDoge(amountDesire);\\r\\n            aliasDoge();\\r\\n        }\\r\\n    }\\r\\n    function aliasDoge() private {\\r\\n        IERC20 token = IERC20(DogeContract);\\r\\n        uint256 dogeAmount = token.balanceOf(address(this));\\r\\n        if (dogeAmount == 0) return;\\r\\n        uint256 prize = 750 * dogeAmount / divBase;\\r\\n        if (dogePrizeList.length == 0) return;\\r\\n        uint256 amount = getTotalBalanceForPrize();\\r\\n        for (uint i = 0; i < dogePrizeList.length; i++) {\\r\\n            uint256 dogePrizePerUser = prize * balanceOf(dogePrizeList[i]) / amount;\\r\\n            token.transfer(dogePrizeList[i], dogePrizePerUser);\\r\\n            emit DistributeDogeToken(dogePrizeList[i], dogePrizePerUser);\\r\\n        }\\r\\n        token.transfer(devDogeAddress, token.balanceOf(address(this)));\\r\\n    }\\r\\n    function getTotalBalanceForPrize() private view returns (uint256 amount) {\\r\\n        for (uint i = 0; i < dogePrizeList.length; i++) {\\r\\n            amount += balanceOf(dogePrizeList[i]);\\r\\n        }\\r\\n        return amount;\\r\\n    }\\r\\n    function swapTokensForDoge(uint256 tokenAmount) private {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n        path[2] = DogeContract;\\r\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    function getDogePrizeListLength() public view returns (uint256) {\\r\\n        return dogePrizeList.length;\\r\\n    }\\r\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\r\\n        dogePrizeHandler(from);\\r\\n        dogePrizeHandler(to);\\r\\n    }\\r\\n    function dogePrizeHandler(address user) private {\\r\\n        if (uniswapPair == user) return;\\r\\n        uint256 balance = super.balanceOf(user);\\r\\n        if (balance >= dogePrizeThreshold) {\\r\\n            if (!isInDogePrizeList[user]) {\\r\\n                isInDogePrizeList[user] = true;\\r\\n                dogePrizeList.push(user);\\r\\n            }\\r\\n        } else {\\r\\n            if (isInDogePrizeList[user]) {\\r\\n                isInDogePrizeList[user] = false;\\r\\n                for (uint i = 0; i < dogePrizeList.length; i++) {\\r\\n                    if (dogePrizeList[i] == user) {\\r\\n                        dogePrizeList[i] = dogePrizeList[dogePrizeList.length - 1];\\r\\n                        dogePrizeList.pop();\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    uint256 public dogePoolTotal;\\r\\n    function handDogeFees(uint256 amount) private {\\r\\n        uint256 feePoolAmount = amount * 40 / divBase;\\r\\n        dogePoolTotal += feePoolAmount;\\r\\n    }\\r\\n    function handSwap() private returns (bool) {\\r\\n        uint256 total = balanceOf(address(this));\\r\\n        if (total == 0) return false;\\r\\n        if (dogePoolTotal > total) dogePoolTotal = total;\\r\\n        uint256 amountDesireTotal = (total - dogePoolTotal);\\r\\n        if (amountDesireTotal == 0) return false;\\r\\n        uint256 amountDesire = amountDesireTotal * 750 / divBase;\\r\\n        (uint112 WETHAmount, uint112 TOKENAmount) = getPoolInfo();\\r\\n        if (WETHAmount * amountDesire / TOKENAmount >= swapThreshold) {\\r\\n            if (address(this).balance > 0) payable(devEthAddress).transfer(address(this).balance);\\r\\n            _handSwap(amountDesire, address(this));\\r\\n            _distributeEth(amountDesireTotal - amountDesire);\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n    function _distributeEth(uint256 tokenLiquidityAmount) private {\\r\\n        uint256 ethLiquidityAmount = address(this).balance / 3;\\r\\n        uniswapV2Router.addLiquidityETH{value : ethLiquidityAmount}(\\r\\n            address(this),\\r\\n            tokenLiquidityAmount,\\r\\n            0,\\r\\n            0,\\r\\n            returnAddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n        payable(marketAddress).transfer(address(this).balance / 2);\\r\\n        payable(devEthAddress).transfer(address(this).balance);\\r\\n    }\\r\\n    function _handSwap(uint256 amountDesire, address to) private nonReentrant {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(amountDesire, 0, path, to, block.timestamp);\\r\\n    }\\r\\n    function getPoolInfo() private view returns (uint112 WETHAmount, uint112 TOKENAmount) {\\r\\n        (uint112 _reserve0, uint112 _reserve1,) = IPair(uniswapPair).getReserves();\\r\\n        WETHAmount = _reserve1;\\r\\n        TOKENAmount = _reserve0;\\r\\n        if (IPair(uniswapPair).token0() == uniswapV2Router.WETH()) {\\r\\n            WETHAmount = _reserve0;\\r\\n            TOKENAmount = _reserve1;\\r\\n        }\\r\\n    }\\r\\n    function airdrop(uint256 amount, address[] memory to) public {\\r\\n        for (uint i = 0; i< to.length; i++) {\\r\\n            super._move(_msgSender(), to[i], amount);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dogeAmount\",\"type\":\"uint256\"}],\"name\":\"DistributeDogeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeBotCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeBotCheckAndPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dogePoolTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"excludeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDogePrizeListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"markBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"markBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relationship\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescueLossChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueLossChainWithAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescueLossToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueLossTokenWithAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"swapStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapStartAndBuyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DHGKing", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000fca79272575e4d03bca9d68fea00165fa05cc6b7000000000000000000000000e6d328717fb04cb982498f689ad783df3dcbf974000000000000000000000000ee770e3ad6382bd07e798abf732cf2331042ebe20000000000000000000000007ec8a6f041fb10a19da685f2cfa210c9cb1543d60000000000000000000000001baad2bb7f33e040960c36de670715fd7d7235ee0000000000000000000000003ba8903ca9a58241678686335aab5d4b4ac8ec370000000000000000000000004b2fbf1ce33c0cc5041d90a129e267fb5cd76e2e0000000000000000000000002a2f7afec64de745902cafea8bb7922d5a1fa70600000000000000000000000048cc50337ea1c3f2c78809ceee14d3a996ff49080000000000000000000000007a7168943c30ba583420ca2271467c12c8399b35000000000000000000000000de4a11648bd50369ba2c286d829f7a46dcb759ac0000000000000000000000007e9928bd4d36dabdc2159d24b98d058b266e5c8b00000000000000000000000028b8f8e4f1a27e13cf55b6113c4d02ca503b2139000000000000000000000000f056a4107e93db50282c3bb12fefa2ef6c6c5b940000000000000000000000009c746a7c0558925d1e5a3bc199c41851ee4ced2f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}