{"SourceCode": "// File: @openzeppelin/contracts/utils/math/Math.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: contracts/Glutech.sol\r\n\r\n//SPDX-License-Identifier: Unlicense\r\npragma solidity 0.8.9;\r\n\r\n\r\n\r\ncontract StakingBot is ReentrancyGuard {\r\n    struct StakingPlan {\r\n        uint256 minStakeAmount;\r\n        uint256 maxStakeAmount;\r\n        uint256 dailyROI;\r\n        uint256 stakingPeriod;\r\n        uint256 totalStaked;\r\n        uint256 totalPayouts;\r\n    }\r\n\r\n    struct Staking {\r\n        uint256 rewardDebt;\r\n        uint256 totalInvestments;\r\n        uint256 amount;\r\n        uint256 initialTime;\r\n        uint256 earningStartTime;\r\n        uint256 totalWithdrawal;\r\n        uint256 lockEndTime;\r\n    }\r\n\r\n    struct User {\r\n        uint256 referralDebt;\r\n        uint256 teamSalesDebt;\r\n        uint256 lastTeamHarvest;\r\n        uint256 totalInvestments;\r\n        address referrer;\r\n        mapping(uint256 => Staking) stakings;\r\n        uint256 currentRank;\r\n        uint256 totalDirectReferrals;\r\n        uint256 totalCommissionEarned;\r\n        address[] referrals;\r\n        uint256 totalTeam;\r\n        uint256 leadershipScore;\r\n    }\r\n\r\n    struct LeadershipRank {\r\n        uint256 weeklyEarnings;\r\n        uint256 directReferrals;\r\n        uint256 teamVolume;\r\n        uint256 investments;\r\n    }\r\n\r\n    address payable public immutable admin;\r\n    address payable public immutable liquiditySupportBot;\r\n\r\n    uint16 private constant HARVEST_FEE_PERCENTAGE = 300; // in percentage\r\n    uint16 private constant PENALTY_PERCENTAGE = 2500; // in percentage\r\n    uint16 private constant REFERRAL_LEVELS = 10;\r\n    uint16 public constant LIQUIDITY_SUPPORT_PERCENTAGE = 3000; // 30%\r\n\r\n    mapping(uint256 => LeadershipRank) public leadershipRanks;\r\n    mapping(uint256 => StakingPlan) public stakingPlans;\r\n    mapping(uint256 => uint256) public referralLevels;\r\n    mapping(address => uint256) public referralCounts;\r\n    mapping(address => address) private referrals;\r\n    mapping(address => User) public users;\r\n\r\n    uint256 public immutable contractInitializedAt;\r\n    uint256 public totalTeams = 0;\r\n\r\n    event Staked(address indexed staker, uint256 amount);\r\n    event ReleaseBotSupport(uint256 amount);\r\n    event Unstaked(address indexed staker, uint256 amount);\r\n    event Harvested(address indexed staker, uint256 amount);\r\n    event ReferralRecorded(address indexed user, address indexed referrer);\r\n    event ReferralEarningsReceived(address indexed user, uint256 amount);\r\n    event PenaltyCharged(address indexed offender, uint256 amount);\r\n\r\n    modifier validPlanId(uint256 planId) {\r\n        require(planId >= 1 && planId <= 3, \"Invalid plan ID\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address payable adminAdd,\r\n        address payable liquiditySupportBotAddress\r\n    ) {\r\n        require(\r\n            adminAdd != address(0) && liquiditySupportBotAddress != address(0)\r\n        );\r\n        admin = adminAdd;\r\n        liquiditySupportBot = liquiditySupportBotAddress;\r\n        contractInitializedAt = block.timestamp;\r\n\r\n        // Initialize referral levels\r\n        referralLevels[1] = 1000;\r\n        referralLevels[2] = 700;\r\n        referralLevels[3] = 500;\r\n        referralLevels[4] = 300;\r\n        referralLevels[5] = 200;\r\n        referralLevels[6] = 200;\r\n        referralLevels[7] = 200;\r\n        referralLevels[8] = 50;\r\n        referralLevels[9] = 50;\r\n        referralLevels[10] = 50;\r\n\r\n        leadershipRanks[1] = LeadershipRank(\r\n            0.18 ether,\r\n            5,\r\n            18.01 ether,\r\n            0.36 ether\r\n        );\r\n        leadershipRanks[2] = LeadershipRank(\r\n            0.36 ether,\r\n            7,\r\n            36 ether,\r\n            0.36 ether\r\n        );\r\n        leadershipRanks[3] = LeadershipRank(\r\n            0.90 ether,\r\n            10,\r\n            72.05 ether,\r\n            1.80 ether\r\n        );\r\n        leadershipRanks[4] = LeadershipRank(\r\n            1.8 ether,\r\n            20,\r\n            180.14 ether,\r\n            3.60 ether\r\n        );\r\n        leadershipRanks[5] = LeadershipRank(\r\n            7.21 ether,\r\n            20,\r\n            360.27 ether,\r\n            10.7959 ether\r\n        );\r\n        leadershipRanks[6] = LeadershipRank(\r\n            18.01 ether,\r\n            20,\r\n            900.69 ether,\r\n            18 ether\r\n        );\r\n        leadershipRanks[7] = LeadershipRank(\r\n            36.03 ether,\r\n            20,\r\n            3602.74 ether,\r\n            36 ether\r\n        );\r\n\r\n        // Initialize staking plans\r\n        stakingPlans[1] = StakingPlan(\r\n            0.033 ether,\r\n            1663.22 ether,\r\n            200,\r\n            5 days,\r\n            0,\r\n            0\r\n        );\r\n        stakingPlans[2] = StakingPlan(\r\n            0.033 ether,\r\n            1663.22 ether,\r\n            250,\r\n            15 days,\r\n            0,\r\n            0\r\n        );\r\n        stakingPlans[3] = StakingPlan(\r\n            0.033 ether,\r\n            1663.22 ether,\r\n            260,\r\n            30 days,\r\n            0,\r\n            0\r\n        );\r\n    }\r\n\r\n    function teamEarnings(address userAddress) public view returns (uint256) {\r\n        User storage user = users[userAddress];\r\n\r\n        if (user.currentRank == 0 || user.lastTeamHarvest == 0) {\r\n            return 0;\r\n        }\r\n\r\n        LeadershipRank memory leadershipRank = leadershipRanks[\r\n            user.currentRank\r\n        ];\r\n        uint256 weeklyEarnings = leadershipRank.weeklyEarnings;\r\n\r\n        uint256 lastHarvestWeek = user.lastTeamHarvest / 1 weeks;\r\n        uint256 currentWeek = block.timestamp / 1 weeks;\r\n        uint256 elapsedWeeks = currentWeek - lastHarvestWeek;\r\n\r\n        if (elapsedWeeks == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 pendingReward = elapsedWeeks * weeklyEarnings;\r\n\r\n        return pendingReward;\r\n    }\r\n\r\n    function getRewards(\r\n        address userAddress,\r\n        uint256 planId\r\n    ) public view validPlanId(planId) returns (uint256) {\r\n        Staking storage staking = users[userAddress].stakings[planId];\r\n\r\n        if (staking.amount == 0) {\r\n            return staking.rewardDebt;\r\n        }\r\n\r\n        StakingPlan storage stakingPlan = stakingPlans[planId];\r\n        uint256 timeDiff = block.timestamp - staking.earningStartTime;\r\n        uint256 earningRate = staking.amount * stakingPlan.dailyROI;\r\n        uint256 rewardAmount = (earningRate * Math.min(timeDiff, stakingPlan.stakingPeriod)) / (10000 * 1 days);\r\n\r\n        return staking.rewardDebt + rewardAmount;\r\n    }\r\n\r\n    function getUserPlanDetails(\r\n        address userAddress,\r\n        uint256 planId\r\n    ) external view returns (Staking memory, uint256) {\r\n        uint256 reward = getRewards(userAddress, planId);\r\n        Staking memory staking = users[userAddress].stakings[planId];\r\n        return (staking, reward);\r\n    }\r\n\r\n    function getAllUserPlansEarnings(\r\n        address userAddress\r\n    ) public view returns (uint256) {\r\n        uint256 planOneReward = getRewards(userAddress, 1);\r\n        uint256 planTwoReward = getRewards(userAddress, 2);\r\n        uint256 planThreeReward = getRewards(userAddress, 3);\r\n\r\n        return planOneReward + planTwoReward + planThreeReward;\r\n    }\r\n\r\n    function getUserDetails(\r\n        address userAddress\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 reward = getAllUserPlansEarnings(userAddress);\r\n        User storage user = users[userAddress];\r\n        return (\r\n            user.referralDebt,\r\n            user.teamSalesDebt,\r\n            user.lastTeamHarvest,\r\n            user.totalInvestments,\r\n            user.referrer,\r\n            user.currentRank,\r\n            user.totalDirectReferrals,\r\n            user.totalCommissionEarned,\r\n            user.totalTeam,\r\n            user.leadershipScore,\r\n            reward\r\n        );\r\n    }\r\n\r\n    function getAvailableReferralRewards(\r\n        address userAddress\r\n    ) public view returns (uint256) {\r\n        User storage user = users[userAddress];\r\n        return user.referralDebt;\r\n    }\r\n\r\n    function getReferralRewards(\r\n        address userAddress\r\n    ) public view returns (uint256) {\r\n        uint256 pendingReward = 0;\r\n        User storage user = users[userAddress];\r\n        for (uint256 i = 0; i < user.referrals.length; i++) {\r\n            uint256 userRewards = getAllUserPlansEarnings(user.referrals[i]);\r\n            uint256 rewardsPercentage = referralLevels[1];\r\n            pendingReward = pendingReward +\r\n                ((userRewards * rewardsPercentage) / 10000);\r\n\r\n            User storage referredUser = users[user.referrals[i]];\r\n            uint256 generation = 1;\r\n            uint256 maxGenerations = REFERRAL_LEVELS - 1;\r\n\r\n            while (\r\n                generation <= maxGenerations &&\r\n                referredUser.referrals.length > 0\r\n            ) {\r\n                uint256 _referralsCount = referredUser.referrals.length;\r\n                for (uint256 j = 0; j < _referralsCount; j++) {\r\n                    address referrer = referredUser.referrals[j];\r\n                    if (referrer == address(0)) continue;\r\n\r\n                    userRewards = getAllUserPlansEarnings(referrer);\r\n                    uint256 referralEarningsPercentage = referralLevels[\r\n                        generation + 1\r\n                    ];\r\n\r\n                    uint256 referralEarningsShare = (\r\n                        userRewards * referralEarningsPercentage\r\n                    ) / 10000;\r\n                    pendingReward = pendingReward + referralEarningsShare;\r\n                }\r\n\r\n                referredUser = users[referredUser.referrals[0]];\r\n                generation++;\r\n            }\r\n        }\r\n\r\n        return pendingReward;\r\n    }\r\n\r\n    function stake(\r\n        uint256 planId\r\n    ) external payable nonReentrant validPlanId(planId) {\r\n        require(\r\n            msg.value >= stakingPlans[planId].minStakeAmount &&\r\n                msg.value <= stakingPlans[planId].maxStakeAmount,\r\n            \"Invalid staking amount\"\r\n        );\r\n\r\n        require(users[msg.sender].referrer != address(0), \"You must be referred to participate\");\r\n\r\n        updateUplinesEarnings(msg.sender, planId);\r\n        updateUserStake(msg.sender, planId);\r\n\r\n        User storage user = users[msg.sender];\r\n        user.totalInvestments = user.totalInvestments + msg.value;\r\n\r\n        StakingPlan storage stakingPlan = stakingPlans[planId];\r\n\r\n        Staking storage staking = users[msg.sender].stakings[planId];\r\n        staking.amount += msg.value;\r\n        staking.initialTime = block.timestamp;\r\n        staking.earningStartTime = block.timestamp;\r\n        staking.lockEndTime = block.timestamp + stakingPlan.stakingPeriod;\r\n        staking.totalInvestments = staking.totalInvestments + msg.value;\r\n\r\n        stakingPlan.totalStaked += msg.value;\r\n\r\n        updateLeadershipRank(msg.sender);\r\n        balanceLeadershipRank(msg.sender, msg.value);\r\n\r\n        emit Staked(msg.sender, msg.value);\r\n\r\n        uint256 liquiditySupportFee = (\r\n            msg.value * LIQUIDITY_SUPPORT_PERCENTAGE\r\n        ) / 10000;\r\n\r\n        emit ReleaseBotSupport(liquiditySupportFee);\r\n\r\n        liquiditySupportBot.transfer(liquiditySupportFee);\r\n    }\r\n\r\n    function harvest(uint256 planId) external nonReentrant validPlanId(planId) {\r\n        User storage user = users[msg.sender];\r\n        Staking storage staking = users[msg.sender].stakings[planId];\r\n        StakingPlan storage stakingPlan = stakingPlans[planId];\r\n\r\n        uint256 teamSalesEarnings = user.teamSalesDebt + teamEarnings(msg.sender);\r\n        uint256 rewardAmount = getRewards(msg.sender, planId) + teamSalesEarnings;\r\n        require(rewardAmount > 0, \"harvest: not enough funds\");\r\n\r\n        updateUplinesEarnings(msg.sender, planId);\r\n\r\n        staking.rewardDebt = 0;\r\n        staking.totalWithdrawal = staking.totalWithdrawal + rewardAmount;\r\n        staking.earningStartTime = block.timestamp;\r\n\r\n        user.teamSalesDebt = 0;\r\n        user.lastTeamHarvest = block.timestamp;\r\n\r\n        uint256 harvestFee = (rewardAmount * HARVEST_FEE_PERCENTAGE) / 10000;\r\n\r\n        stakingPlan.totalPayouts += rewardAmount;\r\n\r\n        emit Harvested(msg.sender, rewardAmount - harvestFee);\r\n\r\n        payable(msg.sender).transfer(rewardAmount - harvestFee);\r\n        admin.transfer(harvestFee);\r\n    }\r\n\r\n    function harvestReferralEarnings() external nonReentrant {\r\n        User storage user = users[msg.sender];\r\n        require(user.referralDebt > 0, \"harvest: not enough funds\");\r\n\r\n        uint256 rewardAmount = user.referralDebt;\r\n\r\n        user.referralDebt = 0;\r\n\r\n        uint256 harvestFee = (rewardAmount * HARVEST_FEE_PERCENTAGE) / 10000;\r\n\r\n        emit Harvested(msg.sender, rewardAmount - harvestFee);\r\n\r\n        payable(msg.sender).transfer(rewardAmount - harvestFee);\r\n        admin.transfer(harvestFee);\r\n    }\r\n\r\n    function unstake(uint256 planId) external nonReentrant validPlanId(planId) {\r\n        User storage user = users[msg.sender];\r\n        Staking storage staking = users[msg.sender].stakings[planId];\r\n        StakingPlan storage stakingPlan = stakingPlans[planId];\r\n\r\n        uint256 teamSalesEarnings = user.teamSalesDebt + teamEarnings(msg.sender);\r\n\r\n        uint256 totalBalance = getRewards(msg.sender, planId) + staking.amount + teamSalesEarnings;\r\n        require(totalBalance > 0, \"Unstake: nothing to unstake\");\r\n\r\n        uint256 harvestFee = (totalBalance * HARVEST_FEE_PERCENTAGE) / 10000;\r\n        uint256 harvestableAmount = _harvestableAmount(\r\n            totalBalance,\r\n            harvestFee,\r\n            msg.sender,\r\n            planId\r\n        );\r\n\r\n        require(\r\n            address(this).balance >= totalBalance,\r\n            \"Insufficient fund to initiate unstake\"\r\n        );\r\n\r\n        updateUplinesEarnings(msg.sender, planId);\r\n        updateUserStake(msg.sender, planId);\r\n\r\n        staking.amount = 0;\r\n        staking.rewardDebt = 0;\r\n        staking.totalWithdrawal = staking.totalWithdrawal + totalBalance;\r\n        staking.earningStartTime = 0;\r\n\r\n        user.teamSalesDebt = 0;\r\n        user.lastTeamHarvest = block.timestamp;\r\n\r\n        stakingPlan.totalPayouts += totalBalance;\r\n\r\n        emit Unstaked(msg.sender, harvestableAmount);\r\n\r\n        payable(msg.sender).transfer(harvestableAmount);\r\n        admin.transfer(harvestFee);\r\n    }\r\n\r\n    function recordReferral(address referrerAddress) public nonReentrant {\r\n        require(msg.sender.code.length == 0, \"Contracts not allowed.\");\r\n\r\n        // Check for circular referral\r\n        address currentReferrer = referrerAddress;\r\n        while (currentReferrer != address(0)) {\r\n            require(\r\n                currentReferrer != msg.sender,\r\n                \"Circular referral detected.\"\r\n            );\r\n            currentReferrer = referrals[currentReferrer];\r\n        }\r\n\r\n        if (referrerAddress != address(0) && referrals[msg.sender] == address(0)) {\r\n            User storage user = users[referrerAddress];\r\n            User storage referredUser = users[msg.sender];\r\n\r\n            referrals[msg.sender] = referrerAddress;\r\n            referralCounts[referrerAddress]++;\r\n\r\n            referredUser.referrer = referrerAddress;\r\n\r\n            user.referrals.push(msg.sender);\r\n            user.totalDirectReferrals = user.totalDirectReferrals + 1;\r\n\r\n            totalTeams = totalTeams + 1;\r\n\r\n            updateUplines(msg.sender);\r\n\r\n            emit ReferralRecorded(msg.sender, referrerAddress);\r\n        }\r\n    }\r\n\r\n    function _harvestableAmount(\r\n        uint256 _amount,\r\n        uint256 _harvestFee,\r\n        address userAddress,\r\n        uint256 planId\r\n    ) private view returns (uint256) {\r\n        Staking storage staking = users[userAddress].stakings[planId];\r\n        uint256 harvestableAmount = _amount - _harvestFee;\r\n\r\n        if (staking.lockEndTime > block.timestamp) {\r\n            uint256 penalty = (harvestableAmount * PENALTY_PERCENTAGE) / 10000;\r\n            harvestableAmount = harvestableAmount - penalty;\r\n        }\r\n\r\n        return harvestableAmount;\r\n    }\r\n\r\n    function updateUserStake(address userAddress, uint256 planId) internal {\r\n        Staking storage staking = users[userAddress].stakings[planId];\r\n        StakingPlan storage stakingPlan = stakingPlans[planId];\r\n\r\n        uint256 rewardAmount = getRewards(userAddress, planId);\r\n        staking.rewardDebt = rewardAmount;\r\n        staking.initialTime = block.timestamp;\r\n        staking.lockEndTime = staking.initialTime + stakingPlan.stakingPeriod;\r\n    }\r\n\r\n    function updateUplinesEarnings(address userAddress, uint256 planId) internal {\r\n        if (referrals[userAddress] != address(0)) {\r\n            uint256 userEarnings = getRewards(userAddress, planId);\r\n            address[] memory userUps = getUplines(userAddress);\r\n\r\n            for (uint i = 0; i < userUps.length; i++) {\r\n                if (userUps[i] == address(0)) {\r\n                    break;\r\n                }\r\n                User storage user = users[userUps[i]];\r\n                uint256 referralEarningsPercentage = referralLevels[i + 1];\r\n                uint256 referralReward = userEarnings * referralEarningsPercentage / 10000;\r\n                user.referralDebt = user.referralDebt + referralReward;\r\n                user.totalCommissionEarned += referralReward;\r\n                emit ReferralEarningsReceived(userUps[i], referralReward);\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateUplines(address userAddress) internal {\r\n        address[] memory userUplines = getUplines(userAddress);\r\n\r\n        for (uint256 i = 0; i < userUplines.length; i++) {\r\n            address referrer = userUplines[i];\r\n\r\n            if (referrer == address(0)) {\r\n                break;\r\n            }\r\n            updateLeadershipRank(referrer);\r\n            User storage user = users[referrer];\r\n            user.totalTeam = user.totalTeam + 1;\r\n        }\r\n    }\r\n\r\n    function getUplines(\r\n        address userAddress\r\n    ) internal view returns (address[] memory) {\r\n        uint16 limit = 10;\r\n        address[] memory uplines = new address[](limit);\r\n        address current = userAddress;\r\n        for (uint i = 0; i < limit; i++) {\r\n            if (referrals[current] == address(0)) {\r\n                break;\r\n            }\r\n            uplines[i] = referrals[current];\r\n            current = uplines[i];\r\n        }\r\n        return uplines;\r\n    }\r\n\r\n    function balanceLeadershipRank(\r\n        address userAddress,\r\n        uint256 transactionAmount\r\n    ) internal {\r\n        address referrer = referrals[userAddress];\r\n        if (referrer != address(0)) {\r\n            address[] memory userUps = getUplines(userAddress);\r\n\r\n            for (uint256 i = 0; i < userUps.length; i++) {\r\n                if (userUps[i] == address(0)) {\r\n                    break;\r\n                }\r\n                User storage user = users[userUps[i]];\r\n                user.leadershipScore = user.leadershipScore + transactionAmount;\r\n                updateLeadershipRank(userUps[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateLeadershipRank(address uplineAddress) internal {\r\n        uint256 totalLeadershipRanks = 7;\r\n        User storage user = users[uplineAddress];\r\n        uint256 currentPosition = user.currentRank;\r\n        if (currentPosition != totalLeadershipRanks) {\r\n            for (\r\n                uint256 index = currentPosition;\r\n                index < totalLeadershipRanks;\r\n                index++\r\n            ) {\r\n                LeadershipRank memory leadershipRank = leadershipRanks[\r\n                    index + 1\r\n                ];\r\n                if (\r\n                    user.leadershipScore >= leadershipRank.teamVolume &&\r\n                    user.totalInvestments >= leadershipRank.investments &&\r\n                    user.totalDirectReferrals >= leadershipRank.directReferrals\r\n                ) {\r\n                    currentPosition = currentPosition + 1;\r\n                }\r\n            }\r\n            if (currentPosition != user.currentRank) {\r\n                user.teamSalesDebt += teamEarnings(uplineAddress);\r\n                user.lastTeamHarvest = block.timestamp;\r\n            }\r\n            user.currentRank = currentPosition;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adminAdd\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"liquiditySupportBotAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PenaltyCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralEarningsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"ReferralRecorded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReleaseBotSupport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LIQUIDITY_SUPPORT_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInitializedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getAllUserPlansEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getAvailableReferralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getReferralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"getUserPlanDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestments\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earningStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockEndTime\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingBot.Staking\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestReferralEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leadershipRanks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weeklyEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directReferrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investments\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquiditySupportBot\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"recordReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingPlans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyROI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayouts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"teamEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTeams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referralDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamSalesDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTeamHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestments\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDirectReferrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCommissionEarned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leadershipScore\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakingBot", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000043cb53e63144e6348be0ac964ca0eebbfe2d82fd0000000000000000000000005b41b4ebd5ca53e60da2e57f43f4d092ff4ce0c5", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3a7320ef87ecac75cbeb968fd11b9b9fb38a03a18046c44da17450f2ffee2686"}