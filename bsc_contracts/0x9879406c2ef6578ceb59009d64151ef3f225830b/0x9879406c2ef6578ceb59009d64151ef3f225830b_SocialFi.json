{"SourceCode": "{\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./Include.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 is IERC165 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of NFTs in ``owner``\\u0027s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     *\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `from`, `to` cannot be zero.\\r\\n     * - `tokenId` must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move this\\r\\n     * NFT by either {approve} or {setApprovalForAll}.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n    /**\\r\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\r\\n     * either {approve} or {setApprovalForAll}.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Metadata is IERC721 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Enumerable is IERC721 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\r\\n\\r\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721Receiver {\\r\\n    /**\\r\\n     * @notice Handle the receipt of an NFT\\r\\n     * @dev The ERC721 smart contract calls this function on the recipient\\r\\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\\r\\n     * otherwise the caller will revert the transaction. The selector to be\\r\\n     * returned can be obtained as `this.onERC721Received.selector`. This\\r\\n     * function MAY throw to revert and reject the transfer.\\r\\n     * Note: the ERC721 contract address is always the message sender.\\r\\n     * @param operator The address which called `safeTransferFrom` function\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param tokenId The NFT identifier which is being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return bytes4 `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n     */\\r\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\\r\\n    external returns (bytes4);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts may inherit from this and call {_registerInterface} to declare\\r\\n * their support of an interface.\\r\\n */\\r\\ncontract ERC165UpgradeSafe is Initializable, IERC165 {\\r\\n    /*\\r\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\r\\n\\r\\n    /**\\r\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\r\\n     */\\r\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\r\\n\\r\\n\\r\\n    function __ERC165_init() internal initializer {\\r\\n        __ERC165_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __ERC165_init_unchained() internal initializer {\\r\\n\\r\\n\\r\\n        // Derived contracts need only register support for their own interfaces,\\r\\n        // we register support for ERC165 itself here\\r\\n        _registerInterface(_INTERFACE_ID_ERC165);\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     *\\r\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\r\\n        return _supportedInterfaces[interfaceId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Registers the contract as an implementer of the interface defined by\\r\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\r\\n     * registering its interface id is not required.\\r\\n     *\\r\\n     * See {IERC165-supportsInterface}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\r\\n     */\\r\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\r\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\r\\n        _supportedInterfaces[interfaceId] = true;\\r\\n    }\\r\\n\\r\\n    uint256[49] private __gap;\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Library for managing\\r\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\r\\n * types.\\r\\n *\\r\\n * Sets have the following properties:\\r\\n *\\r\\n * - Elements are added, removed, and checked for existence in constant time\\r\\n * (O(1)).\\r\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\r\\n *\\r\\n * ```\\r\\n * contract Example {\\r\\n *     // Add the library methods\\r\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\r\\n *\\r\\n *     // Declare a set state variable\\r\\n *     EnumerableSet.AddressSet private mySet;\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\r\\n * (`UintSet`) are supported.\\r\\n */\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\r\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\r\\n\\r\\n            bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n            // Move the last value to the index where the value to delete is\\r\\n            set._values[toDeleteIndex] = lastvalue;\\r\\n            // Update the index for the moved value\\r\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\r\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(uint256(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(uint256(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(uint256(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\r\\n        return address(uint256(_at(set._inner, index)));\\r\\n    }\\r\\n\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Library for managing an enumerable variant of Solidity\\u0027s\\r\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\r\\n * type.\\r\\n *\\r\\n * Maps have the following properties:\\r\\n *\\r\\n * - Entries are added, removed, and checked for existence in constant time\\r\\n * (O(1)).\\r\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\r\\n *\\r\\n * ```\\r\\n * contract Example {\\r\\n *     // Add the library methods\\r\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\r\\n *\\r\\n *     // Declare a set state variable\\r\\n *     EnumerableMap.UintToAddressMap private myMap;\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * As of v3.0.0, only maps of type `uint256 -\\u003e address` (`UintToAddressMap`) are\\r\\n * supported.\\r\\n */\\r\\nlibrary EnumerableMap {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Map type with\\r\\n    // bytes32 keys and values.\\r\\n    // The Map implementation uses private functions, and user-facing\\r\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\r\\n    // the underlying Map.\\r\\n    // This means that we can only create new EnumerableMaps for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct MapEntry {\\r\\n        bytes32 _key;\\r\\n        bytes32 _value;\\r\\n    }\\r\\n\\r\\n    struct Map {\\r\\n        // Storage of map keys and values\\r\\n        MapEntry[] _entries;\\r\\n\\r\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\r\\n        // because index 0 means a key is not in the map.\\r\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\r\\n     * key. O(1).\\r\\n     *\\r\\n     * Returns true if the key was added to the map, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\r\\n        // We read and store the key\\u0027s index to prevent multiple reads from the same storage slot\\r\\n        uint256 keyIndex = map._indexes[key];\\r\\n\\r\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\r\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\r\\n            // The entry is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            map._indexes[key] = map._entries.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            map._entries[keyIndex - 1]._value = value;\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a key-value pair from a map. O(1).\\r\\n     *\\r\\n     * Returns true if the key was removed from the map, that is if it was present.\\r\\n     */\\r\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\r\\n        // We read and store the key\\u0027s index to prevent multiple reads from the same storage slot\\r\\n        uint256 keyIndex = map._indexes[key];\\r\\n\\r\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\r\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\r\\n            // in the array, and then remove the last entry (sometimes called as \\u0027swap and pop\\u0027).\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = keyIndex - 1;\\r\\n            uint256 lastIndex = map._entries.length - 1;\\r\\n\\r\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\r\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\r\\n\\r\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\r\\n\\r\\n            // Move the last entry to the index where the entry to delete is\\r\\n            map._entries[toDeleteIndex] = lastEntry;\\r\\n            // Update the index for the moved entry\\r\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\r\\n\\r\\n            // Delete the slot where the moved entry was stored\\r\\n            map._entries.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete map._indexes[key];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the key is in the map. O(1).\\r\\n     */\\r\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\r\\n        return map._indexes[key] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\r\\n     */\\r\\n    function _length(Map storage map) private view returns (uint256) {\\r\\n        return map._entries.length;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of entries inside the\\r\\n    * array, and it may change when more entries are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\r\\n        require(map._entries.length \\u003e index, \\\"EnumerableMap: index out of bounds\\\");\\r\\n\\r\\n        MapEntry storage entry = map._entries[index];\\r\\n        return (entry._key, entry._value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value associated with `key`.  O(1).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `key` must be in the map.\\r\\n     */\\r\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\r\\n        return _get(map, key, \\\"EnumerableMap: nonexistent key\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\r\\n     */\\r\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\r\\n        uint256 keyIndex = map._indexes[key];\\r\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\r\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\r\\n    }\\r\\n\\r\\n    // UintToAddressMap\\r\\n\\r\\n    struct UintToAddressMap {\\r\\n        Map _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\r\\n     * key. O(1).\\r\\n     *\\r\\n     * Returns true if the key was added to the map, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\r\\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the key was removed from the map, that is if it was present.\\r\\n     */\\r\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\r\\n        return _remove(map._inner, bytes32(key));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the key is in the map. O(1).\\r\\n     */\\r\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\r\\n        return _contains(map._inner, bytes32(key));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of elements in the map. O(1).\\r\\n     */\\r\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\r\\n        return _length(map._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\r\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\r\\n        return (uint256(key), address(uint256(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value associated with `key`.  O(1).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `key` must be in the map.\\r\\n     */\\r\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\r\\n        return address(uint256(_get(map._inner, bytes32(key))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\r\\n     */\\r\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\r\\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        uint256 index = digits - 1;\\r\\n        temp = value;\\r\\n        while (temp != 0) {\\r\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\r\\n            temp /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\r\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ncontract ERC721UpgradeSafe is Initializable, ContextUpgradeSafe, ERC165UpgradeSafe, IERC721, IERC721Metadata, IERC721Enumerable {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n    using EnumerableSet for EnumerableSet.UintSet;\\r\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\r\\n    using Strings for uint256;\\r\\n\\r\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\r\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\r\\n\\r\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\r\\n    mapping (address =\\u003e EnumerableSet.UintSet) private _holderTokens;\\r\\n\\r\\n    // Enumerable mapping from token ids to their owners\\r\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\r\\n\\r\\n    // Mapping from token ID to approved address\\r\\n    mapping (uint256 =\\u003e address) private _tokenApprovals;\\r\\n\\r\\n    // Mapping from owner to operator approvals\\r\\n    mapping (address =\\u003e mapping (address =\\u003e bool)) private _operatorApprovals;\\r\\n\\r\\n    // Token name\\r\\n    string internal _name;\\r\\n\\r\\n    // Token symbol\\r\\n    string internal _symbol;\\r\\n\\r\\n    // Optional mapping for token URIs\\r\\n    mapping(uint256 =\\u003e string) private _tokenURIs;\\r\\n\\r\\n    // Base URI\\r\\n    string private _baseURI;\\r\\n\\r\\n    /*\\r\\n     *     bytes4(keccak256(\\u0027balanceOf(address)\\u0027)) == 0x70a08231\\r\\n     *     bytes4(keccak256(\\u0027ownerOf(uint256)\\u0027)) == 0x6352211e\\r\\n     *     bytes4(keccak256(\\u0027approve(address,uint256)\\u0027)) == 0x095ea7b3\\r\\n     *     bytes4(keccak256(\\u0027getApproved(uint256)\\u0027)) == 0x081812fc\\r\\n     *     bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) == 0xa22cb465\\r\\n     *     bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) == 0xe985e9c5\\r\\n     *     bytes4(keccak256(\\u0027transferFrom(address,address,uint256)\\u0027)) == 0x23b872dd\\r\\n     *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256)\\u0027)) == 0x42842e0e\\r\\n     *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,bytes)\\u0027)) == 0xb88d4fde\\r\\n     *\\r\\n     *     =\\u003e 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\r\\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\r\\n\\r\\n    /*\\r\\n     *     bytes4(keccak256(\\u0027name()\\u0027)) == 0x06fdde03\\r\\n     *     bytes4(keccak256(\\u0027symbol()\\u0027)) == 0x95d89b41\\r\\n     *     bytes4(keccak256(\\u0027tokenURI(uint256)\\u0027)) == 0xc87b56dd\\r\\n     *\\r\\n     *     =\\u003e 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\r\\n\\r\\n    /*\\r\\n     *     bytes4(keccak256(\\u0027totalSupply()\\u0027)) == 0x18160ddd\\r\\n     *     bytes4(keccak256(\\u0027tokenOfOwnerByIndex(address,uint256)\\u0027)) == 0x2f745c59\\r\\n     *     bytes4(keccak256(\\u0027tokenByIndex(uint256)\\u0027)) == 0x4f6ccce7\\r\\n     *\\r\\n     *     =\\u003e 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\r\\n\\r\\n\\r\\n    function __ERC721_init(string memory name, string memory symbol) internal initializer {\\r\\n        __Context_init_unchained();\\r\\n        __ERC165_init_unchained();\\r\\n        __ERC721_init_unchained(name, symbol);\\r\\n    }\\r\\n\\r\\n    function __ERC721_init_unchained(string memory name, string memory symbol) internal initializer {\\r\\n\\r\\n\\r\\n        _name = name;\\r\\n        _symbol = symbol;\\r\\n\\r\\n        // register the supported interfaces to conform to ERC721 via ERC165\\r\\n        _registerInterface(_INTERFACE_ID_ERC721);\\r\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\r\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the balance of the specified address.\\r\\n     * @param owner address to query the balance of\\r\\n     * @return uint256 representing the amount owned by the passed address\\r\\n     */\\r\\n    function balanceOf(address owner) public view override returns (uint256) {\\r\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\r\\n\\r\\n        return _holderTokens[owner].length();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the owner of the specified token ID.\\r\\n     * @param tokenId uint256 ID of the token to query the owner of\\r\\n     * @return address currently marked as the owner of the given token ID\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\r\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token name.\\r\\n     * @return string representing the token name\\r\\n     */\\r\\n    function name() public view override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token symbol.\\r\\n     * @return string representing the token symbol\\r\\n     */\\r\\n    function symbol() public view override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the URI for a given token ID. May return an empty string.\\r\\n     *\\r\\n     * If a base URI is set (via {_setBaseURI}), it is added as a prefix to the\\r\\n     * token\\u0027s own URI (via {_setTokenURI}).\\r\\n     *\\r\\n     * If there is a base URI but no token URI, the token\\u0027s ID will be used as\\r\\n     * its URI when appending it to the base URI. This pattern for autogenerated\\r\\n     * token URIs can lead to large gas savings.\\r\\n     *\\r\\n     * .Examples\\r\\n     * |===\\r\\n     * |`_setBaseURI()` |`_setTokenURI()` |`tokenURI()`\\r\\n     * | \\\"\\\"\\r\\n     * | \\\"\\\"\\r\\n     * | \\\"\\\"\\r\\n     * | \\\"\\\"\\r\\n     * | \\\"token.uri/123\\\"\\r\\n     * | \\\"token.uri/123\\\"\\r\\n     * | \\\"token.uri/\\\"\\r\\n     * | \\\"123\\\"\\r\\n     * | \\\"token.uri/123\\\"\\r\\n     * | \\\"token.uri/\\\"\\r\\n     * | \\\"\\\"\\r\\n     * | \\\"token.uri/\\u003ctokenId\\u003e\\\"\\r\\n     * |===\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\r\\n\\r\\n        string memory _tokenURI = _tokenURIs[tokenId];\\r\\n\\r\\n        // If there is no base URI, return the token URI.\\r\\n        if (bytes(_baseURI).length == 0) {\\r\\n            return _tokenURI;\\r\\n        }\\r\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\r\\n        if (bytes(_tokenURI).length \\u003e 0) {\\r\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\r\\n        }\\r\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\r\\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\r\\n    * automatically added as a prefix in {tokenURI} to each token\\u0027s URI, or\\r\\n    * to the token ID if no specific URI is set for that token ID.\\r\\n    */\\r\\n    function baseURI() public view returns (string memory) {\\r\\n        return _baseURI;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\\r\\n     * @param owner address owning the tokens list to be accessed\\r\\n     * @param index uint256 representing the index to be accessed of the requested tokens list\\r\\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\\r\\n     */\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\r\\n        return _holderTokens[owner].at(index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the total amount of tokens stored by the contract.\\r\\n     * @return uint256 representing the total amount of tokens\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\r\\n        return _tokenOwners.length();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token ID at a given index of all the tokens in this contract\\r\\n     * Reverts if the index is greater or equal to the total number of tokens.\\r\\n     * @param index uint256 representing the index to be accessed of the tokens list\\r\\n     * @return uint256 token ID at the given index of the tokens list\\r\\n     */\\r\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\r\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\r\\n        return tokenId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approves another address to transfer the given token ID\\r\\n     * The zero address indicates there is no approved address.\\r\\n     * There can only be one approved address per token at a given time.\\r\\n     * Can only be called by the token owner or an approved operator.\\r\\n     * @param to address to be approved for the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be approved\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) public virtual override {\\r\\n        address owner = ownerOf(tokenId);\\r\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\r\\n\\r\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\r\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\r\\n        );\\r\\n\\r\\n        _approve(to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the approved address for a token ID, or zero if no address set\\r\\n     * Reverts if the token ID does not exist.\\r\\n     * @param tokenId uint256 ID of the token to query the approval of\\r\\n     * @return address currently approved for the given token ID\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\r\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\r\\n\\r\\n        return _tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets or unsets the approval of a given operator\\r\\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\\r\\n     * @param operator operator address to set the approval\\r\\n     * @param approved representing the status of the approval to be set\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\r\\n\\r\\n        _operatorApprovals[_msgSender()][operator] = approved;\\r\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tells whether an operator is approved by a given owner.\\r\\n     * @param owner owner address which you want to query the approval of\\r\\n     * @param operator operator address which you want to query the approval of\\r\\n     * @return bool whether the given operator is approved by the given owner\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\r\\n        return _operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers the ownership of a given token ID to another address.\\r\\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     * Requires the msg.sender to be the owner, approved, or operator.\\r\\n     * @param from current owner of the token\\r\\n     * @param to address to receive the ownership of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\r\\n        //solhint-disable-next-line max-line-length\\r\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n\\r\\n        _transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers the ownership of a given token ID to another address\\r\\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\r\\n     * which is called upon a safe transfer, and return the magic value\\r\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n     * the transfer is reverted.\\r\\n     * Requires the msg.sender to be the owner, approved, or operator\\r\\n     * @param from current owner of the token\\r\\n     * @param to address to receive the ownership of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\r\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers the ownership of a given token ID to another address\\r\\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\r\\n     * which is called upon a safe transfer, and return the magic value\\r\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n     * the transfer is reverted.\\r\\n     * Requires the _msgSender() to be the owner, approved, or operator\\r\\n     * @param from current owner of the token\\r\\n     * @param to address to receive the ownership of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     * @param _data bytes data to send along with a safe transfer check\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\r\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n        _safeTransfer(from, to, tokenId, _data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers the ownership of a given token ID to another address\\r\\n     * If the target address is a contract, it must implement `onERC721Received`,\\r\\n     * which is called upon a safe transfer, and return the magic value\\r\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n     * the transfer is reverted.\\r\\n     * Requires the msg.sender to be the owner, approved, or operator\\r\\n     * @param from current owner of the token\\r\\n     * @param to address to receive the ownership of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     * @param _data bytes data to send along with a safe transfer check\\r\\n     */\\r\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\r\\n        _transfer(from, to, tokenId);\\r\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether the specified token exists.\\r\\n     * @param tokenId uint256 ID of the token to query the existence of\\r\\n     * @return bool whether the token exists\\r\\n     */\\r\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\r\\n        return _tokenOwners.contains(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether the given spender can transfer a given token ID.\\r\\n     * @param spender address of the spender to query\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     * @return bool whether the msg.sender is approved for the given token ID,\\r\\n     * is an operator of the owner, or is the owner of the token\\r\\n     */\\r\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\r\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\r\\n        address owner = ownerOf(tokenId);\\r\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to safely mint a new token.\\r\\n     * Reverts if the given token ID already exists.\\r\\n     * If the target address is a contract, it must implement `onERC721Received`,\\r\\n     * which is called upon a safe transfer, and return the magic value\\r\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n     * the transfer is reverted.\\r\\n     * @param to The address that will own the minted token\\r\\n     * @param tokenId uint256 ID of the token to be minted\\r\\n     */\\r\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\r\\n        _safeMint(to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to safely mint a new token.\\r\\n     * Reverts if the given token ID already exists.\\r\\n     * If the target address is a contract, it must implement `onERC721Received`,\\r\\n     * which is called upon a safe transfer, and return the magic value\\r\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n     * the transfer is reverted.\\r\\n     * @param to The address that will own the minted token\\r\\n     * @param tokenId uint256 ID of the token to be minted\\r\\n     * @param _data bytes data to send along with a safe transfer check\\r\\n     */\\r\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\r\\n        _mint(to, tokenId);\\r\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to mint a new token.\\r\\n     * Reverts if the given token ID already exists.\\r\\n     * @param to The address that will own the minted token\\r\\n     * @param tokenId uint256 ID of the token to be minted\\r\\n     */\\r\\n    function _mint(address to, uint256 tokenId) internal virtual {\\r\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\r\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), to, tokenId);\\r\\n\\r\\n        _holderTokens[to].add(tokenId);\\r\\n\\r\\n        _tokenOwners.set(tokenId, to);\\r\\n\\r\\n        emit Transfer(address(0), to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to burn a specific token.\\r\\n     * Reverts if the token does not exist.\\r\\n     * @param tokenId uint256 ID of the token being burned\\r\\n     */\\r\\n    function _burn(uint256 tokenId) internal virtual {\\r\\n        address owner = ownerOf(tokenId);\\r\\n\\r\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\r\\n\\r\\n        // Clear approvals\\r\\n        _approve(address(0), tokenId);\\r\\n\\r\\n        // Clear metadata (if any)\\r\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\r\\n            delete _tokenURIs[tokenId];\\r\\n        }\\r\\n\\r\\n        _holderTokens[owner].remove(tokenId);\\r\\n\\r\\n        _tokenOwners.remove(tokenId);\\r\\n\\r\\n        emit Transfer(owner, address(0), tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\r\\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\r\\n     * @param from current owner of the token\\r\\n     * @param to address to receive the ownership of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     */\\r\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\r\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\r\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, tokenId);\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        _approve(address(0), tokenId);\\r\\n\\r\\n        _holderTokens[from].remove(tokenId);\\r\\n        _holderTokens[to].add(tokenId);\\r\\n\\r\\n        _tokenOwners.set(tokenId, to);\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to set the token URI for a given token.\\r\\n     *\\r\\n     * Reverts if the token ID does not exist.\\r\\n     *\\r\\n     * TIP: If all token IDs share a prefix (for example, if your URIs look like\\r\\n     * `https://api.myproject.com/token/\\u003cid\\u003e`), use {_setBaseURI} to store\\r\\n     * it and save gas.\\r\\n     */\\r\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\r\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\r\\n        _tokenURIs[tokenId] = _tokenURI;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to set the base URI for all token IDs. It is\\r\\n     * automatically added as a prefix to the value returned in {tokenURI},\\r\\n     * or to the token ID if {tokenURI} is empty.\\r\\n     */\\r\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\r\\n        _baseURI = baseURI_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\r\\n     * The call is not executed if the target address is not a contract.\\r\\n     *\\r\\n     * @param from address representing the previous owner of the given token ID\\r\\n     * @param to target address that will receive the tokens\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     * @param _data bytes optional data to send along with the call\\r\\n     * @return bool whether the call correctly returned the expected magic value\\r\\n     */\\r\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\r\\n        private returns (bool)\\r\\n    {\\r\\n        if (!to.isContract()) {\\r\\n            return true;\\r\\n        }\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\\r\\n            IERC721Receiver(to).onERC721Received.selector,\\r\\n            _msgSender(),\\r\\n            from,\\r\\n            tokenId,\\r\\n            _data\\r\\n        ));\\r\\n        if (!success) {\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n            }\\r\\n        } else {\\r\\n            bytes4 retval = abi.decode(returndata, (bytes4));\\r\\n            return (retval == _ERC721_RECEIVED);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _approve(address to, uint256 tokenId) private {\\r\\n        _tokenApprovals[tokenId] = to;\\r\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any token transfer. This includes minting\\r\\n     * and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - when `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - when `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\r\\n\\r\\n    uint256[41] private __gap;\\r\\n}\\r\\n\"},\"Include.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ncontract PlaceHolder {\\r\\n    \\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Proxy\\r\\n * @dev Implements delegation of calls to other contracts, with proper\\r\\n * forwarding of return values and bubbling of failures.\\r\\n * It defines a fallback function that delegates all calls to the address\\r\\n * returned by the abstract _implementation() internal function.\\r\\n */\\r\\nabstract contract Proxy {\\r\\n  /**\\r\\n   * @dev Fallback function.\\r\\n   * Implemented entirely in `_fallback`.\\r\\n   */\\r\\n  fallback () virtual payable external {\\r\\n    _fallback();\\r\\n  }\\r\\n  \\r\\n  receive () virtual payable external {\\r\\n    _fallback();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The Address of the implementation.\\r\\n   */\\r\\n  function _implementation() virtual internal view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @dev Delegates execution to an implementation contract.\\r\\n   * This is a low level function that doesn\\u0027t return to its internal call site.\\r\\n   * It will return to the external caller whatever the implementation returns.\\r\\n   * @param implementation Address to delegate.\\r\\n   */\\r\\n  function _delegate(address implementation) internal {\\r\\n    assembly {\\r\\n      // Copy msg.data. We take full control of memory in this inline assembly\\r\\n      // block because it will not return to Solidity code. We overwrite the\\r\\n      // Solidity scratch pad at memory position 0.\\r\\n      calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n      // Call the implementation.\\r\\n      // out and outsize are 0 because we don\\u0027t know the size yet.\\r\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n      // Copy the returned data.\\r\\n      returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n      switch result\\r\\n      // delegatecall returns 0 on error.\\r\\n      case 0 { revert(0, returndatasize()) }\\r\\n      default { return(0, returndatasize()) }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Function that is run as the first thing in the fallback function.\\r\\n   * Can be redefined in derived contracts to add functionality.\\r\\n   * Redefinitions must call super._willFallback().\\r\\n   */\\r\\n  function _willFallback() virtual internal {\\r\\n      \\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev fallback implementation.\\r\\n   * Extracted to enable manual triggering.\\r\\n   */\\r\\n  function _fallback() internal {\\r\\n    //if(OpenZeppelinUpgradesAddress.isContract(msg.sender) \\u0026\\u0026 msg.data.length == 0 \\u0026\\u0026 gasleft() \\u003c= 2300)         // for receive ETH only from other contract\\r\\n    if(OpenZeppelinUpgradesAddress.isContract(msg.sender) \\u0026\\u0026 msg.data.length == 0)         // for receive ETH only from other contract\\r\\n        return;\\r\\n    _willFallback();\\r\\n    _delegate(_implementation());\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title BaseUpgradeabilityProxy\\r\\n * @dev This contract implements a proxy that allows to change the\\r\\n * implementation address to which it will delegate.\\r\\n * Such a change is called an implementation upgrade.\\r\\n */\\r\\nabstract contract BaseUpgradeabilityProxy is Proxy {\\r\\n  /**\\r\\n   * @dev Emitted when the implementation is upgraded.\\r\\n   * @param implementation Address of the new implementation.\\r\\n   */\\r\\n  event Upgraded(address indexed implementation);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the address of the current implementation.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the current implementation.\\r\\n   * @return impl Address of the current implementation\\r\\n   */\\r\\n  function _implementation() virtual override internal view returns (address impl) {\\r\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n    assembly {\\r\\n      impl := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrades the proxy to a new implementation.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function _upgradeTo(address newImplementation) internal {\\r\\n    _setImplementation(newImplementation);\\r\\n    emit Upgraded(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the implementation address of the proxy.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function _setImplementation(address newImplementation) internal {\\r\\n    require(newImplementation == address(0) || OpenZeppelinUpgradesAddress.isContract(newImplementation), \\\"Cannot set a proxy implementation to a non-contract address\\\");\\r\\n\\r\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newImplementation)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title BaseAdminUpgradeabilityProxy\\r\\n * @dev This contract combines an upgradeability proxy with an authorization\\r\\n * mechanism for administrative tasks.\\r\\n * All external functions in this contract must be guarded by the\\r\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\r\\n * feature proposal that would enable this to be done automatically.\\r\\n */\\r\\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Emitted when the administration has been transferred.\\r\\n   * @param previousAdmin Address of the previous admin.\\r\\n   * @param newAdmin Address of the new admin.\\r\\n   */\\r\\n  event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the admin of the contract.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n\\r\\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\r\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\r\\n   * to the implementation.\\r\\n   */\\r\\n  modifier ifAdmin() {\\r\\n    if (msg.sender == _admin()) {\\r\\n      _;\\r\\n    } else {\\r\\n      _fallback();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the proxy admin.\\r\\n   */\\r\\n  function admin() external ifAdmin returns (address) {\\r\\n    return _admin();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the implementation.\\r\\n   */\\r\\n  function implementation() external ifAdmin returns (address) {\\r\\n    return _implementation();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Changes the admin of the proxy.\\r\\n   * Only the current admin can call this function.\\r\\n   * @param newAdmin Address to transfer proxy administration to.\\r\\n   */\\r\\n  function changeAdmin(address newAdmin) external ifAdmin {\\r\\n    require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\r\\n    emit AdminChanged(_admin(), newAdmin);\\r\\n    _setAdmin(newAdmin);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy.\\r\\n   * Only the admin can call this function.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function upgradeTo(address newImplementation) external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\r\\n   * on the new implementation.\\r\\n   * This is useful to initialize the proxied contract.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   * @param data Data to send as msg.data in the low level call.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   */\\r\\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n    (bool success,) = newImplementation.delegatecall(data);\\r\\n    require(success);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return adm The admin slot.\\r\\n   */\\r\\n  function _admin() internal view returns (address adm) {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n    assembly {\\r\\n      adm := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the address of the proxy admin.\\r\\n   * @param newAdmin Address of the new proxy admin.\\r\\n   */\\r\\n  function _setAdmin(address newAdmin) internal {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newAdmin)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  function _willFallback() virtual override internal {\\r\\n    require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\r\\n    //super._willFallback();\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface IAdminUpgradeabilityProxyView {\\r\\n  function admin() external view returns (address);\\r\\n  function implementation() external view returns (address);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title UpgradeabilityProxy\\r\\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\\r\\n * implementation and init data.\\r\\n */\\r\\nabstract contract UpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Contract constructor.\\r\\n   * @param _logic Address of the initial implementation.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  constructor(address _logic, bytes memory _data) public payable {\\r\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\r\\n    _setImplementation(_logic);\\r\\n    if(_data.length \\u003e 0) {\\r\\n      (bool success,) = _logic.delegatecall(_data);\\r\\n      require(success);\\r\\n    }\\r\\n  }  \\r\\n  \\r\\n  //function _willFallback() virtual override internal {\\r\\n    //super._willFallback();\\r\\n  //}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title AdminUpgradeabilityProxy\\r\\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \\r\\n * initializing the implementation, admin, and init data.\\r\\n */\\r\\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\\r\\n  /**\\r\\n   * Contract constructor.\\r\\n   * @param _logic address of the initial implementation.\\r\\n   * @param _admin Address of the proxy administrator.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\r\\n    _setAdmin(_admin);\\r\\n  }\\r\\n  \\r\\n  function _willFallback() override(Proxy, BaseAdminUpgradeabilityProxy) internal {\\r\\n    super._willFallback();\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title BaseAdminUpgradeabilityProxy\\r\\n * @dev This contract combines an upgradeability proxy with an authorization\\r\\n * mechanism for administrative tasks.\\r\\n * All external functions in this contract must be guarded by the\\r\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\r\\n * feature proposal that would enable this to be done automatically.\\r\\n */\\r\\ncontract __BaseAdminUpgradeabilityProxy__ is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Emitted when the administration has been transferred.\\r\\n   * @param previousAdmin Address of the previous admin.\\r\\n   * @param newAdmin Address of the new admin.\\r\\n   */\\r\\n  event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the admin of the contract.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n\\r\\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\r\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\r\\n   * to the implementation.\\r\\n   */\\r\\n  //modifier ifAdmin() {\\r\\n  //  if (msg.sender == _admin()) {\\r\\n  //    _;\\r\\n  //  } else {\\r\\n  //    _fallback();\\r\\n  //  }\\r\\n  //}\\r\\n  modifier ifAdmin() {\\r\\n    require (msg.sender == _admin(), \\\"only admin\\\");\\r\\n      _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the proxy admin.\\r\\n   */\\r\\n  //function admin() external ifAdmin returns (address) {\\r\\n  //  return _admin();\\r\\n  //}\\r\\n  function __admin__() external view returns (address) {\\r\\n    return _admin();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the implementation.\\r\\n   */\\r\\n  //function implementation() external ifAdmin returns (address) {\\r\\n  //  return _implementation();\\r\\n  //}\\r\\n  function __implementation__() external view returns (address) {\\r\\n    return _implementation();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Changes the admin of the proxy.\\r\\n   * Only the current admin can call this function.\\r\\n   * @param newAdmin Address to transfer proxy administration to.\\r\\n   */\\r\\n  //function changeAdmin(address newAdmin) external ifAdmin {\\r\\n  //  require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\r\\n  //  emit AdminChanged(_admin(), newAdmin);\\r\\n  //  _setAdmin(newAdmin);\\r\\n  //}\\r\\n  function __changeAdmin__(address newAdmin) external ifAdmin {\\r\\n    require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\r\\n    emit AdminChanged(_admin(), newAdmin);\\r\\n    _setAdmin(newAdmin);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy.\\r\\n   * Only the admin can call this function.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  //function upgradeTo(address newImplementation) external ifAdmin {\\r\\n  //  _upgradeTo(newImplementation);\\r\\n  //}\\r\\n  function __upgradeTo__(address newImplementation) external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\r\\n   * on the new implementation.\\r\\n   * This is useful to initialize the proxied contract.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   * @param data Data to send as msg.data in the low level call.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   */\\r\\n  //function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\\r\\n  //  _upgradeTo(newImplementation);\\r\\n  //  (bool success,) = newImplementation.delegatecall(data);\\r\\n  //  require(success);\\r\\n  //}\\r\\n  function __upgradeToAndCall__(address newImplementation, bytes calldata data) payable external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n    (bool success,) = newImplementation.delegatecall(data);\\r\\n    require(success);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return adm The admin slot.\\r\\n   */\\r\\n  function _admin() internal view returns (address adm) {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n    assembly {\\r\\n      adm := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the address of the proxy admin.\\r\\n   * @param newAdmin Address of the new proxy admin.\\r\\n   */\\r\\n  function _setAdmin(address newAdmin) internal {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newAdmin)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  //function _willFallback() virtual override internal {\\r\\n  //  require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\r\\n  //  //super._willFallback();\\r\\n  //}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title AdminUpgradeabilityProxy\\r\\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \\r\\n * initializing the implementation, admin, and init data.\\r\\n */\\r\\ncontract __AdminUpgradeabilityProxy__ is __BaseAdminUpgradeabilityProxy__, UpgradeabilityProxy {\\r\\n  /**\\r\\n   * Contract constructor.\\r\\n   * @param _logic address of the initial implementation.\\r\\n   * @param _admin Address of the proxy administrator.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\r\\n    _setAdmin(_admin);\\r\\n  }\\r\\n  \\r\\n  //function _willFallback() override(Proxy, BaseAdminUpgradeabilityProxy) internal {\\r\\n  //  super._willFallback();\\r\\n  //}\\r\\n}  \\r\\n\\r\\ncontract __AdminUpgradeabilityProxy0__ is __BaseAdminUpgradeabilityProxy__, UpgradeabilityProxy {\\r\\n  constructor() UpgradeabilityProxy(address(0), \\\"\\\") public {\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\r\\n    _setAdmin(msg.sender);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title InitializableUpgradeabilityProxy\\r\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\r\\n * implementation and init data.\\r\\n */\\r\\nabstract contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Contract initializer.\\r\\n   * @param _logic Address of the initial implementation.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function initialize(address _logic, bytes memory _data) public payable {\\r\\n    require(_implementation() == address(0));\\r\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\r\\n    _setImplementation(_logic);\\r\\n    if(_data.length \\u003e 0) {\\r\\n      (bool success,) = _logic.delegatecall(_data);\\r\\n      require(success);\\r\\n    }\\r\\n  }  \\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title InitializableAdminUpgradeabilityProxy\\r\\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \\r\\n * initializing the implementation, admin, and init data.\\r\\n */\\r\\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\\r\\n  /**\\r\\n   * Contract initializer.\\r\\n   * @param _logic address of the initial implementation.\\r\\n   * @param _admin Address of the proxy administrator.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function initialize(address _logic, address _admin, bytes memory _data) public payable {\\r\\n    require(_implementation() == address(0));\\r\\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\r\\n    _setAdmin(_admin);\\r\\n  }\\r\\n  \\r\\n  function _willFallback() override(Proxy, BaseAdminUpgradeabilityProxy) internal {\\r\\n    super._willFallback();\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ninterface IProxyFactory {\\r\\n    function governor() external view returns (address);\\r\\n    function __admin__() external view returns (address);\\r\\n    function productImplementation() external view returns (address);\\r\\n    function productImplementations(bytes32 name) external view returns (address);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ProductProxy\\r\\n * @dev This contract implements a proxy that \\r\\n * it is deploied by ProxyFactory, \\r\\n * and it\\u0027s implementation is stored in factory.\\r\\n */\\r\\ncontract ProductProxy is Proxy {\\r\\n    \\r\\n  /**\\r\\n   * @dev Storage slot with the address of the ProxyFactory.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.factory\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n  bytes32 internal constant FACTORY_SLOT = 0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1;\\r\\n  bytes32 internal constant NAME_SLOT    = 0x4cd9b827ca535ceb0880425d70eff88561ecdf04dc32fcf7ff3b15c587f8a870;      // bytes32(uint256(keccak256(\\\"eip1967.proxy.name\\\")) - 1)\\r\\n\\r\\n  function _name() virtual internal view returns (bytes32 name_) {\\r\\n    bytes32 slot = NAME_SLOT;\\r\\n    assembly {  name_ := sload(slot)  }\\r\\n  }\\r\\n  \\r\\n  function _setName(bytes32 name_) internal {\\r\\n    bytes32 slot = NAME_SLOT;\\r\\n    assembly {  sstore(slot, name_)  }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the factory address of the ProductProxy.\\r\\n   * @param newFactory Address of the new factory.\\r\\n   */\\r\\n  function _setFactory(address newFactory) internal {\\r\\n    require(newFactory == address(0) || OpenZeppelinUpgradesAddress.isContract(newFactory), \\\"Cannot set a factory to a non-contract address\\\");\\r\\n\\r\\n    bytes32 slot = FACTORY_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newFactory)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the factory.\\r\\n   * @return factory_ Address of the factory.\\r\\n   */\\r\\n  function _factory() internal view returns (address factory_) {\\r\\n    bytes32 slot = FACTORY_SLOT;\\r\\n    assembly {\\r\\n      factory_ := sload(slot)\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @dev Returns the current implementation.\\r\\n   * @return Address of the current implementation\\r\\n   */\\r\\n  function _implementation() virtual override internal view returns (address) {\\r\\n    address factory_ = _factory();\\r\\n    bytes32 name_ = _name();\\r\\n    if(OpenZeppelinUpgradesAddress.isContract(factory_))\\r\\n        if(name_ != 0x0)\\r\\n            return IProxyFactory(factory_).productImplementations(name_);\\r\\n        else\\r\\n            return IProxyFactory(factory_).productImplementation();\\r\\n    else\\r\\n        return address(0);\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title InitializableProductProxy\\r\\n * @dev Extends ProductProxy with an initializer for initializing\\r\\n * factory and init data.\\r\\n */\\r\\ncontract InitializableProductProxy is ProductProxy {\\r\\n  /**\\r\\n   * @dev Contract initializer.\\r\\n   * @param factory Address of the initial factory.\\r\\n   * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function __InitializableProductProxy_init(address factory, bytes32 name, bytes memory data) external payable {\\r\\n    address factory_ = _factory();\\r\\n    require(factory_ == address(0) || msg.sender == factory_ || msg.sender == IProxyFactory(factory_).governor() || msg.sender == IProxyFactory(factory_).__admin__());\\r\\n    assert(FACTORY_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.factory\\\")) - 1));\\r\\n    assert(NAME_SLOT    == bytes32(uint256(keccak256(\\\"eip1967.proxy.name\\\")) - 1));\\r\\n    _setFactory(factory);\\r\\n    _setName(name);\\r\\n    if(data.length \\u003e 0) {\\r\\n      (bool success,) = _implementation().delegatecall(data);\\r\\n      require(success);\\r\\n    }\\r\\n  }  \\r\\n}\\r\\n\\r\\n\\r\\ncontract __InitializableAdminUpgradeabilityProductProxy__ is __BaseAdminUpgradeabilityProxy__, ProductProxy {\\r\\n  function __InitializableAdminUpgradeabilityProductProxy_init__(address logic, address admin, address factory, bytes32 name, bytes memory data) public payable {\\r\\n    assert(IMPLEMENTATION_SLOT  == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\r\\n    assert(ADMIN_SLOT           == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\r\\n    assert(FACTORY_SLOT         == bytes32(uint256(keccak256(\\\"eip1967.proxy.factory\\\")) - 1));\\r\\n    assert(NAME_SLOT            == bytes32(uint256(keccak256(\\\"eip1967.proxy.name\\\")) - 1));\\r\\n    address admin_ = _admin();\\r\\n    require(admin_ == address(0) || msg.sender == admin_);\\r\\n    _setAdmin(admin);\\r\\n    _setImplementation(logic);\\r\\n    _setFactory(factory);\\r\\n    _setName(name);\\r\\n    if(data.length \\u003e 0) {\\r\\n      (bool success,) = _implementation().delegatecall(data);\\r\\n      require(success);\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  function _implementation() virtual override(BaseUpgradeabilityProxy, ProductProxy) internal view returns (address impl) {\\r\\n    impl = ProductProxy._implementation();\\r\\n    if(impl == address(0))\\r\\n        impl = BaseUpgradeabilityProxy._implementation();\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract __AdminUpgradeabilityProductProxy__ is __InitializableAdminUpgradeabilityProductProxy__ {\\r\\n  constructor(address logic, address admin, address factory, bytes32 name, bytes memory data) public payable {\\r\\n    __InitializableAdminUpgradeabilityProductProxy_init__(logic, admin, factory, name, data);\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract __AdminUpgradeabilityProductProxy0__ is __InitializableAdminUpgradeabilityProductProxy__ {\\r\\n  constructor() public {\\r\\n    __InitializableAdminUpgradeabilityProductProxy_init__(address(0), msg.sender, address(0), 0, \\\"\\\");\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nlibrary Config {\\r\\n  bytes32 internal constant CONFIG_SLOT        = 0x54c601f62ced84cb3960726428d8409adc363a3fa5c7abf6dba0c198dcc43c14;     // bytes32(uint256(keccak256(\\\"eip1967.proxy.config\\\")) - 1));\\r\\n\\r\\n  function config() internal pure returns (mapping (bytes32 =\\u003e uint) storage map) {\\r\\n    assembly {  map_slot := CONFIG_SLOT   }\\r\\n  }\\r\\n\\r\\n  function configA() internal pure returns (mapping (bytes32 =\\u003e address) storage map) {\\r\\n    assembly {  map_slot := CONFIG_SLOT   }\\r\\n  }\\r\\n\\r\\n  function get(bytes32 key) internal view returns (uint) {\\r\\n    return config()[key];\\r\\n  }\\r\\n\\r\\n  function get(bytes32 key, uint index) internal view returns (uint) {\\r\\n    return config()[bytes32(uint(key) ^ index)];\\r\\n  }\\r\\n\\r\\n  function get(bytes32 key, address addr) internal view returns (uint) {\\r\\n    return config()[bytes32(uint(key) ^ uint(addr))];\\r\\n  }\\r\\n\\r\\n  function getA(bytes32 key) internal view returns (address) {\\r\\n    return configA()[key];\\r\\n  }\\r\\n\\r\\n  function getA(bytes32 key, uint index) internal view returns (address) {\\r\\n    return configA()[bytes32(uint(key) ^ index)];\\r\\n  }\\r\\n\\r\\n  function getA(bytes32 key, address addr) internal view returns (address) {\\r\\n    return configA()[bytes32(uint(key) ^ uint(addr))];\\r\\n  }\\r\\n\\r\\n  function set(bytes32 key, uint value) internal {\\r\\n    config()[key] = value;\\r\\n  }\\r\\n\\r\\n  function set(bytes32 key, uint index, uint value) internal {\\r\\n    config()[bytes32(uint(key) ^ index)] = value;\\r\\n  }\\r\\n\\r\\n  function set(bytes32 key, address addr, uint value) internal {\\r\\n    config()[bytes32(uint(key) ^ uint(addr))] = value;\\r\\n  }\\r\\n\\r\\n  function setA(bytes32 key, address value) internal {\\r\\n    configA()[key] = value;\\r\\n  }\\r\\n\\r\\n  function setA(bytes32 key, uint index, address value) internal {\\r\\n    configA()[bytes32(uint(key) ^ index)] = value;\\r\\n  }\\r\\n\\r\\n  function setA(bytes32 key, address addr, address value) internal {\\r\\n    configA()[bytes32(uint(key) ^ uint(addr))] = value;\\r\\n  }\\r\\n\\r\\n  // bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1)\\r\\n  bytes32 internal constant ADMIN_SLOT_ = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n  function admin() internal view returns (address adm) {\\r\\n    bytes32 slot = ADMIN_SLOT_;\\r\\n    assembly {\\r\\n      adm := sload(slot)\\r\\n    }\\r\\n  }\\r\\n    \\r\\n}\\r\\n\\r\\ncontract Setable {\\r\\n  bytes32 internal constant _governor_  = \\\"governor\\\";\\r\\n\\r\\n  constructor() public {\\r\\n    Config.setA(_governor_, msg.sender);\\r\\n  }\\r\\n\\r\\n  function _governance() internal view {\\r\\n    require(msg.sender == Config.getA(_governor_) || msg.sender == Config.admin());\\r\\n  }\\r\\n  \\r\\n  modifier governance() virtual {\\r\\n    _governance();\\r\\n    _;\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract Sets is Setable {\\r\\n  struct KeyValue {\\r\\n    bytes32 key;\\r\\n    uint    value;\\r\\n  }\\r\\n\\r\\n  function sets_(KeyValue[] calldata s) external governance {\\r\\n    for(uint i=0; i\\u003cs.length; i++)\\r\\n      Config.set(s[i].key, s[i].value);\\r\\n  }\\r\\n\\r\\n  function gets(bytes32[] calldata keys) external view returns (uint[] memory values){\\r\\n    values = new uint[](keys.length);\\r\\n    for(uint i=0; i\\u003ckeys.length; i++)\\r\\n      values[i] = Config.get(keys[i]);\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary IDelegateStaticCall {\\r\\n  function delegatestaticcall(address ex, bytes memory data) external view returns (bool, bytes memory) {\\r\\n    return ex.staticcall(data);\\r\\n  }\\r\\n  function delegatestaticcall(bytes memory data) external view returns (bool, bytes memory) {\\r\\n    return address(this).staticcall(data);\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary DelegateStaticCall {\\r\\n  function delegatestaticcall(address ex, bytes memory data) external returns (bool, bytes memory) {\\r\\n    return ex.delegatecall(data);\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract Extend {\\r\\n  bytes32 internal constant _extend_        = \\\"extend\\\";\\r\\n  string  internal constant ERROR_FALLBACK  = \\\"eip1967.proxy.error.fallback\\\";\\r\\n  //bytes32 internal constant ERROR_FALLBACK_HASH = 0xa4ed89f730f2683d5e2b90496ac1d7ea6d9032c060f8c649055bab6502c3e570;     // keccak256(abi.encodeWithSignature(\\\"Error(string)\\\", ERROR_FALLBACK))\\r\\n\\r\\n\\r\\n  //bytes32 internal constant EXTENDS_SLOT        = 0xeecbcf0201b7ee036ec6ec9c93727f8f360e2af38caa9978f4801d35c2f82997;     // bytes32(uint256(keccak256(\\\"eip1967.proxy.extends\\\")) - 1));\\r\\n  //\\r\\n  //function extends() virtual internal pure returns (mapping (bytes4 =\\u003e address) storage map) {\\r\\n  //  assembly {  map_slot := EXTENDS_SLOT   }\\r\\n  //}\\r\\n\\r\\n  function _getExtend(bytes4 sig) virtual internal view returns (address) {\\r\\n    return Config.getA(_extend_, uint32(sig));\\r\\n  }\\r\\n  \\r\\n  function _setExtend(bytes4 sig, address ex) virtual internal {\\r\\n    Config.setA(_extend_, uint32(sig), ex);\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract Extendable is Sets, Extend {\\r\\n  //constructor(address ex0, bytes memory data) public {\\r\\n  //  _setExtend(0x00000000, ex0);\\r\\n  //  if(data.length \\u003e 0) {\\r\\n  //    (bool success,) = ex0.delegatecall(data);\\r\\n  //    require(success);\\r\\n  //  }\\r\\n  //}\\r\\n\\r\\n  modifier viewExtend virtual {\\r\\n    _viewExtend();\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier extend virtual {\\r\\n    _extend();\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function _viewExtend() virtual internal view {\\r\\n    //if(msg.sender == address(this))\\r\\n    //  return;\\r\\n    address ex = _getExtend(0xffffffff);\\r\\n    if(ex == address(0))\\r\\n      ex = _getExtend(msg.sig);\\r\\n    if(OpenZeppelinUpgradesAddress.isContract(ex)) {\\r\\n      (bool success, bytes memory r) = IDelegateStaticCall.delegatestaticcall(ex, msg.data);\\r\\n      if(success)\\r\\n        assembly {  return(add(r, 32), returndatasize())  }\\r\\n      else\\r\\n        assembly {  revert(add(r, 32), returndatasize())  }\\r\\n    } else if(ex == 0x000000000000000000000000000000000000dEaD)\\r\\n      revert(\\\"obsolete\\\");\\r\\n  }\\r\\n  \\r\\n  function _extend() virtual internal {\\r\\n    address ex = _getExtend(0xffffffff);\\r\\n    if(ex == address(0))\\r\\n      ex = _getExtend(msg.sig);\\r\\n    return _extend(ex);\\r\\n  }\\r\\n\\r\\n  function _extend0() virtual internal {\\r\\n    address ex = address(0);\\r\\n    address ex1 = _getExtend(0xffffffff);\\r\\n    if(ex1 == address(0))\\r\\n      ex = _getExtend(msg.sig);\\r\\n    if(ex == address(0)) {\\r\\n      ex = _getExtend(0);\\r\\n      if(ex == address(0)) {\\r\\n        ex = ex1;\\r\\n        require(ex != address(0), ERROR_FALLBACK);\\r\\n      }\\r\\n    }\\r\\n    return _extend(ex);\\r\\n  }\\r\\n\\r\\n  function _extend(address ex) internal {\\r\\n    if(OpenZeppelinUpgradesAddress.isContract(ex)) {\\r\\n      (bool success, bytes memory r) = ex.delegatecall(msg.data);\\r\\n      if(success)\\r\\n        assembly {  return(add(r, 32), returndatasize())  }\\r\\n      else\\r\\n        assembly {  revert(add(r, 32), returndatasize())  }\\r\\n    } else if(ex == 0x000000000000000000000000000000000000dEaD)\\r\\n      revert(\\\"obsolete\\\");\\r\\n  }\\r\\n\\r\\n  struct SigEx {\\r\\n    bytes4  sig;\\r\\n    address ex;\\r\\n  }\\r\\n  \\r\\n  function setExtends_(SigEx[] memory s) external governance {\\r\\n    for(uint i=0; i\\u003cs.length; i++)\\r\\n      _setExtend(s[i].sig, s[i].ex);\\r\\n  }\\r\\n\\r\\n  fallback () virtual payable external {\\r\\n    _extend0();\\r\\n  }\\r\\n  \\r\\n  receive () virtual payable external {\\r\\n    if(OpenZeppelinUpgradesAddress.isContract(msg.sender) \\u0026\\u0026 msg.data.length == 0 \\u0026\\u0026 gasleft() \\u003c= 2300)         // for receive ETH only from other contract\\r\\n        return;\\r\\n    _extend0();\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract Extended is Setable, Extend {\\r\\n  function _callback(bytes memory data) internal returns(bytes memory rdata) {\\r\\n    bytes4 sig = abi.decode(data, (bytes4));\\r\\n    address ex = _getExtend(sig);\\r\\n    if(ex != address(0))\\r\\n      _setExtend(sig, address(0));\\r\\n    address ex1 = _getExtend(0xffffffff);\\r\\n    if(ex1 != address(0))\\r\\n      _setExtend(0xffffffff, address(0));\\r\\n    bool success;\\r\\n    (success, rdata) = address(this).delegatecall(data);\\r\\n    if(!success)\\r\\n      assembly {  revert(add(data, 32), returndatasize()) }\\r\\n    if(ex != address(0))\\r\\n      _setExtend(sig, ex);\\r\\n    if(ex1 != address(0))\\r\\n      _setExtend(0xffffffff, ex1);\\r\\n  }\\r\\n\\r\\n  fallback () virtual payable external {\\r\\n     revert(ERROR_FALLBACK);\\r\\n  }\\r\\n\\r\\n  receive () virtual payable external {\\r\\n    if(OpenZeppelinUpgradesAddress.isContract(msg.sender) \\u0026\\u0026 msg.data.length == 0)         // for receive ETH only from other contract\\r\\n      return;\\r\\n    revert(ERROR_FALLBACK);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Initializable\\r\\n *\\r\\n * @dev Helper contract to support initializer functions. To use it, replace\\r\\n * the constructor with a function that has the `initializer` modifier.\\r\\n * WARNING: Unlike constructors, initializer functions must be manually\\r\\n * invoked. This applies both to deploying an Initializable contract, as well\\r\\n * as extending an Initializable contract via inheritance.\\r\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\r\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\r\\n * because this is not dealt with automatically as with constructors.\\r\\n */\\r\\ncontract Initializable {\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract has been initialized.\\r\\n   */\\r\\n  bool private initialized;\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract is in the process of being initialized.\\r\\n   */\\r\\n  bool private initializing;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to use in the initializer function of a contract.\\r\\n   */\\r\\n  modifier initializer() {\\r\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\r\\n\\r\\n    bool isTopLevelCall = !initializing;\\r\\n    if (isTopLevelCall) {\\r\\n      initializing = true;\\r\\n      initialized = true;\\r\\n    }\\r\\n\\r\\n    _;\\r\\n\\r\\n    if (isTopLevelCall) {\\r\\n      initializing = false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Returns true if and only if the function is running in the constructor\\r\\n  function isConstructor() private view returns (bool) {\\r\\n    // extcodesize checks the size of the code stored in an address, and\\r\\n    // address returns the current address. Since the code is still not\\r\\n    // deployed when running a constructor, any checks on its code size will\\r\\n    // yield zero, making it an effective way to detect if a contract is\\r\\n    // under construction or not.\\r\\n    address self = address(this);\\r\\n    uint256 cs;\\r\\n    assembly { cs := extcodesize(self) }\\r\\n    return cs == 0;\\r\\n  }\\r\\n\\r\\n  // Reserved storage space to allow for layout changes in the future.\\r\\n  uint256[50] private ______gap;\\r\\n}\\r\\n\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract ContextUpgradeSafe is Initializable {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n\\r\\n    function __Context_init() internal initializer {\\r\\n        __Context_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __Context_init_unchained() internal initializer {\\r\\n\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\ncontract ReentrancyGuardUpgradeSafe is Initializable {\\r\\n    bool private _notEntered;\\r\\n\\r\\n\\r\\n    function __ReentrancyGuard_init() internal initializer {\\r\\n        __ReentrancyGuard_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\r\\n\\r\\n\\r\\n        // Storing an initial non-zero value makes deployment a bit more\\r\\n        // expensive, but in exchange the refund on every call to nonReentrant\\r\\n        // will be lower in amount. Since refunds are capped to a percetange of\\r\\n        // the total transaction\\u0027s gas, it is best to keep them low in cases\\r\\n        // like this one, to increase the likelihood of the full refund coming\\r\\n        // into effect.\\r\\n        _notEntered = true;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _notEntered = false;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    uint256[49] private __gap;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n\\r\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\r\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\r\\n        if (x == 0) return 0;\\r\\n        // this block is equivalent to r = uint256(1) \\u003c\\u003c (BitMath.mostSignificantBit(x) / 2);\\r\\n        // however that code costs significantly more gas\\r\\n        uint256 xx = x;\\r\\n        uint256 r = 1;\\r\\n        if (xx \\u003e= 0x100000000000000000000000000000000) {\\r\\n            xx \\u003e\\u003e= 128;\\r\\n            r \\u003c\\u003c= 64;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10000000000000000) {\\r\\n            xx \\u003e\\u003e= 64;\\r\\n            r \\u003c\\u003c= 32;\\r\\n        }\\r\\n        if (xx \\u003e= 0x100000000) {\\r\\n            xx \\u003e\\u003e= 32;\\r\\n            r \\u003c\\u003c= 16;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10000) {\\r\\n            xx \\u003e\\u003e= 16;\\r\\n            r \\u003c\\u003c= 8;\\r\\n        }\\r\\n        if (xx \\u003e= 0x100) {\\r\\n            xx \\u003e\\u003e= 8;\\r\\n            r \\u003c\\u003c= 4;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10) {\\r\\n            xx \\u003e\\u003e= 4;\\r\\n            r \\u003c\\u003c= 2;\\r\\n        }\\r\\n        if (xx \\u003e= 0x8) {\\r\\n            r \\u003c\\u003c= 1;\\r\\n        }\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1; // Seven iterations should be enough\\r\\n        uint256 r1 = x / r;\\r\\n        return (r \\u003c r1 ? r : r1);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub0(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e b ? a - b : 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div0(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return b == 0 ? 0 : a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Utility library of inline functions on addresses\\r\\n *\\r\\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\\r\\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\\r\\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\\r\\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\\r\\n */\\r\\nlibrary OpenZeppelinUpgradesAddress {\\r\\n    /**\\r\\n     * Returns whether the target address is a contract\\r\\n     * @dev This function will return false if invoked during the constructor of a contract,\\r\\n     * as the code is not actually created until after the constructor finishes.\\r\\n     * @param account address of the account to check\\r\\n     * @return whether the target address is a contract\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        // XXX Currently there is no better way to check if there is a contract in an address\\r\\n        // than to check the size of the code at that address.\\r\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n        // for more details about how this works.\\r\\n        // TODO Check this again before the Serenity release, because all addresses will be\\r\\n        // contracts then.\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20MinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20UpgradeSafe is ContextUpgradeSafe, IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowances;\\r\\n\\r\\n    uint256 internal _totalSupply;\\r\\n\\r\\n    string internal _name;\\r\\n    string internal _symbol;\\r\\n    uint8 internal _decimals;\\r\\n\\r\\n    uint256 internal _cap;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\r\\n     * a default value of 18.\\r\\n     *\\r\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\r\\n     *\\r\\n     * All three of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n\\r\\n    function __ERC20_init(string memory name, string memory symbol) internal initializer {\\r\\n        __Context_init_unchained();\\r\\n        __ERC20_init_unchained(name, symbol);\\r\\n    }\\r\\n\\r\\n    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {\\r\\n        _name = name;\\r\\n        _symbol = symbol;\\r\\n        _decimals = 18;\\r\\n    }\\r\\n\\r\\n    function __ERC20Capped_init(string memory name, string memory symbol, uint256 cap) internal initializer {\\r\\n        __Context_init_unchained();\\r\\n        __ERC20_init_unchained(name, symbol);\\r\\n        __ERC20Capped_init_unchained(cap);\\r\\n    }\\r\\n\\r\\n    function __ERC20Capped_init_unchained(uint256 cap) internal initializer {\\r\\n        require(cap \\u003e 0, \\\"ERC20Capped: cap is 0\\\");\\r\\n        _cap = cap;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the cap on the token\\u0027s total supply.\\r\\n     */\\r\\n    function cap() virtual public view returns (uint256) {\\r\\n        return _cap;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() virtual public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() virtual public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\r\\n     * called.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() virtual public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public virtual override view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) virtual override public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20};\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        if(sender != _msgSender() \\u0026\\u0026 _allowances[sender][_msgSender()] != uint(-1))\\r\\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n\\r\\n        _afterTokenTransfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        if (_cap \\u003e 0) { // When Capped\\r\\n            require(_totalSupply.add(amount) \\u003c= _cap, \\\"ERC20Capped: cap exceeded\\\");\\r\\n        }\\r\\n\\t\\t\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n  \\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n  }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\r\\n     *\\r\\n     * WARNING: This function should only be called from the constructor. Most\\r\\n     * applications that interact with token contracts will not expect\\r\\n     * {decimals} to ever change, and may work incorrectly if it does.\\r\\n     */\\r\\n    function _setupDecimals(uint8 decimals_) internal {\\r\\n        _decimals = decimals_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * has been transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens have been burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n\\r\\n    uint256[43] private __gap;\\r\\n}\\r\\n\\r\\n\\r\\ncontract ERC20Permit is ERC20UpgradeSafe {\\t\\t// ERC2612\\r\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\r\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\r\\n    bytes32 public DOMAIN_SEPARATOR;\\r\\n    mapping (address =\\u003e uint) public nonces;\\r\\n    \\r\\n    function __ERC20Permit_init_unchained() internal initializer {\\r\\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(_name)), keccak256(bytes(\\\"1\\\")), _chainId(), address(this)));\\r\\n    }\\r\\n    \\r\\n    function _chainId() internal pure returns (uint id) {\\r\\n        assembly { id := chainid() }\\r\\n    }\\r\\n    \\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) virtual external {\\r\\n      return _permit(owner, spender, value, deadline, v, r, s);\\r\\n    }\\r\\n    function _permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) virtual internal {\\r\\n        require(deadline \\u003e= block.timestamp, \\\"permit EXPIRED\\\");\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                DOMAIN_SEPARATOR,\\r\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\r\\n            )\\r\\n        );\\r\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\r\\n        require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\\"permit INVALID_SIGNATURE\\\");\\r\\n        _approve(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    uint256[48] private __gap;\\r\\n}\\r\\n\\r\\n\\r\\nlibrary $M {\\r\\n    function msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    function chainId() internal pure returns (uint id) {\\r\\n        assembly { id := chainid() }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\nstruct ERC20Stru {\\r\\n    mapping (address =\\u003e uint256) balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowances;\\r\\n    uint256 totalSupply;\\r\\n\\r\\n    string name;\\r\\n    string symbol;\\r\\n    uint8 decimals;\\r\\n\\r\\n    uint256 cap;\\r\\n\\r\\n    bytes32 DOMAIN_SEPARATOR;\\r\\n    mapping (address =\\u003e uint) nonces;\\r\\n}\\r\\n\\r\\nlibrary ERC20Lib {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\r\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\r\\n    \\r\\n    function ERC20_init(ERC20Stru storage $, string memory name, string memory symbol) internal {\\r\\n        ERC20_init_unchained($, name, symbol);\\r\\n    }\\r\\n    \\r\\n    function ERC20_init_unchained(ERC20Stru storage $, string memory name, string memory symbol) internal {\\r\\n        $.name = name;\\r\\n        $.symbol = symbol;\\r\\n        $.decimals = 18;\\r\\n    }\\r\\n    \\r\\n    function ERC20Capped_init(ERC20Stru storage $, string memory name, string memory symbol, uint256 cap) internal {\\r\\n        ERC20_init_unchained($, name, symbol);\\r\\n        ERC20Capped_init_unchained($, cap);\\r\\n    }\\r\\n    \\r\\n    function ERC20Capped_init_unchained(ERC20Stru storage $, uint256 cap) internal {\\r\\n        require(cap \\u003e 0, \\\"ERC20Capped: cap is 0\\\");\\r\\n        $.cap = cap;\\r\\n    }\\r\\n    \\r\\n    function ERC20Permit_init(ERC20Stru storage $, string memory name, string memory symbol, uint256 cap) internal {\\r\\n        ERC20_init_unchained($, name, symbol);\\r\\n        ERC20Capped_init_unchained($, cap);\\r\\n        ERC20Permit_init_unchained($);\\r\\n    }\\r\\n    \\r\\n    function ERC20Permit_init_unchained(ERC20Stru storage $) internal {\\r\\n        $.DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes($.name)), keccak256(bytes(\\\"1\\\")), $M.chainId(), address(this)));\\r\\n    }\\r\\n    \\r\\n    function setupDecimals(ERC20Stru storage $, uint8 decimals) internal {\\r\\n        $.decimals = decimals;\\r\\n    }\\r\\n\\r\\n    function transfer(ERC20Stru storage $, address recipient, uint256 amount) internal returns (bool) {\\r\\n        transfer($, $M.msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function allowance(ERC20Stru storage $, address owner, address spender) internal view returns (uint256) {\\r\\n        return $.allowances[owner][spender];\\r\\n    }\\r\\n    \\r\\n    function approve(ERC20Stru storage $, address spender, uint256 amount) internal returns (bool) {\\r\\n        approve($, $M.msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function transferFrom(ERC20Stru storage $, address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        transfer($, sender, recipient, amount);\\r\\n        if(sender != $M.msgSender() \\u0026\\u0026 $.allowances[sender][$M.msgSender()] != uint(-1))\\r\\n            approve($, sender, $M.msgSender(), $.allowances[sender][$M.msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function increaseAllowance(ERC20Stru storage $, address spender, uint256 addedValue) internal returns (bool) {\\r\\n        approve($, $M.msgSender(), spender, $.allowances[$M.msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function decreaseAllowance(ERC20Stru storage $, address spender, uint256 subtractedValue) internal returns (bool) {\\r\\n        approve($, $M.msgSender(), spender, $.allowances[$M.msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function transfer(ERC20Stru storage $, address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        //_beforeTokenTransfer($, sender, recipient, amount);\\r\\n\\r\\n        $.balances[sender] = $.balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        $.balances[recipient] = $.balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function mint(ERC20Stru storage $, address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        if ($.cap \\u003e 0) { // When Capped\\r\\n            require($.totalSupply.add(amount) \\u003c= $.cap, \\\"ERC20Capped: cap exceeded\\\");\\r\\n        }\\r\\n\\t\\t\\r\\n        //_beforeTokenTransfer($, address(0), account, amount);\\r\\n\\r\\n        $.totalSupply = $.totalSupply.add(amount);\\r\\n        $.balances[account] = $.balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function burn(ERC20Stru storage $, address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        //_beforeTokenTransfer($, account, address(0), amount);\\r\\n\\r\\n        $.balances[account] = $.balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        $.totalSupply = $.totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    function approve(ERC20Stru storage $, address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        $.allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function permit(ERC20Stru storage $, address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) internal {\\r\\n        require(deadline \\u003e= block.timestamp, \\\"permit EXPIRED\\\");\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                $.DOMAIN_SEPARATOR,\\r\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, $.nonces[owner]++, deadline))\\r\\n            )\\r\\n        );\\r\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\r\\n        require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\\"permit INVALID_SIGNATURE\\\");\\r\\n        approve($, owner, spender, value);\\r\\n    }\\r\\n\\r\\n    //function _beforeTokenTransfer(ERC20Stru storage $, address from, address to, uint256 amount) internal { }\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\\"safeIncreaseAllowance\\\" and \\\"safeDecreaseAllowance\\\"\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove_(IERC20 token, address spender, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract Governable is Initializable {\\r\\n    address public governor;\\r\\n\\r\\n    event GovernorshipTransferred(address indexed previousGovernor, address indexed newGovernor);\\r\\n\\r\\n    /**\\r\\n     * @dev Contract initializer.\\r\\n     * called once by the factory at time of deployment\\r\\n     */\\r\\n    function __Governable_init_unchained(address governor_) virtual internal initializer {\\r\\n        governor = governor_;\\r\\n        emit GovernorshipTransferred(address(0), governor);\\r\\n    }\\r\\n\\r\\n    modifier governance() virtual {\\r\\n        require(msg.sender == governor || msg.sender == Config.admin());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current governor to relinquish control of the contract.\\r\\n     * @notice Renouncing to governorship will leave the contract without an governor.\\r\\n     * It will not be possible to call the functions with the `governance`\\r\\n     * modifier anymore.\\r\\n     */\\r\\n    function renounceGovernorship_() public governance {\\r\\n        emit GovernorshipTransferred(governor, address(0));\\r\\n        governor = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current governor to transfer control of the contract to a newGovernor.\\r\\n     * @param newGovernor The address to transfer governorship to.\\r\\n     */\\r\\n    function transferGovernorship_(address newGovernor) public governance {\\r\\n        _transferGovernorship(newGovernor);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers control of the contract to a newGovernor.\\r\\n     * @param newGovernor The address to transfer governorship to.\\r\\n     */\\r\\n    function _transferGovernorship(address newGovernor) internal {\\r\\n        require(newGovernor != address(0));\\r\\n        emit GovernorshipTransferred(governor, newGovernor);\\r\\n        governor = newGovernor;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract Configurable is Governable {\\r\\n    mapping (bytes32 =\\u003e uint) internal config;\\r\\n    \\r\\n    function getConfig(bytes32 key) public view returns (uint) {\\r\\n        return config[key];\\r\\n    }\\r\\n    function getConfigI(bytes32 key, uint index) public view returns (uint) {\\r\\n        return config[bytes32(uint(key) ^ index)];\\r\\n    }\\r\\n    function getConfigA(bytes32 key, address addr) public view returns (uint) {\\r\\n        return config[bytes32(uint(key) ^ uint(addr))];\\r\\n    }\\r\\n\\r\\n    function _setConfig(bytes32 key, uint value) internal {\\r\\n        if(config[key] != value)\\r\\n            config[key] = value;\\r\\n    }\\r\\n    function _setConfig(bytes32 key, uint index, uint value) internal {\\r\\n        _setConfig(bytes32(uint(key) ^ index), value);\\r\\n    }\\r\\n    function _setConfig(bytes32 key, address addr, uint value) internal {\\r\\n        _setConfig(bytes32(uint(key) ^ uint(addr)), value);\\r\\n    }\\r\\n\\r\\n    function setConfig_(bytes32 key, uint value) external governance {\\r\\n        _setConfig(key, value);\\r\\n    }\\r\\n    function setConfigI_(bytes32 key, uint index, uint value) external governance {\\r\\n        _setConfig(bytes32(uint(key) ^ index), value);\\r\\n    }\\r\\n    function setConfigA_(bytes32 key, address addr, uint value) public governance {\\r\\n        _setConfig(bytes32(uint(key) ^ uint(addr)), value);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract Rescue is Governable, Setable {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    modifier governance() override(Governable, Setable) {\\r\\n        require(msg.sender == governor || msg.sender == Config.admin() || msg.sender == Config.getA(_governor_));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function rescue(address payable _dst, uint _amt) external governance {\\r\\n        _dst.transfer(Math.min(_amt, address(this).balance));\\r\\n    }\\r\\n\\r\\n    function rescueTokens(address _token, address _dst, uint _amt) external governance {\\r\\n        uint balance = IERC20(_token).balanceOf(address(this));\\r\\n        IERC20(_token).safeTransfer(_dst, Math.min(_amt, balance));\\r\\n    }\\r\\n}\\r\\n\"},\"IUniswapV3.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity \\u003e=0.5.0 \\u003c0.8.0;\\r\\npragma experimental ABIEncoderV2;   // pragma abicoder v2;\\r\\n\\r\\nimport \\\"./ERC721.sol\\\";\\r\\n\\r\\n// https://docs.uniswap.org/sdk/guides/fetching-prices\\r\\n// https://github.com/Uniswap/v3-sdk/blob/12f3b7033bd70210a4f117b477cdaec027a436f6/src/utils/tickMath.ts\\r\\n// https://github.com/Uniswap/v3-sdk/blob/12f3b7033bd70210a4f117b477cdaec027a436f6/src/utils/priceTickConversions.ts\\r\\n\\r\\ninterface IUniswapV3Factory {\\r\\n    /// @notice Emitted when the owner of the factory is changed\\r\\n    /// @param oldOwner The owner before the owner was changed\\r\\n    /// @param newOwner The owner after the owner was changed\\r\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n    /// @notice Emitted when a pool is created\\r\\n    /// @param token0 The first token of the pool by address sort order\\r\\n    /// @param token1 The second token of the pool by address sort order\\r\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\r\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\r\\n    /// @param pool The address of the created pool\\r\\n    event PoolCreated(\\r\\n        address indexed token0,\\r\\n        address indexed token1,\\r\\n        uint24 indexed fee,\\r\\n        int24 tickSpacing,\\r\\n        address pool\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\r\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\r\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\r\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\r\\n\\r\\n    /// @notice Returns the current owner of the factory\\r\\n    /// @dev Can be changed by the current owner via setOwner\\r\\n    /// @return The address of the factory owner\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\r\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\r\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\r\\n    /// @return The tick spacing\\r\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\r\\n\\r\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\r\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\r\\n    /// @param tokenA The contract address of either token0 or token1\\r\\n    /// @param tokenB The contract address of the other token\\r\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\r\\n    /// @return pool The pool address\\r\\n    function getPool(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint24 fee\\r\\n    ) external view returns (address pool);\\r\\n\\r\\n    /// @notice Creates a pool for the given two tokens and fee\\r\\n    /// @param tokenA One of the two tokens in the desired pool\\r\\n    /// @param tokenB The other of the two tokens in the desired pool\\r\\n    /// @param fee The desired fee for the pool\\r\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\r\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\r\\n    /// are invalid.\\r\\n    /// @return pool The address of the newly created pool\\r\\n    function createPool(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint24 fee\\r\\n    ) external returns (address pool);\\r\\n\\r\\n    /// @notice Updates the owner of the factory\\r\\n    /// @dev Must be called by the current owner\\r\\n    /// @param _owner The new owner of the factory\\r\\n    function setOwner(address _owner) external;\\r\\n\\r\\n    /// @notice Enables a fee amount with the given tickSpacing\\r\\n    /// @dev Fee amounts may never be removed once enabled\\r\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\r\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\r\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\r\\n}\\r\\n\\r\\n/// @title Pool state that never changes\\r\\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\\r\\ninterface IUniswapV3PoolImmutables {\\r\\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\\r\\n    /// @return The contract address\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    /// @notice The first of the two tokens of the pool, sorted by address\\r\\n    /// @return The token contract address\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    /// @notice The second of the two tokens of the pool, sorted by address\\r\\n    /// @return The token contract address\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    /// @notice The pool\\u0027s fee in hundredths of a bip, i.e. 1e-6\\r\\n    /// @return The fee\\r\\n    function fee() external view returns (uint24);\\r\\n\\r\\n    /// @notice The pool tick spacing\\r\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\r\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\r\\n    /// This value is an int24 to avoid casting even though it is always positive.\\r\\n    /// @return The tick spacing\\r\\n    function tickSpacing() external view returns (int24);\\r\\n\\r\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\r\\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\r\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\r\\n    /// @return The max amount of liquidity per tick\\r\\n    function maxLiquidityPerTick() external view returns (uint128);\\r\\n}\\r\\n\\r\\n/// @title Pool state that can change\\r\\n/// @notice These methods compose the pool\\u0027s state, and can change with any frequency including multiple times\\r\\n/// per transaction\\r\\ninterface IUniswapV3PoolState {\\r\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\r\\n    /// when accessed externally.\\r\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\r\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\r\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\r\\n    /// boundary.\\r\\n    /// observationIndex The index of the last oracle observation that was written,\\r\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\r\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\r\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\r\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\r\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\r\\n    /// unlocked Whether the pool is currently locked to reentrancy\\r\\n    function slot0()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint160 sqrtPriceX96,\\r\\n            int24 tick,\\r\\n            uint16 observationIndex,\\r\\n            uint16 observationCardinality,\\r\\n            uint16 observationCardinalityNext,\\r\\n            uint8 feeProtocol,\\r\\n            bool unlocked\\r\\n        );\\r\\n\\r\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\r\\n    /// @dev This value can overflow the uint256\\r\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\r\\n\\r\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\r\\n    /// @dev This value can overflow the uint256\\r\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\r\\n\\r\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\r\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\r\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\r\\n\\r\\n    /// @notice The currently in range liquidity available to the pool\\r\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\r\\n    function liquidity() external view returns (uint128);\\r\\n\\r\\n    /// @notice Look up information about a specific tick in the pool\\r\\n    /// @param tick The tick to look up\\r\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\r\\n    /// tick upper,\\r\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\r\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\r\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\r\\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\r\\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\r\\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\\r\\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\r\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\r\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\r\\n    /// a specific position.\\r\\n    function ticks(int24 tick)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 liquidityGross,\\r\\n            int128 liquidityNet,\\r\\n            uint256 feeGrowthOutside0X128,\\r\\n            uint256 feeGrowthOutside1X128,\\r\\n            int56 tickCumulativeOutside,\\r\\n            uint160 secondsPerLiquidityOutsideX128,\\r\\n            uint32 secondsOutside,\\r\\n            bool initialized\\r\\n        );\\r\\n\\r\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\r\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\r\\n\\r\\n    /// @notice Returns the information about a position by the position\\u0027s key\\r\\n    /// @param key The position\\u0027s key is a hash of a preimage composed by the owner, tickLower and tickUpper\\r\\n    /// @return _liquidity The amount of liquidity in the position,\\r\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\r\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\r\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\r\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\r\\n    function positions(bytes32 key)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 _liquidity,\\r\\n            uint256 feeGrowthInside0LastX128,\\r\\n            uint256 feeGrowthInside1LastX128,\\r\\n            uint128 tokensOwed0,\\r\\n            uint128 tokensOwed1\\r\\n        );\\r\\n\\r\\n    /// @notice Returns data about a specific observation index\\r\\n    /// @param index The element of the observations array to fetch\\r\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\r\\n    /// ago, rather than at a specific index in the array.\\r\\n    /// @return blockTimestamp The timestamp of the observation,\\r\\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\r\\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\r\\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\\r\\n    function observations(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint32 blockTimestamp,\\r\\n            int56 tickCumulative,\\r\\n            uint160 secondsPerLiquidityCumulativeX128,\\r\\n            bool initialized\\r\\n        );\\r\\n}\\r\\n\\r\\n/// @title Pool state that is not stored\\r\\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\r\\n/// blockchain. The functions here may have variable gas costs.\\r\\ninterface IUniswapV3PoolDerivedState {\\r\\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\r\\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\r\\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\r\\n    /// you must call it with secondsAgos = [3600, 0].\\r\\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\r\\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\r\\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\r\\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\r\\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\\r\\n    /// timestamp\\r\\n    function observe(uint32[] calldata secondsAgos)\\r\\n        external\\r\\n        view\\r\\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\\r\\n\\r\\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\r\\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\r\\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\r\\n    /// snapshot is taken and the second snapshot is taken.\\r\\n    /// @param tickLower The lower tick of the range\\r\\n    /// @param tickUpper The upper tick of the range\\r\\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\\r\\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\\r\\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\\r\\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            int56 tickCumulativeInside,\\r\\n            uint160 secondsPerLiquidityInsideX128,\\r\\n            uint32 secondsInside\\r\\n        );\\r\\n}\\r\\n\\r\\ninterface IUniswapV3PoolActions {\\r\\n    /// @notice Sets the initial price for the pool\\r\\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\r\\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\\r\\n    function initialize(uint160 sqrtPriceX96) external;\\r\\n\\r\\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\\r\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\\r\\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\r\\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\\r\\n    /// @param recipient The address for which the liquidity will be created\\r\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\r\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\r\\n    /// @param amount The amount of liquidity to mint\\r\\n    /// @param data Any data that should be passed through to the callback\\r\\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\r\\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\r\\n    function mint(\\r\\n        address recipient,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    /// @notice Collects tokens owed to a position\\r\\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\r\\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\r\\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\r\\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\r\\n    /// @param recipient The address which should receive the fees collected\\r\\n    /// @param tickLower The lower tick of the position for which to collect fees\\r\\n    /// @param tickUpper The upper tick of the position for which to collect fees\\r\\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\\r\\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\\r\\n    /// @return amount0 The amount of fees collected in token0\\r\\n    /// @return amount1 The amount of fees collected in token1\\r\\n    function collect(\\r\\n        address recipient,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount0Requested,\\r\\n        uint128 amount1Requested\\r\\n    ) external returns (uint128 amount0, uint128 amount1);\\r\\n\\r\\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\r\\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\r\\n    /// @dev Fees must be collected separately via a call to #collect\\r\\n    /// @param tickLower The lower tick of the position for which to burn liquidity\\r\\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\\r\\n    /// @param amount How much liquidity to burn\\r\\n    /// @return amount0 The amount of token0 sent to the recipient\\r\\n    /// @return amount1 The amount of token1 sent to the recipient\\r\\n    function burn(\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    /// @notice Swap token0 for token1, or token1 for token0\\r\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\\r\\n    /// @param recipient The address to receive the output of the swap\\r\\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\\r\\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\r\\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\r\\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\\r\\n    /// @param data Any data to be passed through to the callback\\r\\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\r\\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\r\\n    function swap(\\r\\n        address recipient,\\r\\n        bool zeroForOne,\\r\\n        int256 amountSpecified,\\r\\n        uint160 sqrtPriceLimitX96,\\r\\n        bytes calldata data\\r\\n    ) external returns (int256 amount0, int256 amount1);\\r\\n\\r\\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\r\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\\r\\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\\r\\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\\r\\n    /// @param recipient The address which will receive the token0 and token1 amounts\\r\\n    /// @param amount0 The amount of token0 to send\\r\\n    /// @param amount1 The amount of token1 to send\\r\\n    /// @param data Any data to be passed through to the callback\\r\\n    function flash(\\r\\n        address recipient,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\\r\\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\r\\n    /// the input observationCardinalityNext.\\r\\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\r\\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\r\\n}\\r\\n\\r\\n/// @title The interface for a Uniswap V3 Pool\\r\\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\\r\\n/// to the ERC20 specification\\r\\n/// @dev The pool interface is broken up into many smaller pieces\\r\\ninterface IUniswapV3Pool is\\r\\n    IUniswapV3PoolImmutables,\\r\\n    IUniswapV3PoolState,\\r\\n    IUniswapV3PoolDerivedState,\\r\\n    IUniswapV3PoolActions//,\\r\\n//    IUniswapV3PoolOwnerActions,\\r\\n//    IUniswapV3PoolEvents\\r\\n{\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n/// @title Creates and initializes V3 Pools\\r\\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\\r\\n/// require the pool to exist.\\r\\ninterface IPoolInitializer {\\r\\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\\r\\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\\r\\n    /// @param token0 The contract address of token0 of the pool\\r\\n    /// @param token1 The contract address of token1 of the pool\\r\\n    /// @param fee The fee amount of the v3 pool for the specified token pair\\r\\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\\r\\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\\r\\n    function createAndInitializePoolIfNecessary(\\r\\n        address token0,\\r\\n        address token1,\\r\\n        uint24 fee,\\r\\n        uint160 sqrtPriceX96\\r\\n    ) external payable returns (address pool);\\r\\n}\\r\\n\\r\\n/// @title Immutable state\\r\\n/// @notice Functions that return immutable state of the router\\r\\ninterface IPeripheryImmutableState {\\r\\n    /// @return Returns the address of the Uniswap V3 factory\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    /// @return Returns the address of WETH9\\r\\n    function WETH9() external view returns (address);\\r\\n}\\r\\n\\r\\n/// @title Non-fungible token for positions\\r\\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\\r\\n/// and authorized.\\r\\ninterface INonfungiblePositionManager is\\r\\n    IPoolInitializer,\\r\\n    //IPeripheryPayments,\\r\\n    IPeripheryImmutableState,\\r\\n    IERC721Metadata,\\r\\n    IERC721Enumerable//,\\r\\n    //IERC721Permit\\r\\n{\\r\\n    /// @notice Emitted when liquidity is increased for a position NFT\\r\\n    /// @dev Also emitted when a token is minted\\r\\n    /// @param tokenId The ID of the token for which liquidity was increased\\r\\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\\r\\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\\r\\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\\r\\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\\r\\n    /// @notice Emitted when liquidity is decreased for a position NFT\\r\\n    /// @param tokenId The ID of the token for which liquidity was decreased\\r\\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\\r\\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\\r\\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\\r\\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\\r\\n    /// @notice Emitted when tokens are collected for a position NFT\\r\\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\\r\\n    /// @param tokenId The ID of the token for which underlying tokens were collected\\r\\n    /// @param recipient The address of the account that received the collected tokens\\r\\n    /// @param amount0 The amount of token0 owed to the position that was collected\\r\\n    /// @param amount1 The amount of token1 owed to the position that was collected\\r\\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\\r\\n\\r\\n    /// @notice Returns the position information associated with a given token ID.\\r\\n    /// @dev Throws if the token ID is not valid.\\r\\n    /// @param tokenId The ID of the token that represents the position\\r\\n    /// @return nonce The nonce for permits\\r\\n    /// @return operator The address that is approved for spending\\r\\n    /// @return token0 The address of the token0 for a specific pool\\r\\n    /// @return token1 The address of the token1 for a specific pool\\r\\n    /// @return fee The fee associated with the pool\\r\\n    /// @return tickLower The lower end of the tick range for the position\\r\\n    /// @return tickUpper The higher end of the tick range for the position\\r\\n    /// @return liquidity The liquidity of the position\\r\\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\\r\\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\\r\\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\\r\\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\\r\\n    function positions(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint96 nonce,\\r\\n            address operator,\\r\\n            address token0,\\r\\n            address token1,\\r\\n            uint24 fee,\\r\\n            int24 tickLower,\\r\\n            int24 tickUpper,\\r\\n            uint128 liquidity,\\r\\n            uint256 feeGrowthInside0LastX128,\\r\\n            uint256 feeGrowthInside1LastX128,\\r\\n            uint128 tokensOwed0,\\r\\n            uint128 tokensOwed1\\r\\n        );\\r\\n\\r\\n    struct MintParams {\\r\\n        address token0;\\r\\n        address token1;\\r\\n        uint24 fee;\\r\\n        int24 tickLower;\\r\\n        int24 tickUpper;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    /// @notice Creates a new position wrapped in a NFT\\r\\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\\r\\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\\r\\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\\r\\n    /// @return tokenId The ID of the token that represents the minted position\\r\\n    /// @return liquidity The amount of liquidity for this position\\r\\n    /// @return amount0 The amount of token0\\r\\n    /// @return amount1 The amount of token1\\r\\n    function mint(MintParams calldata params)\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 tokenId,\\r\\n            uint128 liquidity,\\r\\n            uint256 amount0,\\r\\n            uint256 amount1\\r\\n        );\\r\\n\\r\\n    struct IncreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\\r\\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\\r\\n    /// amount0Desired The desired amount of token0 to be spent,\\r\\n    /// amount1Desired The desired amount of token1 to be spent,\\r\\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\\r\\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\\r\\n    /// deadline The time by which the transaction must be included to effect the change\\r\\n    /// @return liquidity The new liquidity amount as a result of the increase\\r\\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\\r\\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\\r\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint128 liquidity,\\r\\n            uint256 amount0,\\r\\n            uint256 amount1\\r\\n        );\\r\\n\\r\\n    struct DecreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint128 liquidity;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\\r\\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\\r\\n    /// amount The amount by which liquidity will be decreased,\\r\\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\\r\\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\\r\\n    /// deadline The time by which the transaction must be included to effect the change\\r\\n    /// @return amount0 The amount of token0 accounted to the position\\u0027s tokens owed\\r\\n    /// @return amount1 The amount of token1 accounted to the position\\u0027s tokens owed\\r\\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    struct CollectParams {\\r\\n        uint256 tokenId;\\r\\n        address recipient;\\r\\n        uint128 amount0Max;\\r\\n        uint128 amount1Max;\\r\\n    }\\r\\n\\r\\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\r\\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\\r\\n    /// recipient The account that should receive the tokens,\\r\\n    /// amount0Max The maximum amount of token0 to collect,\\r\\n    /// amount1Max The maximum amount of token1 to collect\\r\\n    /// @return amount0 The amount of fees collected in token0\\r\\n    /// @return amount1 The amount of fees collected in token1\\r\\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\\r\\n    /// must be collected first.\\r\\n    /// @param tokenId The ID of the token that is being burned\\r\\n    function burn(uint256 tokenId) external payable;\\r\\n}\\r\\n\\r\\n\\r\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\r\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\r\\n/// prices between 2**-128 and 2**128\\r\\nlibrary TickMath {\\r\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\r\\n    int24 internal constant MIN_TICK = -887272;\\r\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\r\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\r\\n\\r\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\r\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\r\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\r\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\r\\n\\r\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\r\\n    /// @dev Throws if |tick| \\u003e max tick\\r\\n    /// @param tick The input tick for the above formula\\r\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\r\\n    /// at the given tick\\r\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\r\\n        uint256 absTick = tick \\u003c 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\r\\n        require(absTick \\u003c= uint256(MAX_TICK), \\u0027T\\u0027);\\r\\n\\r\\n        uint256 ratio = absTick \\u0026 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\r\\n        if (absTick \\u0026 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) \\u003e\\u003e 128;\\r\\n        if (absTick \\u0026 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) \\u003e\\u003e 128;\\r\\n\\r\\n        if (tick \\u003e 0) ratio = type(uint256).max / ratio;\\r\\n\\r\\n        // this divides by 1\\u003c\\u003c32 rounding up to go from a Q128.128 to a Q128.96.\\r\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\r\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\r\\n        sqrtPriceX96 = uint160((ratio \\u003e\\u003e 32) + (ratio % (1 \\u003c\\u003c 32) == 0 ? 0 : 1));\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) \\u003c= ratio\\r\\n    /// @dev Throws in case sqrtPriceX96 \\u003c MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\r\\n    /// ever return.\\r\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\r\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\r\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\r\\n        // second inequality must be \\u003c because the price can never reach the price at the max tick\\r\\n        require(sqrtPriceX96 \\u003e= MIN_SQRT_RATIO \\u0026\\u0026 sqrtPriceX96 \\u003c MAX_SQRT_RATIO, \\u0027R\\u0027);\\r\\n        uint256 ratio = uint256(sqrtPriceX96) \\u003c\\u003c 32;\\r\\n\\r\\n        uint256 r = ratio;\\r\\n        uint256 msb = 0;\\r\\n\\r\\n        assembly {\\r\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\r\\n            msb := or(msb, f)\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\r\\n            msb := or(msb, f)\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\r\\n            msb := or(msb, f)\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            let f := shl(4, gt(r, 0xFFFF))\\r\\n            msb := or(msb, f)\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            let f := shl(3, gt(r, 0xFF))\\r\\n            msb := or(msb, f)\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            let f := shl(2, gt(r, 0xF))\\r\\n            msb := or(msb, f)\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            let f := shl(1, gt(r, 0x3))\\r\\n            msb := or(msb, f)\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            let f := gt(r, 0x1)\\r\\n            msb := or(msb, f)\\r\\n        }\\r\\n\\r\\n        if (msb \\u003e= 128) r = ratio \\u003e\\u003e (msb - 127);\\r\\n        else r = ratio \\u003c\\u003c (127 - msb);\\r\\n\\r\\n        int256 log_2 = (int256(msb) - 128) \\u003c\\u003c 64;\\r\\n\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(63, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(62, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(61, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(60, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(59, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(58, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(57, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(56, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(55, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(54, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(53, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(52, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(51, f))\\r\\n            r := shr(f, r)\\r\\n        }\\r\\n        assembly {\\r\\n            r := shr(127, mul(r, r))\\r\\n            let f := shr(128, r)\\r\\n            log_2 := or(log_2, shl(50, f))\\r\\n        }\\r\\n\\r\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\r\\n\\r\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) \\u003e\\u003e 128);\\r\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) \\u003e\\u003e 128);\\r\\n\\r\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) \\u003c= sqrtPriceX96 ? tickHi : tickLow;\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @title Contains 512-bit math functions\\r\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\r\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\r\\nlibrary FullMath {\\r\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n    function mulDiv(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        // 512-bit multiply [prod1 prod0] = a * b\\r\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n        // then use the Chinese Remainder Theorem to reconstruct\\r\\n        // the 512 bit result. The result is stored in two 256\\r\\n        // variables such that product = prod1 * 2**256 + prod0\\r\\n        uint256 prod0; // Least significant 256 bits of the product\\r\\n        uint256 prod1; // Most significant 256 bits of the product\\r\\n        assembly {\\r\\n            let mm := mulmod(a, b, not(0))\\r\\n            prod0 := mul(a, b)\\r\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n        }\\r\\n\\r\\n        // Handle non-overflow cases, 256 by 256 division\\r\\n        if (prod1 == 0) {\\r\\n            require(denominator \\u003e 0);\\r\\n            assembly {\\r\\n                result := div(prod0, denominator)\\r\\n            }\\r\\n            return result;\\r\\n        }\\r\\n\\r\\n        // Make sure the result is less than 2**256.\\r\\n        // Also prevents denominator == 0\\r\\n        require(denominator \\u003e prod1);\\r\\n\\r\\n        ///////////////////////////////////////////////\\r\\n        // 512 by 256 division.\\r\\n        ///////////////////////////////////////////////\\r\\n\\r\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n        // Compute remainder using mulmod\\r\\n        uint256 remainder;\\r\\n        assembly {\\r\\n            remainder := mulmod(a, b, denominator)\\r\\n        }\\r\\n        // Subtract 256 bit number from 512 bit number\\r\\n        assembly {\\r\\n            prod1 := sub(prod1, gt(remainder, prod0))\\r\\n            prod0 := sub(prod0, remainder)\\r\\n        }\\r\\n\\r\\n        // Factor powers of two out of denominator\\r\\n        // Compute largest power of two divisor of denominator.\\r\\n        // Always \\u003e= 1.\\r\\n        uint256 twos = -denominator \\u0026 denominator;\\r\\n        // Divide denominator by power of two\\r\\n        assembly {\\r\\n            denominator := div(denominator, twos)\\r\\n        }\\r\\n\\r\\n        // Divide [prod1 prod0] by the factors of two\\r\\n        assembly {\\r\\n            prod0 := div(prod0, twos)\\r\\n        }\\r\\n        // Shift in bits from prod1 into prod0. For this we need\\r\\n        // to flip `twos` such that it is 2**256 / twos.\\r\\n        // If twos is zero, then it becomes one\\r\\n        assembly {\\r\\n            twos := add(div(sub(0, twos), twos), 1)\\r\\n        }\\r\\n        prod0 |= prod1 * twos;\\r\\n\\r\\n        // Invert denominator mod 2**256\\r\\n        // Now that denominator is an odd number, it has an inverse\\r\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n        // Compute the inverse by starting with a seed that is correct\\r\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n        uint256 inv = (3 * denominator) ^ 2;\\r\\n        // Now use Newton-Raphson iteration to improve the precision.\\r\\n        // Thanks to Hensel\\u0027s lifting lemma, this also works in modular\\r\\n        // arithmetic, doubling the correct bits in each step.\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\r\\n\\r\\n        // Because the division is now exact we can divide by multiplying\\r\\n        // with the modular inverse of denominator. This will give us the\\r\\n        // correct result modulo 2**256. Since the precoditions guarantee\\r\\n        // that the outcome is less than 2**256, this is the final result.\\r\\n        // We don\\u0027t need to compute the high bits of the result and prod1\\r\\n        // is no longer required.\\r\\n        result = prod0 * inv;\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    function mulDivRoundingUp(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        result = mulDiv(a, b, denominator);\\r\\n        if (mulmod(a, b, denominator) \\u003e 0) {\\r\\n            require(result \\u003c type(uint256).max);\\r\\n            result++;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @title Safe casting methods\\r\\n/// @notice Contains methods for safely casting between types\\r\\nlibrary SafeCast {\\r\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\r\\n    /// @param y The uint256 to be downcasted\\r\\n    /// @return z The downcasted integer, now type uint160\\r\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\r\\n        require((z = uint160(y)) == y);\\r\\n    }\\r\\n\\r\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\r\\n    /// @param y The int256 to be downcasted\\r\\n    /// @return z The downcasted integer, now type int128\\r\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\r\\n        require((z = int128(y)) == y);\\r\\n    }\\r\\n\\r\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\r\\n    /// @param y The uint256 to be casted\\r\\n    /// @return z The casted integer, now type int256\\r\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\r\\n        require(y \\u003c 2**255);\\r\\n        z = int256(y);\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @title Oracle library\\r\\n/// @notice Provides functions to integrate with V3 pool oracle\\r\\nlibrary OracleLibrary {\\r\\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\\r\\n    /// @param pool Address of the pool that we want to observe\\r\\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\\r\\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\\r\\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\\r\\n    function consult(address pool, uint32 secondsAgo)\\r\\n        internal\\r\\n        view\\r\\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\\r\\n    {\\r\\n        require(secondsAgo != 0, \\u0027BP\\u0027);\\r\\n\\r\\n        uint32[] memory secondsAgos = new uint32[](2);\\r\\n        secondsAgos[0] = secondsAgo;\\r\\n        secondsAgos[1] = 0;\\r\\n\\r\\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\\r\\n            IUniswapV3Pool(pool).observe(secondsAgos);\\r\\n\\r\\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\\r\\n        uint160 secondsPerLiquidityCumulativesDelta =\\r\\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\\r\\n\\r\\n        arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\\r\\n        // Always round to negative infinity\\r\\n        if (tickCumulativesDelta \\u003c 0 \\u0026\\u0026 (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;\\r\\n\\r\\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn\\u0027t overflow uint128\\r\\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\\r\\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) \\u003c\\u003c 32));\\r\\n    }\\r\\n\\r\\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\\r\\n    /// @param tick Tick value used to calculate the quote\\r\\n    /// @param baseAmount Amount of token to be converted\\r\\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\r\\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\r\\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\r\\n    function getQuoteAtTick(\\r\\n        int24 tick,\\r\\n        uint128 baseAmount,\\r\\n        address baseToken,\\r\\n        address quoteToken\\r\\n    ) internal pure returns (uint256 quoteAmount) {\\r\\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\\r\\n\\r\\n        // Calculate quoteAmount with better precision if it doesn\\u0027t overflow when multiplied by itself\\r\\n        if (sqrtRatioX96 \\u003c= type(uint128).max) {\\r\\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\\r\\n            quoteAmount = baseToken \\u003c quoteToken\\r\\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 \\u003c\\u003c 192)\\r\\n                : FullMath.mulDiv(1 \\u003c\\u003c 192, baseAmount, ratioX192);\\r\\n        } else {\\r\\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 \\u003c\\u003c 64);\\r\\n            quoteAmount = baseToken \\u003c quoteToken\\r\\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 \\u003c\\u003c 128)\\r\\n                : FullMath.mulDiv(1 \\u003c\\u003c 128, baseAmount, ratioX128);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\\r\\n    /// @param pool Address of Uniswap V3 pool that we want to observe\\r\\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\\r\\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\\r\\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\\r\\n        require(observationCardinality \\u003e 0, \\u0027NI\\u0027);\\r\\n\\r\\n        (uint32 observationTimestamp, , , bool initialized) =\\r\\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\\r\\n\\r\\n        // The next index might not be initialized if the cardinality is in the process of increasing\\r\\n        // In this case the oldest observation is always in index 0\\r\\n        if (!initialized) {\\r\\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\\r\\n        }\\r\\n\\r\\n        secondsAgo = uint32(block.timestamp) - observationTimestamp;\\r\\n    }\\r\\n\\r\\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\\r\\n    /// @param pool Address of Uniswap V3 pool\\r\\n    /// @return The tick that the pool was in at the start of the current block\\r\\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\\r\\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\\r\\n\\r\\n        // 2 observations are needed to reliably calculate the block starting tick\\r\\n        require(observationCardinality \\u003e 1, \\u0027NEO\\u0027);\\r\\n\\r\\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\\r\\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\\r\\n        // We don\\u0027t need to check if this observation is initialized - it is guaranteed to be.\\r\\n        (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) =\\r\\n            IUniswapV3Pool(pool).observations(observationIndex);\\r\\n        if (observationTimestamp != uint32(block.timestamp)) {\\r\\n            return (tick, IUniswapV3Pool(pool).liquidity());\\r\\n        }\\r\\n\\r\\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\\r\\n        (\\r\\n            uint32 prevObservationTimestamp,\\r\\n            int56 prevTickCumulative,\\r\\n            uint160 prevSecondsPerLiquidityCumulativeX128,\\r\\n            bool prevInitialized\\r\\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\\r\\n\\r\\n        require(prevInitialized, \\u0027ONI\\u0027);\\r\\n\\r\\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\\r\\n        tick = int24((tickCumulative - prevTickCumulative) / delta);\\r\\n        uint128 liquidity =\\r\\n            uint128(\\r\\n                (uint192(delta) * type(uint160).max) /\\r\\n                    (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) \\u003c\\u003c 32)\\r\\n            );\\r\\n        return (tick, liquidity);\\r\\n    }\\r\\n\\r\\n    /// @notice Information for calculating a weighted arithmetic mean tick\\r\\n    struct WeightedTickData {\\r\\n        int24 tick;\\r\\n        uint128 weight;\\r\\n    }\\r\\n\\r\\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\\r\\n    /// @param weightedTickData An array of ticks and weights\\r\\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\\r\\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\\r\\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\\r\\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\\r\\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int24 weightedArithmeticMeanTick)\\r\\n    {\\r\\n        // Accumulates the sum of products between each tick and its weight\\r\\n        int256 numerator;\\r\\n\\r\\n        // Accumulates the sum of the weights\\r\\n        uint256 denominator;\\r\\n\\r\\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\\r\\n        for (uint256 i; i \\u003c weightedTickData.length; i++) {\\r\\n            numerator += weightedTickData[i].tick * int256(weightedTickData[i].weight);\\r\\n            denominator += weightedTickData[i].weight;\\r\\n        }\\r\\n\\r\\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\\r\\n        // Always round to negative infinity\\r\\n        if (numerator \\u003c 0 \\u0026\\u0026 (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the \\\"synthetic\\\" tick which represents the price of the first entry in `tokens` in terms of the last\\r\\n    /// @dev Useful for calculating relative prices along routes.\\r\\n    /// @dev There must be one tick for each pairwise set of tokens.\\r\\n    /// @param tokens The token contract addresses\\r\\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\\r\\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\\r\\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256 syntheticTick)\\r\\n    {\\r\\n        require(tokens.length - 1 == ticks.length, \\u0027DL\\u0027);\\r\\n        for (uint256 i = 1; i \\u003c= ticks.length; i++) {\\r\\n            // check the tokens for address sort order, then accumulate the\\r\\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \\\"cancel out\\\"\\r\\n            tokens[i - 1] \\u003c tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\\r\\n        }\\r\\n    }\\r\\n}\"},\"TraitSniper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./Include.sol\\\";\\r\\nimport \\\"./IUniswapV3.sol\\\";\\r\\n\\r\\nlibrary $C {\\r\\n    bytes32 internal constant _denyVerify_      = \\\"denyVerify\\\";\\r\\n    bytes32 internal constant _denyInfluenceClaim_    = \\\"denyInfluenceClaim\\\";\\r\\n    bytes32 internal constant _denyReferrerClaim_     = \\\"denyReferrerClaim\\\";\\r\\n    bytes32 internal constant _denyBuy_         = \\\"denyBuy\\\";\\r\\n    bytes32 internal constant _minSignatures_   = \\\"minSignatures\\\";\\r\\n    bytes32 internal constant _minAirClaim_     = \\\"minAirClaim\\\";\\r\\n    bytes32 internal constant _maxAirClaim_     = \\\"maxAirClaim\\\";\\r\\n    bytes32 internal constant _spanAirClaim_    = \\\"spanAirClaim\\\";\\r\\n    bytes32 internal constant _factorAirClaim_  = \\\"factorAirClaim\\\";\\r\\n    bytes32 internal constant _factorProfitAir_ = \\\"factorProfitAir\\\";\\r\\n    bytes32 internal constant _factorProfitBuy_ = \\\"factorProfitBuy\\\";\\r\\n    //bytes32 internal constant _factorMoreInfluence_ = \\\"factorMoreInfluence\\\";\\r\\n    bytes32 internal constant _unlockBegin_     = \\\"unlockBegin\\\";\\r\\n    bytes32 internal constant _lockSpanAirClaim_= \\\"lockSpanAirClaim\\\";\\r\\n    bytes32 internal constant _lockSpanBuy_     = \\\"lockSpanBuy\\\";\\r\\n    bytes32 internal constant _spanBuyBuf_      = \\\"spanBuyBuf\\\";\\r\\n    bytes32 internal constant _factorPrice_     = \\\"factorPrice\\\";\\r\\n    bytes32 internal constant _factorPrice20_   = \\\"factorPrice20\\\";\\r\\n    bytes32 internal constant _currency_        = \\\"currency\\\";\\r\\n    bytes32 internal constant _swapRouter_      = \\\"swapRouter\\\";\\r\\n    bytes32 internal constant _swapFactory_     = \\\"swapFactory\\\";\\r\\n    //bytes32 internal constant _uniPosMngr_      = \\\"uniPosMngr\\\";\\r\\n    bytes32 internal constant _panPosMngr_      = \\\"panPosMngr\\\";\\r\\n    bytes32 internal constant _discount_        = \\\"discount\\\";\\r\\n    bytes32 internal constant _rebaseTime_      = \\\"rebaseTime\\\";\\r\\n    bytes32 internal constant _rebasePeriod_    = \\\"rebasePeriod\\\";\\r\\n    bytes32 internal constant _rebaseSpan_      = \\\"rebaseSpan\\\";\\r\\n    bytes32 internal constant _lpTknMaxRatio_   = \\\"lpTknMaxRatio\\\";\\r\\n    bytes32 internal constant _lpCurMaxRatio_   = \\\"lpCurMaxRatio\\\";\\r\\n    bytes32 internal constant _buybackRatio_    = \\\"buybackRatio\\\";\\r\\n    bytes32 internal constant _ecoAddr_         = \\\"ecoAddr\\\";\\r\\n    bytes32 internal constant _ecoRatio_        = \\\"ecoRatio\\\";\\r\\n    bytes32 internal constant _deadRatio_       = \\\"deadRatio\\\";\\r\\n    bytes32 internal constant _buybackAnytime_  = \\\"buybackAnytime\\\";\\r\\n    bytes32 internal constant _operator_        = \\\"operator\\\";\\r\\n\\r\\n    bytes32 internal constant _woofSpan_        = \\\"woofSpan\\\";\\r\\n    bytes32 internal constant _minCowoof_       = \\\"minCowoof\\\";\\r\\n    bytes32 internal constant _yieldPerRebase_  = \\\"yieldPerRebase\\\";\\r\\n    bytes32 internal constant _maxYieldFactor_  = \\\"maxYieldFactor\\\";\\r\\n    bytes32 internal constant _maxCoYieldFactor_= \\\"maxCoYieldFactor\\\";\\r\\n    bytes32 internal constant _minRewoofIncRatio_= \\\"minRewoofIncRatio\\\";\\r\\n\\r\\n    bytes32 internal constant _unlockSelfRatio_ = \\\"unlockSelfRatio\\\";\\r\\n    bytes32 internal constant _unlockRefRatio_  = \\\"unlockRefRatio\\\";\\r\\n    bytes32 internal constant _unlockRef2Ratio_ = \\\"unlockRef2Ratio\\\";\\r\\n    bytes32 internal constant _unlockAllRatio_  = \\\"unlockAllRatio\\\";\\r\\n\\r\\n    bytes32 internal constant VERIFY_TYPEHASH   = keccak256(\\\"Verify(address sender,uint256 nonce,bytes32 tweetId,Twitter twitter,address signatory)\\\");\\r\\n    \\r\\n    uint24  internal constant FEE               = 10000;     // 1.00%\\r\\n    uint    internal constant PRICE0            = 1e-6 * 1e18;\\r\\n\\r\\n    address internal constant DEAD_ADDR         = 0x000000000000000000000000000000000000dEaD;   // black hole address\\r\\n    address internal constant ALL_ADDR          = address(-1);                                  // for all\\r\\n\\r\\n    function _chainId() internal pure returns (uint id) {\\r\\n        assembly { id := chainid() }\\r\\n    }\\r\\n}\\r\\n\\r\\nstruct Twitter {\\r\\n    bytes32 id;\\r\\n    uint    createTime;\\r\\n    uint    followers;\\r\\n    uint    tweets;\\r\\n}\\r\\n\\r\\nstruct Signature {\\r\\n    address signatory;\\r\\n    uint8   v;\\r\\n    bytes32 r;\\r\\n    bytes32 s;\\r\\n}\\r\\n\\r\\nstruct PermitSign {\\r\\n    bool    allowed;\\r\\n    uint32  deadline;\\r\\n    uint8   v;\\r\\n    bytes32 r;\\r\\n    bytes32 s;\\r\\n}\\r\\n\\r\\nstruct Account {\\r\\n    uint112 airFactor;\\r\\n    uint112 airUnlocked;\\r\\n    uint112 airClaimed;             // uses single storage slot\\r\\n    uint112 airClaiming;\\r\\n    uint112 locked;                 // uses single storage slot\\r\\n    uint32  unlockEnd;              // uses single storage slot\\r\\n    address referrer;\\r\\n    bool    isCmpd;\\r\\n}\\r\\n\\r\\nstruct Dog {\\r\\n    uint    cowoofAmt;\\r\\n    uint    yieldPerToken;\\r\\n    uint    yield;\\r\\n    uint    yieldPaid;\\r\\n    uint    rewoofPrin;\\r\\n    uint    rewardPerPrin;\\r\\n    uint    reward;\\r\\n    uint    rewardPaid;\\r\\n}\\r\\n\\r\\nstruct Woof {\\r\\n    bytes32 twitterId;\\r\\n    uint    endTime;\\r\\n    uint    lastRewoof;\\r\\n    uint    lastTime;\\r\\n    uint    rewardRate;\\r\\n    mapping (address =\\u003e Dog) dogs;   // address(-1) for all\\r\\n}\\r\\n\\r\\nstruct SocialFiStru {                 // is ERC20Stru \\r\\n    mapping (address =\\u003e uint256) balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowances;\\r\\n    uint256 totalSupply;\\r\\n\\r\\n    string name;\\r\\n    string symbol;\\r\\n    uint8 decimals;\\r\\n\\r\\n    uint256 cap;\\r\\n\\r\\n    bytes32 DOMAIN_SEPARATOR;\\r\\n    mapping (address =\\u003e uint) nonces;\\r\\n\\r\\n    uint flatSupply;\\r\\n    uint index;\\r\\n    mapping (address =\\u003e Account) accts;\\r\\n    mapping (bytes32 =\\u003e address) addrOfId;\\r\\n\\r\\n    address[] signatories;\\r\\n    mapping (address =\\u003e bool) isSignatory;\\r\\n\\r\\n    address pool;\\r\\n    mapping (address =\\u003e bool) tax0list;\\r\\n    \\r\\n    uint    totalProfit;\\r\\n    uint112 buySupply;              // uses single storage slot\\r\\n    uint112 buyBuffer;              // uses single storage slot\\r\\n    uint32  lastUpdateBuf;          // uses single storage slot\\r\\n\\r\\n    mapping (bytes32 =\\u003e Woof) woofs;\\r\\n}\\r\\n\\r\\ncontract SocialFi is IERC20, Extendable {\\r\\n    using Config for bytes32;\\r\\n    using SafeMath for uint;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using ERC20Lib for ERC20Stru;\\r\\n    using SocialFiLib for SocialFiStru;\\r\\n\\r\\n    SocialFiStru internal $;\\r\\n    \\r\\n    function E$() internal pure returns (ERC20Stru storage e$) {\\r\\n        assembly {  e$_slot := $_slot   }\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        __SocialFi_init();\\r\\n    }\\r\\n\\r\\n    function __SocialFi_init() public governance {\\r\\n        E$().ERC20_init_unchained(\\\"TraitSniper.com\\\", \\\"TS\\\");\\r\\n        //E$().setupDecimals(18);\\r\\n        //E$().ERC20Capped_init_unchained(1e12 * 1e18);\\r\\n        E$().ERC20Permit_init_unchained();\\r\\n        $.__SocialFi_init_unchained();\\r\\n    }\\r\\n\\r\\n    function name() external view viewExtend returns (string memory) {\\r\\n        return $.name;\\r\\n    }\\r\\n\\r\\n    function symbol() external view viewExtend returns (string memory) {\\r\\n        return $.symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() external view viewExtend returns (uint8) {\\r\\n        return $.decimals;\\r\\n    }\\r\\n    \\r\\n    function cap() external view viewExtend returns (uint256) {\\r\\n        return $.cap;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) override external view viewExtend returns (uint) {\\r\\n        return $.allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) override external extend returns (bool) {\\r\\n        return E$().approve(spender, amount);\\r\\n    }\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external extend {\\r\\n        return $.permit(owner, spender, value, deadline, v, r, s);\\r\\n    }\\r\\n\\r\\n    function nonces(address who) external view viewExtend returns(uint) {\\r\\n        return $.nonces[who];\\r\\n    }\\r\\n\\r\\n    function totalSupply() override external view viewExtend returns(uint) {\\r\\n        return $.totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address who) override external view viewExtend returns(uint) {\\r\\n        return $.balanceOf(who);\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amt) override external extend returns(bool) {\\r\\n        return $.transfer($M.msgSender(), to, amt);\\r\\n    }\\r\\n    \\r\\n    function transferFrom(address from, address to, uint256 amt) override external extend returns(bool) {\\r\\n        return $.transferFrom(from, to, amt);\\r\\n    }\\r\\n\\r\\n    function airDrop(string calldata why, address[] calldata tos, uint[] calldata amts) external extend {\\r\\n        require(tos.length == amts.length, \\\"length !=\\\");\\r\\n        require(msg.sender == $C._operator_.getA(), \\\"only operator\\\");\\r\\n        uint sum;\\r\\n        for(uint i=0; i\\u003ctos.length; sum=sum.add(amts[i++])) {\\r\\n            _updateAirClaimed(tos[i], amts[i]);\\r\\n            _airClaim(tos[i], amts[i]);\\r\\n            emit AirDrop(why, tos[i], amts[i]);\\r\\n        }\\r\\n        _updateAirClaimed($C.ALL_ADDR, sum);\\r\\n    }\\r\\n    event AirDrop(string indexed why, address indexed to, uint amt);\\r\\n    \\r\\n    function _airClaim(address to, uint amt) internal {\\r\\n        $.mint_(to, amt);\\r\\n    }\\r\\n    \\r\\n    function _mint(address to, uint amt) internal {\\r\\n        $.mint(to, amt);\\r\\n    }\\r\\n    \\r\\n    function burn(uint amt) external extend {\\r\\n        _burn($M.msgSender(), amt);\\r\\n    }\\r\\n    function _burn(address from, uint amt) internal {\\r\\n        $.burn(from, amt);\\r\\n    }\\r\\n\\r\\n    function lockedOf(address who) external view viewExtend returns(uint) {\\r\\n        return $.lockedOf(who);\\r\\n    }\\r\\n\\r\\n    function unlockedOf(address who) external view viewExtend returns(uint) {\\r\\n        return $.unlockedOf(who);\\r\\n    }\\r\\n\\r\\n    function unlockEndOf(address who) external view viewExtend returns(uint) {\\r\\n        return _unlockEndOf(who);\\r\\n    }\\r\\n    function _unlockEndOf(address who) internal view returns(uint) {\\r\\n        return $.accts[who].unlockEnd;\\r\\n    }\\r\\n\\r\\n    function VERIFY_TYPEHASH() external view viewExtend returns (bytes32) {\\r\\n        return $C.VERIFY_TYPEHASH;\\r\\n    }\\r\\n\\r\\n    function flatSupply() external view viewExtend returns(uint) {\\r\\n        return $.flatSupply;\\r\\n    }\\r\\n\\r\\n    function index() external view viewExtend returns(uint) {\\r\\n        return $.index;\\r\\n    }\\r\\n\\r\\n    function totalProfit() external view viewExtend returns(uint) {\\r\\n        return $.totalProfit;\\r\\n    }\\r\\n\\r\\n    function buySupply() external view viewExtend returns(uint) {\\r\\n        return _buySupply();\\r\\n    }\\r\\n    function _buySupply() internal view returns(uint) {\\r\\n        return $.buySupply;\\r\\n    }\\r\\n\\r\\n    function buyBuffer() external view viewExtend returns(uint) {\\r\\n        return _buyBuffer();\\r\\n    }\\r\\n    function _buyBuffer() internal view returns(uint) {\\r\\n        mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n        uint span = config[$C._spanBuyBuf_];\\r\\n        (uint buf, uint last) = ($.buyBuffer, $.lastUpdateBuf);        // uses single storage slot\\r\\n        //return span.sub0(now.sub0(Math.max(last, config[$C._unlockBegin_]))).mul(buf).div(span);\\r\\n        last = Math.max(last, config[$C._unlockBegin_]);\\r\\n        uint past = now.sub0(last);\\r\\n        return buf.mul(span).div(span.add(past));\\r\\n    }\\r\\n\\r\\n    function _updateBuffer(uint val, uint amt) internal {\\r\\n        uint buffer = _buyBuffer().add(val);\\r\\n        uint supply = _buySupply().add(amt);\\r\\n        require(supply \\u003c= uint112(-1), \\\"buySupply OVERFLOW\\\");\\r\\n        require(buffer \\u003c= uint112(-1), \\\"buyBuffer OVERFLOW\\\");\\r\\n        ($.buySupply, $.buyBuffer, $.lastUpdateBuf) = (uint112(supply), uint112(buffer), uint32(now));\\r\\n    }\\r\\n\\r\\n    //function price1() external view viewExtend returns(uint) {\\r\\n    //    return _price1();\\r\\n    //}\\r\\n    //function _price1() internal view returns(uint) {\\r\\n    //    return Config.config()[$C._factorPrice_].mul(_buyBuffer()).div0(_buySupply());\\r\\n    //}\\r\\n//\\r\\n    //function price2() external view viewExtend returns(uint) {\\r\\n    //    return _price2();\\r\\n    //}\\r\\n    //function _price2() internal view returns(uint) {\\r\\n    //    mapping (bytes32 =\\u003e address) storage configA = Config.configA();\\r\\n    //    address currency = configA[$C._currency_];\\r\\n    //    address pair = IUniswapV2Factory(configA[$C._swapFactory_]).getPair(currency, address(this));\\r\\n    //    if(pair == address(0) || $.balances[pair] == 0)\\r\\n    //        return 0;\\r\\n    //    return IERC20(currency).balanceOf(pair).mul(1e18).div($.balanceOf(pair));\\r\\n    //}\\r\\n//\\r\\n    function price() external view viewExtend returns(uint) {\\r\\n        return _price();\\r\\n    }\\r\\n    function _price() internal view returns(uint) {\\r\\n        if($.pool == address(0))\\r\\n            return $C.PRICE0;\\r\\n        else\\r\\n            return _sqrtToPrice(_sqrtPriceX96($.pool)).mul(1e18).div(2^96);\\r\\n    //    uint p1 = _price1();\\r\\n    //    uint p2 = _price2();\\r\\n    //    if(p1 == 0)\\r\\n    //        return p2;\\r\\n    //    if(p2 == 0)\\r\\n    //        return p1;\\r\\n    //    uint r1 = _calcRatio1(p1, p2);\\r\\n    //    return uint(1e36).div(r1.mul(1e18).div(p1).add(uint(1e18).sub(r1).mul(1e18).div(p2)));\\r\\n    }\\r\\n    //function price0() external view viewExtend returns(address) {\\r\\n    //    return $.pool;\\r\\n    //}\\r\\n    //function price1(address pool) external view viewExtend returns(uint) {\\r\\n    //    return _sqrtPriceX96(pool);\\r\\n    //}\\r\\n    //function price2(uint160 u) external view viewExtend returns(uint) {\\r\\n    //    return _sqrtToPrice(u);\\r\\n    //}\\r\\n    //function price3(uint u) external view viewExtend returns(uint) {\\r\\n    //    return u.mul(1e18).div(2^96);\\r\\n    //}\\r\\n\\r\\n    function isCmpdOf(address who) external view viewExtend returns(bool) {\\r\\n        return $.accts[who].isCmpd;\\r\\n    }\\r\\n\\r\\n    function setCmpd(bool isCmpd) external extend {\\r\\n        return _setCmpd(isCmpd);\\r\\n    }\\r\\n    function _setCmpd(bool isCmpd) internal {\\r\\n        address who = $M.msgSender();\\r\\n        if($.accts[who].isCmpd == isCmpd)\\r\\n            return;\\r\\n        \\r\\n        $.accts[who].isCmpd = isCmpd;\\r\\n        emit SetCmpd(who, isCmpd);\\r\\n\\r\\n        uint bal = $.balances[who];\\r\\n        if(bal == 0)\\r\\n            return;\\r\\n \\r\\n        if(isCmpd) {\\r\\n            $.flatSupply = $.flatSupply.sub(bal);\\r\\n            $.balances[who] = $.prin4Bal(bal);\\r\\n        } else {\\r\\n            bal = $.bal4Prin(bal);\\r\\n            $.flatSupply = $.flatSupply.add(bal);\\r\\n            $.balances[who] = bal;\\r\\n        }\\r\\n    }\\r\\n    event SetCmpd(address indexed sender, bool indexed isCmpd);\\r\\n\\r\\n    //function APR() external view viewExtend returns(uint) {\\r\\n    //    (, uint r, uint period) = $.calcRebaseProfit(address(0));\\r\\n    //    return r.mul(365 days).div(period);\\r\\n    //}\\r\\n\\r\\n    //function APY(bytes32 tweetId) external view viewExtend returns(uint) {\\r\\n    //    return $.APY(tweetId);\\r\\n    //}\\r\\n    \\r\\n    //function calcRebaseProfit(address who) external view viewExtend returns(uint profit, uint ratio, uint period) {\\r\\n    //    return $.calcRebaseProfit(who);\\r\\n    //}\\r\\n    \\r\\n    //function _rebase() internal {\\r\\n    //    mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n    //    uint time = config[$C._rebaseTime_];\\r\\n    //    if(now \\u003c time)\\r\\n    //        return;\\r\\n//\\r\\n    //    uint period = config[$C._rebasePeriod_];\\r\\n    //    config[$C._rebaseTime_] = time.add(period);\\r\\n    //    config[$C._factorAirClaim_] -= config[$C._factorAirClaim_].mul(period).div(config[$C._spanAirClaim_].add(now.sub0(config[$C._unlockBegin_])));\\r\\n//\\r\\n    //    uint tp = $.totalProfit;\\r\\n    //    uint profit = tp.mul(period).div(config[$C._rebaseSpan_]);\\r\\n    //    uint p = profit.mul(config[$C._ecoRatio_]).div(1e18);\\r\\n    //    address eco = address(config[$C._ecoAddr_]);\\r\\n    //    $.totalProfit = tp.sub(profit);\\r\\n    //    \\r\\n    //    uint supply = $.totalSupply;\\r\\n    //    uint flat = $.flatSupply;\\r\\n    //    $.index = $.index.mul(supply.add(profit).sub(p).sub(flat).add(1)).div(supply.sub(flat).add(1));\\r\\n    //    $.totalSupply = supply.add(profit);\\r\\n    //    require($.cap == 0 || supply.add(profit) \\u003c= $.cap, \\\"cap exceeded\\\");\\r\\n//\\r\\n    //    uint v;\\r\\n    //    if(!$.accts[eco].isCmpd) {\\r\\n    //        $.flatSupply = flat.add(p);\\r\\n    //        v = p;\\r\\n    //    } else\\r\\n    //        v = $.prin4Bal(p);\\r\\n    //    $.balances[eco] = $.balances[eco].add(v);\\r\\n//\\r\\n    //    $.adjustLiquidity();\\r\\n//\\r\\n    //    $.tryBuyback();\\r\\n//\\r\\n    //    emit Rebase(profit.sub(p).mul(1e18).div0(supply.sub(flat)), profit.sub(p), supply.sub(flat), supply.add(profit));\\r\\n    //}\\r\\n    //event Rebase(uint ratio, uint profit, uint oldCmpdSupply, uint newTotalSupply);\\r\\n\\r\\n    modifier compound() {\\r\\n        _compound();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _compound() internal {\\r\\n        _setCmpd(true);\\r\\n        //_rebase();\\r\\n    }\\r\\n\\r\\n    function _setAcct(address sender, uint airClaimed, uint locked, uint lockSpan, address referrer, bool isCmpd) internal {\\r\\n        mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n        uint unlockEnd = Math.max(now, config[$C._unlockBegin_]).add(lockSpan);\\r\\n        require(unlockEnd \\u003c= uint32(-1), \\\"unlockEnd OVERFLOW\\\");\\r\\n        require(locked   \\u003c= uint112(-1), \\\"locked OVERFLOW\\\");\\r\\n        require(airClaimed \\u003c= uint112(-1), \\\"airClaimed OVERFLOW\\\");\\r\\n        $.accts[sender] = Account($.accts[$C.ALL_ADDR].airFactor, 0, uint112(airClaimed), 0, uint112(locked), uint32(unlockEnd), referrer, isCmpd);\\r\\n        $.totalProfit = $.totalProfit.add(locked.mul(config[$C._factorProfitAir_]));    // todo\\r\\n        _updateLocked(address(-1), locked, lockSpan);\\r\\n    }\\r\\n    \\r\\n    function _updateLocked(address sender, uint amt, uint lockSpan) internal {\\r\\n        mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n        if(sender != address(-1)) {\\r\\n            _updateLocked(address(-1), amt, lockSpan);\\r\\n            $.totalProfit = $.totalProfit.add(amt.mul(config[$C._factorProfitBuy_]));   // todo\\r\\n        }\\r\\n        Account storage acct = $.accts[sender];\\r\\n        (uint locked, uint unlockEnd) = (acct.locked, acct.unlockEnd);\\r\\n\\r\\n        if(amt \\u003e 0 \\u0026\\u0026 lockSpan \\u003e 0) {\\r\\n            uint unlockBegin = config[$C._unlockBegin_];\\r\\n            uint mnb = Math.max(now, unlockBegin);\\r\\n            locked = SocialFiLib.currLocked(locked, unlockEnd);\\r\\n            unlockEnd = unlockEnd.sub0(mnb).mul(locked).add(lockSpan.mul(amt)).div(locked.add(amt)).add(mnb);\\r\\n            locked = locked.add(amt).mul(unlockEnd.sub(unlockBegin)).div(unlockEnd.sub(mnb));\\r\\n            require(locked \\u003c= uint112(-1), \\\"locked OVERFLOW\\\");\\r\\n            require(unlockEnd \\u003c= uint32(-1), \\\"unlockEnd OVERFLOW\\\");\\r\\n        }\\r\\n        (acct.locked, acct.unlockEnd) = (uint112(locked), uint32(unlockEnd));\\r\\n    }\\r\\n\\r\\n    function _updateAirClaimed(address sender, uint amt) internal returns (uint claimed) {\\r\\n        claimed = amt.add($.accts[sender].airClaimed);\\r\\n        require(claimed \\u003c= uint112(-1), \\\"airClaimed OVERFLOW\\\");\\r\\n        $.accts[sender].airClaimed = uint112(claimed);\\r\\n    }\\r\\n\\r\\n    function calcInfluence(Twitter calldata twitter) external view viewExtend returns(uint) {\\r\\n        return _calcInfluence(twitter);\\r\\n    }\\r\\n    function _calcInfluence(Twitter calldata twitter) internal view returns(uint) {\\r\\n        uint age = now.sub(twitter.createTime).div(1 days).add(1);\\r\\n        uint followers = twitter.followers.add(1);\\r\\n        uint tweets = twitter.tweets.add(1);\\r\\n        return Math.sqrt(age.mul(followers).mul(tweets));\\r\\n    }\\r\\n    \\r\\n    function calcInfluenceClaim(Twitter calldata twitter) external view viewExtend returns(uint amt) {\\r\\n        return _calcInfluenceClaim(twitter);\\r\\n    }\\r\\n    function _calcInfluenceClaim(Twitter calldata twitter) internal view returns(uint amt) {\\r\\n        mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n        amt = _calcInfluence(twitter);\\r\\n        amt = Math.min(amt.add(config[$C._minAirClaim_]), config[$C._maxAirClaim_]).mul(config[$C._factorAirClaim_]);\\r\\n    }\\r\\n        \\r\\n    function isInfluenceClaimed(address sender, bytes32 id) external view viewExtend returns(uint flag) {\\r\\n        return _isInfluenceClaimed(sender, id);\\r\\n    }\\r\\n    function _isInfluenceClaimed(address sender, bytes32 id) internal view returns(uint flag) {\\r\\n        if($.accts[sender].airClaimed != 0)\\r\\n            flag += 1;\\r\\n        if($.addrOfId[id] != address(0))\\r\\n            flag += 2;\\r\\n    }\\r\\n    \\r\\n    function influenceClaim(string calldata channel, address referrer, bytes32 tweetId, Twitter calldata twitter, Signature[] calldata signatures) payable external extend {\\r\\n        require($C._denyInfluenceClaim_.get() == 0, \\\"denyInfluenceClaim\\\");\\r\\n        //_rebase();\\r\\n        address sender = $M.msgSender();\\r\\n        _verify(sender, tweetId, twitter, signatures);\\r\\n        require(twitter.id != 0, \\\"missing twitter id\\\");\\r\\n        require(_isInfluenceClaimed(sender, twitter.id) == 0, \\\"Influence Claimed already\\\");\\r\\n        $.addrOfId[twitter.id] = sender;\\r\\n        uint amt = _calcInfluenceClaim(twitter);\\r\\n        _setAcct(sender, amt, 0, 0, referrer, true);\\r\\n        _updateAirClaimed($C.ALL_ADDR, amt);\\r\\n        if(referrer != address(0)) {\\r\\n            uint claiming = amt.add($.accts[referrer].airClaiming);\\r\\n            require(claiming \\u003c= uint112(-1), \\\"airClaiming OVERFLOW\\\");\\r\\n            $.accts[referrer].airClaiming = uint112(claiming);\\r\\n            address ref2 = $.accts[referrer].referrer;\\r\\n            if(ref2 != address(0)) {\\r\\n                claiming = (amt/2).add($.accts[ref2].airClaiming);\\r\\n                require(claiming \\u003c= uint112(-1), \\\"airClaiming2 OVERFLOW\\\");\\r\\n                $.accts[ref2].airClaiming = uint112(claiming);\\r\\n            }\\r\\n        }\\r\\n        _airClaim(sender, amt);\\r\\n        emit InfluenceClaim(sender, channel, referrer, tweetId, twitter.id, amt);\\r\\n\\r\\n        //_buyInEth(sender, msg.value);\\r\\n    }\\r\\n    event InfluenceClaim(address indexed sender, string indexed channel, address indexed referrer, bytes32 tweetId, bytes32 id, uint amt);\\r\\n\\r\\n    function calcReferrerClaim(address sender) external view viewExtend returns(uint amt) {\\r\\n        return _calcReferrerClaim(sender);\\r\\n    }\\r\\n    function _calcReferrerClaim(address sender) internal view returns(uint amt) {\\r\\n        mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n        Account storage acct = $.accts[sender];\\r\\n        (uint airClaimed, uint airClaiming) = (acct.airClaimed, acct.airClaiming);\\r\\n        amt = Math.min(airClaiming, config[$C._maxAirClaim_].mul(2).mul(config[$C._factorAirClaim_]).sub0(airClaimed));\\r\\n    }\\r\\n        \\r\\n    function referrerClaim(string calldata channel) payable external extend {\\r\\n        require($C._denyReferrerClaim_.get() == 0, \\\"denyReferrerClaim\\\");\\r\\n        //_rebase();\\r\\n        address sender = $M.msgSender();\\r\\n        //require($.accts[sender].referrerClaimed == 0, \\\"Referrer Claimed already\\\");\\r\\n        uint amt = _calcReferrerClaim(sender);\\r\\n        uint claimed = _updateAirClaimed(sender, amt);\\r\\n        _updateAirClaimed($C.ALL_ADDR, amt);\\r\\n        $.accts[sender].airClaiming = 0;\\r\\n        _airClaim(sender, amt);\\r\\n        emit ReferrerClaim(sender, channel, amt, claimed);\\r\\n\\r\\n        //_buyInEth(sender, msg.value);\\r\\n    }\\r\\n    event ReferrerClaim(address indexed sender, string indexed channel, uint amt, uint claimed);\\r\\n\\r\\n/*\\r\\n    function APY(SocialFiStru storage $, bytes32 tweetId) external view returns(uint y) {\\r\\n        (, uint r, uint period) = calcRebaseProfit($, address(0));\\r\\n        r = r.add($.woofs[tweetId].rewardRate.mul(period).mul(1e18).div0($.bal4Prin($.woofs[tweetId].dogs[address(-1)].rewoofPrin)));\\r\\n        r = r.add(1e18);\\r\\n        y = 1e18;\\r\\n        for(uint i=(365 days/period); i\\u003e0; i\\u003e\\u003e=1) {\\r\\n            if(i % 2 == 1)\\r\\n                y = y.mul(r).div(1e18);\\r\\n            r = r.mul(r).div(1e18);\\r\\n        }\\r\\n        y -= 1e18;\\r\\n    }\\r\\n*/    \\r\\n/*    function calcRebaseProfit(SocialFiStru storage $, address who) public view returns(uint profit, uint ratio, uint period) {\\r\\n        mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n        period = config[$C._rebasePeriod_];\\r\\n        profit = $.totalProfit.mul(period).div(config[$C._rebaseSpan_]);\\r\\n        profit = profit.sub(profit.mul(config[$C._ecoRatio_]).div(1e18));\\r\\n        uint cmpdSupply = $.totalSupply.sub($.flatSupply);\\r\\n        ratio = profit.mul(1e18).div0(cmpdSupply);\\r\\n        if(who != address(0) \\u0026\\u0026 who != address(-1))\\r\\n            if($.accts[who].isCmpd)\\r\\n                profit = profit.mul(IERC20(address(this)).balanceOf(who)).div0(cmpdSupply);\\r\\n            else\\r\\n                profit = 0;\\r\\n    }\\r\\n*/\\r\\n    function verify(bytes32 tweetId, Twitter calldata twitter, Signature[] calldata signatures) external extend {\\r\\n        _verify($M.msgSender(), tweetId, twitter, signatures);\\r\\n    }\\r\\n    function _verify(address sender, bytes32 tweetId, Twitter calldata twitter, Signature[] calldata signatures) internal {\\r\\n        mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n        require(config[$C._denyVerify_] == 0, \\\"denyVerify\\\");\\r\\n        require(signatures.length \\u003e= config[$C._minSignatures_], \\\"too few signatures\\\");\\r\\n        for(uint i=0; i\\u003csignatures.length; i++) {\\r\\n            for(uint j=0; j\\u003ci; j++)\\r\\n                require(signatures[i].signatory != signatures[j].signatory, \\\"repetitive signatory\\\");\\r\\n            bytes32 structHash = keccak256(abi.encode($C.VERIFY_TYPEHASH, sender, $.nonces[sender]++, tweetId, twitter, signatures[i].signatory));\\r\\n            bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", $.DOMAIN_SEPARATOR, structHash));\\r\\n            address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\\r\\n            require(signatory != address(0), \\\"invalid signature\\\");\\r\\n            require(signatory == signatures[i].signatory \\u0026\\u0026 $.isSignatory[signatory], \\\"unauthorized\\\");\\r\\n            emit Authorize(sender, tweetId, twitter, signatures[i].signatory);\\r\\n        }\\r\\n    }\\r\\n    event Authorize(address indexed sender, bytes32 indexed tweetId, Twitter twitter, address indexed signatory);\\r\\n    \\r\\n    function createPool_() external extend governance {\\r\\n        uint price0 = $C.PRICE0;\\r\\n        //$.createPool(price0, $.totalSupply *  5 / 100, Config.getA($C._uniPosMngr_));      //  5%\\r\\n        $.pool = _createPool(price0, $.totalSupply * 10 / 100, Config.getA($C._panPosMngr_));      // 10%\\r\\n    }\\r\\n\\r\\n    function _createPool(uint price_, uint amount, address posMngr) internal returns (address pool) {\\r\\n        price_ = price_.mul(2**96).div(1e18);\\r\\n        address currency = Config.getA($C._currency_);\\r\\n        address token = address(this);\\r\\n        (address token0, address token1) = token \\u003c currency ? (token, currency) : (currency, token);\\r\\n        pool = IPoolInitializer(posMngr).createAndInitializePoolIfNecessary(token0, token1, $C.FEE, _priceToSqrt(price_));\\r\\n\\r\\n        IERC20(address(this)).approve(posMngr, uint(-1));\\r\\n        IERC20(currency).approve(posMngr, uint(-1));\\r\\n                \\r\\n        _nfpMint(0, amount, price_, posMngr);\\r\\n    }\\r\\n\\r\\n    function _nfpMint(uint e, uint b1, uint p1, address posMngr) internal returns(uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) {\\r\\n        address currency = Config.getA($C._currency_);\\r\\n        int24 tickSpacing = IUniswapV3Factory(IPeripheryImmutableState(posMngr).factory()).feeAmountTickSpacing($C.FEE);\\r\\n        int24 tick = TickMath.getTickAtSqrtRatio(_priceToSqrt(p1));\\r\\n        tick = tick / tickSpacing * tickSpacing - (tick \\u003c 0 ? tickSpacing : 0);\\r\\n\\r\\n        //(uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) = \\r\\n        return INonfungiblePositionManager(posMngr).mint(\\r\\n            INonfungiblePositionManager.MintParams({\\r\\n                token0          : address(this) \\u003c= currency ? address(this) : currency,\\r\\n                token1          : address(this) \\u003c= currency ? currency : address(this),\\r\\n                fee             : $C.FEE,\\r\\n                tickLower       : address(this) \\u003c= currency ? (e == 0 ? tick + tickSpacing : tick) : TickMath.MIN_TICK / tickSpacing * tickSpacing,\\r\\n                tickUpper       : address(this) \\u003c= currency ? TickMath.MAX_TICK / tickSpacing * tickSpacing : (e == 0 ? tick : tick + tickSpacing),\\r\\n                amount0Desired  : address(this) \\u003c= currency ? b1 : e,\\r\\n                amount1Desired  : address(this) \\u003c= currency ? e : b1,\\r\\n                amount0Min      : 0,\\r\\n                amount1Min      : 0,\\r\\n                recipient       : address(this),\\r\\n                deadline        : now\\r\\n            })\\r\\n        );\\r\\n    }\\r\\n\\r\\n    //function _pool() internal view returns (address) {\\r\\n    //    return IUniswapV3Factory(_UniswapV3Factory_).getPool(address(this), Config.getA($C._currency_), FEE);\\r\\n    //}\\r\\n\\r\\n    function _sqrtPriceX96(address pool_) internal view returns (uint160 sqrtPriceX96) {\\r\\n        (sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool_).slot0();\\r\\n    }\\r\\n\\r\\n    function _sqrtToPrice(uint160 sqrtPriceX96) internal view returns (uint price_) {\\r\\n        price_ = uint(sqrtPriceX96)**2 / 2**96;\\r\\n        if(address(this) \\u003e Config.getA($C._currency_))\\r\\n            price_ = uint(2**192) / price_;\\r\\n    }\\r\\n\\r\\n    function _priceToSqrt(uint price_) internal view returns (uint160 sqrtPriceX96) {\\r\\n        if(address(this) \\u003e Config.getA($C._currency_))\\r\\n            price_ = uint(2**192) / price_;\\r\\n        sqrtPriceX96 = SafeCast.toUint160(Math.sqrt(price_.mul(2**96)));\\r\\n    }\\r\\n\\r\\n    function quota(address who) external view viewExtend returns(uint q) {\\r\\n        return _quota(who);\\r\\n    }\\r\\n    function _quota(address who) internal view returns(uint q) {\\r\\n    }\\r\\n\\r\\n    function calcBuyOut(uint u) external view viewExtend returns(uint a) {\\r\\n        return _calcBuyOut(u);\\r\\n    }\\r\\n    function _calcBuyOut(uint u) internal view returns(uint a) {\\r\\n    }\\r\\n\\r\\n    function buy(uint u) external extend {\\r\\n        _buy(u);\\r\\n    }\\r\\n    function _buy(uint u) internal {\\r\\n        \\r\\n    }\\r\\n\\r\\n    function calcSellOut(uint a) external view viewExtend returns(uint u) {\\r\\n        return _calcSellOut(a);\\r\\n    }\\r\\n    function _calcSellOut(uint a) internal view returns(uint u) {\\r\\n    }\\r\\n\\r\\n    function sell(uint a) external extend {\\r\\n        _sell(a);\\r\\n    }\\r\\n    function _sell(uint a) internal {\\r\\n        \\r\\n    }\\r\\n\\r\\n    //function _buyInEth(address sender, uint value) internal returns (uint) {\\r\\n    //    if(value == 0)\\r\\n    //        return 0;\\r\\n    //    mapping (bytes32 =\\u003e address) storage configA = Config.configA();\\r\\n    //    IUniswapV2Router01 router = IUniswapV2Router01(configA[$C._swapRouter_]);\\r\\n    //    address WETH = router.WETH();\\r\\n    //    address currency = configA[$C._currency_];\\r\\n    //    if(currency != WETH) {\\r\\n    //        address[] memory path = new address[](2);\\r\\n    //        (path[0], path[1]) = (WETH, currency);\\r\\n    //        uint[] memory amounts = router.swapExactETHForTokens{value: value}(0, path, address(this), now);\\r\\n    //        value = amounts[1];\\r\\n    //    } else\\r\\n    //        IWETH(WETH).deposit{value: value}();\\r\\n    //    return _buy(sender, value);\\r\\n    //}\\r\\n    //\\r\\n    //function buy(PermitSign calldata ps, address[] calldata path, uint amt) payable external extend compound {\\r\\n    //    _buy($M.msgSender(), ps, path, amt);\\r\\n    //}\\r\\n    //function _buy(address sender, PermitSign calldata ps, address[] calldata path, uint amt) internal returns (uint) {\\r\\n    //    uint value = SocialFiLib.swapTokenToCurrency(sender, ps, path, amt);\\r\\n    //    return _buy(sender, value);\\r\\n    //}\\r\\n    //\\r\\n    //function _buy(address sender, uint value) internal returns (uint a){\\r\\n    //    require(Config.config()[$C._denyBuy_] == 0, \\\"denyBuy\\\");\\r\\n    //    if(value == 0)\\r\\n    //        return 0;\\r\\n    //    uint r1 = _calcRatio1();\\r\\n    //    uint v1 = value.mul(r1).div(1e18);\\r\\n    //    if(v1 \\u003e 0) {\\r\\n    //        a = _calcOut1(v1);\\r\\n    //        _mint(sender, a);\\r\\n    //        _updateLocked(sender, 0, a, Config.config()[$C._lockSpanBuy_]);     // todo\\r\\n    //        _updateBuffer(v1, a);\\r\\n    //    }\\r\\n    //    uint v2 = value.sub(v1);\\r\\n    //    if(v2 \\u003e 0) {\\r\\n    //        address currency = $C._currency_.getA();\\r\\n    //        address router = $C._swapRouter_.getA();\\r\\n    //        address[] memory path = new address[](2);\\r\\n    //        (path[0], path[1]) = (currency, address(this));\\r\\n    //        IERC20(currency).safeApprove_(address(router), v2);\\r\\n    //        uint[] memory amounts = IUniswapV2Router01(router).swapExactTokensForTokens(v2, 0, path, sender, now);\\r\\n    //        a = a.add(amounts[1]);\\r\\n    //    }\\r\\n    //    emit Buy(sender, value, a);\\r\\n    //}\\r\\n    //event Buy(address indexed sender, uint value, uint amount);\\r\\n//\\r\\n    ////function calcOut1(uint v) external view viewExtend returns(uint a) {\\r\\n    ////    return _calcOut1(v);\\r\\n    ////}\\r\\n    //function _calcOut1(uint v) internal view returns(uint a) {\\r\\n    //    uint f = Config.config()[$C._factorPrice_];\\r\\n    //    uint b = _buyBuffer();\\r\\n    //    uint s = _buySupply();\\r\\n    //    uint p = f.mul(b).div0(s);\\r\\n    //    uint pv = f.mul(b.add(v)).div0(s.add(v.mul(1e18).div0(p)));\\r\\n    //    p = p.add(pv).div(2);\\r\\n    //    return v.mul(1e18).div0(p);\\r\\n    //}\\r\\n//\\r\\n    //function calcOut(uint value, address[] calldata path) external view viewExtend returns(uint a) {\\r\\n    //    mapping (bytes32 =\\u003e address) storage configA = Config.configA();\\r\\n    //    address currency = configA[$C._currency_];\\r\\n    //    address router = configA[$C._swapRouter_];\\r\\n    //    require(path.length == 0 || path[path.length-1] == currency, \\\"INVALID_PATH\\\");\\r\\n    //    if(path.length \\u003e= 2)\\r\\n    //        value = IUniswapV2Router01(router).getAmountsOut(value, path)[path.length-1];\\r\\n    //    uint r1 = _calcRatio1();\\r\\n    //    uint v1 = value.mul(r1).div(1e18);\\r\\n    //    if(v1 \\u003e 0)\\r\\n    //        a = _calcOut1(v1);\\r\\n    //    uint v2 = value.sub(v1);\\r\\n    //    if(v2 \\u003e 0) {\\r\\n    //        address[] memory p = new address[](2);\\r\\n    //        (p[0], p[1]) = (currency, address(this));\\r\\n    //        uint[] memory amounts = IUniswapV2Router01(router).getAmountsOut(v2, p);\\r\\n    //        a = a.add(amounts[1]);\\r\\n    //    }\\r\\n    //}\\r\\n//\\r\\n    //function calcIn(uint a, address[] calldata path) external view viewExtend returns(uint) {\\r\\n    //    return _calcIn(a, path);\\r\\n    //}\\r\\n    //function _calcIn(uint amt, address[] calldata path) internal view returns(uint v) {\\r\\n    //    uint r1 = _calcRatio1();\\r\\n    //    uint a = amt.mul(r1).div(1e18);\\r\\n    //    v = _calcIn1(a);\\r\\n    //\\r\\n    //    mapping (bytes32 =\\u003e address) storage configA = Config.configA();\\r\\n    //    address currency = configA[$C._currency_];\\r\\n    //    address router = configA[$C._swapRouter_];\\r\\n    //\\r\\n    //    a = amt.sub(a);\\r\\n    //    if(a \\u003e 0) {\\r\\n    //        address[] memory p = new address[](2);\\r\\n    //        (p[0], p[1]) = (currency, address(this));\\r\\n    //        v = v.add(IUniswapV2Router01(router).getAmountsIn(a, p)[0]);\\r\\n    //    }\\r\\n    //\\r\\n    //    require(path.length == 0 || path[path.length-1] == currency, \\\"INVALID_PATH\\\");\\r\\n    //    if(path.length \\u003e= 2)\\r\\n    //        v = IUniswapV2Router01(router).getAmountsIn(v, path)[0];\\r\\n    //}\\r\\n    //\\r\\n    ////function calcIn1(uint quota) external view viewExtend returns(uint) {\\r\\n    ////    return _calcIn1(quota);\\r\\n    ////}\\r\\n    //function _calcIn1(uint a) internal view returns(uint) {\\r\\n    //    uint f = Config.config()[$C._factorPrice_];\\r\\n    //    uint b = _buyBuffer();\\r\\n    //    uint s = _buySupply();\\r\\n    //    uint p = f.mul(b).div0(s);\\r\\n    //    uint pa = f.mul(b.add(a.mul(p).div(1e18))).div0(s.add(a));\\r\\n    //    p = p.add(pa).div(2);\\r\\n    //    return a.mul(p).div(1e18);\\r\\n    //}\\r\\n//\\r\\n    //function calcRatio1() external view viewExtend returns(uint r) {\\r\\n    //    return _calcRatio1();\\r\\n    //}\\r\\n    //function _calcRatio1() internal view returns(uint r) {\\r\\n    //    return _calcRatio1(_price1(), _price2());\\r\\n    //}\\r\\n    //function _calcRatio1(uint p1, uint p2) internal view returns(uint r) {\\r\\n    //    if(p2 == 0)\\r\\n    //        return 1e18;\\r\\n    //    return Math.min(p2.sub0(p1).mul(1e18).div(p2).mul(1e18).div(Config.config()[$C._discount_]), 1e18);\\r\\n    //}\\r\\n\\r\\n    //function sell(uint vol) external extend {\\r\\n    //    address sender = $M.msgSender();\\r\\n    //    IUniswapV2Router01 router = IUniswapV2Router01($C._swapRouter_.getA());\\r\\n    //    $.transfer(sender, address(this), vol);\\r\\n    //    _approve(address(this), address(router), vol);\\r\\n    //    address[] memory path = new address[](2);\\r\\n    //    (path[0], path[1]) = (address(this), router.WETH());\\r\\n    //    uint[] memory amounts = router.swapExactTokensForETH(vol, 0, path, sender, now);\\r\\n    //    emit Sell(sender, vol, amounts[1]);\\r\\n    //}\\r\\n    //event Sell(address indexed sender, uint vol, uint eth);\\r\\n\\r\\n    //function sellForToken(uint vol, address token) external extend {\\r\\n    //    address sender = $M.msgSender();\\r\\n    //    IUniswapV2Router01 router = IUniswapV2Router01($C._swapRouter_.getA());\\r\\n    //    $.transfer(sender, address(this), vol);\\r\\n    //    _approve(address(this), address(router), vol);\\r\\n    //    address[] memory path = new address[](3);\\r\\n    //    (path[0], path[1], path[2]) = (address(this), router.WETH(), token);\\r\\n    //    uint[] memory amounts = router.swapExactTokensForTokens(vol, 0, path, sender, now);\\r\\n    //    emit SellForToken(sender, vol, token, amounts[2]);\\r\\n    //}\\r\\n    //event SellForToken(address indexed sender, uint vol, address indexed token, uint amt);\\r\\n\\r\\n    function setSignatories_(address[] calldata signatories) external extend governance {\\r\\n        $.setSignatories(signatories);\\r\\n    }\\r\\n\\r\\n    function setTax0List_(address[] calldata list, bool[] calldata tax0) external extend governance {\\r\\n        require(list.length == tax0.length, \\\"!=length\\\");\\r\\n        for(uint i=0; i\\u003clist.length; i++)\\r\\n            $.tax0list[list[i]] = tax0[i];\\r\\n    }\\r\\n\\r\\n    //function setBuf_(uint112 supply, uint factor, uint p1) external extend governance {\\r\\n    //    $.setBuf(supply, factor, p1);\\r\\n    //}\\r\\n\\r\\n    function woofEndTime(bytes32 tweetId) external view viewExtend returns (uint) {\\r\\n        return $.woofs[tweetId].endTime;\\r\\n    }\\r\\n    \\r\\n    //function woofRewardRate(bytes32 tweetId) external view viewExtend returns (uint) {\\r\\n    //    return $.woofs[tweetId].rewardRate;\\r\\n    //}\\r\\n    \\r\\n    //function woofDog(bytes32 tweetId, address acct) external view viewExtend returns (uint cowoofAmt, uint yieldPerToken, uint yield_, uint yieldPaid, uint rewoofAmt, uint rewardPerToken, uint reward, uint rewardPaid) {\\r\\n    //    Dog storage dog = $.woofs[tweetId].dogs[acct];\\r\\n    //    return (dog.cowoofAmt, dog.yieldPerToken, dog.yield, dog.yieldPaid, $.bal4Prin(dog.rewoofPrin), $.prin4Bal(dog.rewardPerPrin), dog.reward, dog.rewardPaid);\\r\\n    //}\\r\\n    \\r\\n    //function yieldPerToken(bytes32 tweetId) external view viewExtend returns (uint) {\\r\\n    //    return _yieldPerToken(tweetId);\\r\\n    //}\\r\\n    function _yieldPerToken(bytes32 tweetId) internal view returns (uint) {\\r\\n        Woof storage woof = $.woofs[tweetId];\\r\\n        Dog  storage all  = woof.dogs[address(-1)];\\r\\n        if (all.cowoofAmt == 0 || woof.lastTime \\u003e= woof.endTime)\\r\\n            return all.yieldPerToken;\\r\\n        return all.yieldPerToken.add($.bal4Prin(all.rewoofPrin).sub(woof.lastRewoof).mul($C._yieldPerRebase_.get()).div(all.cowoofAmt));\\r\\n    }\\r\\n\\r\\n    function yielded(bytes32 tweetId, address acct) external view viewExtend returns (uint) {\\r\\n        return _yielded(tweetId, acct);\\r\\n    }\\r\\n    function _yielded(bytes32 tweetId, address acct) internal view returns (uint) {\\r\\n        Dog storage dog = $.woofs[tweetId].dogs[acct];\\r\\n        uint yield = dog.cowoofAmt.mul(_yieldPerToken(tweetId).sub(dog.yieldPerToken)).div(1e18).add(dog.yield);\\r\\n        bytes32 _factor_ = (acct == $.addrOfId[$.woofs[tweetId].twitterId]) ? $C._maxYieldFactor_ : $C._maxCoYieldFactor_;\\r\\n        uint max = _factor_.get().mul(dog.cowoofAmt).div(1e18);\\r\\n        return Math.min(yield, max.sub0(dog.yieldPaid));\\r\\n    }\\r\\n\\r\\n    function roi(bytes32 tweetId, address acct) external view viewExtend returns (uint) {\\r\\n        if(acct == address(-1))\\r\\n            return _yieldPerToken(tweetId);\\r\\n        Dog storage dog = $.woofs[tweetId].dogs[acct];\\r\\n        return _yielded(tweetId, acct).add(dog.yieldPaid).mul(1e18).div(dog.cowoofAmt);\\r\\n    }\\r\\n\\r\\n    function getYields(bytes32[] calldata tweetIds) external extend compound {\\r\\n        for(uint i=0; i\\u003ctweetIds.length; i++) {\\r\\n            _updateWoof(tweetIds[i], $M.msgSender());\\r\\n            _getYield(tweetIds[i]);\\r\\n        }\\r\\n    }\\r\\n    function getYield(bytes32 tweetId) external extend updateWoof(tweetId) {\\r\\n        _getYield(tweetId);\\r\\n    }\\r\\n    function _getYield(bytes32 tweetId) internal {\\r\\n        address sender = $M.msgSender();\\r\\n        Dog storage dog = $.woofs[tweetId].dogs[sender];\\r\\n        uint256 yield = dog.yield;\\r\\n        if (yield \\u003e 0) {\\r\\n            dog.yield = 0;\\r\\n            _mint(sender, yield);\\r\\n            _updateLocked(sender, yield, $.woofs[tweetId].endTime.sub0(block.timestamp).add($C._woofSpan_.get()));   // todo\\r\\n            dog.yieldPaid = dog.yieldPaid.add(yield);\\r\\n            emit YieldPaid(sender, yield);\\r\\n        }\\r\\n    }\\r\\n    event YieldPaid(address indexed user, uint256 yield_);\\r\\n    \\r\\n    function _lastTime(bytes32 tweetId) internal view returns (uint) {\\r\\n        return Math.min(block.timestamp, $.woofs[tweetId].endTime);\\r\\n    }\\r\\n\\r\\n    function _rewardPerPrin(bytes32 tweetId) internal view returns (uint) {\\r\\n        Woof storage woof = $.woofs[tweetId];\\r\\n        Dog  storage all  = woof.dogs[address(-1)];\\r\\n        if (all.rewoofPrin == 0)\\r\\n            return all.rewardPerPrin;\\r\\n        return all.rewardPerPrin.add(_lastTime(tweetId).sub(woof.lastTime).mul(woof.rewardRate).mul(1e18).div(all.rewoofPrin));\\r\\n    }\\r\\n\\r\\n    function earned(bytes32 tweetId, address acct) external view viewExtend returns (uint) {\\r\\n        return _earned(tweetId, acct);\\r\\n    }\\r\\n    function _earned(bytes32 tweetId, address acct) internal view returns (uint) {\\r\\n        Dog storage dog = $.woofs[tweetId].dogs[acct];\\r\\n        return dog.rewoofPrin.mul(_rewardPerPrin(tweetId).sub(dog.rewardPerPrin)).div(1e18).add(dog.reward);\\r\\n    }\\r\\n\\r\\n    function getRewards(bytes32[] calldata tweetIds) external extend compound {\\r\\n        for(uint i=0; i\\u003ctweetIds.length; i++) {\\r\\n            _updateWoof(tweetIds[i], $M.msgSender());\\r\\n            _getReward(tweetIds[i]);\\r\\n        }\\r\\n    }\\r\\n    function getReward(bytes32 tweetId) external extend updateWoof(tweetId) {\\r\\n        _getReward(tweetId);\\r\\n    }\\r\\n    function _getReward(bytes32 tweetId) internal {\\r\\n        address sender = $M.msgSender();\\r\\n        Dog storage dog = $.woofs[tweetId].dogs[sender];\\r\\n        uint256 reward = dog.reward;\\r\\n        if (reward \\u003e 0) {\\r\\n            dog.reward = 0;\\r\\n            _mint(sender, reward);\\r\\n            _updateLocked(sender, reward, $.woofs[tweetId].endTime.sub0(block.timestamp).add($C._woofSpan_.get()));  // todo\\r\\n            dog.rewardPaid = dog.rewardPaid.add(reward);\\r\\n            emit RewardPaid(sender, reward);\\r\\n        }\\r\\n    }\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n\\r\\n    modifier updateWoof(bytes32 tweetId) {\\r\\n        _updateWoof(tweetId);\\r\\n        _;\\r\\n    }\\r\\n    function _updateWoof(bytes32 tweetId) internal compound {\\r\\n        _updateWoof(tweetId, $M.msgSender());\\r\\n    }\\r\\n    function _updateWoof(bytes32 tweetId, address acct) internal {\\r\\n        Woof storage woof   = $.woofs[tweetId];\\r\\n        Dog  storage all    = woof.dogs[address(-1)];\\r\\n        all.yieldPerToken   = _yieldPerToken(tweetId);\\r\\n        all.rewardPerPrin   = _rewardPerPrin(tweetId);\\r\\n        woof.lastRewoof     = $.bal4Prin(all.rewoofPrin);\\r\\n        woof.lastTime       = _lastTime(tweetId);\\r\\n        if (acct != address(0)) {\\r\\n            Dog storage dog     = woof.dogs[acct];\\r\\n            dog.yield           = _yielded(tweetId, acct);\\r\\n            dog.reward          = _earned (tweetId, acct);\\r\\n            dog.yieldPerToken   = all.yieldPerToken;\\r\\n            dog.rewardPerPrin   = all.rewardPerPrin;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //receive () override payable external {\\r\\n    //\\r\\n    //}\\r\\n}\\r\\n\\r\\ncontract SocialFiEx is SocialFi {\\r\\n    modifier extend override {\\r\\n        _;\\r\\n    }\\r\\n    modifier viewExtend override {\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    fallback () override payable external {\\r\\n        revert(ERROR_FALLBACK);\\r\\n    }\\r\\n\\r\\n    receive () override payable external {\\r\\n        if(OpenZeppelinUpgradesAddress.isContract(msg.sender) \\u0026\\u0026 msg.data.length == 0)         // for receive ETH only from other contract\\r\\n            return;\\r\\n        revert(ERROR_FALLBACK);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SocialFiLib {\\r\\n    using Config for bytes32;\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using ERC20Lib for ERC20Stru;\\r\\n    using SocialFiLib for SocialFiStru;\\r\\n    \\r\\n    function E(SocialFiStru storage $) internal pure returns (ERC20Stru storage e$) {\\r\\n        assembly {  e$_slot := $_slot   }\\r\\n    }\\r\\n\\r\\n    function delegatestaticcall(address ex, bytes memory data) external returns (bool, bytes memory) {\\r\\n        return ex.delegatecall(data);\\r\\n    }\\r\\n\\r\\n    function __SocialFi_init_unchained(SocialFiStru storage $) external {\\r\\n        $.index                       = 1e18;\\r\\n        $.accts[$C.ALL_ADDR].airFactor= 1e32;\\r\\n        mapping (bytes32 =\\u003e uint) storage config = Config.config();\\r\\n        config[$C._minSignatures_   ] = 1;\\r\\n        config[$C._minAirClaim_     ] = 999;\\r\\n        config[$C._maxAirClaim_     ] = 100_000;\\r\\n        config[$C._spanAirClaim_    ] = 20 days;\\r\\n        config[$C._factorAirClaim_  ] = 10000e18;\\r\\n        config[$C._factorProfitAir_ ] = 100;\\r\\n        config[$C._factorProfitBuy_ ] = 100;\\r\\n        //config[$C._factorMoreInfluence_ ] = 0.5e18;\\r\\n        config[$C._unlockBegin_     ] = now.add(10 days);\\r\\n        config[$C._lockSpanAirClaim_] = 100*365 days;       // todo\\r\\n        config[$C._lockSpanBuy_     ] = 7 days;\\r\\n        config[$C._spanBuyBuf_      ] = 7 days;\\r\\n        //config[$C._factorPrice_     ] = 0.01e18;        //0.0000025e18;   // $0.01\\r\\n        config[$C._factorPrice20_   ] = 1.1e18;           // price20 = price1 * 1.1\\r\\n        config[$C._currency_        ] = uint(0x6B175474E89094C44Da98b954EedeAC495271d0F);   // DAI 18\\r\\n        if($C._chainId() == 56)         // BSC Mainnet\\r\\n            config[$C._currency_    ] = uint(0x55d398326f99059fF775485246999027B3197955);   // BSC_USDT 18\\r\\n        else if($C._chainId() == 97)    // BSC Testnet\\r\\n            config[$C._currency_    ] = uint(0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684);   // BSC_TEST_USDT 18\\r\\n        else if($C._chainId() == 5)     // Goerli\\r\\n            config[$C._currency_    ] = uint(0x5C221E77624690fff6dd741493D735a17716c26B);   // Goerli_DAI 18\\r\\n        config[$C._swapRouter_      ] = uint(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        config[$C._swapFactory_     ] = uint(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\\r\\n        //if($C._chainId() == 56)         // BSC Mainnet\\r\\n        //    config[$C._uniPosMngr_  ] = uint(0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613);\\r\\n        //else\\r\\n        //    config[$C._uniPosMngr_  ] = uint(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\\r\\n        if($C._chainId() == 56 || $C._chainId() == 1)   // BSC Mainnet or Ethereum Mainnet\\r\\n            config[$C._panPosMngr_  ] = uint(0x46A15B0b27311cedF172AB29E4f4766fbE7F4364);\\r\\n        else\\r\\n            config[$C._panPosMngr_  ] = uint(0x427bF5b37357632377eCbEC9de3626C71A5396c1);\\r\\n        config[$C._discount_        ] = 0.10e18;        // 10%\\r\\n        config[$C._rebaseTime_      ] = now.add(10 days).add(8 hours).sub(now % 8 hours);\\r\\n        config[$C._rebasePeriod_    ] = 8 hours;\\r\\n        config[$C._rebaseSpan_      ] = 20*365 days;\\r\\n        config[$C._lpTknMaxRatio_   ] = 0.10e18;        // 10%\\r\\n        config[$C._lpCurMaxRatio_   ] = 0.50e18;        // 50%\\r\\n        config[$C._buybackRatio_    ] = 0.10e18;        // 10%\\r\\n        config[$C._operator_        ] = uint(msg.sender);\\r\\n        config[$C._ecoAddr_         ] = uint(msg.sender);\\r\\n        config[$C._ecoRatio_        ] = 0.01e18;        //  1%\\r\\n        config[$C._deadRatio_       ] = 0.09e18;        //  9%;\\r\\n        config[$C._unlockSelfRatio_ ] = 0.05e18;        //  5%\\r\\n        config[$C._unlockRefRatio_  ] = 0.02e18;        //  2%\\r\\n        config[$C._unlockRef2Ratio_ ] = 0.01e18;        //  1%\\r\\n        config[$C._unlockAllRatio_  ] = 0.01e18;        //  1%\\r\\n        config[$C._denyBuy_         ] = 1;\\r\\n\\r\\n        //setBuf($, 100_000e18 * 5 * 100e18 / 0.01e18, 100e18, 0.01e18);\\r\\n\\r\\n        address[] memory signatories = new address[](6);\\r\\n        signatories[0] = 0x4f91F7639B21D004Aa2A81D1d6C9eB506dAf46aa;\\r\\n        signatories[1] = 0x0634Aab76586644f43A4A5d395FA737E49cbbba6;\\r\\n        signatories[2] = 0x023C8a3209F3dae154A5407cB290894478184423;\\r\\n        signatories[3] = 0x27414b9FA8992002462D5F3B97bb2C161528b808;\\r\\n        signatories[4] = 0xB5F6CadFbE80928dabD1e58669493f1e520aBf50;\\r\\n        signatories[5] = 0xc0D957AB3398bB1D4E3BbD18bfC6Da8aaDEf1d6B;\\r\\n        setSignatories($, signatories);\\r\\n\\r\\n        $.tax0list[address(this)]       = true;\\r\\n        $.tax0list[$C._ecoAddr_.getA()] = true;\\r\\n\\r\\n        config[$C._woofSpan_        ] = 7 days;\\r\\n        config[$C._minCowoof_       ] = 100000e18;\\r\\n        config[$C._yieldPerRebase_  ] = 0.50e18;        // 50%\\r\\n        config[$C._maxYieldFactor_  ] = 1.50e18;        // 150%\\r\\n        config[$C._maxCoYieldFactor_] = 1.35e18;        // 135%\\r\\n        config[$C._minRewoofIncRatio_]= 0.10e18;        // 10%\\r\\n\\r\\n        uint totalSupply = 1e12 * 1e18;\\r\\n        mint($, address(this), totalSupply);\\r\\n    }\\r\\n\\r\\n    function prin4Bal(SocialFiStru storage $, uint bal) internal view returns(uint) {\\r\\n        return bal.mul(1e18).div($.index);\\r\\n    }\\r\\n\\r\\n    function bal4Prin(SocialFiStru storage $, uint prin) internal view returns(uint) {\\r\\n        return prin.mul($.index).div(1e18);\\r\\n    }\\r\\n\\r\\n    function balanceOf(SocialFiStru storage $, address who) internal view returns(uint bal) {\\r\\n        bal = $.balances[who];\\r\\n        if($.accts[who].isCmpd)\\r\\n            bal = $.bal4Prin(bal);\\r\\n    }\\r\\n\\r\\n    function unlockAir(SocialFiStru storage $, address who, uint amt) internal {\\r\\n        Account storage all = $.accts[$C.ALL_ADDR];\\r\\n        (uint allFactor, uint allUnlocked, uint allClaimed) = (all.airFactor, all.airUnlocked, all.airClaimed);\\r\\n        if(who == $C.ALL_ADDR) {\\r\\n            uint allRest = allClaimed.sub0(allUnlocked);\\r\\n            if(amt != 0)\\r\\n                (all.airFactor, all.airUnlocked) = (uint112(allFactor.mul(allRest.sub0(amt).div(allRest))), uint112(Math.min(allUnlocked.add(amt), allClaimed)));\\r\\n        } else {\\r\\n            Account storage acct = $.accts[who];\\r\\n            (uint airFactor, uint airUnlocked, uint airClaimed) = (acct.airFactor, acct.airUnlocked, acct.airClaimed);\\r\\n            uint airRest = airClaimed.sub0(airUnlocked);\\r\\n            airRest = airRest.sub0(airRest.mul(allFactor).div0(airFactor));\\r\\n            amt = Math.min(amt, airClaimed.sub0(airUnlocked.add(airRest)));\\r\\n            airUnlocked = airUnlocked.add(airRest).add(amt);\\r\\n            if(airFactor != allFactor || amt != 0)\\r\\n                (acct.airFactor, acct.airUnlocked) = (uint112(allFactor), uint112(airUnlocked));\\r\\n            if(amt != 0)\\r\\n                all.airUnlocked = uint112(allUnlocked.add(amt));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function update(SocialFiStru storage $, address who) internal {\\r\\n        $.unlockAir(who, 0);\\r\\n    }\\r\\n\\r\\n    //function transfer(SocialFiStru storage $, address from, address to, uint256 amt) public returns (bool) {\\r\\n    //    //$.beforeTokenTransfer(from, to, amt);\\r\\n    //    require($.unlockedOf(from) \\u003e= amt, \\\"transfer amt exceeds unlocked\\\");\\r\\n    //\\r\\n    //    uint flat = $.flatSupply;\\r\\n    //    uint prin = $.prin4Bal(amt);\\r\\n    //    uint v = prin;\\r\\n    //    if(!$.accts[from].isCmpd) {\\r\\n    //        flat = flat.sub(amt);\\r\\n    //        v = amt;\\r\\n    //    }\\r\\n    //    $.balances[from] = $.balances[from].sub(v, \\\"transfer amt exceeds bal\\\");\\r\\n    //    v = prin;\\r\\n    //    if(!$.accts[to].isCmpd) {\\r\\n    //        flat = flat.add(amt);\\r\\n    //        v = amt;\\r\\n    //    }\\r\\n    //    $.balances[to] = $.balances[to  ].add(v);\\r\\n    //    if($.flatSupply != flat)\\r\\n    //        $.flatSupply = flat;\\r\\n    //    emit ERC20Lib.Transfer(from, to, amt);\\r\\n    //    return true;\\r\\n    //}\\r\\n    function _transfer(SocialFiStru storage $, address from, address to, uint amt) internal {\\r\\n        update($, from);\\r\\n        if(to != from)\\r\\n            update($, to);\\r\\n        //$.beforeTokenTransfer(from, to, amt);\\r\\n        require($.unlockedOf(from) \\u003e= amt, \\\"transfer amt exceeds unlocked\\\");\\r\\n    \\r\\n        $.balances[from] = $.balances[from].sub(amt);\\r\\n        $.balances[to  ] = $.balances[to  ].add(amt);\\r\\n        emit ERC20Lib.Transfer(from, to, amt);\\r\\n    }\\r\\n    \\r\\n    function transfer(SocialFiStru storage $, address from, address to, uint amt) public returns (bool) {\\r\\n        uint amtTo = amt;\\r\\n        uint amtDead;\\r\\n        uint amtEco;\\r\\n        uint deadRatio = $C._deadRatio_.get();\\r\\n        uint ecoRatio  = $C._ecoRatio_ .get();\\r\\n        if(!$.tax0list[from] \\u0026\\u0026 !$.tax0list[to]) {\\r\\n            amtDead = amt.mul(deadRatio).div(1e18);\\r\\n            amtEco  = amt.mul(ecoRatio).div(1e18);\\r\\n            amtTo   = amt.sub(amtDead).sub(amtEco);\\r\\n        }\\r\\n        if(!$.tax0list[from] \\u0026\\u0026 to == $.pool){                                  // sell\\r\\n            uint toRatio = uint(1e18).sub(deadRatio).sub(ecoRatio);\\r\\n            amtDead = amt.mul(deadRatio).div(toRatio);\\r\\n            amtEco  = amt.mul(ecoRatio).div(toRatio);\\r\\n            amtTo   = amt;\\r\\n        } else if(from == $.pool) {                                             // buy\\r\\n            unlockAir($, to, amt.mul($C._unlockSelfRatio_.get()).div(1e18));\\r\\n            address ref = $.accts[to].referrer;\\r\\n            unlockAir($, ref, amt.mul($C._unlockRefRatio_.get()).div(1e18));\\r\\n            address ref2 = $.accts[ref].referrer;\\r\\n            unlockAir($, ref2, amt.mul($C._unlockRef2Ratio_.get()).div(1e18));\\r\\n            unlockAir($, $C.ALL_ADDR, amt.mul($C._unlockAllRatio_.get()).div(1e18));\\r\\n        }\\r\\n        _transfer($, from, to, amtTo);\\r\\n        _transfer($, from, $C.DEAD_ADDR, amtDead);\\r\\n        _transfer($, from, $C._ecoAddr_.getA(), amtEco);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(SocialFiStru storage $, address from, address to, uint256 amt) external returns (bool) {\\r\\n        if(from != $M.msgSender() \\u0026\\u0026 $.allowances[from][$M.msgSender()] != uint(-1))\\r\\n            E($).approve(from, $M.msgSender(), $.allowances[from][$M.msgSender()].sub(amt, \\\"transfer amt exceeds allowance\\\"));\\r\\n        return transfer($, from, to, amt);\\r\\n    }\\r\\n\\r\\n    function mint(SocialFiStru storage $, address to, uint256 amt) public {\\r\\n        if ($.cap \\u003e 0)   // When Capped\\r\\n            require($.totalSupply.add(amt) \\u003c= $.cap, \\\"cap exceeded\\\");\\r\\n        //$.beforeTokenTransfer(address(0), to, amt);\\r\\n\\r\\n        $.totalSupply = $.totalSupply.add(amt);\\r\\n        mint_($, to, amt);\\r\\n    }\\r\\n\\r\\n    function mint_(SocialFiStru storage $, address to, uint256 amt) public {\\r\\n        uint v;\\r\\n        if(!$.accts[to].isCmpd) {\\r\\n            $.flatSupply = $.flatSupply.add(amt);\\r\\n            v = amt;\\r\\n        } else\\r\\n            v = $.prin4Bal(amt);\\r\\n        $.balances[to] = $.balances[to].add(v);\\r\\n        emit ERC20Lib.Transfer(address(0), to, amt);\\r\\n    }\\r\\n\\r\\n    function burn(SocialFiStru storage $, address from, uint256 amt) public {\\r\\n        //$.beforeTokenTransfer(from, address(0), amt);\\r\\n        //require($.unlockedOf(from) \\u003e= amt, \\\"burn amt exceeds unlocked\\\");\\r\\n        uint v;\\r\\n        if(!$.accts[from].isCmpd) {\\r\\n            $.flatSupply = $.flatSupply.sub(amt);\\r\\n            v = amt;\\r\\n        } else\\r\\n            v = $.prin4Bal(amt);\\r\\n        $.balances[from] = $.balances[from].sub(v, \\\"burn amt exceeds balance\\\");\\r\\n        $.totalSupply = $.totalSupply.sub(amt);\\r\\n        emit ERC20Lib.Transfer(from, address(0), amt);\\r\\n    }\\r\\n\\r\\n    //function beforeTokenTransfer(SocialFiStru storage $, address from, address to, uint256 amount) internal { }\\r\\n\\r\\n    function currLocked(uint locked, uint unlockEnd) internal view returns(uint) {\\r\\n        if(locked == 0 || now \\u003e= unlockEnd)\\r\\n            return 0;\\r\\n        uint unlockBegin = Config.config()[$C._unlockBegin_];\\r\\n        if(now \\u003c= unlockBegin)\\r\\n            return locked;\\r\\n        return locked.mul(unlockEnd.sub(now)).div(unlockEnd.sub(unlockBegin));\\r\\n    }\\r\\n\\r\\n    function lockedOf(SocialFiStru storage $, address who) internal view returns(uint) {\\r\\n        Account storage acct = $.accts[who];\\r\\n        (uint locked, uint unlockEnd) = (acct.locked, acct.unlockEnd);\\r\\n        return currLocked(locked, unlockEnd);\\r\\n    }\\r\\n\\r\\n    function unlockedOf(SocialFiStru storage $, address who) internal view returns(uint) {\\r\\n        Account storage acct = $.accts[who];\\r\\n        (uint airFactor, uint airUnlocked, uint airClaimed) = (acct.airFactor, acct.airUnlocked, acct.airClaimed);\\r\\n        uint airRest = airClaimed.sub0(airUnlocked).mul($.accts[$C.ALL_ADDR].airFactor).div0(airFactor);\\r\\n        return $.balanceOf(who).sub0($.lockedOf(who)).sub0(airRest);\\r\\n    }\\r\\n\\r\\n    function permit(SocialFiStru storage $, address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\r\\n        ERC20Stru storage E$ = E($);\\r\\n        return E$.permit(owner, spender, value, deadline, v, r, s);\\r\\n    }\\r\\n   \\r\\n/*\\r\\n    //function addLiquidity(SocialFiStru storage $, uint value, uint amount) internal {\\r\\n    //    mint($, address(this), amount);\\r\\n    //    address currency = Config.getA($C._currency_);\\r\\n    //    IUniswapV2Router01 router = IUniswapV2Router01(Config.getA($C._swapRouter_));\\r\\n    //    IERC20(currency).safeApprove_(address(router), value);\\r\\n    //    IERC20(address(this)).approve(address(router), amount);\\r\\n    //    (, uint amt,) = router.addLiquidity(currency, address(this), value, amount, 0, 0, address(this), now);\\r\\n    //    if(amount \\u003e amt)\\r\\n    //        burn($, address(this), amount - amt);\\r\\n    //    $.totalProfit = $.totalProfit.sub0(amt);\\r\\n    //}\\r\\n//\\r\\n    //function removeLiquidity(SocialFiStru storage $, uint liquidity) internal {\\r\\n    //    address currency = Config.getA($C._currency_);\\r\\n    //    IUniswapV2Router01 router = IUniswapV2Router01(Config.getA($C._swapRouter_));\\r\\n    //    address pair = IUniswapV2Factory(Config.getA($C._swapFactory_)).getPair(currency, address(this));\\r\\n    //    IERC20(pair).approve(address(router), liquidity);\\r\\n    //    (, uint amount) = router.removeLiquidity(currency, address(this), liquidity, 0, 0, address(this), now);\\r\\n    //    burn($, address(this), amount);\\r\\n    //    $.totalProfit = $.totalProfit.add(amount);\\r\\n    //}\\r\\n\\r\\n    //function adjustLiquidity(SocialFiStru storage $) external {\\r\\n    //    SocialFi SocialFi = SocialFi(payable(address(this)));\\r\\n    //    uint curBal = 0;\\r\\n    //    uint tknBal = 0;\\r\\n    //    address currency = $C._currency_.getA();\\r\\n    //    address pair = IUniswapV2Factory($C._swapFactory_.getA()).getPair(currency, address(this));\\r\\n    //    if(pair != address(0)) {\\r\\n    //        curBal = IERC20(currency).balanceOf(pair);\\r\\n    //        tknBal = $.balances[pair];\\r\\n    //    }\\r\\n    //    uint curTgt = IERC20(currency).balanceOf(address(this)).add(curBal).mul($C._lpCurMaxRatio_.get()).div(1e18);\\r\\n    //    uint tknR = $C._lpTknMaxRatio_.get();\\r\\n    //    uint tknTgt = $.totalSupply.sub(tknBal).mul(tknR).div(uint(1e18).sub(tknR));\\r\\n    //    //if(curBal == 0)\\r\\n    //    //    curTgt = tknTgt.mul(SocialFi.price1()).div(1e18).mul($C._factorPrice20_.get()).div(1e18);\\r\\n    //    if(tknBal == 0)\\r\\n    //        tknTgt = curTgt.mul(1e18).div(SocialFi.price1()).mul(1e18).div($C._factorPrice20_.get());\\r\\n    //    if(curTgt \\u003e curBal \\u0026\\u0026 tknTgt \\u003e tknBal) \\r\\n    //        $.addLiquidity(curTgt - curBal, tknTgt - tknBal);\\r\\n    //    else {\\r\\n    //        uint rr = Math.max(curBal.sub0(curTgt).mul(1e18).div(curBal), tknBal.sub0(tknTgt).mul(1e18).div(tknBal));\\r\\n    //        if(rr \\u003e 0)\\r\\n    //            $.removeLiquidity(IERC20(pair).balanceOf(address(this)).mul(rr).div(1e18));\\r\\n    //    }   \\r\\n    //}\\r\\n//\\r\\n    //function tryBuyback(SocialFiStru storage $) external {\\r\\n    //    SocialFi SocialFi = SocialFi(payable(address(this)));\\r\\n    //    address currency = Config.getA($C._currency_);\\r\\n    //    IUniswapV2Router01 router = IUniswapV2Router01(Config.getA($C._swapRouter_));\\r\\n    //    address pair = IUniswapV2Factory(Config.getA($C._swapFactory_)).getPair(currency, address(this));\\r\\n    //    //require(Config.get($C._buybackAnytime_) \\u003e 0 || $.totalSupply.mul(SocialFi.price2()).div(1e18) \\u003c IERC20(currency).balanceOf(address(this)).add(IERC20(currency).balanceOf(pair).mul(2)), \\\"price2 should below net value\\\");\\r\\n    //    if(Config.get($C._buybackAnytime_) == 0 \\u0026\\u0026 $.totalSupply.mul(SocialFi.price2()).div(1e18) \\u003e= IERC20(currency).balanceOf(address(this)).add(IERC20(currency).balanceOf(pair).mul(2)))\\r\\n    //        return;\\r\\n    //    uint value = IERC20(currency).balanceOf(address(this)).mul(Config.get($C._buybackRatio_)).div(1e18);\\r\\n    //    address[] memory path = new address[](2);\\r\\n    //    (path[0], path[1]) = (currency, address(this));\\r\\n    //    IERC20(currency).safeApprove_(address(router), value);\\r\\n    //    uint[] memory amounts = router.swapExactTokensForTokens(value, 0, path, address(0xdEaD), now);\\r\\n    //    burn($, address(0xdEaD), amounts[1]);\\r\\n    //    $.totalProfit = $.totalProfit.add(amounts[1]);\\r\\n    //}\\r\\n\\r\\n    function swapTokenToCurrency(address sender, PermitSign calldata ps, address[] calldata path, uint amt) external returns(uint) {\\r\\n        address currency = $C._currency_.getA();\\r\\n        require(path.length == 0 || path[path.length-1] == currency, \\\"INVALID_PATH\\\");\\r\\n        address token0 = (path.length == 0 ? currency : path[0]);\\r\\n        if(ps.v != 0 || ps.r != 0 || ps.s != 0)\\r\\n            if(ps.allowed)\\r\\n                IPermitAllowed(token0).permit(sender, address(this), IPermitAllowed(token0).nonces(sender), ps.deadline, true, ps.v, ps.r, ps.s);\\r\\n            else\\r\\n                ERC20Permit(token0).permit(sender, address(this), amt, ps.deadline, ps.v, ps.r, ps.s);\\r\\n        IUniswapV2Router01 router = IUniswapV2Router01($C._swapRouter_.getA());\\r\\n        if(msg.value \\u003e 0 \\u0026\\u0026 token0 == router.WETH()) {\\r\\n            require(msg.value == amt, \\\"msg.value != amt\\\");\\r\\n            IWETH(token0).deposit{value: amt}();\\r\\n        } else\\r\\n            IERC20(token0).safeTransferFrom(sender, address(this), amt);\\r\\n        if(path.length \\u003c= 1)\\r\\n            return amt;\\r\\n        IERC20(path[0]).safeApprove_(address(router), amt);\\r\\n        uint[] memory amounts = router.swapExactTokensForTokens(amt, 0, path, address(this), now);\\r\\n        return amounts[path.length-1];\\r\\n    }\\r\\n*/    \\r\\n    function setSignatories(SocialFiStru storage $, address[] memory signatories) public {\\r\\n        for(uint i=0; i\\u003c$.signatories.length; i++)\\r\\n            $.isSignatory[$.signatories[i]] = false;\\r\\n            \\r\\n        $.signatories = signatories;\\r\\n        \\r\\n        for(uint i=0; i\\u003c$.signatories.length; i++)\\r\\n            $.isSignatory[$.signatories[i]] = true;\\r\\n            \\r\\n        emit SetSignatories(signatories);\\r\\n    }\\r\\n    event SetSignatories(address[] signatories);\\r\\n\\r\\n    //function setBuf(SocialFiStru storage $, uint112 supply, uint factor, uint p1) public {\\r\\n    //    //require(supply \\u003c= uint112(-1), \\\"buySupply OVERFLOW\\\");\\r\\n    //    if(supply == 0)\\r\\n    //        supply = $.buySupply;\\r\\n    //    if(factor == 0)\\r\\n    //        factor = Config.config()[$C._factorPrice_];\\r\\n    //    else\\r\\n    //        Config.config()[$C._factorPrice_] = factor;\\r\\n    //    if(p1 == 0)\\r\\n    //        p1 = SocialFi(uint160(address(this))).price1();\\r\\n    //    uint buffer = p1.mul(supply).div(factor);\\r\\n    //    require(buffer \\u003c= uint112(-1), \\\"buyBuffer OVERFLOW\\\");\\r\\n    //    ($.buySupply, $.buyBuffer, $.lastUpdateBuf) = (supply, uint112(buffer), uint32(now));\\r\\n    //    //Config.config()[$C._factorPrice_] = p1.mul($.buySupply).div(buf);\\r\\n    //}\\r\\n}\\r\\n\\r\\n\\r\\ninterface IPermitAllowed {\\r\\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    function nonces(address holder) external view returns (uint);\\r\\n}\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() payable external;\\r\\n    //function transfer(address to, uint value) external returns (bool);\\r\\n    //function withdraw(uint) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        payable\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"why\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"AirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"followers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tweets\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Twitter\",\"name\":\"twitter\",\"type\":\"tuple\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"}],\"name\":\"Authorize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"InfluenceClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"name\":\"ReferrerClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isCmpd\",\"type\":\"bool\"}],\"name\":\"SetCmpd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yield_\",\"type\":\"uint256\"}],\"name\":\"YieldPaid\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"VERIFY_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__SocialFi_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"why\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amts\",\"type\":\"uint256[]\"}],\"name\":\"airDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"u\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"u\",\"type\":\"uint256\"}],\"name\":\"calcBuyOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"followers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tweets\",\"type\":\"uint256\"}],\"internalType\":\"struct Twitter\",\"name\":\"twitter\",\"type\":\"tuple\"}],\"name\":\"calcInfluence\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"followers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tweets\",\"type\":\"uint256\"}],\"internalType\":\"struct Twitter\",\"name\":\"twitter\",\"type\":\"tuple\"}],\"name\":\"calcInfluenceClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"calcReferrerClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"calcSellOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"u\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPool_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"acct\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flatSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"}],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"tweetIds\",\"type\":\"bytes32[]\"}],\"name\":\"getRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"}],\"name\":\"getYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"tweetIds\",\"type\":\"bytes32[]\"}],\"name\":\"getYields\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"keys\",\"type\":\"bytes32[]\"}],\"name\":\"gets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"followers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tweets\",\"type\":\"uint256\"}],\"internalType\":\"struct Twitter\",\"name\":\"twitter\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature[]\",\"name\":\"signatures\",\"type\":\"tuple[]\"}],\"name\":\"influenceClaim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isCmpdOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"isInfluenceClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"lockedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"quota\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"q\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"}],\"name\":\"referrerClaim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"acct\",\"type\":\"address\"}],\"name\":\"roi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isCmpd\",\"type\":\"bool\"}],\"name\":\"setCmpd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"ex\",\"type\":\"address\"}],\"internalType\":\"struct Extendable.SigEx[]\",\"name\":\"s\",\"type\":\"tuple[]\"}],\"name\":\"setExtends_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"signatories\",\"type\":\"address[]\"}],\"name\":\"setSignatories_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"tax0\",\"type\":\"bool[]\"}],\"name\":\"setTax0List_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Sets.KeyValue[]\",\"name\":\"s\",\"type\":\"tuple[]\"}],\"name\":\"sets_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"unlockEndOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"unlockedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"followers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tweets\",\"type\":\"uint256\"}],\"internalType\":\"struct Twitter\",\"name\":\"twitter\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature[]\",\"name\":\"signatures\",\"type\":\"tuple[]\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"}],\"name\":\"woofEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tweetId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"acct\",\"type\":\"address\"}],\"name\":\"yielded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SocialFi", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "SocialFiLib:59db3fc26c51ce0a3a8a01c39d04e54d1f15b28b;IDelegateStaticCall:59db3fc26c51ce0a3a8a01c39d04e54d1f15b28b", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0xa4942b302c1546d169de04bf9893fb0a61a75b75", "SwarmSource": "ipfs://80baac73abde2f66d795e27c72b191bfb8d8e0141b7a6aaf7d6f8ca94db58fbe"}