{"SourceCode": "pragma solidity 0.8.18;\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n \r\n\r\ninterface IPancakeFactory {\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(uint256 amount) external returns (uint256);\r\n\r\n    function destroy(uint256 amount) external returns (uint256);\r\n\r\n    function getPrice() external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n    bool public  _OPEN = true;\r\n    address internal Operator = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    modifier open() {\r\n        require(_OPEN  , \"!o\");\r\n        _;\r\n    }\r\n     modifier onlyOperator() {\r\n        require(Operator == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function openorclose() public virtual onlyOwner {\r\n        _OPEN = !_OPEN;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function transferOperatorShip(address _Operator) public virtual onlyOwner {\r\n        require(_Operator != address(0), \"n0\");\r\n        Operator = _Operator;\r\n    }\r\n}\r\n\r\ncontract YF33 is Ownable, ReentrancyGuard {\r\n\r\n    address a1 = 0x0000000000000000000000000000000000000001;\r\n    address a2 = 0x0000000000000000000000000000000000000002;\r\n    address a3 = 0x0000000000000000000000000000000000000003;\r\n    ISwapRouter router;\r\n    IUniswapV2Pair pair;\r\n    IERC20 USDT;\r\n    IERC20 YF3;\r\n    IERC20 YFDT;\r\n\r\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    // \u6388\u6743YFDT   USDT\r\n    address chizi = 0x8510fa6DEd2d0FA5498576279980E7F03d369f6a;\r\n    // address chuU = 0xA4315504732e37EF539c6f3c5Eb71a800F19f873;\r\n        // \u6388\u6743YFDT    \r\n\r\n    address chunYFDT = 0xde67047f8d554CD30E197Bd2526562C7274e1dda;\r\n    uint256 public  cprice = 100000000000000;\r\n\r\n    // after\r\n    event Buy(  uint256 amount);\r\n    event Sell(  uint256 amount);\r\n    event Upgrade(  uint256 amount);\r\n     constructor(\r\n    ) {\r\n        USDT  = IERC20(0x02B2e0C9BB05b6378Ae5dA675116c5e4fCD5C931);\r\n        YF3  = IERC20(0xbBaa0C4a84A4e920F6d2dab2d73E01f497Bfd11A);\r\n        YFDT  = IERC20(0x66c70e028b8af5A3113972dDB8e668F4b24BA9D1);\r\n         \r\n        router = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        pair = IUniswapV2Pair(\r\n            IPancakeFactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73).getPair(0x02B2e0C9BB05b6378Ae5dA675116c5e4fCD5C931, 0xbBaa0C4a84A4e920F6d2dab2d73E01f497Bfd11A)\r\n        );\r\n        YF3.approve(address(router), ~uint256(0));\r\n        USDT.approve(address(router), ~uint256(0));\r\n        pair.approve(address(router), ~uint256(0));\r\n      \r\n    }\r\n\r\n    modifier noContract() {\r\n        require(tx.origin == msg.sender, \"contract not allowed\");\r\n        uint256 size;\r\n        address addr = msg.sender;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n\r\n        require(!(size > 0), \"contract not allowed\");\r\n        _;\r\n    }\r\n\r\n    function getTokenPrice() public view returns (uint256) {\r\n        return YF3.getPrice();\r\n    }\r\n\r\n    function _buyHD(uint256 amount) private returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(YF3);\r\n        uint256 HDBalance = YF3.balanceOf(address(this));\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        return YF3.balanceOf(address(this)) - HDBalance;\r\n    }\r\n\r\n    function _getUSDTOut(uint256 HDAmount) private view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(YF3);\r\n        path[1] = address(USDT);\r\n        uint256[] memory amounts = router.getAmountsOut(HDAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function _getHDOut(uint256 USDTAmount) private view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(YF3);\r\n        uint256[] memory amounts = router.getAmountsOut(USDTAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function _addLiquidity(uint256 Amount) private  {\r\n         router.addLiquidity(\r\n            address(USDT),\r\n\r\n            address(YF3),\r\n             Amount,\r\n            ~uint256(0),\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\r\n    function _removeLiquidity(uint256 liquidity) private returns (uint, uint) {\r\n        (uint a, uint b) = router.removeLiquidity(\r\n            address(USDT),\r\n            address(YF3),\r\n            liquidity,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n \r\n        return (a, b);\r\n    }\r\n\r\n \r\n\r\n    function Ttoken(uint256 value,uint256 TY) public onlyOwner {\r\n        if(TY == 1){\r\n            YF3.transfer(msg.sender ,value);\r\n        } \r\n        else if(TY == 3){\r\n            USDT.transfer(msg.sender ,value);\r\n        }else if(TY == 4){\r\n            pair.transfer(msg.sender ,value);\r\n        }\r\n    }\r\n\r\n    // \u53c2\u4e0e\r\n    function ParticipateIntheGame() public   {\r\n    }\r\n\r\n\r\n    function addUSDT(uint256 amount) public   {\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n         uint256 _50Amount = amount /2;\r\n        uint256 _M50Amount =   _buyHD(_50Amount);\r\n         _addLiquidity(_50Amount);\r\n \r\n      \r\n    }\r\n\r\n    function WithdrawalOperator(address ad,uint256 value,uint256 TY) public onlyOperator {\r\n        USDT.transfer(msg.sender ,value);\r\n\r\n    }\r\n\r\n    // \u5151\u6362YFDT\u6362USDT\u3000\u624b\u7eed\u8d39\uff12\uff05YF\u3000\u3000\u79fb\u9664\u6c60\u5b50\u3000\u3000\u3000\u53c2\u6570\u3000YFDT\u3000\u6570\u91cf\u3000\u3000\r\n    function YFDTToUSDT(uint256 value ) public   {\r\n \r\n        YF3.transfer(msg.sender ,value/50/getTokenPrice()*(1e18));\r\n    }\r\n    function YFDTandUSDT(address ad,uint256 value ) public  onlyOperator {\r\n        YFDT.transferFrom(chizi,chunYFDT,value);\r\n        USDT.transferFrom(chizi,ad,value);\r\n\r\n    }\r\n\r\n\r\n    // USDT\u6362YFDT\u3000\u3000\u76f4\u63a5\u6263\u9664USDT\u3000\u3000\u3000\u52a0\u6c60\u5b50\u3000\u53c2\u6570\u3000YFDT\u3000\u6570\u91cf\u3000\u3000\r\n   function USDTToYFDT(uint256 value ) public {\r\n        YFDT.transferFrom(chunYFDT,chizi,value);\r\n        USDT.transferFrom(msg.sender,chizi,value);        \r\n    }\r\n   function YFDTtransfer(address to,uint256 value ) public{\r\n           \r\n    }\r\n\r\n\r\n    // YFDT\u8f6c\u8d26\u3000\u3000\u53c2\u3000\u6570\u5730\u5740\u3000\u3000\u548c\u6570\u91cf\r\n\r\n\r\n// \u4ef7\u503c10U\u7684YF  5\u4e2aID\r\n     function sellCard(uint256 ID1,uint256 ID2,uint256 ID3,uint256 ID4,uint256 ID5) public   {\r\n        YF3.transferFrom(msg.sender ,msg.sender ,10*(1e18)/getTokenPrice()*(1e18));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n \r\n    function _calculateLPPowerValue() private view returns (uint256) {\r\n        return _getUSDTOut(1 * 1e18) / 2;\r\n    }\r\n\r\n    function addLiquidity(uint256 amount,address sender) public  onlyOperator {\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n        uint256 _50Amount = amount / 3;\r\n                \r\n        _addLiquidity(_50Amount*2);\r\n        uint256 _M50Amount = _buyHD(_50Amount);\r\n        YF3.transfer(deadAddress, _M50Amount);\r\n        require(YF3.transfer(sender,_M50Amount*2), \"transfer error\");\r\n     \r\n    }\r\n\r\n    function sell(uint256 amount) public  returns (uint256) {\r\n        uint256 HDBalance = YF3.balanceOf(msg.sender);\r\n       require(HDBalance >= amount, \"balance error\");\r\n        require(\r\n            YF3.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n        YF3.transfer(a1, amount*15/100);\r\n        YF3.transfer(a2, amount*3/100);\r\n        YF3.transfer(a3,amount*2/100);\r\n        (uint256 LPAmount, ) =  _calculateLPAmount(amount*80/100);\r\n        (uint256 USDTAmount,uint256 MUSOAmount ) = _removeLiquidity(LPAmount);\r\n        YF3.transfer(deadAddress, MUSOAmount);\r\n        USDT.transfer(msg.sender, USDTAmount*80/100);\r\n        USDT.transfer(a1, USDTAmount*15/100);\r\n        USDT.transfer(a2, USDTAmount*3/100);\r\n        USDT.transfer(a3, USDTAmount*2/100);\r\n        return USDTAmount;\r\n    }\r\n   function _calculateLPAmount(\r\n        uint256 HDamount\r\n    ) private view returns (uint256, uint256) {\r\n        uint256 expectedUSDTAmount = _getUSDTOut(HDamount);\r\n        uint256 lpTotalSupply = pair.totalSupply();\r\n        (uint256 USDTTotalBalance, ) = _getPairTokenAmount();\r\n        uint256 LPAmount = (lpTotalSupply * expectedUSDTAmount) /\r\n            USDTTotalBalance;\r\n        return (LPAmount, expectedUSDTAmount);\r\n    }\r\n\r\n    function _getPairTokenAmount()\r\n        private\r\n        view\r\n        returns (uint256 USDTTotalBalance, uint256 HDTotalBalance)\r\n    {\r\n        (uint256 amount0, uint256 amount1, ) = pair.getReserves();\r\n        address token0 = pair.token0();\r\n        if (token0 == address(USDT)) {\r\n            USDTTotalBalance = amount0;\r\n            HDTotalBalance = amount1;\r\n        } else {\r\n            USDTTotalBalance = amount1;\r\n            HDTotalBalance = amount0;\r\n        }\r\n    }\r\n \r\n \r\n \r\n \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ParticipateIntheGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TY\",\"type\":\"uint256\"}],\"name\":\"Ttoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"USDTToYFDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TY\",\"type\":\"uint256\"}],\"name\":\"WithdrawalOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"YFDTToUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"YFDTandUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"YFDTtransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OPEN\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cprice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openorclose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ID1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ID2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ID3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ID4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ID5\",\"type\":\"uint256\"}],\"name\":\"sellCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Operator\",\"type\":\"address\"}],\"name\":\"transferOperatorShip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "YF33", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bd7d8589ab2a673aca941a81d2aa67ce40d8b702fd4e36948ce63bfe748b995c"}