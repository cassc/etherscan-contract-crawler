{"SourceCode": "{\"Auth.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nabstract contract Auth {\\n    address internal owner;\\n    mapping (address =\\u003e bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be contract owner\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"!OWNER\\\"); _;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be authorized\\n     */\\n    modifier authorized() {\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\"); _;\\n    }\\n\\n    /**\\n     * Authorize address. Owner only\\n     */\\n    function authorize(address adr) public onlyOwner {\\n        authorizations[adr] = true;\\n    }\\n\\n    /**\\n     * Remove address\\u0027 authorization. Owner only\\n     */\\n    function unauthorize(address adr) public onlyOwner {\\n        authorizations[adr] = false;\\n    }\\n\\n    /**\\n     * Check if address is owner\\n     */\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    /**\\n     * Return address\\u0027 authorization status\\n     */\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    /**\\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\\n     */\\n    function transferOwnership(address payable adr) public onlyOwner {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\"},\"Hibiki.sol\":{\"content\":\"/**\\n * \u97ff\\n * \u3072\u3073\u304d\\n * /\u00e7ib\u02b2ik\u02b2i/\\n * \\n * The sound of money in your pocket. The echoes of the cries of those who didn\\u0027t buy. The reverberation of the rocket going to the moon.\\n *\\n * Multichain tools and blockchain games.\\n * https://hibiki.finance https://t.me/hibikifinance \\n */\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./Auth.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./IDexRouter.sol\\\";\\nimport \\\"./IDexFactory.sol\\\";\\n\\ncontract Hibiki is IBEP20, Auth {\\n\\n\\taddress DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\n\\n\\tstring constant _name = \\\"Hibiki.finance\\\";\\n    string constant _symbol = \\\"HIBIKI\\\";\\n    uint8 constant _decimals = 18;\\n\\n    uint256 _totalSupply = 10_000_000 * (10 ** _decimals);\\n    uint256 public _maxTxAmount = _totalSupply / 100;\\n\\tuint256 public _maxWalletAmount = _totalSupply / 100;\\n\\n\\tmapping (address =\\u003e uint256) _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) _allowances;\\n    mapping (address =\\u003e bool) isFeeExempt;\\n    mapping (address =\\u003e bool) isTxLimitExempt;\\n\\n\\t// Fees. Some may be completely inactive at all times.\\n\\tuint256 liquidityFee = 30;\\n    uint256 burnFee = 0;\\n\\tuint256 stakingFee = 20;\\n\\tuint256 nftStakingFee = 0;\\n    uint256 feeDenominator = 1000;\\n\\tbool public feeOnNonTrade = false;\\n\\n\\tuint256 public stakingPrizePool = 0;\\n\\tbool public stakingRewardsActive = false;\\n\\taddress public stakingRewardsContract;\\n\\tuint256 public nftStakingPrizePool = 0;\\n\\tbool public nftStakingRewardsActive = false;\\n\\taddress public nftStakingRewardsContract;\\n\\n\\taddress public autoLiquidityReceiver;\\n\\n\\tIDexRouter public router;\\n    address pcs2BNBPair;\\n    address[] public pairs;\\n\\n\\tbool public swapEnabled = true;\\n    uint256 public swapThreshold = _totalSupply / 20000;\\n    bool inSwap;\\n    modifier swapping() {\\n\\t\\tinSwap = true;\\n\\t\\t_;\\n\\t\\tinSwap = false;\\n\\t}\\n\\n\\tuint256 public launchedAt = 0;\\n\\tuint256 private antiSniperBlocks = 3;\\n\\tuint256 private antiSniperGasLimit = 30 gwei;\\n\\tbool private gasLimitActive = true;\\n\\n\\tevent AutoLiquifyEnabled(bool enabledOrNot);\\n\\tevent AutoLiquify(uint256 amountBNB, uint256 autoBuybackAmount);\\n\\tevent StakingRewards(bool activate);\\n\\tevent NFTStakingRewards(bool active);\\n\\n\\tconstructor() Auth(msg.sender) {\\n\\t\\t//router = IDexRouter(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);\\n\\t\\trouter = IDexRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        pcs2BNBPair = IDexFactory(router.factory()).createPair(router.WETH(), address(this));\\n        _allowances[address(this)][address(router)] = type(uint256).max;\\n\\n\\t\\tisFeeExempt[msg.sender] = true;\\n        isFeeExempt[address(this)] = true;\\n\\t\\tisTxLimitExempt[msg.sender] = true;\\n\\t\\tisTxLimitExempt[address(this)] = true;\\n        isTxLimitExempt[DEAD] = true;\\n        isTxLimitExempt[ZERO] = true;\\n\\n\\t\\tautoLiquidityReceiver = msg.sender;\\n\\t\\tpairs.push(pcs2BNBPair);\\n\\t\\t_balances[msg.sender] = _totalSupply;\\n\\t\\temit Transfer(address(0), msg.sender, _totalSupply);\\n\\t}\\n\\n\\treceive() external payable {}\\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\\n    function decimals() external pure override returns (uint8) { return _decimals; }\\n    function symbol() external pure override returns (string memory) { return _symbol; }\\n    function name() external pure override returns (string memory) { return _name; }\\n    function getOwner() external view override returns (address) { return owner; }\\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, type(uint256).max);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        return _transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n\\tfunction transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\\n\\t\\t\\trequire(_allowances[sender][msg.sender] \\u003e= amount, \\\"Insufficient Allowance\\\");\\n            _allowances[sender][msg.sender] -= amount;\\n        }\\n\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n\\tfunction _isStakingReward(address sender, address recipient) internal view returns (bool) {\\n\\t\\treturn sender == stakingRewardsContract\\n\\t\\t\\t|| sender == nftStakingRewardsContract\\n\\t\\t\\t|| recipient == stakingRewardsContract\\n\\t\\t\\t|| recipient == nftStakingRewardsContract;\\n\\t}\\n\\n\\tfunction _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\\n\\t\\trequire(amount \\u003e 0);\\n        if (inSwap || _isStakingReward(sender, recipient)) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        checkTxLimit(sender, recipient, amount);\\n\\n        if (shouldSwapBack()) {\\n            liquify();\\n        }\\n\\n        if (!launched() \\u0026\\u0026 recipient == pcs2BNBPair) {\\n            require(_balances[sender] \\u003e 0);\\n            require(sender == owner, \\\"Only the owner can be the first to add liquidity.\\\");\\n            launch();\\n        }\\n\\n\\t\\trequire(amount \\u003c= _balances[sender], \\\"Insufficient Balance\\\");\\n        _balances[sender] -= amount;\\n\\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, amount) : amount;\\n        _balances[recipient] += amountReceived;\\n\\n\\t\\t// Update staking pool, if active.\\n\\t\\t// Update of the pool can be deactivated for launch and staking contract migration.\\n\\t\\tif (stakingRewardsActive) {\\n\\t\\t\\tsendToStakingPool();\\n\\t\\t}\\n\\t\\tif (nftStakingRewardsActive) {\\n\\t\\t\\tsendToNftStakingPool();\\n\\t\\t}\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n\\n\\tfunction _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n\\t\\trequire(amount \\u003c= _balances[sender], \\\"Insufficient Balance\\\");\\n        _balances[sender] -= amount;\\n        _balances[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n\\tfunction checkTxLimit(address sender, address recipient, uint256 amount) internal view {\\n        require(amount \\u003c= _maxTxAmount || isTxLimitExempt[sender] || isTxLimitExempt[recipient] \\u0026\\u0026 sender == pcs2BNBPair, \\\"TX Limit Exceeded\\\");\\n\\t\\t// Max wallet check.\\n\\t\\tif (sender != owner\\n            \\u0026\\u0026 recipient != owner\\n            \\u0026\\u0026 !isTxLimitExempt[recipient]\\n            \\u0026\\u0026 recipient != ZERO \\n            \\u0026\\u0026 recipient != DEAD \\n            \\u0026\\u0026 recipient != pcs2BNBPair \\n            \\u0026\\u0026 recipient != address(this)\\n        ) {\\n            uint256 newBalance = balanceOf(recipient) + amount;\\n            require(newBalance \\u003c= _maxWalletAmount, \\\"Exceeds max wallet.\\\");\\n        }\\n    }\\n\\n\\t// Decides whether this trade should take a fee.\\n\\t// Trades with pairs are always taxed, unless sender or receiver is exempted.\\n\\t// Non trades, like wallet to wallet, are configured, untaxed by default.\\n\\tfunction shouldTakeFee(address sender, address recipient) internal view returns (bool) {\\n        if (isFeeExempt[sender] || isFeeExempt[recipient] || !launched()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n        address[] memory liqPairs = pairs;\\n        for (uint256 i = 0; i \\u003c liqPairs.length; i++) {\\n            if (sender == liqPairs[i] || recipient == liqPairs[i]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n        }\\n\\n        return feeOnNonTrade;\\n    }\\n\\n\\tfunction setAntisniperBlocks(uint256 blocks) external authorized {\\n\\t\\tantiSniperBlocks = blocks;\\n\\t}\\n\\n\\tfunction setAntisniperGas(bool active, uint256 quantity) external authorized {\\n\\t\\trequire(!active || quantity \\u003e= 1 gwei, \\\"Needs to be at least 1 gwei.\\\");\\n\\t\\tgasLimitActive = active;\\n\\t\\tantiSniperGasLimit = quantity;\\n\\t}\\n\\n\\tfunction takeFee(address sender, uint256 amount) internal returns (uint256) {\\n\\t\\tif (!launched()) {\\n\\t\\t\\treturn amount;\\n\\t\\t}\\n\\t\\tuint256 liqFee = 0;\\n\\t\\tuint256 bf = 0;\\n\\t\\tuint256 steak = 0;\\n\\t\\tuint256 nftStake = 0;\\n\\t\\tif (block.number - launchedAt \\u003c= antiSniperBlocks || gasLimitActive \\u0026\\u0026 tx.gasprice \\u003e= antiSniperGasLimit) {\\n\\t\\t\\tliqFee = amount * feeDenominator - 1 / feeDenominator;\\n            _balances[address(this)] += liqFee;\\n\\t\\t\\tamount -= liqFee;\\n\\t\\t\\temit Transfer(sender, address(this), liqFee);\\n        } else {\\n\\t\\t\\t// If there is a liquidity tax active for autoliq, the contract keeps it.\\n\\t\\t\\tif (liquidityFee \\u003e 0) {\\n\\t\\t\\t\\tliqFee = amount * liquidityFee / feeDenominator;\\n\\t\\t\\t\\t_balances[address(this)] += liqFee;\\n\\t\\t\\t\\temit Transfer(sender, address(this), liqFee);\\n\\t\\t\\t}\\n\\t\\t\\t// If there is an active burn fee, burn a percentage and give it to dead address.\\n\\t\\t\\tif (burnFee \\u003e 0) {\\n\\t\\t\\t\\tbf = amount * burnFee / feeDenominator;\\n\\t\\t\\t\\t_balances[DEAD] += bf;\\n\\t\\t\\t\\temit Transfer(sender, DEAD, bf);\\n\\t\\t\\t}\\n\\t\\t\\t// If staking tax is active, it is stored on ZERO address.\\n\\t\\t\\t// If staking payout itself is active, it is later moved from ZERO to the appropriate staking address.\\n\\t\\t\\tif (stakingFee \\u003e 0) {\\n\\t\\t\\t\\tsteak = amount * stakingFee / feeDenominator;\\n\\t\\t\\t\\t_balances[ZERO] += steak;\\n\\t\\t\\t\\tstakingPrizePool += steak;\\n\\t\\t\\t\\temit Transfer(sender, ZERO, steak);\\n\\t\\t\\t}\\n\\t\\t\\tif (nftStakingFee \\u003e 0) {\\n\\t\\t\\t\\tnftStake = amount * nftStakingFee / feeDenominator;\\n\\t\\t\\t\\t_balances[ZERO] += nftStake;\\n\\t\\t\\t\\tnftStakingPrizePool += nftStake;\\n\\t\\t\\t\\temit Transfer(sender, ZERO, nftStake);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        return amount - liqFee - bf - steak - nftStake;\\n    }\\n\\n\\tfunction sendToStakingPool() internal {\\n\\t\\t_balances[ZERO] -= stakingPrizePool;\\n\\t\\t_balances[stakingRewardsContract] += stakingPrizePool;\\n\\t\\temit Transfer(ZERO, stakingRewardsContract, stakingPrizePool);\\n\\t\\tstakingPrizePool = 0;\\n\\t}\\n\\n\\tfunction sendToNftStakingPool() internal {\\n\\t\\t_balances[ZERO] -= nftStakingPrizePool;\\n\\t\\t_balances[nftStakingRewardsContract] += nftStakingPrizePool;\\n\\t\\temit Transfer(ZERO, nftStakingRewardsContract, nftStakingPrizePool);\\n\\t\\tnftStakingPrizePool = 0;\\n\\t}\\n\\n\\tfunction setStakingRewardsAddress(address addy) external authorized {\\n\\t\\tstakingRewardsContract = addy;\\n\\t\\tisFeeExempt[addy] = true;\\n\\t\\tisTxLimitExempt[addy] = true;\\n\\t}\\n\\n\\tfunction setNftStakingRewardsAddress(address addy) external authorized {\\n\\t\\tnftStakingRewardsContract = addy;\\n\\t\\tisFeeExempt[addy] = true;\\n\\t\\tisTxLimitExempt[addy] = true;\\n\\t}\\n\\n    function shouldSwapBack() internal view returns (bool) {\\n        return launched()\\n\\t\\t\\t\\u0026\\u0026 msg.sender != pcs2BNBPair\\n            \\u0026\\u0026 !inSwap\\n            \\u0026\\u0026 swapEnabled\\n            \\u0026\\u0026 _balances[address(this)] \\u003e= swapThreshold;\\n    }\\n\\n\\tfunction setSwapEnabled(bool set) external authorized {\\n\\t\\tswapEnabled = set;\\n\\t\\temit AutoLiquifyEnabled(set);\\n\\t}\\n\\n\\tfunction liquify() internal swapping {\\n        uint256 amountToLiquify = swapThreshold / 2;\\n\\t\\tuint256 balanceBefore = address(this).balance;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH();\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToLiquify,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 amountBNB = address(this).balance - balanceBefore;\\n        uint256 amountBNBLiquidity = amountBNB / 2;\\n\\n\\t\\trouter.addLiquidityETH{value: amountBNBLiquidity}(\\n\\t\\t\\taddress(this),\\n\\t\\t\\tamountToLiquify,\\n\\t\\t\\t0,\\n\\t\\t\\t0,\\n\\t\\t\\tautoLiquidityReceiver,\\n\\t\\t\\tblock.timestamp\\n\\t\\t);\\n\\t\\temit AutoLiquify(amountBNBLiquidity, amountToLiquify);\\n    }\\n\\n\\tfunction launched() internal view returns (bool) {\\n        return launchedAt != 0;\\n    }\\n\\n    function launch() internal {\\n        launchedAt = block.number;\\n    }\\n\\n\\tfunction setTxLimit(uint256 amount) external authorized {\\n        require(amount \\u003e= _totalSupply / 1000);\\n        _maxTxAmount = amount;\\n    }\\n\\n\\tfunction setMaxWallet(uint256 amount) external authorized {\\n\\t\\trequire(amount \\u003e= _totalSupply / 1000);\\n\\t\\t_maxWalletAmount = amount;\\n\\t}\\n\\n    function setIsFeeExempt(address holder, bool exempt) external authorized {\\n        isFeeExempt[holder] = exempt;\\n    }\\n\\n    function setIsTxLimitExempt(address holder, bool exempt) external authorized {\\n        isTxLimitExempt[holder] = exempt;\\n    }\\n\\n    function setFees(uint256 _liquidityFee, uint256 _burnFee, uint256 _stakingFee, uint256 _nftStakingFee, uint256 _feeDenominator) external authorized {\\n        liquidityFee = _liquidityFee;\\n        burnFee = _burnFee;\\n\\t\\tstakingFee = _stakingFee;\\n\\t\\tnftStakingFee = _nftStakingFee;\\n        feeDenominator = _feeDenominator;\\n\\t\\tuint256 totalFee = _liquidityFee + _burnFee + _stakingFee + _nftStakingFee;\\n        require(totalFee \\u003c feeDenominator / 5, \\\"Maximum allowed taxation on this contract is 20%.\\\");\\n    }\\n\\n    function setLiquidityReceiver(address _autoLiquidityReceiver) external authorized {\\n        autoLiquidityReceiver = _autoLiquidityReceiver;\\n    }\\n\\n\\tfunction getCirculatingSupply() public view returns (uint256) {\\n        return _totalSupply - balanceOf(DEAD) - balanceOf(ZERO) + stakingPrizePool + nftStakingPrizePool;\\n    }\\n\\n\\t// Recover any BNB sent to the contract by mistake.\\n\\tfunction rescue() external {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n\\tfunction setStakingRewardsActive(bool active) external authorized {\\n\\t\\tstakingRewardsActive = active;\\n\\t\\temit StakingRewards(active);\\n\\t}\\n\\n\\tfunction setNftStakingRewardsActive(bool active) external authorized {\\n\\t\\tnftStakingRewardsActive = active;\\n\\t\\temit NFTStakingRewards(active);\\n\\t}\\n\\n\\tfunction addPair(address pair) external authorized {\\n        pairs.push(pair);\\n    }\\n    \\n    function removeLastPair() external authorized {\\n        pairs.pop();\\n    }\\n}\\n\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface IBEP20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n  * @dev Returns the token name.\\n  */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view returns (address);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IDexFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface IDexFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"},\"IDexRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface IDexRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"},\"IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"autoBuybackAmount\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabledOrNot\",\"type\":\"bool\"}],\"name\":\"AutoLiquifyEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"NFTStakingRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"activate\",\"type\":\"bool\"}],\"name\":\"StakingRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"addPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOnNonTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftStakingPrizePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftStakingRewardsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftStakingRewardsContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLastPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"setAntisniperBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"setAntisniperGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftStakingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDenominator\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"}],\"name\":\"setLiquidityReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setNftStakingRewardsActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setNftStakingRewardsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setStakingRewardsActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setStakingRewardsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPrizePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardsContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Hibiki", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://96758b65d5df3443df72b6a0eacc78a59c36738d8be665398eb6c644618bcf38"}