{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: stake.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ncontract HydraStaking is Ownable {\r\n    // struct to save the stake detail\r\n    struct StakeRecord {\r\n        uint256 packageId;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 unstakeTime;\r\n        uint256 amount;\r\n        uint256 rate;\r\n        bool claimed;\r\n    }\r\n\r\n    // struct to save the staking package\r\n    struct Package {\r\n        uint256 rate;\r\n        uint256 duration;\r\n        uint256 amountRequired;\r\n    }\r\n\r\n    // mappings to save staked records, staking packages\r\n    mapping(address => StakeRecord[]) staked; \r\n    Package[] StakingPackages;\r\n\r\n    // total token staked\r\n    mapping(address => uint256) public totalAmountStaked;\r\n\r\n    // total token in staking now\r\n    mapping(address => uint256) public totalAmountStaking;\r\n\r\n    // main token address\r\n    address public tokenAddress;\r\n    IERC20 tokenContract;\r\n\r\n    /**\r\n     * @dev Initialize\r\n     * @notice This is the initialize function, run on deploy event\r\n     * @param _tokenAddr    address of main token\r\n    */\r\n    constructor(address _tokenAddr) {\r\n        tokenAddress = _tokenAddr;\r\n        tokenContract = IERC20(tokenAddress);\r\n        \r\n        // add free-time staking package\r\n        Package memory pk;\r\n        pk.rate = 2739; //Package 0 will be 10% APR => 0.02739% per day\r\n        pk.duration = 60*60*24;\r\n        StakingPackages.push(pk);\r\n    }\r\n\r\n    /**\r\n     * @dev Add new staking package\r\n     * @notice New package will be pushed to the end of StakingPackages\r\n     * @param _durationDay  duration in day unit\r\n     * @param _rate         rate per ten million per day, 10.000.000 will be 100% per day\r\n    */\r\n    function addStakingPackage(uint256 _durationDay, uint256 _rate, uint256 _amountRequired) public onlyOwner {\r\n        require(_rate > 0, 'Rate have to larger than zero');\r\n        require(_durationDay > 0, 'Duration have to equal or higher than 1');\r\n        Package memory pk;\r\n        pk.rate = _rate;\r\n        pk.duration = _durationDay * 60*60*24;\r\n        pk.amountRequired = _amountRequired;\r\n        StakingPackages.push(pk);\r\n    }\r\n\r\n    /**\r\n     * @dev Update a staking package\r\n     * @param _packageId    specific package ID to update\r\n     * @param _newDuration  new duration in day unit\r\n     * @param _newRate      new rate per Million per day\r\n    */\r\n    function updateStakingPackage(uint256 _packageId, uint256 _newDuration, uint256 _newRate) public onlyOwner {\r\n        require(StakingPackages[_packageId].rate > 0, 'Invalid package ID');\r\n        StakingPackages[_packageId].rate = _newRate;\r\n        StakingPackages[_packageId].duration = _newDuration * 60*60*24;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove staking package\r\n     * @notice Package rate will be set to 0\r\n     * @param _packageId    package ID to remove\r\n    */\r\n    function removeStakingPackage(uint256 _packageId) public onlyOwner {\r\n        require(StakingPackages[_packageId].rate > 0, 'Invalid package ID');\r\n        StakingPackages[_packageId].rate = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Get staking package information\r\n     * @param _packageId    package ID to get information\r\n    */\r\n    function getStakePackageInfo(uint256 _packageId) public view returns(uint256 _rate, uint256 _duration, uint256 _amountRequired) {\r\n        require(StakingPackages[_packageId].rate > 0, \"Invalid package ID\");\r\n        return (StakingPackages[_packageId].rate, StakingPackages[_packageId].duration, StakingPackages[_packageId].amountRequired);\r\n    }\r\n\r\n    /**\r\n     * @dev Start staking\r\n     * @notice Users have to approve main token to this contract before start staking\r\n     * @param _amount       amount of token to stake\r\n     * @param _packageId    package ID to stake\r\n    */\r\n    function stake(uint256 _amount, uint256 _packageId) public {\r\n        // validate available package and approved amount\r\n        require(StakingPackages[_packageId].rate > 0, \"Invalid package\");\r\n        require(StakingPackages[_packageId].amountRequired <= _amount, \"Insufficient amount\");\r\n        require(tokenContract.allowance(msg.sender, address(this)) >= _amount, \"Insufficient balance\");\r\n        // transfer token to this staking contract\r\n        tokenContract.transferFrom(msg.sender, address(this), _amount);\r\n\r\n        // prepare new staking record\r\n        StakeRecord memory sr;\r\n        sr.packageId = _packageId;\r\n        sr.startTime = uint256(block.timestamp);\r\n\r\n        // set the withdraw time based on package type\r\n        if (_packageId == 0) {\r\n            // free-time staking package\r\n            sr.endTime = sr.startTime;\r\n        } else {\r\n            // fixed-time staking packages\r\n            sr.endTime = sr.startTime + StakingPackages[_packageId].duration;\r\n        }\r\n\r\n        sr.amount = _amount;\r\n        sr.rate = StakingPackages[_packageId].rate;\r\n        totalAmountStaked[msg.sender] += _amount;\r\n        totalAmountStaking[msg.sender] += _amount;\r\n        // save staking record\r\n        staked[msg.sender].push(sr);\r\n    }\r\n\r\n    /**\r\n     * @dev Get stake record count of an address\r\n     * @notice With finished records\r\n     * @param _owner    address to check\r\n    */\r\n    function stakeCount(address _owner) public view returns (uint256) {\r\n        return staked[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Get stake info of caller\r\n     * @notice with specific stake ID\r\n     * @param _stakeId  stake id to check\r\n    */\r\n    function getStakeInfo(uint256 _stakeId) public view returns (uint256 _packageId, uint256 startTime, uint256 endTime, uint256 unstakeTime, uint256 amount, uint256 rate, bool claimed) {\r\n        // validate available staking ID\r\n        require(staked[msg.sender][_stakeId].amount > 0, \"Invalid stakeId\");\r\n        StakeRecord memory sr = staked[msg.sender][_stakeId];\r\n        return (sr.packageId, sr.startTime, sr.endTime, sr.unstakeTime, sr.amount, sr.rate, sr.claimed);\r\n    }\r\n\r\n    /**\r\n     * @dev Get staking package count\r\n     * @notice With removed package\r\n    */\r\n    function packageCount() public view returns (uint256) {\r\n        return StakingPackages.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate only staking reward with stake amount and package ID\r\n     * @notice Free-time package will be calculated with 1 day\r\n     * @param _packageId    package ID to calculate\r\n     * @param _amount       staking amount to calculate\r\n    */\r\n    function calcReward(uint256 _packageId, uint256 _amount) public view returns(uint256 _reward) {\r\n        // validate available package ID\r\n        require(StakingPackages[_packageId].rate > 0, \"Invalid package ID\");\r\n\r\n        // calculare and return\r\n        uint256 stakeRate = StakingPackages[_packageId].rate;\r\n        uint256 duration = StakingPackages[_packageId].duration / (60*60*24);\r\n        return _amount * duration * stakeRate / 10000000;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate caller reward\r\n     * @notice With specific staking ID\r\n     * @param _stakeId  staking ID to calculate\r\n    */\r\n    function calcMyReward(uint256 _stakeId) public view returns(uint256 _reward) {\r\n        // validate available staking ID\r\n        require(staked[msg.sender][_stakeId].amount > 0, \"Invalid stakeId\");\r\n\r\n        // retrieve staking infor & package info\r\n        uint256 stakeAmount = staked[msg.sender][_stakeId].amount;\r\n        uint256 stakeRate = staked[msg.sender][_stakeId].rate;\r\n        uint256 startTime = staked[msg.sender][_stakeId].startTime;\r\n        uint256 endTime = staked[msg.sender][_stakeId].endTime;\r\n        uint256 duration = endTime - startTime;\r\n\r\n        // check if staking in package 0 is finished\r\n        if(staked[msg.sender][_stakeId].packageId == 0){\r\n            duration = block.timestamp - startTime;\r\n            if(endTime != startTime){\r\n                duration = endTime - startTime;\r\n            }\r\n        }\r\n\r\n        if(staked[msg.sender][_stakeId].packageId != 0 && block.timestamp < endTime){\r\n            duration = block.timestamp - startTime;\r\n        }\r\n\r\n        // calculate and return\r\n        return stakeAmount * duration * stakeRate / (60*60*24) / 10000000;\r\n    }\r\n\r\n    function unlockToken(uint256 _stakeId) public {\r\n        // validate staking infor\r\n        require(staked[msg.sender][_stakeId].amount > 0, \"Invalid stakeId\");\r\n        require(staked[msg.sender][_stakeId].claimed == false, \"Claimed\");\r\n        require(staked[msg.sender][_stakeId].packageId == 0 || staked[msg.sender][_stakeId].endTime > block.timestamp, \"token can't unlock\");\r\n        \r\n        //Set endTime = now and modify rate to flexible pacakge\r\n        staked[msg.sender][_stakeId].endTime = block.timestamp;\r\n        staked[msg.sender][_stakeId].rate = StakingPackages[0].rate;\r\n    }\r\n\r\n    /**\r\n     * @dev Unstake\r\n     * @notice With staking ID\r\n     * @param _stakeId  staking ID to unstake\r\n    */\r\n    function unstake(uint256 _stakeId) public {\r\n        // validate staking infor\r\n        require(staked[msg.sender][_stakeId].amount > 0, \"Invalid stakeId\");\r\n        require(staked[msg.sender][_stakeId].claimed == false, \"Claimed\");\r\n\r\n        // retrieve staking info\r\n        uint256 stakeAmount = staked[msg.sender][_stakeId].amount;\r\n        uint256 claimAmount = stakeAmount;\r\n        uint256 packageId = staked[msg.sender][_stakeId].packageId;\r\n        // check whether package is free-time or fixed-time\r\n        if (packageId == 0) {\r\n            // free-time package\r\n            // check stake unlocked\r\n            require(staked[msg.sender][_stakeId].endTime + 2*60*60*24 <= block.timestamp, \"Not available to unstake\");\r\n            // calculate with duration\r\n            claimAmount = stakeAmount + calcMyReward(_stakeId);\r\n        } else {\r\n            Package memory pkg = StakingPackages[packageId];\r\n            //check if user withdraw before time end\r\n            if(staked[msg.sender][_stakeId].endTime - staked[msg.sender][_stakeId].startTime < pkg.duration){\r\n                require(staked[msg.sender][_stakeId].endTime + 2*60*60*24 <= block.timestamp, \"Not available to unstake\");\r\n            } else {\r\n                require(staked[msg.sender][_stakeId].endTime <= block.timestamp, \"token is locked\");\r\n            }\r\n            claimAmount = stakeAmount + calcMyReward(_stakeId);\r\n        }\r\n\r\n        // transfer main token to claimer\r\n        tokenContract.transfer(msg.sender, claimAmount);\r\n        staked[msg.sender][_stakeId].unstakeTime = block.timestamp;\r\n        totalAmountStaking[msg.sender] -= stakeAmount;\r\n        // remove staking record\r\n        staked[msg.sender][_stakeId].claimed = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency withdraw main token to contract owner\r\n     * @notice Only owner can call this function\r\n    */\r\n    function emergencyWithdraw() public onlyOwner{\r\n        uint256 myBalance = tokenContract.balanceOf(address(this));\r\n        tokenContract.transfer(owner(), myBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev get balance stake of user \r\n     * @param addressUser  get balance staking off adddress\r\n     */\r\n    function getTotalAmountStaked(address addressUser) external view returns(uint256){\r\n        return totalAmountStaking[addressUser];\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_durationDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountRequired\",\"type\":\"uint256\"}],\"name\":\"addStakingPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"calcMyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calcReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageId\",\"type\":\"uint256\"}],\"name\":\"getStakePackageInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountRequired\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressUser\",\"type\":\"address\"}],\"name\":\"getTotalAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"packageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageId\",\"type\":\"uint256\"}],\"name\":\"removeStakingPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_packageId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalAmountStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"unlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"updateStakingPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HydraStaking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008cd0d76c0ad377378ab6ce878a7be686223497ee", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e04612d32ca4008aebf428e685dc9af64021c2c115e7e8089396c7e607880eab"}