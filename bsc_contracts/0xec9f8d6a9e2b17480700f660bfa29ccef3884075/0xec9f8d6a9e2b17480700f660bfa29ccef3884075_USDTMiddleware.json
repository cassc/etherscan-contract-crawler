{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the air of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `++` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function air(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"USDTMiddleware.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract USDTMiddleware is Ownable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    address private _usdt;\\r\\n    address private _ucToken;\\r\\n    address private _cxToken;\\r\\n    uint256 private usdtTotalQuota; \\r\\n    uint256 private cxTotalQuota; \\r\\n    address private constant blackholeAddress = 0x0000000000000000000000000000000000000001;\\r\\n    constructor (\\r\\n        address UsdtAddress,\\r\\n        address UcAddress,\\r\\n        address CxAddress\\r\\n    ){\\r\\n        _usdt = UsdtAddress;\\r\\n        _ucToken = UcAddress;\\r\\n        _cxToken = CxAddress;\\r\\n        usdtTotalQuota = 0;\\r\\n        cxTotalQuota = 0;\\r\\n    }\\r\\n\\r\\n    function payForTicket(address from , uint256 ucAmount) external  \\r\\n    { \\r\\n        require(ucAmount \\u003e 0, \\\"BEP20: transfer ucAmount equal zero\\\");\\r\\n        IERC20 UCToken = IERC20(_ucToken);\\r\\n        require(UCToken.balanceOf(from) \\u003e= ucAmount, \\\"BEP20: ucamount not enough\\\");\\r\\n        UCToken.transferFrom(from, address(this), ucAmount);\\r\\n    }\\r\\n\\r\\n    function autoSysRepo(\\r\\n        address ucReceiver,\\r\\n        uint256 ucAmount,\\r\\n        address[] calldata tokenReceivers,\\r\\n        uint256[] calldata tokenAmounts\\r\\n        ) external onlyOwner {\\r\\n            require(ucAmount \\u003e 0, \\\"BEP20: transfer amount equal zero\\\");\\r\\n            require(tokenReceivers.length == tokenAmounts.length,\\\"BEP20: Mismatch between Address and value\\\");\\r\\n            IERC20 UCToken = IERC20(_ucToken);\\r\\n            IERC20 CXToken = IERC20(_cxToken);\\r\\n            UCToken.transfer(ucReceiver, ucAmount);\\r\\n            for(uint i = 0; i \\u003c tokenReceivers.length; i++){\\r\\n                CXToken.transfer(tokenReceivers[i], tokenAmounts[i]);\\r\\n                }\\r\\n    }\\r\\n    \\r\\n    function getUCBalance(address from) public view returns (uint256) \\r\\n    {\\r\\n        return IERC20(_ucToken).balanceOf(from);\\r\\n    }\\r\\n\\r\\n    function getCXBalance(address from) external view returns (uint256) \\r\\n    {\\r\\n        return IERC20(_cxToken).balanceOf(from);\\r\\n    }\\r\\n\\r\\n    function getTotalMarket() external view returns (uint256) \\r\\n    {\\r\\n        uint256 newprice = getCXtoUSDTLastPrice();\\r\\n        uint256 total= IERC20(_cxToken).totalSupply();\\r\\n        return newprice.mul(total).div(10**18);\\r\\n    }\\r\\n\\r\\n    function getUSDTBalance(address from) external view returns (uint256) {\\r\\n        return IERC20(_usdt).balanceOf(from);\\r\\n    }\\r\\n\\r\\n    function getUSDTtoCXLastPrice() public view returns (uint256)\\r\\n    {\\r\\n        uint256 CXAmonunt = IERC20(_cxToken).balanceOf(address(this));\\r\\n        uint256 USDT = IERC20(_usdt).balanceOf(address(this));\\r\\n        CXAmonunt = CXAmonunt * 10**18;\\r\\n        return CXAmonunt.div(USDT);\\r\\n    }\\r\\n\\r\\n    function getCXtoUSDTLastPrice() public  view returns (uint256)\\r\\n    {  \\r\\n        uint256 CXAmonunt = IERC20(_cxToken).balanceOf(address(this));\\r\\n        uint256 USDT = IERC20(_usdt).balanceOf(address(this));\\r\\n        USDT = USDT * 10**18;\\r\\n        return USDT.div(CXAmonunt);\\r\\n    }\\r\\n\\r\\n    function securityDeposit(address from ,uint256 usdtAmount) external  \\r\\n    {\\r\\n        IERC20 USDT = IERC20(_usdt);\\r\\n        require(usdtAmount \\u003e= 10, \\\"BEP20: transfer amount equal zero\\\");\\r\\n        require(USDT.balanceOf(from) \\u003e= usdtAmount, \\\"BEP20: transfer amount not enough\\\");\\r\\n        USDT.transferFrom(from, address(this), usdtAmount);\\r\\n    }\\r\\n\\r\\n    function USDTtoUC(address from , uint256 Amount) external  \\r\\n    { \\r\\n        IERC20 USDT = IERC20(_usdt);\\r\\n        IERC20 UCToken = IERC20(_ucToken);\\r\\n        require(Amount \\u003e 0, \\\"BEP20: transfer amount equal zero\\\");\\r\\n        require(UCToken.balanceOf(address(this)) \\u003e Amount, \\\"BEP20: transfer amount not enough\\\");\\r\\n        USDT.transferFrom(from, address(this), Amount);\\r\\n        UCToken.transfer(from, Amount);\\r\\n    }\\r\\n\\r\\n    function UCtoUSDT(address from , uint256 Amount) external  \\r\\n    {\\r\\n        IERC20 USDT = IERC20(_usdt);\\r\\n        IERC20 UCToken = IERC20(_ucToken);\\r\\n        require(Amount \\u003e 0, \\\"BEP20: transfer amount equal zero\\\");\\r\\n        require(UCToken.balanceOf(address(this)) \\u003e Amount, \\\"BEP20: transfer amount not enough\\\");\\r\\n        UCToken.transferFrom(from, address(this), Amount);\\r\\n        uint256 usdtAmount = Amount.mul(9).div(10);\\r\\n        USDT.transfer(from, usdtAmount);\\r\\n    }\\r\\n\\r\\n    function setUcToken(address addr) external onlyOwner {\\r\\n        _ucToken = addr;\\r\\n    }\\r\\n\\r\\n    function setCxToken(address addr) external onlyOwner {\\r\\n        _cxToken = addr;\\r\\n    }\\r\\n\\r\\n    function claimToken(address token, uint256 amount, address to) external onlyOwner {\\r\\n        IERC20(token).transfer(to, amount);\\r\\n    }\\r\\n    \\r\\n    function UCclaimToken(address to, uint256 amount) external onlyOwner {\\r\\n        IERC20 UCToken = IERC20(_ucToken);\\r\\n        UCToken.transfer(to, amount);\\r\\n    } \\r\\n\\r\\n    function CXclaimToken(address to, uint256 amount) external onlyOwner {\\r\\n        IERC20 CxToken = IERC20(_cxToken);\\r\\n        CxToken.transfer(to, amount);\\r\\n    } \\r\\n\\r\\n    function CxToUsdt(address from , uint256 Amount) external  {\\r\\n        require(Amount \\u003e 0, \\\"BEP20: transfer amount equal zero\\\"); \\r\\n        IERC20 CxToken = IERC20(_cxToken);\\r\\n        IERC20 USDT = IERC20(_usdt);\\r\\n        require(CxToken.balanceOf(address(this)) \\u003e= Amount, \\\"BEP20: transfer amount equal zero\\\");\\r\\n        uint256 newprice = getCXtoUSDTLastPrice();\\r\\n        uint256 usdtAmount=Amount.mul(newprice).div(10**18);\\r\\n        require(usdtAmount \\u003e= 10, \\\"BEP20: transfer amount equal zero\\\"); \\r\\n        CxToken.transferFrom(from, address(this), Amount);\\r\\n        CxToken.transfer(blackholeAddress, Amount.mul(2));\\r\\n        USDT.transfer(from, usdtAmount);\\r\\n        cxTotalQuota += Amount;\\r\\n    }\\r\\n\\r\\n    function UsdtToCx(address from , uint256 Amount) external  {\\r\\n        require(Amount \\u003e 0, \\\"BEP20: transfer amount equal zero\\\"); \\r\\n        IERC20 CxToken = IERC20(_cxToken);\\r\\n        IERC20 USDT = IERC20(_usdt);\\r\\n        require(Amount \\u003e= 10, \\\"BEP20: transfer amount equal zero\\\"); \\r\\n        uint256 newprice =getUSDTtoCXLastPrice();\\r\\n        uint256 cxAmount=Amount.mul(newprice).div(10**18);\\r\\n        cxAmount=cxAmount.mul(9).div(10);\\r\\n        USDT.transferFrom(from, address(this), Amount);\\r\\n        CxToken.transfer(from, cxAmount);\\r\\n        usdtTotalQuota += Amount;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"UsdtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"UcAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"CxAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CXclaimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"CxToUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UCclaimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"UCtoUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"USDTtoUC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"UsdtToCx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ucReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ucAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokenReceivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"autoSysRepo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getCXBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCXtoUSDTLastPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getUCBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getUSDTBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUSDTtoCXLastPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ucAmount\",\"type\":\"uint256\"}],\"name\":\"payForTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"securityDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setCxToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setUcToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "USDTMiddleware", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000004e0f23467481d88e355f5e6fa7f976920475ed3c0000000000000000000000009a1a1905181415e18084979aa2134bf239fed6bf", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://75cd8291b9865ad01f2658a79cf411013e9241a929849e5a27f18f65520fbca6"}