{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBCPCashier {\r\n    function deposit(address token, uint256 mode, uint256 amount, address beneficiary) external;\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract BSGCashier {\r\n    using SafeMath for uint256;\r\n    uint256 private constant baseDividend = 10000;\r\n    address private constant HOLE = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    uint256 public timeStep = 1 days;\r\n    uint256 public dayPerCycle = 10 days;\r\n    uint256 public maxAddFreeze = 30 days;\r\n    uint256 public predictDuration = 30 minutes;\r\n    uint256 public unlimitDay = 365;\r\n\r\n    uint256 private constant initDayNewbies = 5;\r\n    uint256 private constant incInterval = 2;\r\n    uint256 private constant incNumber = 1;\r\n    uint256 private constant predictFee = 1e18;\r\n    uint256 private constant dayPredictLimit = 10;\r\n    uint256 private constant maxSearchDepth = 3000;\r\n    uint256 private constant incomeFeePercents = 700;\r\n    uint256 private constant bonusPercents = 500;\r\n    uint256 private constant splitPercents = 2000;\r\n    uint256 private constant transferFeePercents = 1000;\r\n    uint256 private constant dayRewardPercents = 150;\r\n    uint256 private constant predictPoolPercents = 300;\r\n    uint256 private constant unfreezeWithoutIncomePercents = 15000;\r\n    uint256 private constant unfreezeWithIncomePercents = 20000;\r\n    uint256 private constant ufdBuyBackPercents = 1000;\r\n    uint256 private constant ufdBuyBackUfcPercents = 7000;\r\n\r\n    uint256[5] private levelTeam = [0, 0, 0, 50, 200];\r\n    uint256[5] private levelInvite = [0, 0, 0, 10000e18, 20000e18];\r\n    uint256[5] private levelDeposit = [50e18, 500e18, 1000e18, 2000e18, 3000e18];\r\n    uint256[5] private balReached = [50e22, 100e22, 200e22, 500e22, 1000e22];\r\n    uint256[5] private balFreeze = [35e22, 70e22, 100e22, 300e22, 500e22];\r\n    uint256[5] private balUnfreeze = [80e22, 150e22, 200e22, 500e22, 1000e22];\r\n\r\n    uint256[20] private invitePercents = [\r\n        500,\r\n        100,\r\n        200,\r\n        300,\r\n        200,\r\n        100,\r\n        100,\r\n        100,\r\n        50,\r\n        50,\r\n        50,\r\n        50,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30\r\n    ];\r\n\r\n    uint256[20] private predictWinnerPercents = [\r\n        3000,\r\n        2000,\r\n        1000,\r\n        500,\r\n        500,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200,\r\n        200\r\n    ];\r\n\r\n    IERC20 private usdt;\r\n    address private ufd;\r\n    address private ufc;\r\n    IUniswapV2Router02 private router;\r\n    address private feeReceiver;\r\n    address private defaultRefer;\r\n    uint256 private startTime;\r\n    uint256 private lastDistribute;\r\n    uint256 private totalUsers;\r\n    uint256 private totalDeposit;\r\n    uint256 private freezedTimes;\r\n    uint256 private predictPool;\r\n    uint256 private totalPredictPool;\r\n    uint256 private totalWinners;\r\n    bool private isFreezing;\r\n    DepositorInfo[] private depositors;\r\n\r\n    mapping(uint256 => bool) private balStatus;\r\n    mapping(uint256 => address[]) private dayNewbies;\r\n    mapping(uint256 => uint256) private freezeTime;\r\n    mapping(uint256 => uint256) private unfreezeTime;\r\n    mapping(uint256 => uint256) private dayPredictPool;\r\n    mapping(uint256 => uint256) private dayDeposits;\r\n    mapping(address => mapping(uint256 => bool)) private isUnfreezedReward;\r\n    mapping(uint256 => mapping(uint256 => address[])) private dayPredictors;\r\n    mapping(address => PredictInfo[]) private userPredicts;\r\n    mapping(uint256 => mapping(address => PredictInfo[])) private userDayPredicts;\r\n    mapping(uint256 => PredictWinner[]) private dayPredictWinners;\r\n\r\n    struct UserInfo {\r\n        address referrer;\r\n        uint256 level;\r\n        uint256 maxDeposit;\r\n        uint256 maxDepositable;\r\n        uint256 teamNum;\r\n        uint256 teamTotalDeposit;\r\n        uint256 totalFreezed;\r\n        uint256 totalRevenue;\r\n        uint256 unfreezeIndex;\r\n        uint256 startTime;\r\n        bool isMaxFreezing;\r\n    }\r\n\r\n    struct RewardInfo {\r\n        uint256 capitals;\r\n        uint256 statics;\r\n        uint256 invited;\r\n        uint256 bonusFreezed;\r\n        uint256 bonusReleased;\r\n        uint256 l5Freezed;\r\n        uint256 l5Released;\r\n        uint256 predictWin;\r\n        uint256 split;\r\n        uint256 lastWithdaw;\r\n    }\r\n\r\n    struct OrderInfo {\r\n        uint256 amount;\r\n        uint256 start;\r\n        uint256 unfreeze;\r\n        bool isUnfreezed;\r\n    }\r\n\r\n    struct DepositorInfo {\r\n        address account;\r\n        uint256 amount;\r\n        uint256 createsAt;\r\n    }\r\n\r\n    struct PredictInfo {\r\n        uint256 time;\r\n        uint256 number;\r\n    }\r\n\r\n    struct PredictWinner {\r\n        address account;\r\n        uint256 winAmount;\r\n        uint256 rewardAmount;\r\n    }\r\n\r\n    mapping(address => UserInfo) private userInfo;\r\n    mapping(address => RewardInfo) private rewardInfo;\r\n    mapping(address => OrderInfo[]) private orderInfos;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) private userCycleMax;\r\n    mapping(address => mapping(uint256 => address[])) private teamUsers;\r\n\r\n    event Register(address user, address referral);\r\n    event Deposit(address user, uint256 types, uint256 amount, bool isFreezing);\r\n    event TransferBySplit(address user, uint256 subBal, address receiver, uint256 amount);\r\n    event Withdraw(address user, uint256 incomeFee, uint256 poolFee, uint256 split, uint256 withdraw);\r\n    event Predict(uint256 time, address user, uint256 amount);\r\n    event DistributePredictPool(uint256 day, uint256 reward, uint256 pool, uint256 time);\r\n\r\n    constructor(address _usdtAddr, address _ufd, address _ufc, address _router, address _feeReceiver, uint256 _startTime) {\r\n        usdt = IERC20(_usdtAddr);\r\n        ufd = _ufd;\r\n        ufc = _ufc;\r\n        router = IUniswapV2Router02(_router);\r\n        feeReceiver = _feeReceiver;\r\n        startTime = _startTime;\r\n        lastDistribute = _startTime;\r\n\r\n        defaultRefer = 0x23f0bFA82fD36FA5ffadC63A84487E270b28A4A9;\r\n        userInfo[0x7e5F94e43D80018eE81274335a7D08D9C43c4302].referrer = 0xbAca276575bCF4E537c2031A333BD91f4B17263f;\r\n        userInfo[0x72D3d4c2Ce57c867778a0962793100c9aF7d0Cb7].referrer = 0x7e5F94e43D80018eE81274335a7D08D9C43c4302;\r\n        userInfo[0x2FAE4EB5DF5C340832727743e911e0118120a4fc].referrer = 0x72D3d4c2Ce57c867778a0962793100c9aF7d0Cb7;\r\n        userInfo[0x23f0bFA82fD36FA5ffadC63A84487E270b28A4A9].referrer = 0x2FAE4EB5DF5C340832727743e911e0118120a4fc;\r\n    }\r\n\r\n    function register(address _referral) external {\r\n        require(userInfo[_referral].maxDeposit > 0 || _referral == defaultRefer, \"invalid refer\");\r\n        require(userInfo[msg.sender].referrer == address(0), \"referrer bonded\");\r\n        userInfo[msg.sender].referrer = _referral;\r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n    function deposit(uint256 _amount) external {\r\n        _deposit(msg.sender, _amount, 0);\r\n    }\r\n\r\n    function depositBySplit(uint256 _amount) public {\r\n        _deposit(msg.sender, _amount, 1);\r\n    }\r\n\r\n    function redeposit() public {\r\n        _deposit(msg.sender, 0, 2);\r\n    }\r\n\r\n    function _deposit(address _userAddr, uint256 _amount, uint256 _types) private {\r\n        require(block.timestamp >= startTime, \"not start\");\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        require(user.referrer != address(0), \"not register\");\r\n\r\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\r\n        if (_types == 0) {\r\n            usdt.transferFrom(_userAddr, address(this), _amount);\r\n            _balActived();\r\n        } else if (_types == 1) {\r\n            require(user.level == 0, \"actived\");\r\n            require(userRewards.split >= _amount, \"insufficient\");\r\n            require(_amount.mod(levelDeposit[0].mul(2)) == 0, \"amount err\");\r\n            userRewards.split = userRewards.split.sub(_amount);\r\n        } else {\r\n            require(user.level > 0, \"newbie\");\r\n            _amount = orderInfos[_userAddr][user.unfreezeIndex].amount;\r\n        }\r\n\r\n        uint256 curCycle = getCurCycle();\r\n        (uint256 userCurMin, uint256 userCurMax) = getUserCycleDepositable(_userAddr, curCycle);\r\n        require(_amount >= userCurMin && _amount <= userCurMax && _amount.mod(levelDeposit[0]) == 0, \"amount err\");\r\n        if (isFreezing && !isUnfreezedReward[_userAddr][freezedTimes]) isUnfreezedReward[_userAddr][freezedTimes] = true;\r\n\r\n        uint256 curDay = getCurDay();\r\n        dayDeposits[curDay] = dayDeposits[curDay].add(_amount);\r\n        totalDeposit = totalDeposit.add(_amount);\r\n        depositors.push(DepositorInfo({account: _userAddr, amount: _amount, createsAt: block.timestamp}));\r\n\r\n        if (user.level == 0) {\r\n            if (curDay < unlimitDay) require(dayNewbies[curDay].length < getMaxDayNewbies(curDay), \"reach max\");\r\n            dayNewbies[curDay].push(_userAddr);\r\n            totalUsers = totalUsers + 1;\r\n            user.startTime = block.timestamp;\r\n            if (_types == 0) {\r\n                userRewards.bonusFreezed = _amount.mul(bonusPercents).div(baseDividend);\r\n                user.totalRevenue = user.totalRevenue.add(userRewards.bonusFreezed);\r\n            }\r\n        }\r\n\r\n        _updateUplineReward(_userAddr, _amount);\r\n        _unfreezeCapitalOrReward(_userAddr, _amount, _types);\r\n\r\n        bool isMaxFreezing = _addNewOrder(_userAddr, _amount, _types, user.startTime, user.isMaxFreezing);\r\n        user.isMaxFreezing = isMaxFreezing;\r\n\r\n        _updateUserMax(_userAddr, _amount, userCurMax, curCycle);\r\n        _updateLevel(_userAddr);\r\n\r\n        if (isFreezing) _setFreezeReward();\r\n\r\n        emit Deposit(_userAddr, _types, _amount, isFreezing);\r\n    }\r\n\r\n    function _updateUplineReward(address _userAddr, uint256 _amount) private {\r\n        address upline = userInfo[_userAddr].referrer;\r\n        for (uint256 i = 0; i < invitePercents.length; i++) {\r\n            if (upline != address(0)) {\r\n                if (!isFreezing || isUnfreezedReward[upline][freezedTimes]) {\r\n                    OrderInfo[] storage upOrders = orderInfos[upline];\r\n                    if (upOrders.length > 0) {\r\n                        uint256 latestUnFreezeTime = getOrderUnfreezeTime(upline, upOrders.length - 1);\r\n                        uint256 maxFreezing = latestUnFreezeTime > block.timestamp ? upOrders[upOrders.length - 1].amount : 0;\r\n                        uint256 newAmount = maxFreezing < _amount ? maxFreezing : _amount;\r\n\r\n                        if (newAmount > 0) {\r\n                            RewardInfo storage upRewards = rewardInfo[upline];\r\n                            uint256 reward = newAmount.mul(invitePercents[i]).div(baseDividend);\r\n                            if (i == 0 || (i < 4 && userInfo[upline].level >= 4)) {\r\n                                upRewards.invited = upRewards.invited.add(reward);\r\n                                userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                            } else if (userInfo[upline].level >= 5) {\r\n                                upRewards.l5Freezed = upRewards.l5Freezed.add(reward);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _unfreezeCapitalOrReward(address _userAddr, uint256 _amount, uint256 _types) private {\r\n        (uint256 unfreezed, uint256 rewards) = _unfreezeOrder(_userAddr, _amount);\r\n        if (_types == 0) {\r\n            require(_amount > unfreezed, \"redeposit only\");\r\n        } else if (_types >= 2) {\r\n            require(_amount == unfreezed, \"redeposit err\");\r\n        }\r\n\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\r\n\r\n        if (unfreezed > 0) {\r\n            user.unfreezeIndex = user.unfreezeIndex + 1;\r\n            if (userRewards.bonusFreezed > 0) {\r\n                userRewards.bonusReleased = userRewards.bonusFreezed;\r\n                userRewards.bonusFreezed = 0;\r\n            }\r\n\r\n            if (rewards > 0) userRewards.statics = userRewards.statics.add(rewards);\r\n            if (_types < 2) userRewards.capitals = userRewards.capitals.add(unfreezed);\r\n        } else {\r\n            uint256 l5Freezed = userRewards.l5Freezed;\r\n            if (l5Freezed > 0) {\r\n                rewards = _amount <= l5Freezed ? _amount : l5Freezed;\r\n                userRewards.l5Freezed = l5Freezed.sub(rewards);\r\n                userRewards.l5Released = userRewards.l5Released.add(rewards);\r\n            }\r\n        }\r\n\r\n        user.totalRevenue = user.totalRevenue.add(rewards);\r\n        _updateFreezeAndTeamDeposit(_userAddr, _amount, unfreezed);\r\n    }\r\n\r\n    function _unfreezeOrder(address _userAddr, uint256 _amount) private returns (uint256 unfreezed, uint256 rewards) {\r\n        if (orderInfos[_userAddr].length > 0) {\r\n            UserInfo storage user = userInfo[_userAddr];\r\n            OrderInfo storage order = orderInfos[_userAddr][user.unfreezeIndex];\r\n            uint256 orderUnfreezeTime = getOrderUnfreezeTime(_userAddr, user.unfreezeIndex);\r\n            if (user.level > 0 && user.level < 5) require(block.timestamp >= orderUnfreezeTime, \"freezing\");\r\n            if (order.isUnfreezed == false && block.timestamp >= orderUnfreezeTime && _amount >= order.amount) {\r\n                order.isUnfreezed = true;\r\n                unfreezed = order.amount;\r\n                rewards = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDividend);\r\n                if (isFreezing) {\r\n                    if (user.totalFreezed > user.totalRevenue) {\r\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\r\n                        if (rewards > leftCapital) {\r\n                            rewards = leftCapital;\r\n                        }\r\n                    } else {\r\n                        rewards = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateFreezeAndTeamDeposit(address _userAddr, uint256 _amount, uint256 _unfreezed) private {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        if (_amount > _unfreezed) {\r\n            uint256 incAmount = _amount.sub(_unfreezed);\r\n            user.totalFreezed = user.totalFreezed.add(incAmount);\r\n\r\n            address upline = user.referrer;\r\n            for (uint256 i = 0; i < invitePercents.length; i++) {\r\n                if (upline != address(0)) {\r\n                    UserInfo storage upUser = userInfo[upline];\r\n                    if (user.level == 0 && _userAddr != upline) {\r\n                        upUser.teamNum = upUser.teamNum + 1;\r\n                        teamUsers[upline][i].push(_userAddr);\r\n                    }\r\n                    upUser.teamTotalDeposit = upUser.teamTotalDeposit.add(incAmount);\r\n                    if (upline == defaultRefer) break;\r\n                    upline = upUser.referrer;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addNewOrder(\r\n        address _userAddr,\r\n        uint256 _amount,\r\n        uint256 _types,\r\n        uint256 _startTime,\r\n        bool _isMaxFreezing\r\n    ) private returns (bool isMaxFreezing) {\r\n        uint256 addFreeze;\r\n        OrderInfo[] storage orders = orderInfos[_userAddr];\r\n\r\n        if (_isMaxFreezing) {\r\n            isMaxFreezing = true;\r\n        } else {\r\n            if ((freezedTimes > 0 && _types == 1) || (!isFreezing && _startTime < freezeTime[freezedTimes])) {\r\n                isMaxFreezing = true;\r\n            } else {\r\n                addFreeze = (orders.length).mul(timeStep);\r\n                if (addFreeze > maxAddFreeze) isMaxFreezing = true;\r\n            }\r\n        }\r\n\r\n        uint256 unfreeze = isMaxFreezing\r\n            ? block.timestamp.add(dayPerCycle).add(maxAddFreeze)\r\n            : block.timestamp.add(dayPerCycle).add(addFreeze);\r\n        orders.push(OrderInfo(_amount, block.timestamp, unfreeze, false));\r\n    }\r\n\r\n    function _updateUserMax(address _userAddr, uint256 _amount, uint256 _userCurMax, uint256 _curCycle) internal {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        if (_amount > user.maxDeposit) user.maxDeposit = _amount;\r\n        userCycleMax[_userAddr][_curCycle] = _userCurMax;\r\n\r\n        uint256 nextMaxDepositable;\r\n        if (_amount == _userCurMax) {\r\n            uint256 curMaxDepositable = getCurMaxDepositable();\r\n            if (_userCurMax >= curMaxDepositable) {\r\n                nextMaxDepositable = curMaxDepositable;\r\n            } else {\r\n                if (_userCurMax < levelDeposit[3]) {\r\n                    nextMaxDepositable = _userCurMax.add(levelDeposit[1]);\r\n                } else {\r\n                    nextMaxDepositable = _userCurMax.add(levelDeposit[2]);\r\n                }\r\n            }\r\n        } else {\r\n            nextMaxDepositable = _userCurMax;\r\n        }\r\n\r\n        userCycleMax[_userAddr][_curCycle + 1] = nextMaxDepositable;\r\n        user.maxDepositable = nextMaxDepositable;\r\n    }\r\n\r\n    function _updateLevel(address _userAddr) private {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        for (uint256 i = user.level; i < levelDeposit.length; i++) {\r\n            if (user.maxDeposit >= levelDeposit[i]) {\r\n                if (i < 3) {\r\n                    user.level = i + 1;\r\n                } else {\r\n                    (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_userAddr);\r\n                    if (maxTeam >= levelInvite[i] && otherTeam >= levelInvite[i] && user.teamNum >= levelTeam[i]) {\r\n                        user.level = i + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw() external {\r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        uint256 rewardsStatic = userRewards.statics.add(userRewards.invited).add(userRewards.bonusReleased).add(\r\n            userRewards.predictWin\r\n        );\r\n\r\n        uint256 incomeFee = rewardsStatic.mul(incomeFeePercents).div(baseDividend);\r\n        usdt.transfer(feeReceiver, incomeFee);\r\n\r\n        uint256 predictPoolFee = rewardsStatic.mul(predictPoolPercents).div(baseDividend);\r\n        predictPool = predictPool.add(predictPoolFee);\r\n        totalPredictPool = totalPredictPool.add(predictPoolFee);\r\n\r\n        (uint256 ufdFee, , ) = _takeUfdBuyBackFee(msg.sender, rewardsStatic);\r\n\r\n        uint256 leftReward = rewardsStatic.add(userRewards.l5Released).sub(incomeFee).sub(predictPoolFee).sub(ufdFee);\r\n        uint256 split = leftReward.mul(splitPercents).div(baseDividend);\r\n        uint256 withdrawable = leftReward.sub(split);\r\n        uint256 capitals = userRewards.capitals;\r\n\r\n        userRewards.capitals = 0;\r\n        userRewards.statics = 0;\r\n        userRewards.invited = 0;\r\n        userRewards.bonusReleased = 0;\r\n        userRewards.l5Released = 0;\r\n        userRewards.predictWin = 0;\r\n        userRewards.split = userRewards.split.add(split);\r\n        userRewards.lastWithdaw = block.timestamp;\r\n\r\n        withdrawable = withdrawable.add(capitals);\r\n        usdt.transfer(msg.sender, withdrawable);\r\n\r\n        if (!isFreezing) _setFreezeReward();\r\n        emit Withdraw(msg.sender, incomeFee, predictPoolFee, split, withdrawable);\r\n    }\r\n\r\n    function _takeUfdBuyBackFee(\r\n        address account,\r\n        uint256 rewards\r\n    ) private returns (uint256 total, uint256 ufcAmount, uint256 destroyAmount) {\r\n        if (rewards == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        total = rewards.mul(ufdBuyBackPercents).div(baseDividend);\r\n\r\n        usdt.approve(address(router), total);\r\n\r\n        address[] memory ufdBuyBackPath = new address[](2);\r\n        ufdBuyBackPath[0] = address(usdt);\r\n        ufdBuyBackPath[1] = ufd;\r\n\r\n        uint256 ufdBuyBackReceivedAmount = IERC20(ufd).balanceOf(address(this));\r\n        router.swapExactTokensForTokens(total, 0, ufdBuyBackPath, address(this), block.timestamp)[1];\r\n        ufdBuyBackReceivedAmount = IERC20(ufd).balanceOf(address(this)) - ufdBuyBackReceivedAmount;\r\n\r\n        ufcAmount = ufdBuyBackReceivedAmount.mul(ufdBuyBackUfcPercents).div(baseDividend);\r\n        IERC20(ufd).approve(ufc, ufcAmount);\r\n        IBCPCashier(ufc).deposit(ufd, 0, ufcAmount, account);\r\n\r\n        destroyAmount = ufdBuyBackReceivedAmount - ufcAmount;\r\n        IERC20(ufd).transfer(HOLE, destroyAmount);\r\n    }\r\n\r\n    function withdrawableAmount(\r\n        address account\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 rewardsStatic, uint256 fee, uint256 split, uint256 withdrawableRewards, uint256 capitals)\r\n    {\r\n        RewardInfo memory userRewards = rewardInfo[account];\r\n        rewardsStatic = userRewards.statics.add(userRewards.invited).add(userRewards.bonusReleased).add(\r\n            userRewards.predictWin\r\n        );\r\n\r\n        fee = rewardsStatic\r\n            .mul(incomeFeePercents)\r\n            .div(baseDividend)\r\n            .add(rewardsStatic.mul(predictPoolPercents).div(baseDividend))\r\n            .add(rewardsStatic.mul(ufdBuyBackPercents).div(baseDividend));\r\n\r\n        split = rewardsStatic.add(userRewards.l5Released).sub(fee).mul(splitPercents).div(baseDividend);\r\n        withdrawableRewards = rewardsStatic.add(userRewards.l5Released).sub(fee).sub(split);\r\n        capitals = userRewards.capitals;\r\n    }\r\n\r\n    function predict(uint256 _amount) external {\r\n        require(userInfo[msg.sender].referrer != address(0), \"not register\");\r\n        require(_amount.mod(levelDeposit[0]) == 0, \"amount err\");\r\n        uint256 curDay = getCurDay();\r\n        require(userDayPredicts[curDay][msg.sender].length < dayPredictLimit, \"reached day limit\");\r\n        uint256 predictEnd = startTime.add(curDay.mul(timeStep)).add(predictDuration);\r\n        require(block.timestamp < predictEnd, \"today is over\");\r\n        usdt.transferFrom(msg.sender, address(this), predictFee);\r\n        dayPredictors[curDay][_amount].push(msg.sender);\r\n        userPredicts[msg.sender].push(PredictInfo(block.timestamp, _amount));\r\n        userDayPredicts[curDay][msg.sender].push(PredictInfo(block.timestamp, _amount));\r\n        if (isFreezing) _setFreezeReward();\r\n        emit Predict(block.timestamp, msg.sender, _amount);\r\n    }\r\n\r\n    function transferBySplit(address _receiver, uint256 _amount) external {\r\n        uint256 minTransfer = levelDeposit[0].mul(2);\r\n        require(_amount >= minTransfer && _amount.mod(minTransfer) == 0, \"amount err\");\r\n        uint256 subBal = _amount.add(_amount.mul(transferFeePercents).div(baseDividend));\r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        require(userRewards.split >= subBal, \"insufficient split\");\r\n        userRewards.split = userRewards.split.sub(subBal);\r\n        rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(_amount);\r\n        emit TransferBySplit(msg.sender, subBal, _receiver, _amount);\r\n    }\r\n\r\n    function distributePredictPool() external {\r\n        if (block.timestamp >= lastDistribute.add(timeStep)) {\r\n            uint256 curDay = getCurDay();\r\n            uint256 lastDay = curDay - 1;\r\n            uint256 totalReward;\r\n            if (predictPool > 0) {\r\n                (address[] memory winners, uint256[] memory amounts) = getPredictWinners(lastDay);\r\n                for (uint256 i = 0; i < winners.length; i++) {\r\n                    if (winners[i] != address(0)) {\r\n                        uint256 reward = predictPool.mul(predictWinnerPercents[i]).div(baseDividend);\r\n                        totalReward = totalReward.add(reward);\r\n                        rewardInfo[winners[i]].predictWin = rewardInfo[winners[i]].predictWin.add(reward);\r\n                        userInfo[winners[i]].totalRevenue = userInfo[winners[i]].totalRevenue.add(reward);\r\n                        totalWinners++;\r\n\r\n                        dayPredictWinners[lastDay].push(\r\n                            PredictWinner({account: winners[i], winAmount: amounts[i], rewardAmount: reward})\r\n                        );\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                dayPredictPool[lastDay] = predictPool;\r\n                predictPool = predictPool > totalReward ? predictPool.sub(totalReward) : 0;\r\n            }\r\n            lastDistribute = startTime.add(curDay.mul(timeStep));\r\n            emit DistributePredictPool(lastDay, totalReward, predictPool, lastDistribute);\r\n        }\r\n    }\r\n\r\n    function _balActived() private {\r\n        uint256 bal = usdt.balanceOf(address(this));\r\n        for (uint256 i = balReached.length; i > 0; i--) {\r\n            if (bal >= balReached[i - 1]) {\r\n                balStatus[balReached[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setFreezeReward() private {\r\n        uint256 bal = usdt.balanceOf(address(this));\r\n        for (uint256 i = balReached.length; i > 0; i--) {\r\n            if (balStatus[balReached[i - 1]]) {\r\n                if (!isFreezing) {\r\n                    if (bal < balFreeze[i - 1]) {\r\n                        isFreezing = true;\r\n                        freezedTimes = freezedTimes + 1;\r\n                        freezeTime[freezedTimes] = block.timestamp;\r\n                    }\r\n                } else {\r\n                    if (bal >= balUnfreeze[i - 1]) {\r\n                        isFreezing = false;\r\n                        unfreezeTime[freezedTimes] = block.timestamp;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getOrderUnfreezeTime(address _userAddr, uint256 _index) public view returns (uint256 orderUnfreezeTime) {\r\n        OrderInfo storage order = orderInfos[_userAddr][_index];\r\n        orderUnfreezeTime = order.unfreeze;\r\n        if (!isFreezing && !order.isUnfreezed && userInfo[_userAddr].startTime < freezeTime[freezedTimes]) {\r\n            orderUnfreezeTime = order.start.add(dayPerCycle).add(maxAddFreeze);\r\n        }\r\n    }\r\n\r\n    function getUserCycleDepositable(\r\n        address _userAddr,\r\n        uint256 _cycle\r\n    ) public view returns (uint256 cycleMin, uint256 cycleMax) {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        if (user.maxDeposit > 0) {\r\n            cycleMin = user.maxDeposit;\r\n            cycleMax = userCycleMax[_userAddr][_cycle];\r\n\r\n            if (cycleMax == 0) cycleMax = user.maxDepositable;\r\n\r\n            uint256 curMaxDepositable = getCurMaxDepositable();\r\n            if (isFreezing) {\r\n                if (user.startTime < freezeTime[freezedTimes] && !isUnfreezedReward[_userAddr][freezedTimes]) {\r\n                    cycleMin = user.totalFreezed > user.totalRevenue\r\n                        ? cycleMin.mul(unfreezeWithoutIncomePercents).div(baseDividend)\r\n                        : cycleMin.mul(unfreezeWithIncomePercents).div(baseDividend);\r\n                    cycleMax = curMaxDepositable;\r\n                }\r\n            } else {\r\n                if (user.startTime < freezeTime[freezedTimes]) cycleMax = curMaxDepositable;\r\n            }\r\n        } else {\r\n            cycleMin = levelDeposit[0];\r\n            cycleMax = levelDeposit[1];\r\n        }\r\n\r\n        if (cycleMin > cycleMax) cycleMin = cycleMax;\r\n    }\r\n\r\n    function getPredictWinners(uint256 _day) public view returns (address[] memory winners, uint256[] memory amounts) {\r\n        uint256 steps = dayDeposits[_day].div(levelDeposit[0]);\r\n        uint256 maxWinners = predictWinnerPercents.length;\r\n        winners = new address[](maxWinners);\r\n        amounts = new uint256[](maxWinners);\r\n        uint256 counter;\r\n        for (uint256 i = steps; i >= 0; i--) {\r\n            uint256 winAmount = i.mul(levelDeposit[0]);\r\n            for (uint256 j = 0; j < dayPredictors[_day][winAmount].length; j++) {\r\n                address predictUser = dayPredictors[_day][winAmount][j];\r\n                if (predictUser != address(0)) {\r\n                    winners[counter] = predictUser;\r\n                    amounts[counter] = winAmount;\r\n                    counter++;\r\n                    if (counter >= maxWinners) break;\r\n                }\r\n            }\r\n            if (counter >= maxWinners || i == 0 || steps.sub(i) >= maxSearchDepth) break;\r\n        }\r\n    }\r\n\r\n    function getTeamDeposit(address _userAddr) public view returns (uint256 maxTeam, uint256 otherTeam, uint256 totalTeam) {\r\n        address[] memory directTeamUsers = teamUsers[_userAddr][0];\r\n        for (uint256 i = 0; i < directTeamUsers.length; i++) {\r\n            UserInfo storage user = userInfo[directTeamUsers[i]];\r\n            uint256 userTotalTeam = user.teamTotalDeposit.add(user.totalFreezed);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if (userTotalTeam > maxTeam) maxTeam = userTotalTeam;\r\n            if (i >= maxSearchDepth) break;\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n    }\r\n\r\n    function getCurDay() public view returns (uint256) {\r\n        return (block.timestamp.sub(startTime)).div(timeStep);\r\n    }\r\n\r\n    function getCurCycle() public view returns (uint256) {\r\n        return (block.timestamp.sub(startTime)).div(dayPerCycle);\r\n    }\r\n\r\n    function getCurMaxDepositable() public view returns (uint256) {\r\n        return levelDeposit[4].mul(2 ** freezedTimes);\r\n    }\r\n\r\n    function getMaxDayNewbies(uint256 _day) public pure returns (uint256) {\r\n        return initDayNewbies + _day.mul(incNumber).div(incInterval);\r\n    }\r\n\r\n    function getOrderLength(address _userAddr) public view returns (uint256) {\r\n        return orderInfos[_userAddr].length;\r\n    }\r\n\r\n    function getLatestDepositors(uint256 _length) public view returns (DepositorInfo[] memory latestDepositors) {\r\n        uint256 totalCount = depositors.length;\r\n        if (_length > totalCount) _length = totalCount;\r\n        latestDepositors = new DepositorInfo[](_length);\r\n        for (uint256 i = totalCount; i > totalCount - _length; i--) {\r\n            latestDepositors[totalCount - i] = depositors[i - 1];\r\n        }\r\n    }\r\n\r\n    function getTeamUsers(address _userAddr, uint256 _layer) public view returns (address[] memory) {\r\n        return teamUsers[_userAddr][_layer];\r\n    }\r\n\r\n    function getUserPredicts(address account) public view returns (PredictInfo[] memory) {\r\n        return userPredicts[account];\r\n    }\r\n\r\n    function getUserDayPredicts(address _userAddr, uint256 _day) public view returns (PredictInfo[] memory) {\r\n        return userDayPredicts[_day][_userAddr];\r\n    }\r\n\r\n    function getDayPredictors(uint256 _day, uint256 _number) external view returns (address[] memory) {\r\n        return dayPredictors[_day][_number];\r\n    }\r\n\r\n    function getDayWinners(uint256 day) external view returns (PredictWinner[] memory) {\r\n        return dayPredictWinners[day];\r\n    }\r\n\r\n    function getDayInfos(uint256 _day) external view returns (address[] memory newbies, uint256 deposits, uint256 pool) {\r\n        return (dayNewbies[_day], dayDeposits[_day], dayPredictPool[_day]);\r\n    }\r\n\r\n    function getBalStatus(uint256 _bal) external view returns (bool) {\r\n        return balStatus[_bal];\r\n    }\r\n\r\n    function getUserCycleMax(address _userAddr, uint256 _cycle) external view returns (uint256) {\r\n        return userCycleMax[_userAddr][_cycle];\r\n    }\r\n\r\n    function getUserInfos(\r\n        address _userAddr\r\n    ) external view returns (UserInfo memory user, RewardInfo memory reward, OrderInfo[] memory orders, bool unfreeze) {\r\n        user = userInfo[_userAddr];\r\n        reward = rewardInfo[_userAddr];\r\n        orders = orderInfos[_userAddr];\r\n        unfreeze = isUnfreezedReward[_userAddr][freezedTimes];\r\n    }\r\n\r\n    function getUserOrders(address user) external view returns (OrderInfo[] memory orders) {\r\n        orders = orderInfos[user];\r\n\r\n        if (!isFreezing && userInfo[user].startTime < freezeTime[freezedTimes]) {\r\n            for (uint i = 0; i < orders.length; i++) {\r\n                if (!orders[i].isUnfreezed) {\r\n                    orders[i].unfreeze = orders[i].start.add(dayPerCycle).add(maxAddFreeze);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getContractInfos() external view returns (address[3] memory infos0, uint256[10] memory infos1, bool freezing) {\r\n        infos0[0] = address(usdt);\r\n        infos0[1] = feeReceiver;\r\n        infos0[2] = defaultRefer;\r\n        infos1[0] = startTime;\r\n        infos1[1] = lastDistribute;\r\n        infos1[2] = totalUsers;\r\n        infos1[3] = totalDeposit;\r\n        infos1[4] = predictPool;\r\n        infos1[5] = totalPredictPool;\r\n        infos1[6] = totalWinners;\r\n        infos1[7] = freezedTimes;\r\n        infos1[8] = freezeTime[freezedTimes];\r\n        infos1[9] = unfreezeTime[freezedTimes];\r\n        freezing = isFreezing;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ufd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ufc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"types\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFreezing\",\"type\":\"bool\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"DistributePredictPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Predict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subBal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"dayPerCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePredictPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"getBalStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractInfos\",\"outputs\":[{\"internalType\":\"address[3]\",\"name\":\"infos0\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[10]\",\"name\":\"infos1\",\"type\":\"uint256[10]\"},{\"internalType\":\"bool\",\"name\":\"freezing\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurMaxDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayInfos\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"newbies\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getDayPredictors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getDayWinners\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BSGCashier.PredictWinner[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"getLatestDepositors\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createsAt\",\"type\":\"uint256\"}],\"internalType\":\"struct BSGCashier.DepositorInfo[]\",\"name\":\"latestDepositors\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getMaxDayNewbies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getOrderUnfreezeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderUnfreezeTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getPredictWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleMax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getUserDayPredicts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct BSGCashier.PredictInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getUserInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMaxFreezing\",\"type\":\"bool\"}],\"internalType\":\"struct BSGCashier.UserInfo\",\"name\":\"user\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l5Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l5Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictWin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdaw\",\"type\":\"uint256\"}],\"internalType\":\"struct BSGCashier.RewardInfo\",\"name\":\"reward\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"internalType\":\"struct BSGCashier.OrderInfo[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"unfreeze\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"internalType\":\"struct BSGCashier.OrderInfo[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserPredicts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct BSGCashier.PredictInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAddFreeze\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"predict\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"predictDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlimitDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BSGCashier", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000936685c7d81a03a204219cc7d0e61684c65471ca000000000000000000000000ce75c7099f5f0eb3dd5629207df359935d2f7fb500000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000007872d768dfe22ffd8fed94460adcef773e7bfefa0000000000000000000000000000000000000000000000000000000064bf64e0", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4e13e1858111bf0cb96525b06644bfa5f20f4740e817c891f3880e46971c091e"}