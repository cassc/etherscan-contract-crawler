{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/BerryGetters.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/BerryStorage.sol\\\";\\nimport \\\"./libraries/BerryTransfer.sol\\\";\\nimport \\\"./libraries/BerryGettersLibrary.sol\\\";\\nimport \\\"./libraries/BerryStake.sol\\\";\\n\\n/**\\n* @title Berry Getters\\n* @dev Oracle contract with all berry getter functions. The logic for the functions on this contract\\n* is saved on the BerryGettersLibrary, BerryTransfer, BerryGettersLibrary, and BerryStake\\n*/\\ncontract BerryGetters {\\n    using SafeMath for uint256;\\n\\n    using BerryTransfer for BerryStorage.BerryStorageStruct;\\n    using BerryGettersLibrary for BerryStorage.BerryStorageStruct;\\n    using BerryStake for BerryStorage.BerryStorageStruct;\\n\\n    BerryStorage.BerryStorageStruct berry;\\n\\n    /**\\n    * @param _user address\\n    * @param _spender address\\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\\n    */\\n    function allowance(address _user, address _spender) external view returns (uint256) {\\n        return berry.allowance(_user, _spender);\\n    }\\n\\n    /**\\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\\n    * @param _user address\\n    * @param _amount uint of amount\\n    * @return true if the user is alloed to trade the amount specified\\n    */\\n    function allowedToTrade(address _user, uint256 _amount) external view returns (bool) {\\n        return berry.allowedToTrade(_user, _amount);\\n    }\\n\\n    /**\\n    * @dev Gets balance of owner specified\\n    * @param _user is the owner address used to look up the balance\\n    * @return Returns the balance associated with the passed in _user\\n    */\\n    function balanceOf(address _user) external view returns (uint256) {\\n        return berry.balanceOf(_user);\\n    }\\n\\n    /**\\n    * @dev Queries the balance of _user at a specific _blockNumber\\n    * @param _user The address from which the balance will be retrieved\\n    * @param _blockNumber The block number when the balance is queried\\n    * @return The balance at _blockNumber\\n    */\\n    function balanceOfAt(address _user, uint256 _blockNumber) external view returns (uint256) {\\n        return berry.balanceOfAt(_user, _blockNumber);\\n    }\\n\\n    /**\\n    * @dev This function tells you if a given challenge has been completed by a given miner\\n    * @param _challenge the challenge to search for\\n    * @param _miner address that you want to know if they solved the challenge\\n    * @return true if the _miner address provided solved the\\n    */\\n    function didMine(bytes32 _challenge, address _miner) external view returns (bool) {\\n        return berry.didMine(_challenge, _miner);\\n    }\\n\\n    /**\\n    * @dev Checks if an address voted in a given dispute\\n    * @param _disputeId to look up\\n    * @param _address to look up\\n    * @return bool of whether or not party voted\\n    */\\n    function didVote(uint256 _disputeId, address _address) external view returns (bool) {\\n        return berry.didVote(_disputeId, _address);\\n    }\\n\\n    /**\\n    * @dev allows Berry to read data from the addressVars mapping\\n    * @param _data is the keccak256(\\\"variable_name\\\") of the variable that is being accessed.\\n    * These are examples of how the variables are saved within other functions:\\n    * addressVars[keccak256(\\\"_owner\\\")]\\n    * addressVars[keccak256(\\\"berryContract\\\")]\\n    * @return address of the requested variable \\n    */\\n    function getAddressVars(bytes32 _data) external view returns (address) {\\n        return berry.getAddressVars(_data);\\n    }\\n\\n    /**\\n    * @dev Gets all dispute variables\\n    * @param _disputeId to look up\\n    * @return bytes32 hash of dispute\\n    * @return bool executed where true if it has been voted on\\n    * @return bool disputeVotePassed\\n    * @return bool isPropFork true if the dispute is a proposed fork\\n    * @return address of reportedMiner\\n    * @return address of reportingParty\\n    * @return address of proposedForkAddress\\n    * @return uint of requestId\\n    * @return uint of timestamp\\n    * @return uint of value\\n    * @return uint of minExecutionDate\\n    * @return uint of numberOfVotes\\n    * @return uint of blocknumber\\n    * @return uint of minerSlot\\n    * @return uint of quorum\\n    * @return uint of fee\\n    * @return int count of the current tally\\n    */\\n    function getAllDisputeVars(uint256 _disputeId)\\n        public\\n        view\\n        returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256)\\n    {\\n        return berry.getAllDisputeVars(_disputeId);\\n    }\\n\\n    /**\\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\\n    */\\n    function getCurrentVariables() external view returns (bytes32, uint256, uint256, string memory, uint256, uint256) {\\n        return berry.getCurrentVariables();\\n    }\\n\\n    /**\\n    * @dev Checks if a given hash of miner,requestId has been disputed\\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\\n    * @return uint disputeId\\n    */\\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256) {\\n        return berry.getDisputeIdByDisputeHash(_hash);\\n    }\\n\\n    /**\\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\\n    * @param _disputeId is the dispute id;\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the disputeUintVars under the Dispute struct\\n    * @return uint value for the bytes32 data submitted\\n    */\\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data) external view returns (uint256) {\\n        return berry.getDisputeUintVars(_disputeId, _data);\\n    }\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @return value for timestamp of last proof of work submited\\n    * @return true if the is a timestamp for the lastNewValue\\n    */\\n    function getLastNewValue() external view returns (uint256, bool) {\\n        return berry.getLastNewValue();\\n    }\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @param _requestId being requested\\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\\n    */\\n    function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool) {\\n        return berry.getLastNewValueById(_requestId);\\n    }\\n\\n    /**\\n    * @dev Gets blocknumber for mined timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up blocknumber\\n    * @return uint of the blocknumber which the dispute was mined\\n    */\\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp) external view returns (uint256) {\\n        return berry.getMinedBlockNum(_requestId, _timestamp);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return the 5 miners' addresses\\n    */\\n    function getMinersByRequestIdAndTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (address[5] memory) {\\n        return berry.getMinersByRequestIdAndTimestamp(_requestId, _timestamp);\\n    }\\n\\n    /**\\n    * @dev Counts the number of values that have been submited for the request\\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\\n    * request so far\\n    * @param _requestId the requestId to look up\\n    * @return uint count of the number of values received for the requestId\\n    */\\n    function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256) {\\n        return berry.getNewValueCountbyRequestId(_requestId);\\n    }\\n\\n    /**\\n    * @dev Getter function for the specified requestQ index\\n    * @param _index to look up in the requestQ array\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByRequestQIndex(uint256 _index) external view returns (uint256) {\\n        return berry.getRequestIdByRequestQIndex(_index);\\n    }\\n\\n    /**\\n    * @dev Getter function for requestId based on timestamp\\n    * @param _timestamp to check requestId\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByTimestamp(uint256 _timestamp) external view returns (uint256) {\\n        return berry.getRequestIdByTimestamp(_timestamp);\\n    }\\n\\n    /**\\n    * @dev Getter function for requestId based on the queryHash\\n    * @param _request is the hash(of string api and granularity) to check if a request already exists\\n    * @return uint requestId\\n    */\\n    function getRequestIdByQueryHash(bytes32 _request) external view returns (uint256) {\\n        return berry.getRequestIdByQueryHash(_request);\\n    }\\n\\n    /**\\n    * @dev Getter function for the requestQ array\\n    * @return the requestQ arrray\\n    */\\n    function getRequestQ() public view returns (uint256[51] memory) {\\n        return berry.getRequestQ();\\n    }\\n\\n    /**\\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\\n    * for the requestId specified\\n    * @param _requestId to look up\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the apiUintVars under the requestDetails struct\\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\\n    */\\n    function getRequestUintVars(uint256 _requestId, bytes32 _data) external view returns (uint256) {\\n        return berry.getRequestUintVars(_requestId, _data);\\n    }\\n\\n    /**\\n    * @dev Gets the API struct variables that are not mappings\\n    * @param _requestId to look up\\n    * @return string of api to query\\n    * @return string of symbol of api to query\\n    * @return bytes32 hash of string\\n    * @return bytes32 of the granularity(decimal places) requested\\n    * @return uint of index in requestQ array\\n    * @return uint of current payout/tip for this requestId\\n    */\\n    function getRequestVars(uint256 _requestId) external view returns (string memory, string memory, bytes32, uint256, uint256, uint256) {\\n        return berry.getRequestVars(_requestId);\\n    }\\n\\n    /**\\n    * @dev This function allows users to retireve all information about a staker\\n    * @param _staker address of staker inquiring about\\n    * @return uint current state of staker\\n    * @return uint startDate of staking\\n    */\\n    function getStakerInfo(address _staker) external view returns (uint256, uint256) {\\n        return berry.getStakerInfo(_staker);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestampt to look up miners for\\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\\n    */\\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (uint256[5] memory) {\\n        return berry.getSubmissionsByTimestamp(_requestId, _timestamp);\\n    }\\n\\n\\n    /**\\n    * @dev Gets the timestamp for the value based on their index\\n    * @param _requestID is the requestId to look up\\n    * @param _index is the value index to look up\\n    * @return uint timestamp\\n    */\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index) external view returns (uint256) {\\n        return berry.getTimestampbyRequestIDandIndex(_requestID, _index);\\n    }\\n\\n    /**\\n    * @dev Getter for the variables saved under the BerryStorageStruct uintVars variable\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the uintVars under the BerryStorageStruct struct\\n    * This is an example of how data is saved into the mapping within other functions:\\n    * self.uintVars[keccak256(\\\"stakerCount\\\")]\\n    * @return uint of specified variable\\n    */\\n    function getUintVar(bytes32 _data) public view returns (uint256) {\\n        return berry.getUintVar(_data);\\n    }\\n\\n    /**\\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\\n    */\\n    function getVariablesOnDeck() external view returns (uint256, uint256, string memory) {\\n        return berry.getVariablesOnDeck();\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return bool true if requestId/timestamp is under dispute\\n    */\\n    function isInDispute(uint256 _requestId, uint256 _timestamp) external view returns (bool) {\\n        return berry.isInDispute(_requestId, _timestamp);\\n    }\\n\\n    /**\\n    * @dev Retreive value from oracle based on timestamp\\n    * @param _requestId being requested\\n    * @param _timestamp to retreive data/value from\\n    * @return value for timestamp submitted\\n    */\\n    function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256) {\\n        return berry.retrieveData(_requestId, _timestamp);\\n    }\\n\\n    /**\\n    * @dev Getter for the total_supply of oracle tokens\\n    * @return uint total supply\\n    */\\n    function totalSupply() external view returns (uint256) {\\n        return berry.totalSupply();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/BerryMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./BerryGetters.sol\\\";\\n\\n/**\\n* @title Berry Master\\n* @dev This is the Master contract with all berry getter functions and delegate call to Berry.\\n* The logic for the functions on this contract is saved on the BerryGettersLibrary, BerryTransfer,\\n* BerryGettersLibrary, and BerryStake\\n*/\\ncontract BerryMaster is BerryGetters {\\n    event NewBerryAddress(address _newBerry);\\n\\n    /**\\n    * @dev The constructor sets the original `berryStorageOwner` of the contract to the sender\\n    * account, the berry contract to the Berry master address and owner to the Berry master owner address\\n    * @param _berryContract is the address for the berry contract\\n    */\\n    constructor(address _berryContract) public {\\n        berry.init();\\n        berry.addressVars[keccak256(\\\"_owner\\\")] = msg.sender;\\n        berry.addressVars[keccak256(\\\"_deity\\\")] = msg.sender;\\n        berry.addressVars[keccak256(\\\"berryContract\\\")] = _berryContract;\\n        emit NewBerryAddress(_berryContract);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @dev Only needs to be in library\\n    * @param _newDeity the new Deity in the contract\\n    */\\n\\n    function changeDeity(address _newDeity) external {\\n        berry.changeDeity(_newDeity);\\n    }\\n\\n    /**\\n    * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized\\n    * @param _berryContract the address of the new Berry Contract\\n    */\\n    function changeBerryContract(address _berryContract) external {\\n        berry.changeBerryContract(_berryContract);\\n    }\\n\\n    /**\\n    * @dev This is the fallback function that allows contracts to call the berry contract at the address stored\\n    */\\n    function() external payable {\\n        address addr = berry.addressVars[keccak256(\\\"berryContract\\\")];\\n        bytes memory _calldata = msg.data;\\n        assembly {\\n            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n            let size := returndatasize\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n            // if the call returned error data, forward it\\n            switch result\\n                case 0 {\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/BerryDispute.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\nimport \\\"./BerryStorage.sol\\\";\\nimport \\\"./BerryTransfer.sol\\\";\\n\\n\\n/**\\n* @title Berry Dispute\\n* @dev Contains the methods related to disputes. Berry.sol references this library for function's logic.\\n*/\\n\\nlibrary BerryDispute {\\n    using SafeMath for uint256;\\n    using SafeMath for int256;\\n\\n    //emitted when a new dispute is initialized\\n    event NewDispute(uint256 indexed _disputeId, uint256 indexed _requestId, uint256 _timestamp, address _miner);\\n    //emitted when a new vote happens\\n    event Voted(uint256 indexed _disputeID, bool _position, address indexed _voter, uint256 indexed _voteWeight);\\n    //emitted upon dispute tally\\n    event DisputeVoteTallied(uint256 indexed _disputeID, int256 _result, address indexed _reportedMiner, address _reportingParty, bool _active);\\n    event NewBerryAddress(address _newBerry); //emmited when a proposed fork is voted true\\n\\n    /*Functions*/\\n\\n    /**\\n    * @dev Helps initialize a dispute by assigning it a disputeId\\n    * when a miner returns a false on the validate array(in Berry.ProofOfWork) it sends the\\n    * invalidated value information to POS voting\\n    * @param _requestId being disputed\\n    * @param _timestamp being disputed\\n    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\\n    * requires 5 miners to submit a value.\\n    */\\n    function beginDispute(BerryStorage.BerryStorageStruct storage self, uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) public {\\n        BerryStorage.Request storage _request = self.requestDetails[_requestId];\\n        require(_request.minedBlockNum[_timestamp] != 0, \\\"Mined block is 0\\\");\\n        require(_minerIndex < 5, \\\"Miner index is wrong\\\");\\n\\n        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\\n        //provided by the party initiating the dispute\\n        address _miner = _request.minersByValue[_timestamp][_minerIndex];\\n        bytes32 _hash = keccak256(abi.encodePacked(_miner, _requestId, _timestamp));\\n\\n\\n\\n        //Increase the dispute count by 1\\n        uint256 disputeId = self.uintVars[keccak256(\\\"disputeCount\\\")] + 1;\\n        self.uintVars[keccak256(\\\"disputeCount\\\")] = disputeId;\\n\\n        //Sets the new disputeCount as the disputeId\\n\\n                //Ensures that a dispute is not already open for the that miner, requestId and timestamp\\n        uint256 hashId = self.disputeIdByDisputeHash[_hash];\\n        if(hashId != 0){\\n            self.disputesById[disputeId].disputeUintVars[keccak256(\\\"origID\\\")] = hashId;\\n\\n        }\\n        else{\\n            self.disputeIdByDisputeHash[_hash] = disputeId;\\n            hashId = disputeId;\\n        }\\n        uint256 origID = hashId;\\n        uint256 dispRounds = self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")] + 1;\\n        self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")] = dispRounds;\\n        self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds))] = disputeId;\\n        if(disputeId != origID){\\n            uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds-1))];\\n            require(self.disputesById[lastID].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] <= now, \\\"Dispute is already open\\\");\\n            if(self.disputesById[lastID].executed){\\n                require(now - self.disputesById[lastID].disputeUintVars[keccak256(\\\"tallyDate\\\")] <= 1 days, \\\"Time for voting haven't elapsed\\\");\\n            }\\n        }\\n        uint256 _fee;\\n        if (_minerIndex == 2) {\\n            self.requestDetails[_requestId].apiUintVars[keccak256(\\\"disputeCount\\\")] = self.requestDetails[_requestId].apiUintVars[keccak256(\\\"disputeCount\\\")] +1;\\n            //update dispute fee for this case\\n            _fee = self.uintVars[keccak256(\\\"stakeAmount\\\")]*self.requestDetails[_requestId].apiUintVars[keccak256(\\\"disputeCount\\\")];\\n        } else {\\n\\n            _fee = self.uintVars[keccak256(\\\"disputeFee\\\")] * dispRounds;\\n        }\\n\\n        //maps the dispute to the Dispute struct\\n        self.disputesById[disputeId] = BerryStorage.Dispute({\\n            hash: _hash,\\n            isPropFork: false,\\n            reportedMiner: _miner,\\n            reportingParty: msg.sender,\\n            proposedForkAddress: address(0),\\n            executed: false,\\n            disputeVotePassed: false,\\n            tally: 0\\n        });\\n\\n        //Saves all the dispute variables for the disputeId\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"requestId\\\")] = _requestId;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"timestamp\\\")] = _timestamp;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"value\\\")] = _request.valuesByTimestamp[_timestamp][_minerIndex];\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] = now + 2 days * dispRounds;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"blockNumber\\\")] = block.number;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minerSlot\\\")] = _minerIndex;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"fee\\\")] = _fee;\\n        BerryTransfer.doTransfer(self, msg.sender, address(this),_fee);\\n\\n   \\n\\n        //Values are sorted as they come in and the official value is the median of the first five\\n        //So the \\\"official value\\\" miner is always minerIndex==2. If the official value is being\\n        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\\n        if (_minerIndex == 2) {\\n            _request.inDispute[_timestamp] = true;\\n            _request.finalValues[_timestamp] = 0;\\n        }\\n        if (self.stakerDetails[_miner].currentStatus != 4){\\n            self.stakerDetails[_miner].currentStatus = 3;\\n        }\\n        emit NewDispute(disputeId, _requestId, _timestamp, _miner);\\n    }\\n\\n    /**\\n    * @dev Allows token holders to vote\\n    * @param _disputeId is the dispute id\\n    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\\n    */\\n    function vote(BerryStorage.BerryStorageStruct storage self, uint256 _disputeId, bool _supportsDispute) public {\\n        BerryStorage.Dispute storage disp = self.disputesById[_disputeId];\\n\\n        //Get the voteWeight or the balance of the user at the time/blockNumber the disupte began\\n        uint256 voteWeight = BerryTransfer.balanceOfAt(self, msg.sender, disp.disputeUintVars[keccak256(\\\"blockNumber\\\")]);\\n\\n        //Require that the msg.sender has not voted\\n        require(disp.voted[msg.sender] != true, \\\"Sender has already voted\\\");\\n\\n        //Requre that the user had a balance >0 at time/blockNumber the disupte began\\n        require(voteWeight != 0, \\\"User balance is 0\\\");\\n\\n        //ensures miners that are under dispute cannot vote\\n        require(self.stakerDetails[msg.sender].currentStatus != 3, \\\"Miner is under dispute\\\");\\n\\n        //Update user voting status to true\\n        disp.voted[msg.sender] = true;\\n\\n        //Update the number of votes for the dispute\\n        disp.disputeUintVars[keccak256(\\\"numberOfVotes\\\")] += 1;\\n\\n        //If the user supports the dispute increase the tally for the dispute by the voteWeight\\n        //otherwise decrease it\\n        if (_supportsDispute) {\\n            disp.tally = disp.tally.add(int256(voteWeight));\\n        } else {\\n            disp.tally = disp.tally.sub(int256(voteWeight));\\n        }\\n\\n        //Let the network know the user has voted on the dispute and their casted vote\\n        emit Voted(_disputeId, _supportsDispute, msg.sender, voteWeight);\\n    }\\n\\n    /**\\n    * @dev tallies the votes and locks the stake disbursement(currentStatus = 4) if the vote passes\\n    * @param _disputeId is the dispute id\\n    */\\n    function tallyVotes(BerryStorage.BerryStorageStruct storage self, uint256 _disputeId) public {\\n        BerryStorage.Dispute storage disp = self.disputesById[_disputeId];\\n\\n        //Ensure this has not already been executed/tallied\\n        require(disp.executed == false, \\\"Dispute has been already executed\\\");\\n        require(now >= disp.disputeUintVars[keccak256(\\\"minExecutionDate\\\")], \\\"Time for voting haven't elapsed\\\");\\n        require(disp.reportingParty != address(0), \\\"reporting Party is address 0\\\");\\n        int256  _tally = disp.tally;\\n        if (_tally > 0) {\\n            //Set the dispute state to passed/true\\n            disp.disputeVotePassed = true;\\n        }\\n        //If the vote is not a proposed fork\\n        if (disp.isPropFork == false) {\\n                //Ensure the time for voting has elapsed\\n                    BerryStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];\\n                    //If the vote for disputing a value is succesful(disp.tally >0) then unstake the reported\\n                    // miner and transfer the stakeAmount and dispute fee to the reporting party\\n                    if(stakes.currentStatus == 3){\\n                        stakes.currentStatus = 4;\\n                    }\\n        } else if (uint(_tally) >= ((self.uintVars[keccak256(\\\"total_supply\\\")] * 10) / 100)) {\\n            emit NewBerryAddress(disp.proposedForkAddress);\\n        }\\n        disp.disputeUintVars[keccak256(\\\"tallyDate\\\")] = now;\\n        disp.executed = true;\\n        emit DisputeVoteTallied(_disputeId, _tally, disp.reportedMiner, disp.reportingParty, disp.disputeVotePassed);\\n    }\\n\\n    /**\\n    * @dev Allows for a fork to be proposed\\n    * @param _propNewBerryAddress address for new proposed Berry\\n    */\\n    function proposeFork(BerryStorage.BerryStorageStruct storage self, address _propNewBerryAddress) public {\\n        bytes32 _hash = keccak256(abi.encode(_propNewBerryAddress));\\n        BerryTransfer.doTransfer(self, msg.sender, address(this), 100e18); //This is the fork fee (just 100 tokens flat, no refunds)\\n        self.uintVars[keccak256(\\\"disputeCount\\\")]++;\\n        uint256 disputeId = self.uintVars[keccak256(\\\"disputeCount\\\")];\\n        if(self.disputeIdByDisputeHash[_hash] != 0){\\n            self.disputesById[disputeId].disputeUintVars[keccak256(\\\"origID\\\")] = self.disputeIdByDisputeHash[_hash];\\n        }\\n        else{\\n            self.disputeIdByDisputeHash[_hash] = disputeId;\\n        }\\n        uint256 origID = self.disputeIdByDisputeHash[_hash];\\n\\n        self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")]++;\\n        uint256 dispRounds = self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")];\\n        self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds))] = disputeId;\\n        if(disputeId != origID){\\n            uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds-1))];\\n            require(self.disputesById[lastID].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] <= now, \\\"Dispute is already open\\\");\\n            if(self.disputesById[lastID].executed){\\n                require(now - self.disputesById[lastID].disputeUintVars[keccak256(\\\"tallyDate\\\")] <= 1 days, \\\"Time for voting haven't elapsed\\\");\\n            }\\n        }\\n        self.disputesById[disputeId] = BerryStorage.Dispute({\\n            hash: _hash,\\n            isPropFork: true,\\n            reportedMiner: msg.sender,\\n            reportingParty: msg.sender,\\n            proposedForkAddress: _propNewBerryAddress,\\n            executed: false,\\n            disputeVotePassed: false,\\n            tally: 0\\n        });\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"blockNumber\\\")] = block.number;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] = now + 7 days;\\n    }\\n\\n    /**\\n    * @dev Updates the Berry address after a proposed fork has \\n    * passed the vote and day has gone by without a dispute\\n    * @param _disputeId the disputeId for the proposed fork\\n    */\\n    function updateBerry(BerryStorage.BerryStorageStruct storage self, uint _disputeId) public {\\n        bytes32 _hash = self.disputesById[_disputeId].hash;\\n        uint256 origID = self.disputeIdByDisputeHash[_hash];\\n        uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")]))];\\n        BerryStorage.Dispute storage disp = self.disputesById[lastID];\\n        require(disp.disputeVotePassed == true, \\\"vote needs to pass\\\");\\n        require(now - disp.disputeUintVars[keccak256(\\\"tallyDate\\\")] > 1 days, \\\"Time for voting for further disputes has not passed\\\");\\n        self.addressVars[keccak256(\\\"berryContract\\\")] = disp.proposedForkAddress;\\n    }\\n\\n    /**\\n    * @dev Allows disputer to unlock the dispute fee\\n    * @param _disputeId to unlock fee from\\n    */\\n    function unlockDisputeFee (BerryStorage.BerryStorageStruct storage self, uint _disputeId) public {\\n        uint256 origID = self.disputeIdByDisputeHash[self.disputesById[_disputeId].hash];\\n        uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")]))];\\n        if(lastID == 0){\\n            lastID = origID;\\n        }\\n        BerryStorage.Dispute storage disp = self.disputesById[origID];\\n        BerryStorage.Dispute storage last = self.disputesById[lastID];\\n                //disputeRounds is increased by 1 so that the _id is not a negative number when it is the first time a dispute is initiated\\n        uint256 dispRounds = disp.disputeUintVars[keccak256(\\\"disputeRounds\\\")];\\n        if(dispRounds == 0){\\n          dispRounds = 1;  \\n        }\\n        uint256 _id;\\n        require(disp.disputeUintVars[keccak256(\\\"paid\\\")] == 0,\\\"already paid out\\\");\\n        require(now - last.disputeUintVars[keccak256(\\\"tallyDate\\\")] > 1 days, \\\"Time for voting haven't elapsed\\\");\\n        BerryStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];\\n        disp.disputeUintVars[keccak256(\\\"paid\\\")] = 1;\\n        if (last.disputeVotePassed == true){\\n                //Changing the currentStatus and startDate unstakes the reported miner and transfers the stakeAmount\\n                stakes.startDate = now - (now % 86400);\\n\\n                //Reduce the staker count\\n                self.uintVars[keccak256(\\\"stakerCount\\\")] -= 1;\\n\\n                //Update the minimum dispute fee that is based on the number of stakers \\n                updateMinDisputeFee(self);\\n                //Decreases the stakerCount since the miner's stake is being slashed\\n                if(stakes.currentStatus == 4){\\n                    stakes.currentStatus = 5;\\n                    BerryTransfer.doTransfer(self,disp.reportedMiner,disp.reportingParty,self.uintVars[keccak256(\\\"stakeAmount\\\")]);\\n                    stakes.currentStatus =0 ;\\n                }\\n                for(uint i = 0; i < dispRounds;i++){\\n                    _id = disp.disputeUintVars[keccak256(abi.encode(dispRounds-i))];\\n                    if(_id == 0){\\n                        _id = origID;\\n                    }\\n                    BerryStorage.Dispute storage disp2 = self.disputesById[_id];\\n                        //transfer fee adjusted based on number of miners if the minerIndex is not 2(official value)\\n                    BerryTransfer.doTransfer(self,address(this), disp2.reportingParty, disp2.disputeUintVars[keccak256(\\\"fee\\\")]);\\n                }\\n            }\\n            else {\\n                stakes.currentStatus = 1;\\n                BerryStorage.Request storage _request = self.requestDetails[disp.disputeUintVars[keccak256(\\\"requestId\\\")]];\\n                if(disp.disputeUintVars[keccak256(\\\"minerSlot\\\")] == 2) {\\n                    //note we still don't put timestamp back into array (is this an issue? (shouldn't be))\\n                  _request.finalValues[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] = disp.disputeUintVars[keccak256(\\\"value\\\")];\\n                }\\n                if (_request.inDispute[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] == true) {\\n                    _request.inDispute[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] = false;\\n                }\\n                for(uint i = 0; i < dispRounds;i++){\\n                    _id = disp.disputeUintVars[keccak256(abi.encode(dispRounds-i))];\\n                    if(_id != 0){\\n                        last = self.disputesById[_id];//handling if happens during an upgrade\\n                    }\\n                    BerryTransfer.doTransfer(self,address(this),last.reportedMiner,self.disputesById[_id].disputeUintVars[keccak256(\\\"fee\\\")]);\\n                }\\n            }\\n\\n            if (disp.disputeUintVars[keccak256(\\\"minerSlot\\\")] == 2) {\\n                self.requestDetails[disp.disputeUintVars[keccak256(\\\"requestId\\\")]].apiUintVars[keccak256(\\\"disputeCount\\\")]--;\\n            } \\n    }\\n\\n    /**\\n    * @dev This function upates the minimun dispute fee as a function of the amount\\n    * of staked miners\\n    */\\n    function updateMinDisputeFee(BerryStorage.BerryStorageStruct storage self) public {\\n        uint256 stakeAmount = self.uintVars[keccak256(\\\"stakeAmount\\\")];\\n        uint256 targetMiners = self.uintVars[keccak256(\\\"targetMiners\\\")];\\n        self.uintVars[keccak256(\\\"disputeFee\\\")] = SafeMath.max(15e18,\\n                (stakeAmount-(stakeAmount*(SafeMath.min(targetMiners,self.uintVars[keccak256(\\\"stakerCount\\\")])*1000)/\\n                targetMiners)/1000));\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/BerryGettersLibrary.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./BerryStorage.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\n\\n/**\\n* @title Berry Getters Library\\n* @dev This is the getter library for all variables in the Berry Tributes system. BerryGetters references this\\n* libary for the getters logic\\n*/\\nlibrary BerryGettersLibrary {\\n    using SafeMath for uint256;\\n\\n    event NewBerryAddress(address _newBerry); //emmited when a proposed fork is voted true\\n\\n    /*Functions*/\\n\\n    //The next two functions are onlyOwner functions.  For Berry to be truly decentralized, we will need to transfer the Deity to the 0 address.\\n    //Only needs to be in library\\n    /**\\n    * @dev This function allows us to set a new Deity (or remove it)\\n    * @param _newDeity address of the new Deity of the berry system\\n    */\\n    function changeDeity(BerryStorage.BerryStorageStruct storage self, address _newDeity) internal {\\n        require(self.addressVars[keccak256(\\\"_deity\\\")] == msg.sender, \\\"Sender is not deity\\\");\\n        self.addressVars[keccak256(\\\"_deity\\\")] = _newDeity;\\n    }\\n\\n    //Only needs to be in library\\n    /**\\n    * @dev This function allows the deity to upgrade the Berry System\\n    * @param _berryContract address of new updated BerryCore contract\\n    */\\n    function changeBerryContract(BerryStorage.BerryStorageStruct storage self, address _berryContract) internal {\\n        require(self.addressVars[keccak256(\\\"_deity\\\")] == msg.sender, \\\"Sender is not deity\\\");\\n        self.addressVars[keccak256(\\\"berryContract\\\")] = _berryContract;\\n        emit NewBerryAddress(_berryContract);\\n    }\\n\\n    /*Berry Getters*/\\n\\n    /**\\n    * @dev This function tells you if a given challenge has been completed by a given miner\\n    * @param _challenge the challenge to search for\\n    * @param _miner address that you want to know if they solved the challenge\\n    * @return true if the _miner address provided solved the\\n    */\\n    function didMine(BerryStorage.BerryStorageStruct storage self, bytes32 _challenge, address _miner) public view returns (bool) {\\n        return self.minersByChallenge[_challenge][_miner];\\n    }\\n\\n    /**\\n    * @dev Checks if an address voted in a dispute\\n    * @param _disputeId to look up\\n    * @param _address of voting party to look up\\n    * @return bool of whether or not party voted\\n    */\\n    function didVote(BerryStorage.BerryStorageStruct storage self, uint256 _disputeId, address _address) internal view returns (bool) {\\n        return self.disputesById[_disputeId].voted[_address];\\n    }\\n\\n    /**\\n    * @dev allows Berry to read data from the addressVars mapping\\n    * @param _data is the keccak256(\\\"variable_name\\\") of the variable that is being accessed.\\n    * These are examples of how the variables are saved within other functions:\\n    * addressVars[keccak256(\\\"_owner\\\")]\\n    * addressVars[keccak256(\\\"berryContract\\\")]\\n    * @return address requested\\n    */\\n    function getAddressVars(BerryStorage.BerryStorageStruct storage self, bytes32 _data) internal view returns (address) {\\n        return self.addressVars[_data];\\n    }\\n\\n    /**\\n    * @dev Gets all dispute variables\\n    * @param _disputeId to look up\\n    * @return bytes32 hash of dispute\\n    * @return bool executed where true if it has been voted on\\n    * @return bool disputeVotePassed\\n    * @return bool isPropFork true if the dispute is a proposed fork\\n    * @return address of reportedMiner\\n    * @return address of reportingParty\\n    * @return address of proposedForkAddress\\n    * @return uint of requestId\\n    * @return uint of timestamp\\n    * @return uint of value\\n    * @return uint of minExecutionDate\\n    * @return uint of numberOfVotes\\n    * @return uint of blocknumber\\n    * @return uint of minerSlot\\n    * @return uint of quorum\\n    * @return uint of fee\\n    * @return int count of the current tally\\n    */\\n    function getAllDisputeVars(BerryStorage.BerryStorageStruct storage self, uint256 _disputeId)\\n        internal\\n        view\\n        returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256)\\n    {\\n        BerryStorage.Dispute storage disp = self.disputesById[_disputeId];\\n        return (\\n            disp.hash,\\n            disp.executed,\\n            disp.disputeVotePassed,\\n            disp.isPropFork,\\n            disp.reportedMiner,\\n            disp.reportingParty,\\n            disp.proposedForkAddress,\\n            [\\n                disp.disputeUintVars[keccak256(\\\"requestId\\\")],\\n                disp.disputeUintVars[keccak256(\\\"timestamp\\\")],\\n                disp.disputeUintVars[keccak256(\\\"value\\\")],\\n                disp.disputeUintVars[keccak256(\\\"minExecutionDate\\\")],\\n                disp.disputeUintVars[keccak256(\\\"numberOfVotes\\\")],\\n                disp.disputeUintVars[keccak256(\\\"blockNumber\\\")],\\n                disp.disputeUintVars[keccak256(\\\"minerSlot\\\")],\\n                disp.disputeUintVars[keccak256(\\\"quorum\\\")],\\n                disp.disputeUintVars[keccak256(\\\"fee\\\")]\\n            ],\\n            disp.tally\\n        );\\n    }\\n\\n    /**\\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\\n    */\\n    function getCurrentVariables(BerryStorage.BerryStorageStruct storage self)\\n        internal\\n        view\\n        returns (bytes32, uint256, uint256, string memory, uint256, uint256)\\n    {\\n        return (\\n            self.currentChallenge,\\n            self.uintVars[keccak256(\\\"currentRequestId\\\")],\\n            self.uintVars[keccak256(\\\"difficulty\\\")],\\n            self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].queryString,\\n            self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].apiUintVars[keccak256(\\\"granularity\\\")],\\n            self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].apiUintVars[keccak256(\\\"totalTip\\\")]\\n        );\\n    }\\n\\n    /**\\n    * @dev Checks if a given hash of miner,requestId has been disputed\\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\\n    * @return uint disputeId\\n    */\\n    function getDisputeIdByDisputeHash(BerryStorage.BerryStorageStruct storage self, bytes32 _hash) internal view returns (uint256) {\\n        return self.disputeIdByDisputeHash[_hash];\\n    }\\n\\n    /**\\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\\n    * @param _disputeId is the dispute id;\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the disputeUintVars under the Dispute struct\\n    * @return uint value for the bytes32 data submitted\\n    */\\n    function getDisputeUintVars(BerryStorage.BerryStorageStruct storage self, uint256 _disputeId, bytes32 _data)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.disputesById[_disputeId].disputeUintVars[_data];\\n    }\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @return value for timestamp of last proof of work submited\\n    * @return true if the is a timestamp for the lastNewValue\\n    */\\n    function getLastNewValue(BerryStorage.BerryStorageStruct storage self) internal view returns (uint256, bool) {\\n        return (\\n            retrieveData(\\n                self,\\n                self.requestIdByTimestamp[self.uintVars[keccak256(\\\"timeOfLastNewValue\\\")]],\\n                self.uintVars[keccak256(\\\"timeOfLastNewValue\\\")]\\n            ),\\n            true\\n        );\\n    }\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @param _requestId being requested\\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\\n    */\\n    function getLastNewValueById(BerryStorage.BerryStorageStruct storage self, uint256 _requestId) internal view returns (uint256, bool) {\\n        BerryStorage.Request storage _request = self.requestDetails[_requestId];\\n        if (_request.requestTimestamps.length != 0) {\\n            return (retrieveData(self, _requestId, _request.requestTimestamps[_request.requestTimestamps.length - 1]), true);\\n        } else {\\n            return (0, false);\\n        }\\n    }\\n\\n    /**\\n    * @dev Gets blocknumber for mined timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up blocknumber\\n    * @return uint of the blocknumber which the dispute was mined\\n    */\\n    function getMinedBlockNum(BerryStorage.BerryStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.requestDetails[_requestId].minedBlockNum[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return the 5 miners' addresses\\n    */\\n    function getMinersByRequestIdAndTimestamp(BerryStorage.BerryStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\\n        internal\\n        view\\n        returns (address[5] memory)\\n    {\\n        return self.requestDetails[_requestId].minersByValue[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Counts the number of values that have been submited for the request\\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\\n    * request so far\\n    * @param _requestId the requestId to look up\\n    * @return uint count of the number of values received for the requestId\\n    */\\n    function getNewValueCountbyRequestId(BerryStorage.BerryStorageStruct storage self, uint256 _requestId) internal view returns (uint256) {\\n        return self.requestDetails[_requestId].requestTimestamps.length;\\n    }\\n\\n    /**\\n    * @dev Getter function for the specified requestQ index\\n    * @param _index to look up in the requestQ array\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByRequestQIndex(BerryStorage.BerryStorageStruct storage self, uint256 _index) internal view returns (uint256) {\\n        require(_index <= 50, \\\"RequestQ index is above 50\\\");\\n        return self.requestIdByRequestQIndex[_index];\\n    }\\n\\n    /**\\n    * @dev Getter function for requestId based on timestamp\\n    * @param _timestamp to check requestId\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByTimestamp(BerryStorage.BerryStorageStruct storage self, uint256 _timestamp) internal view returns (uint256) {\\n        return self.requestIdByTimestamp[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Getter function for requestId based on the qeuaryHash\\n    * @param _queryHash hash(of string api and granularity) to check if a request already exists\\n    * @return uint requestId\\n    */\\n    function getRequestIdByQueryHash(BerryStorage.BerryStorageStruct storage self, bytes32 _queryHash) internal view returns (uint256) {\\n        return self.requestIdByQueryHash[_queryHash];\\n    }\\n\\n    /**\\n    * @dev Getter function for the requestQ array\\n    * @return the requestQ arrray\\n    */\\n    function getRequestQ(BerryStorage.BerryStorageStruct storage self) internal view returns (uint256[51] memory) {\\n        return self.requestQ;\\n    }\\n\\n    /**\\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\\n    * for the requestId specified\\n    * @param _requestId to look up\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the apiUintVars under the requestDetails struct\\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\\n    */\\n    function getRequestUintVars(BerryStorage.BerryStorageStruct storage self, uint256 _requestId, bytes32 _data)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.requestDetails[_requestId].apiUintVars[_data];\\n    }\\n\\n    /**\\n    * @dev Gets the API struct variables that are not mappings\\n    * @param _requestId to look up\\n    * @return string of api to query\\n    * @return string of symbol of api to query\\n    * @return bytes32 hash of string\\n    * @return bytes32 of the granularity(decimal places) requested\\n    * @return uint of index in requestQ array\\n    * @return uint of current payout/tip for this requestId\\n    */\\n    function getRequestVars(BerryStorage.BerryStorageStruct storage self, uint256 _requestId)\\n        internal\\n        view\\n        returns (string memory, string memory, bytes32, uint256, uint256, uint256)\\n    {\\n        BerryStorage.Request storage _request = self.requestDetails[_requestId];\\n        return (\\n            _request.queryString,\\n            _request.dataSymbol,\\n            _request.queryHash,\\n            _request.apiUintVars[keccak256(\\\"granularity\\\")],\\n            _request.apiUintVars[keccak256(\\\"requestQPosition\\\")],\\n            _request.apiUintVars[keccak256(\\\"totalTip\\\")]\\n        );\\n    }\\n\\n    /**\\n    * @dev This function allows users to retireve all information about a staker\\n    * @param _staker address of staker inquiring about\\n    * @return uint current state of staker\\n    * @return uint startDate of staking\\n    */\\n    function getStakerInfo(BerryStorage.BerryStorageStruct storage self, address _staker) internal view returns (uint256, uint256) {\\n        return (self.stakerDetails[_staker].currentStatus, self.stakerDetails[_staker].startDate);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestampt to look up miners for\\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\\n    */\\n    function getSubmissionsByTimestamp(BerryStorage.BerryStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\\n        internal\\n        view\\n        returns (uint256[5] memory)\\n    {\\n        return self.requestDetails[_requestId].valuesByTimestamp[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Gets the timestamp for the value based on their index\\n    * @param _requestID is the requestId to look up\\n    * @param _index is the value index to look up\\n    * @return uint timestamp\\n    */\\n    function getTimestampbyRequestIDandIndex(BerryStorage.BerryStorageStruct storage self, uint256 _requestID, uint256 _index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.requestDetails[_requestID].requestTimestamps[_index];\\n    }\\n\\n    /**\\n    * @dev Getter for the variables saved under the BerryStorageStruct uintVars variable\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the uintVars under the BerryStorageStruct struct\\n    * This is an example of how data is saved into the mapping within other functions:\\n    * self.uintVars[keccak256(\\\"stakerCount\\\")]\\n    * @return uint of specified variable\\n    */\\n    function getUintVar(BerryStorage.BerryStorageStruct storage self, bytes32 _data) internal view returns (uint256) {\\n        return self.uintVars[_data];\\n    }\\n\\n    /**\\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\\n    */\\n    function getVariablesOnDeck(BerryStorage.BerryStorageStruct storage self) internal view returns (uint256, uint256, string memory) {\\n        uint256 newRequestId = getTopRequestID(self);\\n        return (\\n            newRequestId,\\n            self.requestDetails[newRequestId].apiUintVars[keccak256(\\\"totalTip\\\")],\\n            self.requestDetails[newRequestId].queryString\\n        );\\n    }\\n\\n    /**\\n    * @dev Getter function for the request with highest payout. This function is used within the getVariablesOnDeck function\\n    * @return uint _requestId of request with highest payout at the time the function is called\\n    */\\n    function getTopRequestID(BerryStorage.BerryStorageStruct storage self) internal view returns (uint256 _requestId) {\\n        uint256 _max;\\n        uint256 _index;\\n        (_max, _index) = Utilities.getMax(self.requestQ);\\n        _requestId = self.requestIdByRequestQIndex[_index];\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to looku p\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return bool true if requestId/timestamp is under dispute\\n    */\\n    function isInDispute(BerryStorage.BerryStorageStruct storage self, uint256 _requestId, uint256 _timestamp) internal view returns (bool) {\\n        return self.requestDetails[_requestId].inDispute[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Retreive value from oracle based on requestId/timestamp\\n    * @param _requestId being requested\\n    * @param _timestamp to retreive data/value from\\n    * @return uint value for requestId/timestamp submitted\\n    */\\n    function retrieveData(BerryStorage.BerryStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.requestDetails[_requestId].finalValues[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Getter for the total_supply of oracle tokens\\n    * @return uint total supply\\n    */\\n    function totalSupply(BerryStorage.BerryStorageStruct storage self) internal view returns (uint256) {\\n        return self.uintVars[keccak256(\\\"total_supply\\\")];\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/BerryStake.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\nimport \\\"./BerryStorage.sol\\\";\\nimport \\\"./BerryTransfer.sol\\\";\\nimport \\\"./BerryDispute.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\n/**\\n* itle Berry Stake\\n* @dev Contains the methods related to miners staking and unstaking. Berry.sol\\n* references this library for function's logic.\\n*/\\n\\nlibrary BerryStake {\\n    event NewStake(address indexed _sender); //Emits upon new staker\\n    event StakeWithdrawn(address indexed _sender); //Emits when a staker is now no longer staked\\n    event StakeWithdrawRequested(address indexed _sender); //Emits when a staker begins the 7 day withdraw period\\n\\n    /*Functions*/\\n\\n    /**\\n    * @dev This function stakes the five initial miners, sets the supply and all the constant variables.\\n    * This function is called by the constructor function on BerryMaster.sol\\n    */\\n    function init(BerryStorage.BerryStorageStruct storage self) public {\\n        require(self.uintVars[keccak256(\\\"decimals\\\")] == 0, \\\"Too many decimals\\\");\\n        //Give this contract 6000 Berry Tributes so that it can stake the initial 6 miners\\n        BerryTransfer.updateBalanceAtNow(self.balances[address(this)], 5000000e18);\\n\\n        // //the initial 5 miner addresses are specfied below\\n        // //changed payable[5] to 6\\n        address payable[6] memory _initalMiners = [\\naddress(0x1b906684efa10C536E4ADbAB63489acE94fE0724),\\naddress(0x12d13EA7869eCBFE703Fb77C0259614b8b927b62),\\naddress(0x1ca1Cd7FB013DEd91B24403B008C5E65C8367E1d),\\naddress(0x95676256f152D3b0E1511a1ED00617aF34FBcC13),\\naddress(0x1d49038242c9CCd299543a765fdf927d0c05F37d),\\naddress(0x18358A7d4A72fAe65d0b30c80CC85CD2332243E3)\\n        ];\\n        //Stake each of the 5 miners specified above\\n        for (uint256 i = 0; i < 6; i++) {\\n            //6th miner to allow for dispute\\n            //Miner balance is set at 1000e18 at the block that this function is ran\\n            BerryTransfer.updateBalanceAtNow(self.balances[_initalMiners[i]], 1000e18);\\n\\n            newStake(self, _initalMiners[i]);\\n        }\\n\\n        // for add tip, if accounts[0] will overwrite 1000 staking\\n        BerryTransfer.updateBalanceAtNow(self.balances[msg.sender], 10000e18);\\n        \\n        // for Mining liquidity 1875000 + for IFO 2000000\\n        BerryTransfer.updateBalanceAtNow(self.balances[address(0xa2Dd53Cdf42C49963BD8d4E505d7C921b6558F61)], 3875000e18);\\n        // for Ecosystem data 2875000 - 6000(6 miners staking) - 10000(for add tip)\\n        BerryTransfer.updateBalanceAtNow(self.balances[address(0x55d166E9b4b20352c18D66BdcC828eD4A9113C19)], 2859000e18);\\n        // for Team, will vesting for 2 years\\n        BerryTransfer.updateBalanceAtNow(self.balances[address(0x8342DD495b3aE442BB3615f4779D6db0E85eBD48)], 750000e18);\\n\\n        //update the total suppply\\n        self.uintVars[keccak256(\\\"total_supply\\\")] += 7500000e18; //6th miner to allow for dispute\\n        //set Constants\\n        self.uintVars[keccak256(\\\"decimals\\\")] = 18;\\n        self.uintVars[keccak256(\\\"targetMiners\\\")] = 200;\\n        self.uintVars[keccak256(\\\"stakeAmount\\\")] = 1000e18;\\n        self.uintVars[keccak256(\\\"disputeFee\\\")] = 970e18;\\n        self.uintVars[keccak256(\\\"timeTarget\\\")] = 180;\\n        self.uintVars[keccak256(\\\"timeOfLastNewValue\\\")] = now - (now % self.uintVars[keccak256(\\\"timeTarget\\\")]);\\n        self.uintVars[keccak256(\\\"difficulty\\\")] = 1;\\n        self.uintVars[keccak256(\\\"height\\\")] = 0;\\n    }\\n\\n    /**\\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\\n    * can withdraw the deposit\\n    */\\n    function requestStakingWithdraw(BerryStorage.BerryStorageStruct storage self) public {\\n        BerryStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\\n        //Require that the miner is staked\\n        require(stakes.currentStatus == 1, \\\"Miner is not staked\\\");\\n\\n        //Change the miner staked to locked to be withdrawStake\\n        stakes.currentStatus = 2;\\n\\n        //Change the startDate to now since the lock up period begins now\\n        //and the miner can only withdraw 7 days later from now(check the withdraw function)\\n        stakes.startDate = now - (now % 86400);\\n\\n        //Reduce the staker count\\n        self.uintVars[keccak256(\\\"stakerCount\\\")] -= 1;\\n\\n        //Update the minimum dispute fee that is based on the number of stakers \\n        BerryDispute.updateMinDisputeFee(self);\\n        emit StakeWithdrawRequested(msg.sender);\\n    }\\n\\n    /**\\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\\n    */\\n    function withdrawStake(BerryStorage.BerryStorageStruct storage self) public {\\n        BerryStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\\n        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have\\n        //passed by since they locked for withdraw\\n        require(now - (now % 86400) - stakes.startDate >= 7 days, \\\"7 days didn't pass\\\");\\n        require(stakes.currentStatus == 2, \\\"Miner was not locked for withdrawal\\\");\\n        stakes.currentStatus = 0;\\n        emit StakeWithdrawn(msg.sender);\\n    }\\n\\n    /**\\n    * @dev This function allows miners to deposit their stake.\\n    */\\n    function depositStake(BerryStorage.BerryStorageStruct storage self) public {\\n        newStake(self, msg.sender);\\n        //self adjusting disputeFee\\n        BerryDispute.updateMinDisputeFee(self);\\n    }\\n\\n    /**\\n    * @dev This function is used by the init function to succesfully stake the initial 5 miners.\\n    * The function updates their status/state and status start date so they are locked it so they can't withdraw\\n    * and updates the number of stakers in the system.\\n    */\\n    function newStake(BerryStorage.BerryStorageStruct storage self, address staker) internal {\\n        require(BerryTransfer.balanceOf(self, staker) >= self.uintVars[keccak256(\\\"stakeAmount\\\")], \\\"Balance is lower than stake amount\\\");\\n        //Ensure they can only stake if they are not currrently staked or if their stake time frame has ended\\n        //and they are currently locked for witdhraw\\n        require(self.stakerDetails[staker].currentStatus == 0 || self.stakerDetails[staker].currentStatus == 2, \\\"Miner is in the wrong state\\\");\\n        self.uintVars[keccak256(\\\"stakerCount\\\")] += 1;\\n        self.stakerDetails[staker] = BerryStorage.StakeInfo({\\n            currentStatus: 1, //this resets their stake start date to today\\n            startDate: now - (now % 86400)\\n        });\\n        emit NewStake(staker);\\n    }\\n\\n    /**\\n    * @dev Getter function for the requestId being mined \\n    * @return variables for the current minin event: Challenge, 5 RequestId, difficulty and Totaltips\\n    */\\n    function getNewCurrentVariables(BerryStorage.BerryStorageStruct storage self) internal view returns(bytes32 _challenge,uint[5] memory _requestIds,uint256 _difficulty, uint256 _tip){\\n        for(uint i=0;i<5;i++){\\n            _requestIds[i] =  self.currentMiners[i].value;\\n        }\\n        return (self.currentChallenge,_requestIds,self.uintVars[keccak256(\\\"difficulty\\\")],self.uintVars[keccak256(\\\"currentTotalTips\\\")]);\\n    }\\n\\n    /**\\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\\n    * @return onDeck/info on top 5 requests(highest payout)-- RequestId, Totaltips\\n    */\\n    function getNewVariablesOnDeck(BerryStorage.BerryStorageStruct storage self) internal view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck) {\\n        idsOnDeck = getTopRequestIDs(self);\\n        for(uint i = 0;i<5;i++){\\n            tipsOnDeck[i] = self.requestDetails[idsOnDeck[i]].apiUintVars[keccak256(\\\"totalTip\\\")];\\n        }\\n    }\\n    \\n    /**\\n    * @dev Getter function for the top 5 requests with highest payouts. This function is used within the getNewVariablesOnDeck function\\n    * @return uint256[5] is an array with the top 5(highest payout) _requestIds at the time the function is called\\n    */\\n    function getTopRequestIDs(BerryStorage.BerryStorageStruct storage self) internal view returns (uint256[5] memory _requestIds) {\\n        uint256[5] memory _max;\\n        uint256[5] memory _index;\\n        (_max, _index) = Utilities.getMax5(self.requestQ);\\n        for(uint i=0;i<5;i++){\\n            if(_max[i] != 0){\\n                _requestIds[i] = self.requestIdByRequestQIndex[_index[i]];\\n            }\\n            else{\\n                _requestIds[i] = self.currentMiners[4-i].value;\\n            }\\n        }\\n    }\\n\\n\\n   \\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/BerryStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Berry Oracle Storage Library\\n * @dev Contains all the variables/structs used by Berry\\n */\\n\\nlibrary BerryStorage {\\n    //Internal struct for use in proof-of-work submission\\n    struct Details {\\n        uint256 value;\\n        address miner;\\n    }\\n\\n    struct Dispute {\\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\\n        int256 tally; //current tally of votes for - against measure\\n        bool executed; //is the dispute settled\\n        bool disputeVotePassed; //did the vote pass?\\n        bool isPropFork; //true for fork proposal NEW\\n        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\\n        address proposedForkAddress; //new fork address (if fork proposal)\\n        mapping(bytes32 => uint256) disputeUintVars;\\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\\n        //e.g. BerryStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\\\"requestId\\\")]\\n        //These are the variables saved in this mapping:\\n        // uint keccak256(\\\"requestId\\\");//apiID of disputed value\\n        // uint keccak256(\\\"timestamp\\\");//timestamp of distputed value\\n        // uint keccak256(\\\"value\\\"); //the value being disputed\\n        // uint keccak256(\\\"minExecutionDate\\\");//7 days from when dispute initialized\\n        // uint keccak256(\\\"numberOfVotes\\\");//the number of parties who have voted on the measure\\n        // uint keccak256(\\\"blockNumber\\\");// the blocknumber for which votes will be calculated from\\n        // uint keccak256(\\\"minerSlot\\\"); //index in dispute array\\n        // uint keccak256(\\\"fee\\\"); //fee paid corresponding to dispute\\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\\n    }\\n\\n    struct StakeInfo {\\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\\n        uint256 startDate; //stake start date\\n    }\\n\\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\\n    struct Checkpoint {\\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\\n        uint128 value; // value is the amount of tokens at a specific block number\\n    }\\n\\n    struct Request {\\n        string queryString; //id to string api\\n        string dataSymbol; //short name for api request\\n        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\\n        mapping(bytes32 => uint256) apiUintVars;\\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\\\"totalTip\\\")]\\n        //These are the variables saved in this mapping:\\n        // uint keccak256(\\\"granularity\\\"); //multiplier for miners\\n        // uint keccak256(\\\"requestQPosition\\\"); //index in requestQ\\n        // uint keccak256(\\\"totalTip\\\");//bonus portion of payout\\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\\n        mapping(uint256 => uint256) finalValues;\\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\\n        mapping(uint256 => address[5]) minersByValue;\\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\\n    }\\n\\n    struct BerryStorageStruct {\\n        bytes32 currentChallenge; //current challenge to be solved\\n        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\\n        uint256[] newValueTimestamps; //array of all timestamps requested\\n        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\\n        mapping(bytes32 => address) addressVars;\\n        //Address fields in the Berry contract are saved the addressVars mapping\\n        //e.g. addressVars[keccak256(\\\"berryContract\\\")] = address\\n        //These are the variables saved in this mapping:\\n        // address keccak256(\\\"berryContract\\\");//Berry address\\n        // address  keccak256(\\\"_owner\\\");//Berry Owner address\\n        // address  keccak256(\\\"_deity\\\");//Berry Owner that can do things at will\\n        // address  keccak256(\\\"pending_owner\\\"); // The proposed new owner\\n        mapping(bytes32 => uint256) uintVars;\\n        //uint fields in the Berry contract are saved the uintVars mapping\\n        //e.g. uintVars[keccak256(\\\"decimals\\\")] = uint\\n        //These are the variables saved in this mapping:\\n        // keccak256(\\\"decimals\\\");    //18 decimal standard ERC20\\n        // keccak256(\\\"disputeFee\\\");//cost to dispute a mined value\\n        // keccak256(\\\"disputeCount\\\");//totalHistoricalDisputes\\n        // keccak256(\\\"total_supply\\\"); //total_supply of the token in circulation\\n        // keccak256(\\\"stakeAmount\\\");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\\n        // keccak256(\\\"stakerCount\\\"); //number of parties currently staked\\n        // keccak256(\\\"timeOfLastNewValue\\\"); // time of last challenge solved\\n        // keccak256(\\\"difficulty\\\"); // Difficulty of current block\\n        // keccak256(\\\"currentTotalTips\\\"); //value of highest api/timestamp PayoutPool\\n        // keccak256(\\\"currentRequestId\\\"); //API being mined--updates with the ApiOnQ Id\\n        // keccak256(\\\"requestCount\\\"); // total number of requests through the system\\n        // keccak256(\\\"slotProgress\\\");//Number of miners who have mined this value so far\\n        // keccak256(\\\"miningReward\\\");//Mining Reward in PoWo tokens given to all miners per value\\n        // keccak256(\\\"timeTarget\\\"); //The time between blocks (mined Oracle values)\\n        // keccak256(\\\"_tBlock\\\"); //\\n        // keccak256(\\\"runningTips\\\"); // VAriable to track running tips\\n        // keccak256(\\\"currentReward\\\"); // The current reward\\n        // keccak256(\\\"devShare\\\"); // The amount directed towards th devShare\\n        // keccak256(\\\"currentTotalTips\\\"); //\\n        // keccak256(\\\"height\\\");\\n        \\n        //This is a boolean that tells you if a given challenge has been completed by a given miner\\n        mapping(bytes32 => mapping(address => bool)) minersByChallenge;\\n        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\\n        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\\n        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\\n        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\\n        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\\n        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\\n        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\\n        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\\n        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/BerryTransfer.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./BerryStorage.sol\\\";\\n\\n/**\\n* @title Berry Transfer\\n* @dev Contains the methods related to transfers and ERC20. Berry.sol and BerryGetters.sol\\n* reference this library for function's logic.\\n*/\\nlibrary BerryTransfer {\\n    using SafeMath for uint256;\\n\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //ERC20 Approval event\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value); //ERC20 Transfer Event\\n\\n    bytes32 public constant stakeAmount = 0x7be108969d31a3f0b261465c71f2b0ba9301cd914d55d9091c3b36a49d4d41b2; //keccak256(\\\"stakeAmount\\\")\\n\\n    /*Functions*/\\n\\n    /**\\n    * @dev Allows for a transfer of tokens to _to\\n    * @param _to The address to send tokens to\\n    * @param _amount The amount of tokens to send\\n    * @return true if transfer is successful\\n    */\\n    function transfer(BerryStorage.BerryStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\\n        doTransfer(self, msg.sender, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n    * @notice Send _amount tokens to _to from _from on the condition it\\n    * is approved by _from\\n    * @param _from The address holding the tokens being transferred\\n    * @param _to The address of the recipient\\n    * @param _amount The amount of tokens to be transferred\\n    * @return True if the transfer was successful\\n    */\\n    function transferFrom(BerryStorage.BerryStorageStruct storage self, address _from, address _to, uint256 _amount)\\n        public\\n        returns (bool success)\\n    {\\n        require(self.allowed[_from][msg.sender] >= _amount, \\\"Allowance is wrong\\\");\\n        self.allowed[_from][msg.sender] -= _amount;\\n        doTransfer(self, _from, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev This function approves a _spender an _amount of tokens to use\\n    * @param _spender address\\n    * @param _amount amount the spender is being approved for\\n    * @return true if spender appproved successfully\\n    */\\n    function approve(BerryStorage.BerryStorageStruct storage self, address _spender, uint256 _amount) public returns (bool) {\\n        require(_spender != address(0), \\\"Spender is 0-address\\\");\\n        require(self.allowed[msg.sender][_spender] == 0 || _amount == 0, \\\"Spender is already approved\\\");\\n        self.allowed[msg.sender][_spender] = _amount;\\n        emit Approval(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n    * @param _user address of party with the balance\\n    * @param _spender address of spender of parties said balance\\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\\n    */\\n    function allowance(BerryStorage.BerryStorageStruct storage self, address _user, address _spender) public view returns (uint256) {\\n        return self.allowed[_user][_spender];\\n    }\\n\\n    /**\\n    * @dev Completes POWO transfers by updating the balances on the current block number\\n    * @param _from address to transfer from\\n    * @param _to addres to transfer to\\n    * @param _amount to transfer\\n    */\\n    function doTransfer(BerryStorage.BerryStorageStruct storage self, address _from, address _to, uint256 _amount) public {\\n        require(_amount != 0, \\\"Tried to send non-positive amount\\\");\\n        require(_to != address(0), \\\"Receiver is 0 address\\\");\\n        require(allowedToTrade(self, _from, _amount), \\\"Should have sufficient balance to trade\\\");\\n        uint256 previousBalance = balanceOf(self, _from);\\n        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\\n        previousBalance = balanceOf(self,_to);\\n        require(previousBalance + _amount >= previousBalance, \\\"Overflow happened\\\"); // Check for overflow\\n        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n    /**\\n    * @dev Gets balance of owner specified\\n    * @param _user is the owner address used to look up the balance\\n    * @return Returns the balance associated with the passed in _user\\n    */\\n    function balanceOf(BerryStorage.BerryStorageStruct storage self, address _user) public view returns (uint256) {\\n        return balanceOfAt(self, _user, block.number);\\n    }\\n\\n    /**\\n    * @dev Queries the balance of _user at a specific _blockNumber\\n    * @param _user The address from which the balance will be retrieved\\n    * @param _blockNumber The block number when the balance is queried\\n    * @return The balance at _blockNumber specified\\n    */\\n    function balanceOfAt(BerryStorage.BerryStorageStruct storage self, address _user, uint256 _blockNumber) public view returns (uint256) {\\n        BerryStorage.Checkpoint[] storage checkpoints = self.balances[_user];\\n        if (checkpoints.length == 0|| checkpoints[0].fromBlock > _blockNumber) {\\n            return 0;\\n        } else {\\n            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock) return checkpoints[checkpoints.length - 1].value;\\n            // Binary search of the value in the array\\n            uint256 min = 0;\\n            uint256 max = checkpoints.length - 2;\\n            while (max > min) {\\n                uint256 mid = (max + min + 1) / 2;\\n                if  (checkpoints[mid].fromBlock ==_blockNumber){\\n                    return checkpoints[mid].value;\\n                }else if(checkpoints[mid].fromBlock < _blockNumber) {\\n                    min = mid;\\n                } else {\\n                    max = mid - 1;\\n                }\\n            }\\n            return checkpoints[min].value;\\n        }\\n    }\\n    /**\\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\\n    * and removing the staked amount from their balance if they are staked\\n    * @param _user address of user\\n    * @param _amount to check if the user can spend\\n    * @return true if they are allowed to spend the amount being checked\\n    */\\n    function allowedToTrade(BerryStorage.BerryStorageStruct storage self, address _user, uint256 _amount) public view returns (bool) { \\n        if (self.stakerDetails[_user].currentStatus != 0 && self.stakerDetails[_user].currentStatus < 5) {\\n            //Subtracts the stakeAmount from balance if the _user is staked\\n            if (balanceOf(self, _user)- self.uintVars[stakeAmount] >= _amount) {\\n                return true;\\n            }\\n            return false;\\n        } \\n        return (balanceOf(self, _user) >= _amount);\\n    }\\n\\n    /**\\n    * @dev Updates balance for from and to on the current block number via doTransfer\\n    * @param checkpoints gets the mapping for the balances[owner]\\n    * @param _value is the new balance\\n    */\\n    function updateBalanceAtNow(BerryStorage.Checkpoint[] storage checkpoints, uint256 _value) public {\\n        if (checkpoints.length == 0 || checkpoints[checkpoints.length - 1].fromBlock != block.number) {\\n           checkpoints.push(BerryStorage.Checkpoint({\\n                fromBlock : uint128(block.number),\\n                value : uint128(_value)\\n            }));\\n        } else {\\n            BerryStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\\n            oldCheckPoint.value = uint128(_value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b > 0) {\\n            c = a + b;\\n            assert(c >= a);\\n        } else {\\n            c = a + b;\\n            assert(c <= a);\\n        }\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function max(int256 a, int256 b) internal pure returns (uint256) {\\n        return a > b ? uint256(a) : uint256(b);\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        assert(a == 0 || c / a == b);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b > 0) {\\n            c = a - b;\\n            assert(c <= a);\\n        } else {\\n            c = a - b;\\n            assert(c >= a);\\n        }\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/Utilities.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n//Functions for retrieving min and Max in 51 length array (requestQ)\\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\\n\\nlibrary Utilities {\\n    /**\\n    * @dev Returns the max value in an array.\\n    * The zero position here is ignored. It's because \\n    * there's no null in solidity and we map each address \\n    * to an index in this array. So when we get 51 parties, \\n    * and one person is kicked out of the top 50, we \\n    * assign them a 0, and when you get mined and pulled \\n    * out of the top 50, also a 0. So then lot's of parties \\n    * will have zero as the index so we made the array run \\n    * from 1-51 with zero as nothing.\\n    * @param data is the array to calculate max from\\n    * @return max amount and its index within the array\\n    */\\n    function getMax(uint256[51] memory data) internal pure returns (uint256 max, uint256 maxIndex) {\\n        maxIndex = 1;\\n        max = data[maxIndex];\\n        for (uint256 i = 2; i < data.length; i++) {\\n            if (data[i] > max) {\\n                max = data[i];\\n                maxIndex = i;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Returns the minimum value in an array.\\n    * @param data is the array to calculate min from\\n    * @return min amount and its index within the array\\n    */\\n    function getMin(uint256[51] memory data) internal pure returns (uint256 min, uint256 minIndex) {\\n        minIndex = data.length - 1;\\n        min = data[minIndex];\\n        for (uint256 i = data.length - 2; i > 0; i--) {\\n            if (data[i] < min) {\\n                min = data[i];\\n                minIndex = i;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Returns the 5 requestsId's with the top payouts in an array.\\n    * @param data is the array to get the top 5 from\\n    * @return to 5 max amounts and their respective index within the array\\n    */\\n    function getMax5(uint256[51] memory data) internal pure returns (uint256[5] memory max, uint256[5] memory maxIndex) {\\n        uint256 min5 = data[1];\\n        uint256 minI = 0;\\n        for(uint256 j=0;j<5;j++){\\n            max[j]= data[j+1];//max[0]=data[1]\\n            maxIndex[j] = j+1;//maxIndex[0]= 1\\n            if(max[j] < min5){\\n                min5 = max[j];\\n                minI = j;\\n            }\\n        }\\n        for(uint256 i = 6; i < data.length; i++) {\\n            if (data[i] > min5) {\\n                max[minI] = data[i];\\n                maxIndex[minI] = i;\\n                min5 = data[i];\\n                for(uint256 j=0;j<5;j++){\\n                    if(max[j] < min5){\\n                        min5 = max[j];\\n                        minI = j;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/BerryTransfer.sol\": {\r\n        \"BerryTransfer\": \"0x93DbC20622631e3F819a7ab996ccF68326Cc21E9\"\r\n      },\r\n      \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/BerryGettersLibrary.sol\": {\r\n        \"BerryGettersLibrary\": \"0x63A8488900D1dcE6878C4ac9C2EA6cf7DA7f212b\"\r\n      },\r\n      \"/home/ubuntu/v2/bsc/BerryCore/contracts/libraries/BerryStake.sol\": {\r\n        \"BerryStake\": \"0xE4b404183DDB6416C42a9f22b1B8d58Dd033f4A4\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_berryContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newBerry\",\"type\":\"address\"}],\"name\":\"NewBerryAddress\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allowedToTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_berryContract\",\"type\":\"address\"}],\"name\":\"changeBerryContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDeity\",\"type\":\"address\"}],\"name\":\"changeDeity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_challenge\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"}],\"name\":\"didMine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"didVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getAddressVars\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"getAllDisputeVars\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentVariables\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getDisputeIdByDisputeHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getDisputeUintVars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastNewValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getLastNewValueById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinedBlockNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinersByRequestIdAndTimestamp\",\"outputs\":[{\"internalType\":\"address[5]\",\"name\":\"\",\"type\":\"address[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getNewValueCountbyRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_request\",\"type\":\"bytes32\"}],\"name\":\"getRequestIdByQueryHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getRequestIdByRequestQIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getRequestIdByTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRequestQ\",\"outputs\":[{\"internalType\":\"uint256[51]\",\"name\":\"\",\"type\":\"uint256[51]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getRequestUintVars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestVars\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStakerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getSubmissionsByTimestamp\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyRequestIDandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getUintVar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVariablesOnDeck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BerryMaster", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000089c0be3d87e0f28073390e997527d765f9384ed4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}