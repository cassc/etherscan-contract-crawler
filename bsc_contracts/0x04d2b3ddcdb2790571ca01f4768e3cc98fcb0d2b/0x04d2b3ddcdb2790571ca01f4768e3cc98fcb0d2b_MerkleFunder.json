{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@api3/airnode-protocol-v1/contracts/utils/ExtendedSelfMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./SelfMulticall.sol\\\";\\nimport \\\"./interfaces/IExtendedSelfMulticall.sol\\\";\\n\\n/// @title Contract that extends SelfMulticall to fetch some of the global\\n/// variables\\n/// @notice Available global variables are limited to the ones that Airnode\\n/// tends to need\\ncontract ExtendedSelfMulticall is SelfMulticall, IExtendedSelfMulticall {\\n    /// @notice Returns the chain ID\\n    /// @return Chain ID\\n    function getChainId() external view override returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    /// @notice Returns the account balance\\n    /// @param account Account address\\n    /// @return Account balance\\n    function getBalance(\\n        address account\\n    ) external view override returns (uint256) {\\n        return account.balance;\\n    }\\n\\n    /// @notice Returns if the account contains bytecode\\n    /// @dev An account not containing any bytecode does not indicate that it\\n    /// is an EOA or it will not contain any bytecode in the future.\\n    /// Contract construction and `SELFDESTRUCT` updates the bytecode at the\\n    /// end of the transaction.\\n    /// @return If the account contains bytecode\\n    function containsBytecode(\\n        address account\\n    ) external view override returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    /// @notice Returns the current block number\\n    /// @return Current block number\\n    function getBlockNumber() external view override returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /// @notice Returns the current block timestamp\\n    /// @return Current block timestamp\\n    function getBlockTimestamp() external view override returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /// @notice Returns the current block basefee\\n    /// @return Current block basefee\\n    function getBlockBasefee() external view override returns (uint256) {\\n        return block.basefee;\\n    }\\n}\\n\"\r\n    },\r\n    \"@api3/airnode-protocol-v1/contracts/utils/interfaces/IExtendedSelfMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ISelfMulticall.sol\\\";\\n\\ninterface IExtendedSelfMulticall is ISelfMulticall {\\n    function getChainId() external view returns (uint256);\\n\\n    function getBalance(address account) external view returns (uint256);\\n\\n    function containsBytecode(address account) external view returns (bool);\\n\\n    function getBlockNumber() external view returns (uint256);\\n\\n    function getBlockTimestamp() external view returns (uint256);\\n\\n    function getBlockBasefee() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@api3/airnode-protocol-v1/contracts/utils/interfaces/ISelfMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISelfMulticall {\\n    function multicall(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory returndata);\\n\\n    function tryMulticall(\\n        bytes[] calldata data\\n    ) external returns (bool[] memory successes, bytes[] memory returndata);\\n}\\n\"\r\n    },\r\n    \"@api3/airnode-protocol-v1/contracts/utils/SelfMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/ISelfMulticall.sol\\\";\\n\\n/// @title Contract that enables calls to the inheriting contract to be batched\\n/// @notice Implements two ways of batching, one requires none of the calls to\\n/// revert and the other tolerates individual calls reverting\\n/// @dev This implementation uses delegatecall for individual function calls.\\n/// Since delegatecall is a message call, it can only be made to functions that\\n/// are externally visible. This means that a contract cannot multicall its own\\n/// functions that use internal/private visibility modifiers.\\n/// Refer to OpenZeppelin's Multicall.sol for a similar implementation.\\ncontract SelfMulticall is ISelfMulticall {\\n    /// @notice Batches calls to the inheriting contract and reverts as soon as\\n    /// one of the batched calls reverts\\n    /// @param data Array of calldata of batched calls\\n    /// @return returndata Array of returndata of batched calls\\n    function multicall(\\n        bytes[] calldata data\\n    ) external override returns (bytes[] memory returndata) {\\n        uint256 callCount = data.length;\\n        returndata = new bytes[](callCount);\\n        for (uint256 ind = 0; ind < callCount; ) {\\n            bool success;\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (success, returndata[ind]) = address(this).delegatecall(data[ind]);\\n            if (!success) {\\n                bytes memory returndataWithRevertData = returndata[ind];\\n                if (returndataWithRevertData.length > 0) {\\n                    // Adapted from OpenZeppelin's Address.sol\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        let returndata_size := mload(returndataWithRevertData)\\n                        revert(\\n                            add(32, returndataWithRevertData),\\n                            returndata_size\\n                        )\\n                    }\\n                } else {\\n                    revert(\\\"Multicall: No revert string\\\");\\n                }\\n            }\\n            unchecked {\\n                ind++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Batches calls to the inheriting contract but does not revert if\\n    /// any of the batched calls reverts\\n    /// @param data Array of calldata of batched calls\\n    /// @return successes Array of success conditions of batched calls\\n    /// @return returndata Array of returndata of batched calls\\n    function tryMulticall(\\n        bytes[] calldata data\\n    )\\n        external\\n        override\\n        returns (bool[] memory successes, bytes[] memory returndata)\\n    {\\n        uint256 callCount = data.length;\\n        successes = new bool[](callCount);\\n        returndata = new bytes[](callCount);\\n        for (uint256 ind = 0; ind < callCount; ) {\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (successes[ind], returndata[ind]) = address(this).delegatecall(\\n                data[ind]\\n            );\\n            unchecked {\\n                ind++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMerkleFunder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@api3/airnode-protocol-v1/contracts/utils/interfaces/IExtendedSelfMulticall.sol\\\";\\n\\ninterface IMerkleFunder is IExtendedSelfMulticall {\\n    event DeployedMerkleFunderDepository(\\n        address indexed merkleFunderDepository,\\n        address owner,\\n        bytes32 root\\n    );\\n\\n    event Funded(\\n        address indexed merkleFunderDepository,\\n        address recipient,\\n        uint256 amount\\n    );\\n\\n    event Withdrew(\\n        address indexed merkleFunderDepository,\\n        address recipient,\\n        uint256 amount\\n    );\\n\\n    error RootZero();\\n\\n    error RecipientAddressZero();\\n\\n    error LowThresholdHigherThanHigh();\\n\\n    error HighThresholdZero();\\n\\n    error InvalidProof();\\n\\n    error RecipientBalanceLargerThanLowThreshold();\\n\\n    error NoSuchMerkleFunderDepository();\\n\\n    error AmountZero();\\n\\n    error InsufficientBalance();\\n\\n    function deployMerkleFunderDepository(\\n        address owner,\\n        bytes32 root\\n    ) external returns (address payable merkleFunderDepository);\\n\\n    function fund(\\n        address owner,\\n        bytes32 root,\\n        bytes32[] calldata proof,\\n        address recipient,\\n        uint256 lowThreshold,\\n        uint256 highThreshold\\n    ) external returns (uint256 amount);\\n\\n    function withdraw(bytes32 root, address recipient, uint256 amount) external;\\n\\n    function withdrawAll(\\n        bytes32 root,\\n        address recipient\\n    ) external returns (uint256 amount);\\n\\n    function computeMerkleFunderDepositoryAddress(\\n        address owner,\\n        bytes32 root\\n    ) external view returns (address merkleFunderDepository);\\n\\n    function ownerToRootToMerkleFunderDepositoryAddress(\\n        address owner,\\n        bytes32 root\\n    ) external view returns (address payable merkleFunderDepository);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMerkleFunderDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMerkleFunderDepository {\\n    error SenderNotMerkleFunder();\\n\\n    error TransferUnsuccessful();\\n\\n    function merkleFunder() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function root() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/MerkleFunder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@api3/airnode-protocol-v1/contracts/utils/ExtendedSelfMulticall.sol\\\";\\nimport \\\"./interfaces/IMerkleFunder.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"./MerkleFunderDepository.sol\\\";\\n\\n/// @title Contract that can be called to deploy MerkleFunderDepository\\n/// contracts or transfer the funds in them within the limitations specified by\\n/// the respective Merkle trees\\n/// @notice Use-cases such as self-funded data feeds require users to keep\\n/// multiple accounts funded. The only way to achieve this without relying on\\n/// on-chain activity is running a bot that triggers the funding using a hot\\n/// wallet. In the naive implementation, the funds to be used would also be\\n/// kept by this hot wallet, which is obviously risky. This contract allows one\\n/// to deploy a MerkleFunderDepository where they can keep the funds, which\\n/// this contract only allows to be transferred within the limitations\\n/// specified by the respective Merkle tree. This means the bot's hot wallet no\\n/// longer needs to be trusted with the funds, and multiple bots with different\\n/// hot wallets can be run against the same MerkleFunderDepository deployment\\n/// for redundancy.\\n/// @dev MerkleFunder inherits SelfMulticall to allow `fund()` to be\\n/// multi-called so that multiple fundings can be executed in a single\\n/// transaction without depending on an external contract. Furthermore, it\\n/// inherits ExtendedSelfMulticall to allow `getBlockNumber()` be multi-called\\n/// to avoid race conditions that would have caused the bot implementation to\\n/// make redundant transactions that revert.\\ncontract MerkleFunder is ExtendedSelfMulticall, IMerkleFunder {\\n    /// @notice Returns the address of the MerkleFunderDepository deployed for\\n    /// the owner address and the Merkle tree root, and zero-address if such a\\n    /// MerkleFunderDepository is not deployed yet\\n    /// @dev The MerkleFunderDepository address can be derived from the owner\\n    /// address and the Merkle tree root using\\n    /// `computeMerkleFunderDepositoryAddress()`, yet doing so is more\\n    /// expensive than reading it from this mapping, which is why we prefer\\n    /// storing it during deployment\\n    mapping(address => mapping(bytes32 => address payable))\\n        public\\n        override ownerToRootToMerkleFunderDepositoryAddress;\\n\\n    /// @notice Called to deterministically deploy the MerkleFunderDepository\\n    /// with the owner address and the Merkle tree root\\n    /// @dev The owner address is allowed to be zero in case the deployer wants\\n    /// to disallow `withdraw()` from being called for the respective\\n    /// MerkleFunderDepository.\\n    /// See `fund()` for how the Merkle tree leaves are derived and how the\\n    /// comprising parameters are validated.\\n    /// @param owner Owner address\\n    /// @param root Merkle tree root\\n    /// @return merkleFunderDepository MerkleFunderDepository address\\n    function deployMerkleFunderDepository(\\n        address owner,\\n        bytes32 root\\n    ) external override returns (address payable merkleFunderDepository) {\\n        if (root == bytes32(0)) revert RootZero();\\n        merkleFunderDepository = payable(\\n            new MerkleFunderDepository{salt: bytes32(0)}(owner, root)\\n        );\\n        ownerToRootToMerkleFunderDepositoryAddress[owner][\\n            root\\n        ] = merkleFunderDepository;\\n        emit DeployedMerkleFunderDepository(\\n            merkleFunderDepository,\\n            owner,\\n            root\\n        );\\n    }\\n\\n    /// @notice Called to transfer funds from a MerkleFunderDepository to the\\n    /// recipient within the limitations specified by the respective Merkle\\n    /// tree\\n    /// @param owner Owner address\\n    /// @param root Merkle tree root\\n    /// @param proof Merkle tree proof\\n    /// @param recipient Recipient address\\n    /// @param lowThreshold Low hysteresis threshold\\n    /// @param highThreshold High hysteresis threshold\\n    /// @return amount Amount used in funding\\n    function fund(\\n        address owner,\\n        bytes32 root,\\n        bytes32[] calldata proof,\\n        address recipient,\\n        uint256 lowThreshold,\\n        uint256 highThreshold\\n    ) external override returns (uint256 amount) {\\n        if (recipient == address(0)) revert RecipientAddressZero();\\n        if (lowThreshold > highThreshold) revert LowThresholdHigherThanHigh();\\n        if (highThreshold == 0) revert HighThresholdZero();\\n        bytes32 leaf = keccak256(\\n            bytes.concat(\\n                keccak256(abi.encode(recipient, lowThreshold, highThreshold))\\n            )\\n        );\\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidProof();\\n        uint256 recipientBalance = recipient.balance;\\n        if (recipientBalance > lowThreshold)\\n            revert RecipientBalanceLargerThanLowThreshold();\\n        address payable merkleFunderDepository = ownerToRootToMerkleFunderDepositoryAddress[\\n                owner\\n            ][root];\\n        if (merkleFunderDepository == address(0))\\n            revert NoSuchMerkleFunderDepository();\\n        uint256 amountNeededToTopUp;\\n        unchecked {\\n            amountNeededToTopUp = highThreshold - recipientBalance;\\n        }\\n        amount = amountNeededToTopUp <= merkleFunderDepository.balance\\n            ? amountNeededToTopUp\\n            : merkleFunderDepository.balance;\\n        if (amount == 0) revert AmountZero();\\n        MerkleFunderDepository(merkleFunderDepository).transfer(\\n            recipient,\\n            amount\\n        );\\n        emit Funded(merkleFunderDepository, recipient, amount);\\n    }\\n\\n    /// @notice Called by the owner of the respective MerkleFunderDepository to\\n    /// withdraw funds in a way that is exempt from the limitations specified\\n    /// by the respective Merkle tree\\n    /// @param root Merkle tree root\\n    /// @param recipient Recipient address\\n    /// @param amount Withdrawal amount\\n    function withdraw(\\n        bytes32 root,\\n        address recipient,\\n        uint256 amount\\n    ) public override {\\n        if (recipient == address(0)) revert RecipientAddressZero();\\n        if (amount == 0) revert AmountZero();\\n        address payable merkleFunderDepository = ownerToRootToMerkleFunderDepositoryAddress[\\n                msg.sender\\n            ][root];\\n        if (merkleFunderDepository == address(0))\\n            revert NoSuchMerkleFunderDepository();\\n        if (merkleFunderDepository.balance < amount)\\n            revert InsufficientBalance();\\n        MerkleFunderDepository(merkleFunderDepository).transfer(\\n            recipient,\\n            amount\\n        );\\n        emit Withdrew(merkleFunderDepository, recipient, amount);\\n    }\\n\\n    /// @notice Called by the owner of the respective MerkleFunderDepository to\\n    /// withdraw its entire balance in a way that is exempt from the\\n    /// limitations specified by the respective Merkle tree\\n    /// @param root Merkle tree root\\n    /// @param recipient Recipient address\\n    /// @return amount Withdrawal amount\\n    function withdrawAll(\\n        bytes32 root,\\n        address recipient\\n    ) external override returns (uint256 amount) {\\n        amount = ownerToRootToMerkleFunderDepositoryAddress[msg.sender][root]\\n            .balance;\\n        withdraw(root, recipient, amount);\\n    }\\n\\n    /// @notice Computes the address of the MerkleFunderDepository\\n    /// @param owner Owner address\\n    /// @param root Merkle tree root\\n    /// @return merkleFunderDepository MerkleFunderDepository address\\n    function computeMerkleFunderDepositoryAddress(\\n        address owner,\\n        bytes32 root\\n    ) external view override returns (address merkleFunderDepository) {\\n        if (root == bytes32(0)) revert RootZero();\\n        merkleFunderDepository = Create2.computeAddress(\\n            bytes32(0),\\n            keccak256(\\n                abi.encodePacked(\\n                    type(MerkleFunderDepository).creationCode,\\n                    abi.encode(owner, root)\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MerkleFunderDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./interfaces/IMerkleFunderDepository.sol\\\";\\n\\n/// @title Contract that is deployed through MerkleFunder and keeps the funds\\n/// that can be transferred within the limitations specified by the respective\\n/// Merkle tree\\n/// @notice As noted above, this contract should only be deployed by a\\n/// MerkleFunder contract. Since the owner address and the Merkle tree root are\\n/// immutable, the only way to update these is to deploy a new\\n/// MerkleFunderDepository with the desired parameters and have the owner of\\n/// the previous MerkleFunderDepository withdraw the funds to the new one.\\ncontract MerkleFunderDepository is IMerkleFunderDepository {\\n    /// @notice Address of the MerkleFunder that deployed this contract\\n    address public immutable override merkleFunder;\\n\\n    /// @notice Owner address\\n    address public immutable override owner;\\n\\n    /// @notice Merkle tree root\\n    bytes32 public immutable override root;\\n\\n    /// @dev Argument validation is done in MerkleFunder to reduce the\\n    /// bytecode of this contract\\n    /// @param _owner Owner address\\n    /// @param _root Merkle tree root\\n    constructor(address _owner, bytes32 _root) {\\n        merkleFunder = msg.sender;\\n        owner = _owner;\\n        root = _root;\\n    }\\n\\n    /// @dev Funds transferred to this contract can be transferred by anyone\\n    /// within the limitations of the respective Merkle tree\\n    receive() external payable {}\\n\\n    /// @notice Called by the MerkleFunder that has deployed this contract to\\n    /// transfer its funds within the limitations of the respective Merkle tree\\n    /// or to allow the owner to withdraw funds\\n    /// @dev Argument validation is done in MerkleFunder to reduce the bytecode\\n    /// of this contract.\\n    /// This function is omitted in the interface because it is intended to\\n    /// only be called by MerkleFunder.\\n    /// @param recipient Recipient address\\n    /// @param amount Amount\\n    function transfer(address recipient, uint256 amount) external {\\n        if (msg.sender != merkleFunder) revert SenderNotMerkleFunder();\\n        // MerkleFunder checks for balance so MerkleFunderDepository does not\\n        // need to\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) revert TransferUnsuccessful();\\n        // MerkleFunder emits the event so MerkleFunderDepository does not need\\n        // to\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AmountZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HighThresholdZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LowThresholdHigherThanHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSuchMerkleFunderDepository\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecipientAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecipientBalanceLargerThanLowThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"DeployedMerkleFunderDepository\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"computeMerkleFunderDepositoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"containsBytecode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"deployMerkleFunderDepository\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lowThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highThreshold\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockBasefee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"returndata\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ownerToRootToMerkleFunderDepositoryAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"tryMulticall\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"successes\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returndata\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MerkleFunder", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}