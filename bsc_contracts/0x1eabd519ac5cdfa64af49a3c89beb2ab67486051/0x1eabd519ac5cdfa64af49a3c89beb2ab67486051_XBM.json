{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-02-10\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n  interface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function name() external view returns (string memory);\r\n  function getOwner() external view returns (address);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n  interface BurningMoon is IBEP20{\r\n    function Compound() external;\r\n    function getDividents(address addr) external view returns (uint256);\r\n    function getShares(address addr) external view returns (uint256);\r\n    function TransferSacrifice(address target, uint256 amount) external;\r\n    function addFunds(bool boost, bool stake)external payable;\r\n    function getTaxes() external view returns(\r\n    uint256 buyTax, \r\n    uint256 sellTax, \r\n    uint256 transferTax, \r\n    uint8 whitelistBuyTax,\r\n    uint256 burnTax,\r\n    uint256 liquidityTax,\r\n    uint256 stakingTax);\r\n}\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n \r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n    \r\n}\r\ninterface IDexRouter {\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n}\r\ninterface IPancakeFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ncontract XBMMint{\r\n    address public owner;\r\n    address public token;\r\n\r\n    BurningMoon BM;\r\n    modifier onlyToken(){\r\n        require(msg.sender==token);\r\n        _;\r\n    }\r\n    constructor(address _owner, address _token, address burningMoon){\r\n        BM=BurningMoon(burningMoon);\r\n        owner=_owner;\r\n        token=_token;\r\n    }\r\n\r\n    function _sacrifice() private{\r\n        BM.transfer(address(0xdead),BM.balanceOf(address(this)));\r\n    }\r\n\r\n    function Mint() public onlyToken returns (uint Minted){\r\n        if(BM.balanceOf(address(this))>0)_sacrifice();\r\n        Minted=BM.getShares(address(this));\r\n        BM.TransferSacrifice(token,Minted);\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//XBM Contract//////////////////////////////////////////////////////////////////////////////////////////\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\ncontract XBM is IBEP20, Ownable\r\n{\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address=>uint) public paidOutAmount;\r\n\r\n    mapping(address=>bool) private _excluded;\r\n    mapping(address=>bool) private _excludedFromStaking;\r\n    mapping(address=>bool) private _automatedMarketMakers;\r\n    mapping(address=>uint) public FreshlyMintedToken;\r\n    mapping(address=>uint) public MintedAllowance;\r\n    mapping(address=>uint32) public LastSellDay;\r\n    uint DailyMintedSellAllowance=100000*10**_decimals;\r\n    //Token Info\r\n    string private _name = 'MetaBurn';\r\n    string private constant _symbol = 'xBM';\r\n    uint8 private constant _decimals = 9;\r\n\r\n    //The time Liquidity gets locked at start and prolonged once it gets released\r\n    uint256 private constant DefaultLiquidityLockTime=7 days;\r\n    uint public MintingStartTimestamp=type(uint).max;\r\n\r\n    //variables that track balanceLimit and sellLimit,\r\n    //can be updated based on circulating supply and Sell- and BalanceLimitDividers\r\n    uint256 private _circulatingSupply;\r\n\r\n    //The shares of the specific Taxes, always needs to equal 100%\r\n    uint private _liquidityTax=2000;\r\n    uint private _stakingTax=7000;\r\n    uint private _burnTax=1000;\r\n    uint private constant TaxDenominator=10000;\r\n\r\n    uint8 public LiquifyTreshold=15;\r\n    uint public BurnedSupply=0;\r\n    address private _pancakePairAddress; \r\n    IDexRouter private  _pancakeRouter=IDexRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); \r\n    BurningMoon private BM=BurningMoon(0x97c6825e6911578A515B11e25B552Ecd5fE58dbA);\r\n    //IDexRouter private  _pancakeRouter=IDexRouter(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); \r\n    //BurningMoon private BM=BurningMoon(0x1Fd93329706579516e18ef2B51890F7a146B5b14);\r\n\r\n\r\n    bool _isInFunction;\r\n    modifier isInFunction(){\r\n        require(!_isInFunction);\r\n        _isInFunction=true;\r\n        _;\r\n        _isInFunction=false;\r\n    }\r\n\r\n    function _isEnabled() private view returns(bool){\r\n        return block.timestamp>=MintingStartTimestamp||_excluded[msg.sender];\r\n    } \r\n    function StartMintingIn(uint EnableInSeconds) public{\r\n        SetMintingStartTimestamp(block.timestamp+EnableInSeconds);\r\n    }\r\n    function SetMintingStartTimestamp(uint Timestamp) public onlyOwner{\r\n        require(block.timestamp<MintingStartTimestamp);\r\n        require(Timestamp>=block.timestamp);\r\n        MintingStartTimestamp=Timestamp;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //Minting///////////////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function GetRate(uint Input) public view returns(uint){\r\n        if(_circulatingSupply==0)return Input;\r\n        uint MaxSupply=_circulatingSupply+BurnedSupply;\r\n        return Input*_circulatingSupply/MaxSupply;\r\n    }\r\n    mapping(address=>address) public MintingContracts;\r\n    mapping(address=>bool) public SacrificeWhitelist;\r\n    function AddToMintingWhitelist(address[] memory addresses, bool add) public onlyOwner{\r\n        for(uint i=0;i<addresses.length;i++){\r\n            SacrificeWhitelist[addresses[i]]=add;\r\n        }\r\n    }\r\n\r\n    event OnCreateMintingContract(address owner, address contractAddress);\r\n    function CreateMintingContract() public returns (address MintingContract){\r\n        require(SacrificeWhitelist[msg.sender],\"Not on minting whitelist\");\r\n        require(_isEnabled(),\"Minting not yet Enabled\");\r\n        MintingContract=_createMintingContract(msg.sender);\r\n    }\r\n    \r\n    function _createMintingContract(address account) private returns (address MintingContract){\r\n        MintingContract=MintingContracts[account];\r\n        require(MintingContract==address(0), \"Minting Contract already defined\");\r\n        XBMMint newMintContract=new XBMMint(account,address(this),address(BM));\r\n        MintingContract=address(newMintContract);\r\n        MintingContracts[account]=MintingContract;\r\n        emit OnCreateMintingContract(account,MintingContract);\r\n    }\r\n\r\n    //mints new xBM according to the balance of sBM on the minting contract of msg.sender\r\n    function Mint() external isInFunction{\r\n        _mint(msg.sender);\r\n    }\r\n    function _mint(address account) private {\r\n        address MintingContract=MintingContracts[account];\r\n        require(MintingContract!=address(0), \"No Minting Contract Defined\");\r\n        XBMMint mintContract=XBMMint(MintingContract);\r\n        uint MintedAmount=GetRate(mintContract.Mint());\r\n        _addToken(account,MintedAmount);\r\n        emit Transfer(address(0),account,MintedAmount);\r\n        FreshlyMintedToken[account]+=MintedAmount;\r\n    }\r\n\r\n\r\n    //Mint XBM using BM\r\n    function ConvertBM(uint amount) external isInFunction{\r\n        _convertBM(amount,msg.sender);\r\n    }\r\n    function _convertBM(uint amount,address account) private {\r\n        require(_isEnabled(),\"Minting not yet Enabled\");\r\n        uint initialBalance=BM.balanceOf(address(this));\r\n        BM.transferFrom(account, address(this), amount);\r\n        uint newBalance=BM.balanceOf(address(this))-initialBalance;\r\n        BM.transfer(address(0xdead),newBalance);\r\n        uint MintedAmount=GetRate(newBalance*2);\r\n        _addToken(account,MintedAmount);\r\n        emit Transfer(address(0),account,MintedAmount);\r\n        FreshlyMintedToken[account]+=MintedAmount;\r\n    }\r\n\r\n    //Mint XBM using BNB\r\n    receive() external payable{\r\n        if(msg.sender==address(_pancakeRouter))return;\r\n        mintWithBNB();\r\n    }\r\n    function mintWithBNB() private isInFunction{\r\n        require(_isEnabled(),\"Minting not yet Enabled\");\r\n        uint initialBalance=BM.balanceOf(address(this));\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = address(BM);\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value:msg.value}(\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp);\r\n\r\n        uint newBalance=BM.balanceOf(address(this))-initialBalance;\r\n        BM.transfer(address(0xdead),newBalance);\r\n        uint MintedAmount=GetRate(newBalance*2);\r\n        _addToken(msg.sender,MintedAmount);\r\n        emit Transfer(address(0),msg.sender,MintedAmount);\r\n        FreshlyMintedToken[msg.sender]+=MintedAmount;\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //Constructor///////////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    constructor () {\r\n        //Creates a Pancake Pair\r\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\r\n        _automatedMarketMakers[_pancakePairAddress]=true;\r\n        //excludes Pancake Pair and contract from staking\r\n        _excludedFromStaking[_pancakePairAddress]=true;\r\n        _excludedFromStaking[address(this)]=true;\r\n        SacrificeWhitelist[msg.sender]=true;\r\n        //Team wallet deployer and contract are excluded from Taxes\r\n        //contract can't be included to taxes\r\n        _excluded[msg.sender]=true;\r\n        _excluded[address(this)]=true;\r\n        _approve(address(this), address(_pancakeRouter), type(uint256).max);\r\n    }\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //Transfer functionality////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n    //picks the transfer function\r\n    function _transfer(address sender, address recipient, uint256 amount) private{\r\n        require(sender != address(0), \"from zero\");\r\n        require(recipient != address(0), \"to zero\");\r\n\r\n        //excluded adresses are transfering tax and lock free\r\n        if(_excluded[sender] || _excluded[recipient]){\r\n            _feelessTransfer(sender, recipient, amount);\r\n            return;\r\n        }\r\n        //once trading is enabled, it can't be turned off again\r\n        _regularTransfer(sender,recipient,amount);\r\n        //AutoPayout\r\n\r\n    }\r\n    //applies taxes, checks for limits, locks generates autoLP and stakingBNB, and autostakes\r\n    function _regularTransfer(address sender, address recipient, uint256 amount) private{\r\n        uint senderBalance=_balances[sender];\r\n        require(senderBalance >= amount, \"exceeds balance\");\r\n        \r\n        //checks all registered AMM if it's a buy or sell.\r\n        bool isBuy=_automatedMarketMakers[sender];\r\n        bool isSell=_automatedMarketMakers[recipient];\r\n        uint tax;\r\n        (uint256 buyTax,uint256 sellTax,uint256 transferTax,,,,)=BM.getTaxes();\r\n        //accounts can only transfer/sell 100k   freshly minted tokens per day (resets at launch timestamp)\r\n        if(!isBuy){\r\n            handleMintAllowance(sender,amount);\r\n            if(isSell) tax=sellTax;\r\n            else tax=transferTax;\r\n        }else tax=buyTax;\r\n\r\n        //Swapping AutoLP and MarketingBNB is only possible if sender is not pancake pair, \r\n        //if its not manually disabled, if its not already swapping\r\n        if((sender!=_pancakePairAddress)&&(!swapAndLiquifyDisabled)&&(!_isSwappingContractModifier))\r\n            _swapContractToken(LiquifyTreshold,false);\r\n\r\n        _transferTaxed(sender,recipient,amount,tax);\r\n    }\r\n    function _transferTaxed(address sender, address recipient, uint256 amount, uint tax) private{\r\n        uint totalTaxedToken=_calculateFee(amount, tax, TaxDenominator);\r\n        uint burnedToken=_calculateFee(amount,tax,_burnTax);\r\n        uint256 taxedAmount=amount-totalTaxedToken;\r\n        //Removes token and handles staking\r\n        _removeToken(sender,amount);\r\n        //Adds the taxed tokens -burnedToken to the contract\r\n        _addToken(address(this), totalTaxedToken-burnedToken);\r\n        //Burns token\r\n        _circulatingSupply-=burnedToken;\r\n        BurnedSupply+=burnedToken;\r\n        //Adds token and handles staking\r\n        _addToken(recipient, taxedAmount);\r\n        emit Transfer(sender,recipient,taxedAmount);\r\n        if(!autoPayoutDisabled) _autoPayout();\r\n\r\n    }\r\n\r\n\r\n    //Feeless transfer only transfers and autostakes\r\n    function _feelessTransfer(address sender, address recipient, uint256 amount) private{\r\n        require(_balances[sender] >= amount, \">balance\");\r\n        //Removes token and handles staking\r\n        _removeToken(sender,amount);\r\n        //Adds token and handles staking\r\n        _addToken(recipient, amount);\r\n        //Adjusts FreshlyMintedToken\r\n        if(_balances[sender]<FreshlyMintedToken[sender]){\r\n            FreshlyMintedToken[sender]=_balances[sender];\r\n        }\r\n\r\n        \r\n        emit Transfer(sender,recipient,amount);\r\n\r\n    }\r\n\r\n    function CurrentDay() public view returns(uint32){\r\n        uint secondsSinceLaunch=block.timestamp-MintingStartTimestamp;\r\n        return uint32(secondsSinceLaunch/(1 days));\r\n    }\r\n\r\n    function MintedSellAllowance(address account) private view returns(uint remainingAllowance){\r\n        if(LastSellDay[account]<CurrentDay())\r\n            return DailyMintedSellAllowance;\r\n        return DailyMintedSellAllowance-MintedAllowance[account];\r\n    }\r\n    function handleMintAllowance(address account, uint amount) private{\r\n        uint balance=_balances[account];\r\n        uint AllowanceFreeBalance=balance-FreshlyMintedToken[account];\r\n        //Not enough allowance free tokens\r\n        if(AllowanceFreeBalance<amount){\r\n            uint remainingAllowance=MintedSellAllowance(account);\r\n            require(remainingAllowance+AllowanceFreeBalance>=amount,\"Not enough allowance left\");\r\n            if(LastSellDay[account]<CurrentDay()){\r\n                LastSellDay[account]=CurrentDay();\r\n                MintedAllowance[account]=0;\r\n            }\r\n            uint allowanceCost=amount-AllowanceFreeBalance;\r\n            MintedAllowance[account]+=allowanceCost;\r\n            FreshlyMintedToken[account]-=allowanceCost;\r\n        }\r\n    }\r\n\r\n    //Calculates the token that should be taxed\r\n    function _calculateFee(uint256 amount, uint tax, uint taxPercent) private pure returns (uint256) {\r\n        return (amount*tax*taxPercent) / (100*TaxDenominator);\r\n    }\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //BM Autostake/////////////////////////////////////////////////////////////////////////////////////////\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////// \r\n    //Autostake uses the balances of each holder to redistribute auto generated BM.\r\n    //Each transaction _addToken and _removeToken gets called for the transaction amount\r\n    EnumerableSet.AddressSet private _autoPayoutList;\r\n    function isAutoPayout(address account) public view returns(bool){\r\n        return _autoPayoutList.contains(account);\r\n    }\r\n    uint AutoPayoutCount=15;\r\n    uint MinPayout=100*10**9;//100 BM\r\n    uint256 currentPayoutIndex;\r\n\r\n    bool public autoPayoutDisabled;\r\n\r\n    event OnDisableAutoPayout(bool disabled);\r\n    function DisableAutoPayout(bool disabled) public onlyOwner{\r\n        autoPayoutDisabled=disabled;\r\n        emit  OnDisableAutoPayout(disabled);\r\n    }\r\n    event OnChangeAutoPayoutCount(uint count); \r\n    function ChangeAutoPayoutCount(uint count) public onlyOwner{\r\n        require(count<=50);\r\n        AutoPayoutCount=count;\r\n        emit OnChangeAutoPayoutCount(count);\r\n    }\r\n    event OnChangeMinPayout(uint treshold); \r\n    function ChangeMinPayout(uint minPayout) public onlyOwner{\r\n        MinPayout=minPayout;\r\n        emit OnChangeAutoPayoutCount(minPayout);\r\n    }\r\n    function SetAutoPayoutAccount(address account, bool enable) public onlyOwner{\r\n        if(enable)_autoPayoutList.add(account);\r\n        else _autoPayoutList.remove(account);\r\n    }\r\n    event OnSetTaxes(uint Staking,uint Burn,uint LP);\r\n    function SetTaxes(uint Staking, uint Burn, uint LP) public onlyOwner{\r\n        require(Staking+Burn+LP==100);\r\n        _stakingTax=Staking;\r\n        _burnTax=Burn;\r\n        _liquidityTax=LP;\r\n        \r\n        emit OnSetTaxes(Staking,Burn,LP);\r\n    }\r\n    \r\n    function _autoPayout() private{\r\n        _compoundBM();\r\n        //resets payout counter and moves to next payout token if last holder is reached\r\n        if(currentPayoutIndex>=_autoPayoutList.length()) currentPayoutIndex=0;\r\n        for(uint i=0;i<AutoPayoutCount;i++){\r\n            address current=_autoPayoutList.at(currentPayoutIndex);\r\n            currentPayoutIndex++; \r\n            if(getDividents(current)>=MinPayout){\r\n                _claimBM(current);\r\n                i+=3;//if payout happens, increase the counter faster  \r\n            }\r\n            if(currentPayoutIndex>=_autoPayoutList.length()){\r\n                currentPayoutIndex=0;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Multiplier to add some accuracy to profitPerShare\r\n    uint256 private constant DistributionMultiplier = 2**64;\r\n    //profit for each share a holder holds, a share equals a decimal.\r\n    uint256 public profitPerShare;\r\n\r\n    uint256 private _totalShares=0;\r\n    //the total reward distributed through staking, for tracking purposes\r\n    uint256 public totalStakingReward;\r\n    //the total payout through staking, for tracking purposes\r\n    uint256 public totalPayouts;\r\n    //Mapping of the already paid out(or missed) shares of each staker\r\n    mapping(address => uint256) private alreadyPaidShares;\r\n    //Mapping of shares that are reserved for payout\r\n    mapping(address => uint256) public totalPayout;\r\n\r\n    //adds Token to balances, adds new BNB to the toBePaid mapping and resets staking\r\n    function _addToken(address addr, uint256 amount) private {\r\n        //the amount of token after transfer\r\n        uint256 newAmount=_balances[addr]+amount;\r\n        _circulatingSupply+=amount;\r\n        //if excluded, don't change staking amount\r\n        if(_excludedFromStaking[addr]){\r\n           _balances[addr]=newAmount;\r\n           return;\r\n        }\r\n        _claimBM(addr);\r\n        _totalShares+=amount;\r\n        //resets dividents to 0 for newAmount\r\n        alreadyPaidShares[addr] = profitPerShare * newAmount;\r\n        //sets newBalance\r\n        _balances[addr]=newAmount;\r\n        _autoPayoutList.add(addr);\r\n\r\n    }\r\n    \r\n    //removes Token, adds BNB to the toBePaid mapping and resets staking\r\n    function _removeToken(address addr, uint256 amount) private {\r\n        //the amount of token after transfer\r\n        uint256 newAmount=_balances[addr]-amount;\r\n        _circulatingSupply-=amount;\r\n        if(_excludedFromStaking[addr]){\r\n           _balances[addr]=newAmount;\r\n           return;\r\n        }\r\n        _claimBM(addr);\r\n        //sets newBalance\r\n        _balances[addr]=newAmount;\r\n        //resets dividents to 0 for newAmount\r\n        alreadyPaidShares[addr] = profitPerShare * getShares(addr);\r\n        //adds dividents to the toBePaid mapping\r\n\r\n        _totalShares-=amount;\r\n        if(newAmount==0)\r\n        _autoPayoutList.remove(addr);\r\n    }\r\n    \r\n    \r\n    //gets the dividents of a staker that aren't in the toBePaid mapping \r\n    function getDividents(address staker) private view returns (uint256) {\r\n        uint256 fullPayout = profitPerShare * getShares(staker);\r\n        //if excluded from staking or some error return 0\r\n        if(fullPayout<=alreadyPaidShares[staker]) return 0;\r\n        return (fullPayout - alreadyPaidShares[staker]) / DistributionMultiplier;\r\n    }\r\n    \r\n    function _compoundBM() private {\r\n        if(BM.getDividents(address(this))==0) return;      \r\n        if(_totalShares==0) return;\r\n        uint oldBM=BM.balanceOf(address(this));\r\n        BM.Compound();\r\n        uint newBM=BM.balanceOf(address(this))-oldBM;\r\n        uint256 totalShares=getTotalShares();\r\n        //when there are 0 shares, add everything to marketing budget\r\n            totalStakingReward += newBM;\r\n            //Increases profit per share based on current total shares\r\n            profitPerShare += ((newBM * DistributionMultiplier) / totalShares);\r\n    }\r\n\r\n    //Sets dividents to 0 returns dividents\r\n    function _substractDividents(address addr) private returns (uint256){\r\n        uint256 amount=getDividents(addr);\r\n        if(amount==0) return 0;\r\n        if(!_excludedFromStaking[addr]){\r\n            alreadyPaidShares[addr] = profitPerShare * getShares(addr);\r\n        }\r\n        totalPayout[addr]+=amount;\r\n        return amount;\r\n    }\r\n    //Manually claimRewards\r\n    function ClaimRewards() public isInFunction{\r\n        _compoundBM();\r\n        _claimBM(msg.sender);\r\n    }\r\n    function _claimBM(address account) private{\r\n        //Substracts the amount from the dividents\r\n        uint256 amount=_substractDividents(account);\r\n        if(amount==0) return;\r\n        totalPayouts+=amount;  \r\n        paidOutAmount[account]+amount;\r\n        BM.transfer(account,amount);     \r\n    }\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //Swap Contract Tokens//////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    //tracks auto generated BNB, useful for ticker etc\r\n    uint256 public totalLPBNB;\r\n    //Locks the swap if already swapping\r\n    bool private _isSwappingContractModifier;\r\n    modifier lockTheSwap {\r\n        _isSwappingContractModifier = true;\r\n        _;\r\n        _isSwappingContractModifier = false;\r\n    }\r\n    uint public overLiquifyTreshold=1500; \r\n    function isOverLiquified() public view returns(bool){\r\n        return _balances[_pancakePairAddress]>_circulatingSupply*overLiquifyTreshold/TaxDenominator;\r\n    }\r\n    function _swapContractToken(uint16 PancakeTreshold,bool ignoreLimits) private lockTheSwap{\r\n        uint contractBalance=_balances[address(this)];\r\n        uint totalTax=_liquidityTax+_stakingTax;\r\n        if(totalTax==0) return;\r\n\r\n            \r\n        uint256 tokenToSwap=_balances[_pancakePairAddress]*PancakeTreshold/TaxDenominator;\r\n        \r\n        //only swap if contractBalance is larger than tokenToSwap or ignore limits\r\n        bool NotEnoughToken=contractBalance<tokenToSwap;\r\n        if(NotEnoughToken){\r\n            if(ignoreLimits)\r\n                tokenToSwap=contractBalance;\r\n            else return;\r\n        }\r\n        uint tokenForLiquidity;\r\n        //if over Liquified, then use 100% of the token for LP\r\n        if(isOverLiquified())tokenForLiquidity=0;\r\n        else tokenForLiquidity=(tokenToSwap*_liquidityTax)/totalTax;\r\n\r\n        uint tokenForBNB=tokenToSwap-tokenForLiquidity;\r\n\r\n\r\n        //splits tokenForLiquidity in 2 halves\r\n        uint liqToken=tokenForLiquidity/2;\r\n        uint liqBNBToken=tokenForLiquidity-liqToken;\r\n\r\n        //swaps marktetingToken and the liquidity token half for BNB\r\n        uint swapToken=liqBNBToken+tokenForBNB;\r\n        //Gets the initial BNB balance, so swap won't touch any staked BNB\r\n        _swapTokenForBNB(swapToken);\r\n        //calculates the amount of BNB belonging to the LP-Pair and converts them to LP\r\n        uint liqBNB = (address(this).balance*liqBNBToken)/swapToken;\r\n        if(liqBNB>0) _addLiquidity(liqToken, liqBNB);\r\n        //distributes BNB between stakers\r\n        BM.addFunds{value:address(this).balance}(false,true);\r\n    }\r\n    //swaps tokens on the contract for BNB\r\n    function _swapTokenForBNB(uint256 amount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _pancakeRouter.WETH();\r\n\r\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n    //Adds Liquidity directly to the contract where LP are locked(unlike safemoon forks, that transfer it to the owner)\r\n    function _addLiquidity(uint256 tokenamount, uint256 bnbamount) private {\r\n        totalLPBNB+=bnbamount;\r\n        try _pancakeRouter.addLiquidityETH{value: bnbamount}(\r\n            address(this),\r\n            tokenamount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        ){}\r\n        catch{}\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //public functions /////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n        //gets shares of an address, returns 0 if excluded\r\n    function getShares(address addr) public view returns(uint256){\r\n        if(_excludedFromStaking[addr]) return 0;\r\n        return _balances[addr];\r\n    }\r\n\r\n    //Total shares equals circulating supply minus excluded Balances\r\n    function getTotalShares() public view returns (uint256){\r\n        return _totalShares;\r\n    }\r\n\r\n    function getLiquidityLockSeconds() public view returns (uint256 LockedSeconds){\r\n        if(block.timestamp<_liquidityUnlockTime)\r\n            return _liquidityUnlockTime-block.timestamp;\r\n        return 0;\r\n    }\r\n\r\n    function getTaxes() public view returns(\r\n    uint256 liquidityTax,\r\n    uint256 stakingTax,\r\n    uint burnTax){\r\n            liquidityTax=_liquidityTax;\r\n            stakingTax=_stakingTax;\r\n            burnTax=_burnTax;\r\n\r\n\r\n    }\r\n    \r\n    function getStatus(address account) public view returns(\r\n        bool Excluded, \r\n        bool ExcludedFromStaking\r\n        ){\r\n        return(\r\n            _excluded[account],\r\n            _excludedFromStaking[account]\r\n            );\r\n    }\r\n    \r\n\r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //Settings//////////////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    bool public swapAndLiquifyDisabled;\r\n    event  OnAddAMM(address AMM,bool Add);\r\n    function TeamAddOrRemoveAMM(address AMMPairAddress, bool Add) public onlyOwner{\r\n        require(AMMPairAddress!=_pancakePairAddress,\"can't change Pancake\");\r\n        if(Add){\r\n            if(!_excludedFromStaking[AMMPairAddress])\r\n                TeamSetStakingExcluded(AMMPairAddress, true);\r\n            _automatedMarketMakers[AMMPairAddress]=true;\r\n        } \r\n        else{\r\n            _automatedMarketMakers[AMMPairAddress]=false;\r\n        }\r\n        emit OnAddAMM(AMMPairAddress, Add);\r\n    }\r\n\r\n    event  OnChangeLiquifyTreshold(uint8 Treshold);\r\n    function TeamSetLiquifyTreshold(uint8 Treshold) public onlyOwner{\r\n        require(Treshold<=TaxDenominator/100);//1%\r\n        require(Treshold>0);\r\n        LiquifyTreshold=Treshold;\r\n        emit OnChangeLiquifyTreshold(Treshold);\r\n    }\r\n\r\n    event  OnChangeOverLiquifyTreshold(uint8 TresholdPermille);\r\n    function TeamSetOverLiquifyTreshold(uint8 TresholdPermille) public onlyOwner{\r\n        \r\n        require(TresholdPermille<=TaxDenominator);\r\n        overLiquifyTreshold=TresholdPermille;\r\n        emit OnChangeOverLiquifyTreshold(TresholdPermille);\r\n    }\r\n\r\n    \r\n    \r\n    event  OnSwitchSwapAndLiquify(bool Disabled);\r\n    //switches autoLiquidity and marketing BNB generation during transfers\r\n    function TeamSwitchSwapAndLiquify(bool disabled) public onlyOwner{\r\n        swapAndLiquifyDisabled=disabled;\r\n        emit OnSwitchSwapAndLiquify(disabled);\r\n    }\r\n\r\n\r\n    //manually converts contract token to LP and staking BNB\r\n    function TeamTriggerLiquify(uint16 pancakePermille, bool ignoreLimits) public onlyOwner{\r\n        _swapContractToken(pancakePermille,ignoreLimits);\r\n    }\r\n    \r\n    event OnExcludeFromStaking(address addr, bool exclude);\r\n    //Excludes account from Staking\r\n    function TeamSetStakingExcluded(address addr, bool exclude) public onlyOwner{\r\n        uint256 shares;\r\n        if(exclude){\r\n            require(!_excludedFromStaking[addr]);\r\n            _claimBM(addr);\r\n            shares=getShares(addr);\r\n            _excludedFromStaking[addr]=true; \r\n            _totalShares-=shares;\r\n            alreadyPaidShares[addr]=shares*profitPerShare;\r\n            _autoPayoutList.remove(addr);\r\n\r\n        } else _includeToStaking(addr);\r\n        emit OnExcludeFromStaking(addr, exclude);\r\n    }    \r\n\r\n    //function to Include own account to staking, should it be excluded\r\n    function IncludeMeToStaking() public{\r\n        _includeToStaking(msg.sender);\r\n    }\r\n    function _includeToStaking(address addr) private{\r\n        require(_excludedFromStaking[addr]);\r\n        _excludedFromStaking[addr]=false;\r\n        uint256 shares=getShares(addr);\r\n        _totalShares+=shares;\r\n        //sets alreadyPaidShares to the current amount\r\n        alreadyPaidShares[addr]=shares*profitPerShare;\r\n        _autoPayoutList.add(addr);\r\n    }\r\n    event OnExclude(address addr, bool exclude);\r\n    //Exclude/Include account from fees and locks (eg. CEX)\r\n    function SetExcludedStatus(address account,bool excluded) public onlyOwner {\r\n        require(account!=address(this),\"can't Include the contract\");   \r\n        _excluded[account]=excluded;\r\n        emit OnExclude(account, excluded);\r\n    }\r\n    event ContractBurn(uint256 amount);\r\n    //Burns token on the contract, like when there is a very large backlog of token\r\n    //or for scheudled BurnEvents\r\n    function BurnContractToken(uint8 percent) public onlyOwner{\r\n        require(percent<=100);\r\n        uint256 burnAmount=_balances[address(this)]*percent/100;\r\n        _removeToken(address(this),burnAmount);\r\n        emit Transfer(address(this), address(0), burnAmount);\r\n        emit ContractBurn(burnAmount);\r\n    }    \r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //Liquidity Lock////////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //the timestamp when Liquidity unlocks\r\n    uint256 private _liquidityUnlockTime;\r\n    //Prolongs the Liquidity Lock. Lock can't be reduced\r\n    event ProlongLiquidityLock(uint256 secondsUntilUnlock);\r\n    function TeamLockLiquidityForSeconds(uint256 secondsUntilUnlock) public onlyOwner{\r\n        _prolongLiquidityLock(secondsUntilUnlock+block.timestamp);\r\n        emit ProlongLiquidityLock(secondsUntilUnlock);\r\n    }\r\n    function _prolongLiquidityLock(uint256 newUnlockTime) private{\r\n        // require new unlock time to be longer than old one\r\n        require(newUnlockTime>_liquidityUnlockTime);\r\n        _liquidityUnlockTime=newUnlockTime;\r\n    }\r\n\r\n\r\n    event OnReleaseLP();\r\n    //Release Liquidity Tokens once unlock time is over\r\n    function LiquidityRelease() public onlyOwner {\r\n        //Only callable if liquidity Unlock time is over\r\n        require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\r\n\r\n        IBEP20 liquidityToken = IBEP20(_pancakePairAddress);\r\n        uint amount = liquidityToken.balanceOf(address(this))*2/10;\r\n        _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\r\n        //regular liquidity release, only releases 20% at a time and locks liquidity for another week\r\n        amount=amount*2/10;\r\n    \r\n        liquidityToken.transfer(msg.sender, amount);\r\n        emit OnReleaseLP();\r\n    }\r\n\r\n\r\n\r\n    //Allows the team to withdraw token that get's accidentally sent to the contract(happens way too often)\r\n    function TeamWithdrawStrandedToken(address strandedToken) public onlyOwner{\r\n        require((strandedToken!=_pancakePairAddress)&&strandedToken!=address(this));\r\n        IBEP20 token=IBEP20(strandedToken);\r\n        token.transfer(msg.sender,token.balanceOf(address(this)));\r\n    }\r\n    bool public emergencyWithdraw=true;\r\n    function DisableEmergencyWithdraw() external onlyOwner{\r\n        emergencyWithdraw=false;\r\n    }\r\n    function EmergencyWithdraw(uint amount) external onlyOwner{\r\n        require(emergencyWithdraw);\r\n        BM.TransferSacrifice(msg.sender,amount);\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //external//////////////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // IBEP20\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner();\r\n    }\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _circulatingSupply;\r\n    }\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address _owner, address spender) external view override returns (uint256) {\r\n        return _allowances[_owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0));\r\n        require(spender != address(0));\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount,\"No allowance\");\r\n\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n    // IBEP20 - Helpers\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue);\r\n\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContractBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Add\",\"type\":\"bool\"}],\"name\":\"OnAddAMM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"OnChangeAutoPayoutCount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Treshold\",\"type\":\"uint8\"}],\"name\":\"OnChangeLiquifyTreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treshold\",\"type\":\"uint256\"}],\"name\":\"OnChangeMinPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"TresholdPermille\",\"type\":\"uint8\"}],\"name\":\"OnChangeOverLiquifyTreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"OnCreateMintingContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"OnDisableAutoPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"OnExclude\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"OnExcludeFromStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnReleaseLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Staking\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LP\",\"type\":\"uint256\"}],\"name\":\"OnSetTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Disabled\",\"type\":\"bool\"}],\"name\":\"OnSwitchSwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondsUntilUnlock\",\"type\":\"uint256\"}],\"name\":\"ProlongLiquidityLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"AddToMintingWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"}],\"name\":\"BurnContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BurnedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"ChangeAutoPayoutCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPayout\",\"type\":\"uint256\"}],\"name\":\"ChangeMinPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConvertBM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CreateMintingContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"MintingContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentDay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"DisableAutoPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DisableEmergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"FreshlyMintedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Input\",\"type\":\"uint256\"}],\"name\":\"GetRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IncludeMeToStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LastSellDay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquifyTreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"MintedAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"MintingContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MintingStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"SacrificeWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetAutoPayoutAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"SetExcludedStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"name\":\"SetMintingStartTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Staking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LP\",\"type\":\"uint256\"}],\"name\":\"SetTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"EnableInSeconds\",\"type\":\"uint256\"}],\"name\":\"StartMintingIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AMMPairAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"Add\",\"type\":\"bool\"}],\"name\":\"TeamAddOrRemoveAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsUntilUnlock\",\"type\":\"uint256\"}],\"name\":\"TeamLockLiquidityForSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"Treshold\",\"type\":\"uint8\"}],\"name\":\"TeamSetLiquifyTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"TresholdPermille\",\"type\":\"uint8\"}],\"name\":\"TeamSetOverLiquifyTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"TeamSetStakingExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"TeamSwitchSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"pancakePermille\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"TeamTriggerLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strandedToken\",\"type\":\"address\"}],\"name\":\"TeamWithdrawStrandedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoPayoutDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityLockSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"LockedSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"Excluded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ExcludedFromStaking\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnTax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAutoPayout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overLiquifyTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"paidOutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLPBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "XBM", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7451a5f4124aa42b4441f1f1a2d0ee936b2debf34d19cfd17bee9d79dce43cda"}