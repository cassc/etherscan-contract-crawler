{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n} \r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n/**\r\n    Stake EGC\r\n    Packages are slow distributions of whatever token they want\r\n        Can choose 1,000 USDT over 10 days\r\n        Everyone who has staked EGC will receive those rewards\r\n        Can create however many they want\r\n        User can claim directly\r\n        User can compound - which sells the token for more EGC\r\n            - Does not re-lock user when compounding\r\n        Lock Timer With Leave-Early-Fee\r\n */\r\ncontract EverGrowStaking is Ownable, ReentrancyGuard {\r\n\r\n    // Staking Token\r\n    address public immutable token;\r\n\r\n    // ERC20 Stuff\r\n    string public constant name = \"Staked EGC\";\r\n    string public constant symbol = \"SEGC\";\r\n    uint8 public immutable decimals;\r\n\r\n    // Precision for token decimal accuracy\r\n    uint256 private constant PRECISION = 10**18;\r\n\r\n    // Lock Time\r\n    uint256 public entryFee; // out of 1,000 -> 0.1% fee precision\r\n    uint256 public exitFee;  // out of 1,000 -> 0.1% fee precision\r\n    uint256 private constant fee_denom = 1_000;\r\n    address public feeRecipient;\r\n\r\n    // Staking Amount\r\n    uint256 public totalStaked;\r\n\r\n    // User Info\r\n    struct UserInfo {\r\n        uint256 amount;\r\n    }\r\n    mapping ( address => UserInfo ) public userInfo;\r\n\r\n    // Packages Info\r\n    struct RewardPackage {\r\n        address rewardToken; // token thats being distributed\r\n        uint256 totalToDistribute; // total number of tokens to distribute over time period\r\n        uint256 totalDistributed; // total number of tokens already distributed\r\n        uint256 tokensPerSecond; // number of tokens to distribute to the pool per second\r\n        uint256 timePeriod; // length of time in seconds that this package is distributing rewards\r\n        uint256 endTime; // time when this package ends\r\n        uint256 startTime; // time whent this package started\r\n\r\n        uint256 dividendsPerShare; // number of tokens receivable for each share of the contract\r\n        uint256 lastUpdate; // last time dividendsPerShare was updated\r\n        bool hasEnded; // true if package has ended\r\n\r\n        address[] swapPath; // swap path between rewardToken and token\r\n        address DEX; // Exchange to swap for token\r\n        mapping ( address => uint256 ) totalExcluded; // maps an address to the dividendsPerShare value last claimed\r\n    }\r\n\r\n    // nonce tracking the package number\r\n    uint256 public packageNonce;\r\n\r\n    // starting index for package looping\r\n    uint256 public startIndex;\r\n\r\n    // total number of unique stakers\r\n    uint256 public totalStakers;\r\n\r\n    // pause the contract, staking, unstaking, claiming, compounding\r\n    bool public pause;\r\n\r\n    // whether or not emergency withdraw is enabled\r\n    bool public emergencyWithdrawEnabled;\r\n\r\n    // Maps a package nonce to a package with info\r\n    mapping ( uint256 => RewardPackage ) private packages;\r\n\r\n    // Transfer Event\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    constructor(\r\n        address _token,\r\n        uint256 _exitFee,\r\n        address _feeRecipient\r\n    ){ \r\n        require(\r\n            _token != address(0),\r\n            'Zero Address'\r\n        );\r\n        require(\r\n            _feeRecipient != address(0),\r\n            'Zero Address'\r\n        );\r\n        token = _token;\r\n        decimals = IERC20(_token).decimals();\r\n\r\n        exitFee = _exitFee;\r\n        feeRecipient = _feeRecipient;\r\n    }\r\n\r\n    /////////////////////////////////////////////////\r\n    /////////       OWNER FUNCTIONS         /////////\r\n    /////////////////////////////////////////////////\r\n\r\n    function addPackage(\r\n        address rewardToken,\r\n        uint256 totalToDistribute,\r\n        uint256 timePeriod,\r\n        address[] calldata swapPath,\r\n        address DEX\r\n    ) external onlyOwner {\r\n        require(\r\n            rewardToken != address(0),\r\n            'Zero Address'\r\n        );\r\n        require(\r\n            totalToDistribute > 0,\r\n            'Zero Tokens To Distribute'\r\n        );\r\n        require(\r\n            timePeriod >= 43200,\r\n            'Time Period Must Be Greater Than Or Equal To 12 Hours'\r\n        );\r\n        require(\r\n            timePeriod <= 7300 days,\r\n            'Time Period Cannot Exceed 20 Years'\r\n        );\r\n        if (DEX != address(0)) {\r\n            require(\r\n                swapPath[0] == rewardToken,\r\n                'Invalid Swap Path'\r\n            );\r\n            require(\r\n                swapPath.length >= 2,\r\n                'Invalid Swap Path Length'\r\n            );\r\n        }        \r\n\r\n        // transfer in tokens\r\n        uint256 received = _transferIn(rewardToken, totalToDistribute);\r\n\r\n        // maps the package nonce\r\n        packages[packageNonce].rewardToken = rewardToken;\r\n        packages[packageNonce].totalToDistribute = received;\r\n        packages[packageNonce].tokensPerSecond = totalToDistribute / timePeriod;\r\n        packages[packageNonce].timePeriod = timePeriod;\r\n        packages[packageNonce].endTime = block.timestamp + timePeriod;\r\n        packages[packageNonce].lastUpdate = block.timestamp;\r\n        packages[packageNonce].swapPath = swapPath;\r\n        packages[packageNonce].DEX = DEX;\r\n        packages[packageNonce].startTime = block.timestamp;\r\n\r\n        // increment nonce\r\n        unchecked {\r\n            ++packageNonce;\r\n        }\r\n    }\r\n\r\n    function alterPackage(\r\n        uint256 packageId,\r\n        address DEX,\r\n        uint256 additionalTokens,\r\n        int256 daysToAddOrSubtract,\r\n        bool addNewTokens,\r\n        bool editTiming\r\n    ) external onlyOwner {\r\n        require(\r\n            packageId < packageNonce,\r\n            'Invalid PackageID'\r\n        );\r\n        require(\r\n            packageId >= startIndex,\r\n            'Package Out Of Bounds'\r\n        );\r\n        require(\r\n            !packageHasEnded(packageId),\r\n            'Cannot Revive An Ended Package'\r\n        );\r\n\r\n        // Update DEX state\r\n        packages[packageId].DEX = DEX;\r\n\r\n        // Update the totalToDistribute and tokensPerSecond values\r\n        if (addNewTokens) {\r\n            // transfer in new tokens, noting amount received for fee-on-transfer tokens\r\n            if (additionalTokens > 0) {\r\n                additionalTokens = _transferIn(packages[packageId].rewardToken, additionalTokens);\r\n                packages[packageId].totalToDistribute += additionalTokens;\r\n            }\r\n        } else {\r\n            if (additionalTokens > 0) {\r\n                require(additionalTokens <= packages[packageId].totalToDistribute, \"Removing too many tokens\");\r\n                packages[packageId].totalToDistribute -= additionalTokens;\r\n                // transfer out unused tokens\r\n                _send(packages[packageId].rewardToken, msg.sender, additionalTokens);\r\n            }\r\n        }\r\n\r\n        // update reward tracking for package, if and only if there are stakers\r\n        if (totalStaked > 0) {\r\n            // Calculate time since last update\r\n            uint256 tSince = timeSinceUpdated(packageId);\r\n            uint256 amountOwed = tSince * packages[packageId].tokensPerSecond;\r\n\r\n            // Fetch difference between total distributed and total to distribute\r\n            uint256 max_extra_rewards = packages[packageId].totalToDistribute - packages[packageId].totalDistributed;\r\n\r\n            // If the amount owed is greater than this value, clamp it\r\n            if (amountOwed > max_extra_rewards) {\r\n                amountOwed = max_extra_rewards;\r\n            }\r\n\r\n            // Increase dividendsPerShare by this value\r\n            unchecked {\r\n                packages[packageId].totalDistributed += amountOwed;\r\n                packages[packageId].dividendsPerShare += (amountOwed * PRECISION) / totalStaked;\r\n            }\r\n\r\n            // update timing on package\r\n            packages[packageId].lastUpdate = block.timestamp;\r\n        }\r\n\r\n        // Edit timing if required\r\n        if (editTiming) {\r\n            if (daysToAddOrSubtract > 0) {\r\n                packages[packageId].timePeriod += uint256(daysToAddOrSubtract) * 1 days;\r\n                packages[packageId].endTime += uint256(daysToAddOrSubtract) * 1 days;\r\n            } else if (daysToAddOrSubtract < 0) {\r\n                uint256 daysToSubtract = uint256(-daysToAddOrSubtract);\r\n                require(\r\n                    packages[packageId].timePeriod > daysToSubtract * 1 days,\r\n                    'Subtracting Too Many Days'\r\n                );\r\n                packages[packageId].timePeriod -= daysToSubtract * 1 days;\r\n                packages[packageId].endTime -= daysToSubtract * 1 days;\r\n            }\r\n        }\r\n\r\n        // Ensure adding or removing tokens does not mess up the totalToDistribute field vs totalDistributed\r\n        require(\r\n            packages[packageId].totalToDistribute >= packages[packageId].totalDistributed,\r\n            'Took Too Many Tokens Away'\r\n        );\r\n\r\n        // Reset tokens per second, if applicable\r\n        if (packages[packageId].timePeriod > 0) {\r\n            packages[packageId].tokensPerSecond = packages[packageId].totalToDistribute / packages[packageId].timePeriod;\r\n        }\r\n\r\n        // If totalToDistribute matches total distributed, end package\r\n        if (\r\n            packages[packageId].totalToDistribute == packages[packageId].totalDistributed || \r\n            packages[packageId].endTime <= block.timestamp || \r\n            packages[packageId].timePeriod == 0\r\n        ) {\r\n            packages[packageId].hasEnded = true;\r\n        }\r\n    }\r\n\r\n    function withdraw(address _token, address _to, uint256 _amount) external onlyOwner {\r\n        _send(_token, _to, _amount);\r\n    }\r\n\r\n    function setEmergencyWithdrawEnabled(bool _enabled) external onlyOwner {\r\n        emergencyWithdrawEnabled = _enabled;\r\n    }\r\n\r\n    function setExitFee(uint256 newFee) external onlyOwner {\r\n        require(\r\n            newFee <= 800,\r\n            'Fee Too High'\r\n        );\r\n        exitFee = newFee;\r\n    }\r\n\r\n    function setEntryFee(uint256 entryFee_) external onlyOwner {\r\n        require(\r\n            entryFee_ <= 800,\r\n            'Fee Too High'\r\n        );\r\n        entryFee = entryFee_;\r\n    }\r\n\r\n    function setFeeRecipient(address newRecipient) external onlyOwner {\r\n        require(\r\n            newRecipient != address(0),\r\n            'Zero Address'\r\n        );\r\n        feeRecipient = newRecipient;\r\n    }\r\n\r\n    function endPackage(uint256 packageId, bool _transferOutTokens) external onlyOwner {\r\n        require(\r\n            !packages[packageId].hasEnded,\r\n            'Package Already Ended'\r\n        );\r\n        require(\r\n            packageId < packageNonce,\r\n            'Invalid ID'\r\n        );\r\n\r\n        // calculate time since last update\r\n        uint256 tSince = timeSinceUpdated(packageId);\r\n        uint256 amountOwed = tSince * packages[packageId].tokensPerSecond;\r\n\r\n        // fetch difference between total distributed and total to distribute\r\n        uint256 max_extra_rewards = packages[packageId].totalToDistribute - packages[packageId].totalDistributed;\r\n\r\n        // if the amount owed is greater than this value, clamp it\r\n        if (amountOwed > max_extra_rewards) {\r\n            amountOwed = max_extra_rewards;\r\n        }\r\n\r\n        // alter staking info for package, if and only if there are stakers\r\n        if (totalStaked > 0) {\r\n\r\n            // increase dividendsPerShare by this value\r\n            unchecked {\r\n                packages[packageId].totalDistributed += amountOwed;\r\n                packages[packageId].dividendsPerShare += ( amountOwed * PRECISION ) / totalStaked;\r\n            }\r\n\r\n            // update timing on package\r\n            packages[packageId].lastUpdate = block.timestamp;\r\n        }\r\n        \r\n        // reset the totalToDistribute\r\n        packages[packageId].totalToDistribute = packages[packageId].totalDistributed;\r\n\r\n        // end package\r\n        packages[packageId].hasEnded = true;\r\n        packages[packageId].endTime = block.timestamp;\r\n\r\n        // determine difference\r\n        uint256 differenceForOwner = max_extra_rewards - amountOwed;\r\n        if (differenceForOwner > 0 && _transferOutTokens) {\r\n            _send(packages[packageId].rewardToken, msg.sender, differenceForOwner);\r\n        }\r\n    }\r\n\r\n    function setDEX(uint256 packageId, address DEX) external onlyOwner {\r\n        packages[packageId].DEX = DEX;\r\n        if (DEX != address(0)) {\r\n            require(\r\n                packages[packageId].swapPath[0] == packages[packageId].rewardToken,\r\n                'Invalid Swap Path'\r\n            );\r\n            require(\r\n                packages[packageId].swapPath.length >= 2,\r\n                'Invalid Swap Path Length'\r\n            );\r\n        }\r\n    }\r\n    \r\n    function setSwapPath(uint256 packageId, address[] calldata swapPath) external onlyOwner {\r\n        require(\r\n            swapPath[0] == packages[packageId].rewardToken,\r\n            'Invalid Swap Path'\r\n        );\r\n        require(\r\n            swapPath.length >= 2,\r\n            'Invalid Swap Path Length'\r\n        );\r\n        packages[packageId].swapPath = swapPath;\r\n    }\r\n\r\n    function claimAllRewardsForUser(address user, bool _compound) external onlyOwner {\r\n        _claimAll(user, _compound);\r\n    }\r\n\r\n    function claimAllRewardsForUsers(address[] calldata users, bool _compound) external onlyOwner {\r\n        uint len = users.length;\r\n        for (uint i = 0; i < len;) {\r\n            _claimAll(users[i], _compound);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setStartIndex(uint256 newStart) external onlyOwner {\r\n        require(\r\n            newStart < packageNonce,\r\n            'newStart is out of bounds'\r\n        );\r\n        require(\r\n            newStart > startIndex,\r\n            'Cannot Go Backwards'\r\n        );\r\n        for (uint i = startIndex; i < newStart;) {\r\n            require(\r\n                packageHasEnded(i),\r\n                'Cannot Set Start Index Passed An Ongoing Package'\r\n            );\r\n            unchecked { ++i; }\r\n        }\r\n        startIndex = newStart;\r\n    }\r\n\r\n    function setPause(bool isPaused) external onlyOwner {\r\n        pause = isPaused;\r\n    }\r\n\r\n    /////////////////////////////////////////////////\r\n    /////////      PUBLIC FUNCTIONS         /////////\r\n    /////////////////////////////////////////////////\r\n\r\n    function cleanUpPackages() external nonReentrant() {\r\n        _cleanUpPackages();\r\n    }\r\n\r\n    function stake(uint256 amount) external nonReentrant {\r\n        require(\r\n            amount > 0,\r\n            'Cannot Stake Zero Tokens'\r\n        );\r\n        require(\r\n            !pause,\r\n            'PAUSED'\r\n        );\r\n\r\n        // clean up packages\r\n        _cleanUpPackages();\r\n\r\n        if (userInfo[msg.sender].amount == 0) {\r\n            unchecked { ++totalStakers; }\r\n        } else {\r\n            // claim pending rewards\r\n            _claimAll(msg.sender, false);\r\n        }\r\n\r\n        // transfer in tokens, noting amount received\r\n        uint256 received = _transferIn(token, amount);\r\n\r\n        // apply entry fee\r\n        uint256 fee = ( received * entryFee ) / fee_denom;\r\n        uint256 amountToAdd = received - fee;\r\n\r\n        // take fee\r\n        _takeFee(fee);\r\n\r\n        // update State\r\n        unchecked {\r\n            userInfo[msg.sender].amount += amountToAdd;\r\n            totalStaked += amountToAdd;\r\n        }\r\n\r\n        // if first stake, reset all pending rewards\r\n        _resetRewards(msg.sender);\r\n\r\n        // emit event for block explorer\r\n        emit Transfer(address(0), msg.sender, amountToAdd);\r\n    }\r\n\r\n    function unstake(uint256 amount) external nonReentrant {\r\n        require(\r\n            amount > 0,\r\n            'Cannot Withdraw Zero Tokens'\r\n        );\r\n        require(\r\n            amount <= userInfo[msg.sender].amount,\r\n            'Insufficient Amount'\r\n        );\r\n        require(\r\n            !pause,\r\n            'PAUSED'\r\n        );\r\n\r\n        // clean up packages\r\n        _cleanUpPackages();\r\n\r\n        // claim all pending rewards\r\n        _claimAll(msg.sender, false);\r\n\r\n        // decrement amount and total staked\r\n        unchecked {\r\n            userInfo[msg.sender].amount -= amount;\r\n            totalStaked -= amount;\r\n        }\r\n\r\n        // emit event\r\n        emit Transfer(msg.sender, address(0), amount);\r\n\r\n        // decrement total stakers if new amount is zero\r\n        if (userInfo[msg.sender].amount == 0) {\r\n            unchecked {\r\n                --totalStakers;\r\n            }\r\n        }\r\n\r\n        // reset rewards\r\n        _resetRewards(msg.sender);\r\n\r\n        // take early fee if applicable\r\n        uint256 earlyFee = ( amount * exitFee ) / fee_denom;\r\n        _takeFee(earlyFee);\r\n\r\n        // send tokens to user\r\n        _send(token, msg.sender, amount - earlyFee);\r\n    }\r\n\r\n    /**\r\n        Allows user to withdraw tokens without claiming rewards in the event of some failure\r\n     */\r\n    function emergencyWithdraw() external nonReentrant {\r\n        require(\r\n            !pause,\r\n            'PAUSED'\r\n        );\r\n        require(\r\n            emergencyWithdrawEnabled,\r\n            'Emergency Withdraw Not Enabled'\r\n        );\r\n        require(\r\n            userInfo[msg.sender].amount > 0,\r\n            'Insufficient Amount'\r\n        );\r\n\r\n        // decrement amount and total staked\r\n        uint256 amount = userInfo[msg.sender].amount;\r\n        delete userInfo[msg.sender].amount;\r\n        unchecked {\r\n            totalStaked -= amount;\r\n            --totalStakers;\r\n        }\r\n\r\n        // emit event\r\n        emit Transfer(msg.sender, address(0), amount);\r\n\r\n        // reset rewards\r\n        _resetRewards(msg.sender);\r\n\r\n        // clean up packages\r\n        _cleanUpPackages();\r\n\r\n        // take early fee if applicable\r\n        uint256 earlyFee = ( amount * exitFee ) / fee_denom;\r\n        _takeFee(earlyFee);\r\n\r\n        // send tokens to user\r\n        _send(token, msg.sender, amount - earlyFee);\r\n    }\r\n\r\n    function claim() external nonReentrant {\r\n        require(\r\n            !pause,\r\n            'PAUSED'\r\n        );\r\n        _claimAll(msg.sender, false);\r\n    }\r\n\r\n    function claimSpecificPackage(uint256 packageId) external nonReentrant {\r\n        require(\r\n            !pause,\r\n            'PAUSED'\r\n        );\r\n        require(\r\n            packageId < packageNonce && packageId >= startIndex,\r\n            'Invalid ID'\r\n        );\r\n        _claim(msg.sender, packageId, false);\r\n    }\r\n\r\n    function compoundSpecificPackage(uint256 packageId) external nonReentrant {\r\n        require(\r\n            !pause,\r\n            'PAUSED'\r\n        );\r\n        require(\r\n            packageId < packageNonce && packageId >= startIndex,\r\n            'Invalid ID'\r\n        );\r\n        _claim(msg.sender, packageId, true);\r\n    }\r\n\r\n    function compound() external nonReentrant {\r\n        require(\r\n            !pause,\r\n            'PAUSED'\r\n        );\r\n        _claimAll(msg.sender, true);\r\n    }\r\n\r\n    /**\r\n        In the event a reward token halts transfers, users can reset their pending rewards (ideally after the owner has removed the package)\r\n     */\r\n    function resetUserRewards(uint256 packageId, address user) external nonReentrant {\r\n        packages[packageId].totalExcluded[user] = getTotalExcluded(user, packageId);\r\n    }\r\n\r\n    /////////////////////////////////////////////////\r\n    /////////        READ FUNCTIONS         /////////\r\n    /////////////////////////////////////////////////\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return totalStaked;\r\n    }\r\n\r\n    function balanceOf(address user) external view returns (uint256) {\r\n        return userInfo[user].amount;\r\n    }\r\n\r\n    function packageHasEnded(uint256 packageId) public view returns (bool) {\r\n        return \r\n            packages[packageId].endTime <= block.timestamp || \r\n            packages[packageId].totalDistributed >= packages[packageId].totalToDistribute ||\r\n            packages[packageId].hasEnded;\r\n    }\r\n\r\n    function timeSinceUpdated(uint256 packageId) public view returns (uint256) {\r\n        if (packageId >= packageNonce || packageHasEnded(packageId)) {\r\n            return 0;\r\n        }\r\n        return packages[packageId].lastUpdate >= block.timestamp ? 0 : block.timestamp - packages[packageId].lastUpdate;\r\n    }\r\n\r\n    function getTotalExcluded(address user, uint256 packageId) public view returns (uint256) {\r\n        return ( userInfo[user].amount * packages[packageId].dividendsPerShare ) / PRECISION;\r\n    }\r\n\r\n    function pendingRewards(address user, uint256 packageId) public view returns (uint256) {\r\n        if (userInfo[user].amount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 userExcluded = packages[packageId].totalExcluded[user];\r\n        uint256 currentNonExcluded = getTotalExcluded(user, packageId);\r\n\r\n        return currentNonExcluded <= userExcluded ? 0 : currentNonExcluded - userExcluded;\r\n    }\r\n\r\n    /////////////////////////////////////////////////\r\n    /////////      INTERNAL FUNCTIONS       /////////\r\n    /////////////////////////////////////////////////\r\n\r\n    function _takeFee(uint256 amount) internal {\r\n        _send(token, feeRecipient, amount);\r\n    }\r\n\r\n    function _transferIn(address _token, uint256 amount) internal returns (uint256) {\r\n        require(\r\n            IERC20(_token).balanceOf(msg.sender) >= amount,\r\n            'Insufficient Balance'\r\n        );\r\n        require(\r\n            IERC20(_token).allowance(msg.sender, address(this)) >= amount,\r\n            'Insufficient Allowance'\r\n        );\r\n        uint256 amountBefore = IERC20(_token).balanceOf(address(this));\r\n        TransferHelper.safeTransferFrom(_token, msg.sender, address(this), amount);\r\n        uint256 amountAfter = IERC20(_token).balanceOf(address(this));\r\n        require(\r\n            amountAfter > amountBefore,\r\n            'Zero Received'\r\n        );\r\n        return amountAfter - amountBefore;\r\n    }\r\n\r\n    function _resetRewards(address user) internal {\r\n\r\n        for (uint i = 0; i < packageNonce;) {\r\n            packages[i].totalExcluded[user] = getTotalExcluded(user, i);\r\n            unchecked { ++i; }\r\n        }\r\n\r\n    }\r\n\r\n    function _claimAll(address user, bool _compound) internal {\r\n        for (uint i = startIndex; i < packageNonce;) {\r\n            _claim(user, i, _compound);\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    function _claim(address user, uint256 packageId, bool _compound) internal {\r\n        if (packageId >= packageNonce) {\r\n            return;\r\n        }\r\n        if (packageHasEnded(packageId) && packages[packageId].totalExcluded[user] == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 pending = pendingRewards(user, packageId);\r\n        if (pending == 0) {\r\n            return;\r\n        }\r\n        uint256 max_balance = IERC20(packages[packageId].rewardToken).balanceOf(address(this));\r\n        if (pending > max_balance) {\r\n            pending = max_balance;\r\n        }\r\n        if (pending == 0) {\r\n            return;\r\n        }\r\n\r\n        // reset rewards\r\n        packages[packageId].totalExcluded[user] = getTotalExcluded(user, packageId);\r\n\r\n        // compound rewards if applicable\r\n        if (_compound && packages[packageId].DEX != address(0)) {\r\n            \r\n            // Approve of token for DEX\r\n            TransferHelper.safeApprove(packages[packageId].rewardToken, packages[packageId].DEX, pending);\r\n\r\n            // Make the swap\r\n            IUniswapV2Router02(packages[packageId].DEX).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                pending,\r\n                1,\r\n                packages[packageId].swapPath,\r\n                user,\r\n                block.timestamp + 100\r\n            );\r\n\r\n        } else {\r\n            // send user their reward\r\n            _send(packages[packageId].rewardToken, user, pending);\r\n        }\r\n    }\r\n\r\n    function _send(address _token, address to, uint256 amount) internal {\r\n        uint bal = IERC20(_token).balanceOf(address(this));\r\n        if (amount > bal) {\r\n            amount = bal;\r\n        }\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        TransferHelper.safeTransfer(_token, to, amount);\r\n    }\r\n\r\n    function _cleanUpPackages() internal {\r\n        if (totalStaked == 0) {\r\n            return;\r\n        }\r\n\r\n        for (uint i = startIndex; i < packageNonce;) {\r\n            if (packages[i].hasEnded) {\r\n                unchecked { ++i; }\r\n                continue;\r\n            }\r\n\r\n            if (packages[i].endTime <= block.timestamp) {\r\n                if (packages[i].totalDistributed < packages[i].totalToDistribute) {\r\n                    \r\n                    // determine remaining amount to add\r\n                    uint256 diff = packages[i].totalToDistribute - packages[i].totalDistributed;\r\n                    \r\n                    // add to package\r\n                    unchecked {\r\n                        packages[i].totalDistributed += diff;\r\n                        packages[i].dividendsPerShare += ( diff * PRECISION ) / totalStaked;\r\n                    }\r\n                }\r\n                packages[i].hasEnded = true;\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // loop through available packages, increasing the dividendsPerShare based on time\r\n        for (uint i = startIndex; i < packageNonce;) {\r\n            if (packages[i].hasEnded) {\r\n                unchecked { ++i; }\r\n                continue;\r\n            }\r\n\r\n            // determine the amount of time since package was updated\r\n            uint256 timeSince = timeSinceUpdated(i);\r\n            if (timeSince == 0) {\r\n                unchecked { ++i; }\r\n                continue;\r\n            }\r\n\r\n            // fetch the tokens per second\r\n            uint256 tokensPerSecond = packages[i].tokensPerSecond;\r\n\r\n            // determine the number of tokens owed to holders\r\n            uint256 amountOwed = tokensPerSecond * timeSince;\r\n\r\n            // fetch difference between total distributed and total to distribute\r\n            uint256 max_extra_rewards = packages[i].totalToDistribute - packages[i].totalDistributed;\r\n\r\n            // if the amount owed is greater than this value, clamp it\r\n            if (amountOwed > max_extra_rewards) {\r\n                amountOwed = max_extra_rewards;\r\n            }\r\n\r\n            // increase dividendsPerShare by this value\r\n            unchecked {\r\n                packages[i].totalDistributed += amountOwed;\r\n                packages[i].dividendsPerShare += ( amountOwed * PRECISION ) / totalStaked;\r\n                ++i;\r\n            }\r\n\r\n            // update timing on package\r\n            packages[i].lastUpdate = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function getIdsOfActivePackages() external view returns (uint256[] memory) {\r\n        uint256 len = 0;\r\n        for (uint i = startIndex; i < packageNonce; ++i) {\r\n            if (!packageHasEnded(i)) {\r\n                unchecked { ++len; }\r\n            }\r\n        }\r\n        uint256[] memory activePackages = new uint256[](len);\r\n        uint count = 0;\r\n        for (uint i = startIndex; i < packageNonce; ++i) {\r\n            if (!packageHasEnded(i)) {\r\n               activePackages[count] = i;\r\n               unchecked { ++count; }\r\n            }\r\n        }\r\n        return activePackages;\r\n    }\r\n\r\n    function getSwapPath(\r\n        uint256 packageId\r\n    ) external view returns (address[] memory) {\r\n        return packages[packageId].swapPath;\r\n    }\r\n\r\n    function getRewardPackageInfo(\r\n        uint256 packageId\r\n    ) external view returns (\r\n        address rewardToken,\r\n        uint256 totalToDistribute,\r\n        uint256 totalDistributed,\r\n        uint256 tokensPerSecond,\r\n        uint256 timePeriod,\r\n        uint256 endTime,\r\n        uint256 dividendsPerShare,\r\n        uint256 lastUpdate,\r\n        bool hasEnded,\r\n        address DEX,\r\n        uint256 startTime\r\n    ) {\r\n        rewardToken = packages[packageId].rewardToken;\r\n        totalToDistribute = packages[packageId].totalToDistribute;\r\n        totalDistributed = packages[packageId].totalDistributed;\r\n        tokensPerSecond = packages[packageId].tokensPerSecond;\r\n        timePeriod = packages[packageId].timePeriod;\r\n        endTime = packages[packageId].endTime;\r\n        dividendsPerShare = packages[packageId].dividendsPerShare;\r\n        lastUpdate = packages[packageId].lastUpdate;\r\n        hasEnded = packages[packageId].hasEnded;\r\n        DEX = packages[packageId].DEX;\r\n        startTime = packages[packageId].startTime;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_exitFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalToDistribute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePeriod\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"swapPath\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"DEX\",\"type\":\"address\"}],\"name\":\"addPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"DEX\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"additionalTokens\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"daysToAddOrSubtract\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"addNewTokens\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"editTiming\",\"type\":\"bool\"}],\"name\":\"alterPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_compound\",\"type\":\"bool\"}],\"name\":\"claimAllRewardsForUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_compound\",\"type\":\"bool\"}],\"name\":\"claimAllRewardsForUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"claimSpecificPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cleanUpPackages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"compoundSpecificPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_transferOutTokens\",\"type\":\"bool\"}],\"name\":\"endPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdsOfActivePackages\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"getRewardPackageInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalToDistribute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dividendsPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"DEX\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"getSwapPath\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"getTotalExcluded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"packageHasEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"packageNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"resetUserRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"DEX\",\"type\":\"address\"}],\"name\":\"setDEX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setEmergencyWithdrawEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"entryFee_\",\"type\":\"uint256\"}],\"name\":\"setEntryFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setExitFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStart\",\"type\":\"uint256\"}],\"name\":\"setStartIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"swapPath\",\"type\":\"address[]\"}],\"name\":\"setSwapPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"timeSinceUpdated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EverGrowStaking", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c001bbe2b87079294c63ece98bdd0a88d761434e00000000000000000000000000000000000000000000000000000000000000140000000000000000000000009394f5eb46972b1cf22c9ecf5f5cb34f36d5b794", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6b98d95ffb90e36e4f9f01a5cf27ca33145e0f4e3a421ef9e0c5eb1d378e2988"}