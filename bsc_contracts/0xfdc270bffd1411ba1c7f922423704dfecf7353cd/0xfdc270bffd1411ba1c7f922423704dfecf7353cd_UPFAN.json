{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UPFAN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n \\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n \\nlibrary SafeMath {\\n \\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n \\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n \\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n  \\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n \\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n \\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n \\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n \\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n \\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n \\nlibrary Address {\\n \\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n \\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n \\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n \\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n    \\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n \\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n \\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n \\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n \\ncontract Ownable is Context {\\n    address internal _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n \\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n \\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n \\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n \\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n \\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n \\n    function WETH() external pure returns (address);\\n \\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n     function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n}\\n \\ncontract UPFAN is Context, IERC20, Ownable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n \\n    mapping (address => uint256) private _tOwned;\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n \\n    mapping (address => bool) private _isExcludedFromFee;\\n   \\n    uint256 private _decimals = 18;\\n    uint256 private _tTotal = 100000000 * 10**18;\\n \\n    string private _name = \\\"Up Fan\\\";\\n    string private _symbol = \\\"UPFAN\\\";\\n    \\n    uint256 public _buyLiquidityFee = 40;\\n    uint256 public _sellLiquidityFee = 40;\\n    uint256 public _transferLiquidityFee = 40;\\n \\n    uint256 public _buyBurnFee = 40;\\n    uint256 public _sellBurnFee = 40;\\n    uint256 public _transferBurnFee = 40;\\n\\n    uint256 public totalBuyFee = 80;\\n    uint256 public totalSellFee = 80;\\n    uint256 public totalTransferFee = 80;\\n    uint256 public transferFee = 80;\\n   \\n    IUniswapV2Router02 public  uniswapV2Router;\\n    address public  uniswapV2Pair;\\n \\n    mapping(address => bool) public ammPairs;\\n    \\n    bool inSwapAndLiquify;\\n    \\n    uint256 public _maxTxAmount = 200 * 10**18;\\n\\n    uint256 public _minRelationAmount = 5 * 10**17;\\n    \\n    address public wbnb;\\n \\n    address public holder;\\n \\n    address constant public rootAddress = address(0x000000000000000000000000000000000000dEaD);\\n    \\n    mapping (address => address) public _recommerMapping;\\n\\n    mapping(uint256 => address) public totalUserAddres;\\n\\n    uint256 public userTotal = 0;\\n\\n    uint256 public startTime;\\n\\n    bool public swapLock = true;\\n\\n    mapping(address => bool) public whitelist;\\n    mapping(address => bool) public antiRobot;\\n    mapping(address => bool) public poolWhitelist;\\n\\n \\n    modifier lockTheSwap {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n    \\n    constructor (){\\n        holder = msg.sender;\\n\\n        _recommerMapping[rootAddress] = address(0xdeaddead);\\n        _recommerMapping[holder] = rootAddress;\\n        userTotal++;\\n        totalUserAddres[userTotal] = holder;\\n \\n        _tOwned[holder] = _tTotal;\\n        \\n        startTime = block.timestamp;\\n\\n        whitelist[holder] =  true;\\n        poolWhitelist[holder] = true;\\n      \\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        uniswapV2Router = _uniswapV2Router;\\n        address _uniswapV2Pair  = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n\\n        wbnb = _uniswapV2Router.WETH();\\n\\n        uniswapV2Pair = _uniswapV2Pair;\\n\\n        ammPairs[uniswapV2Pair] = true;\\n\\n        _isExcludedFromFee[holder] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n\\n        _owner = msg.sender;\\n\\n        emit Transfer(address(0), holder, _tTotal);\\n    }\\n\\n    function setWhilteList(address _addr) external onlyOwner{\\n        whitelist[_addr] =  true;\\n    }\\n\\n    function cancelWhilteList(address _addr) external onlyOwner{\\n        whitelist[_addr] =  false;\\n    }\\n\\n    function lockAntiRobot(address _addr) external onlyOwner{\\n        antiRobot[_addr] = true;\\n    }\\n\\n    function setFreeAntiRobot(address _addr) external onlyOwner{\\n        antiRobot[_addr] = false;\\n    }\\n \\n    function setSwapLock() external onlyOwner{\\n        swapLock = !swapLock;\\n    }\\n\\n    function getDay() public view returns (uint256) {\\n        return (block.timestamp - startTime)/1 days;\\n    }\\n \\n    function setAmmPair(address pair,bool hasPair)external onlyOwner{\\n        ammPairs[pair] = hasPair;\\n    }\\n \\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n \\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n \\n    function decimals() public view returns (uint256) {\\n        return _decimals;\\n    }\\n \\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n \\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _tOwned[account];\\n    }\\n \\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n \\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n \\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n \\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n \\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n    \\n    function excludeFromFee(address account) public onlyOwner {\\n        _isExcludedFromFee[account] = true;\\n    }\\n \\n    function excludeFromFees(address[] memory accounts) public onlyOwner{\\n        uint len = accounts.length;\\n        for( uint i = 0; i < len; i++ ){\\n            _isExcludedFromFee[accounts[i]] = true;\\n        }\\n    }\\n    \\n    function includeInFee(address account) public onlyOwner {\\n        _isExcludedFromFee[account] = false;\\n    }\\n    \\n    receive() external payable {}\\n \\n    function _take(uint256 tValue,address from,address to) private {\\n        _tOwned[to] = _tOwned[to].add(tValue);\\n        emit Transfer(from, to, tValue);\\n    }\\n    \\n    function getForefathers(address owner,uint num) internal view returns(address[] memory fathers){\\n        fathers = new address[](num);\\n        address parent  = owner;\\n        for( uint i = 0; i < num; i++){\\n            parent = _recommerMapping[parent];\\n            if( parent == rootAddress || parent == address(0) ) break;\\n            fathers[i] = parent;\\n        }\\n    }\\n    \\n    function isExcludedFromFee(address account) public view returns(bool) {\\n        return _isExcludedFromFee[account];\\n    }\\n \\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n \\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n \\n    event AddRelation(address recommer, address user);\\n    \\n    function addRelationEx(address recommer,address user) internal {\\n        if( \\n            recommer != user \\n            && _recommerMapping[user] == address(0x0) \\n            && _recommerMapping[recommer] != address(0x0) ){\\n                _recommerMapping[user] = recommer;\\n                userTotal++;\\n                totalUserAddres[userTotal] = user;\\n                emit AddRelation(recommer, user);\\n        }       \\n    }\\n \\n    struct Param{\\n        bool takeFee;\\n        uint256 tTransferAmount;\\n        uint256 tLiquidity;\\n        uint256 tBurn;\\n    }\\n\\n    event Record(address indexed a,address indexed b);\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        emit Record(from,to);\\n        if( !to.isContract() \\n            && _recommerMapping[to] == address(0) \\n            && amount >= _minRelationAmount){\\n            if( ammPairs[from]  ){\\n                addRelationEx(holder,to);\\n            }else{\\n                addRelationEx(from,to);\\n            }\\n        }\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        \\n        if( \\n            contractTokenBalance >= _maxTxAmount \\n            && !inSwapAndLiquify \\n            && !ammPairs[from] \\n            && !ammPairs[to]\\n            && IERC20(uniswapV2Pair).totalSupply() > 10 * 10**18 ){\\n \\n            swapAndLiquify(contractTokenBalance);\\n        }\\n        \\n        bool takeFee = true;\\n        if( _isExcludedFromFee[from] || _isExcludedFromFee[to] || from ==  address(uniswapV2Router)){\\n            takeFee = false;\\n        }\\n        \\n        Param memory param;\\n        if( takeFee ){\\n            param.takeFee = true;\\n            if(ammPairs[from]){  // buy or removeLiquidity\\n                if(swapLock) {\\n                    require(whitelist[to],\\\"swap locked\\\");\\n                }\\n                _getBuyParam(amount,param);\\n            }\\n            if(ammPairs[to]){\\n                require(!antiRobot[from], \\\"swap locked\\\");\\n                _getSellParam(amount,param);   //sell or addLiquidity\\n            }\\n            if(!ammPairs[from] && !ammPairs[to]){\\n                _getTransferParam(amount,param);\\n            }\\n        }else{\\n            param.takeFee = false;\\n            param.tTransferAmount = amount;\\n        }\\n        _tokenTransfer(from,to,amount,param);\\n    }\\n \\n    function _getBuyParam(uint256 tAmount,Param memory param) private view  {\\n        param.tLiquidity = tAmount.mul(_buyLiquidityFee).div(1000);\\n        param.tBurn = tAmount.mul(_buyBurnFee).div(1000);\\n        uint256 tFee = tAmount.mul(totalBuyFee).div(1000);\\n        param.tTransferAmount = tAmount.sub(tFee);\\n       \\n    }\\n \\n    function _getSellParam(uint256 tAmount,Param memory param) private view  {\\n        param.tLiquidity = tAmount.mul(_sellLiquidityFee).div(1000);\\n        param.tBurn = tAmount.mul(_sellBurnFee).div(1000);\\n        uint256 tFee = tAmount.mul(totalSellFee).div(1000);\\n        param.tTransferAmount = tAmount.sub(tFee);\\n    }\\n \\n    function _getTransferParam(uint256 tAmount,Param memory param) private view {\\n        param.tLiquidity = tAmount.mul(_transferLiquidityFee).div(1000);\\n        param.tBurn = tAmount.mul(_transferBurnFee).div(1000);\\n        uint256 tFee = tAmount.mul(totalTransferFee).div(1000);\\n        param.tTransferAmount = tAmount.sub(tFee);\\n    }\\n \\n    function swapAndLiquify(uint256 contractTokenBalance) private  lockTheSwap{\\n        uint256 half = contractTokenBalance.div(2);\\n        uint256 otherHalf = contractTokenBalance.sub(half);\\n        uint256 initialBalance = address(this).balance;\\n        swapTokensForEth(half,address(this)); \\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\n        addLiquidity(otherHalf, newBalance);\\n    }\\n \\n    function swapTokensForEth(uint256 tokenAmount,address to) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = wbnb;\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, \\n            path,\\n            to,\\n            block.timestamp\\n        );\\n    }\\n \\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            holder,\\n            block.timestamp\\n        );\\n    }\\n \\n    function _takeFee(Param memory param,address from)private {\\n        if( param.tBurn > 0 ){\\n            _take(param.tBurn, from, address(0));\\n        }\\n        if( param.tLiquidity > 0 ){\\n            _take(param.tLiquidity, from, address(this));\\n        }\\n    }\\n\\n    event _param(address indexed sender,uint256 tBurn,uint256 tLiquidity,uint256 tTransferAmount,string a);\\n \\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount,Param memory param) private {\\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\\n        _tOwned[recipient] = _tOwned[recipient].add(param.tTransferAmount);\\n         emit Transfer(sender, recipient, param.tTransferAmount);\\n         \\n        if(param.takeFee){\\n           \\n            emit _param(sender,param.tBurn,param.tLiquidity,param.tTransferAmount,\\\"takeFee true\\\");\\n              _takeFee(param,sender);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recommer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddRelation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"b\",\"type\":\"address\"}],\"name\":\"Record\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tTransferAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"}],\"name\":\"_param\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_buyBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minRelationAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_recommerMapping\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_transferBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_transferLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ammPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"antiRobot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"cancelWhilteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"lockAntiRobot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasPair\",\"type\":\"bool\"}],\"name\":\"setAmmPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFreeAntiRobot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSwapLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWhilteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalUserAddres\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbnb\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UPFAN", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}