{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\ninterface VRFV2WrapperInterface {\r\n  function lastRequestId() external view returns (uint256);\r\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\r\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\r\n}\r\n\r\nabstract contract VRFV2WrapperConsumerBase {\r\n  IERC20 internal immutable LINK;\r\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\r\n  /**\r\n   * @param _link is the address of LinkToken\r\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\r\n   */\r\n  constructor(address _link, address _vrfV2Wrapper) {\r\n    LINK = IERC20(_link);\r\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\r\n  }\r\n  /**\r\n   * @dev Requests randomness from the VRF V2 wrapper.\r\n   *\r\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\r\n   *        fulfillRandomWords function.\r\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\r\n   *        request. A higher number of confirmations increases security by reducing the likelihood\r\n   *        that a chain re-org changes a published randomness outcome.\r\n   * @param _numWords is the number of random words to request.\r\n   *\r\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\r\n   */\r\n  function requestRandomness(\r\n    uint32 _callbackGasLimit,\r\n    uint16 _requestConfirmations,\r\n    uint32 _numWords\r\n  ) internal returns (uint256 requestId) {\r\n    LINK.transferAndCall(\r\n      address(VRF_V2_WRAPPER),\r\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\r\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\r\n    );\r\n    return VRF_V2_WRAPPER.lastRequestId();\r\n  }\r\n  /**\r\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\r\n   * @notice implement it.\r\n   *\r\n   * @param _requestId is the VRF V2 request ID.\r\n   * @param _randomWords is the randomness result.\r\n   */\r\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\r\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\r\n    require(msg.sender == address(VRF_V2_WRAPPER), \"only VRF V2 wrapper can fulfill\");\r\n    fulfillRandomWords(_requestId, _randomWords);\r\n  }\r\n}\r\ncontract VRFv2DirectFundingConsumer is\r\n    VRFV2WrapperConsumerBase\r\n{\r\n    event RequestSent(uint256 requestId, uint32 numWords);\r\n    event RequestFulfilled(\r\n        uint256 requestId,\r\n        uint256[] randomWords,\r\n        uint256 payment\r\n    );\r\n    struct RequestStatus {\r\n        uint256 paid; // amount paid in link\r\n        bool fulfilled; // whether the request has been successfully fulfilled\r\n        uint256[] randomWords;\r\n    }\r\n    mapping(uint256 => RequestStatus)\r\n        public s_requests; /* requestId --> requestStatus */\r\n    // past requests Id.\r\n    uint256[] public requestIds;\r\n    uint256 public lastRequestId;\r\n    uint256 public lastRandomwords;\r\n\r\n    // Depends on the number of requested values that you want sent to the\r\n    // fulfillRandomWords() function. Test and adjust\r\n    // this limit based on the network that you select, the size of the request,\r\n    // and the processing of the callback request in the fulfillRandomWords()\r\n    // function.\r\n    uint32 callbackGasLimit = 150000;\r\n\r\n    // The default is 3, but you can set this higher.\r\n    uint16 requestConfirmations = 3;\r\n\r\n    // For this example, retrieve 2 random values in one request.\r\n    // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.\r\n    uint32 numWords = 1;\r\n\r\n    // Address LINK - hardcoded for Sepolia\r\n    address linkAddress = 0x404460C6A5EdE2D891e8297795264fDe62ADBB75;\r\n\r\n    // address WRAPPER - hardcoded for Sepolia\r\n    address wrapperAddress = 0x721DFbc5Cfe53d32ab00A9bdFa605d3b8E1f3f42;\r\n\r\n    constructor()\r\n         VRFV2WrapperConsumerBase(linkAddress, wrapperAddress)\r\n    {}\r\n    function requestRandomWords() internal returns (uint256 requestId)\r\n    {\r\n        requestId = requestRandomness(\r\n            callbackGasLimit,\r\n            requestConfirmations,\r\n            numWords\r\n        );\r\n        s_requests[requestId] = RequestStatus({\r\n            paid: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),\r\n            randomWords: new uint256[](0),\r\n            fulfilled: false\r\n        });\r\n        requestIds.push(requestId);\r\n        lastRequestId = requestId;\r\n        emit RequestSent(requestId, numWords);\r\n        return requestId;\r\n    }\r\n    function fulfillRandomWords( uint256 _requestId, uint256[] memory _randomWords ) internal override {\r\n        require(s_requests[_requestId].paid > 0, \"request not found\");\r\n        s_requests[_requestId].fulfilled = true;\r\n        s_requests[_requestId].randomWords = _randomWords;\r\n        lastRandomwords = _randomWords[0];\r\n        emit RequestFulfilled(\r\n            _requestId,\r\n            _randomWords,\r\n            s_requests[_requestId].paid\r\n        );\r\n    }\r\n    function getRequestStatus(uint256 _requestId) external view returns (uint256 paid, bool fulfilled, uint256[] memory randomWords)\r\n    {\r\n        require(s_requests[_requestId].paid > 0, \"request not found\");\r\n        RequestStatus memory request = s_requests[_requestId];\r\n        return (request.paid, request.fulfilled, request.randomWords);\r\n    }\r\n}\r\n\r\ncontract CoinFlip is VRFv2DirectFundingConsumer () {\r\n    event Result(address indexed winer, address indexed looser, uint256 type_game);\r\n        address internal _owner;        \r\n        address public g_t_address = 0xC51c05B7eA1147a9c846136a6F64358Db4D6548e; //gaming_token_address 000000000000000000\r\n        address public fee_address = 0x56CD37b5C7f5C1e713a151bA32ddCD2CF117c572;\r\n        address public burn_address = 0x000000000000000000000000000000000000dEaD;\r\n        uint256 public amount;\r\n        uint256 public fee;   \r\n        uint256 public burn_fee; \r\n\r\n        constructor( uint256 _amount,  uint256 _fee,  uint256 _burn_fee) {\r\n            amount = _amount;\r\n            fee = _fee;\r\n            burn_fee = _burn_fee;\r\n            _owner = msg.sender;\r\n        }\r\n        modifier onlyOwner() {\r\n            require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n            _;\r\n        }\r\n        struct Games{ address winner; address loser; uint256 outcome; }\r\n        mapping(uint256 => Games) public historygames; \r\n        uint256 public lastgame;\r\n       \r\n        struct Status{ uint256 status; uint256 outcome;}\r\n        mapping(address => Status) public status;\r\n\r\n        uint256 public queue_1_last;\r\n        uint256 public queue_1_first;\r\n        struct Queue_1 { address gamer; bool status; }\r\n        mapping(uint256 => Queue_1) public queue_1;\r\n\r\n        uint256 public queue_2_last;\r\n        uint256 public queue_2_first; \r\n        struct Queue_2 { address gamer; bool status;}\r\n        mapping(uint256 => Queue_2) public queue_2;\r\n\r\n        function sequence_1() external view returns(address[] memory) {\r\n            uint256 length = queue_1_last - queue_1_first;\r\n            address[] memory sequence_arr = new address[](length);\r\n            for(uint i = 0; i < length; i++){        \r\n                    sequence_arr[i] = queue_1[i + queue_1_first].gamer;               \r\n            }\r\n            return sequence_arr;\r\n        }        \r\n        function sequence_2() external view returns(address[] memory) {\r\n            uint256 length = queue_2_last - queue_2_first;\r\n            address[] memory sequence_arr = new address[](length);\r\n            for(uint i = 0; i < length; i++){\r\n                    sequence_arr[i] = queue_2[i + queue_2_first].gamer;               \r\n            }\r\n            return sequence_arr;\r\n        }\r\n        function game(uint outcome) public {\r\n            require(0 < outcome && outcome < 3, \": Outcome out range\");\r\n            require(IERC20(g_t_address).allowance(msg.sender, address(this)) >= amount, \": Game token consumption not allowed\");\r\n            require(IERC20(g_t_address).balanceOf(msg.sender) >= amount, \": Your game token balance is insufficient\");\r\n            require(status[msg.sender].status != 3 , \": You are already in the queue\");\r\n            address this_gamer = msg.sender;\r\n            status[this_gamer].outcome = outcome;\r\n            // deposit\r\n            transferFrom(this_gamer);\r\n            // outcome == #1\r\n            if (outcome == 1){\r\n                //game immediately?\r\n                if(queue_2[queue_2_first].status) {\r\n                    //get random number from CHAINLINK \r\n                    requestRandomWords();\r\n                    uint result = random() + 1;\r\n                    address second_gamer =  queue_2[queue_2_first].gamer;\r\n                    // msg.sender == winer?\r\n                    if (result == outcome) {                     \r\n                        transfer(this_gamer);                  \r\n                        status[this_gamer].status = 1; //win\r\n                        status[second_gamer].status = 2; //lose                      \r\n                        historygames[lastgame].winner = this_gamer;\r\n                        historygames[lastgame].loser = second_gamer;\r\n                        emit Result(this_gamer, second_gamer, 1);\r\n                    } else {\r\n                        transfer(second_gamer);\r\n                        status[this_gamer].status = 2; // lose\r\n                        status[second_gamer].status = 1; // win\r\n                      \r\n                        historygames[lastgame].winner = second_gamer;\r\n                        historygames[lastgame].loser = this_gamer;\r\n                        emit Result(second_gamer, this_gamer, 1);\r\n                    }                  \r\n                    queue_2[queue_2_first].status = false;                   \r\n                    queue_2_first++;\r\n                    historygames[lastgame].outcome = result;\r\n                    lastgame ++;\r\n                //queuing: \r\n                } else {\r\n                    queue_1[queue_1_last].status = true;\r\n                    queue_1[queue_1_last].gamer = this_gamer;\r\n                    queue_1_last++;\r\n                    status[this_gamer].status = 3; // waiting\r\n                }\r\n            // outcome == #2        \r\n            } else {                \r\n                 //game immediately?    \r\n                 if(queue_1[queue_1_first].status) {\r\n                    //get random number from CHAINLINK \r\n                     requestRandomWords();\r\n                    uint result = random() + 1; \r\n                    address second_gamer =  queue_1[queue_1_first].gamer;\r\n                    // msg.sender == winer?\r\n                    if (result == outcome) {\r\n                        transfer(this_gamer);\r\n                        status[this_gamer].status = 1; //win\r\n                        status[second_gamer].status = 2; //lose\r\n                        historygames[lastgame].winner = this_gamer;\r\n                        historygames[lastgame].loser = second_gamer;\r\n                         emit Result(this_gamer, second_gamer, 1);\r\n                    } else {\r\n                        transfer(second_gamer);\r\n                        status[this_gamer].status = 2; // lose\r\n                        status[second_gamer].status = 1; // win\r\n                        historygames[lastgame].winner = second_gamer;\r\n                        historygames[lastgame].loser = this_gamer;\r\n                        emit Result(second_gamer, this_gamer, 1);\r\n                    }\r\n                    queue_1[queue_1_first].status = false;\r\n                    queue_1_first++;\r\n                    historygames[lastgame].outcome = result;\r\n                    lastgame ++;\r\n                //queuing: \r\n                } else {\r\n                    queue_2[queue_2_last].status = true;\r\n                    queue_2[queue_2_last].gamer = this_gamer;\r\n                    queue_2_last++;\r\n                    status[this_gamer].status = 3; // waiting\r\n                }\r\n            }\r\n        }\r\n        function transfer(address _to) internal {\r\n             IERC20(g_t_address).transfer(_to, 2*amount - fee - burn_fee);\r\n             IERC20(g_t_address).transfer(fee_address, fee);\r\n             IERC20(g_t_address).transfer(burn_address, burn_fee);\r\n        }\r\n        function transferFrom(address _from) internal {\r\n             IERC20(g_t_address).transferFrom(_from, address(this), amount);\r\n        }\r\n        function random() public view virtual returns(uint){       \r\n            uint randomInt = lastRandomwords % 2;\r\n            return randomInt;\r\n        }\r\n        function set_amount(uint256 _amount) public onlyOwner {\r\n              amount = _amount;\r\n        }\r\n        function set_fee(uint256 _fee) public onlyOwner {\r\n              fee = _fee;\r\n        }\r\n        function set_burn_fee(uint256 _burn_fee) public onlyOwner {\r\n              burn_fee = _burn_fee;\r\n        }\r\n        function transfer_ownership(address  new_owner) public onlyOwner {\r\n              _owner = new_owner;\r\n        }        \r\n        function set_fee_address(address _fee_address) public onlyOwner {\r\n              fee_address = _fee_address;\r\n        }\r\n        function set_g_t_address(address _g_t_address) public onlyOwner {\r\n              g_t_address = _g_t_address;\r\n        }\r\n        function withdrawLink() public onlyOwner{\r\n            IERC20(linkAddress).transfer(msg.sender, IERC20(linkAddress).balanceOf(address(this)));\r\n        }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burn_fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"RequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"looser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"type_game\",\"type\":\"uint256\"}],\"name\":\"Result\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burn_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burn_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"g_t_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"}],\"name\":\"game\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"historygames\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRandomwords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastgame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queue_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gamer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queue_1_first\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queue_1_last\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queue_2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gamer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queue_2_first\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queue_2_last\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"s_requests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequence_1\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequence_2\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"set_amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_burn_fee\",\"type\":\"uint256\"}],\"name\":\"set_burn_fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"set_fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fee_address\",\"type\":\"address\"}],\"name\":\"set_fee_address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_g_t_address\",\"type\":\"address\"}],\"name\":\"set_g_t_address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"status\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"transfer_ownership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CoinFlip", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000d8d726b7177a800000000000000000000000000000000000000000000000000004563918244f40000000000000000000000000000000000000000000000000000ad78ebc5ac620000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b0a305a2699e678416b1bae2f7f569f300240e8241c571ba2c955f2ef0d3aef7"}