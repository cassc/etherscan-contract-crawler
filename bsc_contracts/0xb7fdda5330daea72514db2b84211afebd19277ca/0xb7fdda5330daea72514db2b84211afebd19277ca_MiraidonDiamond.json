{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /**\\n     * @notice Add/replace/remove any number of functions and optionally execute\\n     *         a function with delegatecall\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     *                  _calldata is executed with delegatecall on _init\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/GenericErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary GenericErrors {\\n    ///// TokenAddressIsZero();\\n    string internal constant E00 = \\\"E00\\\";\\n\\n    ///// TokenNotSupported();\\n    string internal constant E01 = \\\"E01\\\";\\n\\n    ///// CannotBridgeToSameNetwork();\\n    string internal constant E02 = \\\"E02\\\";\\n\\n    ///// ZeroPostSwapBalance();\\n    string internal constant E03 = \\\"E03\\\";\\n\\n    ///// NoSwapDataProvided();\\n    string internal constant E04 = \\\"E04\\\";\\n\\n    ///// NativeValueWithERC();\\n    string internal constant E05 = \\\"E05\\\";\\n\\n    ///// ContractCallNotAllowed();\\n    string internal constant E06 = \\\"E06\\\";\\n\\n    ///// NullAddrIsNotAValidSpender();\\n    string internal constant E07 = \\\"E07\\\";\\n\\n    ///// NullAddrIsNotAnERC20Token();\\n    string internal constant E08 = \\\"E08\\\";\\n\\n    ///// NoTransferToNullAddress();\\n    string internal constant E09 = \\\"E09\\\";\\n\\n    ///// NativeAssetTransferFailed();\\n    string internal constant E10 = \\\"E10\\\";\\n\\n    ///// InvalidBridgeConfigLength();\\n    string internal constant E11 = \\\"E11\\\";\\n\\n    ///// InvalidAmount();\\n    string internal constant E12 = \\\"E12\\\";\\n\\n    ///// InvalidContract();\\n    string internal constant E13 = \\\"E13\\\";\\n\\n    ///// InvalidConfig();\\n    string internal constant E14 = \\\"E14\\\";\\n\\n    ///// UnsupportedChainId(uint256 chainId);\\n    string internal constant E15 = \\\"E15\\\";\\n\\n    ///// InvalidReceiver();\\n    string internal constant E16 = \\\"E16\\\";\\n\\n    ///// InvalidDestinationChain();\\n    string internal constant E17 = \\\"E17\\\";\\n\\n    ///// InvalidSendingToken();\\n    string internal constant E18 = \\\"E18\\\";\\n\\n    ///// InvalidCaller();\\n    string internal constant E19 = \\\"E19\\\";\\n\\n    ///// AlreadyInitialized();\\n    string internal constant E20 = \\\"E20\\\";\\n\\n    ///// NotInitialized();\\n    string internal constant E21 = \\\"E21\\\";\\n\\n    ///// OnlyContractOwner();\\n    string internal constant E22 = \\\"E22\\\";\\n\\n    ///// CannotAuthoriseSelf();\\n    string internal constant E23 = \\\"E23\\\";\\n\\n    ///// RecoveryAddressCannotBeZero();\\n    string internal constant E24 = \\\"E24\\\";\\n\\n    ///// CannotDepositNativeToken();\\n    string internal constant E25 = \\\"E25\\\";\\n\\n    ///// InvalidCallData();\\n    string internal constant E26 = \\\"E26\\\";\\n\\n    ///// NativeAssetNotSupported();\\n    string internal constant E27 = \\\"E27\\\";\\n\\n    ///// UnAuthorized();\\n    string internal constant E28 = \\\"E28\\\";\\n\\n    ///// NoSwapFromZeroBalance();\\n    string internal constant E29 = \\\"E29\\\";\\n\\n    ///// InvalidFallbackAddress();\\n    string internal constant E30 = \\\"E30\\\";\\n\\n    ///// CumulativeSlippageTooHigh(uint256 minAmount, uint256 receivedAmount);\\n    string internal constant E31 = \\\"E31\\\";\\n\\n    ///// InsufficientBalance(uint256 required, uint256 balance);\\n    string internal constant E32 = \\\"E32\\\";\\n\\n    ///// ZeroAmount();\\n    string internal constant E33 = \\\"E33\\\";\\n\\n    ///// InvalidFee();\\n    string internal constant E34 = \\\"E34\\\";\\n\\n    ///// InformationMismatch();\\n    string internal constant E35 = \\\"E35\\\";\\n\\n    ///// NotAContract();\\n    string internal constant E36 = \\\"E36\\\";\\n\\n    ///// NotEnoughBalance(uint256 requested, uint256 available);\\n    string internal constant E37 = \\\"E37\\\";\\n\\n    ///// ReentrancyError();\\n    string internal constant E38 = \\\"E38\\\";\\n\\n    ///// NotImplementError();\\n    string internal constant E39 = \\\"E39\\\";\\n\\n    // Diamond specific errors\\n    //// error IncorrectFacetCutAction();\\n    string internal constant E40 = \\\"E40\\\";\\n\\n    //// error NoSelectorsInFace();\\n    string internal constant E41 = \\\"E41\\\";\\n\\n    //// error FunctionAlreadyExists();\\n    string internal constant E42 = \\\"E42\\\";\\n\\n    //// error FacetAddressIsZero();\\n    string internal constant E43 = \\\"E43\\\";\\n\\n    //// error FacetAddressIsNotZero();\\n    string internal constant E44 = \\\"E44\\\";\\n\\n    //// error FacetContainsNoCode();\\n    string internal constant E45 = \\\"E45\\\";\\n\\n    //// error FunctionDoesNotExist();\\n    string internal constant E46 = \\\"E46\\\";\\n\\n    //// error FunctionIsImmutable();\\n    string internal constant E47 = \\\"E47\\\";\\n\\n    //// error InitZeroButCalldataNotEmpty();\\n    string internal constant E48 = \\\"E48\\\";\\n\\n    //// error CalldataEmptyButInitNotZero();\\n    string internal constant E49 = \\\"E49\\\";\\n\\n    //// error InitReverted();\\n    string internal constant E50 = \\\"E50\\\";\\n    // ----------------\\n\\n    //// // LibBytes specific errors\\n    string internal constant E51 = \\\"E51\\\";\\n\\n    //// error SliceOverflow();\\n    string internal constant E52 = \\\"E52\\\";\\n\\n    //// error SliceOutOfBounds();\\n    string internal constant E53 = \\\"E53\\\";\\n\\n    //// error AddressOutOfBounds();\\n    string internal constant E54 = \\\"E54\\\";\\n\\n    //// error UintOutOfBounds();\\n    string internal constant E55 = \\\"E55\\\";\\n\\n    //// // -------------------------\\n\\n    //// error InvalidRouter();\\n    string internal constant E56 = \\\"E56\\\";\\n\\n    /// Stargate Errors ///\\n    //// error UnknownStargatePool();\\n    string internal constant E57 = \\\"E57\\\";\\n\\n    //// error UnknownLayerZeroChain();\\n    string internal constant E58 = \\\"E58\\\";\\n\\n    //// error InvalidStargateRouter();\\n    string internal constant E59 = \\\"E59\\\";\\n\\n    //// error ContractPaused();\\n    string internal constant E60 = \\\"E60\\\";\\n\\n    //// error CannotPauseSelf();\\n    string internal constant E61 = \\\"E61\\\";\\n\\n    /// error InvalidFeeNumerator()\\n    string internal constant E62 = \\\"E62\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {GenericErrors} from \\\"./GenericErrors.sol\\\";\\n\\nlibrary LibBytes {\\n    // solhint-disable no-inline-assembly\\n\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    ) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    ) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(\\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\\n                2\\n            )\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, GenericErrors.E52);\\n        require(_bytes.length >= _start + _length, GenericErrors.E53);\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(\\n                    add(tempBytes, lengthmod),\\n                    mul(0x20, iszero(lengthmod))\\n                )\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(\\n                        add(\\n                            add(_bytes, lengthmod),\\n                            mul(0x20, iszero(lengthmod))\\n                        ),\\n                        _start\\n                    )\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, GenericErrors.E54);\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(\\n                mload(add(add(_bytes, 0x20), _start)),\\n                0x1000000000000000000000000\\n            )\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1, GenericErrors.E55);\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, GenericErrors.E55);\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, GenericErrors.E55);\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, GenericErrors.E55);\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, GenericErrors.E55);\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, GenericErrors.E55);\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, GenericErrors.E55);\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, GenericErrors.E55);\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    ) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    ) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(\\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\\n                2\\n            )\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        // solhint-disable-next-line no-empty-blocks\\n                        for {\\n\\n                        } eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport {LibUtil} from \\\"./LibUtil.sol\\\";\\nimport {GenericErrors} from \\\"./GenericErrors.sol\\\";\\n\\n/// Implementation of EIP-2535 Diamond Standard\\n/// https://eips.ethereum.org/EIPS/eip-2535\\nlibrary LibDiamond {\\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    // Diamond specific errors\\n    error IncorrectFacetCutAction();\\n    error NoSelectorsInFace();\\n    error FunctionAlreadyExists();\\n    error FacetAddressIsZero();\\n    error FacetAddressIsNotZero();\\n    error FacetContainsNoCode();\\n    error FunctionDoesNotExist();\\n    error FunctionIsImmutable();\\n    error InitZeroButCalldataNotEmpty();\\n    error CalldataEmptyButInitNotZero();\\n    error InitReverted();\\n    // ----------------\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(\\n            msg.sender == diamondStorage().contractOwner,\\n            GenericErrors.E22\\n        );\\n        //if (msg.sender != diamondStorage().contractOwner)\\n        //revert OnlyContractOwner();\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            require(\\n                action == IDiamondCut.FacetCutAction.Add ||\\n                    action == IDiamondCut.FacetCutAction.Replace ||\\n                    action == IDiamondCut.FacetCutAction.Remove,\\n                GenericErrors.E40\\n            );\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(_functionSelectors.length != 0, GenericErrors.E41);\\n        DiamondStorage storage ds = diamondStorage();\\n        require(!LibUtil.isZeroAddress(_facetAddress), GenericErrors.E43);\\n        uint96 selectorPosition = uint96(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(LibUtil.isZeroAddress(oldFacetAddress), GenericErrors.E44);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            unchecked {\\n                ++selectorPosition;\\n                ++selectorIndex;\\n            }\\n        }\\n    }\\n\\n    function replaceFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(_functionSelectors.length != 0, GenericErrors.E41);\\n        DiamondStorage storage ds = diamondStorage();\\n        require(!LibUtil.isZeroAddress(_facetAddress), GenericErrors.E43);\\n        uint96 selectorPosition = uint96(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(oldFacetAddress != _facetAddress, GenericErrors.E42);\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            unchecked {\\n                ++selectorPosition;\\n                ++selectorIndex;\\n            }\\n        }\\n    }\\n\\n    function removeFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(_functionSelectors.length != 0, GenericErrors.E41);\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(!LibUtil.isZeroAddress(_facetAddress), GenericErrors.E43);\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldfacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            removeFunction(ds, oldfacetAddress, selector);\\n            unchecked {\\n                ++selectorIndex;\\n            }\\n        }\\n    }\\n\\n    function addFacet(\\n        DiamondStorage storage ds,\\n        address _facetAddress\\n    ) internal {\\n        enforceHasContractCode(_facetAddress);\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\\n            .facetAddresses\\n            .length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        DiamondStorage storage ds,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n            _selector\\n        );\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(\\n        DiamondStorage storage ds,\\n        address _facetAddress,\\n        bytes4 _selector\\n    ) internal {\\n        require(!LibUtil.isZeroAddress(_facetAddress), GenericErrors.E46);\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), GenericErrors.E47);\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds\\n            .facetFunctionSelectors[_facetAddress]\\n            .functionSelectors\\n            .length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n                selectorPosition\\n            ] = lastSelector;\\n            ds\\n                .selectorToFacetAndPosition[lastSelector]\\n                .functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[\\n                    lastFacetAddressPosition\\n                ];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds\\n                    .facetFunctionSelectors[lastFacetAddress]\\n                    .facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        if (LibUtil.isZeroAddress(_init)) {\\n            require(_calldata.length == 0, GenericErrors.E48);\\n        } else {\\n            require(_calldata.length != 0, GenericErrors.E49);\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init);\\n            }\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert InitReverted();\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract) internal view {\\n        uint256 contractSize;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize != 0, GenericErrors.E45);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./LibBytes.sol\\\";\\n\\nlibrary LibUtil {\\n    using LibBytes for bytes;\\n\\n    function getRevertMsg(\\n        bytes memory _res\\n    ) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_res.length < 68) return \\\"Transaction reverted silently\\\";\\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\\n        return abi.decode(revertData, (string)); // All that remains is the revert string\\n    }\\n\\n    /// @notice Determines whether the given address is the zero address\\n    /// @param addr The address to verify\\n    /// @return Boolean indicating if the address is the zero address\\n    function isZeroAddress(address addr) internal pure returns (bool) {\\n        return addr == address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MiraidonDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {LibDiamond} from \\\"./libraries/LibDiamond.sol\\\";\\nimport {IDiamondCut} from \\\"./interfaces/IDiamondCut.sol\\\";\\nimport {LibUtil} from \\\"./libraries/LibUtil.sol\\\";\\nimport {GenericErrors} from \\\"./libraries/GenericErrors.sol\\\";\\n\\ncontract MiraidonDiamond {\\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\\n        LibDiamond.setContractOwner(_contractOwner);\\n\\n        // Add the diamondCut external function from the diamondCutFacet\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({\\n            facetAddress: _diamondCutFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    /**\\n     * Find facet for function that is called and execute the\\n     * function if a facet is found and return any value.\\n     * solhint-disable-next-line no-complex-fallback\\n     */\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n\\n        // get diamond storage\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            ds.slot := position\\n        }\\n\\n        // get facet from function selector\\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n\\n        require(facet != address(0), GenericErrors.E46);\\n\\n        // Execute external function from facet using delegatecall and return any value.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Able to receive ether\\n     * solhint-disable-next-line no-empty-blocks\\n     */\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InitReverted\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MiraidonDiamond", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "000000000000000000000000c6972a28ddf68c75b93eea7b771464612ec8f9990000000000000000000000000c9f2c1619de44d41ce70a61f11ae2194a423f50", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x92f55036ab9fd169cd5155516443debb185e8c72", "SwarmSource": ""}