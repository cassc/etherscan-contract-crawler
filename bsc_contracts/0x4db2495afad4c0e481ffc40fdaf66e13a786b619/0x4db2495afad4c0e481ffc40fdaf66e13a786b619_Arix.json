{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.2;\r\n\r\nabstract contract Initializable {\r\n    bool private _initialized;\r\n    bool private _initializing;\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\ninterface IBeaconUpgradeable {\r\n    function implementation() external view returns (address);\r\n}\r\nlibrary AddressUpgradeable {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\nlibrary StorageSlotUpgradeable {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n}\r\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\r\n    function __ERC1967Upgrade_init() internal initializer {\r\n        __ERC1967Upgrade_init_unchained();\r\n    }\r\n    function __ERC1967Upgrade_init_unchained() internal initializer {}\r\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n    event Upgraded(address indexed implementation);\r\n    function _getImplementation() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n    function _setImplementation(address newImplementation) private {\r\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n    }\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n    function _upgradeToAndCall(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _upgradeTo(newImplementation);\r\n        if (data.length > 0 || forceCall) {\r\n            _functionDelegateCall(newImplementation, data);\r\n        }\r\n    }\r\n    function _upgradeToAndCallSecure(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        address oldImplementation = _getImplementation();\r\n        _setImplementation(newImplementation);\r\n        if (data.length > 0 || forceCall) {\r\n            _functionDelegateCall(newImplementation, data);\r\n        }\r\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\r\n        if (!rollbackTesting.value) {\r\n            rollbackTesting.value = true;\r\n            _functionDelegateCall(\r\n                newImplementation,\r\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\r\n            );\r\n            rollbackTesting.value = false;\r\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\r\n            _upgradeTo(newImplementation);\r\n        }\r\n    }\r\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n    function _getAdmin() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\r\n    }\r\n    function _setAdmin(address newAdmin) private {\r\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n    }\r\n    function _changeAdmin(address newAdmin) internal {\r\n        emit AdminChanged(_getAdmin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n    event BeaconUpgraded(address indexed beacon);\r\n    function _getBeacon() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\r\n    }\r\n    function _setBeacon(address newBeacon) private {\r\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\r\n        require(\r\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\r\n            \"ERC1967: beacon implementation is not a contract\"\r\n        );\r\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n    }\r\n    function _upgradeBeaconToAndCall(\r\n        address newBeacon,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _setBeacon(newBeacon);\r\n        emit BeaconUpgraded(newBeacon);\r\n        if (data.length > 0 || forceCall) {\r\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\r\n        }\r\n    }\r\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\r\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\r\n    function __UUPSUpgradeable_init() internal initializer {\r\n        __ERC1967Upgrade_init_unchained();\r\n        __UUPSUpgradeable_init_unchained();\r\n    }\r\n    function __UUPSUpgradeable_init_unchained() internal initializer {\r\n    }\r\n    function upgradeTo(address newImplementation) external virtual {\r\n        _authorizeUpgrade(newImplementation);\r\n        _upgradeToAndCallSecure(newImplementation, bytes(\"\"), false);\r\n    }\r\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {\r\n        _authorizeUpgrade(newImplementation);\r\n        _upgradeToAndCallSecure(newImplementation, data, true);\r\n    }\r\n    function _authorizeUpgrade(address newImplementation) internal virtual;\r\n    uint256[50] private __gap;\r\n}\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n    function __Context_init_unchained() internal initializer {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    function __Ownable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n    function __Ownable_init_unchained() internal initializer {\r\n        _setOwner(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\nlibrary SafeMathUpgradeable {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\ninterface IERC20Upgradeable {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n    using AddressUpgradeable for address;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => bool) private _taxExclusion;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    address private _liquidityAddress;\r\n    address private _taxRewardsAddress;\r\n    uint256 private _taxFee;\r\n    uint256 private _liqFee;\r\n    uint256 private _burnFee;\r\n    \r\n    function _setTaxFee(uint256 taxFee) internal virtual {\r\n        _taxFee = taxFee ;\r\n    }\r\n    function getTaxFee() internal view virtual returns (uint256) {\r\n        return _taxFee;\r\n    }\r\n    function _setLiqFee(uint256 liqFee) internal virtual {\r\n        _liqFee = liqFee ;\r\n    }\r\n    function getLiqFee() internal view virtual returns (uint256) {\r\n        return _liqFee;\r\n    }\r\n    function _setBurnFee(uint256 burnFee) internal virtual {\r\n        _burnFee = burnFee ;\r\n    }\r\n    function getBurnFee() internal view virtual returns (uint256) {\r\n        return _burnFee;\r\n    }\r\n    function _setLiquidityAddress(address liqAddress) internal virtual {\r\n        _liquidityAddress = liqAddress;   \r\n    }\r\n    function _setTaxRewardAddress(address taxAdress) internal virtual {\r\n        _taxRewardsAddress = taxAdress;   \r\n    }\r\n    function getLiquidityAddress() internal view virtual returns (address){\r\n        return _liquidityAddress;\r\n    }\r\n    function getTaxRewardAddress() internal view virtual returns (address){\r\n        return _taxRewardsAddress;\r\n    }\r\n    function _calcBurnAmount(uint256 amount) internal virtual returns (uint256){\r\n        return amount.mul(_burnFee).div(1000);\r\n    }\r\n    function _calcTaxAmount(uint256 amount) internal virtual returns (uint256){\r\n        return amount.mul(_taxFee).div(1000);\r\n    }\r\n    function _calcLiqAmount(uint256 amount) internal virtual returns (uint256){\r\n        return amount.mul(_liqFee).div(1000);\r\n    }\r\n    function _payInterest(address hodlerAddress,uint256 amount) internal virtual returns (bool){\r\n        _balances[_liquidityAddress]-=amount;\r\n        _balances[hodlerAddress]+=amount;\r\n        return true;\r\n    }\r\n    function _reductionExclusion(address hodlerAddress,bool excluded) internal virtual returns (bool) {\r\n        _taxExclusion[hodlerAddress] = excluded;\r\n        return true;\r\n    }\r\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\r\n        __Context_init_unchained();\r\n        __ERC20_init_unchained(name_, symbol_);\r\n    }\r\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"Arix: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"Arix: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"Arix: transfer from the zero address\");\r\n        require(recipient != address(0), \"Arix: transfer to the zero address\");\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"Arix: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        if(!_taxExclusion[sender]){\r\n            uint256 tax = _calcTaxAmount(amount);\r\n            uint256 liq = _calcLiqAmount(amount);\r\n            uint256 burn = _calcBurnAmount(amount);\r\n            amount = amount.sub(tax+liq+burn);\r\n            _balances[_liquidityAddress]+= liq;\r\n            _balances[_taxRewardsAddress]+= tax;\r\n            if(_totalSupply>= 500000 * 10 ** decimals()){\r\n                _totalSupply -= burn;\r\n            }\r\n        }\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"Arix: mint to the zero address\");\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"Arix: burn from the zero address\");\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"Arix: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"Arix: approve from the zero address\");\r\n        require(spender != address(0), \"Arix: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n    uint256[45] private __gap;\r\n}\r\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\r\n    function __ERC20Burnable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __ERC20Burnable_init_unchained();\r\n    }\r\n    function __ERC20Burnable_init_unchained() internal initializer {\r\n    }\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        uint256 currentAllowance = allowance(account, _msgSender());\r\n        require(currentAllowance >= amount, \"Arix: burn amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(account, _msgSender(), currentAllowance - amount);\r\n        }\r\n        _burn(account, amount);\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\ncontract Arix is Initializable, ERC20Upgradeable,ERC20BurnableUpgradeable, OwnableUpgradeable, UUPSUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n    using AddressUpgradeable for address;\r\n    struct Stake {\r\n        uint256 id;\r\n        uint256 amount;\r\n        uint256 stakeTime;\r\n        uint256 interestRate;\r\n        bool stateActive;\r\n    }\r\n    mapping (address => mapping (uint256 => Stake)) private STAKES;\r\n    mapping (address => uint256) private _numberOfStakes;\r\n    mapping (address => mapping (uint256 => mapping (uint256 => uint256))) private _interestPayTimes;\r\n    mapping (address => mapping (uint256 => mapping (uint256 => uint256))) private _interestPaidTimes;\r\n    address private _ownerAddress;\r\n    uint256 private _basicRate;\r\n    uint256 private _supermeRate;\r\n    uint256 private _performerRate;\r\n    uint256 private _turboRate;\r\n    uint256 private _minimumAmountForStaking;\r\n\r\n    function initialize() initializer public {\r\n        __ERC20_init(\"Arix\", \"ARIX\");\r\n        __ERC20Burnable_init();\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n        _ownerAddress = msg.sender;\r\n        _setLiquidityAddress(owner());\r\n        _setTaxRewardAddress(0x185A41064f1993Ba1F1c6F95C3A8cd6115Af7b2C);\r\n        _setBurnFee(10);\r\n        _setLiqFee(10);\r\n        _setTaxFee(10);\r\n        _basicRate = 11;\r\n        setBasicRate(11);\r\n        setSupermeRate(18);\r\n        setPerformerRate(25);\r\n        setTurboRate(30);\r\n        setMinimumAmountForStake(20);\r\n        _reductionExclusion(_ownerAddress,true);\r\n        _reductionExclusion(0xCecB8B0e65CCBF9e1497d599d9D73c675948dA32,true);\r\n        _mint(msg.sender, 2500000 * 10 ** decimals());\r\n    }\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        onlyOwner\r\n        override\r\n    {}\r\n    function renounceOwnership() public override(OwnableUpgradeable) onlyOwner {\r\n        //do nothing\r\n        transferOwnership(owner());\r\n    }\r\n    function setMinimumAmountForStake(uint256 minimumAmount) public virtual onlyOwner returns(bool){\r\n        require(minimumAmount > 0 && minimumAmount < 100 , \"ARIX : Minimum should be between 1 to 99\");\r\n        _minimumAmountForStaking = minimumAmount;\r\n        return true;\r\n    }\r\n    function minimumAmountForStake() public virtual view returns (uint256){\r\n        return _minimumAmountForStaking;\r\n    }    \r\n    function setBasicRate(uint256 rate) public virtual onlyOwner returns (bool){\r\n        _basicRate = rate;\r\n        return true;\r\n    }\r\n    function setSupermeRate(uint256 rate) public virtual onlyOwner returns (bool){\r\n        _supermeRate = rate;\r\n        return true;\r\n    }\r\n    function setPerformerRate(uint256 rate) public virtual onlyOwner returns (bool){\r\n        _performerRate = rate;\r\n        return true;\r\n    }\r\n    function setTurboRate(uint256 rate) public virtual onlyOwner returns (bool){\r\n        _turboRate = rate;\r\n        return true;\r\n    }\r\n    function BasicRate() public virtual view returns (uint256){\r\n        return _basicRate;\r\n    }\r\n    function SupermeRate() public virtual view returns (uint256){\r\n        return _supermeRate;\r\n    }\r\n    function PerformerRate() public virtual view returns (uint256){\r\n        return _performerRate;\r\n    }\r\n    function TurboRate() public virtual view returns (uint256){\r\n        return _turboRate;\r\n    }\r\n    function setTaxFee(uint256 taxFee) public virtual onlyOwner{\r\n        _setTaxFee(taxFee);\r\n    }\r\n    function TaxFee() public view virtual returns (uint256){\r\n        return getTaxFee();\r\n    }\r\n    function setLiqFee(uint256 liqFee) public virtual onlyOwner{\r\n        _setLiqFee(liqFee);\r\n    }\r\n    function LiquidityFee() public view virtual returns (uint256){\r\n        return getLiqFee();\r\n    }\r\n    function setBurnFee(uint256 burnFee) public virtual onlyOwner{\r\n        _setBurnFee(burnFee);\r\n    }\r\n    function BurnFee() public view virtual returns (uint256){\r\n        return getBurnFee();\r\n    }\r\n    function setLiquidityAddress(address liqAddress) public virtual onlyOwner{\r\n        _setLiquidityAddress(liqAddress);\r\n    }\r\n    function LiquidityAddress() public view virtual returns (address){\r\n        return getLiquidityAddress();\r\n    }\r\n    function setTaxRewardAddress(address taxAddress) public virtual onlyOwner{\r\n        _setTaxRewardAddress(taxAddress);\r\n    }\r\n    function TaxRewardAddress() public view virtual returns (address){\r\n        return getTaxRewardAddress();\r\n    }\r\n    function setReductionExclusion(address hodlerAddress,bool excluded) public virtual onlyOwner{\r\n        _reductionExclusion(hodlerAddress,excluded);\r\n    }\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        require(balanceOf(_msgSender()).sub(stakeOf(_msgSender())) >= amount,\"Arix : cant transfer more than Stake\");\r\n        return super.transfer(recipient,amount);\r\n    }\r\n    function stake(uint256 amount) public virtual returns(uint256) {\r\n        address sender = msg.sender;\r\n        require(amount>=(minimumAmountForStake().mul(10**decimals())),\"Arix : minimum amount for staking isn't Meet\");\r\n        require(balanceOf(sender)!=0,\"Arix : stake address balance not enough for staking\");\r\n        require(balanceOf(sender).sub(stakeOf(sender)) >= amount,\"Arix : cant transfer more than Stake\");\r\n        uint256 stakeTime=block.timestamp;\r\n        uint256 nos = _numberOfStakes[sender];\r\n        uint256 stakeId = nos++;\r\n        calculatePayTimes(sender,stakeTime,stakeId);\r\n        uint256 rate = calculateInterestRate(amount);\r\n        Stake memory newStake = Stake(stakeId ,amount,stakeTime,rate,true);\r\n        _setStake(sender,newStake);\r\n        return newStake.amount;\r\n    }\r\n    function stakeFromTime(address stakeAddress,uint256 amount,uint256 time) public virtual onlyOwner returns(uint256) {\r\n        address sender = stakeAddress;\r\n        require(amount>=(minimumAmountForStake().mul(10**decimals())),\"Arix: minimum amount for staking isn't Meet\");\r\n        require(balanceOf(sender)!=0,\"Arix: stake address balance not enough for staking\");\r\n        require(balanceOf(sender).sub(stakeOf(sender)) >= amount,\"Arix: cant transfer more than Stake\");\r\n        uint256 nos = _numberOfStakes[sender];\r\n        uint256 stakeId = nos++;\r\n        calculateAllTimes(sender,time,stakeId);\r\n        uint256 rate = calculateInterestRate(amount);\r\n        Stake memory newStake = Stake(stakeId,amount,time,rate,true);\r\n        _setStake(sender,newStake);\r\n        return newStake.amount;\r\n    }\r\n    function calculateInterestRate(uint256 stakeAmount) internal virtual returns(uint256){\r\n        uint256 rate ;\r\n        if(stakeAmount>=(minimumAmountForStake().mul(10**decimals())) && stakeAmount<=(100*10**decimals())){\r\n            rate = BasicRate();\r\n        }else if(stakeAmount>(100*10**decimals()) && stakeAmount<=(200*10**decimals())){\r\n            rate = SupermeRate();\r\n        }else if(stakeAmount>(200*10**decimals()) && stakeAmount<=(500*10**decimals())){\r\n            rate = PerformerRate();\r\n        }else if(stakeAmount>(500*10**decimals())){\r\n            rate = TurboRate();\r\n        }\r\n        return rate;\r\n    }\r\n    function calculateAllTimes(address stakeAddress,uint256 time,uint256 stakeId) internal virtual {\r\n        uint256 yearseconds = 12 * ((4 weeks)+(1 days));\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 timePassed = currentTime.sub(time);\r\n        uint256 timeRemained = yearseconds.sub(timePassed);\r\n        uint256 remainigMonth = timeRemained.div((4 weeks)+(1 days))+1;\r\n        uint256 passedMonth = timePassed.div((4 weeks)+(1 days));\r\n        for(uint256 i = 1 ; i <= passedMonth ; i++){\r\n            _interestPaidTimes[stakeAddress][stakeId][i] = time.add(i.mul((4 weeks)+(1 days)));\r\n        }\r\n        for(uint256 i = 1 ; i <= remainigMonth ; i++){\r\n            _interestPayTimes[stakeAddress][stakeId][i] = currentTime.add(i.mul((4 weeks)+(1 days)));\r\n        }\r\n    }\r\n    function calculatePayTimes(address stakeAddress,uint256 stakeTime,uint256 stakeId) internal virtual{\r\n        for(uint256 i=1;i<13;i++){\r\n            _interestPayTimes[stakeAddress][stakeId][i] = stakeTime.add(i.mul((4 weeks)+(1 days)));\r\n        }\r\n    }\r\n    function stakeOf(address account) public view virtual returns (uint256) {\r\n        uint256 nos = _numberOfStakes[account];\r\n        uint256 sum = 0;\r\n        for(uint256 i = 1; i<=nos ; i++){\r\n            sum +=STAKES[account][i].amount;\r\n        }\r\n        return sum;\r\n    }\r\n    function _setStake(address stakeAddress,Stake memory stake1) internal virtual returns(bool){\r\n        _numberOfStakes[stakeAddress]++;\r\n        STAKES[stakeAddress][_numberOfStakes[stakeAddress]] = stake1;\r\n        return true;\r\n    }\r\n    function InterestPay(address stakeAddress) public virtual onlyOwner returns (bool){\r\n        require(balanceOf(stakeAddress)!=0,\"Arix: address balance not enough for InterestPayment\");\r\n        require(stakeOf(stakeAddress)!=0,\"Arix: address stake balance not enough for InterestPayment\");\r\n        uint256 nos = _numberOfStakes[stakeAddress];\r\n        for(uint256 i = 1 ; i <= nos ; i++){\r\n            uint256 rate = STAKES[stakeAddress][i].interestRate;\r\n            uint256 stakeAmount = STAKES[stakeAddress][i].amount;\r\n            uint256 interestAmount = stakeAmount.mul(rate).div(10**3);\r\n            uint256 currentTime = block.timestamp;\r\n            for(uint256 j = 1 ; j < 13 ; j++ ){\r\n                if(currentTime >= _interestPayTimes[stakeAddress][STAKES[stakeAddress][i].id][j] \r\n                    && _interestPaidTimes[stakeAddress][STAKES[stakeAddress][i].id][j] == 0){\r\n                    _payInterest(stakeAddress,interestAmount);\r\n                    _interestPaidTimes[stakeAddress][STAKES[stakeAddress][i].id][j] = block.timestamp;\r\n                    if(j==12){\r\n                        STAKES[stakeAddress][i].stateActive = false;\r\n                        STAKES[stakeAddress][i].amount = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n        \r\n    }\r\n    \r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BasicRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeAddress\",\"type\":\"address\"}],\"name\":\"InterestPay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PerformerRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SupermeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TaxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TaxRewardAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TurboRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAmountForStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setBasicRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"burnFee\",\"type\":\"uint256\"}],\"name\":\"setBurnFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liqFee\",\"type\":\"uint256\"}],\"name\":\"setLiqFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liqAddress\",\"type\":\"address\"}],\"name\":\"setLiquidityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumAmount\",\"type\":\"uint256\"}],\"name\":\"setMinimumAmountForStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setPerformerRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hodlerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setReductionExclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setSupermeRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taxFee\",\"type\":\"uint256\"}],\"name\":\"setTaxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"taxAddress\",\"type\":\"address\"}],\"name\":\"setTaxRewardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setTurboRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"stakeFromTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"stakeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Arix", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6c7dffe8c14ce0ee80b08d2bae00f7296754f4762d5e82f7eebe2be046674656"}