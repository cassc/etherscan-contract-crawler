{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/zero-ex/src/features/interfaces/IBatchSignedERC721OrdersFeature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Copyright 2022 Element.Market Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\n\\npragma solidity ^0.8.17;\\n\\n\\ninterface IBatchSignedERC721OrdersFeature {\\n\\n    /// @param fee [16 bits(platformFeePercentage) + 16 bits(royaltyFeePercentage) + 160 bits(royaltyFeeRecipient)].\\n    /// @param items [96 bits(erc20TokenAmount) + 160 bits(nftId)].\\n    /// struct BasicCollection {\\n    ///     address nftAddress;\\n    ///     bytes32 fee;\\n    ///     bytes32[] items;\\n    /// }\\n    ///\\n    /// struct OrderItem {\\n    ///     uint256 erc20TokenAmount;\\n    ///     uint256 nftId;\\n    /// }\\n    ///\\n    /// @param fee [16 bits(platformFeePercentage) + 16 bits(royaltyFeePercentage) + 160 bits(royaltyFeeRecipient)].\\n    /// struct Collection {\\n    ///     address nftAddress;\\n    ///     bytes32 fee;\\n    ///     OrderItem[] items;\\n    /// }\\n    ///\\n    /// struct BatchSignedERC721Orders {\\n    ///     address maker;\\n    ///     uint256 listingTime;\\n    ///     uint256 expiryTime;\\n    ///     uint256 startNonce;\\n    ///     address erc20Token;\\n    ///     address platformFeeRecipient;\\n    ///     BasicCollection[] basicCollections;\\n    ///     Collection[] collections;\\n    ///     uint256 hashNonce;\\n    /// }\\n\\n    /// @param data1 [8 bits(signatureType) + 8 bits(reserved) + 40 bits(startNonce) + 8 bits(v) + 32 bits(listingTime) + 160 bits(maker)]\\n    /// @param data2 [64 bits(taker part1) + 32 bits(expiryTime) + 160 bits(erc20Token)]\\n    /// @param data3 [96 bits(taker part2) + 160 bits(platformFeeRecipient)]\\n    struct BatchSignedERC721OrderParameter {\\n        uint256 data1;\\n        uint256 data2;\\n        uint256 data3;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    function fillBatchSignedERC721Order(BatchSignedERC721OrderParameter calldata parameter, bytes calldata collections) external payable;\\n\\n    /// @param data1 [8 bits(signatureType) + 8 bits(reserved) + 40 bits(startNonce) + 8 bits(v) + 32 bits(listingTime) + 160 bits(maker)]\\n    /// @param data2 [64 bits(taker part1) + 32 bits(expiryTime) + 160 bits(erc20Token)]\\n    /// @param data3 [96 bits(taker part2) + 160 bits(platformFeeRecipient)]\\n    struct BatchSignedERC721OrderParameters {\\n        uint256 data1;\\n        uint256 data2;\\n        uint256 data3;\\n        bytes32 r;\\n        bytes32 s;\\n        bytes collections;\\n    }\\n\\n    /// @param additional1 [96 bits(withdrawETHAmount) + 160 bits(erc20Token)]\\n    /// @param additional2 [8 bits(revertIfIncomplete) + 88 bits(unused) + 160 bits(royaltyFeeRecipient)]\\n    function fillBatchSignedERC721Orders(\\n        BatchSignedERC721OrderParameters[] calldata parameters,\\n        uint256 additional1,\\n        uint256 additional2\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/zero-ex/src/features/nft_orders/BatchSignedERC721OrdersFeature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Copyright 2022 Element.Market Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"../../storage/LibCommonNftOrdersStorage.sol\\\";\\nimport \\\"../../storage/LibERC721OrdersStorage.sol\\\";\\nimport \\\"../interfaces/IBatchSignedERC721OrdersFeature.sol\\\";\\n\\n\\ncontract BatchSignedERC721OrdersFeature is IBatchSignedERC721OrdersFeature {\\n\\n    uint256 internal constant MASK_192 = (1 << 192) - 1;\\n    uint256 internal constant MASK_160 = (1 << 160) - 1;\\n    uint256 internal constant MASK_64 = (1 << 64) - 1;\\n    uint256 internal constant MASK_40 = (1 << 40) - 1;\\n    uint256 internal constant MASK_32 = (1 << 32) - 1;\\n    uint256 internal constant MASK_16 = (1 << 16) - 1;\\n\\n    uint256 internal constant MASK_INDEX_LIST_PART1 = ((1 << 96) - 1) << 160;\\n    uint256 internal constant MASK_INDEX_LIST_PART2 = ((1 << 32) - 1) << 128;\\n\\n    uint256 internal constant NONCE_RANGE_LIMIT = 1 << 248;\\n    uint256 internal constant MAX_ERC20_AMOUNT = (1 << 224) - 1;\\n\\n    // Storage ID.\\n    uint256 constant STORAGE_ID_COMMON_NFT_ORDERS = 4 << 128;\\n    uint256 constant STORAGE_ID_ERC721_ORDERS = 5 << 128;\\n\\n    // Topic for ERC721SellOrderFilled.\\n    bytes32 internal constant _TOPIC_SELL_ORDER_FILLED = 0x9c248aa1a265aa616f707b979d57f4529bb63a4fc34dc7fc61fdddc18410f74e;\\n\\n    // keccak256(\\\"\\\")\\n    bytes32 internal constant _EMPTY_ARRAY_KECCAK256 = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n    // keccak256(abi.encodePacked(\\n    //    \\\"BatchSignedERC721Orders(address maker,uint256 listingTime,uint256 expiryTime,uint256 startNonce,address erc20Token,address platformFeeRecipient,BasicCollection[] basicCollections,Collection[] collections,uint256 hashNonce)\\\",\\n    //    \\\"BasicCollection(address nftAddress,bytes32 fee,bytes32[] items)\\\",\\n    //    \\\"Collection(address nftAddress,bytes32 fee,OrderItem[] items)\\\",\\n    //    \\\"OrderItem(uint256 erc20TokenAmount,uint256 nftId)\\\"\\n    // ))\\n    bytes32 internal constant _BATCH_SIGNED_ERC721_ORDERS_TYPE_HASH = 0x2d8cbbbc696e7292c3b5beb38e1363d34ff11beb8c3456c14cb938854597b9ed;\\n    // keccak256(\\\"BasicCollection(address nftAddress,bytes32 fee,bytes32[] items)\\\")\\n    bytes32 internal constant _BASIC_COLLECTION_TYPE_HASH = 0x12ad29288fd70022f26997a9958d9eceb6e840ceaa79b72ea5945ba87e4d33b0;\\n    // keccak256(abi.encodePacked(\\n    //    \\\"Collection(address nftAddress,bytes32 fee,OrderItem[] items)\\\",\\n    //    \\\"OrderItem(uint256 erc20TokenAmount,uint256 nftId)\\\"\\n    // ))\\n    bytes32 internal constant _COLLECTION_TYPE_HASH = 0xb9f488d48cec782be9ecdb74330c9c6a33c236a8022d8a91a4e4df4e81b51620;\\n    // keccak256(\\\"OrderItem(uint256 erc20TokenAmount,uint256 nftId)\\\")\\n    bytes32 internal constant _ORDER_ITEM_TYPE_HASH = 0x5f93394997caa49a9382d44a75e3ce6a460f32b39870464866ac994f8be97afe;\\n\\n    // keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 internal constant DOMAIN = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    // keccak256(\\\"ElementEx\\\")\\n    bytes32 internal constant NAME = 0x27b14c20196091d9cd90ca9c473d3ad1523b00ddf487a9b7452a8a119a16b98c;\\n    // keccak256(\\\"1.0.0\\\")\\n    bytes32 internal constant VERSION = 0x06c015bd22b4c69690933c1058878ebdfef31f9aaae40bbe86d8a09fe1b2972c;\\n\\n    /// @dev The implementation address of this feature.\\n    address internal immutable _IMPL;\\n    /// @dev The WETH token contract.\\n    address internal immutable _WETH;\\n\\n    constructor(address weth) {\\n        require(address(weth) != address(0), \\\"INVALID_WETH_ADDRESS\\\");\\n        _WETH = weth;\\n        _IMPL = address(this);\\n    }\\n\\n    function fillBatchSignedERC721Order(BatchSignedERC721OrderParameter calldata /* parameter */, bytes calldata collections) external override payable {\\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\\n        uint256 offsetCollectionsBytes;\\n        assembly {\\n            offsetCollectionsBytes := collections.offset\\n        }\\n\\n        // Validate order.\\n        bytes32 orderHash = _validateOrder(offsetCollectionsBytes);\\n\\n        assembly {\\n            // memory[0x0 - 0x20] orderHash\\n            mstore(0, orderHash)\\n\\n            /////////////////////////// memory[0x380 - 0x420] for delegateCall  ///////////\\n            // memory[0x380 - 0x3a0] erc20TokenFromDelegateCall\\n            // memory[0x3a0 - 0x3c0] platformFeeRecipientFromDelegateCall\\n            // memory[0x3c0 - 0x3e0] royaltyFeeRecipientFromDelegateCall\\n            mstore(0x380, 0)\\n            mstore(0x3a0, 0)\\n            mstore(0x3c0, 0)\\n        }\\n\\n        // Fill order.\\n        _fillBatchSignedERC721Order(offsetCollectionsBytes);\\n\\n        // Refund ETH.\\n        assembly {\\n            if eq(selfbalance(), ethBalanceBefore) {\\n                return(0, 0)\\n            }\\n            if gt(selfbalance(), ethBalanceBefore) {\\n                if iszero(call(gas(), caller(), sub(selfbalance(), ethBalanceBefore), 0, 0, 0, 0)) {\\n                    _revertRefundETHFailed()\\n                }\\n                return(0, 0)\\n            }\\n            _revertRefundETHFailed()\\n\\n            function _revertRefundETHFailed() {\\n                // revert(\\\"fillBatchSignedERC721Order: failed to refund ETH.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003166696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x6661696c656420746f20726566756e64204554482e0000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n        }\\n    }\\n\\n    /// @param additional1 [96 bits(withdrawETHAmount) + 160 bits(erc20Token)]\\n    /// @param additional2 [8 bits(revertIfIncomplete) + 88 bits(unused) + 160 bits(royaltyFeeRecipient)]\\n    function fillBatchSignedERC721Orders(\\n        BatchSignedERC721OrderParameters[] calldata parameters,\\n        uint256 additional1,\\n        uint256 additional2\\n    ) external override payable {\\n        require(parameters.length > 0, \\\"fillBatchSignedERC721Orders: invalid parameters.\\\");\\n\\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\\n        uint256 platformFeeRecipient = parameters[0].data3 & MASK_160;\\n        address impl = _IMPL;\\n        address weth = _WETH;\\n\\n        assembly {\\n            let withdrawETHAmount := shr(160, additional1)\\n            let erc20Token := and(additional1, MASK_160)\\n            let royaltyFeeRecipient := and(additional2, MASK_160)\\n            let platformFeeGlobalAccum\\n            let royaltyFeeGlobalAccum\\n            let someSuccess\\n\\n            // Withdraw ETH if needed.\\n            if withdrawETHAmount {\\n                // Step1: transfer WETH from msg.sender to address(this).\\n                _transferERC20(weth, address(), withdrawETHAmount)\\n\\n                // Step2: withdraw ETH.\\n                // selector for `withdraw(uint256)`.\\n                mstore(0, 0x2e1a7d4d)\\n                mstore(0x20, withdrawETHAmount)\\n                if iszero(call(gas(), weth, 0, 0x1c, 0x24, 0, 0)) {\\n                    _revertWithdrawETHFailed()\\n                }\\n            }\\n\\n            /////////////////////////// memory[0 - 0x40] for delegatecall output  /////////////\\n            // memory[0 - 0x20] output [platformFeeGlobal]\\n            // memory[0x20 - 0x40] output [royaltyFeeGlobal]\\n\\n            /////////////////////////// memory[0x40 - ] for delegatecall input /////////////\\n            // memory[0x40 - 0x60] selector for `delegateCallFillBatchSignedERC721Order(BatchSignedERC721OrderParameter,address,address,address,bytes)`\\n            mstore(0x40, 0xdc055ecc)\\n            // memory[0x60 - 0x100] parameter\\n            // memory[0x100 - 0x120] erc20Token\\n            mstore(0x100, erc20Token)\\n            // memory[0x120 - 0x140] platformFeeRecipient\\n            mstore(0x120, platformFeeRecipient)\\n            // memory[0x140 - 0x160] royaltyFeeRecipient\\n            mstore(0x140, royaltyFeeRecipient)\\n            // memory[0x160 - 0x180] collections.offset\\n            mstore(0x160, 0x120)\\n            // memory[0x180 - 0x1a0] collections.length\\n            // memory[0x1a0 - ] collections.data\\n\\n            let ptrEnd := add(parameters.offset, mul(parameters.length, 0x20))\\n            for { let ptr := parameters.offset } lt(ptr, ptrEnd) { ptr := add(ptr, 0x20) } {\\n                let ptrData := add(parameters.offset, calldataload(ptr))\\n\\n                // memory[0x40 - 0x60] selector for `delegateCallFillBatchSignedERC721Order`\\n                // memory[0x60 - 0x100] parameter\\n                calldatacopy(0x60, ptrData, 0xa0 /* 5 * 32*/)\\n                // memory[0x100 - 0x120] erc20Token\\n                // memory[0x120 - 0x140] platformFeeRecipient\\n                // memory[0x140 - 0x160] royaltyFeeRecipient\\n                // memory[0x160 - 0x180] collections.offset\\n                // memory[0x180 - 0x1a0] collections.length\\n                let collectionsLength := calldataload(add(ptrData, 0xc0))\\n                if mod(collectionsLength, 0x20) {\\n                    _revertInvalidCollectionsBytes()\\n                }\\n                mstore(0x180, collectionsLength)\\n\\n                // memory[0x1a0 - ] collections.data\\n                calldatacopy(0x1a0, add(ptrData, 0xe0), collectionsLength)\\n\\n                // 0x144 = 0x4(selector) + 0xa0(parameter) + 0x20(erc20Token) + 0x20(platformFeeRecipient) + 0x20(royaltyFeeRecipient) + 0x20(collections.offset) + 0x20(collections.length)\\n                switch delegatecall(gas(), impl, 0x5c, add(0x144, collectionsLength), 0, 0x40)\\n                case 0 {\\n                    // Check revertIfIncomplete flag if failed.\\n                    if byte(0, additional2) {\\n                        returndatacopy(0, 0, returndatasize())\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n                default {\\n                    // Success.\\n                    someSuccess := 1\\n\\n                    // memory[0 - 0x20] output [platformFeeGlobal]\\n                    // memory[0x20 - 0x40] output [royaltyFeeGlobal]\\n                    platformFeeGlobalAccum := add(platformFeeGlobalAccum, mload(0))\\n                    royaltyFeeGlobalAccum := add(royaltyFeeGlobalAccum, mload(0x20))\\n                }\\n            } // end for\\n\\n            if platformFeeGlobalAccum {\\n                _transferERC20(erc20Token, platformFeeRecipient, platformFeeGlobalAccum)\\n            }\\n\\n            if royaltyFeeGlobalAccum {\\n                _transferERC20(erc20Token, royaltyFeeRecipient, royaltyFeeGlobalAccum)\\n            }\\n\\n            if iszero(someSuccess) {\\n                _revertNoOrderFilled()\\n            }\\n\\n            // Refund ETH.\\n            if eq(selfbalance(), ethBalanceBefore) {\\n                return(0, 0)\\n            }\\n            if gt(selfbalance(), ethBalanceBefore) {\\n                if iszero(call(gas(), caller(), sub(selfbalance(), ethBalanceBefore), 0, 0, 0, 0)) {\\n                    _revertRefundETHFailed()\\n                }\\n                return(0, 0)\\n            }\\n            _revertRefundETHFailed()\\n\\n            ///////////////////////////////// functions  /////////////////////////////////\\n            function _transferERC20(_erc20Token, _to, _amount) {\\n                switch _erc20Token\\n                case 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE {\\n                    if iszero(call(gas(), _to, _amount, 0, 0, 0, 0)) {\\n                        _revertTransferETHFailed()\\n                    }\\n                }\\n\\n                default {\\n                    if iszero(extcodesize(_erc20Token)) {\\n                        _revertInvalidERC20Token()\\n                    }\\n\\n                    // selector for `transferFrom(address,address,uint256)`\\n                    mstore(0, 0x23b872dd)\\n                    mstore(0x20, caller())\\n                    mstore(0x40, _to)\\n                    mstore(0x60, _amount)\\n\\n                    if iszero(call(gas(), _erc20Token, 0, 0x1c, 0x64, 0, 0x20)) {\\n                        _revertTransferERC20Failed()\\n                    }\\n\\n                    // Check for ERC20 success. ERC20 tokens should return a boolean, but some don't.\\n                    // We accept 0-length return data as success, or at least 32 bytes that starts with\\n                    // a 32-byte boolean true.\\n                    if returndatasize() {\\n                        if lt(returndatasize(), 0x20) {\\n                            _revertTransferERC20Failed()\\n                        }\\n                        if iszero(eq(mload(0), 1)) {\\n                            _revertTransferERC20Failed()\\n                        }\\n                    }\\n                }\\n            }\\n\\n            function _revertTransferETHFailed() {\\n                // revert(\\\"fillBatchSignedERC721Orders: failed to transfer ETH.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003466696c6c42617463685369676e65644552433732314f72646572733a)\\n                mstore(0x60, 0x206661696c656420746f207472616e73666572204554482e0000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertTransferERC20Failed() {\\n                // revert(\\\"fillBatchSignedERC721Orders: failed to transfer ERC20.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003666696c6c42617463685369676e65644552433732314f72646572733a)\\n                mstore(0x60, 0x206661696c656420746f207472616e736665722045524332302e000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertWithdrawETHFailed() {\\n                // revert(\\\"fillBatchSignedERC721Orders: failed to withdraw ETH.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003466696c6c42617463685369676e65644552433732314f72646572733a)\\n                mstore(0x60, 0x206661696c656420746f207769746864726177204554482e0000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertInvalidCollectionsBytes() {\\n                // revert(\\\"fillBatchSignedERC721Orders: invalid collectionsBytes.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003666696c6c42617463685369676e65644552433732314f72646572733a)\\n                mstore(0x60, 0x20696e76616c696420636f6c6c656374696f6e7342797465732e000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertNoOrderFilled() {\\n                // revert(\\\"fillBatchSignedERC721Orders: no order filled.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002d66696c6c42617463685369676e65644552433732314f72646572733a)\\n                mstore(0x60, 0x206e6f206f726465722066696c6c65642e000000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertRefundETHFailed() {\\n                // revert(\\\"fillBatchSignedERC721Orders: failed to refund ETH.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003266696c6c42617463685369676e65644552433732314f72646572733a)\\n                mstore(0x60, 0x206661696c656420746f20726566756e64204554482e00000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertInvalidERC20Token() {\\n                // revert(\\\"invalid erc20 token\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x00000013696e76616c696420657263323020746f6b656e000000000000000000)\\n                mstore(0x60, 0)\\n                revert(0, 0x64)\\n            }\\n        }\\n    }\\n\\n    // @Note `delegateCallFillBatchSignedERC721Order` is a external function, but must delegatecall from an external exchange,\\n    //        and should not be registered in the external exchange.\\n    function delegateCallFillBatchSignedERC721Order(\\n        BatchSignedERC721OrderParameter calldata /* parameter */,\\n        address erc20TokenFromDelegateCall,\\n        address platformFeeRecipientFromDelegateCall,\\n        address royaltyFeeRecipientFromDelegateCall,\\n        bytes calldata collections\\n    ) external payable {\\n        address impl = _IMPL;\\n        uint256 offsetCollectionsBytes;\\n        assembly {\\n            if eq(impl, address()) {\\n                // revert(\\\"delegateCallFillBatchSignedERC721Order: must delegateCall from an external exchange.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000005464656c656761746543616c6c46696c6c42617463685369676e656445)\\n                mstore(0x60, 0x52433732314f726465723a206d7573742064656c656761746543616c6c206672)\\n                mstore(0x80, 0x6f6d20616e2065787465726e616c2065786368616e67652e0000000000000000)\\n                mstore(0xa0, 0)\\n                revert(0, 0xa4)\\n            }\\n\\n            offsetCollectionsBytes := collections.offset\\n        }\\n\\n        // Validate order.\\n        bytes32 orderHash = _validateOrder(offsetCollectionsBytes);\\n\\n        assembly {\\n            // memory[0x0 - 0x20] orderHash\\n            mstore(0, orderHash)\\n\\n            /////////////////////////// memory[0x380 - 0x420] for delegateCall  ///////////\\n            // memory[0x380 - 0x3a0] erc20TokenFromDelegateCall\\n            // memory[0x3a0 - 0x3c0] platformFeeRecipientFromDelegateCall\\n            // memory[0x3c0 - 0x3e0] royaltyFeeRecipientFromDelegateCall\\n            mstore(0x380, erc20TokenFromDelegateCall)\\n            mstore(0x3a0, platformFeeRecipientFromDelegateCall)\\n            mstore(0x3c0, royaltyFeeRecipientFromDelegateCall)\\n        }\\n\\n        // Fill order.\\n        _fillBatchSignedERC721Order(offsetCollectionsBytes);\\n\\n        assembly {\\n            // Return platformFeeGlobal and royaltyFeeGlobal.\\n            // memory[0x3e0 - 0x400] platformFeeGlobal\\n            // memory[0x400 - 0x420] royaltyFeeGlobal\\n            return(0x3e0, 0x40)\\n        }\\n    }\\n\\n    /// data1 [[8 bits(signatureType) + 8 bits(reserved) + 40 bits(startNonce) + 8 bits(v) + 32 bits(listingTime) + 160 bits(maker)]\\n    /// data2 [64 bits(taker part1) + 32 bits(expiryTime) + 160 bits(erc20Token)]\\n    /// data3 [96 bits(taker part2) + 160 bits(platformFeeRecipient)]\\n    function _fillBatchSignedERC721Order(uint256 offsetCollectionsBytes) internal {\\n        assembly {\\n            /////////////////////////// memory[0x0 - 0x1c0] for emitEvent data ////////////////////////\\n            // memory[0x0 - 0x20] orderHash\\n            // memory[0x20 - 0x40] maker\\n            mstore(0x20, and(calldataload(0x4), MASK_160)) // maker = data1 & MASK_160\\n            // memory[0x40 - 0x60] taker\\n            mstore(0x40, or(shl(96, shr(192, calldataload(0x24))), shr(160, calldataload(0x44)))) // taker = ((data2 >> 192) << 96) | (data3 >> 160)\\n            if iszero(mload(0x40)) {\\n                mstore(0x40, caller())\\n            }\\n\\n            // memory[0x60 - 0x80] nonce\\n            // memory[0x80 - 0xa0] erc20Token\\n            mstore(0x80, and(calldataload(0x24), MASK_160)) // erc20Token = data2 & MASK_160\\n            // memory[0xa0 - 0xc0] erc20TokenAmount\\n            // memory[0xc0 - 0xe0] fees.offset\\n            mstore(0xc0, 0x120 /* 9 * 32 */)\\n            // memory[0xe0 - 0x100] nftAddress\\n            // memory[0x100 - 0x120] nftId\\n            // memory[0x120 - 0x140] fees.length\\n            // memory[0x140 - 0x1c0] fees.data\\n\\n            /////////////////////////// memory[0x1c0 - 0x240] for transferERC721 //////////\\n            // memory[0x1c0 - 0x1e0] selector for `transferFrom(address,address,uint256)`\\n            mstore(0x1c0, 0x23b872dd)\\n            // memory[0x1e0 - 0x200] maker\\n            mstore(0x1e0, mload(0x20))\\n            // memory[0x200 - 0x220] taker\\n            mstore(0x200, mload(0x40))\\n            // memory[0x220 - 0x240] nftId\\n\\n            /////////////////////////// memory[0x240 - 0x300] for nonceVector /////////////\\n            // Note: nonceRange = nonce >> 8\\n            // Note: nonceVector = LibERC721OrdersStorage.orderStatusByMaker[maker][nonceRange]\\n            // Note: nonceVector.slot = keccak256(nonceRange, keccak256(maker, LibERC721OrdersStorage.storageId))\\n\\n            // memory[0x240 - 0x260] shouldStoreNonceVectorToStorage flag\\n            mstore(0x240, 0)\\n            // memory[0x260 - 0x280] nonceMask\\n            // memory[0x280 - 0x2a0] nonceVector.slot\\n            // memory[0x2a0 - 0x2c0] nonceVector\\n            // memory[0x2c0 - 0x2e0] nonceRange\\n            mstore(0x2c0, NONCE_RANGE_LIMIT)\\n            // memory[0x2e0 - 0x300] keccak256(maker, LibERC721OrdersStorage.storageId)\\n            mstore(0x2e0, mload(0x20))\\n            mstore(0x300, STORAGE_ID_ERC721_ORDERS)\\n            mstore(0x2e0, keccak256(0x2e0, 0x40))\\n\\n            /////////////////////////// memory[0x300 - 0x380] for collection //////////////\\n            // memory[0x300 - 0x320] collection.head2\\n            // memory[0x320 - 0x340] collection.platformFeePercentage\\n            // memory[0x340 - 0x360] collection.royaltyFeePercentage\\n            // memory[0x360 - 0x380] someSuccess flag\\n            mstore(0x360, 0)\\n\\n            /////////////////////////// memory[0x380 - 0x420] for delegateCall  ///////////\\n            // memory[0x380 - 0x3a0] erc20TokenFromDelegateCall\\n            // memory[0x3a0 - 0x3c0] platformFeeRecipientFromDelegateCall\\n            // memory[0x3c0 - 0x3e0] royaltyFeeRecipientFromDelegateCall\\n            // memory[0x3e0 - 0x400] platformFeeGlobal\\n            mstore(0x3e0, 0)\\n            // memory[0x400 - 0x420] royaltyFeeGlobal\\n            mstore(0x400, 0)\\n\\n            /////////////////////////// memory[0x420 - 0x4a0] for transferERC20 ///////////\\n            // memory[0x420 - 0x440] selector for `transferFrom(address,address,uint256)`\\n            mstore(0x420, 0x23b872dd)\\n            // memory[0x440 - 0x460] msg.sender\\n            mstore(0x440, caller())\\n            // memory[0x460 - 0x480] to\\n            // memory[0x480 - 0x4a0] amount\\n\\n            /////////////////////////// global variables /////////////////////////////////\\n            let nonceVectorForCheckingNonReentrant\\n\\n            // collectionStartNonce = (data1 >> 200) & MASK_40\\n            let collectionStartNonce := and(shr(200, calldataload(0x4)), MASK_40)\\n\\n            // platformFeeRecipient = data3 & MASK_160\\n            let platformFeeRecipient := and(calldataload(0x44), MASK_160)\\n\\n            // Total erc20 amount.\\n            let totalERC20AmountToPlatform\\n            let totalERC20AmountToMaker\\n\\n            let ptrEnd := add(offsetCollectionsBytes, calldataload(sub(offsetCollectionsBytes, 0x20)))\\n            for { let offsetCollection := offsetCollectionsBytes } lt(offsetCollection, ptrEnd) {} {\\n                // memory[0xe0 - 0x100] nftAddress\\n                // head1 [96 bits(filledIndexList part1) + 160 bits(nftAddress)]\\n                mstore(0xe0, and(calldataload(offsetCollection), MASK_160)) // nftAddress = head1 & MASK_160\\n\\n                // memory[0x300 - 0x320] collection.head2\\n                // collectionType: 0 - basicCollection, 1 - collection\\n                // head2 [8 bits(collectionType) + 8 bits(itemsCount) + 8 bits(filledCount) + 8 bits(unused) + 32 bits(filledIndexList part2)\\n                //        + 16 bits(platformFeePercentage) + 16 bits(royaltyFeePercentage) + 160 bits(royaltyFeeRecipient)]\\n                mstore(0x300, calldataload(add(offsetCollection, 0x20)))\\n\\n                // filledIndexList [96 bits(filledIndexList part1) + 32 bits(filledIndexList part2) + 128 bits(unused)]\\n                // filledIndexList = (head1 & MASK_INDEX_LIST_PART1) | ((head2 >> 64) & MASK_INDEX_LIST_PART2)\\n                let filledIndexList := or(and(calldataload(offsetCollection), MASK_INDEX_LIST_PART1), and(shr(64, mload(0x300)), MASK_INDEX_LIST_PART2))\\n                let filledCount := byte(2, mload(0x300))\\n                let itemsCount := byte(1, mload(0x300))\\n                if filledCount {\\n                    if gt(filledCount, itemsCount) {\\n                        _revertInvalidFilledIndex()\\n                    }\\n                    if gt(filledCount, 128) {\\n                        _revertInvalidFilledIndex()\\n                    }\\n                    if iszero(extcodesize(mload(0xe0))) {\\n                        _revertInvalidERC721Token()\\n                    }\\n                }\\n\\n                // memory[0x140 - 0x160] platformFeeRecipient\\n                mstore(0x140, platformFeeRecipient)\\n                // memory[0x320 - 0x340] collection.platformFeePercentage\\n                switch platformFeeRecipient\\n                // if (platformFeeRecipient == address(0) platformFeePercentage = 0\\n                case 0 { mstore(0x320, 0) }\\n                // else platformFeePercentage = collection.platformFeePercentage\\n                default { mstore(0x320, and(shr(176, mload(0x300)), MASK_16)) }\\n\\n                // memory[0x180 - 0x1a0] royaltyFeeRecipient\\n                mstore(0x180, and(mload(0x300), MASK_160))\\n                // memory[0x340 - 0x360] collection.royaltyFeePercentage\\n                switch mload(0x180)\\n                // if (royaltyFeeRecipient == address(0) royaltyFeePercentage = 0\\n                case 0 { mstore(0x340, 0) }\\n                // else royaltyFeePercentage = collection.royaltyFeePercentage\\n                default { mstore(0x340, and(shr(160, mload(0x300)), MASK_16)) }\\n\\n                // Check fees.\\n                if gt(add(mload(0x320), mload(0x340)), 10000) {\\n                    revertFeesPercentageExceedsLimit()\\n                }\\n\\n                let totalERC20AmountToRoyalty\\n\\n                // switch collectionType\\n                switch byte(0, mload(0x300))\\n\\n                // basicCollection\\n                case 0 {\\n                    for { } filledCount { } {\\n                        filledCount := sub(filledCount, 1)\\n\\n                        let filledIndex := byte(filledCount, filledIndexList)\\n                        if iszero(lt(filledIndex, itemsCount)) {\\n                            _revertInvalidFilledIndex()\\n                        }\\n\\n                        // memory[0x60 - 0x80] nonce\\n                        // memory[0x240 - 0x260] shouldStoreNonceVectorToStorage flag\\n                        // memory[0x260 - 0x280] nonceMask\\n                        // memory[0x280 - 0x2a0] nonceVector.slot\\n                        // memory[0x2a0 - 0x2c0] nonceVector\\n                        // memory[0x2c0 - 0x2e0] nonceRange\\n                        // memory[0x2e0 - 0x300] keccak256(maker, LibERC721OrdersStorage.storageId)\\n\\n                        // nonce = add(collectionStartNonce, filledIndex)\\n                        mstore(0x60, add(collectionStartNonce, filledIndex))\\n\\n                        // if (nonceRange != newNonceRange)\\n                        if iszero(eq(mload(0x2c0), shr(8, mload(0x60)))) {\\n                            // Store nonce to storage if needed.\\n                            if mload(0x240) {\\n                                // Revert if reentrant.\\n                                if iszero(eq(nonceVectorForCheckingNonReentrant, sload(mload(0x280)))) {\\n                                    _revertReentrantCall()\\n                                }\\n\\n                                // Store nonce to storage at one time.\\n                                sstore(mload(0x280), mload(0x2a0))\\n                                // Clear store nonceVector flag.\\n                                mstore(0x240, 0)\\n                            }\\n\\n                            // nonceRange = nonce >> 8\\n                            mstore(0x2c0, shr(8, mload(0x60)))\\n                            // Calculate nonceVector.slot and store to memory.\\n                            mstore(0x280, keccak256(0x2c0, 0x40))\\n                            // Load nonceVector from storage.\\n                            nonceVectorForCheckingNonReentrant := sload(mload(0x280))\\n                            // Store nonceVector to memory.\\n                            mstore(0x2a0, nonceVectorForCheckingNonReentrant)\\n                        }\\n\\n                        // memory[0x260 - 0x280] nonceMask\\n                        // nonceMask = 1 << (nonce & 0xff)\\n                        mstore(0x260, shl(and(mload(0x60), 0xff), 1))\\n\\n                        // if order is not filled.\\n                        // if (nonceVector & nonceMask == 0)\\n                        if iszero(and(mload(0x2a0), mload(0x260))) {\\n                            // orderItem [96 bits(erc20TokenAmount) + 160 bits(nftId)]\\n                            let orderItem := calldataload(add(add(offsetCollection, 0x40), mul(filledIndex, 0x20)))\\n\\n                            // memory[0xe0 - 0x100] nftAddress\\n                            // memory[0x1c0 - 0x1e0] selector for `transferFrom(address,address,uint256)`\\n                            // memory[0x1e0 - 0x200] maker\\n                            // memory[0x200 - 0x220] taker\\n                            // memory[0x220 - 0x240] nftId\\n                            mstore(0x220, and(orderItem, MASK_160))\\n\\n                            // transferERC721\\n                            // 0x1dc = 0x1c0 + 28\\n                            if call(gas(), mload(0xe0), 0, 0x1dc, 0x64, 0, 0) {\\n                                // Set store nonceVector flag.\\n                                mstore(0x240, 1)\\n\\n                                // Update nonceVector.\\n                                // nonceVector |= nonceMask\\n                                mstore(0x2a0, or(mload(0x2a0), mload(0x260)))\\n\\n                                // Calculate fees.\\n                                // memory[0xa0 - 0xc0] erc20TokenAmount\\n                                mstore(0xa0, shr(160, orderItem)) // erc20TokenAmount = orderItem >> 160\\n\\n                                // memory[0x140 - 0x1c0] fees.data\\n                                // memory[0x140 - 0x160] platformFeeRecipient\\n                                // memory[0x160 - 0x180] platformFeeAmount\\n                                // memory[0x180 - 0x1a0] royaltyFeeRecipient\\n                                // memory[0x1a0 - 0x1c0] royaltyFeeAmount\\n\\n                                // memory[0x320 - 0x340] platformFeePercentage\\n                                // platformFeeAmount = erc20TokenAmount * platformFeePercentage / 10000\\n                                mstore(0x160, div(mul(mload(0xa0), mload(0x320)), 10000))\\n\\n                                // memory[0x340 - 0x360] royaltyFeePercentage\\n                                // royaltyFeeAmount = erc20TokenAmount * royaltyFeePercentage / 10000\\n                                mstore(0x1a0, div(mul(mload(0xa0), mload(0x340)), 10000))\\n\\n                                // Update total erc20 amount.\\n                                // totalERC20AmountToMaker += erc20TokenAmount - (platformFeeAmount + royaltyFeeAmount)\\n                                totalERC20AmountToMaker := add(totalERC20AmountToMaker, sub(mload(0xa0), add(mload(0x160), mload(0x1a0))))\\n                                // totalERC20AmountToPlatform += platformFeeAmount\\n                                totalERC20AmountToPlatform := add(totalERC20AmountToPlatform, mload(0x160))\\n                                // totalERC20AmountToRoyalty += royaltyFeeAmount\\n                                totalERC20AmountToRoyalty := add(totalERC20AmountToRoyalty, mload(0x1a0))\\n\\n                                // Emit event\\n                                // memory[0 - 0x20] orderHash\\n                                // memory[0x20 - 0x40] maker\\n                                // memory[0x40 - 0x60] taker\\n                                // memory[0x60 - 0x80] nonce\\n                                // memory[0x80 - 0xa0] erc20Token\\n                                // memory[0xa0 - 0xc0] erc20TokenAmount\\n                                // memory[0xc0 - 0xe0] fees.offset\\n                                // memory[0xe0 - 0x100] nftAddress\\n                                // memory[0x100 - 0x120] nftId\\n                                mstore(0x100, mload(0x220))\\n\\n                                // fees\\n                                switch platformFeeRecipient\\n                                case 0 {\\n                                    // memory[0x180 - 0x1a0] royaltyFeeRecipient\\n                                    switch mload(0x180)\\n                                    case 0 {\\n                                        // memory[0x120 - 0x140] fees.length\\n                                        mstore(0x120, 0)\\n                                        // emit event\\n                                        log1(0, 320 /* 10 * 32 */, _TOPIC_SELL_ORDER_FILLED)\\n                                    }\\n                                    default {\\n                                        // memory[0x120 - 0x140] fees.length\\n                                        mstore(0x120, 1)\\n                                        // Copy royaltyFeeRecipient to memory[0x140 - 0x160]\\n                                        mstore(0x140, mload(0x180))\\n                                        // Copy royaltyFeeAmount to memory[0x160 - 0x180]\\n                                        mstore(0x160, mload(0x1a0))\\n                                        // emit event\\n                                        log1(0, 384 /* 12 * 32 */, _TOPIC_SELL_ORDER_FILLED)\\n                                    }\\n                                }\\n                                default {\\n                                    // memory[0x180 - 0x1a0] royaltyFeeRecipient\\n                                    switch mload(0x180)\\n                                    case 0 {\\n                                        // memory[0x120 - 0x140] fees.length\\n                                        mstore(0x120, 1)\\n                                        // emit event\\n                                        log1(0, 384 /* 12 * 32 */, _TOPIC_SELL_ORDER_FILLED)\\n                                    }\\n                                    default {\\n                                        // memory[0x120 - 0x140] fees.length\\n                                        mstore(0x120, 2)\\n                                        // emit event\\n                                        log1(0, 448 /* 14 * 32 */, _TOPIC_SELL_ORDER_FILLED)\\n                                    }\\n                                }\\n\\n                                // Set someSuccess flag.\\n                                mstore(0x360, 1)\\n                            }\\n                        }\\n                    } // end for\\n                    // Update offsetCollection.\\n                    offsetCollection := add(add(offsetCollection, 0x40), mul(itemsCount, 0x20))\\n                } // end basicCollection\\n\\n                // collection\\n                default {\\n                    for { } filledCount { } {\\n                        filledCount := sub(filledCount, 1)\\n\\n                        let filledIndex := byte(filledCount, filledIndexList)\\n                        if iszero(lt(filledIndex, itemsCount)) {\\n                            _revertInvalidFilledIndex()\\n                        }\\n\\n                        // memory[0x60 - 0x80] nonce\\n                        // memory[0x240 - 0x260] shouldStoreNonceVectorToStorage flag\\n                        // memory[0x260 - 0x280] nonceMask\\n                        // memory[0x280 - 0x2a0] nonceVector.slot\\n                        // memory[0x2a0 - 0x2c0] nonceVector\\n                        // memory[0x2c0 - 0x2e0] nonceRange\\n                        // memory[0x2e0 - 0x300] keccak256(maker, LibERC721OrdersStorage.storageId)\\n\\n                        // nonce = add(collectionStartNonce, filledIndex)\\n                        mstore(0x60, add(collectionStartNonce, filledIndex))\\n\\n                        // if (nonceRange != newNonceRange)\\n                        if iszero(eq(mload(0x2c0), shr(8, mload(0x60)))) {\\n                            // Store nonce to storage if needed.\\n                            if mload(0x240) {\\n                                // Revert if reentrant.\\n                                if iszero(eq(nonceVectorForCheckingNonReentrant, sload(mload(0x280)))) {\\n                                    _revertReentrantCall()\\n                                }\\n\\n                                // Store nonce to storage at one time.\\n                                sstore(mload(0x280), mload(0x2a0))\\n                                // Clear store nonceVector flag.\\n                                mstore(0x240, 0)\\n                            }\\n\\n                            // nonceRange = nonce >> 8\\n                            mstore(0x2c0, shr(8, mload(0x60)))\\n                            // Calculate nonceVector.slot and store to memory.\\n                            mstore(0x280, keccak256(0x2c0, 0x40))\\n                            // Load nonceVector from storage.\\n                            nonceVectorForCheckingNonReentrant := sload(mload(0x280))\\n                            // Store nonceVector to memory.\\n                            mstore(0x2a0, nonceVectorForCheckingNonReentrant)\\n                        }\\n\\n                        // memory[0x260 - 0x280] nonceMask\\n                        // nonceMask = 1 << (nonce & 0xff)\\n                        mstore(0x260, shl(and(mload(0x60), 0xff), 1))\\n\\n                        // if order is not filled.\\n                        // if (nonceVector & nonceMask == 0)\\n                        if iszero(and(mload(0x2a0), mload(0x260))) {\\n                            // struct OrderItem {\\n                            //     uint256 erc20TokenAmount;\\n                            //     uint256 nftId;\\n                            // }\\n                            let offsetOrderItem := add(add(offsetCollection, 0x40), mul(filledIndex, 0x40))\\n                            if gt(calldataload(offsetOrderItem), MAX_ERC20_AMOUNT) {\\n                                _revertERC20AmountExceedsLimit()\\n                            }\\n\\n                            // memory[0xe0 - 0x100] nftAddress\\n                            // memory[0x1c0 - 0x1e0] selector for `transferFrom(address,address,uint256)`\\n                            // memory[0x1e0 - 0x200] maker\\n                            // memory[0x200 - 0x220] taker\\n                            // memory[0x220 - 0x240] nftId\\n                            mstore(0x220, calldataload(add(offsetOrderItem, 0x20)))\\n\\n                            // transferERC721\\n                            // 0x1dc = 0x1c0 + 28\\n                            if call(gas(), mload(0xe0), 0, 0x1dc, 0x64, 0, 0) {\\n                                // Set store nonceVector flag.\\n                                mstore(0x240, 1)\\n\\n                                // Update nonceVector.\\n                                // nonceVector |= nonceMask\\n                                mstore(0x2a0, or(mload(0x2a0), mload(0x260)))\\n\\n                                // Calculate fees.\\n                                // memory[0xa0 - 0xc0] erc20TokenAmount\\n                                mstore(0xa0, calldataload(offsetOrderItem))\\n\\n                                // memory[0x140 - 0x1c0] fees.data\\n                                // memory[0x140 - 0x160] platformFeeRecipient\\n                                // memory[0x160 - 0x180] platformFeeAmount\\n                                // memory[0x180 - 0x1a0] royaltyFeeRecipient\\n                                // memory[0x1a0 - 0x1c0] royaltyFeeAmount\\n\\n                                // memory[0x320 - 0x340] platformFeePercentage\\n                                // platformFeeAmount = erc20TokenAmount * platformFeePercentage / 10000\\n                                mstore(0x160, div(mul(mload(0xa0), mload(0x320)), 10000))\\n\\n                                // memory[0x340 - 0x360] royaltyFeePercentage\\n                                // royaltyFeeAmount = erc20TokenAmount * royaltyFeePercentage / 10000\\n                                mstore(0x1a0, div(mul(mload(0xa0), mload(0x340)), 10000))\\n\\n                                // Update total erc20 amount.\\n                                // totalERC20AmountToMaker += erc20TokenAmount - (platformFeeAmount + royaltyFeeAmount)\\n                                totalERC20AmountToMaker := add(totalERC20AmountToMaker, sub(mload(0xa0), add(mload(0x160), mload(0x1a0))))\\n                                // totalERC20AmountToPlatform += platformFeeAmount\\n                                totalERC20AmountToPlatform := add(totalERC20AmountToPlatform, mload(0x160))\\n                                // totalERC20AmountToRoyalty += royaltyFeeAmount\\n                                totalERC20AmountToRoyalty := add(totalERC20AmountToRoyalty, mload(0x1a0))\\n\\n                                // Emit event\\n                                // memory[0 - 0x20] orderHash\\n                                // memory[0x20 - 0x40] maker\\n                                // memory[0x40 - 0x60] taker\\n                                // memory[0x60 - 0x80] nonce\\n                                // memory[0x80 - 0xa0] erc20Token\\n                                // memory[0xa0 - 0xc0] erc20TokenAmount\\n                                // memory[0xc0 - 0xe0] fees.offset\\n                                // memory[0xe0 - 0x100] nftAddress\\n                                // memory[0x100 - 0x120] nftId\\n                                mstore(0x100, mload(0x220))\\n\\n                                // fees\\n                                switch platformFeeRecipient\\n                                case 0 {\\n                                    // memory[0x180 - 0x1a0] royaltyFeeRecipient\\n                                    switch mload(0x180)\\n                                    case 0 {\\n                                        // memory[0x120 - 0x140] fees.length\\n                                        mstore(0x120, 0)\\n                                        // emit event\\n                                        log1(0, 320 /* 10 * 32 */, _TOPIC_SELL_ORDER_FILLED)\\n                                    }\\n                                    default {\\n                                        // memory[0x120 - 0x140] fees.length\\n                                        mstore(0x120, 1)\\n                                        // Copy royaltyFeeRecipient to memory[0x140 - 0x160]\\n                                        mstore(0x140, mload(0x180))\\n                                        // Copy royaltyFeeAmount to memory[0x160 - 0x180]\\n                                        mstore(0x160, mload(0x1a0))\\n                                        // emit event\\n                                        log1(0, 384 /* 12 * 32 */, _TOPIC_SELL_ORDER_FILLED)\\n                                    }\\n                                }\\n                                default {\\n                                    // memory[0x180 - 0x1a0] royaltyFeeRecipient\\n                                    switch mload(0x180)\\n                                    case 0 {\\n                                        // memory[0x120 - 0x140] fees.length\\n                                        mstore(0x120, 1)\\n                                        // emit event\\n                                        log1(0, 384 /* 12 * 32 */, _TOPIC_SELL_ORDER_FILLED)\\n                                    }\\n                                    default {\\n                                        // memory[0x120 - 0x140] fees.length\\n                                        mstore(0x120, 2)\\n                                        // emit event\\n                                        log1(0, 448 /* 14 * 32 */, _TOPIC_SELL_ORDER_FILLED)\\n                                    }\\n                                }\\n\\n                                // Set someSuccess flag.\\n                                mstore(0x360, 1)\\n                            }\\n                        }\\n                    } // end for\\n                    // Update offsetCollection.\\n                    offsetCollection := add(add(offsetCollection, 0x40), mul(itemsCount, 0x40))\\n                } // end collection\\n\\n                // Update collectionStartNonce.\\n                // collectionStartNonce += itemsCount\\n                // memory[0x300 - 0x320] collection.head2\\n                collectionStartNonce := add(collectionStartNonce, itemsCount)\\n\\n                // Pay royaltyFee together.\\n                if totalERC20AmountToRoyalty {\\n                    // memory[0x80 - 0xa0] erc20Token\\n                    // memory[0x180 - 0x1a0] royaltyFeeRecipient\\n                    // memory[0x380 - 0x3a0] erc20TokenFromDelegateCall\\n                    // memory[0x3c0 - 0x3e0] royaltyFeeRecipientFromDelegateCall\\n                    switch and(eq(mload(0x80), mload(0x380)), eq(mload(0x180), mload(0x3c0)))\\n                    case 1 {\\n                        // memory[0x400 - 0x420] royaltyFeeGlobal\\n                        mstore(0x400, add(mload(0x400), totalERC20AmountToRoyalty))\\n                    }\\n                    default {\\n                        _transferERC20(mload(0x180), totalERC20AmountToRoyalty)\\n                    }\\n                }\\n            } // end for\\n\\n            // Store nonce to storage if needed.\\n            if mload(0x240) {\\n                // Revert if reentrant.\\n                if iszero(eq(nonceVectorForCheckingNonReentrant, sload(mload(0x280)))) {\\n                    _revertReentrantCall()\\n                }\\n\\n                // Store nonce to storage at one time.\\n                // memory[0x280 - 0x2a0] nonceVector.slot\\n                // memory[0x2a0 - 0x2c0] nonceVector\\n                sstore(mload(0x280), mload(0x2a0))\\n            }\\n\\n            // Pay to maker at one time.\\n            if totalERC20AmountToMaker {\\n                // memory[0x20 - 0x40] maker\\n                _transferERC20(mload(0x20), totalERC20AmountToMaker)\\n            }\\n\\n            // Pay to platform at one time.\\n            if totalERC20AmountToPlatform {\\n                // memory[0x80 - 0xa0] erc20Token\\n                // memory[0x380 - 0x3a0] erc20TokenFromDelegateCall\\n                // memory[0x3a0 - 0x3c0] platformFeeRecipientFromDelegateCall\\n                switch and(eq(mload(0x80), mload(0x380)), eq(platformFeeRecipient, mload(0x3a0)))\\n                case 1 {\\n                    // memory[0x3e0 - 0x400] platformFeeGlobal\\n                    mstore(0x3e0, add(mload(0x3e0), totalERC20AmountToPlatform))\\n                }\\n                default {\\n                    _transferERC20(platformFeeRecipient, totalERC20AmountToPlatform)\\n                }\\n            }\\n\\n            // Revert if none of the orders is filled.\\n            // memory[0x360 - 0x380] someSuccess flag\\n            if iszero(mload(0x360)) {\\n                _revertNoOrderFilled()\\n            }\\n\\n            ///////////////////////////////// functions  /////////////////////////////////\\n            function _transferERC20(_to, _amount) {\\n                // memory[0x80 - 0xa0] erc20Token\\n                switch mload(0x80)\\n                case 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE {\\n                    if iszero(call(gas(), _to, _amount, 0, 0, 0, 0)) {\\n                        _revertTransferETHFailed()\\n                    }\\n                }\\n                default {\\n                    if iszero(extcodesize(mload(0x80))) {\\n                        _revertInvalidERC20Token()\\n                    }\\n\\n                    // memory[0x420 - 0x440] selector for `transferFrom(address,address,uint256)`\\n                    // memory[0x440 - 0x460] msg.sender\\n                    // memory[0x460 - 0x480] to\\n                    mstore(0x460, _to)\\n                    // memory[0x480 - 0x4a0] amount\\n                    mstore(0x480, _amount)\\n\\n                    // memory[0x80 - 0xa0] erc20Token\\n                    // 0x43c = 0x420 + 28\\n                    if iszero(call(gas(), mload(0x80), 0, 0x43c, 0x64, 0x480, 0x20)) {\\n                        _revertTransferERC20Failed()\\n                    }\\n\\n                    // Check for ERC20 success. ERC20 tokens should return a boolean, but some don't.\\n                    // We accept 0-length return data as success, or at least 32 bytes that starts with\\n                    // a 32-byte boolean true.\\n                    if returndatasize() {\\n                        if lt(returndatasize(), 0x20) {\\n                            _revertTransferERC20Failed()\\n                        }\\n                        if iszero(eq(mload(0x480), 1)) {\\n                            _revertTransferERC20Failed()\\n                        }\\n                    }\\n                }\\n            }\\n\\n            function revertFeesPercentageExceedsLimit() {\\n                // revert(\\\"fillBatchSignedERC721Order: total fees percentage exceeds the limit.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000004466696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x746f74616c20666565732070657263656e746167652065786365656473207468)\\n                mstore(0x80, 0x65206c696d69742e000000000000000000000000000000000000000000000000)\\n                mstore(0xa0, 0)\\n                revert(0, 0xa4)\\n            }\\n\\n            function _revertInvalidFilledIndex() {\\n                // revert(\\\"fillBatchSignedERC721Order: invalid filledIndex.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003066696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x696e76616c69642066696c6c6564496e6465782e000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertReentrantCall() {\\n                // revert(\\\"fillBatchSignedERC721Order: reentrant call.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002b66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x7265656e7472616e742063616c6c2e0000000000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertERC20AmountExceedsLimit() {\\n                // revert(\\\"fillBatchSignedERC721Order: erc20TokenAmount exceeds limit.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003b66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x6572633230546f6b656e416d6f756e742065786365656473206c696d69742e00)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertNoOrderFilled() {\\n                // revert(\\\"fillBatchSignedERC721Order: no order filled.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002c66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x6e6f206f726465722066696c6c65642e00000000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertTransferETHFailed() {\\n                // revert(\\\"fillBatchSignedERC721Order: failed to transfer ETH.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003366696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x6661696c656420746f207472616e73666572204554482e000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertTransferERC20Failed() {\\n                // revert(\\\"fillBatchSignedERC721Order: failed to transfer ERC20.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003566696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x6661696c656420746f207472616e736665722045524332302e00000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertInvalidERC20Token() {\\n                // revert(\\\"invalid erc20 token\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x00000013696e76616c696420657263323020746f6b656e000000000000000000)\\n                mstore(0x60, 0)\\n                revert(0, 0x64)\\n            }\\n\\n            function _revertInvalidERC721Token() {\\n                // revert(\\\"invalid erc271 token\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x00000014696e76616c69642065726337323120746f6b656e0000000000000000)\\n                mstore(0x60, 0)\\n                revert(0, 0x64)\\n            }\\n        }\\n    }\\n\\n    /// data1 [8 bits(signatureType) + 8 bits(reserved) + 40 bits(startNonce) + 8 bits(v) + 32 bits(listingTime) + 160 bits(maker)]\\n    /// data2 [64 bits(taker part1) + 32 bits(expiryTime) + 160 bits(erc20Token)]\\n    function _validateOrder(uint256 offsetCollectionsBytes) internal view returns (bytes32 orderHash) {\\n        address maker;\\n        uint8 signatureType;\\n        uint8 v;\\n\\n        assembly {\\n            let data1 := calldataload(0x4)\\n            let data2 := calldataload(0x24)\\n            signatureType := byte(0, data1)\\n            v := byte(7, data1)\\n\\n            // Check for listingTime.\\n            // if ((data1 >> 160) & MASK_32 > block.timestamp)\\n            if gt(and(shr(160, data1), MASK_32), timestamp()) {\\n                // revert(\\\"fillBatchSignedERC721Order: failed to check for listingTime.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003c66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x6661696c656420746f20636865636b20666f72206c697374696e6754696d652e)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            // Check for expiryTime.\\n            // if ((data2 >> 160) & MASK_32 <= block.timestamp)\\n            if iszero(gt(and(shr(160, data2), MASK_32), timestamp())) {\\n                // revert(\\\"fillBatchSignedERC721Order: failed to check for expiryTime.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003b66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x6661696c656420746f20636865636b20666f722065787069727954696d652e00)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            // Check for erc20Token.\\n            if iszero(and(data2, MASK_160)) {\\n                // revert(\\\"fillBatchSignedERC721Order: invalid erc20Token.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002f66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x696e76616c6964206572633230546f6b656e2e00000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            // Check maker.\\n            maker := and(data1, MASK_160)\\n            if iszero(maker) {\\n                // revert(\\\"fillBatchSignedERC721Order: invalid maker.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002a66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x696e76616c6964206d616b65722e000000000000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n        }\\n\\n        // Get order hash.\\n        orderHash = _getEIP712Hash(_getStructHash(offsetCollectionsBytes));\\n\\n        if (signatureType == 0) {\\n            bytes32 r;\\n            bytes32 s;\\n            assembly {\\n                // Must reset memory status before the `require` sentence.\\n                mstore(0x40, 0x80)\\n                mstore(0x60, 0)\\n\\n                // Get r and v.\\n                r := calldataload(0x64)\\n                s := calldataload(0x84)\\n            }\\n            require(maker == ecrecover(orderHash, v, r, s), \\\"fillBatchSignedERC721Order: failed to validate signature.\\\");\\n        } else if (signatureType == 3) {\\n            assembly {\\n                // selector for `isValidSignature(bytes32,bytes)`\\n                mstore(0, 0x1626ba7e)\\n                mstore(0x20, orderHash)\\n                mstore(0x40, 0x40)\\n                mstore(0x60, 0x41)\\n                calldatacopy(0x80, 0x64, 64)\\n                mstore(0xc0, shl(248, v))\\n\\n                if iszero(extcodesize(maker)) {\\n                    _revertInvalidMaker()\\n                }\\n\\n                // Call signer with `isValidSignature` to validate signature.\\n                if iszero(staticcall(gas(), maker, 0x1c, 0xa5, 0, 0x20)) {\\n                    _revertInvalidSignature()\\n                }\\n\\n                // Check for returnData.\\n                if iszero(eq(mload(0), 0x1626ba7e00000000000000000000000000000000000000000000000000000000)) {\\n                    _revertInvalidSignature()\\n                }\\n\\n                function _revertInvalidMaker() {\\n                    // revert(\\\"fillBatchSignedERC721Order: invalid maker.\\\")\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x40, 0x0000002a66696c6c42617463685369676e65644552433732314f726465723a20)\\n                    mstore(0x60, 0x696e76616c6964206d616b65722e000000000000000000000000000000000000)\\n                    mstore(0x80, 0)\\n                    revert(0, 0x84)\\n                }\\n\\n                function _revertInvalidSignature() {\\n                    // revert(\\\"fillBatchSignedERC721Order: invalid signature.\\\")\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x40, 0x0000003266696c6c42617463685369676e65644552433732314f726465723a20)\\n                    mstore(0x60, 0x696e76616c6964207369676e61747572652e0000000000000000000000000000)\\n                    mstore(0x80, 0)\\n                    revert(0, 0x84)\\n                }\\n            }\\n        } else {\\n            assembly {\\n                // revert(\\\"fillBatchSignedERC721Order: invalid signatureType.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003266696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x696e76616c6964207369676e6174757265547970652e00000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n        }\\n    }\\n\\n    function _getEIP712Hash(bytes32 structHash) internal view returns (bytes32 eip712Hash) {\\n        assembly {\\n            // EIP712_DOMAIN_SEPARATOR = keccak256(abi.encode(\\n            //     DOMAIN,\\n            //     NAME,\\n            //     VERSION,\\n            //     block.chainid,\\n            //     address(this)\\n            // ));\\n            mstore(0, DOMAIN)\\n            mstore(0x20, NAME)\\n            mstore(0x40, VERSION)\\n            mstore(0x60, chainid())\\n            mstore(0x80, address())\\n\\n            // eip712Hash = keccak256(abi.encodePacked(\\n            //     hex\\\"1901\\\",\\n            //     EIP712_DOMAIN_SEPARATOR,\\n            //     structHash\\n            // ));\\n            mstore(0xa0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n            mstore(0xa2, keccak256(0, 0xa0))\\n            mstore(0xc2, structHash)\\n            eip712Hash := keccak256(0xa0, 0x42)\\n        }\\n    }\\n\\n    /// data1 [[8 bits(signatureType) + 8 bits(reserved) + 40 bits(startNonce) + 8 bits(v) + 32 bits(listingTime) + 160 bits(maker)]\\n    /// data2 [64 bits(taker part1) + 32 bits(expiryTime) + 160 bits(erc20Token)]\\n    /// data3 [96 bits(taker part2) + 160 bits(platformFeeRecipient)]\\n    function _getStructHash(uint256 offsetCollectionsBytes) internal view returns (bytes32 structHash) {\\n        // structHash = keccak256(abi.encode(\\n        //     _BATCH_SIGNED_ERC721_ORDERS_TYPE_HASH, // offset: 0x0\\n        //     maker,       // offset: 0x20\\n        //     listingTime, // offset: 0x40\\n        //     expiryTime,  // offset: 0x60\\n        //     startNonce,  // offset: 0x80\\n        //     erc20Token,  // offset: 0xa0\\n        //     platformFeeRecipient,    // offset: 0xc0\\n        //     basicCollectionsHash,    // offset: 0xe0\\n        //     collectionsHash,         // offset: 0x100\\n        //     hashNonce    // offset: 0x120\\n        // ));\\n\\n        // Store basicCollectionsHash to memory[0xe0] and store collectionsHash to memory[0x100].\\n        _storeCollectionsHashToMemory(offsetCollectionsBytes);\\n\\n        assembly {\\n            let data1 := calldataload(0x4)\\n            let data2 := calldataload(0x24)\\n            let data3 := calldataload(0x44)\\n            let maker := and(data1, MASK_160)\\n\\n            // _BATCH_SIGNED_ERC721_ORDERS_TYPE_HASH\\n            mstore(0, _BATCH_SIGNED_ERC721_ORDERS_TYPE_HASH)\\n\\n            // maker\\n            mstore(0x20, maker)\\n\\n            // listingTime = (data1 >> 160) & MASK_32\\n            mstore(0x40, and(shr(160, data1), MASK_32))\\n\\n            // expiryTime = (data2 >> 160) & MASK_32\\n            mstore(0x60, and(shr(160, data2), MASK_32))\\n\\n            // startNonce = (data1 >> 200) & MASK_40\\n            mstore(0x80, and(shr(200, data1), MASK_40))\\n\\n            // erc20Token = data2 & MASK_160\\n            mstore(0xa0, and(data2, MASK_160))\\n\\n            // platformFeeRecipient = data3 & MASK_160\\n            mstore(0xc0, and(data3, MASK_160))\\n\\n            // 0xe0 basicCollectionsHash\\n            // 0x100 collectionsHash\\n\\n            // 0x120 hashNonce\\n            // hashNonce.slot = keccak256(abi.encode(maker, STORAGE_ID_COMMON_NFT_ORDERS))\\n            // hashNonce = sload(hashNonce.slot)\\n            mstore(0x120, maker)\\n            mstore(0x140, STORAGE_ID_COMMON_NFT_ORDERS)\\n            mstore(0x120, sload(keccak256(0x120, 0x40)))\\n\\n            structHash := keccak256(0, 0x140 /* 10 * 32 */)\\n        }\\n    }\\n\\n    function _storeCollectionsHashToMemory(uint256 offsetCollectionsBytes) internal pure {\\n        assembly {\\n            let isBasicCollectionsEnded\\n            let basicCollectionsHash\\n            let ptrCollectionHash\\n\\n            let offsetCollection := offsetCollectionsBytes\\n            let ptrEnd := add(offsetCollectionsBytes, calldataload(sub(offsetCollectionsBytes, 0x20)))\\n            for {} lt(offsetCollection, ptrEnd) {} {\\n                // head1 [96 bits(filledIndexList part1) + 160 bits(nftAddress)]\\n                // nftAddress = head1 & MASK_160\\n                let nftAddress := and(calldataload(offsetCollection), MASK_160)\\n                if iszero(nftAddress) {\\n                    _revertInvalidNftAddress()\\n                }\\n\\n                // collectionType: 0 - basicCollection, 1 - collection\\n                // head2 [8 bits(collectionType) + 8 bits(itemsCount) + 8 bits(filledCount) + 8 bits(unused) + 32 bits(filledIndexList part2)\\n                //        + 16 bits(platformFeePercentage) + 16 bits(royaltyFeePercentage) + 160 bits(royaltyFeeRecipient)]\\n                let head2 := calldataload(add(offsetCollection, 0x20))\\n\\n                let itemsCount := byte(1, head2)\\n                if iszero(itemsCount) {\\n                    _revertInvalidItemCount()\\n                }\\n\\n                let filledCount := byte(2, head2)\\n                if or(gt(filledCount, itemsCount), gt(filledCount, 16)) {\\n                    _revertInvalidFilledCount()\\n                }\\n\\n                // basicCollection\\n                if iszero(byte(0, head2)) {\\n                    if isBasicCollectionsEnded {\\n                        _revertInvalidCollectionsBytes()\\n                    }\\n\\n                    // typeHash = _BASIC_COLLECTION_TYPE_HASH\\n                    mstore(ptrCollectionHash, _BASIC_COLLECTION_TYPE_HASH)\\n\\n                    // nftAddress\\n                    mstore(add(ptrCollectionHash, 0x20), nftAddress)\\n\\n                    // fee = head2 & MASK_192\\n                    mstore(add(ptrCollectionHash, 0x40), and(head2, MASK_192))\\n\\n                    // itemsHash\\n                    let ptrItemsHash := add(ptrCollectionHash, 0x60)\\n                    let itemsBytesLength := mul(itemsCount, 0x20)\\n\\n                    // offset: 0x0 - head1\\n                    //         0x20 - head2\\n                    //         0x40 - items.data\\n                    let offsetItems := add(offsetCollection, 0x40)\\n                    calldatacopy(ptrItemsHash, offsetItems, itemsBytesLength)\\n\\n                    // Calculate and store itemsHash.\\n                    mstore(ptrItemsHash, keccak256(ptrItemsHash, itemsBytesLength))\\n\\n                    // keccak256(abi.encode(_BASIC_COLLECTION_TYPE_HASH, nftAddress, fee, itemsHash))\\n                    mstore(ptrCollectionHash, keccak256(ptrCollectionHash, 0x80))\\n\\n                    // Update offset.\\n                    ptrCollectionHash := add(ptrCollectionHash, 0x20)\\n                    offsetCollection := add(offsetItems, itemsBytesLength)\\n                    continue\\n                }\\n\\n                // Get basicCollectionsHash.\\n                if iszero(isBasicCollectionsEnded) {\\n                    // Set flag.\\n                    isBasicCollectionsEnded := 1\\n\\n                    switch ptrCollectionHash\\n                    case 0 {\\n                        // basicCollections is empty.\\n                        basicCollectionsHash := _EMPTY_ARRAY_KECCAK256\\n                    }\\n                    default {\\n                        // Calculate basicCollectionsHash.\\n                        basicCollectionsHash := keccak256(0, ptrCollectionHash)\\n                        ptrCollectionHash := 0\\n                    }\\n                }\\n\\n                // collection\\n                // typeHash = _COLLECTION_TYPE_HASH\\n                mstore(ptrCollectionHash, _COLLECTION_TYPE_HASH)\\n\\n                // nftAddress\\n                mstore(add(ptrCollectionHash, 0x20), nftAddress)\\n\\n                // fee = head2 & MASK_192\\n                mstore(add(ptrCollectionHash, 0x40), and(head2, MASK_192))\\n\\n                // itemsHash\\n                let ptrItemsHash := add(ptrCollectionHash, 0x60)\\n                let itemsBytesLength := mul(itemsCount, 0x40)\\n\\n                // offset: 0x0 - head1\\n                //         0x20 - head2\\n                //         0x40 - items.data\\n                let offsetItems := add(offsetCollection, 0x40)\\n\\n                // Copy items to memory [ptrItemsHash + 0x20].\\n                // Reserve a slot(0x20) to store _ORDER_ITEM_TYPE_HASH.\\n                calldatacopy(add(ptrItemsHash, 0x20), offsetItems, itemsBytesLength)\\n\\n                let ptrItemHashData := ptrItemsHash\\n                let ptrItemEnd := add(ptrItemsHash, mul(itemsCount, 0x20))\\n                for { let ptrItem := ptrItemsHash } lt(ptrItem, ptrItemEnd) {} {\\n                    mstore(ptrItemHashData, _ORDER_ITEM_TYPE_HASH)\\n                    mstore(ptrItem, keccak256(ptrItemHashData, 0x60))\\n\\n                    ptrItem := add(ptrItem, 0x20)\\n                    ptrItemHashData := add(ptrItemHashData, 0x40)\\n                }\\n\\n                // Calculate and store itemsHash.\\n                mstore(ptrItemsHash, keccak256(ptrItemsHash, mul(itemsCount, 0x20)))\\n\\n                // keccak256(abi.encode(_COLLECTION_TYPE_HASH, nftAddress, fee, itemsHash))\\n                mstore(ptrCollectionHash, keccak256(ptrCollectionHash, 0x80))\\n\\n                // Update offset.\\n                ptrCollectionHash := add(ptrCollectionHash, 0x20)\\n                offsetCollection := add(offsetItems, itemsBytesLength)\\n            }\\n\\n            // if (offsetCollection != ptrEnd) revert()\\n            if iszero(eq(offsetCollection, ptrEnd)) {\\n                _revertInvalidCollectionsBytes()\\n            }\\n\\n            switch isBasicCollectionsEnded\\n            // Order.collections is empty.\\n            case 0 {\\n                // Order.basicCollections is empty.\\n                if iszero(ptrCollectionHash) {\\n                    _revertInvalidCollectionsBytes()\\n                }\\n\\n                // Store basicCollectionsHash to memory[0xe0].\\n                mstore(0xe0, keccak256(0, ptrCollectionHash))\\n\\n                // Store collectionsHash to memory[0x100].\\n                mstore(0x100, _EMPTY_ARRAY_KECCAK256)\\n            }\\n            // Order.collections is not empty.\\n            default {\\n                // Store basicCollectionsHash to memory[0xe0].\\n                mstore(0xe0, basicCollectionsHash)\\n\\n                // Store collectionsHash to memory[0x100].\\n                mstore(0x100, keccak256(0, ptrCollectionHash))\\n            }\\n\\n            ///////////////////////////////// functions  /////////////////////////////////\\n            function _revertInvalidNftAddress() {\\n                // revert(\\\"fillBatchSignedERC721Order: invalid nftAddress.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002f66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x696e76616c6964206e6674416464726573732e00000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertInvalidItemCount() {\\n                // revert(\\\"fillBatchSignedERC721Order: invalid itemCount.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002e66696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x696e76616c6964206974656d436f756e742e0000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertInvalidFilledCount() {\\n                // revert(\\\"fillBatchSignedERC721Order: invalid filledCount.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003066696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x696e76616c69642066696c6c6564436f756e742e000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertInvalidCollectionsBytes() {\\n                // revert(\\\"fillBatchSignedERC721Order: invalid collectionsBytes.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003566696c6c42617463685369676e65644552433732314f726465723a20)\\n                mstore(0x60, 0x696e76616c696420636f6c6c656374696f6e7342797465732e00000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zero-ex/src/storage/LibCommonNftOrdersStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Copyright 2022 Element.Market\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"./LibStorage.sol\\\";\\n\\n\\nlibrary LibCommonNftOrdersStorage {\\n\\n    /// @dev Storage bucket for this feature.\\n    struct Storage {\\n        /* Track per-maker nonces that can be incremented by the maker to cancel orders in bulk. */\\n        // The current nonce for the maker represents the only valid nonce that can be signed by the maker\\n        // If a signature was signed with a nonce that's different from the one stored in nonces, it\\n        // will fail validation.\\n        mapping(address => uint256) hashNonces;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        uint256 storageSlot = LibStorage.STORAGE_ID_COMMON_NFT_ORDERS;\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor.slot := storageSlot }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zero-ex/src/storage/LibERC721OrdersStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Modifications Copyright 2022 Element.Market\\n  Copyright 2020 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"./LibStorage.sol\\\";\\n\\n\\n/// @dev Storage helpers for `ERC721OrdersFeature`.\\nlibrary LibERC721OrdersStorage {\\n\\n    /// @dev Storage bucket for this feature.\\n    struct Storage {\\n        // maker => nonce range => order status bit vector\\n        mapping(address => mapping(uint248 => uint256)) orderStatusByMaker;\\n        // order hash => preSigned\\n        mapping(bytes32 => uint256) preSigned;\\n        // order hash => filledAmount\\n        mapping(bytes32 => uint128) filledAmount;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        uint256 storageSlot = LibStorage.STORAGE_ID_ERC721_ORDERS;\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor.slot := storageSlot }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zero-ex/src/storage/LibStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Modifications Copyright 2022 Element.Market\\n  Copyright 2020 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\n\\n/// @dev Common storage helpers\\nlibrary LibStorage {\\n\\n    /// @dev What to bit-shift a storage ID by to get its slot.\\n    ///      This gives us a maximum of 2**128 inline fields in each bucket.\\n    uint256 constant STORAGE_ID_PROXY = 1 << 128;\\n    uint256 constant STORAGE_ID_SIMPLE_FUNCTION_REGISTRY = 2 << 128;\\n    uint256 constant STORAGE_ID_OWNABLE = 3 << 128;\\n    uint256 constant STORAGE_ID_COMMON_NFT_ORDERS = 4 << 128;\\n    uint256 constant STORAGE_ID_ERC721_ORDERS = 5 << 128;\\n    uint256 constant STORAGE_ID_ERC1155_ORDERS = 6 << 128;\\n    uint256 constant STORAGE_ID_REENTRANCY_GUARD = 7 << 128;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data3\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IBatchSignedERC721OrdersFeature.BatchSignedERC721OrderParameter\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"erc20TokenFromDelegateCall\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"platformFeeRecipientFromDelegateCall\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltyFeeRecipientFromDelegateCall\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"collections\",\"type\":\"bytes\"}],\"name\":\"delegateCallFillBatchSignedERC721Order\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data3\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IBatchSignedERC721OrdersFeature.BatchSignedERC721OrderParameter\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"collections\",\"type\":\"bytes\"}],\"name\":\"fillBatchSignedERC721Order\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data3\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"collections\",\"type\":\"bytes\"}],\"internalType\":\"struct IBatchSignedERC721OrdersFeature.BatchSignedERC721OrderParameters[]\",\"name\":\"parameters\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"additional1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"additional2\",\"type\":\"uint256\"}],\"name\":\"fillBatchSignedERC721Orders\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "BatchSignedERC721OrdersFeature", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}