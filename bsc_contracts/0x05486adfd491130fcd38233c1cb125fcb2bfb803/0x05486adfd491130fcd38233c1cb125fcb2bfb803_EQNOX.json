{"SourceCode": "{\"BokkyPooBahsDateTimeLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// BokkyPooBah\\u0027s DateTime Library v1.01\\r\\n//\\r\\n// A gas-efficient Solidity date and time library\\r\\n//\\r\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\r\\n//\\r\\n// Tested date range 1970/01/01 to 2345/12/31\\r\\n//\\r\\n// Conventions:\\r\\n// Unit      | Range         | Notes\\r\\n// :-------- |:-------------:|:-----\\r\\n// timestamp | \\u003e= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\r\\n// year      | 1970 ... 2345 |\\r\\n// month     | 1 ... 12      |\\r\\n// day       | 1 ... 31      |\\r\\n// hour      | 0 ... 23      |\\r\\n// minute    | 0 ... 59      |\\r\\n// second    | 0 ... 59      |\\r\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\r\\n//\\r\\n//\\r\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------\\r\\n\\r\\nlibrary BokkyPooBahsDateTimeLibrary {\\r\\n\\r\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    uint constant SECONDS_PER_HOUR = 60 * 60;\\r\\n    uint constant SECONDS_PER_MINUTE = 60;\\r\\n    int constant OFFSET19700101 = 2440588;\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // days = day\\r\\n    //      - 32075\\r\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\r\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\r\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\r\\n    //      - offset\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\\r\\n        require(year \\u003e= 1970);\\r\\n        int _year = int(year);\\r\\n        int _month = int(month);\\r\\n        int _day = int(day);\\r\\n\\r\\n        int __days = _day\\r\\n          - 32075\\r\\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\\r\\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\\r\\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\\r\\n          - OFFSET19700101;\\r\\n\\r\\n        _days = uint(__days);\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // int L = days + 68569 + offset\\r\\n    // int N = 4 * L / 146097\\r\\n    // L = L - (146097 * N + 3) / 4\\r\\n    // year = 4000 * (L + 1) / 1461001\\r\\n    // L = L - 1461 * year / 4 + 31\\r\\n    // month = 80 * L / 2447\\r\\n    // dd = L - 2447 * month / 80\\r\\n    // L = month / 11\\r\\n    // month = month + 2 - 12 * L\\r\\n    // year = 100 * (N - 49) + year + L\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\r\\n        int __days = int(_days);\\r\\n\\r\\n        int L = __days + 68569 + OFFSET19700101;\\r\\n        int N = 4 * L / 146097;\\r\\n        L = L - (146097 * N + 3) / 4;\\r\\n        int _year = 4000 * (L + 1) / 1461001;\\r\\n        L = L - 1461 * _year / 4 + 31;\\r\\n        int _month = 80 * L / 2447;\\r\\n        int _day = L - 2447 * _month / 80;\\r\\n        L = _month / 11;\\r\\n        _month = _month + 2 - 12 * L;\\r\\n        _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n        year = uint(_year);\\r\\n        month = uint(_month);\\r\\n        day = uint(_day);\\r\\n    }\\r\\n\\r\\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\r\\n    }\\r\\n    \\r\\n\\r\\n    \\r\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\r\\n        leapYear = ((year % 4 == 0) \\u0026\\u0026 (year % 100 != 0)) || (year % 400 == 0);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function getDayOfYear(uint timestamp) internal pure returns (uint) {\\r\\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint startYearTimestamp = timestampFromDate(year, 1, 1);\\r\\n        uint diff = timestamp - startYearTimestamp;\\r\\n        return (diff / SECONDS_PER_DAY) + 1;\\r\\n    }\\r\\n\\r\\n    function getYear(uint timestamp) internal pure returns (uint year) {\\r\\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    \\r\\n\\r\\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\r\\n    }\\r\\n    \\r\\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    \\r\\n}\\r\\n\"},\"nox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \\r\\n* EEEEEEEEEEEEEEEEEEEEEE       QQQQQQQQQ       NNNNNNNN        NNNNNNNN       OOOOOOOOO       XXXXXXX       XXXXXXX  *\\r\\n* E::::::::::::::::::::E     QQ:::::::::QQ     N:::::::N       N::::::N     OO:::::::::OO     X:::::X       X:::::X  *\\r\\n* E::::::::::::::::::::E   QQ:::::::::::::QQ   N::::::::N      N::::::N   OO:::::::::::::OO   X:::::X       X:::::X  *\\r\\n* EE::::::EEEEEEEEE::::E  Q:::::::QQQ:::::::Q  N:::::::::N     N::::::N  O:::::::OOO:::::::O  X::::::X     X::::::X  *\\r\\n*   E:::::E       EEEEEE  Q::::::O   Q::::::Q  N::::::::::N    N::::::N  O::::::O   O::::::O  XXX:::::X   X:::::XXX  *\\r\\n*   E:::::E               Q:::::O     Q:::::Q  N:::::::::::N   N::::::N  O:::::O     O:::::O     X:::::X X:::::X     *\\r\\n*   E::::::EEEEEEEEEE     Q:::::O     Q:::::Q  N:::::::N::::N  N::::::N  O:::::O     O:::::O      X:::::X:::::X      *\\r\\n*   E:::::::::::::::E     Q:::::O     Q:::::Q  N::::::N N::::N N::::::N  O:::::O     O:::::O       X:::::::::X       *\\r\\n*   E:::::::::::::::E     Q:::::O     Q:::::Q  N::::::N  N::::N:::::::N  O:::::O     O:::::O       X:::::::::X       *\\r\\n*   E::::::EEEEEEEEEE     Q:::::O     Q:::::Q  N::::::N   N:::::::::::N  O:::::O     O:::::O      X:::::X:::::X      *\\r\\n*   E:::::E               Q:::::O  QQQQ:::::Q  N::::::N    N::::::::::N  O:::::O     O:::::O     X:::::X X:::::X     *\\r\\n*   E:::::E       EEEEEE  Q::::::O Q::::::::Q  N::::::N     N:::::::::N  O::::::O   O::::::O  XXX:::::X   X:::::XXX  *\\r\\n* EE::::::EEEEEEEE:::::E  Q:::::::QQ::::::::Q  N::::::N      N::::::::N  O:::::::OOO:::::::O  X::::::X     X::::::X  *\\r\\n* E::::::::::::::::::::E   QQ::::::::::::::Q   N::::::N       N:::::::N   OO:::::::::::::OO   X:::::X       X:::::X  *\\r\\n* E::::::::::::::::::::E     QQ:::::::::::Q    N::::::N        N::::::N     OO:::::::::OO     X:::::X       X:::::X  *\\r\\n* EEEEEEEEEEEEEEEEEEEEEE       QQQQQQQQ::::QQ  NNNNNNNN         NNNNNNN       OOOOOOOOO       XXXXXXX       XXXXXXX  *\\r\\n*                                      Q:::::Q                                                                       *\\r\\n*                                       QQQQQQ                                                                       *\\r\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /\\r\\n\\r\\n/*\\r\\nProject Name:   Equinox\\r\\nTicker:         EQNOX\\r\\nDecimals:       18\\r\\nToken type:     Certificate of deposit\\r\\n\\r\\n\\r\\nEQNOX has everything a good staking token should have:\\r\\n- EQNOX is immutable\\r\\n- EQNOX has no owner\\r\\n- EQNOX has daily auctions\\r\\n- EQNOX has daily rewards for auction participants\\r\\n- EQNOX has an Automated Market Maker built in\\r\\n- EQNOX has a stable supply and liquidity growth\\r\\n- EQNOX has a 1.8% daily inflation that slowly decays over time\\r\\n- EQNOX has shares that go up when stakes are ended \\r\\n- EQNOX has penalties for ending stakes early\\r\\n- EQNOX has 10% rewards for referrals \\r\\n- EQNOX has a sticky referral system\\r\\n- EQNOX has flexible splitting and merging of stakes\\r\\n- EQNOX allows transferring stakes to different accounts\\r\\n- EQNOX has no end date for stakes\\r\\n\\r\\nAlso, EQNOX is the first certificate of deposit aligned with the seasons:\\r\\n- Every season change has a predictable impact on how EQNOX behaves\\r\\n- Harvest season is the most important season for EQNOX\\r\\n- It\\u0027s when old holders leave, new ones join, and diamond hands are rewarded\\r\\n- Stakes can only be ended without penalty during harvest season\\r\\n- Stakes that survive harvest get more valuable and earn more interest\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\ninterface IBEP20 {\\r\\n  \\r\\n  /**\\r\\n   * @dev Returns the amount of tokens owned by `account`.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remaining number of tokens that `spender` will be\\r\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n   * zero by default.\\r\\n   *\\r\\n   * This value changes when {approve} or {transferFrom} are called.\\r\\n   */\\r\\n  function allowance(address _owner, address spender) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n   * that someone may use both the old and the new allowance by unfortunate\\r\\n   * transaction ordering. One possible solution to mitigate this race\\r\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n   * desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n   * allowance.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  \\r\\n}\\r\\n\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n  function _msgSender() internal view returns (address payable) {\\r\\n    return payable(msg.sender); // added payable\\r\\n  }\\r\\n\\r\\n  function _msgData() internal view returns (bytes memory) {\\r\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n    return msg.data;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            codehash := extcodehash(account)\\r\\n        }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n  /**\\r\\n   * @dev Returns the addition of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `+` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Addition cannot overflow.\\r\\n   */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a, errorMessage);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `*` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Multiplication cannot overflow.\\r\\n   */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b \\u003e 0, errorMessage);\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    function token0() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function factory() external pure returns (address);\\r\\n    function addLiquidity(  \\r\\n        address tokenA,  \\r\\n        address tokenB,  \\r\\n        uint amountADesired,  \\r\\n        uint amountBDesired,  \\r\\n        uint amountAMin,  \\r\\n        uint amountBMin,  \\r\\n        address to,  \\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n}\\r\\n\\r\\n\\r\\ncontract BEP20Token is Context {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  mapping (address =\\u003e uint256) private _balances;\\r\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n  uint256 private _totalSupply = 0;\\r\\n  uint8 private _decimals = 18;\\r\\n  string private _symbol;\\r\\n  string private _name;\\r\\n\\r\\n  event Transfer(\\r\\n      address indexed from,\\r\\n      address indexed to,\\r\\n      uint256 value\\r\\n  );\\r\\n\\r\\n  event Approval(\\r\\n      address indexed owner,\\r\\n      address indexed spender,\\r\\n      uint256 value\\r\\n  );\\r\\n\\r\\n  constructor (string memory tokenName, string memory tokenSymbol) {\\r\\n    _name = tokenName;\\r\\n    _symbol = tokenSymbol;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token decimals.\\r\\n   */\\r\\n  function decimals() external view returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token symbol.\\r\\n   */\\r\\n  function symbol() external view returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Returns the token name.\\r\\n  */\\r\\n  function name() external view returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-totalSupply}.\\r\\n   */\\r\\n  function totalSupply() public view returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-balanceOf}.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256) {\\r\\n    return _balances[account];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-transfer}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `recipient` cannot be the zero address.\\r\\n   * - the caller must have a balance of at least `amount`.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool) {\\r\\n    _transfer(_msgSender(), recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-allowance}.\\r\\n   */\\r\\n  function allowance(address owner, address spender) external view returns (uint256) {\\r\\n    return _allowances[owner][spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-approve}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external returns (bool) {\\r\\n    _approve(_msgSender(), spender, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-transferFrom}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n   * required by the EIP. See the note at the beginning of {BEP20};\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - `sender` and `recipient` cannot be the zero address.\\r\\n   * - `sender` must have a balance of at least `amount`.\\r\\n   * - the caller must have allowance for `sender`\\u0027s tokens of at least\\r\\n   * `amount`.\\r\\n   */\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\r\\n    _transfer(sender, recipient, amount);\\r\\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\"));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n   *\\r\\n   * This is an alternative to {approve} that can be used as a mitigation for\\r\\n   * problems described in {BEP20-approve}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n   *\\r\\n   * This is an alternative to {approve} that can be used as a mitigation for\\r\\n   * problems described in {BEP20-approve}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   * - `spender` must have allowance for the caller of at least\\r\\n   * `subtractedValue`.\\r\\n   */\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"BEP20: decreased allowance below zero\\\"));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n   *\\r\\n   * This is internal function is equivalent to {transfer}, and can be used to\\r\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `sender` cannot be the zero address.\\r\\n   * - `recipient` cannot be the zero address.\\r\\n   * - `sender` must have a balance of at least `amount`.\\r\\n   */\\r\\n  function _transfer(address sender, address recipient, uint256 amount) internal {\\r\\n    require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\r\\n    require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\r\\n\\r\\n    _balances[sender] = _balances[sender].sub(amount, \\\"BEP20: transfer amount exceeds balance\\\");\\r\\n    _balances[recipient] = _balances[recipient].add(amount);\\r\\n    emit Transfer(sender, recipient, amount);\\r\\n  }\\r\\n\\r\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n   * the total supply.\\r\\n   *\\r\\n   * Emits a {Transfer} event with `from` set to the zero address.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `to` cannot be the zero address.\\r\\n   */\\r\\n  function _mint(address account, uint256 amount) internal {\\r\\n    require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\r\\n\\r\\n    _totalSupply = _totalSupply.add(amount);\\r\\n    _balances[account] = _balances[account].add(amount);\\r\\n    emit Transfer(address(0), account, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n   * total supply.\\r\\n   *\\r\\n   * Emits a {Transfer} event with `to` set to the zero address.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `account` cannot be the zero address.\\r\\n   * - `account` must have at least `amount` tokens.\\r\\n   */\\r\\n  function _burn(address account, uint256 amount) internal {\\r\\n    require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\r\\n\\r\\n    _balances[account] = _balances[account].sub(amount, \\\"BEP20: burn amount exceeds balance\\\");\\r\\n    _totalSupply = _totalSupply.sub(amount);\\r\\n    emit Transfer(account, address(0), amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n   *\\r\\n   * This is internal function is equivalent to `approve`, and can be used to\\r\\n   * e.g. set automatic allowances for certain subsystems, etc.\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `owner` cannot be the zero address.\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function _approve(address owner, address spender, uint256 amount) internal {\\r\\n    require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\r\\n    require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\r\\n\\r\\n    _allowances[owner][spender] = amount;\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\r\\n   * from the caller\\u0027s allowance.\\r\\n   *\\r\\n   * See {_burn} and {_approve}.\\r\\n   */\\r\\n  function _burnFrom(address account, uint256 amount) internal {\\r\\n    _burn(account, amount);\\r\\n    _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"BEP20: burn amount exceeds allowance\\\"));\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all EQNOX events\\r\\n */\\r\\nabstract contract Events {\\r\\n\\r\\n\\r\\n    event dayUpdated(\\r\\n        uint256 year,\\r\\n        uint256 dayOfYear,\\r\\n        uint256 indexed tokenDay,\\r\\n        uint256 tokenYear\\r\\n    );\\r\\n    \\r\\n    event stakeCreated(\\r\\n        bytes16 indexed stakeId,\\r\\n        address indexed stakerAddress,\\r\\n        uint256 stakeAmount,\\r\\n        uint256 indexed stakeTokenDay\\r\\n    );\\r\\n    \\r\\n    event stakeMoved(\\r\\n        bytes16 indexed stakeId,\\r\\n        bytes16 newStakeId,\\r\\n        address indexed sender,\\r\\n        address indexed receiver,\\r\\n        uint256 tokenDay\\r\\n    );\\r\\n    \\r\\n    event stakeSplit(\\r\\n        bytes16 indexed stakeId,\\r\\n        bytes16 indexed newStakeId,\\r\\n        uint256 splitDivisor,\\r\\n        address indexed stakerAddress,\\r\\n        uint256 tokenDay\\r\\n    );\\r\\n    \\r\\n    event stakesMerged(\\r\\n        bytes16 indexed stake1Id,\\r\\n        bytes16 indexed stake2Id,\\r\\n        address stakerAddress,\\r\\n        uint256 tokenDay\\r\\n    );\\r\\n    \\r\\n    event stakeEnded(\\r\\n        bytes16 indexed stakeId,\\r\\n        address indexed stackerAddress,\\r\\n        uint256 mintedTokens,\\r\\n        uint256 indexed tokenDay\\r\\n    );\\r\\n    \\r\\n    event sharePriceUpdated(\\r\\n        bytes16 indexed stakeId,\\r\\n        uint256 indexed tokenDay,\\r\\n        uint256 newSharePrice);\\r\\n}\\r\\n\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// BokkyPooBah\\u0027s DateTime Library v1.00 - Contract Instance\\r\\n//\\r\\n// A gas-efficient Solidity date and time library\\r\\n//\\r\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\r\\n//\\r\\n// Tested date range 1970/01/01 to 2345/12/31\\r\\n//\\r\\n// Conventions:\\r\\n// Unit      | Range         | Notes\\r\\n// :-------- |:-------------:|:-----\\r\\n// timestamp | \\u003e= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\r\\n// year      | 1970 ... 2345 |\\r\\n// month     | 1 ... 12      |\\r\\n// day       | 1 ... 31      |\\r\\n// hour      | 0 ... 23      |\\r\\n// minute    | 0 ... 59      |\\r\\n// second    | 0 ... 59      |\\r\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\r\\n//\\r\\n//\\r\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\\r\\n//\\r\\n// GNU Lesser General Public License 3.0\\r\\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\\r\\n// ----------------------------------------------------------------------------\\r\\n\\r\\nimport \\\"./BokkyPooBahsDateTimeLibrary.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all required BokkyPooBah\\u0027s library functions\\r\\n */\\r\\nabstract contract DateTime is BEP20Token{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n\\r\\n    function _now() internal view returns (uint timestamp) {\\r\\n        timestamp = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    function isLeapYear(uint year) internal pure returns (bool leapYear) {\\r\\n        leapYear = BokkyPooBahsDateTimeLibrary._isLeapYear(year);\\r\\n    }\\r\\n\\r\\n    function _getYear(uint timestamp) internal pure returns (uint year) {\\r\\n        year = BokkyPooBahsDateTimeLibrary.getYear(timestamp);\\r\\n    }\\r\\n    \\r\\n    function _getDayOfYear(uint timestamp) internal pure returns(uint day) {\\r\\n        day = BokkyPooBahsDateTimeLibrary.getDayOfYear(timestamp);\\r\\n    }\\r\\n\\r\\n    function _addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);\\r\\n    }\\r\\n\\r\\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\\r\\n        _minutes = BokkyPooBahsDateTimeLibrary.diffMinutes(fromTimestamp, toTimestamp);\\r\\n    }\\r\\n\\r\\n    //taken from bokky lib but without the require\\r\\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint256) {\\r\\n        // require(fromTimestamp \\u003c= toTimestamp);\\r\\n        if(fromTimestamp \\u003e toTimestamp) return 0;\\r\\n        return (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all data and functions related to checking current season and season rules.\\r\\n */\\r\\nabstract contract Calendar is DateTime, Events {\\r\\n    \\r\\n    enum Season {\\r\\n        Winter,\\r\\n        Spring,\\r\\n        Summer,\\r\\n        Autumn\\r\\n    }\\r\\n\\r\\n\\r\\n    uint256 constant SEASON_SIZE = 91;\\r\\n    \\r\\n    \\r\\n    //01-01-2022 12:00PM EST\\r\\n    uint256 public TokenStartTimestamp;\\r\\n\\r\\n    uint256 public CurrentTokenDay;\\r\\n    uint256 public CurrentTokenYear;\\r\\n\\r\\n    uint256 public CurrentDayOfYear;\\r\\n\\r\\n    uint256 public CurrentYear;\\r\\n    \\r\\n    function getCurrentTokenDay() public view returns(uint256) {\\r\\n        return CurrentTokenDay;\\r\\n    }\\r\\n\\r\\n    function _getSeasonForDay(uint256 day) internal pure returns (Season) {\\r\\n        if (day \\u003c= SEASON_SIZE) return Season.Winter;\\r\\n        if (day \\u003c= SEASON_SIZE * 2) return Season.Spring;\\r\\n        if (day \\u003c= SEASON_SIZE * 3) return Season.Summer;\\r\\n        return Season.Autumn;\\r\\n    }\\r\\n    \\r\\n    //interest is generated all year except during harvest when it becomes lowest\\r\\n    function canInterestBeGeneratedForDay(uint256 dayOfYear) public pure returns (bool) {\\r\\n        Season currentSeason = _getSeasonForDay(dayOfYear);\\r\\n        return currentSeason != Season.Autumn;\\r\\n    }\\r\\n    \\r\\n    //ending stakes has penalties all year except during harvest\\r\\n    function endingStakesHasPenaltiesForDay(uint256 dayOfYear) public pure returns (bool) {\\r\\n        Season currentSeason = _getSeasonForDay(dayOfYear);\\r\\n        return currentSeason != Season.Autumn;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all main constants, global variables, mappings, and data structures.\\r\\n */\\r\\nabstract contract Data is Calendar {\\r\\n    \\r\\n    IBEP20 public BUSD_CONTRACT;\\r\\n    address public AUCTION_CONTRACT;\\r\\n    address public CONVERTER_CONTRACT;\\r\\n\\r\\n    uint256 constant internal POOL_NUMERATOR = 8;\\r\\n    uint256 constant internal POOL_DENOMINATOR = 10;\\r\\n    uint256 constant internal M_NUMERATOR = 1;\\r\\n    uint256 constant internal M_DENOMINATOR = 20;\\r\\n    uint256 constant internal SHARE_PRICE_PRECISION = 1E5;\\r\\n    uint256 constant internal INITIAL_SHARE_PRICE = 119000;\\r\\n    uint256 constant internal SHARE_PRICE_MAX = 1E40;\\r\\n    uint256 constant internal DEFAULT_TOKEN_BUSD_RATIO = 14285;\\r\\n\\r\\n    \\r\\n    \\r\\n    uint256 public CurrentSharePrice;\\r\\n    uint256 public SharesAccounting;\\r\\n    uint256 public TokensStakedAccounting;\\r\\n    uint256 public ActiveStakesAccounting;\\r\\n    \\r\\n    \\r\\n    enum StakeState {\\r\\n        Active,\\r\\n        InAccounting,\\r\\n        Closed,\\r\\n        Moved,\\r\\n        Merged\\r\\n    }\\r\\n    \\r\\n    struct Stake {\\r\\n        bytes16 stakeId;\\r\\n        uint256 stakeAmount;\\r\\n        uint256 shares;\\r\\n        StakeState stakeState;\\r\\n        uint256 interestAmount;\\r\\n        uint256 stakeStartTokenDay;\\r\\n        uint256 numDaysAccountedFor;\\r\\n        uint256 accountingStartTokenDay;\\r\\n        uint256 accountingStartDayOfYear;\\r\\n        uint256 accountingStartTokenYear;\\r\\n    }\\r\\n\\r\\n    struct Inflation {\\r\\n        uint256 numerator;\\r\\n        uint256 denominator;\\r\\n        uint256 totalShares;\\r\\n        uint256 totalSupply;\\r\\n        uint256 tokensStakedAccounting;\\r\\n    }\\r\\n    \\r\\n    struct PoolRatio {\\r\\n        uint256 amountToken;\\r\\n        uint256 amountBusd;\\r\\n        uint256 timestamp;\\r\\n    }\\r\\n    \\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e Stake)) public stakes;\\r\\n    mapping(address =\\u003e uint256) public stakeCount;\\r\\n    mapping(address =\\u003e address) public referrals;\\r\\n    mapping(address =\\u003e uint256) public tokensMintedToReferrals;\\r\\n    mapping(uint256 =\\u003e Inflation) public dailyInflations;\\r\\n    mapping(address =\\u003e uint256) public totalStakedByAccounts;\\r\\n    \\r\\n    \\r\\n    uint8 public PoolRatioPos = 0;\\r\\n    PoolRatio[] public LastSampledPoolRatios;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to clone an origin stake into destination stake. It used on stake related operations: move, split and merge stake.\\r\\n     */\\r\\n    function _cloneStake(Stake memory origin, Stake memory destination) internal pure {\\r\\n        destination.stakeId = origin.stakeId;\\r\\n        destination.stakeAmount = origin.stakeAmount;\\r\\n        destination.shares = origin.shares;\\r\\n        destination.stakeState = origin.stakeState;\\r\\n        destination.interestAmount = origin.interestAmount;\\r\\n        destination.stakeStartTokenDay = origin.stakeStartTokenDay;\\r\\n        destination.numDaysAccountedFor = origin.numDaysAccountedFor;\\r\\n        destination.accountingStartTokenDay = origin.accountingStartTokenDay;\\r\\n        destination.accountingStartDayOfYear = origin.accountingStartDayOfYear;\\r\\n        destination.accountingStartTokenYear = origin.accountingStartTokenYear;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function that returns the default token to busd ratio.\\r\\n     * This function exists mainly to be used by the auctions contract.\\r\\n     */\\r\\n    function getDefaultTokenBusdRatio() external pure returns(uint256){\\r\\n        return DEFAULT_TOKEN_BUSD_RATIO;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all functions related to interest and inflation calculation.\\r\\n */\\r\\nabstract contract Interest is Data {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev Public function that calculates the penalties for ending a stake at a given year of the token existance, and at the specific day of the year.\\r\\n     * First day of the year has highest penalty. Last day before harvest season has lowest penalty. Harvest season has no penalty.\\r\\n     * First two years have the penalty reduced in 75% and 25%, respectively.\\r\\n     * Returns the fraction that can be multiplied with the principal, to obtain the penalty amount that should be subtracted from the principal.\\r\\n     */\\r\\n     function calculatePenaltyForEndingStakesAtDayOfYear(uint256 tokenYear, uint256 dayOfYear) public pure returns (uint256 numerator, uint256 denominator) {\\r\\n        //if we are in harvest there are no penalties thus return 0/1\\r\\n        if(!endingStakesHasPenaltiesForDay(dayOfYear)) return (0,1);\\r\\n        \\r\\n        \\r\\n        uint256 totalPeriodSize = SEASON_SIZE * 3;\\r\\n        \\r\\n        uint256 firstDayOfYear = 1;\\r\\n        uint256 numDaysElapsedFromYearStart = dayOfYear - firstDayOfYear; //lowest value will be 0\\r\\n        uint256 numDaysRemainingForHarvest = totalPeriodSize - numDaysElapsedFromYearStart;\\r\\n        \\r\\n        //year 1 = 1/4 (75% reduction); year two = 3/4 (25% reduction); onwards = 1/1 (no reduction)\\r\\n        uint256 penaltyReductorNumerator = tokenYear == 2 ? 3 : 1;\\r\\n        uint256 penaltyReductorDenominator = tokenYear \\u003c 3 ? 4 : 1;\\r\\n        \\r\\n        //ajusts the number of days hence decreasing the penalty if it\\u0027s the case\\r\\n        //this division never results in a division by zero\\r\\n        uint256 numDaysAdjusted = numDaysRemainingForHarvest.mul(penaltyReductorNumerator).div(penaltyReductorDenominator);\\r\\n        \\r\\n        return (numDaysAdjusted, totalPeriodSize);\\r\\n    }\\r\\n     \\r\\n    /**\\r\\n     * @dev Public function that calculates the principal and interest for a stake that is going to be closed, or is being closed (stakes that are in accounting state)\\r\\n     * The numDaysToAccountFor allows for the calculation of the principal and interest up to a given number of days.\\r\\n     * This is useful for when \\\"ending a stake slowly\\\" to make sure very old stakes can also be ended, by accounting their principal and interest\\r\\n     * in multiple subsequent transactions until all days have been accounted for.\\r\\n     */\\r\\n    function calculatePrincipalAndInterestIfClosingStakeToday(address addr, bytes16 stakeId, uint256 numDaysToAccountFor) public view returns(uint256 principal, uint256 interest) {\\r\\n        Stake storage stake = stakes[addr][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Address does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active || stake.stakeState == StakeState.InAccounting, \\\"Stake is not active nor in accounting\\\");\\r\\n        \\r\\n        uint256 accountStakeUntilDayOfYear = stake.stakeState == StakeState.InAccounting ? stake.accountingStartDayOfYear : CurrentDayOfYear;\\r\\n        uint256 accountStakeUntilTokenYear = stake.stakeState == StakeState.InAccounting ? stake.accountingStartTokenYear : CurrentTokenYear;\\r\\n        \\r\\n        (principal, interest) = getPrincipalAndInterestForStake(addr, stakeId, numDaysToAccountFor);\\r\\n\\r\\n        //if the stake is being ended on the same token day it was created, there are no penalties\\r\\n        if(stake.stakeStartTokenDay == CurrentTokenDay) {\\r\\n            return (stake.stakeAmount, stake.interestAmount);\\r\\n        }\\r\\n\\r\\n        //outside harvest there are penalties for ending stakes. \\r\\n        if(endingStakesHasPenaltiesForDay(accountStakeUntilDayOfYear)) {\\r\\n            //penalize principal corresponding to how many days are left until last day before harvest\\r\\n            \\r\\n            (uint256 numerator, uint256 denominator) = calculatePenaltyForEndingStakesAtDayOfYear(accountStakeUntilTokenYear, accountStakeUntilDayOfYear);\\r\\n            \\r\\n            //remove from the principal the quantity represented by the fraction of penalty to apply\\r\\n            //the denominator applied as a divisor is a constant in the function that returned it, therefore this divisision never results in a division by zero\\r\\n            principal = principal.sub(principal.mul(numerator).div(denominator));\\r\\n        }\\r\\n        \\r\\n        return (principal, interest);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function that calculates the principal and accrued interest for a stake for a given number of elapsed days, without considering any penalties for ending the stake early.\\r\\n     */\\r\\n    function getPrincipalAndInterestForStake(address addr, bytes16 stakeId, uint256 numDaysToAccountFor) public view returns (uint256 principal, uint256 interest) {\\r\\n        Stake storage stake = stakes[addr][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Address does not contain stake with provided id\\\");\\r\\n\\r\\n        interest = stake.interestAmount;\\r\\n        principal = stake.stakeAmount;\\r\\n        \\r\\n        if(stake.stakeState == StakeState.Closed || stake.stakeState == StakeState.Moved || stake.stakeState == StakeState.Merged) return (principal, interest);\\r\\n        \\r\\n        //if the stake is in accounting use the start accounting date otherwise the stake is still active\\r\\n        uint256 accountStakeUntilTokenDay = stake.stakeState == StakeState.InAccounting ? stake.accountingStartTokenDay : CurrentTokenDay;\\r\\n\\r\\n        //go through all days up to the day before the accountStakeUntilTokenDay\\r\\n        for(uint256 i = stake.stakeStartTokenDay + stake.numDaysAccountedFor; i \\u003c accountStakeUntilTokenDay; i++) {\\r\\n            //solidity doesn\\u0027t support multivariable fors\\r\\n            if(numDaysToAccountFor == 0) break;\\r\\n            \\r\\n            interest = interest.add(\\r\\n                //each stakes earns as interest a fraction of the global token inflation according to its share ratio\\r\\n                    dailyInflations[i].totalSupply.add(dailyInflations[i].tokensStakedAccounting)\\r\\n                    .mul(dailyInflations[i].numerator)\\r\\n                    //multiply by fraction of stake shares to total shares\\r\\n                    .mul(stake.shares)\\r\\n                    .div(dailyInflations[i].denominator)\\r\\n                    //since a stake to exist needs to have shares (this is a require on create stake) and that is accounted for in SharesAccounting\\r\\n                    //and since the totalShares of a dailyInflation has the day value of SharesAccounting\\r\\n                    //therefore this division will never result in a division by zero\\r\\n                    .div(dailyInflations[i].totalShares));\\r\\n            \\r\\n            //solidity doesn\\u0027t support multivariable fors\\r\\n            numDaysToAccountFor--;\\r\\n        }\\r\\n\\r\\n        return (principal, interest);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Public function that obtains the current global inflation rate.\\r\\n     */\\r\\n    function getTodaysGlobalInflationRate() public view returns (uint256 numerator, uint256 denominator) {\\r\\n        return calculateGlobalInflationRateForTokenYearAndDayOfYear(CurrentTokenYear, CurrentDayOfYear);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function that calculates the global inflation rate for a given day. Inflation is expressed as interest for all active stakes according to their individual share size.\\r\\n     * Returns a fraction that expresses the percentage of inflation for the given day.\\r\\n     */\\r\\n    function calculateGlobalInflationRateForTokenYearAndDayOfYear(uint256 tokenYear, uint256 dayOfYear) public pure returns (uint256 numerator, uint256 denominator) {\\r\\n        \\r\\n        //During harvest season minimum interest is generated\\r\\n        if (!canInterestBeGeneratedForDay(dayOfYear)) {\\r\\n            return (146520, 1000000000);\\r\\n        }\\r\\n        \\r\\n        //Since inflation changes every season for the first 6 years, this implementation was used to avoid a long if/else chain\\r\\n        uint32[19] memory numerators = [uint32(18315018), 14652015,10989011,7326007,3663004,3296703,2930403,2564103,2197802,1831502,1465201,1098901,732601,366300,329670,293040,256410,219780,146520];\\r\\n        uint8 index = _getSeasonForDay(dayOfYear) == Season.Winter ? 1 : _getSeasonForDay(dayOfYear) == Season.Spring ? 2 : 3;\\r\\n        uint8 posCalc = uint8((tokenYear-1)*3 + index);\\r\\n        uint8 pos = posCalc \\u003c 19 ? posCalc : 19;\\r\\n        return (numerators[pos-1], 1000000000);\\r\\n        \\r\\n        \\r\\n        /*Here is listed all planned daily percentual inflations for the first six years\\r\\n        \\r\\n        year one    - winter --- 500% interest  - 5/273     = 0.018315018 = (18315018, 1000000000)\\r\\n        year one    - spring --- 400% interest  - 4/273     = 0.014652015 = (14652015, 1000000000)\\r\\n        year one    - summer --- 300% interest  - 3/273     = 0.010989011 = (10989011, 1000000000)\\r\\n        \\r\\n        year two    - winter --- 200% interest  - 2/273     = 0.007326007 = (7326007, 1000000000)\\r\\n        year two    - spring --- 100% interest  - 1/273     = 0.003663004 = (3663004, 1000000000)\\r\\n        year two    - summer --- 90% interest   - 0.9/273   = 0.003296703 = (3296703, 1000000000)\\r\\n        \\r\\n        year three  - winter --- 80% interest   - 0.8/273   = 0.002930403 = (2930403, 1000000000)\\r\\n        year three  - spring --- 70% interest   - 0.7/273   = 0.002564103 = (2564103, 1000000000)\\r\\n        year three  - summer --- 60% interest   - 0.6/273   = 0.002197802 = (2197802, 1000000000)\\r\\n        \\r\\n        year four   - winter --- 50% interest   - 0.5/273   = 0.001831502 = (1831502, 1000000000)\\r\\n        year four   - spring --- 40% interest   - 0.4/273   = 0.001465201 = (1465201, 1000000000)\\r\\n        year four   - summer --- 30% interest   - 0.3/273   = 0.001098901 = (1098901, 1000000000)\\r\\n        \\r\\n        year five   - winter --- 20% interest   - 0.2/273   = 0.000732601 = (732601, 1000000000)\\r\\n        year five   - spring --- 10% interest   - 0.1/273   = 0.000366300 = (366300, 1000000000)\\r\\n        year five   - summer --- 9% interest    - 0.09/273  = 0.000329670 = (329670, 1000000000)\\r\\n        \\r\\n        year six    - winter --- 8% interest    - 0.08/273  = 0.000293040 = (293040, 1000000000)\\r\\n        year six    - spring --- 7% interest    - 0.07/273  = 0.000256410 = (256410, 1000000000)\\r\\n        year six    - summer --- 6% interest    - 0.06/273  = 0.000219780 = (219780, 1000000000)\\r\\n        \\r\\n        further years and seasons have 4% interest. 0.04/273 = 0.000146520 = (146520, 1000000000)\\r\\n        \\r\\n        */\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains helper functions\\r\\n */\\r\\nabstract contract Helper is Interest {\\r\\n    \\r\\n    function _toBytes16(uint256 x) internal pure returns (bytes16 b) {\\r\\n       return bytes16(bytes32(x));\\r\\n    }\\r\\n    \\r\\n    function generateID(address x, uint256 y, bytes1 z) internal pure returns (bytes16 b) {\\r\\n        b = _toBytes16(\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(x, y, z)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    function _notContract(address _addr) internal view returns (bool) {\\r\\n        uint32 size; assembly { size := extcodesize(_addr) } return (size == 0); }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all functions related to interacting with the EQNOX-BUSD pool\\r\\n */\\r\\nabstract contract PoolMgmt is Helper\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    IUniswapV2Pair public UNISWAP_PAIR;\\r\\n    IUniswapV2Router02 public UNISWAP_ROUTER;\\r\\n    address public FACTORY;\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to check if the EQNOX-BUSD pool has been created\\r\\n     */\\r\\n    function hasPoolBeenCreated() public view returns (bool) {\\r\\n        return IUniswapV2Factory(UNISWAP_ROUTER.factory()).getPair(address(this), address(BUSD_CONTRACT)) != address(0x0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function, accessible only by the auctions contract to create the EQNOX-BUSD pool\\r\\n     */\\r\\n    function createPool() external {\\r\\n        require(msg.sender == AUCTION_CONTRACT, \\\"Not authorized\\\");\\r\\n        if(!hasPoolBeenCreated()) {\\r\\n            _createPool();\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Private function to create the EQNOX-BUSD pool\\r\\n     */\\r\\n    function _createPool() private {\\r\\n        UNISWAP_PAIR = IUniswapV2Pair(IUniswapV2Factory(UNISWAP_ROUTER.factory()).createPair(address(this), address(BUSD_CONTRACT)));\\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @dev Public function for registering the current EQNOX-BUSD pool ratio.\\r\\n     * Can be called by an external benefactor\\r\\n     * Contains an array with samples of the pool ratio that can only be updated every X mins.\\r\\n     * It\\u0027s main purpose is to prevent manipulation of the pool ratio right before creating a stake.\\r\\n     */\\r\\n    function registerPoolRatio() public {\\r\\n        \\r\\n\\r\\n        //only register after the pool has been created, this happens when there are enough reserves to fill the pool\\r\\n        if(!hasPoolBeenCreated()) return;\\r\\n\\r\\n        uint256 tokenAmount;\\r\\n        uint256 busdAmount;\\r\\n        uint256 timestamp = _now();\\r\\n\\r\\n        if (LastSampledPoolRatios.length \\u003e 0) \\r\\n        {\\r\\n            PoolRatio storage lastSample = PoolRatioPos == 0 ? LastSampledPoolRatios[LastSampledPoolRatios.length - 1] : LastSampledPoolRatios[PoolRatioPos - 1];\\r\\n\\r\\n            //if the time of the timestamp is higher than the current time, do nothing\\r\\n            if (lastSample.timestamp \\u003e timestamp) return;\\r\\n\\r\\n            //don\\u0027t allow samples that are less than 3 minutes apart\\r\\n            if(diffMinutes(lastSample.timestamp, timestamp) \\u003c 3) return;\\r\\n        }\\r\\n        \\r\\n        (uint256 reserveIn, uint256 reserveOut, ) = UNISWAP_PAIR.getReserves(); // reserveIn SHOULD be TOKEN, may be BUSD\\r\\n        \\r\\n        if(UNISWAP_PAIR.token0() == address(this)) {\\r\\n            tokenAmount = reserveIn;\\r\\n            busdAmount = reserveOut;\\r\\n        }\\r\\n        else {\\r\\n            tokenAmount = reserveOut;\\r\\n            busdAmount = reserveIn;\\r\\n        }\\r\\n        \\r\\n        PoolRatio memory newPoolRatio = PoolRatio(tokenAmount, busdAmount, timestamp);\\r\\n        \\r\\n        //has at best an average of the last 15 minutes\\r\\n        uint256 maxSize = 5;\\r\\n        \\r\\n        //while the array isn\\u0027t filled, fill it\\r\\n        if(LastSampledPoolRatios.length \\u003c maxSize) {\\r\\n            LastSampledPoolRatios.push(newPoolRatio);\\r\\n        }\\r\\n        //after the array has been filled, use the PoolRatioPos to write on top of it and a round-robin approach\\r\\n        else {\\r\\n            LastSampledPoolRatios[PoolRatioPos] = newPoolRatio;\\r\\n            PoolRatioPos++;\\r\\n            if(PoolRatioPos \\u003e= maxSize) PoolRatioPos = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function that calculates the current average of sampled pool ratios\\r\\n     */\\r\\n    function getPoolAvg() public view returns (uint256, uint256) {\\r\\n        \\r\\n        //if pool is empty return the default ratio\\r\\n        if (LastSampledPoolRatios.length == 0) return (DEFAULT_TOKEN_BUSD_RATIO, 1);\\r\\n        uint256 poolTokenAvg;\\r\\n        uint256 poolBusdAvg;\\r\\n\\r\\n        for(uint256 i = 0; i \\u003c LastSampledPoolRatios.length; i++) {\\r\\n            poolTokenAvg = poolTokenAvg.add(LastSampledPoolRatios[i].amountToken);\\r\\n            poolBusdAvg = poolBusdAvg.add(LastSampledPoolRatios[i].amountBusd);\\r\\n        }\\r\\n\\r\\n        //since the length of the array is checked above for zero, these divisions will never result in a division by zero\\r\\n        poolTokenAvg = poolTokenAvg.div(LastSampledPoolRatios.length);\\r\\n        poolBusdAvg = poolBusdAvg.div(LastSampledPoolRatios.length);\\r\\n        \\r\\n        //if for some reason the poolBusdAvg is 0 \\r\\n        //meaning much more EQNOX than BUSD, so EQNOX is cheap\\r\\n        //return the default ratio\\r\\n        if(poolBusdAvg == 0) return (DEFAULT_TOKEN_BUSD_RATIO, 1);\\r\\n\\r\\n\\r\\n        //if for some reason the poolTokenAvg is 0\\r\\n        //meaning much more BUSD than EQNOX, so EQNOX is expensive\\r\\n        //return the default ratio inverted\\r\\n        if(poolTokenAvg == 0) return (1, DEFAULT_TOKEN_BUSD_RATIO);\\r\\n\\r\\n        return (poolTokenAvg, poolBusdAvg);\\r\\n    }\\r\\n    \\r\\n    /** \\r\\n    * @dev Public function to fill the liquidity pool of EQNOX-BUSD if possible\\r\\n    */\\r\\n    function fillLiquidityPool() public {\\r\\n        (uint256 poolTokenAvg, uint256 poolBusdAvg) = getPoolAvg();\\r\\n        _fillLiquidityPool(poolTokenAvg, poolBusdAvg);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to fill the liquidity EQNOX-BUSD pool when enough busd has been gathered.\\r\\n     */\\r\\n    function _fillLiquidityPool(uint256 poolTokenAvg, uint256 poolBusdAvg) internal {\\r\\n        \\r\\n        uint256 tokenAmount;\\r\\n        uint256 busdAmount = BUSD_CONTRACT.balanceOf(address(this));\\r\\n        \\r\\n        if(busdAmount \\u003c 1E18) return;\\r\\n        \\r\\n        if(!hasPoolBeenCreated()) {\\r\\n            _createPool();\\r\\n            \\r\\n            //Set initial ratio for EQNOX to busd\\r\\n            tokenAmount = busdAmount.mul(DEFAULT_TOKEN_BUSD_RATIO);\\r\\n        }\\r\\n        else {\\r\\n            //since this function is only called by fillLiquidityPool, and since the poolBusdAvg parameter is retrieved from getPoolAvg\\r\\n            //and since that function makes sure that poolBusdAvg is never zero, this division never results in a division by zero\\r\\n            tokenAmount = busdAmount.mul(poolTokenAvg).div(poolBusdAvg);\\r\\n        }\\r\\n        \\r\\n        //the contract may have some remaining EQNOX tokens that it wasn\\u0027t able to transfer to the pool\\r\\n        uint256 heldTokens = BEP20Token(address(this)).balanceOf(address(this));\\r\\n        \\r\\n        //if the quantity of held tokens is inferior to what needs to be minted, mint the difference\\r\\n        if(heldTokens \\u003c tokenAmount) {\\r\\n            //mint the tokens for the pool\\r\\n            _mint(address(this), tokenAmount.sub(heldTokens));    \\r\\n        }\\r\\n        //otherwise, the contract holds enough EQNOX to fill the pool at the current rate\\r\\n\\r\\n        _approve(address(this), address(UNISWAP_ROUTER), tokenAmount);\\r\\n        BUSD_CONTRACT.approve(address(UNISWAP_ROUTER), busdAmount);\\r\\n        \\r\\n        UNISWAP_ROUTER.addLiquidity(\\r\\n            address(this),\\r\\n            address(BUSD_CONTRACT),\\r\\n            tokenAmount,\\r\\n            busdAmount,\\r\\n            0,\\r\\n            0,\\r\\n            address(0x0), //burn liquidity tokens\\r\\n            _now().add(2 hours)\\r\\n        );\\r\\n\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all functions related to updating the current EQNOX day.\\r\\n */\\r\\nabstract contract DayMgmt is PoolMgmt\\r\\n{\\r\\n    \\r\\n    /**\\r\\n     * @dev Private function to register the daily inflation and existing shares right before updating the day to the next day.\\r\\n     */\\r\\n    function _registerTodaysInflation(uint256 tokenDay, uint256 tokenYear, uint256 dayOfYear) private {\\r\\n        (uint256 numerator, uint256 denominator) = calculateGlobalInflationRateForTokenYearAndDayOfYear(tokenYear, dayOfYear);\\r\\n        Inflation memory newInflation;\\r\\n        newInflation.numerator = numerator;\\r\\n        newInflation.denominator = denominator;\\r\\n        newInflation.totalShares = SharesAccounting;\\r\\n        newInflation.totalSupply = totalSupply();\\r\\n        newInflation.tokensStakedAccounting = TokensStakedAccounting;\\r\\n        dailyInflations[tokenDay] = newInflation;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    modifier updateDayTrigger() {\\r\\n        _updateDay();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * External function that allows anyone to trigger the update day (and as such paying the transaction fees)\\r\\n     */\\r\\n    function updateDay() external {\\r\\n        _updateDay();\\r\\n    }\\r\\n\\r\\n    \\r\\n    \\r\\n    /**\\r\\n     * @dev Private function to update the current EQNOX day. Is mainly responsible for registering the daily inflation and current existing shares,\\r\\n     * and also to update four global variables: \\r\\n     * CurrentDayOfYear (the current calendar day of the year).\\r\\n     * CurrentYear (the current calendar year)\\r\\n     * CurrentTokenDay (the current number of elapsed days since the start of EQNOX)\\r\\n     * CurrentTokenYear (the current number of elapsed years since the start of EQNOX)\\r\\n     */\\r\\n    function _updateDay() private {\\r\\n\\r\\n        uint256 _NOW = _now();\\r\\n        uint256 checkedDay =  _getDayOfYear(_NOW);\\r\\n        uint256 checkedYear = _getYear(_NOW);\\r\\n\\r\\n        //year is before current year, nothing to do\\r\\n        if (checkedYear \\u003c CurrentYear) return;\\r\\n\\r\\n        //day is before or equal to current day, nothing to do\\r\\n        if (checkedDay \\u003c= CurrentDayOfYear \\u0026\\u0026 checkedYear == CurrentYear) return;\\r\\n        //if we reached here means that either the checked day is bigger than the current day or the checked year is bigger than the current year\\r\\n\\r\\n        //checks if at least one full day has ellapsed since the last update\\r\\n        if(diffDays(\\r\\n            _addDays(TokenStartTimestamp, CurrentTokenDay-1),\\r\\n            _NOW\\r\\n            ) == 0) return;\\r\\n\\r\\n        //if the update day isn\\u0027t called every day, the day will ajust according to midnight UTC instead of the token hour\\r\\n        //this will make the next token day last longer\\r\\n\\r\\n        //try to register the pool ratio\\r\\n        registerPoolRatio();\\r\\n\\r\\n        //if one or more days have passed but still same year\\r\\n        if (checkedDay \\u003e CurrentDayOfYear \\u0026\\u0026 checkedYear == CurrentYear)\\r\\n        {\\r\\n            //for each day update current days\\r\\n            while (CurrentDayOfYear \\u003c checkedDay)\\r\\n            {\\r\\n                _registerTodaysInflation(CurrentTokenDay, CurrentTokenYear, CurrentDayOfYear);\\r\\n                CurrentDayOfYear++;\\r\\n                CurrentTokenDay++;\\r\\n                \\r\\n                emit dayUpdated(CurrentYear, CurrentDayOfYear, CurrentTokenDay, CurrentTokenYear);\\r\\n            }\\r\\n\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (checkedYear \\u003e CurrentYear)\\r\\n        {\\r\\n            //first, update current days until the end of the year\\r\\n            uint256 numDays = isLeapYear(CurrentYear) ? 366 : 365;\\r\\n            while (CurrentDayOfYear \\u003c numDays)\\r\\n            {\\r\\n                _registerTodaysInflation(CurrentTokenDay, CurrentTokenYear, CurrentDayOfYear);\\r\\n                CurrentDayOfYear++;\\r\\n                CurrentTokenDay++;\\r\\n                \\r\\n                emit dayUpdated(CurrentYear, CurrentDayOfYear, CurrentTokenDay, CurrentTokenYear);\\r\\n            }\\r\\n\\r\\n            //update to day 1 of next year\\r\\n            _registerTodaysInflation(CurrentTokenDay, CurrentTokenYear, CurrentDayOfYear);\\r\\n            CurrentDayOfYear = 1;\\r\\n            CurrentTokenDay++;\\r\\n            CurrentYear++;\\r\\n            CurrentTokenYear++;\\r\\n\\r\\n            emit dayUpdated(CurrentYear, CurrentDayOfYear, CurrentTokenDay, CurrentTokenYear);\\r\\n\\r\\n            //while you are not on the same year\\r\\n            while (CurrentYear \\u003c checkedYear)\\r\\n            {\\r\\n                numDays = isLeapYear(CurrentYear) ? 366 : 365;\\r\\n                while (CurrentDayOfYear \\u003c numDays)\\r\\n                {\\r\\n                    _registerTodaysInflation(CurrentTokenDay, CurrentTokenYear, CurrentDayOfYear);\\r\\n                    CurrentDayOfYear++;\\r\\n                    CurrentTokenDay++;\\r\\n                    \\r\\n                    emit dayUpdated(CurrentYear, CurrentDayOfYear, CurrentTokenDay, CurrentTokenYear);\\r\\n                }\\r\\n\\r\\n                //update to day 1 of next year\\r\\n                _registerTodaysInflation(CurrentTokenDay, CurrentTokenYear, CurrentDayOfYear);\\r\\n                CurrentDayOfYear = 1;\\r\\n                CurrentTokenDay++;\\r\\n                CurrentYear++;\\r\\n                CurrentTokenYear++;\\r\\n                \\r\\n                emit dayUpdated(CurrentYear, CurrentDayOfYear, CurrentTokenDay, CurrentTokenYear);\\r\\n            }\\r\\n\\r\\n            //here we\\u0027ve reached the current year\\r\\n            //therefore update the current days until checked day\\r\\n            while (CurrentDayOfYear \\u003c checkedDay)\\r\\n            {\\r\\n                _registerTodaysInflation(CurrentTokenDay, CurrentTokenYear, CurrentDayOfYear);\\r\\n                CurrentDayOfYear++;\\r\\n                CurrentTokenDay++;\\r\\n                \\r\\n                emit dayUpdated(CurrentYear, CurrentDayOfYear, CurrentTokenDay, CurrentTokenYear);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all functions related to the management of stakes\\r\\n */\\r\\nabstract contract StakeMgmt is DayMgmt\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev External function to create a stake.\\r\\n     * The user has to provide the amount of EQNOX he wants to stake.\\r\\n     */\\r\\n    function createStake(uint256 amountToStake) updateDayTrigger external {\\r\\n        require(amountToStake \\u003e 100000, \\\"Cannot stake less than 100000 millis\\\");\\r\\n        \\r\\n        \\r\\n        require(BEP20Token(address(this)).balanceOf(msg.sender) \\u003e= amountToStake, \\\"Account does not have enough tokens\\\");\\r\\n        \\r\\n        //the CurrentSharePrice only increases therefore it will never be 0\\r\\n        uint256 newStakeShares = amountToStake.mul(SHARE_PRICE_PRECISION).div(CurrentSharePrice);\\r\\n        require(newStakeShares \\u003e 0, \\\"Staked amount is not enough to buy shares\\\");\\r\\n        \\r\\n        //burn stake amount\\r\\n        _burn(msg.sender, amountToStake);\\r\\n        //increase the number of tokens staked\\r\\n        TokensStakedAccounting = TokensStakedAccounting.add(amountToStake);\\r\\n        totalStakedByAccounts[msg.sender] = totalStakedByAccounts[msg.sender].add(amountToStake);\\r\\n                \\r\\n        //try to register the pool ratio\\r\\n        registerPoolRatio();\\r\\n        \\r\\n        //create the stake\\r\\n        Stake memory newStake;\\r\\n        \\r\\n        newStake.stakeId = generateID(msg.sender, stakeCount[msg.sender], 0x01);\\r\\n        newStake.stakeAmount = amountToStake;\\r\\n        newStake.shares = newStakeShares;\\r\\n        newStake.stakeState = StakeState.Active;\\r\\n        \\r\\n        newStake.stakeStartTokenDay = CurrentTokenDay;\\r\\n        \\r\\n        stakes[msg.sender][newStake.stakeId] = newStake;\\r\\n        stakeCount[msg.sender] = stakeCount[msg.sender] + 1;\\r\\n        ActiveStakesAccounting = ActiveStakesAccounting + 1;\\r\\n        \\r\\n        \\r\\n        //increase total shares\\r\\n        SharesAccounting = SharesAccounting.add(newStakeShares);\\r\\n        emit stakeCreated(newStake.stakeId, msg.sender, newStake.stakeAmount, newStake.stakeStartTokenDay);\\r\\n        \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function to end a stake. Applies the penalties (if any) on the principal, calculates the accrued interest, and mints back to the user both principal and interest.\\r\\n     */\\r\\n    function endStake(bytes16 stakeId) updateDayTrigger external {\\r\\n        \\r\\n        require(stakeCount[msg.sender] \\u003e 0, \\\"Sender does not contain stakes\\\");\\r\\n\\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active || stake.stakeState == StakeState.InAccounting, \\\"Stake is not active nor in accounting\\\");\\r\\n        \\r\\n        uint256 accountUntilTokenDay = stake.stakeState == StakeState.InAccounting ? stake.accountingStartTokenDay : CurrentTokenDay;\\r\\n        \\r\\n        uint256 numDaysToAccountFor = accountUntilTokenDay.sub(stake.stakeStartTokenDay.add(stake.numDaysAccountedFor));\\r\\n        \\r\\n        (uint256 principal, uint256 interest) = calculatePrincipalAndInterestIfClosingStakeToday(msg.sender, stakeId, numDaysToAccountFor);\\r\\n        \\r\\n        stake.interestAmount = interest;\\r\\n        stake.stakeState = StakeState.Closed;\\r\\n        \\r\\n        stake.numDaysAccountedFor = stake.numDaysAccountedFor + numDaysToAccountFor;\\r\\n        stake.accountingStartTokenDay = CurrentTokenDay;\\r\\n        stake.accountingStartDayOfYear = CurrentDayOfYear;\\r\\n        stake.accountingStartTokenYear = CurrentTokenYear;\\r\\n\\r\\n        uint256 tokensToMint = principal.add(interest);\\r\\n       \\r\\n        //decrease the number of tokens staked\\r\\n        TokensStakedAccounting = TokensStakedAccounting.sub(stake.stakeAmount);\\r\\n        totalStakedByAccounts[msg.sender] = totalStakedByAccounts[msg.sender].sub(stake.stakeAmount);\\r\\n\\r\\n        //decrease total shares\\r\\n        SharesAccounting = SharesAccounting.sub(stake.shares);\\r\\n        \\r\\n        //decrease total active stakes\\r\\n        ActiveStakesAccounting = ActiveStakesAccounting - 1;\\r\\n        \\r\\n         //mint back principal (with possible penalties) plus accrued interest\\r\\n        _mint(msg.sender, tokensToMint);\\r\\n        \\r\\n        _updateSharePrice(stakeId, stake.numDaysAccountedFor, stake.stakeAmount, stake.shares, tokensToMint);\\r\\n        \\r\\n        emit stakeEnded(stakeId, msg.sender, tokensToMint, CurrentTokenDay);\\r\\n        \\r\\n        //try to register the pool ratio\\r\\n        registerPoolRatio();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function to move a stake.\\r\\n     * Marks the provided stake as moved, and creates a new stake equal to the moved one for the receiver address.\\r\\n     * No new shares are generated from this operations.\\r\\n     * The stake marked as moved has all it\\u0027s accounting closed.\\r\\n     */\\r\\n    function moveStake(bytes16 stakeId, address toAddress) updateDayTrigger external {\\r\\n        require(toAddress != msg.sender, \\u0027Sender and receiver cannot be the same\\u0027);\\r\\n\\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active, \\\"Stake can only be moved if it is active\\\");\\r\\n        \\r\\n        Stake memory newStake;\\r\\n\\r\\n        _cloneStake(stake, newStake);\\r\\n        \\r\\n        //mark the old stake as moved\\r\\n        stake.stakeState = StakeState.Moved;\\r\\n        stake.numDaysAccountedFor = CurrentTokenDay.sub(stake.stakeStartTokenDay);\\r\\n        stake.accountingStartTokenDay = CurrentTokenDay;\\r\\n        stake.accountingStartDayOfYear = CurrentDayOfYear;\\r\\n        stake.accountingStartTokenYear = CurrentTokenYear;\\r\\n        \\r\\n        //save the new stake for the new staker (toAddress)\\r\\n        bytes16 newReceiverStakeID = generateID(toAddress, stakeCount[toAddress], 0x01);\\r\\n        newStake.stakeId = newReceiverStakeID;\\r\\n        stakes[toAddress][newReceiverStakeID] = newStake;\\r\\n        stakeCount[toAddress] = stakeCount[toAddress] + 1;\\r\\n\\r\\n        //update accounting of total staked\\r\\n        totalStakedByAccounts[msg.sender] = totalStakedByAccounts[msg.sender].sub(stake.stakeAmount);\\r\\n        totalStakedByAccounts[toAddress] = totalStakedByAccounts[toAddress].add(stake.stakeAmount);\\r\\n \\r\\n        emit stakeMoved(stakeId, newReceiverStakeID, msg.sender, toAddress, CurrentTokenDay);\\r\\n        \\r\\n        //try to register the pool ratio\\r\\n        registerPoolRatio();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function to split a stake.\\r\\n     * Creates a new stake and has the principal, interest, and shares, of the current stake and new stake split according to the split divisor.\\r\\n     * A split divisor of 2 is a split in 50% of the current stake, and a split divisor of 10000 is a split of 0.01% of the current stake.\\r\\n     * The new stake has all the remaining data equal to the current stake.\\r\\n     */\\r\\n    function splitStake(bytes16 stakeId, uint256 splitDivisor) updateDayTrigger external {\\r\\n        \\r\\n        require(splitDivisor \\u003e= 2 \\u0026\\u0026 splitDivisor \\u003c= 10000, \\\"Divisor must be between 2 and 10000\\\");\\r\\n        \\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active, \\\"Stake can only be split if it is active\\\");\\r\\n     \\r\\n        Stake memory newStake;\\r\\n        _cloneStake(stake, newStake);\\r\\n        \\r\\n        newStake.stakeId = generateID(msg.sender, stakeCount[msg.sender], 0x01);\\r\\n        \\r\\n        //update the new stake principal applying the divisor\\r\\n        //the splitDivisor can never be 0 as required by the function\\r\\n        newStake.stakeAmount = newStake.stakeAmount.div(splitDivisor);\\r\\n        require(newStake.stakeAmount \\u003e 0, \\\"Split cancelled, the new stake would have 0 principal\\\");\\r\\n        //update the current stake principal by subtracting the one applied to the new stake\\r\\n        stake.stakeAmount = stake.stakeAmount \\u003e= newStake.stakeAmount ? stake.stakeAmount.sub(newStake.stakeAmount) : 0;\\r\\n        require(stake.stakeAmount \\u003e 0, \\\"Split cancelled, the current stake would have 0 principal\\\");\\r\\n        \\r\\n        //do the same for shares\\r\\n        newStake.shares = newStake.shares.div(splitDivisor);\\r\\n        require(newStake.shares \\u003e 0, \\\"Split cancelled, the new stake would have 0 shares\\\");\\r\\n        stake.shares = stake.shares \\u003e= newStake.shares ? stake.shares.sub(newStake.shares) : 0;\\r\\n        require(stake.shares \\u003e 0, \\\"Split cancelled, the current stake would have 0 shares\\\");\\r\\n        \\r\\n        //do the same for interest\\r\\n        //since the interest is zero in storage until the stake is accounted for, the bigger than 0 requirements do not apply here\\r\\n        newStake.interestAmount = newStake.interestAmount.div(splitDivisor);\\r\\n        stake.interestAmount = stake.interestAmount \\u003e= newStake.interestAmount ? stake.interestAmount.sub(newStake.interestAmount) : 0;\\r\\n        \\r\\n        //save new stake\\r\\n        stakes[msg.sender][newStake.stakeId] = newStake;\\r\\n\\r\\n        //increment stake count\\r\\n        stakeCount[msg.sender] = stakeCount[msg.sender] + 1;\\r\\n        \\r\\n        //increase total active stakes\\r\\n        ActiveStakesAccounting = ActiveStakesAccounting + 1;\\r\\n\\r\\n        emit stakeSplit(stake.stakeId, newStake.stakeId, splitDivisor, msg.sender, CurrentTokenDay);\\r\\n        \\r\\n        //try to register the pool ratio\\r\\n        registerPoolRatio();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function to merge two stakes.\\r\\n     * Both stakes are marked as closed, and a new stake is created with the sum of the principal, accrued interest, and shares of both stakes.\\r\\n     */\\r\\n    function mergeStakes(bytes16 stakeId1, bytes16 stakeId2) updateDayTrigger external {\\r\\n        Stake storage stake1 = stakes[msg.sender][stakeId1];\\r\\n        Stake storage stake2 = stakes[msg.sender][stakeId2];\\r\\n        bool stakeFound1 = stake1.stakeId == stakeId1;\\r\\n        bool stakeFound2 = stake2.stakeId == stakeId2;\\r\\n        require(stakeFound1, \\\"Sender does not contain stake1 with provided id\\\");\\r\\n        require(stakeFound2, \\\"Sender does not contain stake2 with provided id\\\");\\r\\n        require(stake1.stakeState == StakeState.Active, \\\"Stakes can only be merged if they are active\\\");\\r\\n        require(stake2.stakeState == StakeState.Active, \\\"Stakes can only be merged if they are active\\\");\\r\\n        require(stakeId1 != stakeId2, \\\"You can\\u0027t merge a stake with itself\\\");\\r\\n        require(stake1.stakeStartTokenDay \\u003c CurrentTokenDay \\u0026\\u0026 stake2.stakeStartTokenDay \\u003c CurrentTokenDay, \\\"You can\\u0027t merge stakes with 0 days\\\");\\r\\n        \\r\\n        if(stake1.stakeStartTokenDay \\u003c= stake2.stakeStartTokenDay) {\\r\\n            _mergeStakes(msg.sender, stake1, stake2);\\r\\n        }\\r\\n        else {\\r\\n            _mergeStakes(msg.sender, stake2, stake1);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Private helper function to merge two stakes.\\r\\n     * Needs to receive the older and newer stakes, accordingly, to ajust the accrued interest from the older stake until the creation date from the newer stake.\\r\\n     */\\r\\n    function _mergeStakes(address owner, Stake storage olderStake, Stake storage newerStake) private {\\r\\n        //determine the difference of days - has to be \\u003e= 0\\r\\n        uint256 diff = newerStake.stakeStartTokenDay - olderStake.stakeStartTokenDay;\\r\\n        \\r\\n        //get all days of interest from older stake until the start of the newer stake\\r\\n        (uint256 principal, uint256 interest) = getPrincipalAndInterestForStake(owner, olderStake.stakeId, diff);\\r\\n        \\r\\n        //add principal, interest and shares from older stake to newer stake\\r\\n        newerStake.stakeAmount = newerStake.stakeAmount.add(principal);\\r\\n        newerStake.interestAmount = newerStake.interestAmount.add(interest);\\r\\n        newerStake.shares = newerStake.shares.add(olderStake.shares);\\r\\n        \\r\\n        //end old stake\\r\\n        olderStake.stakeState = StakeState.Merged;\\r\\n        //store the interest calculated up until the start of the newer stake\\r\\n        olderStake.interestAmount = interest;\\r\\n        //store the number of days accounted for until the start of the newer stake\\r\\n        olderStake.numDaysAccountedFor = diff;\\r\\n        olderStake.accountingStartTokenDay = CurrentTokenDay;\\r\\n        olderStake.accountingStartDayOfYear = CurrentDayOfYear;\\r\\n        olderStake.accountingStartTokenYear = CurrentTokenYear;\\r\\n\\r\\n        //decrease total active stakes\\r\\n        ActiveStakesAccounting = ActiveStakesAccounting - 1;\\r\\n        \\r\\n        emit stakesMerged(olderStake.stakeId, newerStake.stakeId, owner, CurrentTokenDay);\\r\\n        \\r\\n        //try to register the pool ratio\\r\\n        registerPoolRatio();\\r\\n        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to start or continue the accounting of a stake.\\r\\n     * This function is used to end very long stakes. It ensures stakes can always be ended because this way it is not required to fit all accounting into one block only.\\r\\n     * Accounting can be done slowly, through multiple transactions.\\r\\n     */\\r\\n    function startOrContinueStakeAccounting(bytes16 stakeId, uint256 numDays) updateDayTrigger external {\\r\\n        require(stakeCount[msg.sender] \\u003e 0, \\\"Sender does not contain stakes\\\");\\r\\n\\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active || stake.stakeState == StakeState.InAccounting, \\\"Stake is not active nor in accounting\\\");\\r\\n        \\r\\n        //if the stake is active\\r\\n        if(stake.stakeState == StakeState.Active) {\\r\\n            //when accounting starts it\\u0027s like closing the stake but slowly\\r\\n            \\r\\n            // mark it for accounting\\r\\n            stake.stakeState = StakeState.InAccounting;\\r\\n            stake.accountingStartTokenDay = CurrentTokenDay;\\r\\n            stake.accountingStartDayOfYear = CurrentDayOfYear;\\r\\n            stake.accountingStartTokenYear = CurrentTokenYear;\\r\\n        }\\r\\n        \\r\\n        uint256 stakeDuration = stake.accountingStartTokenDay.sub(stake.stakeStartTokenDay);\\r\\n        uint256 numDaysToAccountStill = stakeDuration.sub(stake.numDaysAccountedFor);\\r\\n        \\r\\n        if(numDaysToAccountStill == 0) return;\\r\\n        \\r\\n        \\r\\n        //if the provided number of days exceeds the number of days to account still, account only until what\\u0027s needed\\r\\n        uint256 numDaysToAccountFor = numDays \\u003c= numDaysToAccountStill ? numDays : numDaysToAccountStill;\\r\\n        \\r\\n        (, uint256 interest) = getPrincipalAndInterestForStake(msg.sender, stakeId, numDaysToAccountFor);\\r\\n        \\r\\n        //update the stake interest\\r\\n        //this is an attribution and not an addition because the addition of the current stake interest plus the accrued interest for numDaysToAccountFor\\r\\n        //has been calculated inside the getPrincipalAndInterestForStake function\\r\\n        stake.interestAmount = interest;\\r\\n        \\r\\n        stake.numDaysAccountedFor = stake.numDaysAccountedFor.add(numDaysToAccountFor);\\r\\n        \\r\\n        //try to register the pool ratio\\r\\n        registerPoolRatio();\\r\\n        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to update the share price. Calculations are similar to the HEX model.\\r\\n     */\\r\\n    function _updateSharePrice(bytes16 stakeId, uint256 stakeDays, uint256 stakedAmount, uint256 stakeShares, uint256 stakeReturn) private {\\r\\n        if (stakeReturn \\u003e stakedAmount) {\\r\\n            \\r\\n\\r\\n            //we want to avoid very sharp share price increases\\r\\n            //this should happen only when there is much more unstaked tokens than staked tokens\\r\\n            //as such we should assume a maximum share price increase that is aligned with the average stake interest growth in normal situations\\r\\n            //let us therefore assume an average daily interest of 1% (this is a good aproximate for the first two years)\\r\\n            //as such, the average return a stake should have is stakedAmount + (0.01 x stakedAmount x stakeDays)\\r\\n            //let us then cap the max stake return to that\\r\\n            uint256 stakeReturnCap = stakedAmount + stakedAmount.mul(stakeDays).div(100);\\r\\n\\r\\n            if(stakeReturn \\u003e stakeReturnCap) {\\r\\n                stakeReturn = stakeReturnCap;\\r\\n            }\\r\\n\\r\\n\\r\\n            //since a stake needs to have a positive amount of shares this division is never by zero\\r\\n            uint256 newSharePrice = stakeReturn.mul(SHARE_PRICE_PRECISION).div(stakeShares);\\r\\n\\r\\n            if (newSharePrice \\u003e SHARE_PRICE_MAX) {\\r\\n\\r\\n                newSharePrice = SHARE_PRICE_MAX;\\r\\n            }\\r\\n\\r\\n            if (newSharePrice \\u003e CurrentSharePrice) {\\r\\n                CurrentSharePrice = newSharePrice;\\r\\n                emit sharePriceUpdated(stakeId, CurrentTokenDay, CurrentSharePrice);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function to provide pagination of stakes.\\r\\n     */\\r\\n    function stakesPagination(address account, uint256 offset, uint256 length) external view returns (Stake[] memory stakeList) {\\r\\n        if(offset \\u003e= stakeCount[account]) {\\r\\n            stakeList = new Stake[](0);\\r\\n            return stakeList;\\r\\n        }\\r\\n\\r\\n        if(offset + length \\u003e stakeCount[account]) {\\r\\n            length = (stakeCount[account]) - offset;\\r\\n        }\\r\\n\\r\\n        stakeList = new Stake[](length);\\r\\n        \\r\\n        uint256 end = offset + length;\\r\\n        \\r\\n        for(uint256 i = 0; offset \\u003c end; offset++) {\\r\\n            bytes16 stakeId = generateID(account, offset, 0x01);\\r\\n            stakeList[i] = stakes[account][stakeId];\\r\\n            i++;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function to provide pagination of daily registered inflations.\\r\\n     */\\r\\n    function inflationPagination(uint256 offset, uint256 length) external view returns (Inflation[] memory inflations) {\\r\\n        //if offset has exceeded the available elements return an empty array\\r\\n        if(offset \\u003e CurrentTokenDay - 1) {\\r\\n            inflations = new Inflation[](0);\\r\\n            return inflations;\\r\\n        }\\r\\n        \\r\\n        if(offset + length \\u003e CurrentTokenDay - 1) {\\r\\n            length = (CurrentTokenDay - 1) - offset;\\r\\n        }\\r\\n        \\r\\n        inflations = new Inflation[](length);\\r\\n        \\r\\n        uint256 end = offset + length;\\r\\n        \\r\\n        for(uint256 i = 0; offset \\u003c end; offset++) {\\r\\n            inflations[i] = dailyInflations[offset+1];\\r\\n            i++;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev EQNOX contract that inherits from all abstract contracts\\r\\n */\\r\\ncontract EQNOX is StakeMgmt {\\r\\n    \\r\\n    address public AUCTION_DEFINER;\\r\\n    address public CONVERTER_DEFINER;\\r\\n    address public TIME_DEFINER;\\r\\n    \\r\\n\\r\\n    modifier onlyAuctionDefiner() {\\r\\n        require(\\r\\n            msg.sender == AUCTION_DEFINER,\\r\\n            \\u0027Wrong sender.\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyConverterDefiner() {\\r\\n        require(\\r\\n            msg.sender == CONVERTER_DEFINER,\\r\\n            \\u0027Wrong sender.\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTimeDefiner() {\\r\\n        require(\\r\\n            msg.sender == TIME_DEFINER,\\r\\n            \\u0027Wrong sender.\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    receive() external payable { revert(); }\\r\\n    fallback() external payable { revert(); }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function accessible only by the token definer to set external addresses and contracts.\\r\\n     */\\r\\n    function setAuctionContract(address auctionContract) external onlyAuctionDefiner {\\r\\n        AUCTION_CONTRACT = auctionContract;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function accessible only by the token definer to set external addresses and contracts.\\r\\n     */\\r\\n    function setConverterContract(address converterContract) external onlyConverterDefiner {\\r\\n        CONVERTER_CONTRACT = converterContract;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function accessible only by the token definer to set the timestamp for the start of the EQNOX contract.\\r\\n     */\\r\\n    function startContract(uint256 timestamp) external onlyTimeDefiner {\\r\\n        \\r\\n        TokenStartTimestamp = timestamp; //value should be 1641056400\\r\\n        CurrentYear = _getYear(TokenStartTimestamp);\\r\\n        CurrentDayOfYear = _getDayOfYear(TokenStartTimestamp);\\r\\n        CurrentTokenDay = 1;\\r\\n        CurrentTokenYear = 1;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function accessible only by the auction definer to forever deny special access for the auction definer. This operation is irreversible.\\r\\n     */\\r\\n    function revokeAccess() external onlyAuctionDefiner {\\r\\n        AUCTION_DEFINER = address(0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function accessible only by the converter definer to forever deny special access for the converter definer. This operation is irreversible.\\r\\n     */\\r\\n    function revokeAccessToConverterDefiner() external onlyConverterDefiner {\\r\\n        CONVERTER_DEFINER = address(0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function accessible only by the time definer to forever deny special access for the time definer. This operation is irreversible.\\r\\n     */\\r\\n    function revokeAccessToTimeDefiner() external onlyTimeDefiner {\\r\\n        TIME_DEFINER = address(0x0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev EQNOX token contract constructor.\\r\\n     */\\r\\n    constructor() BEP20Token(\\\"Equinox\\\", \\\"EQNOX\\\") {\\r\\n        \\r\\n        CurrentSharePrice = INITIAL_SHARE_PRICE;\\r\\n        \\r\\n        AUCTION_DEFINER = msg.sender;\\r\\n        CONVERTER_DEFINER = msg.sender;\\r\\n        TIME_DEFINER = msg.sender;\\r\\n\\r\\n        BUSD_CONTRACT = IBEP20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\\r\\n        FACTORY = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\\r\\n        UNISWAP_ROUTER = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev External function to mint supply for the auction contract only.\\r\\n     */\\r\\n    function mintSupply(address addr, uint256 amount) external {\\r\\n        require(msg.sender == AUCTION_CONTRACT || msg.sender == CONVERTER_CONTRACT, \\\"Not authorized\\\");\\r\\n        _mint(addr, amount);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dayOfYear\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenYear\",\"type\":\"uint256\"}],\"name\":\"dayUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSharePrice\",\"type\":\"uint256\"}],\"name\":\"sharePriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeTokenDay\",\"type\":\"uint256\"}],\"name\":\"stakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stackerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"}],\"name\":\"stakeEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"newStakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"}],\"name\":\"stakeMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"newStakeId\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"splitDivisor\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"}],\"name\":\"stakeSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stake1Id\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stake2Id\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"}],\"name\":\"stakesMerged\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"AUCTION_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AUCTION_DEFINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ActiveStakesAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONVERTER_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONVERTER_DEFINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentDayOfYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentTokenDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentTokenYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LastSampledPoolRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBusd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PoolRatioPos\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SharesAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_DEFINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokensStakedAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_PAIR\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dayOfYear\",\"type\":\"uint256\"}],\"name\":\"calculateGlobalInflationRateForTokenYearAndDayOfYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dayOfYear\",\"type\":\"uint256\"}],\"name\":\"calculatePenaltyForEndingStakesAtDayOfYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"numDaysToAccountFor\",\"type\":\"uint256\"}],\"name\":\"calculatePrincipalAndInterestIfClosingStakeToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dayOfYear\",\"type\":\"uint256\"}],\"name\":\"canInterestBeGeneratedForDay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToStake\",\"type\":\"uint256\"}],\"name\":\"createStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyInflations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensStakedAccounting\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"}],\"name\":\"endStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dayOfYear\",\"type\":\"uint256\"}],\"name\":\"endingStakesHasPenaltiesForDay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fillLiquidityPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokenDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultTokenBusdRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolAvg\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"numDaysToAccountFor\",\"type\":\"uint256\"}],\"name\":\"getPrincipalAndInterestForStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTodaysGlobalInflationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasPoolBeenCreated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"inflationPagination\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensStakedAccounting\",\"type\":\"uint256\"}],\"internalType\":\"struct Data.Inflation[]\",\"name\":\"inflations\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId1\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"stakeId2\",\"type\":\"bytes16\"}],\"name\":\"mergeStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"moveStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerPoolRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeAccessToConverterDefiner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeAccessToTimeDefiner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auctionContract\",\"type\":\"address\"}],\"name\":\"setAuctionContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"converterContract\",\"type\":\"address\"}],\"name\":\"setConverterContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"splitDivisor\",\"type\":\"uint256\"}],\"name\":\"splitStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"enum Data.StakeState\",\"name\":\"stakeState\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeStartTokenDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numDaysAccountedFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountingStartTokenDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountingStartDayOfYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountingStartTokenYear\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"stakesPagination\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"enum Data.StakeState\",\"name\":\"stakeState\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeStartTokenDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numDaysAccountedFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountingStartTokenDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountingStartDayOfYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountingStartTokenYear\",\"type\":\"uint256\"}],\"internalType\":\"struct Data.Stake[]\",\"name\":\"stakeList\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"startContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"numDays\",\"type\":\"uint256\"}],\"name\":\"startOrContinueStakeAccounting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensMintedToReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalStakedByAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EQNOX", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c5a8050c80da8e800411382a95c80058875c9d3ade51173c920e57235cecfc7f"}