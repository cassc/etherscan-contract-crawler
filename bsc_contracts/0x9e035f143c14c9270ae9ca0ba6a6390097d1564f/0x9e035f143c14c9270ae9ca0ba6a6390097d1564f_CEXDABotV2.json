{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/common/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Errors {\\r\\n    /// Common error\\r\\n    string constant CM_CONTRACT_HAS_BEEN_INITIALIZED = \\\"CM-01\\\"; \\r\\n    string constant CM_FACTORY_ADDRESS_IS_NOT_CONFIGURED = \\\"CM-02\\\";\\r\\n    string constant CM_VICS_ADDRESS_IS_NOT_CONFIGURED = \\\"CM-03\\\";\\r\\n    string constant CM_VICS_EXCHANGE_IS_NOT_CONFIGURED = \\\"CM-04\\\";\\r\\n    string constant CM_CEX_FUND_MANAGER_IS_NOT_CONFIGURED = \\\"CM-05\\\";\\r\\n    string constant CM_TREASURY_MANAGER_IS_NOT_CONFIGURED = \\\"CM-06\\\";\\r\\n    string constant CM_CEX_DEFAULT_MASTER_ACCOUNT_IS_NOT_CONFIGURED = \\\"CM-07\\\";\\r\\n    string constant CM_ADDRESS_IS_NOT_ICEXDABOTCERTTOKEN = \\\"CM-08\\\";\\r\\n    \\r\\n\\r\\n    /// IBCertToken error  (Bot Certificate Token)\\r\\n    string constant BCT_CALLER_IS_NOT_OWNER = \\\"BCT-01\\\"; \\r\\n    string constant BCT_REQUIRE_ALL_TOKENS_BURNT = \\\"BCT-02\\\";\\r\\n    string constant BCT_UNLOCK_AMOUNT_EXCEEDS_TOTAL_LOCKED = \\\"BCT-03\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_UNLOCKING = \\\"BCT-04a\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_LOCKING = \\\"BCT-04b\\\";\\r\\n    string constant BCT_AMOUNT_EXCEEDS_TOTAL_STAKE = \\\"BCT-05\\\";\\r\\n    string constant BCT_CANNOT_MINT_TO_ZERO_ADDRESS = \\\"BCT-06\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_BURN = \\\"BCT-07\\\";\\r\\n    string constant BCT_INSUFFICIENT_ACCOUNT_FUND = \\\"BCT-08\\\";\\r\\n    string constant BCT_CALLER_IS_NEITHER_BOT_NOR_CERTLOCKER = \\\"BCT-09\\\";\\r\\n\\r\\n    /// IBCEXCertToken error (Cex Bot Certificate Token)\\r\\n    string constant CBCT_CALLER_IS_NOT_FUND_MANAGER = \\\"CBCT-01\\\";\\r\\n\\r\\n    /// GovernToken error (Bot Governance Token)\\r\\n    string constant BGT_CALLER_IS_NOT_OWNED_BOT = \\\"BGT-01\\\";\\r\\n    string constant BGT_CANNOT_MINT_TO_ZERO_ADDRESS = \\\"BGT-02\\\";\\r\\n    string constant BGT_CALLER_IS_NOT_GOVERNANCE = \\\"BGT-03\\\";\\r\\n\\r\\n    // VaultBase error (VB)\\r\\n    string constant VB_CALLER_IS_NOT_DABOT = \\\"VB-01a\\\";\\r\\n    string constant VB_CALLER_IS_NOT_OWNER_BOT = \\\"VB-01b\\\";\\r\\n    string constant VB_INVALID_VAULT_ID = \\\"VB-02\\\";\\r\\n    string constant VB_INVALID_VAULT_TYPE = \\\"VB-03\\\";\\r\\n    string constant VB_INVALID_SNAPSHOT_ID = \\\"VB-04\\\";\\r\\n\\r\\n    // RegularVault Error (RV)\\r\\n    string constant RV_VAULT_IS_RESTRICTED = \\\"RV-01\\\";\\r\\n    string constant RV_DEPOSIT_LOCKED = \\\"RV-02\\\";\\r\\n    string constant RV_WITHDRAWL_AMOUNT_EXCEED_DEPOSIT = \\\"RV-03\\\";\\r\\n\\r\\n    // BotVaultManager (VM)\\r\\n    string constant VM_VAULT_EXISTS = \\\"VM-01\\\";\\r\\n\\r\\n    // BotManager (BM)\\r\\n    string constant BM_DOES_NOT_SUPPORT_IDABOT = \\\"BM-01\\\";\\r\\n    string constant BM_DUPLICATED_BOT_QUALIFIED_NAME = \\\"BM-02\\\";\\r\\n    string constant BM_TEMPLATE_IS_NOT_REGISTERED = \\\"BM-03\\\";\\r\\n    string constant BM_GOVERNANCE_TOKEN_IS_NOT_DEPLOYED = \\\"BM-04\\\";\\r\\n    string constant BM_BOT_IS_NOT_REGISTERED = \\\"BM-05\\\";\\r\\n\\r\\n    // DABotModule (BMOD)\\r\\n    string constant BMOD_CALLER_IS_NOT_OWNER = \\\"BMOD-01\\\";\\r\\n    string constant BMOD_CALLER_IS_NOT_BOT_MANAGER = \\\"BMOD-02\\\";\\r\\n    string constant BMOD_BOT_IS_ABANDONED = \\\"BMOD-03\\\";\\r\\n\\r\\n    // DABotControllerLib (BCL)\\r\\n    string constant BCL_DUPLICATED_MODULE = \\\"BCL-01\\\";\\r\\n    string constant BCL_CERT_TOKEN_IS_NOT_CONFIGURED = \\\"BCL-02\\\";\\r\\n    string constant BCL_GOVERN_TOKEN_IS_NOT_CONFIGURED = \\\"BCL-03\\\";\\r\\n    string constant BCL_GOVERN_TOKEN_IS_NOT_DEPLOYED = \\\"BCL-04\\\";\\r\\n    string constant BCL_WARMUP_LOCKER_IS_NOT_CONFIGURED = \\\"BCL-05\\\";\\r\\n    string constant BCL_COOLDOWN_LOCKER_IS_NOT_CONFIGURED = \\\"BCL-06\\\";\\r\\n    string constant BCL_UKNOWN_MODULE_ID = \\\"BCL-07\\\";\\r\\n    string constant BCL_BOT_MANAGER_IS_NOT_CONFIGURED = \\\"BCL-08\\\";\\r\\n\\r\\n    // DABotController (BCMOD)\\r\\n    string constant BCMOD_CANNOT_CALL_TEMPLATE_METHOD_ON_BOT_INSTANCE = \\\"BCMOD-01\\\";\\r\\n    string constant BCMOD_CALLER_IS_NOT_OWNER = \\\"BCMOD-02\\\";\\r\\n    string constant BCMOD_MODULE_HANDLER_NOT_FOUND_FOR_METHOD_SIG = \\\"BCMOD-03\\\";\\r\\n    string constant BCMOD_NEW_OWNER_IS_ZERO = \\\"BCMOD-04\\\";\\r\\n\\r\\n    // CEXFundManagerModule (CFMOD)\\r\\n    string constant CFMOD_DUPLICATED_BENEFITCIARY = \\\"CFMOD-01\\\";\\r\\n    string constant CFMOD_INVALID_CERTIFICATE_OF_ASSET = \\\"CFMOD-02\\\";\\r\\n    string constant CFMOD_CALLER_IS_NOT_FUND_MANAGER = \\\"CFMOD-03\\\";\\r\\n\\r\\n    // DABotSettingLib (BSL)\\r\\n    string constant BSL_CALLER_IS_NOT_OWNER = \\\"BSL-01\\\";\\r\\n    string constant BSL_CALLER_IS_NOT_GOVERNANCE_EXECUTOR = \\\"BSL-02\\\";\\r\\n    string constant BSL_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME = \\\"BSL-03\\\";\\r\\n    string constant BSL_BOT_IS_ABANDONED = \\\"BSL-04\\\";\\r\\n\\r\\n    // DABotSettingModule (BSMOD)\\r\\n    string constant BSMOD_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME =  \\\"BSMOD-01\\\";\\r\\n    string constant BSMOD_INIT_DEPOSIT_IS_LESS_THAN_CONFIGURED_THRESHOLD = \\\"BSMOD-02\\\";\\r\\n    string constant BSMOD_FOUNDER_SHARE_IS_ZERO = \\\"BSMOD-03\\\";\\r\\n    string constant BSMOD_INSUFFICIENT_MAX_SHARE = \\\"BSMOD-04\\\";\\r\\n    string constant BSMOD_FOUNDER_SHARE_IS_GREATER_THAN_IBO_SHARE = \\\"BSMOD-05\\\";\\r\\n\\r\\n    // DABotCertLocker (LOCKER)\\r\\n    string constant LOCKER_CALLER_IS_NOT_OWNER_BOT = \\\"LOCKER-01\\\";\\r\\n\\r\\n    // DABotStakingModule (BSTMOD)\\r\\n    string constant BSTMOD_PRE_IBO_REQUIRED = \\\"BSTMOD-01\\\";\\r\\n    string constant BSTMOD_AFTER_IBO_REQUIRED = \\\"BSTMOD-02\\\";\\r\\n    string constant BSTMOD_INVALID_PORTFOLIO_ASSET = \\\"BSTMOD-03\\\";\\r\\n    string constant BSTMOD_PORTFOLIO_FULL = \\\"BSTMOD-04\\\";\\r\\n    string constant BSTMOD_INVALID_CERTIFICATE_ASSET = \\\"BSTMOD-05\\\";\\r\\n    string constant BSTMOD_PORTFOLIO_ASSET_NOT_FOUND = \\\"BSTMOD-06\\\";\\r\\n    string constant BSTMOD_ASSET_IS_ZERO = \\\"BSTMOD-07\\\";\\r\\n    string constant BSTMOD_INVALID_STAKING_CAP = \\\"BSTMOD-08\\\";\\r\\n    string constant BSTMOD_INSUFFICIENT_FUND = \\\"BSTMOD-09\\\";\\r\\n    string constant BSTMOD_CAP_IS_ZERO = \\\"BSTMOD-10\\\";\\r\\n    string constant BSTMOD_CAP_IS_LESS_THAN_STAKED_AND_IBO_CAP = \\\"BSTMOD-11\\\";\\r\\n    string constant BSTMOD_WERIGHT_IS_ZERO = \\\"BSTMOD-12\\\";\\r\\n\\r\\n    // CEX FundManager (CFM)\\r\\n    string constant CFM_REQ_TYPE_IS_MISMATCHED = \\\"CFM-01\\\";\\r\\n    string constant CFM_INVALID_REQUEST_ID = \\\"CFM-02\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_BOT_TOKEN = \\\"CFM-03\\\";\\r\\n    string constant CFM_CLOSE_TYPE_VALUE_IS_NOT_SUPPORTED = \\\"CFM-04\\\";\\r\\n    string constant CFM_UNKNOWN_REQUEST_TYPE = \\\"CFM-05\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_REQUESTER = \\\"CFM-06\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_APPROVER = \\\"CFM-07\\\";\\r\\n    string constant CFM_CEX_CERTIFICATE_IS_REQUIRED = \\\"CFM-08\\\";\\r\\n    string constant CFM_TREASURY_ASSET_CERTIFICATE_IS_REQUIRED = \\\"CFM-09\\\";\\r\\n    string constant CFM_FAIL_TO_TRANSFER_VALUE = \\\"CFM-10\\\";\\r\\n    string constant CFM_AWARDED_ASSET_IS_NOT_TREASURY = \\\"CFM-11\\\";\\r\\n    string constant CFM_INSUFFIENT_ASSET_TO_MINT_STOKEN = \\\"CFM-12\\\";\\r\\n\\r\\n    // TreasuryAsset (TA)\\r\\n    string constant TA_MINT_ZERO_AMOUNT = \\\"TA-01\\\";\\r\\n    string constant TA_LOCK_AMOUNT_EXCEED_BALANCE = \\\"TA-02\\\";\\r\\n    string constant TA_UNLOCK_AMOUNT_AND_PASSED_VALUE_IS_MISMATCHED = \\\"TA-03\\\";\\r\\n    string constant TA_AMOUNT_EXCEED_AVAILABLE_BALANCE = \\\"TA-04\\\";\\r\\n    string constant TA_AMOUNT_EXCEED_VALUE_BALANCE = \\\"TA-05\\\";\\r\\n    string constant TA_FUND_MANAGER_IS_NOT_SET = \\\"TA-06\\\";\\r\\n    string constant TA_FAIL_TO_TRANSFER_VALUE = \\\"TA-07\\\";\\r\\n\\r\\n    // Governance (GOV)\\r\\n    string constant GOV_DEFAULT_STRATEGY_IS_NOT_SET = \\\"GOV-01\\\";\\r\\n    string constant GOV_INSUFFICIENT_POWER_TO_CREATE_PROPOSAL = \\\"GOV-02\\\";\\r\\n    string constant GOV_INSUFFICIENT_VICS_TO_CREATE_PROPOSAL = \\\"GOV-03\\\";\\r\\n    string constant GOV_INVALID_PROPOSAL_ID = \\\"GOV-04\\\";\\r\\n    string constant GOV_REQUIRED_PROPOSER_OR_GUARDIAN = \\\"GOV-05\\\";\\r\\n    string constant GOV_TARGET_SHOULD_BE_ZERO_OR_REGISTERED_BOT = \\\"GOV-06\\\";\\r\\n    string constant GOV_INSUFFICIENT_POWER_TO_VOTE = \\\"GOV-07\\\";\\r\\n    string constant GOV_INVALID_NEW_STATE = \\\"GOV-08\\\";\\r\\n    string constant GOV_CANNOT_CHANGE_STATE_OF_CLOSED_PROPOSAL = \\\"GOV-08\\\";\\r\\n    string constant GOV_INVALID_CREATION_DATA = \\\"GOV-09\\\";\\r\\n    string constant GOV_CANNOT_CHANGE_STATE_OF_ON_CHAIN_PROPOSAL = \\\"GOV-10\\\";\\r\\n    string constant GOV_PROPOSAL_DONT_ACCEPT_VOTE = \\\"GOV-11\\\";\\r\\n    string constant GOV_DUPLICATED_VOTE = \\\"GOV-12\\\";\\r\\n    string constant GOV_CAN_ONLY_QUEUE_PASSED_PROPOSAL = \\\"GOV-13\\\";\\r\\n    string constant GOV_DUPLICATED_ACTION = \\\"GOV-14\\\";\\r\\n    string constant GOV_INVALID_VICS_ADDRESS = \\\"GOV-15\\\";\\r\\n\\r\\n    // Timelock Executor (TLE)\\r\\n    string constant TLE_DELAY_SHORTER_THAN_MINIMUM = \\\"TLE-01\\\";\\r\\n    string constant TLE_DELAY_LONGER_THAN_MAXIMUM = \\\"TLE-02\\\";\\r\\n    string constant TLE_ONLY_BY_ADMIN = \\\"TLE-03\\\";\\r\\n    string constant TLE_ONLY_BY_PENDING_ADMIN = \\\"TLE-04\\\";\\r\\n    string constant TLE_ONLY_BY_THIS_TIMELOCK = \\\"TLE-05\\\";\\r\\n    string constant TLE_EXECUTION_TIME_UNDERESTIMATED = \\\"TLE-06\\\";\\r\\n    string constant TLE_ACTION_NOT_QUEUED = \\\"TLE-07\\\";\\r\\n    string constant TLE_TIMELOCK_NOT_FINISHED = \\\"TLE-08\\\";\\r\\n    string constant TLE_GRACE_PERIOD_FINISHED = \\\"TLE-09\\\";\\r\\n    string constant TLE_NOT_ENOUGH_MSG_VALUE = \\\"TLE-10\\\";\\r\\n\\r\\n    // DABotVoteStrategy (BVS) string constant BVS_ = \\\"BVS-\\\";\\r\\n    string constant BVS_NOT_A_REGISTERED_DABOT = \\\"BVS-01\\\";\\r\\n\\r\\n    // DABotWhiteList (BWL) string constant BWL_ = \\\"BWL-\\\";\\r\\n    string constant BWL_ACCOUNT_IS_ZERO = \\\"BWL-01\\\";\\r\\n    string constant BWL_ACCOUNT_IS_NOT_WHITELISTED = \\\"BWL-02\\\";\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/common/IConfigurator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\nlibrary Roles {\\r\\n    bytes32 constant ROLE_ADMIN = keccak256('operator.dabot.role');\\r\\n    bytes32 constant ROLE_OPERATORS = keccak256('operator.dabot.role');\\r\\n    bytes32 constant ROLE_TEMPLATE_CREATOR = keccak256('creator.template.dabot.role');\\r\\n    bytes32 constant ROLE_BOT_CREATOR = keccak256('creator.dabot.role');\\r\\n    bytes32 constant ROLE_FUND_APPROVER = keccak256('approver.fund.role');\\r\\n}\\r\\n\\r\\nlibrary AddressBook {\\r\\n    bytes32 constant ADDR_FACTORY = keccak256('factory.address');\\r\\n    bytes32 constant ADDR_VICS = keccak256('vics.address');\\r\\n    bytes32 constant ADDR_TAX = keccak256('tax.address');\\r\\n    bytes32 constant ADDR_GOVERNANCE = keccak256('governance.address');\\r\\n    bytes32 constant ADDR_GOVERNANCE_EXECUTOR = keccak256('executor.governance.address');\\r\\n    bytes32 constant ADDR_BOT_MANAGER = keccak256('botmanager.address');\\r\\n    bytes32 constant ADDR_VICS_EXCHANGE = keccak256('exchange.vics.address');\\r\\n    bytes32 constant ADDR_TREASURY_MANAGER = keccak256('treasury-manager.address');\\r\\n    bytes32 constant ADDR_CEX_FUND_MANAGER = keccak256('fund-manager.address');\\r\\n    bytes32 constant ADDR_CEX_DEFAULT_MASTER_ACCOUNT = keccak256('default.master.address');\\r\\n}\\r\\n\\r\\nlibrary Config {\\r\\n    /// The amount of VICS that a proposer has to pay when create a new proposal\\r\\n    bytes32 constant PROPOSAL_DEPOSIT = keccak256('deposit.proposal.config');\\r\\n\\r\\n    /// The percentage of proposal creation fee distributed to the account that execute a propsal\\r\\n    bytes32 constant PROPOSAL_REWARD_PERCENT = keccak256('reward.proposal.config');\\r\\n\\r\\n    /// The minimum VICS a bot creator has to deposit to a newly created bot\\r\\n    bytes32 constant CREATOR_DEPOSIT = keccak256('deposit.creator.config');\\r\\n\\r\\n    /// The minim \\r\\n    bytes32 constant PROPOSAL_CREATOR_MININUM_POWER = keccak256('minpower.goverance.config');\\r\\n    \\r\\n    /// The minimum percentage of for-votes over total votes a proposal has to achieve to be passed\\r\\n    bytes32 constant PROPOSAL_MINIMUM_QUORUM = keccak256('minquorum.governance.config');\\r\\n\\r\\n    /// The minimum difference (in percentage) between for-votes and against-vote for a proposal to be passed\\r\\n    bytes32 constant PROPOSAL_VOTE_DIFFERENTIAL = keccak256('differential.governance.config');\\r\\n\\r\\n    /// The voting duration of a proposal\\r\\n    bytes32 constant PROPOSAL_DURATION = keccak256('duration.goverance.config');\\r\\n\\r\\n    /// The interval that a passed proposed is waiting in queue before being executed\\r\\n    bytes32 constant PROPOSAL_EXECUTION_DELAY = keccak256('execdelay.governance.config');\\r\\n}\\r\\n\\r\\ninterface IConfigurator {\\r\\n    function addressOf(bytes32 addrId) external view returns(address);\\r\\n    function configOf(bytes32 configId) external view returns(uint);\\r\\n    function bytesConfigOf(bytes32 configId) external view returns(bytes memory);\\r\\n\\r\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\r\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\r\\n\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/common/IInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IInitializable {\\r\\n    function init(bytes calldata data) external payable;\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/common/IRoboFiFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRoboFiFactory {\\r\\n    function deploy(address masterContract, \\r\\n                    bytes calldata data, \\r\\n                    bool useCreate2) \\r\\n        external \\r\\n        payable \\r\\n        returns(address);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/DABotCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\n\\r\\n\\r\\nstring constant ERR_PERMISSION_DENIED = \\\"DABot: permission denied\\\";\\r\\n\\r\\nbytes32 constant BOT_MODULE_VOTE_CONTROLER = keccak256(\\\"vote.dabot.module\\\");\\r\\nbytes32 constant BOT_MODULE_STAKING_CONTROLER = keccak256(\\\"staking.dabot.module\\\");\\r\\nbytes32 constant BOT_MODULE_CERTIFICATE_TOKEN = keccak256(\\\"certificate-token.dabot.module\\\");\\r\\nbytes32 constant BOT_MODULE_GOVERNANCE_TOKEN = keccak256(\\\"governance-token.dabot.module\\\");\\r\\n\\r\\nbytes32 constant BOT_MODULE_WARMUP_LOCKER = keccak256(\\\"warmup.dabot.module\\\");\\r\\nbytes32 constant BOT_MODULE_COOLDOWN_LOCKER = keccak256(\\\"cooldown.dabot.module\\\");\\r\\n\\r\\nenum BotStatus { PRE_IBO, IN_IBO, ACTIVE, ABANDONED }\\r\\n\\r\\nstruct BotModuleInitData {\\r\\n    bytes32 moduleId;\\r\\n    bytes data;\\r\\n}\\r\\n\\r\\nstruct BotSetting {             // for saving storage, the meta-fields of a bot are encoded into a single uint256 byte slot.\\r\\n    uint64 iboTime;             // 32 bit low: iboStartTime (unix timestamp), \\r\\n                                // 32 bit high: iboEndTime (unix timestamp)\\r\\n    uint24 stakingTime;         // 8 bit low: warm-up time, \\r\\n                                // 8 bit mid: cool-down time\\r\\n                                // 8 bit high: time unit (0 - day, 1 - hour, 2 - minute, 3 - second)\\r\\n    uint32 pricePolicy;         // 16 bit low: price multiplier (fixed point, 2 digits for decimal)\\r\\n                                // 16 bit high: commission fee in percentage (fixed point, 2 digit for decimal)\\r\\n    uint128 profitSharing;      // packed of 16bit profit sharing: bot-creator, gov-user, stake-user, and robofi-game\\r\\n    uint initDeposit;           // the intial deposit (in VICS) of bot-creator\\r\\n    uint initFounderShare;      // the intial shares (i.e., governance token) distributed to bot-creator\\r\\n    uint maxShare;              // max cap of gtoken supply\\r\\n    uint iboShare;              // max supply of gtoken for IBO. Constraint: maxShare >= iboShare + initFounderShare\\r\\n}\\r\\n\\r\\nstruct BotMetaData {\\r\\n    string name;\\r\\n    string symbol;\\r\\n    string version;\\r\\n    uint8 botType;\\r\\n    bool abandoned;\\r\\n    bool isTemplate;        // determine this module is a template, not a bot instance\\r\\n    bool initialized;       // determines whether the bot has been initialized \\r\\n    address botOwner;       // the public address of the bot owner\\r\\n    address botManager;\\r\\n    address botTemplate;    // address of the template contract \\r\\n    address gToken;         // address of the governance token\\r\\n}\\r\\n\\r\\nstruct BotDetail { // represents a detail information of a bot, merely use for bot infomation query\\r\\n    uint id;                    // the unique id of a bot within its manager.\\r\\n                                // note: this id only has value when calling {DABotManager.queryBots}\\r\\n    address botAddress;         // the contract address of the bot.\\r\\n\\r\\n    BotStatus status;           // 0 - PreIBO, 1 - InIBO, 2 - Active, 3 - Abandonned\\r\\n    uint8 botType;              // type of the bot (inherits from the bot's template)\\r\\n    string botSymbol;           // get the bot name.\\r\\n    string botName;             // get the bot full name.\\r\\n    address governToken;        // the address of the governance token\\r\\n    address template;           // the address of the master contract which defines the behaviors of this bot.\\r\\n    string templateName;        // the template name.\\r\\n    string templateVersion;     // the template version.\\r\\n    uint iboStartTime;          // the time when IBO starts (unix second timestamp)\\r\\n    uint iboEndTime;            // the time when IBO ends (unix second timestamp)\\r\\n    uint warmup;                // the duration (in days) for which the staking profit starts counting\\r\\n    uint cooldown;              // the duration (in days) for which users could claim back their stake after submiting the redeem request.\\r\\n    uint priceMul;              // the price multiplier to calculate the price per gtoken (based on the IBO price).\\r\\n    uint commissionFee;         // the commission fee when buying gtoken after IBO time.\\r\\n    uint initDeposit;           \\r\\n    uint initFounderShare;\\r\\n    uint144 profitSharing;\\r\\n    uint maxShare;              // max supply of governance token.\\r\\n    uint circulatedShare;       // the current supply of governance token.\\r\\n    uint iboShare;              // the max supply of gtoken for IBO.\\r\\n    uint userShare;             // the amount of governance token in the caller's balance.\\r\\n    UserPortfolioAsset[] portfolio;\\r\\n}\\r\\n\\r\\nstruct BotModuleInfo {\\r\\n    string name;\\r\\n    string version;\\r\\n    address handler;\\r\\n}\\r\\n\\r\\nstruct PortfolioCreationData {\\r\\n    address asset;\\r\\n    uint256 cap;            // the maximum stake amount for this asset (bot-lifetime).\\r\\n    uint256 iboCap;         // the maximum stake amount for this asset within the IBO.\\r\\n    uint256 weight;         // preference weight for this asset. Use to calculate the max purchasable amount of governance tokens.\\r\\n}\\r\\n\\r\\nstruct PortfolioAsset {\\r\\n    address certToken;    // the certificate asset to return to stake-users\\r\\n    uint256 cap;            // the maximum stake amount for this asset (bot-lifetime).\\r\\n    uint256 iboCap;         // the maximum stake amount for this asset within the IBO.\\r\\n    uint256 weight;         // preference weight for this asset. Use to calculate the max purchasable amount of governance tokens.\\r\\n}\\r\\n\\r\\nstruct UserPortfolioAsset {\\r\\n    address asset;\\r\\n    PortfolioAsset info;\\r\\n    uint256 userStake;\\r\\n    uint256 totalStake;     // the total stake of all users.\\r\\n    uint256 certSupply;     // the total supply of the certificated token\\r\\n}\\r\\n\\r\\n/**\\r\\n@dev Records warming-up certificate tokens of a DABot.\\r\\n*/\\r\\nstruct LockerData {         \\r\\n    address bot;            // the DABOT which creates this locker.\\r\\n    address owner;          // the locker owner, who is albe to unlock and get tokens after the specified release time.\\r\\n    address token;          // the contract of the certificate token.\\r\\n    uint64 created_at;      // the moment when locker is created.\\r\\n    uint64 release_at;      // the monent when locker could be unlock. \\r\\n}\\r\\n\\r\\n/**\\r\\n@dev Provides detail information of a warming-up token lock, plus extra information.\\r\\n    */\\r\\nstruct LockerInfo {\\r\\n    address locker;\\r\\n    LockerData info;\\r\\n    uint256 amount;         // the locked amount of cert token within this locker.\\r\\n    uint256 reward;         // the accumulated rewards\\r\\n    address asset;          // the stake asset beyond the certificated token\\r\\n}\\r\\n\\r\\nstruct MintableShareDetail {\\r\\n    address asset;\\r\\n    uint stakeAmount;\\r\\n    uint mintableShare;\\r\\n    uint weight;\\r\\n    uint iboCap;\\r\\n}\\r\\n\\r\\nstruct AwardingDetail {\\r\\n    address asset;\\r\\n    uint compound;\\r\\n    uint reward;\\r\\n    uint compoundMode;  // 0 - increase, 1 - decrrease\\r\\n}\\r\\n\\r\\nstruct StakingReward {\\r\\n    address asset;\\r\\n    uint amount;\\r\\n}\\r\\n\\r\\nstruct BenefitciaryInfo {\\r\\n    address account;\\r\\n    string name;\\r\\n    string shortName;\\r\\n    uint weight;\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/controller/DABotController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../../common/IInitializable.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IDABot.sol\\\";\\r\\nimport \\\"../interfaces/IDABotController.sol\\\";\\r\\nimport \\\"../interfaces/IDABotModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotGovernToken.sol\\\";\\r\\nimport \\\"../setting/DABotSettingLib.sol\\\";\\r\\nimport \\\"../staking/DABotStakingLib.sol\\\";\\r\\nimport \\\"./DABotControllerLib.sol\\\";\\r\\n\\r\\ncontract DABotModuleController is IInitializable, Context, IDABotControllerEvent {\\r\\n\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotStakingLib for BotStakingData;\\r\\n    using DABotSettingLib for BotSetting;\\r\\n\\r\\n    constructor(string memory name, string memory version) {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        ds.name = name;\\r\\n        ds.version = version;\\r\\n        ds.botOwner = _msgSender();\\r\\n        ds.isTemplate = true;\\r\\n        ds.initialized = true;\\r\\n    }\\r\\n\\r\\n    modifier onlyTemplate() {\\r\\n        require(DABotMetaLib.metadata().isTemplate, Errors.BCMOD_CANNOT_CALL_TEMPLATE_METHOD_ON_BOT_INSTANCE); \\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(_msgSender() == ds.botOwner, Errors.BCMOD_CALLER_IS_NOT_OWNER);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function registerModule(address moduleHandler) public onlyTemplate onlyOwner {\\r\\n        IDABotModule _module = IDABotModule(moduleHandler);\\r\\n        (string memory _name, string memory _version, bytes32 _moduleId) = _module.moduleInfo();\\r\\n\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        bool moduleExisted = ds.moduleAddresses[_moduleId] != address(0);\\r\\n\\r\\n        (bool success, bytes memory result) = \\r\\n            moduleHandler.delegatecall(abi.encodeWithSelector(IDABotModule.onRegister.selector, moduleHandler));\\r\\n        \\r\\n        require(success, string(abi.encodePacked(\\\"Controller: module \\\", _name, ' registration error: ',  result)));\\r\\n\\r\\n        if (!moduleExisted) \\r\\n            ds.modules.push(_moduleId);\\r\\n        \\r\\n        emit ModuleRegistered(_moduleId, moduleHandler, _name, _version);\\r\\n    }\\r\\n\\r\\n    function updateModuleHandler(bytes32 moduleId, address newModuleAddress) public onlyTemplate onlyOwner {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        address oldModuleAddress = ds.registerModule(moduleId, newModuleAddress); \\r\\n        emit ModuleHandlerChanged(moduleId, oldModuleAddress, newModuleAddress);\\r\\n    }\\r\\n\\r\\n    function module(bytes32 moduleId) external view onlyTemplate returns(address) {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        return ds.module(moduleId);\\r\\n    }\\r\\n\\r\\n    function moduleOfSelector(bytes4 selector) public view onlyTemplate returns(address) {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        return ds.moduleOfSelector(selector);\\r\\n    }\\r\\n\\r\\n    function init(bytes calldata data) external payable override {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.initialized, Errors.CM_CONTRACT_HAS_BEEN_INITIALIZED);\\r\\n       \\r\\n        (BotMetaData memory meta, BotModuleInitData[] memory initData) = \\r\\n            abi.decode(data, (BotMetaData, BotModuleInitData[]));\\r\\n\\r\\n        BotMetaData memory templateMeta = IDABot(meta.botTemplate).metadata();\\r\\n\\r\\n        ds.name = meta.name;\\r\\n        ds.symbol = meta.symbol;\\r\\n        ds.version = meta.version;\\r\\n        ds.botType = templateMeta.botType;\\r\\n        ds.botOwner = meta.botOwner;\\r\\n        ds.botManager = meta.botManager;\\r\\n        ds.botTemplate = meta.botTemplate;\\r\\n                \\r\\n        for(uint i = 0; i < initData.length; i++) {\\r\\n            address moduleAddress = ds.module(initData[i].moduleId);\\r\\n            if (moduleAddress == address(0))\\r\\n                revert(string(abi.encodePacked(\\\"Controller: module #\\\", i, \\\"(\\\", Strings.toHexString(uint256(initData[i].moduleId), 32) ,\\\") not found\\\"))); \\r\\n\\r\\n            (bool success, bytes memory result) = moduleAddress.delegatecall(abi.encodeWithSelector(IDABotModule.onInitialize.selector, initData[i].data));\\r\\n            if (!success) {\\r\\n                revert(string(abi.encodePacked(string(result), ' (module ', Strings.toHexString(uint160(moduleAddress), 20), \\\")\\\")));\\r\\n            }\\r\\n        }\\r\\n        ds.initialized = true;\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n        __forwardCall();\\r\\n    }\\r\\n\\r\\n    function __findImplementation() internal view returns(address) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        address moduleAddress;\\r\\n        if (meta.botTemplate == address(0)) {\\r\\n            moduleAddress = moduleOfSelector(msg.sig);\\r\\n        } else {\\r\\n            moduleAddress = DABotModuleController(payable(meta.botTemplate)).moduleOfSelector(msg.sig);\\r\\n        }\\r\\n        if (moduleAddress == address(0)) {\\r\\n            revert(string(abi.encodePacked(Errors.BCMOD_MODULE_HANDLER_NOT_FOUND_FOR_METHOD_SIG, \\\" \\\", Strings.toHexString(uint32(msg.sig), 4)))); \\r\\n        }\\r\\n        return moduleAddress;\\r\\n    }\\r\\n\\r\\n    function __forwardCall() internal {\\r\\n        address handler = __findImplementation();\\r\\n        // Execute external function from facet using delegatecall and return any value.\\r\\n        assembly {\\r\\n            // copy function selector and any arguments\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n            // execute function call using the facet\\r\\n            let result := delegatecall(gas(), handler, 0, calldatasize(), 0, 0)\\r\\n            // get any return value\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n            // return any return value or error back to the caller\\r\\n            switch result\\r\\n                case 0 {\\r\\n                    revert(0, returndatasize())\\r\\n                }\\r\\n                default {\\r\\n                    return(0, returndatasize())\\r\\n                }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function emergencyWithdraw(address token) external payable onlyOwner {\\r\\n        if (token == address(0))\\r\\n            payable(owner()).transfer(address(this).balance);\\r\\n        else {\\r\\n            IRoboFiERC20 erc20 = IRoboFiERC20(token);\\r\\n            erc20.transfer(owner(), erc20.balanceOf(address(this)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function qualifiedName() external view returns(string memory) {\\r\\n        BotMetaData storage meta = DABotMetaLib.coredata().metadata;\\r\\n        if (meta.isTemplate)\\r\\n            return string(abi.encodePacked(meta.name,\\\":\\\",meta.version));\\r\\n        return string(abi.encodePacked(meta.symbol,\\\":\\\",meta.name));\\r\\n    }\\r\\n\\r\\n    function metadata() external view returns(BotMetaData memory) {\\r\\n        return DABotMetaLib.coredata().metadata;\\r\\n    }\\r\\n\\r\\n    function governToken() external view returns(IDABotGovernToken) {\\r\\n        return IDABotGovernToken(DABotMetaLib.metadata().gToken);\\r\\n    }\\r\\n\\r\\n    function setting() external view returns(BotSetting memory) {\\r\\n        return DABotSettingLib.setting();\\r\\n    }\\r\\n\\r\\n    function botDetails() external view returns(BotDetail memory output) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        BotStakingData storage staking = DABotStakingLib.staking();\\r\\n        BotSetting storage _setting = DABotSettingLib.setting();\\r\\n\\r\\n        BotMetaData memory templateMeta = DABotModuleController(payable(meta.botTemplate)).metadata();\\r\\n        IDABotGovernToken gToken = IDABotGovernToken(meta.gToken);\\r\\n\\r\\n        output.botAddress = address(this);\\r\\n        output.template = meta.botTemplate;\\r\\n        output.botSymbol = meta.symbol;\\r\\n        output.botName = meta.name;\\r\\n        output.status = _setting.status();\\r\\n        output.botType = templateMeta.botType;\\r\\n        output.governToken = meta.gToken;\\r\\n        output.templateName = templateMeta.name; \\r\\n        output.templateVersion = templateMeta.version;\\r\\n        output.iboStartTime = _setting.iboStartTime();\\r\\n        output.iboEndTime = _setting.iboEndTime();\\r\\n        output.warmup = _setting.warmupTime();\\r\\n        output.cooldown = _setting.cooldownTime();\\r\\n        output.priceMul = _setting.priceMultiplier();\\r\\n        output.commissionFee = _setting.commission();\\r\\n        output.profitSharing = _setting.profitSharing;\\r\\n        output.initDeposit = _setting.initDeposit;\\r\\n        output.initFounderShare = _setting.initFounderShare;\\r\\n        output.maxShare = _setting.maxShare;\\r\\n        output.iboShare = _setting.iboShare;\\r\\n        output.circulatedShare = gToken.totalSupply();\\r\\n        output.userShare = gToken.balanceOf(_msgSender());\\r\\n        output.portfolio = staking.portfolioDetails();\\r\\n    }\\r\\n\\r\\n    function owner() public view returns(address) {\\r\\n        return DABotMetaLib.metadata().botOwner;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        require(newOwner != address(0), Errors.BCMOD_NEW_OWNER_IS_ZERO);\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function abandon(bool value) external onlyOwner {\\r\\n        DABotMetaLib.metadata().abandoned = value;\\r\\n        emit BotAbandoned(value);\\r\\n    }\\r\\n\\r\\n    function modulesInfo() external view returns(BotModuleInfo[] memory result) {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        result = new BotModuleInfo[](ds.modules.length);\\r\\n        for (uint i = 0; i < ds.modules.length; i++) {\\r\\n            IDABotModule moduleHandler = IDABotModule(ds.moduleAddresses[ds.modules[i]]);\\r\\n            (string memory _name, string memory _version,) = moduleHandler.moduleInfo();\\r\\n            result[i] = BotModuleInfo(_name, _version, ds.moduleAddresses[ds.modules[i]]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function moduleHandlerInfo(bytes32[] calldata ids) external view returns(address[] memory result) {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        result = new address[](ids.length);\\r\\n        for (uint i = 0; i < ids.length; i++)\\r\\n            result[i] = ds.moduleAddresses[ids[i]];\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        address oldOwner = ds.botOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n        ds.botOwner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/controller/DABotControllerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IBotTemplateController.sol\\\";\\r\\nimport \\\"../interfaces/IDABotGovernToken.sol\\\";\\r\\nimport \\\"../interfaces/IDABotManager.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nstruct BotTemplateController {\\r\\n    mapping(bytes4 => bytes32) selectors;\\r\\n    mapping(bytes32 => address) moduleAddresses;\\r\\n    bytes32[] modules;\\r\\n}\\r\\n\\r\\nstruct BotCoreData {\\r\\n    BotTemplateController controller;\\r\\n    BotMetaData metadata;\\r\\n    BotSetting setting;\\r\\n}\\r\\n\\r\\nlibrary DABotTemplateControllerLib {\\r\\n\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function controller() internal view returns (BotTemplateController storage) {\\r\\n        return coredata().controller;\\r\\n    }\\r\\n\\r\\n    function requireNewModule(bytes32 moduleId) internal view {\\r\\n        BotTemplateController storage ds = controller();\\r\\n        require(ds.module(moduleId) == address(0), Errors.BCL_DUPLICATED_MODULE);\\r\\n    }\\r\\n\\r\\n    function module(BotTemplateController storage ds, bytes32 moduleId) internal view returns(address) {\\r\\n        return ds.moduleAddresses[moduleId];\\r\\n    }\\r\\n\\r\\n    function moduleOfSelector(BotTemplateController storage ds, bytes4 selector) internal view returns(address) {\\r\\n        bytes32 moduleId = ds.selectors[selector];\\r\\n        return ds.moduleAddresses[moduleId];\\r\\n    }\\r\\n\\r\\n    function registerModule(BotTemplateController storage ds, bytes32 moduleId, address moduleAddress) internal returns(address oldModuleAddress) {\\r\\n        oldModuleAddress = ds.moduleAddresses[moduleId];\\r\\n        ds.moduleAddresses[moduleId] = moduleAddress;\\r\\n    }\\r\\n\\r\\n    function registerSelectors(BotTemplateController storage ds, bytes32 moduleId, bytes4[] memory selectors) internal {\\r\\n        for(uint i = 0; i < selectors.length; i++)\\r\\n            ds.selectors[selectors[i]] = moduleId;\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\nlibrary DABotMetaLib {\\r\\n\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function metadata() internal view returns (BotMetaData storage) {\\r\\n        return coredata().metadata;\\r\\n    }\\r\\n\\r\\n    function manager(BotMetaData storage ds) internal view returns(IDABotManager _manager) {\\r\\n        _manager = IDABotManager(ds.botManager);\\r\\n        require(address(_manager) != address(0), Errors.BCL_BOT_MANAGER_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function configurator(BotMetaData storage ds) internal view returns(IConfigurator _config) {\\r\\n        _config = ds.manager().configurator();\\r\\n    }\\r\\n\\r\\n    function factory(BotMetaData storage ds) internal view returns(IRoboFiFactory _factory) {\\r\\n        IConfigurator config = ds.configurator();\\r\\n        _factory = IRoboFiFactory(config.addressOf(AddressBook.ADDR_FACTORY));\\r\\n        require(address(_factory) != address(0), Errors.CM_FACTORY_ADDRESS_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function governToken(BotMetaData storage ds) internal view returns(IDABotGovernToken) {\\r\\n        address gToken = ds.gToken;\\r\\n        require(gToken != address(0), Errors.BCL_GOVERN_TOKEN_IS_NOT_DEPLOYED);\\r\\n        return IDABotGovernToken(gToken);\\r\\n    }\\r\\n\\r\\n    function module(BotMetaData storage ds, bytes32 moduleId) internal view returns(address) {\\r\\n        if (ds.botTemplate == address(0)) {\\r\\n            return DABotTemplateControllerLib.controller().module(moduleId);\\r\\n        }\\r\\n        return IBotTemplateController(ds.botTemplate).module(moduleId);\\r\\n    }\\r\\n\\r\\n    function deployCertToken(BotMetaData storage ds, address asset) internal returns(address) {\\r\\n        address certTokenMaster = ds.module(BOT_MODULE_CERTIFICATE_TOKEN);\\r\\n        if (certTokenMaster == address(0)) {\\r\\n            revert(string(abi.encodePacked(\\r\\n                Errors.BCL_CERT_TOKEN_IS_NOT_CONFIGURED, \\r\\n                '. template: ', \\r\\n                Strings.toHexString(uint160(ds.botTemplate), 20)\\r\\n                )));\\r\\n        }\\r\\n        require(certTokenMaster != address(0), Errors.BCL_CERT_TOKEN_IS_NOT_CONFIGURED);\\r\\n\\r\\n        return ds.factory().deploy(\\r\\n            certTokenMaster,\\r\\n            abi.encode(address(this), asset),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployGovernanceToken(BotMetaData storage ds) internal returns(address) {\\r\\n        address governTokenMaster = ds.module(BOT_MODULE_GOVERNANCE_TOKEN);\\r\\n        require(governTokenMaster != address(0), Errors.BCL_GOVERN_TOKEN_IS_NOT_CONFIGURED);\\r\\n\\r\\n        return ds.factory().deploy(\\r\\n            governTokenMaster,\\r\\n            abi.encode(address(this)),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployLocker(BotMetaData storage ds, bytes32 lockerType, LockerData memory data) internal returns(address) {\\r\\n        address lockerMaster = ds.module(lockerType);\\r\\n        if (lockerMaster == address(0)) {\\r\\n            if (lockerType == BOT_MODULE_WARMUP_LOCKER)\\r\\n                revert(Errors.BCL_WARMUP_LOCKER_IS_NOT_CONFIGURED);\\r\\n            if (lockerType == BOT_MODULE_COOLDOWN_LOCKER) \\r\\n                revert(Errors.BCL_COOLDOWN_LOCKER_IS_NOT_CONFIGURED);\\r\\n            revert(Errors.BCL_UKNOWN_MODULE_ID);\\r\\n        }\\r\\n        return ds.factory().deploy(\\r\\n            lockerMaster,\\r\\n            abi.encode(data),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/fundmanager/DABotFundManagerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\nimport \\\"../interfaces/IBotBenefitciary.sol\\\"; \\r\\n\\r\\nstruct FundManagementData {\\r\\n    address[] benefitciaries;\\r\\n}\\r\\n\\r\\naddress constant BOT_CREATOR_BENEFITCIARY = address(1);\\r\\naddress constant GOV_USER_BENEFITCIARY = address(2);\\r\\naddress constant STAKE_USER_BENEFITCIARY = address(3);\\r\\n\\r\\nlibrary DABotFundManagerLib {\\r\\n    bytes32 constant FUND_MANAGER_STORAGE_POSITION = keccak256(\\\"fundmanager.dabot.storage\\\");\\r\\n\\r\\n\\r\\n    function fundData() internal pure returns(FundManagementData storage ds) {\\r\\n        bytes32 position = FUND_MANAGER_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot :=  position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function benefitciaryName(address benefitciary) internal view returns(string memory) {\\r\\n        if (benefitciary == BOT_CREATOR_BENEFITCIARY)\\r\\n            return \\\"Bot Creator\\\";\\r\\n        if (benefitciary == GOV_USER_BENEFITCIARY)\\r\\n            return \\\"Governance Users\\\";\\r\\n        if (benefitciary == STAKE_USER_BENEFITCIARY)\\r\\n            return \\\"Stake Users\\\";\\r\\n        return IBotBenefitciary(benefitciary).name();\\r\\n    }\\r\\n\\r\\n    function benefitciaryShortName(address benefitciary) internal view returns(string memory) {\\r\\n        if (benefitciary == BOT_CREATOR_BENEFITCIARY)\\r\\n            return \\\"Bot Creator\\\";\\r\\n        if (benefitciary == GOV_USER_BENEFITCIARY)\\r\\n            return \\\"Gov. Users\\\";\\r\\n        if (benefitciary == STAKE_USER_BENEFITCIARY)\\r\\n            return \\\"Stake Users\\\";\\r\\n        return IBotBenefitciary(benefitciary).shortName();\\r\\n    }\\r\\n\\r\\n    function addBenefitciary(FundManagementData storage ds, address benefitciary) internal {\\r\\n        ds.benefitciaries.push(benefitciary);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IBotBenefitciary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\n\\r\\n\\r\\n/**\\r\\n@dev The interface of a bot benefitciary who is awarded from the bot's activities.\\r\\n */\\r\\ninterface IBotBenefitciary {\\r\\n\\r\\n    function name() external view returns(string memory);\\r\\n    function shortName() external view returns(string memory);\\r\\n    function onAward(uint amount) external;\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IBotTemplateController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\ninterface IBotTemplateController {\\r\\n    function module(bytes32 moduleId) external view returns(address);\\r\\n    function moduleOfSelector(bytes32 selector) external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IBotVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\n\\r\\nstruct VaultData {\\r\\n    address botToken;\\r\\n    IERC20 asset;\\r\\n    address bot;\\r\\n    uint8 index;                // the index-th vault generated from botToken\\r\\n                                //  0 - warmup vault, 1 - regular vault, 2 - VIP vault\\r\\n    bytes4 vaultType;           // type of the vault, used to determine the vault handler\\r\\n}\\r\\n\\r\\nstruct UserInfo {\\r\\n    uint deposit;\\r\\n    uint debtPoints;\\r\\n    uint debt;\\r\\n    uint lockPeriod;\\r\\n    uint lastDepositTime;\\r\\n}\\r\\n\\r\\nstruct VaultInfo {\\r\\n    VaultData data;             \\r\\n    UserInfo user;\\r\\n    uint totalDeposit;          // total deposits in the vault\\r\\n    uint accRewardPerShare;     // the pending reward per each unit of deposit\\r\\n    uint lastRewardTime;        // the block time of the last reward transaction\\r\\n    uint pendingReward;         // the pending reward for the caller\\r\\n    bytes option;               // vault option\\r\\n} \\r\\n\\r\\nstruct RegularVaultOption {\\r\\n    bool restricted;    // restrict deposit activity to bot only\\r\\n}\\r\\n\\r\\n\\r\\ninterface IBotVaultEvent {\\r\\n    event Deposit(uint vID, address indexed payor, address indexed account, uint amount);\\r\\n    event Widthdraw(uint vID, address indexed account, uint amount);\\r\\n    event RewardAdded(uint vID, uint assetAmount);\\r\\n    event Snapshot(uint vID, uint snapshotId);\\r\\n}\\r\\n\\r\\ninterface IBotVault is IBotVaultEvent {\\r\\n    function deposit(uint vID, uint amount) external;\\r\\n    function delegateDeposit(uint vID, address payor, address account, uint amount, uint lockTime) external;\\r\\n    function withdraw(uint vID, uint amount) external;\\r\\n    function delegateWithdraw(uint vID, address account, uint amount) external;\\r\\n    function pendingReward(uint vID, address account) external view returns(uint);\\r\\n    function balanceOf(uint vID, address account) external view returns(uint);\\r\\n    function balanceOfAt(uint vID, address account, uint blockNo) external view returns(uint);\\r\\n    function updateReward(uint vID, uint assetAmount) external;\\r\\n    function claimReward(uint vID, address account) external;\\r\\n\\r\\n    /**\\r\\n    @dev Queries user deposit info for the given vault.\\r\\n    @param vID the vault ID to query.\\r\\n    @param account the user account to query.\\r\\n     */\\r\\n    function getUserInfo(uint vID, address account) external view returns(UserInfo memory result);\\r\\n    function getVaultInfo(uint vID, address account) external view returns(VaultInfo memory);\\r\\n    function getVaultOption(uint vID) external view returns(bytes memory);\\r\\n    function setVaultOption(uint vID, bytes calldata option) external;\\r\\n}\\r\\n\\r\\ninterface IBotVaultManagerEvent is IBotVaultEvent {\\r\\n    event OpenVault(uint vID, VaultData data);\\r\\n    event DestroyVault(uint vID);\\r\\n    event RegisterHandler(bytes4 vaultType, address handler);\\r\\n    event BotManagerUpdated(address indexed botManager);\\r\\n}\\r\\n\\r\\ninterface IBotVaultManager is IBotVault, IBotVaultManagerEvent {\\r\\n    function vaultOf(uint vID) external view returns(VaultData memory result);\\r\\n    function validVault(uint vID) external view returns(bool);\\r\\n    function createVault(VaultData calldata data) external returns(uint);\\r\\n    function destroyVault(uint vID) external;\\r\\n    function vaultId(address botToken, uint8 vaultIndex) external pure returns(uint);\\r\\n    function registerHandler(bytes4 vaultType, IBotVault handler) external;\\r\\n    function botManager() external view returns(address);\\r\\n    function setBotManager(address account) external;\\r\\n    function snapshot(uint vID) external;\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\nimport \\\"./IDABotController.sol\\\";\\r\\nimport \\\"./IDABotSettingModule.sol\\\";\\r\\nimport \\\"./IDABotStakingModule.sol\\\";\\r\\nimport \\\"./IDABotGovernModule.sol\\\";\\r\\nimport \\\"./IDABotWhitelist.sol\\\";\\r\\nimport \\\"./IDABotFundManagerModule.sol\\\";\\r\\n\\r\\ninterface IDABot is IDABotController, \\r\\n    IDABotSettingModule, \\r\\n    IDABotStakingModule, \\r\\n    IDABotGovernModule, \\r\\n    IDABotWhitelistModule,\\r\\n    IDABotFundManagerModule \\r\\n{\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotCertLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\ninterface IDABotCertLocker is IRoboFiERC20 {\\r\\n    function asset() external view returns(IRoboFiERC20);\\r\\n    function detail() external view returns(LockerInfo memory);\\r\\n    function lockedBalance() external view returns(uint);\\r\\n    function unlockerable() external view returns(bool);\\r\\n    function tryUnlock() external returns(bool, uint);\\r\\n    function finalize() external payable;\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotCertToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IDABotCertTokenEvent {\\r\\n    /**\\r\\n    @dev Triggered when the bot owner locked an amount of certificate token for trading (or yield farming).\\r\\n    @param assetAmount the amount of the underlying asset locked.\\r\\n     */\\r\\n    event Lock(uint assetAmount);\\r\\n\\r\\n    /**\\r\\n    @dev Triggered when the bot owner unlocked an amount of certificate token.\\r\\n    @param assetAmount the amount of the underlying asset unlocked.\\r\\n     */\\r\\n    event Unlock(uint assetAmount);\\r\\n\\r\\n    /**\\r\\n    @dev Triggered when the amount of pegged assets of this certificate token has been changed.\\r\\n    @param amount the changed amount.\\r\\n    @param profitOrLoss true if the the pegged assets increase, false on otherwise.\\r\\n     */\\r\\n    event Compound(uint amount, bool profitOrLoss);\\r\\n}\\r\\n\\r\\ninterface IDABotCertToken is IERC20, IDABotCertTokenEvent {\\r\\n\\r\\n    /**\\r\\n    @dev Gets the total deposit of the underlying asset within this certificate.\\r\\n     */\\r\\n    function totalStake() external view returns(uint);\\r\\n\\r\\n    function totalLiquid() external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Queries the bot who owned this certificate.\\r\\n     */\\r\\n    function owner() external view returns(address);\\r\\n    \\r\\n    /**\\r\\n    @dev Gets the underlying asset of this certificate.\\r\\n     */\\r\\n    function asset() external view returns (IERC20);\\r\\n    \\r\\n    /**\\r\\n    @dev Returns the equivalent amount of the underlying asset for the given amount\\r\\n        of certificate tokens.\\r\\n    @param certTokenAmount - the amount of certificate tokens.\\r\\n     */\\r\\n    function value(uint certTokenAmount) external view returns(uint);\\r\\n\\r\\n    function lock(uint assetAmount) external;\\r\\n\\r\\n    function unlock(uint assetAmount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Mints an amount of certificate tokens to the given amount. The equivalent of\\r\\n        underlying asset should be tranfered to this certificate contract by the caller.\\r\\n    @param account - the address to recieve minted tokens.\\r\\n    @param certTokenAmount - the amount of tokens to mint.\\r\\n    @notice Only the owner bot can call this function.\\r\\n     */\\r\\n    function mint(address account, uint certTokenAmount) external returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens, and returns the equivalant amount of\\r\\n        the underlying asset to the specified account.\\r\\n    @param account - the address holing certificate tokens to burn.\\r\\n    @param certTokenAmount - the amount of certificate token to burn.\\r\\n    @return the equivalent amount of underlying asset tranfered to the specified account.\\r\\n    @notice Only the owner bot can call this function.\\r\\n     */\\r\\n    function burn(address account, uint certTokenAmount) external returns (uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens, and returns the equivalent amount of the \\r\\n        underlying asset to the caller.\\r\\n    @param amount - the amount of certificate token to burn.\\r\\n    @return the equivalent amount of underlying asset transfered to the caller.\\r\\n     */\\r\\n    function burn(uint amount) external returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens without returning any underlying assets.\\r\\n    @param account - the account holding certificate tokens to burn.\\r\\n    @param amount - the amount of certificate tokens to burn.\\r\\n    @notice Only owner bot can call this function.\\r\\n     */\\r\\n    function slash(address account, uint amount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Compound a given amount of the underlying asset to the total deposit. \\r\\n        The compoud could be either profit or loss.\\r\\n    @param amount - the compound amount.\\r\\n    @param profitOrLoss - `true` to increase the total deposit, `false` to decrease.\\r\\n     */\\r\\n    function compound(uint amount, bool profitOrLoss) external;\\r\\n\\r\\n    /**\\r\\n    @dev Deletes this certificate token contracts.\\r\\n     */\\r\\n    function finalize() external payable;\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\n\\r\\ninterface IDABotControllerEvent {\\r\\n    event BotAbandoned(bool value);\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    event ModuleHandlerChanged(bytes32 moduleId, address indexed oldModuleAddress, address indexed newModuleAddress);\\r\\n    event ModuleRegistered(bytes32 moduleId, address indexed moduleAddress, string name, string version);\\r\\n}\\r\\n\\r\\n/**\\r\\n@dev The generic interface of a DABot.\\r\\n */\\r\\ninterface IDABotController is IDABotControllerEvent {\\r\\n    function abandon(bool value) external;\\r\\n    function modulesInfo() external view returns(BotModuleInfo[] memory result);\\r\\n    function governToken() external view returns(address);\\r\\n    function qualifiedName() external view returns(string memory);\\r\\n    function metadata() external view returns(BotMetaData memory);\\r\\n    function setting() external view returns(BotSetting memory);\\r\\n    function botDetails() view external returns(BotDetail memory);\\r\\n    function updatePortfolio(address asset, uint maxCap, uint iboCap, uint weight) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotFundManagerModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nbytes32 constant IDABotFundManagerModuleID = keccak256('fundmanager.module');\\r\\n\\r\\ninterface IDABotFundManagerModuleEvent {\\r\\n    event Award(AwardingDetail[] pnl, uint[] totalStakes, uint[] certTokenValues);\\r\\n    event AwardCompound(address indexed asset, uint amount, uint mode);\\r\\n    event AwardBenefitciary(address indexed benefitciary, address indexed portfolioAsset, address indexed awardedAsset, uint amount, uint share, uint totalShare);\\r\\n    event AddBenefitciary(address indexed benefitciary);\\r\\n}\\r\\n\\r\\ninterface IDABotFundManagerModule is IDABotFundManagerModuleEvent {\\r\\n    \\r\\n    /**\\r\\n    @dev Gets detailed information about benefitciaries of staking rewards.\\r\\n     */\\r\\n    function benefitciaries() external view returns(BenefitciaryInfo[] memory result);\\r\\n\\r\\n    /**\\r\\n    @dev Replaces the current bot's benefitciaries with its bot template's\\r\\n    @notice Only bot owner can call.\\r\\n     */\\r\\n    function resetBenefitciaries() external; \\r\\n\\r\\n    /**\\r\\n    @dev Add new benefitciary\\r\\n    @param benefitciary - the benefitciary address. Should not be added before.\\r\\n     */\\r\\n    function addBenefitciary(address benefitciary) external;\\r\\n\\r\\n    /**\\r\\n     @dev Add profit/loss for each asset in the portfolio.\\r\\n     @param pnl - list of AwardingDetail data.\\r\\n     */\\r\\n    function award(AwardingDetail[] calldata pnl) external;\\r\\n\\r\\n    /**\\r\\n    @dev Checks the pending stake rewarod of a given account for specified assets.\\r\\n    @param account - the account to check.\\r\\n    @param assets - the list of assets to check for reward. \\r\\n        If empty list is passed, all assets in the portfolio are checked.\\r\\n    @param subVaults - the list of sub-vaults to check. \\r\\n        If empty list is passed, all sub vaults (i.e., [0, 1, 2]) are checked.\\r\\n     */\\r\\n    function pendingStakeReward(address account, address[] calldata assets, \\r\\n        bytes calldata subVaults) external view returns(StakingReward[] memory);\\r\\n\\r\\n    /**\\r\\n    @dev Checks the pending governance rewardsof a given account.\\r\\n    @param account - the account to check.\\r\\n    @param subVaults - the lst oof sub-vaults to check. \\r\\n        if empty list is passed, all sub vaults (i.e., [0, 1]) are checked.\\r\\n     */\\r\\n    function pendingGovernReward(address account, bytes calldata subVaults) external view returns(uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotGovernModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../interfaces/IBotVault.sol\\\";\\r\\n\\r\\nbytes32 constant IDABotGovernModuleID = keccak256('governance.module');\\r\\n\\r\\ninterface IDABotGovernModuleEvent {\\r\\n    event MintGToken(address indexed account, uint amountIn, uint fee, uint amountOut, uint updatedRate);\\r\\n}\\r\\n\\r\\ninterface IDABotGovernModule is IDABotGovernModuleEvent {\\r\\n\\r\\n    /**\\r\\n    @dev Creates staking vaults for governance tokens. This method should be called\\r\\n        internally only by the bot manager.\\r\\n     */\\r\\n    function createGovernVaults() external;\\r\\n\\r\\n    /**\\r\\n    @dev Gets the vaults of governance tokens.\\r\\n    @param account - the account to query depsot/reward information\\r\\n     */\\r\\n    function governVaults(address account) external view returns(VaultInfo[] memory);\\r\\n\\r\\n    /**\\r\\n    @dev Claims all pending governance rewards in all vaults.\\r\\n     */\\r\\n    function harvestGovernanceReward() external;\\r\\n\\r\\n    /**\\r\\n    @dev Queries the total pending governance rewards in all vaults\\r\\n    @param account - the account to query.\\r\\n     */\\r\\n    function governanceReward(address account) external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Gets the maximum amount of gToken that an account could mint from a bot.\\r\\n    @param account - the account to query.\\r\\n    @return the total mintable amount of gToken.\\r\\n     */\\r\\n    function mintableShare(address account) external view returns(uint);\\r\\n\\r\\n    /** \\r\\n    @dev Gets the details accounting for the amount of mintable shares.\\r\\n    @param account the account to query\\r\\n    @return an array of MintableShareDetail strucs.\\r\\n     */\\r\\n    function iboMintableShareDetail(address account) external view returns(MintableShareDetail[] memory); \\r\\n\\r\\n    /**\\r\\n    @dev Calculates the output for an account who mints shares with the given VICS amount.\\r\\n    @param account - the account to query\\r\\n    @param vicsAmount - the amount of VICS used to mint shares.\\r\\n    @return payment - the amount of VICS for minting shares.\\r\\n            shares - the amount of shares mintied.\\r\\n            fee - the amount of VICS for minting fee. \\r\\n     */\\r\\n    function calcOutShare(address account, uint vicsAmount) external view returns(uint payment, uint shares, uint fee);\\r\\n\\r\\n    /**\\r\\n    @dev Get the total balance of shares owned by the specified account. The total includes\\r\\n        shares within the account's wallet, and shares staked in bot's vaults.\\r\\n    @param account - the account to query.\\r\\n    @return the number of shares.\\r\\n     */\\r\\n    function shareOf(address account) external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Mints shares for the given VICS amount. Minted shares will directly stakes to BotVault for rewards.\\r\\n    @param vicsAmount - the amount of VICS used to mint shared.\\r\\n    @notice\\r\\n        Minted shares during IBO will be locked in separated pool, which onlly allow users to withdraw\\r\\n        after 1 month after the IBO ends.\\r\\n\\r\\n        VICS for payment will be kept inside the share contracts. Whereas, VICS for fee are transfered\\r\\n        to the tax address, configured in the platform configurator.\\r\\n     */\\r\\n    function mintShare(uint vicsAmount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of gToken and sends the corresponding VICS to caller's wallet.\\r\\n    @param amount - the amount of gToken to burn.\\r\\n     */\\r\\n    function burnShare(uint amount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Takes a snapshot of current vote powers (i.e. amount of gov)\\r\\n     */\\r\\n    function snapshot() external;\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotGovernToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IDABotGovernToken is IERC20 {\\r\\n\\r\\n    function owner() external view returns(address);\\r\\n    function asset() external view returns (IERC20);\\r\\n    function value(uint amount) external view returns(uint);\\r\\n    function mint(address account, uint amount) external;\\r\\n    function burn(uint amount) external returns(uint);\\r\\n\\r\\n    function snapshot() external;\\r\\n    function totalSupplyAt(uint256 snapshotId) external view returns(uint256);\\r\\n    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBotVault.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../../common/IRoboFiFactory.sol\\\";\\r\\nimport \\\"../../common/IConfigurator.sol\\\";\\r\\n\\r\\ninterface IDABotManagerEvent {\\r\\n    event BotRemoved(address indexed bot);\\r\\n    event BotDeployed(uint botId, address indexed bot, BotDetail detail); \\r\\n    event TemplateRegistered(address indexed template, string name, string version, uint8 templateType);\\r\\n}\\r\\n\\r\\ninterface IDABotManager is IDABotManagerEvent {\\r\\n    \\r\\n    function configurator() external view returns(IConfigurator);\\r\\n    function vaultManager() external view returns(IBotVaultManager);\\r\\n    function addTemplate(address template) external;\\r\\n    function templates() external view returns(address[] memory);\\r\\n    function isRegisteredTemplate(address template) external view returns(bool);\\r\\n    function isRegisteredBot(address botAccount) external view returns(bool);\\r\\n    function totalBots() external view returns(uint);\\r\\n    function botIdOf(string calldata qualifiedName) external view returns(int);\\r\\n    function queryBots(uint[] calldata botId) external view returns(BotDetail[] memory output);\\r\\n    function deployBot(address template, \\r\\n                        string calldata symbol, \\r\\n                        string calldata name,\\r\\n                        BotModuleInitData[] calldata initData\\r\\n                        ) external;\\r\\n    function snapshot(address botAccount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n@dev An common interface of a DABot module.\\r\\n */\\r\\ninterface IDABotModule {\\r\\n    function moduleInfo() external view returns(string memory name, string memory version, bytes32 moduleId);\\r\\n    function onRegister(address moduleAddress) external;\\r\\n    function onInitialize(bytes calldata data) external;\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotSettingModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nbytes32 constant IDABotSettingModuleID = keccak256('setting.module');\\r\\n\\r\\ninterface IDABotSettingModuleEvent {\\r\\n    event SettingChanged(uint what, BotSetting setting);  \\r\\n    event AddressWritten(bytes32 itemId, address indexed value);\\r\\n    event UintWritten(bytes32 itemId, uint value);\\r\\n    event BytesWritten(bytes32 itemId, bytes value);\\r\\n}\\r\\n\\r\\ninterface IDABotSettingModule is IDABotSettingModuleEvent {   \\r\\n    function status() external view returns(uint);\\r\\n    function iboTime() external view returns(uint startTime, uint endTime);\\r\\n    function stakingTime() external view returns(uint warmup, uint cooldown, uint unit);\\r\\n    function pricePolicy() external view returns(uint priceMul, uint commission);\\r\\n    function profitSharing() external view returns(uint128);\\r\\n    function setIBOTime(uint startTime, uint endTime) external;\\r\\n    function setStakingTime(uint warmup, uint cooldown, uint unit) external;\\r\\n    function setPricePolicy(uint priceMul, uint commission) external;\\r\\n    function setProfitSharing(uint sharingScheme) external;\\r\\n\\r\\n    function readAddress(bytes32 itemId, address defaultAddress) external view returns(address);\\r\\n    function readUint(bytes32 itemId, uint defaultValue) external view returns(uint);\\r\\n    function readBytes(bytes32 itemId, bytes calldata defaultValue) external view returns(bytes memory);\\r\\n\\r\\n    function writeAddress(bytes32 itemId, address value) external;\\r\\n    function writeUint(bytes32 itemId, uint value) external;\\r\\n    function writeBytes(bytes32 itemId, bytes calldata value) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotStakingModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IDABotCertToken.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../interfaces/IBotVault.sol\\\";\\r\\n\\r\\nbytes32 constant IDABotStakingModuleID = keccak256(\\\"staking.module\\\");\\r\\n\\r\\ninterface IDABotStakingModuleEvent {\\r\\n     event PortfolioUpdated(address indexed asset, address indexed certToken, uint maxCap, uint iboCap, uint weight);\\r\\n     event AssetRemoved(address indexed asset, address indexed certToken);   \\r\\n     event Stake(address indexed asset, uint amount, address indexed certToken, uint certAmount, address indexed locker);\\r\\n     event Unstake(address indexed certToken, uint certAmount, address indexed asset, \\r\\n          uint assetAmount, address indexed locker, uint releaseTime);\\r\\n}\\r\\n\\r\\ninterface IDABotStakingModule is IDABotStakingModuleEvent {\\r\\n\\r\\n     /**\\r\\n     @dev Gets the detailed information of the bot's portfolio.\\r\\n     @return the arrays of UserPortfolioAsset struct.\\r\\n      */\\r\\n     function portfolioDetails() external view returns(UserPortfolioAsset[] memory);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the portfolio information for the given asset.\\r\\n     @param asset - the asset to query.\\r\\n      */\\r\\n     function portfolioOf(address asset) external view returns(UserPortfolioAsset memory);\\r\\n\\r\\n     /**\\r\\n     @dev Adds or update an asset in the bot's portfolio.\\r\\n     @param asset - the crypto asset to add/update in the portfolio.\\r\\n     @param maxCap - the maximum amount of crypto asset to stake to the bot.\\r\\n     @param iboCap - the maximum amount of crypto asset to stake during the bot's IBO.\\r\\n     @param weight - the preference index of an asset in the portfolio. This is used\\r\\n               to calculate the mintable amount of governance shares in accoardance to \\r\\n               staked amount. \\r\\n\\r\\n               Gven the same USD-worth amount of two assets, the one with higher weight \\r\\n               will contribute more to the mintable amount of shares than the other.\\r\\n      */\\r\\n     function updatePortfolioAsset(address asset, uint maxCap, uint iboCap, uint weight) external;\\r\\n\\r\\n     /**\\r\\n     @dev Removes an asset from the bot's portfolio.\\r\\n     @param asset - the crypto asset to remove.\\r\\n     @notice asset could only be removed before the IBO. After that, asset could only be\\r\\n               remove if there is no tokens of this asset staked to the bot.\\r\\n      */\\r\\n     function removePortfolioAsset(address asset) external;\\r\\n\\r\\n     /**\\r\\n     @dev Creates vaults for each asset in the portfolio. This method should be called \\r\\n          internally by the bot manager.\\r\\n      */\\r\\n     function createPortfolioVaults() external;\\r\\n\\r\\n     /**\\r\\n     @dev Gets the vaults of certificate tokens in the portfolio.\\r\\n     @param certToken the certificate token.\\r\\n     @param account the account to query deposit/reward information\\r\\n      */\\r\\n     function certificateVaults(address certToken, address account) external view returns(VaultInfo[] memory);\\r\\n\\r\\n     /**\\r\\n     @dev Queries the total staking reward of the specific certificate token of the given account\\r\\n     @param certToken the certificate token.\\r\\n     @param account the account to query.\\r\\n      */\\r\\n     function stakingReward(address certToken, address account) external view returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Claims all pending staking rewards of the callers.\\r\\n      */\\r\\n     function harvestStakingReward() external; \\r\\n\\r\\n     /**\\r\\n     @dev Moves certificate tokens staked in warm-up vault to regular vault.\\r\\n          If the tokens are locked, the operation will be reverted.\\r\\n      */\\r\\n     function upgradeVault(address certToken) external;\\r\\n\\r\\n     /**\\r\\n     @dev Gets the maximum amount of crypto asset that could be staked  to the bot.\\r\\n     @param asset - the crypto asset to check.\\r\\n     @return the maximum amount of crypto asset to stake.\\r\\n      */\\r\\n     function getMaxStake(address asset) external returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Stakes an amount of crypto asset to the bot to receive staking certificate tokens.\\r\\n     @param asset - the asset to stake.\\r\\n     @param amount - the amount to stake.\\r\\n      */\\r\\n     function stake(address asset, uint amount) external;\\r\\n\\r\\n     /**\\r\\n     @dev Burns an amount of staking certificates to get back underlying asset.\\r\\n     @param certToken - the certificate to burn.\\r\\n     @param amount - the amount to burn.\\r\\n      */\\r\\n     function unstake(IDABotCertToken certToken, uint amount) external;\\r\\n\\r\\n     /**\\r\\n     @dev Gets the total staking balance of an account for the specific asset.\\r\\n          The balance includes pending stakes (i.e., warmup) and excludes \\r\\n          pending unstakes (i.e., cooldown)\\r\\n     @param account - the account to query.\\r\\n     @param asset - the crypto asset to query.\\r\\n     @return the total staked amount of the asset.\\r\\n      */\\r\\n     function stakeBalanceOf(address account, address asset) external view returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the total pending stake balance of an account for the specific asset.\\r\\n     @param account - the account to query.\\r\\n     @param asset - the asset to query.\\r\\n     @return the total pending stake.\\r\\n      */\\r\\n     function warmupBalanceOf(address account, address asset) external view returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Gets to total pending unstake balance of an account for the specific certificate.\\r\\n     @param account - the account to query.\\r\\n     @param certToken - the certificate token to query.\\r\\n     @return the total pending unstake.\\r\\n      */\\r\\n     function cooldownBalanceOf(address account, address certToken) external view returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the certificate contract of an asset of a bot.\\r\\n     @param asset - to crypto asset to query.\\r\\n     @return the address of the certificate contract.\\r\\n      */\\r\\n     function certificateOf(address asset) external view returns(address);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the underlying asset of a certificate.\\r\\n     @param certToken - the address of the certificate contract.\\r\\n     @return the address of the underlying crypto asset.\\r\\n      */\\r\\n     function assetOf(address certToken) external view returns(address);\\r\\n\\r\\n     /**\\r\\n     @dev Determines whether an account is a certificate locker.\\r\\n     @param account - the account to check.\\r\\n     @return true - if the account is an certificate locker instance creatd by the bot.\\r\\n      */\\r\\n     function isCertLocker(address account) external view returns(bool);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the details of lockers for pending stake.\\r\\n     @param account - the account to query.\\r\\n     @return the array of LockerInfo struct.\\r\\n      */\\r\\n     function warmupDetails(address account) external view returns(LockerInfo[] memory);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the details of lockers for pending unstake.\\r\\n     @param account - the account to query.\\r\\n     @return the array of LockerInfo struct.\\r\\n      */\\r\\n     function cooldownDetails(address account) external view returns(LockerInfo[] memory);\\r\\n\\r\\n     /**\\r\\n     @dev Releases tokens in all pending stake lockers. \\r\\n     @notice At most 20 lockers are unlocked. If the caller has more than 20, additional \\r\\n          transactions are required.\\r\\n      */\\r\\n     function releaseWarmups() external;\\r\\n\\r\\n     /**\\r\\n     @dev Releases token in all pending unstake lockers.\\r\\n     @notice At most 20 lockers are unlocked. If the caller has more than 20, additional \\r\\n          transactions are required.\\r\\n      */\\r\\n     function releaseCooldowns() external;\\r\\n\\r\\n     \\r\\n}\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/interfaces/IDABotWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nbytes32 constant IDABotWhitelistModuleID = keccak256(\\\"whitelist.module\\\");\\r\\n\\r\\nuint constant WHITELIST_CHECK_STAKE_USERS = 1;\\r\\nuint constant WHITELIST_CHECK_GOV_USERS = 2;\\r\\n\\r\\ninterface IDABotWhitelistModuleEvent {\\r\\n    event WhitelistScope(uint scope);\\r\\n    event WhitelistAdd(address indexed account, uint scope);\\r\\n    event WhitelistRemove(address indexed account);\\r\\n}\\r\\n\\r\\ninterface IDABotWhitelistModule is IDABotWhitelistModuleEvent {\\r\\n\\r\\n    function whitelistScope() external view returns(uint);\\r\\n    function setWhitelistScope(uint scope) external;\\r\\n    function addWhitelist(address account, uint scope) external;\\r\\n    function removeWhitelist(address account) external;\\r\\n    function isWhitelist(address acount, uint scope) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/setting/DABotSettingLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../../common/IConfigurator.sol\\\";\\r\\nimport \\\"../interfaces/IDABotSettingModule.sol\\\";\\r\\nimport \\\"../controller/DABotControllerLib.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nstruct SettingStorage { \\r\\n    mapping(bytes32 => address) addrStorage;\\r\\n    mapping(bytes32 => uint) uintStorage;\\r\\n    mapping(bytes32 => bytes) blobStorage;\\r\\n}\\r\\n\\r\\nlibrary DABotSettingLib {\\r\\n\\r\\n    using DABotSettingLib for BotSetting;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n    bytes32 constant SETTING_STORAGE_POSITION = keccak256(\\\"setting.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setting() internal view returns(BotSetting storage) {\\r\\n        return coredata().setting;\\r\\n    }\\r\\n\\r\\n    function settingStorage() internal pure returns(SettingStorage storage ds) {\\r\\n        bytes32 position = SETTING_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function status(BotSetting storage _setting) internal view returns(BotStatus result) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n\\r\\n        if (meta.abandoned) return BotStatus.ABANDONED;\\r\\n        if (block.timestamp < _setting.iboStartTime()) return BotStatus.PRE_IBO;\\r\\n        if (block.timestamp < _setting.iboEndTime()) return BotStatus.IN_IBO;\\r\\n        return BotStatus.ACTIVE;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @dev Ensures that following conditions are met\\r\\n        1) bot is not abandoned, and\\r\\n        2) either bot is pre-ibo stage and sender is bot owner, or the sender is vote controller module\\r\\n     */\\r\\n    function requireSettingChangable(address account) internal view {\\r\\n        BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n        \\r\\n        require(!_metadata.abandoned, Errors.BSL_BOT_IS_ABANDONED);\\r\\n\\r\\n        if (_metadata.isTemplate) {\\r\\n            require(account == _metadata.botOwner, Errors.BSL_CALLER_IS_NOT_OWNER);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        BotSetting storage _setting = DABotSettingLib.setting();\\r\\n        if (block.timestamp < _setting.iboStartTime()) {\\r\\n            require(account == _metadata.botOwner, Errors.BSL_CALLER_IS_NOT_OWNER);\\r\\n            return;\\r\\n        }\\r\\n        address executor = _metadata.configurator().addressOf(AddressBook.ADDR_GOVERNANCE_EXECUTOR);\\r\\n        require(account == executor, Errors.BSL_CALLER_IS_NOT_GOVERNANCE_EXECUTOR);\\r\\n    }\\r\\n\\r\\n    function readAddress(SettingStorage storage ds, bytes32 itemId, address defaultAddress) internal view returns(address result) {\\r\\n        result = ds.addrStorage[itemId]; \\r\\n        if (result == address(0)) { \\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n             if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readAddress(itemId, defaultAddress);\\r\\n            if (result == address(0))\\r\\n                result = _metadata.configurator().addressOf(itemId);\\r\\n            if (result == address(0))\\r\\n                result = defaultAddress;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function writeAddress(SettingStorage storage ds, bytes32 itemId, address value) internal {\\r\\n        ds.addrStorage[itemId] = value;\\r\\n    }\\r\\n\\r\\n    function readUint(SettingStorage storage ds, bytes32 itemId, uint defaultValue) internal view returns(uint result) {\\r\\n        result = ds.uintStorage[itemId];\\r\\n        if (result == 0) {\\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n            if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readUint(itemId, defaultValue);\\r\\n            if (result == 0)\\r\\n                result = _metadata.configurator().configOf(itemId);\\r\\n            if (result == 0)\\r\\n                result = defaultValue;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function writeUint(SettingStorage storage ds, bytes32 itemId, uint value) internal {\\r\\n        ds.uintStorage[itemId] = value;\\r\\n    }\\r\\n\\r\\n    function readBytes(SettingStorage storage ds, bytes32 itemId, bytes calldata defaultValue) internal view returns(bytes memory result) {\\r\\n        result = ds.blobStorage[itemId];\\r\\n        if (result.length == 0) {\\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n            if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readBytes(itemId, defaultValue);\\r\\n            if (result.length == 0)\\r\\n                result = _metadata.configurator().bytesConfigOf(itemId);\\r\\n            if (result.length == 0)\\r\\n                result = defaultValue;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function writeBytes(SettingStorage storage ds, bytes32 itemId, bytes calldata defaultValue) internal {\\r\\n        ds.blobStorage[itemId] = defaultValue;\\r\\n    }\\r\\n\\r\\n    function iboStartTime(BotSetting memory info) internal pure returns(uint) {\\r\\n        return info.iboTime & 0xFFFFFFFF;\\r\\n    }\\r\\n\\r\\n    function iboEndTime(BotSetting memory info) internal pure returns(uint) {\\r\\n        return info.iboTime >> 32;\\r\\n    }\\r\\n\\r\\n    function setIboTime(BotSetting storage info, uint start, uint end) internal {\\r\\n        require(start < end, Errors.BSL_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME);\\r\\n        info.iboTime = uint64((end << 32) | start);\\r\\n    }\\r\\n\\r\\n    function warmupTime(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.stakingTime & 0xFF;\\r\\n    }\\r\\n\\r\\n    function cooldownTime(BotSetting storage info) internal view returns(uint) {\\r\\n        return (info.stakingTime >> 8) & 0xFF;\\r\\n    }\\r\\n\\r\\n    function getStakingTimeMultiplier(BotSetting storage info) internal view returns (uint) {\\r\\n        uint unit = stakingTimeUnit(info);\\r\\n        if (unit == 0) return 1 days;\\r\\n        if (unit == 1) return 1 hours;\\r\\n        if (unit == 2) return 1 minutes;\\r\\n        return 1 seconds;\\r\\n    }\\r\\n\\r\\n    function stakingTimeUnit(BotSetting storage info) internal view returns (uint) {\\r\\n        return (info.stakingTime >> 16);\\r\\n    }\\r\\n\\r\\n    function setStakingTime(BotSetting storage info, uint warmup, uint cooldown, uint unit) internal {\\r\\n        info.stakingTime = uint24((unit << 16) | (cooldown << 8) | warmup);\\r\\n    }\\r\\n\\r\\n    function priceMultiplier(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.pricePolicy & 0xFFFF;\\r\\n    }\\r\\n\\r\\n    function commission(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.pricePolicy >> 16;\\r\\n    }\\r\\n\\r\\n    function setPricePolicy(BotSetting storage info, uint _priceMul, uint _commission) internal {\\r\\n        info.pricePolicy = uint32((_commission << 16) | _priceMul);\\r\\n    }\\r\\n\\r\\n    function profitShare(BotSetting storage info, uint actor) internal view returns(uint) {\\r\\n        return (info.profitSharing >> actor * 16) & 0xFFFF;\\r\\n    }\\r\\n\\r\\n    function setProfitShare(BotSetting storage info, uint sharingScheme) internal {\\r\\n        info.profitSharing = uint128(sharingScheme);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/staking/DABotStakingLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IDABotCertLocker.sol\\\";\\r\\nimport \\\"../interfaces/IDABotCertToken.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../controller/DABotControllerLib.sol\\\";\\r\\n\\r\\n\\r\\nstruct BotStakingData {\\r\\n    IRoboFiERC20[]  assets; \\r\\n    mapping(IRoboFiERC20 => PortfolioAsset) portfolio;\\r\\n    mapping(address => IDABotCertLocker[]) warmup;\\r\\n    mapping(address => IDABotCertLocker[]) cooldown;\\r\\n    mapping(address => bool) lockers;\\r\\n}\\r\\n\\r\\nlibrary DABotStakingLib {\\r\\n    bytes32 constant STAKING_STORAGE_POSITION = keccak256(\\\"staking.dabot.storage\\\");\\r\\n\\r\\n    using DABotStakingLib for BotStakingData;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n\\r\\n    function staking() internal pure returns(BotStakingData storage ds) {\\r\\n        bytes32 position = STAKING_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function stakeBalanceOf(BotStakingData storage ds, address account, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        IBotVaultManager vault = IDABotManager(meta.botManager).vaultManager();\\r\\n        IDABotCertToken certToken = ds.certificateOf(asset);\\r\\n        uint vID = vault.vaultId(address(certToken), 0);\\r\\n\\r\\n        return certToken.balanceOf(account)\\r\\n                // + ds.warmupBalanceOf(account, asset)\\r\\n                + vault.balanceOf(vID, account)\\r\\n                + vault.balanceOf(vID + 1, account)\\r\\n                + vault.balanceOf(vID + 2, account)\\r\\n                + ds.cooldownBalanceOf(account, ds.certificateOf(asset));\\r\\n    }\\r\\n\\r\\n    function totalStake(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        return IDABotCertToken(ds.portfolio[asset].certToken).totalStake();\\r\\n    }\\r\\n\\r\\n    function warmupBalanceOf(BotStakingData storage ds, address account, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        IDABotCertLocker[] storage lockers = ds.warmup[account];\\r\\n        return lockedBalance(lockers, address(asset));\\r\\n    }\\r\\n\\r\\n    function cooldownBalanceOf(BotStakingData storage ds, address account, IDABotCertToken certToken) internal view returns(uint) {\\r\\n        IDABotCertLocker[] storage lockers = ds.cooldown[account];\\r\\n        return lockedBalance(lockers, address(certToken.asset()));\\r\\n    }\\r\\n    \\r\\n    function certificateOf(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(IDABotCertToken) {\\r\\n        return IDABotCertToken(ds.portfolio[asset].certToken); \\r\\n    }\\r\\n\\r\\n    function assetOf(address certToken) public view returns(IERC20) {\\r\\n        return IDABotCertToken(certToken).asset(); \\r\\n    }\\r\\n\\r\\n    function lockedBalance(IDABotCertLocker[] storage lockers, address asset) internal view returns(uint result) {\\r\\n        result = 0;\\r\\n        for (uint i = 0; i < lockers.length; i++) \\r\\n            if (address(lockers[i].asset()) == asset)\\r\\n                result += lockers[i].lockedBalance();\\r\\n    }\\r\\n\\r\\n    function portfolioDetails(BotStakingData storage ds) internal view returns(UserPortfolioAsset[] memory output) {\\r\\n        output = new UserPortfolioAsset[](ds.assets.length);\\r\\n        for(uint i = 0; i < ds.assets.length; i++) {\\r\\n            IRoboFiERC20 asset = ds.assets[i];\\r\\n            output[i].asset = address(asset);\\r\\n            output[i].info = ds.portfolio[asset];\\r\\n            output[i].userStake = ds.stakeBalanceOf(msg.sender, asset);\\r\\n            output[i].totalStake = ds.totalStake(asset);\\r\\n            output[i].certSupply = IERC20(ds.portfolio[asset].certToken).totalSupply();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function portfolioOf(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(UserPortfolioAsset memory  output) {\\r\\n        output.asset = address(asset);\\r\\n        output.info = ds.portfolio[asset];\\r\\n        output.userStake = ds.stakeBalanceOf(msg.sender, asset);\\r\\n        output.totalStake = ds.totalStake(asset);\\r\\n        output.certSupply = IERC20(ds.portfolio[asset].certToken).totalSupply();\\r\\n    }\\r\\n\\r\\n    function updatePortfolioAsset(BotStakingData storage ds, IRoboFiERC20 asset, uint maxCap, uint iboCap, uint weight) internal {\\r\\n        PortfolioAsset storage pAsset = ds.portfolio[asset];\\r\\n\\r\\n        if (address(pAsset.certToken) == address(0)) {\\r\\n            pAsset.certToken = DABotMetaLib.metadata().deployCertToken(address(asset));\\r\\n            ds.assets.push(asset);\\r\\n        }\\r\\n\\r\\n        if (maxCap > 0) pAsset.cap = maxCap;\\r\\n        if (iboCap > 0) pAsset.iboCap = iboCap;\\r\\n        if (weight > 0) pAsset.weight = weight;\\r\\n\\r\\n        uint _totalStake = IDABotCertToken(pAsset.certToken).totalStake();\\r\\n\\r\\n        require((pAsset.cap >= _totalStake) && (pAsset.cap >= pAsset.iboCap), Errors.BSTMOD_INVALID_STAKING_CAP);\\r\\n    }\\r\\n\\r\\n    function removePortfolioAsset(BotStakingData storage ds, IRoboFiERC20 asset) internal returns(address) {\\r\\n        require(address(asset) != address(0), Errors.BSTMOD_ASSET_IS_ZERO);\\r\\n        for(uint i = 0; i < ds.assets.length; i++)\\r\\n            if (address(ds.assets[i]) == address(asset)) {\\r\\n                address certToken = ds.portfolio[asset].certToken;\\r\\n                IDABotCertToken(certToken).finalize(); \\r\\n                delete ds.portfolio[asset];\\r\\n                ds.assets[i] = ds.assets[ds.assets.length - 1];\\r\\n                ds.assets.pop();\\r\\n                return certToken;\\r\\n            }\\r\\n        revert(Errors.BSTMOD_PORTFOLIO_ASSET_NOT_FOUND);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/dabot/templates/CEXDABotV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\nimport \\\"../controller/DABotController.sol\\\";\\r\\nimport \\\"../interfaces/IDABotSettingModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotStakingModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotGovernModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotFundManagerModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotWhitelist.sol\\\";\\r\\nimport \\\"../interfaces/IDABot.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../fundmanager/DABotFundManagerLib.sol\\\";\\r\\n\\r\\ncontract CEXDABotV2 is DABotModuleController, \\r\\n                    IDABotSettingModuleEvent, \\r\\n                    IDABotStakingModuleEvent, \\r\\n                    IDABotGovernModuleEvent,\\r\\n                    IDABotFundManagerModuleEvent,\\r\\n                    IDABotWhitelistModuleEvent,\\r\\n                    IERC165\\r\\n{\\r\\n\\r\\n    using DABotFundManagerLib for FundManagementData;\\r\\n\\r\\n    constructor(\\r\\n        address certToken,\\r\\n        address govToken,\\r\\n        address cooldownLocker,\\r\\n        address[] memory functionModules\\r\\n    ) DABotModuleController('CEX DABot V2', 'v0.2.211201') \\r\\n    {      \\r\\n        updateModuleHandler(BOT_MODULE_CERTIFICATE_TOKEN, certToken);\\r\\n        updateModuleHandler(BOT_MODULE_GOVERNANCE_TOKEN, govToken);\\r\\n        updateModuleHandler(BOT_MODULE_COOLDOWN_LOCKER, cooldownLocker);\\r\\n\\r\\n        for(uint i = 0; i < functionModules.length; i ++) \\r\\n            registerModule(functionModules[i]);\\r\\n\\r\\n        FundManagementData storage fundData = DABotFundManagerLib.fundData();\\r\\n        fundData.addBenefitciary(BOT_CREATOR_BENEFITCIARY);\\r\\n        fundData.addBenefitciary(GOV_USER_BENEFITCIARY);\\r\\n        fundData.addBenefitciary(STAKE_USER_BENEFITCIARY);  \\r\\n    }\\r\\n    \\r\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\r\\n        return (interfaceId == type(IERC165).interfaceId) ||\\r\\n                (interfaceId == type(IDABot).interfaceId)\\r\\n        ;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/D/Snap/marketplace/robofi-contracts-core/contracts/token/IRoboFiERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IRoboFiERC20 is IERC20 {\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"certToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"govToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cooldownLocker\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"functionModules\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"benefitciary\",\"type\":\"address\"}],\"name\":\"AddBenefitciary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"itemId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"AddressWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"certToken\",\"type\":\"address\"}],\"name\":\"AssetRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"compound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compoundMode\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct AwardingDetail[]\",\"name\":\"pnl\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"totalStakes\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"certTokenValues\",\"type\":\"uint256[]\"}],\"name\":\"Award\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"benefitciary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"portfolioAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"awardedAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShare\",\"type\":\"uint256\"}],\"name\":\"AwardBenefitciary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mode\",\"type\":\"uint256\"}],\"name\":\"AwardCompound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"BotAbandoned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"itemId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"name\":\"BytesWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedRate\",\"type\":\"uint256\"}],\"name\":\"MintGToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldModuleAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newModuleAddress\",\"type\":\"address\"}],\"name\":\"ModuleHandlerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"ModuleRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"certToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxCap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iboCap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"PortfolioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"what\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"iboTime\",\"type\":\"uint64\"},{\"internalType\":\"uint24\",\"name\":\"stakingTime\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"pricePolicy\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"profitSharing\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"initDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initFounderShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboShare\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct BotSetting\",\"name\":\"setting\",\"type\":\"tuple\"}],\"name\":\"SettingChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"certToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"certAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"itemId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"UintWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"certToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"certAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releaseTime\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scope\",\"type\":\"uint256\"}],\"name\":\"WhitelistAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistRemove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scope\",\"type\":\"uint256\"}],\"name\":\"WhitelistScope\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"abandon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"botAddress\",\"type\":\"address\"},{\"internalType\":\"enum BotStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"botType\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"botSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"botName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"governToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"templateName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"templateVersion\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"iboStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"warmup\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceMul\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commissionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initFounderShare\",\"type\":\"uint256\"},{\"internalType\":\"uint144\",\"name\":\"profitSharing\",\"type\":\"uint144\"},{\"internalType\":\"uint256\",\"name\":\"maxShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"circulatedShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userShare\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"certToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct PortfolioAsset\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"userStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"certSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct UserPortfolioAsset[]\",\"name\":\"portfolio\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BotDetail\",\"name\":\"output\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governToken\",\"outputs\":[{\"internalType\":\"contract IDABotGovernToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"botType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"abandoned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isTemplate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"botOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"botManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"botTemplate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"}],\"internalType\":\"struct BotMetaData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"name\":\"module\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"ids\",\"type\":\"bytes32[]\"}],\"name\":\"moduleHandlerInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"moduleOfSelector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modulesInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"internalType\":\"struct BotModuleInfo[]\",\"name\":\"result\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qualifiedName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moduleHandler\",\"type\":\"address\"}],\"name\":\"registerModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setting\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"iboTime\",\"type\":\"uint64\"},{\"internalType\":\"uint24\",\"name\":\"stakingTime\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"pricePolicy\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"profitSharing\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"initDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initFounderShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboShare\",\"type\":\"uint256\"}],\"internalType\":\"struct BotSetting\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newModuleAddress\",\"type\":\"address\"}],\"name\":\"updateModuleHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CEXDABotV2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000096dc2e21e2ab21d309e79442d87e179f30a5de6f00000000000000000000000025e5792c1e1f4f67dd2bde90735033e0abfd568f00000000000000000000000035dbad4f16ee9d11cf1a7a77da93a4e68666306f00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000005000000000000000000000000d4e434a08d7971661bf88afaf991290f6de202a700000000000000000000000077446d79e59c96aeb739912a7deb3cac5a1b89d1000000000000000000000000023bb44d3f0e2298d2408a5a9d922a8357e5f699000000000000000000000000219265d9a29d06f2745b8ba8b9feeefe78572ed80000000000000000000000006b05fe6b162d97d924251868f8cf1c1048c95887", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}