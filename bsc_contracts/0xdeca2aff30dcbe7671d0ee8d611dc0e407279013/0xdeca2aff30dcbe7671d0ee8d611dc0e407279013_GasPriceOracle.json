{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CapacitorFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./interfaces/ICapacitorFactory.sol\\\";\\nimport \\\"./capacitors/SingleCapacitor.sol\\\";\\nimport \\\"./capacitors/HashChainCapacitor.sol\\\";\\nimport \\\"./decapacitors/SingleDecapacitor.sol\\\";\\nimport \\\"./decapacitors/HashChainDecapacitor.sol\\\";\\n\\nimport \\\"./libraries/RescueFundsLib.sol\\\";\\nimport \\\"./utils/AccessControlExtended.sol\\\";\\nimport {RESCUE_ROLE} from \\\"./utils/AccessRoles.sol\\\";\\n\\ncontract CapacitorFactory is ICapacitorFactory, AccessControlExtended {\\n    uint256 private constant SINGLE_CAPACITOR = 1;\\n    uint256 private constant HASH_CHAIN_CAPACITOR = 2;\\n\\n    constructor(address owner_) AccessControlExtended(owner_) {\\n        _grantRole(RESCUE_ROLE, owner_);\\n    }\\n\\n    function deploy(\\n        uint256 capacitorType_,\\n        uint256 /** siblingChainSlug */,\\n        uint256 /** maxPacketLength */\\n    ) external override returns (ICapacitor, IDecapacitor) {\\n        address owner = this.owner();\\n\\n        if (capacitorType_ == SINGLE_CAPACITOR) {\\n            return (\\n                new SingleCapacitor(msg.sender, owner),\\n                new SingleDecapacitor(owner)\\n            );\\n        }\\n        if (capacitorType_ == HASH_CHAIN_CAPACITOR) {\\n            return (\\n                new HashChainCapacitor(msg.sender, owner),\\n                new HashChainDecapacitor(owner)\\n            );\\n        }\\n        revert InvalidCapacitorType();\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/capacitors/BaseCapacitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/ICapacitor.sol\\\";\\nimport \\\"../utils/AccessControlExtended.sol\\\";\\nimport \\\"../libraries/RescueFundsLib.sol\\\";\\nimport {RESCUE_ROLE} from \\\"../utils/AccessRoles.sol\\\";\\n\\nabstract contract BaseCapacitor is ICapacitor, AccessControlExtended {\\n    /// an incrementing id for each new packet created\\n    uint64 internal _nextPacketCount;\\n    uint64 internal _nextSealCount;\\n\\n    address public immutable socket;\\n\\n    /// maps the packet id with the root hash generated while adding message\\n    mapping(uint64 => bytes32) internal _roots;\\n\\n    error NoPendingPacket();\\n    error OnlySocket();\\n\\n    modifier onlySocket() {\\n        if (msg.sender != socket) revert OnlySocket();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice initialises the contract with socket address\\n     */\\n    constructor(address socket_, address owner_) AccessControlExtended(owner_) {\\n        socket = socket_;\\n    }\\n\\n    function sealPacket(\\n        uint256\\n    ) external virtual override onlySocket returns (bytes32, uint64) {\\n        uint64 packetCount = _nextSealCount++;\\n        if (_roots[packetCount] == bytes32(0)) revert NoPendingPacket();\\n\\n        bytes32 root = _roots[packetCount];\\n        return (root, packetCount);\\n    }\\n\\n    /// returns the latest packet details to be sealed\\n    /// @inheritdoc ICapacitor\\n    function getNextPacketToBeSealed()\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes32, uint64)\\n    {\\n        uint64 toSeal = _nextSealCount;\\n        return (_roots[toSeal], toSeal);\\n    }\\n\\n    /// returns the root of packet for given id\\n    /// @inheritdoc ICapacitor\\n    function getRootByCount(\\n        uint64 id_\\n    ) external view virtual override returns (bytes32) {\\n        return _roots[id_];\\n    }\\n\\n    function getLatestPacketCount() external view returns (uint256) {\\n        return _nextPacketCount == 0 ? 0 : _nextPacketCount - 1;\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/capacitors/HashChainCapacitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./BaseCapacitor.sol\\\";\\n\\ncontract HashChainCapacitor is BaseCapacitor {\\n    uint256 private _chainLength;\\n    uint256 private constant _MAX_LEN = 10;\\n\\n    /**\\n     * @notice initialises the contract with socket address\\n     */\\n    constructor(\\n        address socket_,\\n        address owner_\\n    ) BaseCapacitor(socket_, owner_) {\\n        _grantRole(RESCUE_ROLE, owner_);\\n    }\\n\\n    /// adds the packed message to a packet\\n    /// @inheritdoc ICapacitor\\n    function addPackedMessage(\\n        bytes32 packedMessage_\\n    ) external override onlySocket {\\n        uint64 packetCount = _nextPacketCount;\\n\\n        _roots[packetCount] = keccak256(\\n            abi.encode(_roots[packetCount], packedMessage_)\\n        );\\n        _chainLength++;\\n\\n        if (_chainLength == _MAX_LEN) {\\n            _nextPacketCount++;\\n            _chainLength = 0;\\n        }\\n\\n        emit MessageAdded(packedMessage_, packetCount, _roots[packetCount]);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/capacitors/SingleCapacitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./BaseCapacitor.sol\\\";\\n\\ncontract SingleCapacitor is BaseCapacitor {\\n    /**\\n     * @notice initialises the contract with socket address\\n     */\\n    constructor(\\n        address socket_,\\n        address owner_\\n    ) BaseCapacitor(socket_, owner_) {\\n        _grantRole(RESCUE_ROLE, owner_);\\n    }\\n\\n    /// adds the packed message to a packet\\n    /// @inheritdoc ICapacitor\\n    function addPackedMessage(\\n        bytes32 packedMessage_\\n    ) external override onlySocket {\\n        uint64 packetCount = _nextPacketCount;\\n        _roots[packetCount] = packedMessage_;\\n        _nextPacketCount++;\\n\\n        emit MessageAdded(packedMessage_, packetCount, packedMessage_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/decapacitors/HashChainDecapacitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IDecapacitor.sol\\\";\\nimport \\\"../libraries/RescueFundsLib.sol\\\";\\nimport \\\"../utils/AccessControlExtended.sol\\\";\\nimport {RESCUE_ROLE} from \\\"../utils/AccessRoles.sol\\\";\\n\\ncontract HashChainDecapacitor is IDecapacitor, AccessControlExtended {\\n    /**\\n     * @notice initialises the contract with owner address\\n     */\\n    constructor(address owner_) AccessControlExtended(owner_) {\\n        _grantRole(RESCUE_ROLE, owner_);\\n    }\\n\\n    /// returns if the packed message is the part of a merkle tree or not\\n    /// @inheritdoc IDecapacitor\\n    function verifyMessageInclusion(\\n        bytes32 root_,\\n        bytes32 packedMessage_,\\n        bytes calldata proof_\\n    ) external pure override returns (bool) {\\n        bytes32[] memory chain = abi.decode(proof_, (bytes32[]));\\n        uint256 len = chain.length;\\n        bytes32 generatedRoot;\\n        bool isIncluded;\\n        for (uint256 i = 0; i < len; i++) {\\n            generatedRoot = keccak256(abi.encode(generatedRoot, chain[i]));\\n            if (chain[i] == packedMessage_) isIncluded = true;\\n        }\\n\\n        return root_ == generatedRoot && isIncluded;\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/decapacitors/SingleDecapacitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IDecapacitor.sol\\\";\\nimport \\\"../libraries/RescueFundsLib.sol\\\";\\nimport \\\"../utils/AccessControlExtended.sol\\\";\\nimport {RESCUE_ROLE} from \\\"../utils/AccessRoles.sol\\\";\\n\\ncontract SingleDecapacitor is IDecapacitor, AccessControlExtended {\\n    /**\\n     * @notice initialises the contract with owner address\\n     */\\n    constructor(address owner_) AccessControlExtended(owner_) {\\n        _grantRole(RESCUE_ROLE, owner_);\\n    }\\n\\n    /// returns if the packed message is the part of a merkle tree or not\\n    /// @inheritdoc IDecapacitor\\n    function verifyMessageInclusion(\\n        bytes32 root_,\\n        bytes32 packedMessage_,\\n        bytes calldata\\n    ) external pure override returns (bool) {\\n        return root_ == packedMessage_;\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/examples/Counter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPlug.sol\\\";\\nimport \\\"../interfaces/ISocket.sol\\\";\\n\\ncontract Counter is IPlug {\\n    // immutables\\n    address public immutable socket;\\n\\n    address public owner;\\n\\n    // application state\\n    uint256 public counter;\\n\\n    // application ops\\n    bytes32 public constant OP_ADD = keccak256(\\\"OP_ADD\\\");\\n    bytes32 public constant OP_SUB = keccak256(\\\"OP_SUB\\\");\\n\\n    error OnlyOwner();\\n\\n    constructor(address socket_) {\\n        socket = socket_;\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"can only be called by owner\\\");\\n        _;\\n    }\\n\\n    function localAddOperation(uint256 amount_) external {\\n        _addOperation(amount_);\\n    }\\n\\n    function localSubOperation(uint256 amount_) external {\\n        _subOperation(amount_);\\n    }\\n\\n    function remoteAddOperation(\\n        uint256 chainSlug_,\\n        uint256 amount_,\\n        uint256 msgGasLimit_\\n    ) external payable {\\n        bytes memory payload = abi.encode(OP_ADD, amount_, msg.sender);\\n        _outbound(chainSlug_, msgGasLimit_, payload);\\n    }\\n\\n    function remoteSubOperation(\\n        uint256 chainSlug_,\\n        uint256 amount_,\\n        uint256 msgGasLimit_\\n    ) external payable {\\n        bytes memory payload = abi.encode(OP_SUB, amount_, msg.sender);\\n        _outbound(chainSlug_, msgGasLimit_, payload);\\n    }\\n\\n    function inbound(\\n        uint256,\\n        bytes calldata payload_\\n    ) external payable override {\\n        require(msg.sender == socket, \\\"Counter: Invalid Socket\\\");\\n        (bytes32 operationType, uint256 amount, ) = abi.decode(\\n            payload_,\\n            (bytes32, uint256, address)\\n        );\\n\\n        if (operationType == OP_ADD) {\\n            _addOperation(amount);\\n        } else if (operationType == OP_SUB) {\\n            _subOperation(amount);\\n        } else {\\n            revert(\\\"CounterMock: Invalid Operation\\\");\\n        }\\n    }\\n\\n    function _outbound(\\n        uint256 targetChain_,\\n        uint256 msgGasLimit_,\\n        bytes memory payload_\\n    ) private {\\n        ISocket(socket).outbound{value: msg.value}(\\n            targetChain_,\\n            msgGasLimit_,\\n            payload_\\n        );\\n    }\\n\\n    //\\n    // base ops\\n    //\\n    function _addOperation(uint256 amount_) private {\\n        counter += amount_;\\n    }\\n\\n    function _subOperation(uint256 amount_) private {\\n        require(counter > amount_, \\\"CounterMock: Subtraction Overflow\\\");\\n        counter -= amount_;\\n    }\\n\\n    // settings\\n    function setSocketConfig(\\n        uint256 remoteChainSlug_,\\n        address remotePlug_,\\n        address switchboard_\\n    ) external onlyOwner {\\n        ISocket(socket).connect(\\n            remoteChainSlug_,\\n            remotePlug_,\\n            switchboard_,\\n            switchboard_\\n        );\\n    }\\n\\n    function setupComplete() external {\\n        owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/examples/Messenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPlug.sol\\\";\\nimport \\\"../interfaces/ISocket.sol\\\";\\nimport \\\"../interfaces/ITransmitManager.sol\\\";\\nimport \\\"../interfaces/ISwitchboard.sol\\\";\\nimport \\\"../interfaces/IExecutionManager.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\ncontract Messenger is IPlug, Ownable(msg.sender) {\\n    // immutables\\n    ISocket public immutable _socket__;\\n    uint256 public immutable _localChainSlug;\\n\\n    bytes32 public _message;\\n    uint256 public _msgGasLimit;\\n\\n    bytes32 public constant _PING = keccak256(\\\"PING\\\");\\n    bytes32 public constant _PONG = keccak256(\\\"PONG\\\");\\n\\n    error NoSocketFee();\\n\\n    constructor(address socket_, uint256 chainSlug_, uint256 msgGasLimit_) {\\n        _socket__ = ISocket(socket_);\\n        _localChainSlug = chainSlug_;\\n\\n        _msgGasLimit = msgGasLimit_;\\n    }\\n\\n    receive() external payable {}\\n\\n    function updateMsgGasLimit(uint256 msgGasLimit_) external onlyOwner {\\n        _msgGasLimit = msgGasLimit_;\\n    }\\n\\n    function removeGas(address payable receiver_) external onlyOwner {\\n        receiver_.transfer(address(this).balance);\\n    }\\n\\n    function sendLocalMessage(bytes32 message_) external {\\n        _updateMessage(message_);\\n    }\\n\\n    function sendRemoteMessage(\\n        uint32 remoteChainSlug_,\\n        bytes32 message_\\n    ) external payable {\\n        bytes memory payload = abi.encode(_localChainSlug, message_);\\n        _outbound(remoteChainSlug_, payload);\\n    }\\n\\n    function inbound(\\n        uint256,\\n        bytes calldata payload_\\n    ) external payable override {\\n        require(msg.sender == address(_socket__), \\\"Counter: Invalid Socket\\\");\\n        (uint32 remoteChainSlug, bytes32 msgDecoded) = abi.decode(\\n            payload_,\\n            (uint32, bytes32)\\n        );\\n\\n        _updateMessage(msgDecoded);\\n\\n        bytes memory newPayload = abi.encode(\\n            _localChainSlug,\\n            msgDecoded == _PING ? _PONG : _PING\\n        );\\n        _outbound(remoteChainSlug, newPayload);\\n    }\\n\\n    // settings\\n    function setSocketConfig(\\n        uint32 remoteChainSlug_,\\n        address remotePlug_,\\n        address switchboard_\\n    ) external onlyOwner {\\n        _socket__.connect(\\n            remoteChainSlug_,\\n            remotePlug_,\\n            switchboard_,\\n            switchboard_\\n        );\\n    }\\n\\n    function message() external view returns (bytes32) {\\n        return _message;\\n    }\\n\\n    function _updateMessage(bytes32 message_) private {\\n        _message = message_;\\n    }\\n\\n    function _outbound(uint32 targetChain_, bytes memory payload_) private {\\n        uint256 fee = _socket__.getMinFees(\\n            _msgGasLimit,\\n            targetChain_,\\n            address(this)\\n        );\\n        if (!(address(this).balance >= fee)) revert NoSocketFee();\\n        _socket__.outbound{value: fee}(targetChain_, _msgGasLimit, payload_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ExecutionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.7;\\n\\nimport \\\"./interfaces/IExecutionManager.sol\\\";\\nimport \\\"./interfaces/IGasPriceOracle.sol\\\";\\nimport \\\"./utils/AccessControlExtended.sol\\\";\\nimport \\\"./libraries/RescueFundsLib.sol\\\";\\nimport \\\"./libraries/SignatureVerifierLib.sol\\\";\\nimport \\\"./libraries/FeesHelper.sol\\\";\\nimport {WITHDRAW_ROLE, RESCUE_ROLE, GOVERNANCE_ROLE, EXECUTOR_ROLE} from \\\"./utils/AccessRoles.sol\\\";\\n\\ncontract ExecutionManager is IExecutionManager, AccessControlExtended {\\n    IGasPriceOracle public gasPriceOracle__;\\n    event GasPriceOracleSet(address gasPriceOracle);\\n\\n    constructor(\\n        IGasPriceOracle gasPriceOracle_,\\n        address owner_\\n    ) AccessControlExtended(owner_) {\\n        gasPriceOracle__ = IGasPriceOracle(gasPriceOracle_);\\n    }\\n\\n    function isExecutor(\\n        bytes32 packedMessage,\\n        bytes memory sig\\n    ) external view override returns (address executor, bool isValidExecutor) {\\n        executor = SignatureVerifierLib.recoverSignerFromDigest(\\n            packedMessage,\\n            sig\\n        );\\n        isValidExecutor = _hasRole(EXECUTOR_ROLE, executor);\\n    }\\n\\n    // these details might be needed for on-chain fee distribution later\\n    function updateExecutionFees(address, uint256, bytes32) external override {}\\n\\n    function payFees(\\n        uint256 msgGasLimit_,\\n        uint32 siblingChainSlug_\\n    ) external payable override {}\\n\\n    function getMinFees(\\n        uint256 msgGasLimit_,\\n        uint32 siblingChainSlug_\\n    ) external view override returns (uint256) {\\n        return _getMinExecutionFees(msgGasLimit_, siblingChainSlug_);\\n    }\\n\\n    function _getMinExecutionFees(\\n        uint256 msgGasLimit_,\\n        uint32 dstChainSlug_\\n    ) internal view returns (uint256) {\\n        uint256 dstRelativeGasPrice = gasPriceOracle__.relativeGasPrice(\\n            dstChainSlug_\\n        );\\n        return msgGasLimit_ * dstRelativeGasPrice;\\n    }\\n\\n    /**\\n     * @notice updates gasPriceOracle__\\n     * @param gasPriceOracle_ address of Gas Price Oracle\\n     */\\n    function setGasPriceOracle(\\n        address gasPriceOracle_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        gasPriceOracle__ = IGasPriceOracle(gasPriceOracle_);\\n        emit GasPriceOracleSet(gasPriceOracle_);\\n    }\\n\\n    function withdrawFees(address account_) external onlyRole(WITHDRAW_ROLE) {\\n        FeesHelper.withdrawFees(account_);\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GasPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./interfaces/IGasPriceOracle.sol\\\";\\nimport \\\"./interfaces/ITransmitManager.sol\\\";\\nimport \\\"./utils/AccessControlExtended.sol\\\";\\nimport \\\"./libraries/RescueFundsLib.sol\\\";\\nimport {GOVERNANCE_ROLE, RESCUE_ROLE} from \\\"./utils/AccessRoles.sol\\\";\\n\\ncontract GasPriceOracle is IGasPriceOracle, AccessControlExtended {\\n    ITransmitManager public transmitManager__;\\n\\n    // plugs/switchboards/transmitter can use it to ensure prices are updated\\n    mapping(uint256 => uint256) public updatedAt;\\n    // chain slug => relative gas price\\n    mapping(uint32 => uint256) public override relativeGasPrice;\\n\\n    // transmitter => nextNonce\\n    mapping(address => uint256) public nextNonce;\\n\\n    // gas price of source chain\\n    uint256 public override sourceGasPrice;\\n    uint32 public immutable chainSlug;\\n\\n    event TransmitManagerUpdated(address transmitManager);\\n    event RelativeGasPriceUpdated(\\n        uint256 dstChainSlug,\\n        uint256 relativeGasPrice\\n    );\\n    event SourceGasPriceUpdated(uint256 sourceGasPrice);\\n\\n    error TransmitterNotFound();\\n    error InvalidNonce();\\n\\n    constructor(\\n        address owner_,\\n        uint32 chainSlug_\\n    ) AccessControlExtended(owner_) {\\n        chainSlug = chainSlug_;\\n    }\\n\\n    /**\\n     * @notice update the sourceGasPrice which is to be used in various computations\\n     * @param sourceGasPrice_ gas price of source chain\\n     */\\n    function setSourceGasPrice(\\n        uint256 nonce_,\\n        uint256 sourceGasPrice_,\\n        bytes calldata signature_\\n    ) external {\\n        (address transmitter, bool isTransmitter) = transmitManager__\\n            .checkTransmitter(\\n                chainSlug,\\n                keccak256(abi.encode(chainSlug, nonce_, sourceGasPrice_)),\\n                signature_\\n            );\\n\\n        if (!isTransmitter) revert TransmitterNotFound();\\n\\n        uint256 nonce = nextNonce[transmitter]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        sourceGasPrice = sourceGasPrice_;\\n        updatedAt[chainSlug] = block.timestamp;\\n\\n        emit SourceGasPriceUpdated(sourceGasPrice);\\n    }\\n\\n    /**\\n     * @dev the relative prices are calculated as:\\n     * relativeGasPrice = (siblingGasPrice * siblingGasUSDPrice)/srcGasUSDPrice\\n     * It is assumed that precision of relative gas price will be same as src native tokens\\n     * So that when it is multiplied with gas limits at other contracts, we get correct values.\\n     */\\n    function setRelativeGasPrice(\\n        uint32 siblingChainSlug_,\\n        uint256 nonce_,\\n        uint256 relativeGasPrice_,\\n        bytes calldata signature_\\n    ) external {\\n        (address transmitter, bool isTransmitter) = transmitManager__\\n            .checkTransmitter(\\n                siblingChainSlug_,\\n                keccak256(\\n                    abi.encode(\\n                        chainSlug,\\n                        siblingChainSlug_,\\n                        nonce_,\\n                        relativeGasPrice_\\n                    )\\n                ),\\n                signature_\\n            );\\n\\n        if (!isTransmitter) revert TransmitterNotFound();\\n        uint256 nonce = nextNonce[transmitter]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        relativeGasPrice[siblingChainSlug_] = relativeGasPrice_;\\n        updatedAt[siblingChainSlug_] = block.timestamp;\\n\\n        emit RelativeGasPriceUpdated(siblingChainSlug_, relativeGasPrice_);\\n    }\\n\\n    function getGasPrices(\\n        uint32 siblingChainSlug_\\n    ) external view override returns (uint256, uint256) {\\n        return (sourceGasPrice, relativeGasPrice[siblingChainSlug_]);\\n    }\\n\\n    function setTransmitManager(\\n        ITransmitManager transmitManager_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        transmitManager__ = transmitManager_;\\n        emit TransmitManagerUpdated(address(transmitManager_));\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICapacitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\ninterface ICapacitor {\\n    /**\\n     * @notice emits the message details when it arrives\\n     * @param packedMessage the message packed with payload, fees and config\\n     * @param packetCount an incremental id assigned to each new packet\\n     * @param newRootHash the packed message hash (to be replaced with the root hash of the merkle tree)\\n     */\\n    event MessageAdded(\\n        bytes32 packedMessage,\\n        uint64 packetCount,\\n        bytes32 newRootHash\\n    );\\n\\n    /**\\n     * @notice adds the packed message to a packet\\n     * @dev this should be only executable by socket\\n     * @dev it will be later replaced with a function adding each message to a merkle tree\\n     * @param packedMessage the message packed with payload, fees and config\\n     */\\n    function addPackedMessage(bytes32 packedMessage) external;\\n\\n    /**\\n     * @notice returns the latest packet details which needs to be sealed\\n     * @return root root hash of the latest packet which is not yet sealed\\n     * @return packetCount latest packet id which is not yet sealed\\n     */\\n    function getNextPacketToBeSealed()\\n        external\\n        view\\n        returns (bytes32 root, uint64 packetCount);\\n\\n    /**\\n     * @notice returns the root of packet for given id\\n     * @param id the id assigned to packet\\n     * @return root root hash corresponding to given id\\n     */\\n    function getRootByCount(uint64 id) external view returns (bytes32 root);\\n\\n    /**\\n     * @notice seals the packet\\n     * @dev also indicates the packet is ready to be shipped and no more messages can be added now.\\n     * @dev this should be executable by socket only\\n     * @return root root hash of the packet\\n     * @return packetCount id of the packed sealed\\n     */\\n    function sealPacket(\\n        uint256 batchSize_\\n    ) external returns (bytes32 root, uint64 packetCount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICapacitorFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./ICapacitor.sol\\\";\\nimport \\\"./IDecapacitor.sol\\\";\\n\\ninterface ICapacitorFactory {\\n    error InvalidCapacitorType();\\n\\n    function deploy(\\n        uint256 capacitorType,\\n        uint256 siblingChainSlug,\\n        uint256 maxPacketLength\\n    ) external returns (ICapacitor, IDecapacitor);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDecapacitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\ninterface IDecapacitor {\\n    /**\\n     * @notice returns if the packed message is the part of a merkle tree or not\\n     * @param root_ root hash of the merkle tree\\n     * @param packedMessage_ packed message which needs to be verified\\n     * @param proof_ proof used to determine the inclusion\\n     */\\n    function verifyMessageInclusion(\\n        bytes32 root_,\\n        bytes32 packedMessage_,\\n        bytes calldata proof_\\n    ) external pure returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExecutionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.7;\\n\\ninterface IExecutionManager {\\n    function isExecutor(\\n        bytes32 packedMessage,\\n        bytes memory sig\\n    ) external view returns (address, bool);\\n\\n    function payFees(uint256 msgGasLimit, uint32 dstSlug) external payable;\\n\\n    function getMinFees(\\n        uint256 msgGasLimit,\\n        uint32 dstSlug\\n    ) external view returns (uint256);\\n\\n    function updateExecutionFees(\\n        address executor,\\n        uint256 executionFees,\\n        bytes32 msgId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGasPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.7;\\n\\ninterface IGasPriceOracle {\\n    function relativeGasPrice(\\n        uint32 dstChainSlug\\n    ) external view returns (uint256);\\n\\n    function sourceGasPrice() external view returns (uint256);\\n\\n    function getGasPrices(\\n        uint32 dstChainSlug_\\n    ) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHasher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\ninterface IHasher {\\n    /**\\n     * @notice returns the bytes32 hash of the message packed\\n     * @param srcChainSlug src chain slug\\n     * @param srcPlug address of plug at source\\n     * @param dstChainSlug remote chain slug\\n     * @param dstPlug address of plug at remote\\n     * @param msgId message id assigned at outbound\\n     * @param msgGasLimit gas limit which is expected to be consumed by the inbound transaction on plug\\n     * @param executionFee msg value which is expected to be sent with inbound transaction to plug\\n     * @param payload the data packed which is used by inbound for execution\\n     */\\n    function packMessage(\\n        uint256 srcChainSlug,\\n        address srcPlug,\\n        uint256 dstChainSlug,\\n        address dstPlug,\\n        bytes32 msgId,\\n        uint256 msgGasLimit,\\n        uint256 executionFee,\\n        bytes calldata payload\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INativeRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\ninterface INativeRelay {\\n    /**\\n     * @notice receiveMessage on PolygonRootReceiver\\n     * @param receivePacketProof receivePacketProof\\n     */\\n    function receiveMessage(bytes memory receivePacketProof) external;\\n\\n    function initiateNativeConfirmation(\\n        bytes32 packetId,\\n        uint256 maxSubmissionCost,\\n        uint256 maxGas,\\n        uint256 gasPriceBid\\n    ) external payable;\\n\\n    function initiateNativeConfirmation(bytes32 packetId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPlug.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.7;\\n\\ninterface IPlug {\\n    /**\\n     * @notice executes the message received from source chain\\n     * @dev this should be only executable by socket\\n     * @param srcChainSlug_ chain slug of source\\n     * @param payload_ the data which is needed by plug at inbound call on remote\\n     */\\n    function inbound(\\n        uint256 srcChainSlug_,\\n        bytes calldata payload_\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISignatureVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\ninterface ISignatureVerifier {\\n    /**\\n     * @notice returns the address of signer recovered from input signature\\n     * @param dstChainSlug_ remote chain slug\\n     * @param packetId_ packet id\\n     * @param root_ root hash of merkle tree\\n     * @param signature_ signature\\n     */\\n    function recoverSigner(\\n        uint256 dstChainSlug_,\\n        uint256 packetId_,\\n        bytes32 root_,\\n        bytes calldata signature_\\n    ) external pure returns (address signer);\\n\\n    /**\\n     * @notice returns the address of signer recovered from input signature and digest\\n     */\\n    function recoverSignerFromDigest(\\n        bytes32 digest_,\\n        bytes memory signature_\\n    ) external pure returns (address signer);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISocket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.7;\\n\\nimport \\\"./ITransmitManager.sol\\\";\\nimport \\\"./IExecutionManager.sol\\\";\\n\\ninterface ISocket {\\n    /**\\n     * @param transmissionFees fees needed for transmission\\n     * @param switchboardFees fees needed by switchboard\\n     * @param executionFee fees needed for execution\\n     */\\n    struct Fees {\\n        uint256 transmissionFees;\\n        uint256 switchboardFees;\\n        uint256 executionFee;\\n    }\\n\\n    /**\\n     * @notice emits the message details when a new message arrives at outbound\\n     * @param localChainSlug local chain slug\\n     * @param localPlug local plug address\\n     * @param dstChainSlug remote chain slug\\n     * @param dstPlug remote plug address\\n     * @param msgId message id packed with remoteChainSlug and nonce\\n     * @param msgGasLimit gas limit needed to execute the inbound at remote\\n     * @param payload the data which will be used by inbound at remote\\n     */\\n    event MessageOutbound(\\n        uint256 localChainSlug,\\n        address localPlug,\\n        uint256 dstChainSlug,\\n        address dstPlug,\\n        bytes32 msgId,\\n        uint256 msgGasLimit,\\n        bytes payload,\\n        Fees fees\\n    );\\n\\n    /**\\n     * @notice emits the status of message after inbound call\\n     * @param msgId msg id which is executed\\n     */\\n    event ExecutionSuccess(bytes32 msgId);\\n\\n    /**\\n     * @notice emits the status of message after inbound call\\n     * @param msgId msg id which is executed\\n     * @param result if message reverts, returns the revert message\\n     */\\n    event ExecutionFailed(bytes32 msgId, string result);\\n\\n    /**\\n     * @notice emits the error message in bytes after inbound call\\n     * @param msgId msg id which is executed\\n     * @param result if message reverts, returns the revert message in bytes\\n     */\\n    event ExecutionFailedBytes(bytes32 msgId, bytes result);\\n\\n    /**\\n     * @notice emits the config set by a plug for a remoteChainSlug\\n     * @param plug address of plug on current chain\\n     * @param siblingChainSlug sibling chain slug\\n     * @param siblingPlug address of plug on sibling chain\\n     * @param inboundSwitchboard inbound switchboard (select from registered options)\\n     * @param outboundSwitchboard outbound switchboard (select from registered options)\\n     * @param capacitor capacitor selected based on outbound switchboard\\n     * @param decapacitor decapacitor selected based on inbound switchboard\\n     */\\n    event PlugConnected(\\n        address plug,\\n        uint256 siblingChainSlug,\\n        address siblingPlug,\\n        address inboundSwitchboard,\\n        address outboundSwitchboard,\\n        address capacitor,\\n        address decapacitor\\n    );\\n\\n    /**\\n     * @notice emits when a new transmitManager contract is set\\n     * @param transmitManager address of new transmitManager contract\\n     */\\n    event TransmitManagerSet(address transmitManager);\\n\\n    /**\\n     * @notice registers a message\\n     * @dev Packs the message and includes it in a packet with capacitor\\n     * @param remoteChainSlug_ the remote chain slug\\n     * @param msgGasLimit_ the gas limit needed to execute the payload on remote\\n     * @param payload_ the data which is needed by plug at inbound call on remote\\n     */\\n    function outbound(\\n        uint256 remoteChainSlug_,\\n        uint256 msgGasLimit_,\\n        bytes calldata payload_\\n    ) external payable returns (bytes32 msgId);\\n\\n    struct MessageDetails {\\n        bytes32 msgId;\\n        uint256 executionFee;\\n        uint256 msgGasLimit;\\n        bytes payload;\\n        bytes decapacitorProof;\\n    }\\n\\n    /**\\n     * @notice executes a message\\n     * @param packetId packet id\\n     * @param localPlug local plug address\\n     * @param messageDetails_ the details needed for message verification\\n     */\\n    function execute(\\n        bytes32 packetId,\\n        address localPlug,\\n        ISocket.MessageDetails calldata messageDetails_,\\n        bytes memory signature\\n    ) external;\\n\\n    /**\\n     * @notice seals data in capacitor for specific batchSizr\\n     * @param batchSize_ size of batch to be sealed\\n     * @param capacitorAddress_ address of capacitor\\n     * @param signature_ signed Data needed for verification\\n     */\\n    function seal(\\n        uint256 batchSize_,\\n        address capacitorAddress_,\\n        bytes calldata signature_\\n    ) external payable;\\n\\n    /**\\n     * @notice proposes a packet\\n     * @param packetId_ packet id\\n     * @param root_ root data\\n     * @param signature_ signed Data needed for verification\\n     */\\n    function propose(\\n        bytes32 packetId_,\\n        bytes32 root_,\\n        bytes calldata signature_\\n    ) external;\\n\\n    /**\\n     * @notice sets the config specific to the plug\\n     * @param siblingChainSlug_ the sibling chain slug\\n     * @param siblingPlug_ address of plug present at sibling chain to call inbound\\n     * @param inboundSwitchboard_ the address of switchboard to use for receiving messages\\n     * @param outboundSwitchboard_ the address of switchboard to use for sending messages\\n     */\\n    function connect(\\n        uint256 siblingChainSlug_,\\n        address siblingPlug_,\\n        address inboundSwitchboard_,\\n        address outboundSwitchboard_\\n    ) external;\\n\\n    function registerSwitchBoard(\\n        address switchBoardAddress_,\\n        uint256 maxPacketLength_,\\n        uint32 siblingChainSlug_,\\n        uint32 capacitorType_\\n    ) external;\\n\\n    function packetIdRoots(bytes32 packetId_) external view returns (bytes32);\\n\\n    function getMinFees(\\n        uint256 msgGasLimit_,\\n        uint32 remoteChainSlug_,\\n        address plug_\\n    ) external view returns (uint256 totalFees);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwitchboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\ninterface ISwitchboard {\\n    function registerCapacitor(\\n        uint256 siblingChainSlug_,\\n        address capacitor_,\\n        uint256 maxPacketSize_\\n    ) external;\\n\\n    function allowPacket(\\n        bytes32 root,\\n        bytes32 packetId,\\n        uint32 srcChainSlug,\\n        uint256 proposeTime\\n    ) external view returns (bool);\\n\\n    function payFees(uint32 dstChainSlug) external payable;\\n\\n    function getMinFees(\\n        uint32 dstChainSlug\\n    ) external view returns (uint256 switchboardFee, uint256 verificationFee);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITransmitManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.7;\\n\\ninterface ITransmitManager {\\n    function checkTransmitter(\\n        uint32 siblingSlug,\\n        bytes32 digest,\\n        bytes calldata signature\\n    ) external view returns (address, bool);\\n\\n    function payFees(uint32 dstSlug) external payable;\\n\\n    function getMinFees(uint32 dstSlug) external view returns (uint256);\\n\\n    function setProposeGasLimit(\\n        uint256 nonce_,\\n        uint256 dstChainSlug_,\\n        uint256 gasLimit_,\\n        bytes calldata signature_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AddressAliasHelper.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.7;\\n\\nlibrary AddressAliasHelper {\\n    uint160 internal constant _OFFSET =\\n        uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address_ the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(\\n        address l1Address_\\n    ) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address_) + _OFFSET);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address_ L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(\\n        address l2Address_\\n    ) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address_) - _OFFSET);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FeesHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nlibrary FeesHelper {\\n    error TransferFailed();\\n    event FeesWithdrawn(address account, uint256 amount);\\n\\n    // TODO: to support fee distribution\\n    /**\\n     * @notice transfers the fees collected to `account_`\\n     * @param account_ address to transfer ETH\\n     */\\n    function withdrawFees(address account_) internal {\\n        require(account_ != address(0));\\n\\n        uint256 amount = address(this).balance;\\n        (bool success, ) = account_.call{value: amount}(\\\"\\\");\\n        if (!success) revert TransferFailed();\\n\\n        emit FeesWithdrawn(account_, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RescueFundsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../libraries/SafeTransferLib.sol\\\";\\n\\nlibrary RescueFundsLib {\\n    using SafeTransferLib for IERC20;\\n    address public constant ETH_ADDRESS =\\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) internal {\\n        require(userAddress_ != address(0));\\n\\n        if (token_ == ETH_ADDRESS) {\\n            (bool success, ) = userAddress_.call{value: address(this).balance}(\\n                \\\"\\\"\\n            );\\n            require(success);\\n        } else {\\n            IERC20(token_).transfer(userAddress_, amount_);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    function safeTransfer(\\n        IERC20 token_,\\n        address to_,\\n        uint256 amount_\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), to_) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SignatureVerifierLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nlibrary SignatureVerifierLib {\\n    error InvalidSigLength();\\n\\n    function recoverSigner(\\n        uint256 destChainSlug_,\\n        uint256 packetId_,\\n        bytes32 root_,\\n        bytes calldata signature_\\n    ) internal pure returns (address signer) {\\n        bytes32 digest = keccak256(\\n            abi.encode(destChainSlug_, packetId_, root_)\\n        );\\n        signer = recoverSignerFromDigest(digest, signature_);\\n    }\\n\\n    /**\\n     * @notice returns the address of signer recovered from input signature and digest\\n     */\\n    function recoverSignerFromDigest(\\n        bytes32 digest_,\\n        bytes memory signature_\\n    ) internal pure returns (address signer) {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", digest_)\\n        );\\n        (bytes32 sigR, bytes32 sigS, uint8 sigV) = _splitSignature(signature_);\\n\\n        // recovered signer is checked for the valid roles later\\n        signer = ecrecover(digest, sigV, sigR, sigS);\\n    }\\n\\n    /**\\n     * @notice splits the signature into v, r and s.\\n     */\\n    function _splitSignature(\\n        bytes memory signature_\\n    ) private pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        if (signature_.length != 65) revert InvalidSigLength();\\n        assembly {\\n            r := mload(add(signature_, 0x20))\\n            s := mload(add(signature_, 0x40))\\n            v := byte(0, mload(add(signature_, 0x60)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../utils/AccessControl.sol\\\";\\n\\ncontract MockAccessControl is AccessControl {\\n    bytes32 public constant ROLE_GIRAFFE = keccak256(\\\"ROLE_GIRAFFE\\\");\\n    bytes32 public constant ROLE_HIPPO = keccak256(\\\"ROLE_HIPPO\\\");\\n\\n    constructor(address owner_) AccessControl(owner_) {}\\n\\n    function giraffe() external onlyRole(ROLE_GIRAFFE) {}\\n\\n    function hippo() external onlyRole(ROLE_HIPPO) {}\\n\\n    function animal() external {}\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\n\\ncontract MockOwnable is Ownable {\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    function ownerFunction() external onlyOwner {}\\n\\n    function publicFunction() external {}\\n}\\n\"\r\n    },\r\n    \"contracts/socket/Socket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport {SocketSrc} from \\\"./SocketSrc.sol\\\";\\nimport \\\"./SocketDst.sol\\\";\\nimport \\\"../libraries/RescueFundsLib.sol\\\";\\nimport {RESCUE_ROLE} from \\\"../utils/AccessRoles.sol\\\";\\n\\ncontract Socket is SocketSrc, SocketDst {\\n    constructor(\\n        uint32 chainSlug_,\\n        address hasher_,\\n        address transmitManager_,\\n        address executionManager_,\\n        address capacitorFactory_,\\n        address owner_\\n    ) AccessControlExtended(owner_) SocketBase(chainSlug_) {\\n        hasher__ = IHasher(hasher_);\\n        transmitManager__ = ITransmitManager(transmitManager_);\\n        executionManager__ = IExecutionManager(executionManager_);\\n        capacitorFactory__ = ICapacitorFactory(capacitorFactory_);\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/socket/SocketBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IHasher.sol\\\";\\nimport \\\"../interfaces/ITransmitManager.sol\\\";\\nimport \\\"../interfaces/IExecutionManager.sol\\\";\\n\\nimport \\\"./SocketConfig.sol\\\";\\n\\nabstract contract SocketBase is SocketConfig {\\n    IHasher public hasher__;\\n    ITransmitManager public transmitManager__;\\n    IExecutionManager public executionManager__;\\n\\n    uint32 public immutable chainSlug;\\n    // incrementing nonce, should be handled in next socket version.\\n    uint224 public messageCount;\\n\\n    constructor(uint32 chainSlug_) {\\n        chainSlug = chainSlug_;\\n    }\\n\\n    error InvalidAttester();\\n\\n    event HasherSet(address hasher);\\n    event ExecutionManagerSet(address executionManager);\\n\\n    function setHasher(address hasher_) external onlyRole(GOVERNANCE_ROLE) {\\n        hasher__ = IHasher(hasher_);\\n        emit HasherSet(hasher_);\\n    }\\n\\n    /**\\n     * @notice updates transmitManager_\\n     * @param transmitManager_ address of Transmit Manager\\n     */\\n    function setTransmitManager(\\n        address transmitManager_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        transmitManager__ = ITransmitManager(transmitManager_);\\n        emit TransmitManagerSet(transmitManager_);\\n    }\\n\\n    /**\\n     * @notice updates executionManager_\\n     * @param executionManager_ address of Execution Manager\\n     */\\n    function setExecutionManager(\\n        address executionManager_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        executionManager__ = IExecutionManager(executionManager_);\\n        emit ExecutionManagerSet(executionManager_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/socket/SocketBatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../libraries/RescueFundsLib.sol\\\";\\nimport \\\"../utils/AccessControlExtended.sol\\\";\\nimport {RESCUE_ROLE} from \\\"../utils/AccessRoles.sol\\\";\\nimport {ISocket} from \\\"../interfaces/ISocket.sol\\\";\\nimport {ITransmitManager} from \\\"../interfaces/ITransmitManager.sol\\\";\\n\\nimport {FastSwitchboard} from \\\"../switchboard/default-switchboards/FastSwitchboard.sol\\\";\\nimport {INativeRelay} from \\\"../interfaces/INativeRelay.sol\\\";\\n\\ncontract SocketBatcher is AccessControlExtended {\\n    constructor(address owner_) AccessControlExtended(owner_) {\\n        _grantRole(RESCUE_ROLE, owner_);\\n    }\\n\\n    struct SealRequest {\\n        uint256 batchSize;\\n        address capacitorAddress;\\n        bytes signature;\\n    }\\n\\n    struct ProposeRequest {\\n        bytes32 packetId;\\n        bytes32 root;\\n        bytes signature;\\n    }\\n\\n    struct AttestRequest {\\n        bytes32 packetId;\\n        uint256 srcChainSlug;\\n        bytes signature;\\n    }\\n\\n    struct ExecuteRequest {\\n        bytes32 packetId;\\n        address localPlug;\\n        ISocket.MessageDetails messageDetails;\\n        bytes signature;\\n    }\\n\\n    struct ArbitrumNativeInitiatorRequest {\\n        bytes32 packetId;\\n        uint256 maxSubmissionCost;\\n        uint256 maxGas;\\n        uint256 gasPriceBid;\\n        uint256 callValue;\\n    }\\n\\n    struct SetProposeGasLimitRequest {\\n        uint256 nonce;\\n        uint256 dstChainId;\\n        uint256 proposeGasLimit;\\n        bytes signature;\\n    }\\n\\n    struct SetAttestGasLimitRequest {\\n        uint256 nonce;\\n        uint256 dstChainId;\\n        uint256 attestGasLimit;\\n        bytes signature;\\n    }\\n\\n    struct SetExecutionOverheadRequest {\\n        uint256 nonce;\\n        uint256 dstChainId;\\n        uint256 executionOverhead;\\n        bytes signature;\\n    }\\n\\n    struct RegisterSwitchboardRequest {\\n        address switchBoardAddress;\\n        uint256 maxPacketLength;\\n        uint32 siblingChainSlug;\\n        uint32 capacitorType;\\n    }\\n\\n    /**\\n     * @notice set propose gas limit for a list of siblings\\n     * @param socketAddress_ address of socket\\n     * @param registerSwitchboardsRequests_ the list of requests with gas limit details\\n     */\\n    function registerSwitchboards(\\n        address socketAddress_,\\n        RegisterSwitchboardRequest[] calldata registerSwitchboardsRequests_\\n    ) external {\\n        uint256 registerSwitchboardsLength = registerSwitchboardsRequests_\\n            .length;\\n        for (uint256 index = 0; index < registerSwitchboardsLength; ) {\\n            ISocket(socketAddress_).registerSwitchBoard(\\n                registerSwitchboardsRequests_[index].switchBoardAddress,\\n                registerSwitchboardsRequests_[index].maxPacketLength,\\n                registerSwitchboardsRequests_[index].siblingChainSlug,\\n                registerSwitchboardsRequests_[index].capacitorType\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice set propose gas limit for a list of siblings\\n     * @param transmitManagerAddress_ address of transmit manager\\n     * @param setProposeGasLimitRequests_ the list of requests with gas limit details\\n     */\\n    function setProposeGasLimits(\\n        address transmitManagerAddress_,\\n        SetProposeGasLimitRequest[] calldata setProposeGasLimitRequests_\\n    ) external {\\n        uint256 setProposeGasLimitLength = setProposeGasLimitRequests_.length;\\n        for (uint256 index = 0; index < setProposeGasLimitLength; ) {\\n            ITransmitManager(transmitManagerAddress_).setProposeGasLimit(\\n                setProposeGasLimitRequests_[index].nonce,\\n                setProposeGasLimitRequests_[index].dstChainId,\\n                setProposeGasLimitRequests_[index].proposeGasLimit,\\n                setProposeGasLimitRequests_[index].signature\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice set attest gas limit for a list of siblings\\n     * @param fastSwitchboardAddress_ address of fast switchboard\\n     * @param setAttestGasLimitRequests_ the list of requests with gas limit details\\n     */\\n    function setAttestGasLimits(\\n        address fastSwitchboardAddress_,\\n        SetAttestGasLimitRequest[] calldata setAttestGasLimitRequests_\\n    ) external {\\n        uint256 setAttestGasLimitLength = setAttestGasLimitRequests_.length;\\n        for (uint256 index = 0; index < setAttestGasLimitLength; ) {\\n            FastSwitchboard(fastSwitchboardAddress_).setAttestGasLimit(\\n                setAttestGasLimitRequests_[index].nonce,\\n                setAttestGasLimitRequests_[index].dstChainId,\\n                setAttestGasLimitRequests_[index].attestGasLimit,\\n                setAttestGasLimitRequests_[index].signature\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice set execution overhead for a list of siblings\\n     * @param switchboardAddress_ address of fast switchboard\\n     * @param setExecutionOverheadRequests_ the list of requests with gas limit details\\n     */\\n    function setExecutionOverheadBatch(\\n        address switchboardAddress_,\\n        SetExecutionOverheadRequest[] calldata setExecutionOverheadRequests_\\n    ) external {\\n        uint256 sealRequestslength = setExecutionOverheadRequests_.length;\\n        for (uint256 index = 0; index < sealRequestslength; ) {\\n            FastSwitchboard(switchboardAddress_).setExecutionOverhead(\\n                setExecutionOverheadRequests_[index].nonce,\\n                setExecutionOverheadRequests_[index].dstChainId,\\n                setExecutionOverheadRequests_[index].executionOverhead,\\n                setExecutionOverheadRequests_[index].signature\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice seal a batch of packets from capacitor on sourceChain mentioned in sealRequests\\n     * @param socketAddress_ address of socket\\n     * @param sealRequests_ the list of requests with packets to be sealed on sourceChain\\n     */\\n    function sealBatch(\\n        address socketAddress_,\\n        SealRequest[] calldata sealRequests_\\n    ) external {\\n        uint256 sealRequestslength = sealRequests_.length;\\n        for (uint256 index = 0; index < sealRequestslength; ) {\\n            ISocket(socketAddress_).seal(\\n                sealRequests_[index].batchSize,\\n                sealRequests_[index].capacitorAddress,\\n                sealRequests_[index].signature\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice propose a batch of packets sequentially by socketDestination\\n     * @param socketAddress_ address of socket\\n     * @param proposeRequests_ the list of requests with packets to be proposed by socketDestination\\n     */\\n    function proposeBatch(\\n        address socketAddress_,\\n        ProposeRequest[] calldata proposeRequests_\\n    ) external {\\n        uint256 proposeRequestslength = proposeRequests_.length;\\n        for (uint256 index = 0; index < proposeRequestslength; ) {\\n            ISocket(socketAddress_).propose(\\n                proposeRequests_[index].packetId,\\n                proposeRequests_[index].root,\\n                proposeRequests_[index].signature\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice attests a batch of Packets\\n     * @param switchBoardAddress_ address of switchboard\\n     * @param attestRequests_ the list of requests with packets to be attested by switchboard in sequence\\n     */\\n    function attestBatch(\\n        address switchBoardAddress_,\\n        AttestRequest[] calldata attestRequests_\\n    ) external {\\n        uint256 attestRequestslength = attestRequests_.length;\\n        for (uint256 index = 0; index < attestRequestslength; ) {\\n            FastSwitchboard(switchBoardAddress_).attest(\\n                attestRequests_[index].packetId,\\n                attestRequests_[index].srcChainSlug,\\n                attestRequests_[index].signature\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice executes a batch of messages\\n     * @param socketAddress_ address of socket\\n     * @param executeRequests_ the list of requests with messages to be executed in sequence\\n     */\\n    function executeBatch(\\n        address socketAddress_,\\n        ExecuteRequest[] calldata executeRequests_\\n    ) external {\\n        uint256 executeRequestslength = executeRequests_.length;\\n        for (uint256 index = 0; index < executeRequestslength; ) {\\n            ISocket(socketAddress_).execute(\\n                executeRequests_[index].packetId,\\n                executeRequests_[index].localPlug,\\n                executeRequests_[index].messageDetails,\\n                executeRequests_[index].signature\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice invoke receieve Message on PolygonRootReceiver for a batch of messages in loop\\n     * @param polygonRootReceiverAddress_ address of polygonRootReceiver\\n     * @param receivePacketProofs_ the list of receivePacketProofs to be sent to receiveHook of polygonRootReceiver\\n     */\\n    function receiveMessageBatch(\\n        address polygonRootReceiverAddress_,\\n        bytes[] calldata receivePacketProofs_\\n    ) external {\\n        uint256 receivePacketProofsLength = receivePacketProofs_.length;\\n        for (uint256 index = 0; index < receivePacketProofsLength; ) {\\n            INativeRelay(polygonRootReceiverAddress_).receiveMessage(\\n                receivePacketProofs_[index]\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice initiate NativeConfirmation on arbitrumChain for a batch of packets in loop\\n     * @param switchboardAddress_ address of nativeArbitrumSwitchboard\\n     * @param arbitrumNativeInitiatorRequests_ the list of requests with packets to initiate nativeConfirmation on switchboard of arbitrumChain\\n     */\\n    function initiateArbitrumNativeBatch(\\n        address switchboardAddress_,\\n        ArbitrumNativeInitiatorRequest[]\\n            calldata arbitrumNativeInitiatorRequests_\\n    ) external payable {\\n        uint256 arbitrumNativeInitiatorRequestsLength = arbitrumNativeInitiatorRequests_\\n                .length;\\n        for (\\n            uint256 index = 0;\\n            index < arbitrumNativeInitiatorRequestsLength;\\n\\n        ) {\\n            INativeRelay(switchboardAddress_).initiateNativeConfirmation{\\n                value: arbitrumNativeInitiatorRequests_[index].callValue\\n            }(\\n                arbitrumNativeInitiatorRequests_[index].packetId,\\n                arbitrumNativeInitiatorRequests_[index].maxSubmissionCost,\\n                arbitrumNativeInitiatorRequests_[index].maxGas,\\n                arbitrumNativeInitiatorRequests_[index].gasPriceBid\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice initiate NativeConfirmation on nativeChain(s) for a batch of packets in loop\\n     * @param switchboardAddress_ address of nativeSwitchboard\\n     * @param nativePacketIds_ the list of requests with packets to initiate nativeConfirmation on switchboard of native chains\\n     */\\n    function initiateNativeBatch(\\n        address switchboardAddress_,\\n        bytes32[] calldata nativePacketIds_\\n    ) external {\\n        uint256 nativePacketIdsLength = nativePacketIds_.length;\\n        for (uint256 index = 0; index < nativePacketIdsLength; ) {\\n            INativeRelay(switchboardAddress_).initiateNativeConfirmation(\\n                nativePacketIds_[index]\\n            );\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/socket/SocketConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/ISocket.sol\\\";\\nimport \\\"../interfaces/ICapacitorFactory.sol\\\";\\nimport \\\"../interfaces/ISwitchboard.sol\\\";\\nimport \\\"../utils/AccessControlExtended.sol\\\";\\nimport {GOVERNANCE_ROLE} from \\\"../utils/AccessRoles.sol\\\";\\n\\nabstract contract SocketConfig is ISocket, AccessControlExtended {\\n    struct PlugConfig {\\n        address siblingPlug;\\n        ICapacitor capacitor__;\\n        IDecapacitor decapacitor__;\\n        ISwitchboard inboundSwitchboard__;\\n        ISwitchboard outboundSwitchboard__;\\n    }\\n\\n    ICapacitorFactory public capacitorFactory__;\\n\\n    // siblingChainSlug => capacitor address\\n    mapping(address => uint32) public capacitorToSlug;\\n\\n    // switchboard => siblingChainSlug => ICapacitor\\n    mapping(address => mapping(uint256 => ICapacitor)) public capacitors__;\\n    // switchboard => siblingChainSlug => IDecapacitor\\n    mapping(address => mapping(uint256 => IDecapacitor)) public decapacitors__;\\n\\n    // plug => remoteChainSlug => (siblingPlug, capacitor__, decapacitor__, inboundSwitchboard__, outboundSwitchboard__)\\n    mapping(address => mapping(uint256 => PlugConfig)) internal _plugConfigs;\\n\\n    event SwitchboardAdded(\\n        address switchboard,\\n        uint256 siblingChainSlug,\\n        address capacitor,\\n        address decapacitor,\\n        uint256 maxPacketLength,\\n        uint32 capacitorType\\n    );\\n    event CapacitorFactorySet(address capacitorFactory);\\n\\n    error SwitchboardExists();\\n    error InvalidConnection();\\n\\n    function setCapacitorFactory(\\n        address capacitorFactory_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        capacitorFactory__ = ICapacitorFactory(capacitorFactory_);\\n        emit CapacitorFactorySet(capacitorFactory_);\\n    }\\n\\n    // it's msg.sender's responsibility to set correct sibling slug\\n    function registerSwitchBoard(\\n        address switchBoardAddress_,\\n        uint256 maxPacketLength_,\\n        uint32 siblingChainSlug_,\\n        uint32 capacitorType_\\n    ) external override {\\n        // only capacitor checked, decapacitor assumed will exist if capacitor does\\n        if (\\n            address(capacitors__[switchBoardAddress_][siblingChainSlug_]) !=\\n            address(0)\\n        ) revert SwitchboardExists();\\n\\n        (\\n            ICapacitor capacitor__,\\n            IDecapacitor decapacitor__\\n        ) = capacitorFactory__.deploy(\\n                capacitorType_,\\n                siblingChainSlug_,\\n                maxPacketLength_\\n            );\\n\\n        capacitorToSlug[address(capacitor__)] = siblingChainSlug_;\\n        capacitors__[switchBoardAddress_][siblingChainSlug_] = capacitor__;\\n        decapacitors__[switchBoardAddress_][siblingChainSlug_] = decapacitor__;\\n\\n        ISwitchboard(switchBoardAddress_).registerCapacitor(\\n            siblingChainSlug_,\\n            address(capacitor__),\\n            maxPacketLength_\\n        );\\n\\n        emit SwitchboardAdded(\\n            switchBoardAddress_,\\n            siblingChainSlug_,\\n            address(capacitor__),\\n            address(decapacitor__),\\n            maxPacketLength_,\\n            capacitorType_\\n        );\\n    }\\n\\n    function connect(\\n        uint256 siblingChainSlug_,\\n        address siblingPlug_,\\n        address inboundSwitchboard_,\\n        address outboundSwitchboard_\\n    ) external override {\\n        if (\\n            address(capacitors__[inboundSwitchboard_][siblingChainSlug_]) ==\\n            address(0) ||\\n            address(capacitors__[outboundSwitchboard_][siblingChainSlug_]) ==\\n            address(0)\\n        ) revert InvalidConnection();\\n\\n        PlugConfig storage _plugConfig = _plugConfigs[msg.sender][\\n            siblingChainSlug_\\n        ];\\n\\n        _plugConfig.siblingPlug = siblingPlug_;\\n        _plugConfig.capacitor__ = capacitors__[outboundSwitchboard_][\\n            siblingChainSlug_\\n        ];\\n        _plugConfig.decapacitor__ = decapacitors__[inboundSwitchboard_][\\n            siblingChainSlug_\\n        ];\\n        _plugConfig.inboundSwitchboard__ = ISwitchboard(inboundSwitchboard_);\\n        _plugConfig.outboundSwitchboard__ = ISwitchboard(outboundSwitchboard_);\\n\\n        emit PlugConnected(\\n            msg.sender,\\n            siblingChainSlug_,\\n            _plugConfig.siblingPlug,\\n            address(_plugConfig.inboundSwitchboard__),\\n            address(_plugConfig.outboundSwitchboard__),\\n            address(_plugConfig.capacitor__),\\n            address(_plugConfig.decapacitor__)\\n        );\\n    }\\n\\n    function getPlugConfig(\\n        address plugAddress_,\\n        uint256 siblingChainSlug_\\n    )\\n        external\\n        view\\n        returns (\\n            address siblingPlug,\\n            address inboundSwitchboard__,\\n            address outboundSwitchboard__,\\n            address capacitor__,\\n            address decapacitor__\\n        )\\n    {\\n        PlugConfig memory _plugConfig = _plugConfigs[plugAddress_][\\n            siblingChainSlug_\\n        ];\\n\\n        return (\\n            _plugConfig.siblingPlug,\\n            address(_plugConfig.inboundSwitchboard__),\\n            address(_plugConfig.outboundSwitchboard__),\\n            address(_plugConfig.capacitor__),\\n            address(_plugConfig.decapacitor__)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/socket/SocketDst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IDecapacitor.sol\\\";\\nimport \\\"../interfaces/IPlug.sol\\\";\\n\\nimport \\\"./SocketBase.sol\\\";\\n\\nabstract contract SocketDst is SocketBase {\\n    error AlreadyAttested();\\n    error InvalidProof();\\n    error InvalidRetry();\\n    error MessageAlreadyExecuted();\\n    error NotExecutor();\\n    error VerificationFailed();\\n\\n    // msgId => message status\\n    mapping(bytes32 => bool) public messageExecuted;\\n    // capacitorAddr|chainSlug|packetId\\n    mapping(bytes32 => bytes32) public override packetIdRoots;\\n    mapping(bytes32 => uint256) public rootProposedAt;\\n\\n    /**\\n     * @notice emits the packet details when proposed at remote\\n     * @param transmitter address of transmitter\\n     * @param packetId packet id\\n     * @param root packet root\\n     */\\n    event PacketProposed(\\n        address indexed transmitter,\\n        bytes32 indexed packetId,\\n        bytes32 root\\n    );\\n\\n    /**\\n     * @notice emits the root details when root is replaced by owner\\n     * @param packetId packet id\\n     * @param oldRoot old root\\n     * @param newRoot old root\\n     */\\n    event PacketRootUpdated(bytes32 packetId, bytes32 oldRoot, bytes32 newRoot);\\n\\n    function propose(\\n        bytes32 packetId_,\\n        bytes32 root_,\\n        bytes calldata signature_\\n    ) external override {\\n        if (packetIdRoots[packetId_] != bytes32(0)) revert AlreadyAttested();\\n\\n        (address transmitter, bool isTransmitter) = transmitManager__\\n            .checkTransmitter(\\n                uint32(_decodeSlug(packetId_)),\\n                keccak256(abi.encode(chainSlug, packetId_, root_)),\\n                signature_\\n            );\\n\\n        if (!isTransmitter) revert InvalidAttester();\\n\\n        packetIdRoots[packetId_] = root_;\\n        rootProposedAt[packetId_] = block.timestamp;\\n\\n        emit PacketProposed(transmitter, packetId_, root_);\\n    }\\n\\n    /**\\n     * @notice executes a message, fees will go to recovered executor address\\n     * @param packetId_ packet id\\n     * @param localPlug_ remote plug address\\n     * @param messageDetails_ the details needed for message verification\\n     */\\n    function execute(\\n        bytes32 packetId_,\\n        address localPlug_,\\n        ISocket.MessageDetails calldata messageDetails_,\\n        bytes memory signature_\\n    ) external override {\\n        if (messageExecuted[messageDetails_.msgId])\\n            revert MessageAlreadyExecuted();\\n        messageExecuted[messageDetails_.msgId] = true;\\n\\n        uint256 remoteSlug = _decodeSlug(messageDetails_.msgId);\\n\\n        PlugConfig storage plugConfig = _plugConfigs[localPlug_][remoteSlug];\\n\\n        bytes32 packedMessage = hasher__.packMessage(\\n            remoteSlug,\\n            plugConfig.siblingPlug,\\n            chainSlug,\\n            localPlug_,\\n            messageDetails_.msgId,\\n            messageDetails_.msgGasLimit,\\n            messageDetails_.executionFee,\\n            messageDetails_.payload\\n        );\\n\\n        (address executor, bool isValidExecutor) = executionManager__\\n            .isExecutor(packedMessage, signature_);\\n        if (!isValidExecutor) revert NotExecutor();\\n\\n        _verify(\\n            packetId_,\\n            remoteSlug,\\n            packedMessage,\\n            plugConfig,\\n            messageDetails_.decapacitorProof\\n        );\\n        _execute(\\n            executor,\\n            messageDetails_.executionFee,\\n            localPlug_,\\n            remoteSlug,\\n            messageDetails_.msgGasLimit,\\n            messageDetails_.msgId,\\n            messageDetails_.payload\\n        );\\n    }\\n\\n    function _verify(\\n        bytes32 packetId_,\\n        uint256 remoteChainSlug_,\\n        bytes32 packedMessage_,\\n        PlugConfig storage plugConfig_,\\n        bytes memory decapacitorProof_\\n    ) internal view {\\n        if (\\n            !ISwitchboard(plugConfig_.inboundSwitchboard__).allowPacket(\\n                packetIdRoots[packetId_],\\n                packetId_,\\n                uint32(remoteChainSlug_),\\n                rootProposedAt[packetId_]\\n            )\\n        ) revert VerificationFailed();\\n\\n        if (\\n            !plugConfig_.decapacitor__.verifyMessageInclusion(\\n                packetIdRoots[packetId_],\\n                packedMessage_,\\n                decapacitorProof_\\n            )\\n        ) revert InvalidProof();\\n    }\\n\\n    function _execute(\\n        address executor,\\n        uint256 executionFee,\\n        address localPlug_,\\n        uint256 remoteChainSlug_,\\n        uint256 msgGasLimit_,\\n        bytes32 msgId_,\\n        bytes calldata payload_\\n    ) internal {\\n        try\\n            IPlug(localPlug_).inbound{gas: msgGasLimit_}(\\n                remoteChainSlug_,\\n                payload_\\n            )\\n        {\\n            executionManager__.updateExecutionFees(\\n                executor,\\n                executionFee,\\n                msgId_\\n            );\\n            emit ExecutionSuccess(msgId_);\\n        } catch Error(string memory reason) {\\n            // catch failing revert() and require()\\n            messageExecuted[msgId_] = false;\\n            emit ExecutionFailed(msgId_, reason);\\n        } catch (bytes memory reason) {\\n            // catch failing assert()\\n            messageExecuted[msgId_] = false;\\n            emit ExecutionFailedBytes(msgId_, reason);\\n        }\\n    }\\n\\n    function isPacketProposed(bytes32 packetId_) external view returns (bool) {\\n        return packetIdRoots[packetId_] == bytes32(0) ? false : true;\\n    }\\n\\n    function _decodeSlug(\\n        bytes32 id_\\n    ) internal pure returns (uint256 chainSlug_) {\\n        chainSlug_ = uint256(id_) >> 224;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/socket/SocketSrc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/ICapacitor.sol\\\";\\nimport \\\"./SocketBase.sol\\\";\\n\\nabstract contract SocketSrc is SocketBase {\\n    error InsufficientFees();\\n\\n    /**\\n     * @notice emits the verification and seal confirmation of a packet\\n     * @param transmitter address of transmitter recovered from sig\\n     * @param packetId packed id\\n     * @param root root\\n     * @param signature signature of attester\\n     */\\n    event PacketVerifiedAndSealed(\\n        address indexed transmitter,\\n        bytes32 indexed packetId,\\n        bytes32 root,\\n        bytes signature\\n    );\\n\\n    /**\\n     * @notice registers a message\\n     * @dev Packs the message and includes it in a packet with capacitor\\n     * @param remoteChainSlug_ the remote chain slug\\n     * @param msgGasLimit_ the gas limit needed to execute the payload on remote\\n     * @param payload_ the data which is needed by plug at inbound call on remote\\n     */\\n    function outbound(\\n        uint256 remoteChainSlug_,\\n        uint256 msgGasLimit_,\\n        bytes calldata payload_\\n    ) external payable override returns (bytes32 msgId) {\\n        PlugConfig storage plugConfig = _plugConfigs[msg.sender][\\n            remoteChainSlug_\\n        ];\\n        uint256 localChainSlug = chainSlug;\\n\\n        msgId = _encodeMsgId(localChainSlug);\\n\\n        ISocket.Fees memory fees = _deductFees(\\n            msgGasLimit_,\\n            uint32(remoteChainSlug_),\\n            plugConfig.outboundSwitchboard__\\n        );\\n\\n        bytes32 packedMessage = hasher__.packMessage(\\n            localChainSlug,\\n            msg.sender,\\n            remoteChainSlug_,\\n            plugConfig.siblingPlug,\\n            msgId,\\n            msgGasLimit_,\\n            fees.executionFee,\\n            payload_\\n        );\\n\\n        plugConfig.capacitor__.addPackedMessage(packedMessage);\\n        emit MessageOutbound(\\n            localChainSlug,\\n            msg.sender,\\n            remoteChainSlug_,\\n            plugConfig.siblingPlug,\\n            msgId,\\n            msgGasLimit_,\\n            payload_,\\n            fees\\n        );\\n    }\\n\\n    function _deductFees(\\n        uint256 msgGasLimit_,\\n        uint32 remoteChainSlug_,\\n        ISwitchboard switchboard__\\n    ) internal returns (Fees memory fees) {\\n        uint256 minExecutionFees;\\n        (\\n            fees.transmissionFees,\\n            fees.switchboardFees,\\n            minExecutionFees\\n        ) = _getMinFees(msgGasLimit_, remoteChainSlug_, switchboard__);\\n\\n        if (\\n            msg.value <\\n            fees.transmissionFees + fees.switchboardFees + minExecutionFees\\n        ) revert InsufficientFees();\\n\\n        unchecked {\\n            // any extra fee is considered as executionFee\\n            fees.executionFee =\\n                msg.value -\\n                fees.transmissionFees -\\n                fees.switchboardFees;\\n\\n            transmitManager__.payFees{value: fees.transmissionFees}(\\n                remoteChainSlug_\\n            );\\n            switchboard__.payFees{value: fees.switchboardFees}(\\n                remoteChainSlug_\\n            );\\n            executionManager__.payFees{value: fees.executionFee}(\\n                msgGasLimit_,\\n                remoteChainSlug_\\n            );\\n        }\\n    }\\n\\n    function getMinFees(\\n        uint256 msgGasLimit_,\\n        uint32 remoteChainSlug_,\\n        address plug_\\n    ) external view override returns (uint256 totalFees) {\\n        PlugConfig storage plugConfig = _plugConfigs[plug_][remoteChainSlug_];\\n\\n        (\\n            uint256 transmissionFees,\\n            uint256 switchboardFees,\\n            uint256 executionFee\\n        ) = _getMinFees(\\n                msgGasLimit_,\\n                remoteChainSlug_,\\n                plugConfig.outboundSwitchboard__\\n            );\\n\\n        totalFees = transmissionFees + switchboardFees + executionFee;\\n    }\\n\\n    function _getMinFees(\\n        uint256 msgGasLimit_,\\n        uint32 remoteChainSlug_,\\n        ISwitchboard switchboard__\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 transmissionFees,\\n            uint256 switchboardFees,\\n            uint256 executionFee\\n        )\\n    {\\n        transmissionFees = transmitManager__.getMinFees(remoteChainSlug_);\\n\\n        uint256 verificationFee;\\n        (switchboardFees, verificationFee) = switchboard__.getMinFees(\\n            remoteChainSlug_\\n        );\\n        uint256 msgExecutionFee = executionManager__.getMinFees(\\n            msgGasLimit_,\\n            remoteChainSlug_\\n        );\\n\\n        executionFee = msgExecutionFee + verificationFee;\\n    }\\n\\n    function seal(\\n        uint256 batchSize_,\\n        address capacitorAddress_,\\n        bytes calldata signature_\\n    ) external payable override {\\n        (bytes32 root, uint64 packetCount) = ICapacitor(capacitorAddress_)\\n            .sealPacket(batchSize_);\\n\\n        bytes32 packetId = _encodePacketId(capacitorAddress_, packetCount);\\n\\n        uint32 siblingChainSlug = capacitorToSlug[capacitorAddress_];\\n        (address transmitter, bool isTransmitter) = transmitManager__\\n            .checkTransmitter(\\n                siblingChainSlug,\\n                keccak256(abi.encode(siblingChainSlug, packetId, root)),\\n                signature_\\n            );\\n\\n        if (!isTransmitter) revert InvalidAttester();\\n        emit PacketVerifiedAndSealed(transmitter, packetId, root, signature_);\\n    }\\n\\n    // Packs the local plug, local chain slug, remote chain slug and nonce\\n    // messageCount++ will take care of msg id overflow as well\\n    // msgId(256) = localChainSlug(32) | nonce(224)\\n    function _encodeMsgId(uint256 slug_) internal returns (bytes32) {\\n        return bytes32((uint256(uint32(slug_)) << 224) | messageCount++);\\n    }\\n\\n    function _encodePacketId(\\n        address capacitorAddress_,\\n        uint256 packetCount_\\n    ) internal view returns (bytes32) {\\n        return\\n            bytes32(\\n                (uint256(chainSlug) << 224) |\\n                    (uint256(uint160(capacitorAddress_)) << 64) |\\n                    packetCount_\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/default-switchboards/FastSwitchboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./SwitchboardBase.sol\\\";\\nimport \\\"../../libraries/SignatureVerifierLib.sol\\\";\\n\\ncontract FastSwitchboard is SwitchboardBase {\\n    mapping(bytes32 => bool) public isPacketValid;\\n\\n    // dst chain slug => total watchers registered\\n    mapping(uint256 => uint256) public totalWatchers;\\n\\n    // dst chain slug => attest gas limit\\n    mapping(uint256 => uint256) public attestGasLimit;\\n\\n    // attester => packetId => is attested\\n    mapping(address => mapping(bytes32 => bool)) public isAttested;\\n\\n    // packetId => total attestations\\n    mapping(bytes32 => uint256) public attestations;\\n\\n    event SocketSet(address newSocket);\\n    event PacketAttested(bytes32 packetId, address attester);\\n    event AttestGasLimitSet(uint256 dstChainSlug, uint256 attestGasLimit);\\n\\n    error WatcherFound();\\n    error WatcherNotFound();\\n    error AlreadyAttested();\\n\\n    constructor(\\n        address owner_,\\n        address socket_,\\n        address gasPriceOracle_,\\n        uint256 chainSlug_,\\n        uint256 timeoutInSeconds_\\n    )\\n        AccessControlExtended(owner_)\\n        SwitchboardBase(gasPriceOracle_, socket_, chainSlug_, timeoutInSeconds_)\\n    {}\\n\\n    function attest(\\n        bytes32 packetId_,\\n        uint256 srcChainSlug_,\\n        bytes calldata signature_\\n    ) external {\\n        address watcher = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(abi.encode(srcChainSlug_, packetId_)),\\n            signature_\\n        );\\n\\n        if (isAttested[watcher][packetId_]) revert AlreadyAttested();\\n        if (!_hasRole(\\\"WATCHER_ROLE\\\", srcChainSlug_, watcher))\\n            revert WatcherNotFound();\\n\\n        isAttested[watcher][packetId_] = true;\\n        attestations[packetId_]++;\\n\\n        if (attestations[packetId_] >= totalWatchers[srcChainSlug_])\\n            isPacketValid[packetId_] = true;\\n\\n        emit PacketAttested(packetId_, watcher);\\n    }\\n\\n    /**\\n     * @notice verifies if the packet satisfies needed checks before execution\\n     * @param packetId_ packetId\\n     * @param proposeTime_ time at which packet was proposed\\n     */\\n    function allowPacket(\\n        bytes32,\\n        bytes32 packetId_,\\n        uint32 srcChainSlug_,\\n        uint256 proposeTime_\\n    ) external view override returns (bool) {\\n        if (tripGlobalFuse || tripSinglePath[srcChainSlug_]) return false;\\n        if (isPacketValid[packetId_]) return true;\\n        if (block.timestamp - proposeTime_ > timeoutInSeconds) return true;\\n        return false;\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256 dstChainSlug_,\\n        uint256 dstRelativeGasPrice_\\n    ) internal view override returns (uint256) {\\n        // assumption: number of watchers are going to be same on all chains for particular chain slug?\\n        return\\n            totalWatchers[dstChainSlug_] *\\n            attestGasLimit[dstChainSlug_] *\\n            dstRelativeGasPrice_;\\n    }\\n\\n    /**\\n     * @notice updates attest gas limit for given chain slug\\n     * @param dstChainSlug_ destination chain\\n     * @param attestGasLimit_ average gas limit needed for attest function call\\n     */\\n    function setAttestGasLimit(\\n        uint256 nonce_,\\n        uint256 dstChainSlug_,\\n        uint256 attestGasLimit_,\\n        bytes calldata signature_\\n    ) external {\\n        address gasLimitUpdater = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"ATTEST_GAS_LIMIT_UPDATE\\\",\\n                    chainSlug,\\n                    dstChainSlug_,\\n                    nonce_,\\n                    attestGasLimit_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(\\\"GAS_LIMIT_UPDATER_ROLE\\\", dstChainSlug_, gasLimitUpdater))\\n            revert NoPermit(\\\"GAS_LIMIT_UPDATER_ROLE\\\");\\n\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        attestGasLimit[dstChainSlug_] = attestGasLimit_;\\n        emit AttestGasLimitSet(dstChainSlug_, attestGasLimit_);\\n    }\\n\\n    /**\\n     * @notice adds a watcher for `srcChainSlug_` chain\\n     * @param watcher_ watcher address\\n     */\\n    function grantWatcherRole(\\n        uint256 srcChainSlug_,\\n        address watcher_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        if (_hasRole(\\\"WATCHER_ROLE\\\", srcChainSlug_, watcher_))\\n            revert WatcherFound();\\n        _grantRole(\\\"WATCHER_ROLE\\\", srcChainSlug_, watcher_);\\n\\n        totalWatchers[srcChainSlug_]++;\\n    }\\n\\n    /**\\n     * @notice removes a watcher from `srcChainSlug_` chain list\\n     * @param watcher_ watcher address\\n     */\\n    function revokeWatcherRole(\\n        uint256 srcChainSlug_,\\n        address watcher_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        if (!_hasRole(\\\"WATCHER_ROLE\\\", srcChainSlug_, watcher_))\\n            revert WatcherNotFound();\\n        _revokeRole(\\\"WATCHER_ROLE\\\", srcChainSlug_, watcher_);\\n\\n        totalWatchers[srcChainSlug_]--;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/default-switchboards/OptimisticSwitchboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./SwitchboardBase.sol\\\";\\n\\ncontract OptimisticSwitchboard is SwitchboardBase {\\n    constructor(\\n        address owner_,\\n        address socket_,\\n        address gasPriceOracle_,\\n        uint256 chainSlug_,\\n        uint256 timeoutInSeconds_\\n    )\\n        AccessControlExtended(owner_)\\n        SwitchboardBase(gasPriceOracle_, socket_, chainSlug_, timeoutInSeconds_)\\n    {}\\n\\n    /**\\n     * @notice verifies if the packet satisfies needed checks before execution\\n     * @param srcChainSlug_ source chain slug\\n     * @param proposeTime_ time at which packet was proposed\\n     */\\n    function allowPacket(\\n        bytes32,\\n        bytes32,\\n        uint32 srcChainSlug_,\\n        uint256 proposeTime_\\n    ) external view override returns (bool) {\\n        if (tripGlobalFuse || tripSinglePath[srcChainSlug_]) return false;\\n        if (block.timestamp - proposeTime_ < timeoutInSeconds) return false;\\n        return true;\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256,\\n        uint256\\n    ) internal pure override returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/default-switchboards/SwitchboardBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../../interfaces/ISwitchboard.sol\\\";\\nimport \\\"../../interfaces/IGasPriceOracle.sol\\\";\\nimport \\\"../../utils/AccessControlExtended.sol\\\";\\n\\nimport \\\"../../libraries/SignatureVerifierLib.sol\\\";\\nimport \\\"../../libraries/RescueFundsLib.sol\\\";\\nimport \\\"../../libraries/FeesHelper.sol\\\";\\n\\nimport {GOVERNANCE_ROLE, WITHDRAW_ROLE, RESCUE_ROLE, GAS_LIMIT_UPDATER_ROLE} from \\\"../../utils/AccessRoles.sol\\\";\\n\\nabstract contract SwitchboardBase is ISwitchboard, AccessControlExtended {\\n    IGasPriceOracle public gasPriceOracle__;\\n\\n    bool public tripGlobalFuse;\\n    address public socket;\\n    uint256 public immutable chainSlug;\\n    uint256 public immutable timeoutInSeconds;\\n\\n    mapping(uint256 => bool) public isInitialised;\\n    mapping(uint256 => uint256) public maxPacketSize;\\n\\n    mapping(uint256 => uint256) public executionOverhead;\\n\\n    // sourceChain => isPaused\\n    mapping(uint256 => bool) public tripSinglePath;\\n\\n    // watcher => nextNonce\\n    mapping(address => uint256) public nextNonce;\\n\\n    event PathTripped(uint256 srcChainSlug, bool tripSinglePath);\\n    event SwitchboardTripped(bool tripGlobalFuse);\\n    event ExecutionOverheadSet(uint256 dstChainSlug, uint256 executionOverhead);\\n    event GasPriceOracleSet(address gasPriceOracle);\\n    event CapacitorRegistered(\\n        uint256 siblingChainSlug,\\n        address capacitor,\\n        uint256 maxPacketSize\\n    );\\n\\n    error AlreadyInitialised();\\n    error InvalidNonce();\\n    error OnlySocket();\\n\\n    constructor(\\n        address gasPriceOracle_,\\n        address socket_,\\n        uint256 chainSlug_,\\n        uint256 timeoutInSeconds_\\n    ) {\\n        gasPriceOracle__ = IGasPriceOracle(gasPriceOracle_);\\n        socket = socket_;\\n        chainSlug = chainSlug_;\\n        timeoutInSeconds = timeoutInSeconds_;\\n    }\\n\\n    function payFees(uint32 dstChainSlug_) external payable override {}\\n\\n    function getMinFees(\\n        uint32 dstChainSlug_\\n    ) external view override returns (uint256, uint256) {\\n        return _calculateMinFees(dstChainSlug_);\\n    }\\n\\n    function _calculateMinFees(\\n        uint32 dstChainSlug_\\n    ) internal view returns (uint256 switchboardFee, uint256 verificationFee) {\\n        uint256 dstRelativeGasPrice = gasPriceOracle__.relativeGasPrice(\\n            dstChainSlug_\\n        );\\n\\n        switchboardFee =\\n            _getMinSwitchboardFees(dstChainSlug_, dstRelativeGasPrice) /\\n            maxPacketSize[dstChainSlug_];\\n        verificationFee =\\n            executionOverhead[dstChainSlug_] *\\n            dstRelativeGasPrice;\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256 dstChainSlug_,\\n        uint256 dstRelativeGasPrice_\\n    ) internal view virtual returns (uint256);\\n\\n    /**\\n     * @notice set capacitor address and packet size\\n     * @param capacitor_ capacitor address\\n     * @param maxPacketSize_ max messages allowed in one packet\\n     */\\n    function registerCapacitor(\\n        uint256 siblingChainSlug_,\\n        address capacitor_,\\n        uint256 maxPacketSize_\\n    ) external override {\\n        if (msg.sender != socket) revert OnlySocket();\\n        if (isInitialised[siblingChainSlug_]) revert AlreadyInitialised();\\n\\n        isInitialised[siblingChainSlug_] = true;\\n        maxPacketSize[siblingChainSlug_] = maxPacketSize_;\\n        emit CapacitorRegistered(siblingChainSlug_, capacitor_, maxPacketSize_);\\n    }\\n\\n    /**\\n     * @notice pause a path\\n     */\\n    function tripPath(\\n        uint256 nonce_,\\n        uint256 srcChainSlug_,\\n        bytes memory signature_\\n    ) external {\\n        address watcher = SignatureVerifierLib.recoverSignerFromDigest(\\n            // it includes trip status at the end\\n            keccak256(\\n                abi.encode(\\\"TRIP_PATH\\\", srcChainSlug_, chainSlug, nonce_, true)\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(\\\"WATCHER_ROLE\\\", srcChainSlug_, watcher))\\n            revert NoPermit(\\\"WATCHER_ROLE\\\");\\n        uint256 nonce = nextNonce[watcher]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        //source chain based tripping\\n        tripSinglePath[srcChainSlug_] = true;\\n        emit PathTripped(srcChainSlug_, true);\\n    }\\n\\n    /**\\n     * @notice pause execution\\n     */\\n    function tripGlobal(uint256 nonce_, bytes memory signature_) external {\\n        address tripper = SignatureVerifierLib.recoverSignerFromDigest(\\n            // it includes trip status at the end\\n            keccak256(abi.encode(\\\"TRIP\\\", chainSlug, nonce_, true)),\\n            signature_\\n        );\\n\\n        if (!_hasRole(\\\"TRIP_ROLE\\\", tripper)) revert NoPermit(\\\"TRIP_ROLE\\\");\\n        uint256 nonce = nextNonce[tripper]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        tripGlobalFuse = true;\\n        emit SwitchboardTripped(true);\\n    }\\n\\n    /**\\n     * @notice unpause a path\\n     */\\n    function untripPath(\\n        uint256 nonce_,\\n        uint256 srcChainSlug_,\\n        bytes memory signature_\\n    ) external {\\n        address untripper = SignatureVerifierLib.recoverSignerFromDigest(\\n            // it includes trip status at the end\\n            keccak256(\\n                abi.encode(\\n                    \\\"UNTRIP_PATH\\\",\\n                    chainSlug,\\n                    srcChainSlug_,\\n                    nonce_,\\n                    false\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(\\\"UNTRIP_ROLE\\\", untripper)) revert NoPermit(\\\"UNTRIP_ROLE\\\");\\n        uint256 nonce = nextNonce[untripper]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        tripSinglePath[srcChainSlug_] = false;\\n        emit PathTripped(srcChainSlug_, false);\\n    }\\n\\n    /**\\n     * @notice unpause execution\\n     */\\n    function untrip(uint256 nonce_, bytes memory signature_) external {\\n        address untripper = SignatureVerifierLib.recoverSignerFromDigest(\\n            // it includes trip status at the end\\n            keccak256(abi.encode(\\\"UNTRIP\\\", chainSlug, nonce_, false)),\\n            signature_\\n        );\\n\\n        if (!_hasRole(\\\"UNTRIP_ROLE\\\", untripper)) revert NoPermit(\\\"UNTRIP_ROLE\\\");\\n        uint256 nonce = nextNonce[untripper]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        tripGlobalFuse = false;\\n        emit SwitchboardTripped(false);\\n    }\\n\\n    /**\\n     * @notice updates execution overhead\\n     * @param executionOverhead_ new execution overhead cost\\n     */\\n    function setExecutionOverhead(\\n        uint256 nonce_,\\n        uint256 dstChainSlug_,\\n        uint256 executionOverhead_,\\n        bytes memory signature_\\n    ) external {\\n        address gasLimitUpdater = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"EXECUTION_OVERHEAD_UPDATE\\\",\\n                    nonce_,\\n                    chainSlug,\\n                    dstChainSlug_,\\n                    executionOverhead_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(\\\"GAS_LIMIT_UPDATER_ROLE\\\", dstChainSlug_, gasLimitUpdater))\\n            revert NoPermit(\\\"GAS_LIMIT_UPDATER_ROLE\\\");\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        executionOverhead[dstChainSlug_] = executionOverhead_;\\n        emit ExecutionOverheadSet(dstChainSlug_, executionOverhead_);\\n    }\\n\\n    /**\\n     * @notice updates gasPriceOracle_ address\\n     * @param gasPriceOracle_ new gasPriceOracle_\\n     */\\n    function setGasPriceOracle(\\n        address gasPriceOracle_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        gasPriceOracle__ = IGasPriceOracle(gasPriceOracle_);\\n        emit GasPriceOracleSet(gasPriceOracle_);\\n    }\\n\\n    function withdrawFees(address account_) external onlyRole(WITHDRAW_ROLE) {\\n        FeesHelper.withdrawFees(account_);\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/native/ArbitrumL1Switchboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IBridge.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IInbox.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IOutbox.sol\\\";\\n\\nimport \\\"./NativeSwitchboardBase.sol\\\";\\n\\ncontract ArbitrumL1Switchboard is NativeSwitchboardBase {\\n    address public remoteRefundAddress;\\n    address public callValueRefundAddress;\\n    uint256 public arbitrumNativeFee;\\n\\n    IInbox public inbox__;\\n    IBridge public bridge__;\\n    IOutbox public outbox__;\\n\\n    event UpdatedInboxAddress(address inbox);\\n    event UpdatedRefundAddresses(\\n        address remoteRefundAddress,\\n        address callValueRefundAddress\\n    );\\n    event UpdatedArbitrumNativeFee(uint256 arbitrumNativeFee);\\n    event UpdatedBridge(address bridgeAddress);\\n    event UpdatedOutbox(address outboxAddress);\\n\\n    modifier onlyRemoteSwitchboard() override {\\n        if (msg.sender != address(bridge__)) revert InvalidSender();\\n        address l2Sender = outbox__.l2ToL1Sender();\\n        if (l2Sender != remoteNativeSwitchboard) revert InvalidSender();\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 chainSlug_,\\n        uint256 arbitrumNativeFee_,\\n        uint256 initiateGasLimit_,\\n        uint256 executionOverhead_,\\n        address inbox_,\\n        address owner_,\\n        address socket_,\\n        IGasPriceOracle gasPriceOracle_,\\n        address bridge_,\\n        address outbox_\\n    )\\n        AccessControlExtended(owner_)\\n        NativeSwitchboardBase(\\n            socket_,\\n            chainSlug_,\\n            initiateGasLimit_,\\n            executionOverhead_,\\n            gasPriceOracle_\\n        )\\n    {\\n        inbox__ = IInbox(inbox_);\\n        arbitrumNativeFee = arbitrumNativeFee_;\\n\\n        bridge__ = IBridge(bridge_);\\n        outbox__ = IOutbox(outbox_);\\n\\n        remoteRefundAddress = msg.sender;\\n        callValueRefundAddress = msg.sender;\\n    }\\n\\n    function initiateNativeConfirmation(\\n        bytes32 packetId_,\\n        uint256 maxSubmissionCost_,\\n        uint256 maxGas_,\\n        uint256 gasPriceBid_\\n    ) external payable {\\n        bytes memory data = _encodeRemoteCall(packetId_);\\n\\n        // to avoid stack too deep\\n        address callValueRefund = callValueRefundAddress;\\n        address remoteRefund = remoteRefundAddress;\\n\\n        inbox__.createRetryableTicket{value: msg.value}(\\n            remoteNativeSwitchboard,\\n            0, // no value needed for receivePacket\\n            maxSubmissionCost_,\\n            remoteRefund,\\n            callValueRefund,\\n            maxGas_,\\n            gasPriceBid_,\\n            data\\n        );\\n\\n        emit InitiatedNativeConfirmation(packetId_);\\n    }\\n\\n    function _encodeRemoteCall(\\n        bytes32 packetId_\\n    ) internal view returns (bytes memory data) {\\n        data = abi.encodeWithSelector(\\n            this.receivePacket.selector,\\n            packetId_,\\n            _getRoot(packetId_)\\n        );\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256,\\n        uint256,\\n        uint256 sourceGasPrice_\\n    ) internal view override returns (uint256) {\\n        // TODO: check if dynamic fees can be divided into more constants\\n        // arbitrum: check src contract\\n        return initiateGasLimit * sourceGasPrice_ + arbitrumNativeFee;\\n    }\\n\\n    function updateRefundAddresses(\\n        address remoteRefundAddress_,\\n        address callValueRefundAddress_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        remoteRefundAddress = remoteRefundAddress_;\\n        callValueRefundAddress = callValueRefundAddress_;\\n\\n        emit UpdatedRefundAddresses(\\n            remoteRefundAddress_,\\n            callValueRefundAddress_\\n        );\\n    }\\n\\n    function updateArbitrumNativeFee(\\n        uint256 nonce_,\\n        uint256 arbitrumNativeFee_,\\n        bytes calldata signature_\\n    ) external {\\n        address gasLimitUpdater = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"ARBITRUM_NATIVE_FEE_UPDATE\\\",\\n                    chainSlug,\\n                    nonce_,\\n                    arbitrumNativeFee_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(GAS_LIMIT_UPDATER_ROLE, gasLimitUpdater))\\n            revert NoPermit(GAS_LIMIT_UPDATER_ROLE);\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        arbitrumNativeFee = arbitrumNativeFee_;\\n        emit UpdatedArbitrumNativeFee(arbitrumNativeFee_);\\n    }\\n\\n    function updateInboxAddresses(\\n        address inbox_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        inbox__ = IInbox(inbox_);\\n        emit UpdatedInboxAddress(inbox_);\\n    }\\n\\n    function updateBridge(\\n        address bridgeAddress_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        bridge__ = IBridge(bridgeAddress_);\\n\\n        emit UpdatedBridge(bridgeAddress_);\\n    }\\n\\n    function updateOutbox(\\n        address outboxAddress_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        outbox__ = IOutbox(outboxAddress_);\\n\\n        emit UpdatedOutbox(outboxAddress_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/native/ArbitrumL2Switchboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IArbSys.sol\\\";\\n\\nimport \\\"../../libraries/AddressAliasHelper.sol\\\";\\nimport \\\"./NativeSwitchboardBase.sol\\\";\\n\\ncontract ArbitrumL2Switchboard is NativeSwitchboardBase {\\n    uint256 public confirmGasLimit;\\n    IArbSys public immutable arbsys__ = IArbSys(address(100));\\n    event UpdatedConfirmGasLimit(uint256 confirmGasLimit);\\n\\n    modifier onlyRemoteSwitchboard() override {\\n        if (\\n            msg.sender !=\\n            AddressAliasHelper.applyL1ToL2Alias(remoteNativeSwitchboard)\\n        ) revert InvalidSender();\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 chainSlug_,\\n        uint256 confirmGasLimit_,\\n        uint256 initiateGasLimit_,\\n        uint256 executionOverhead_,\\n        address owner_,\\n        address socket_,\\n        IGasPriceOracle gasPriceOracle_\\n    )\\n        AccessControlExtended(owner_)\\n        NativeSwitchboardBase(\\n            socket_,\\n            chainSlug_,\\n            initiateGasLimit_,\\n            executionOverhead_,\\n            gasPriceOracle_\\n        )\\n    {\\n        confirmGasLimit = confirmGasLimit_;\\n    }\\n\\n    function initiateNativeConfirmation(bytes32 packetId_) external {\\n        bytes memory data = _encodeRemoteCall(packetId_);\\n\\n        arbsys__.sendTxToL1(remoteNativeSwitchboard, data);\\n        emit InitiatedNativeConfirmation(packetId_);\\n    }\\n\\n    function _encodeRemoteCall(\\n        bytes32 packetId_\\n    ) internal view returns (bytes memory data) {\\n        data = abi.encodeWithSelector(\\n            this.receivePacket.selector,\\n            packetId_,\\n            _getRoot(packetId_)\\n        );\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256,\\n        uint256 dstRelativeGasPrice_,\\n        uint256 sourceGasPrice_\\n    ) internal view override returns (uint256) {\\n        return\\n            initiateGasLimit *\\n            sourceGasPrice_ +\\n            confirmGasLimit *\\n            dstRelativeGasPrice_;\\n    }\\n\\n    function updateConfirmGasLimit(\\n        uint256 nonce_,\\n        uint256 confirmGasLimit_,\\n        bytes memory signature_\\n    ) external {\\n        address gasLimitUpdater = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"L1_RECEIVE_GAS_LIMIT_UPDATE\\\",\\n                    chainSlug,\\n                    nonce_,\\n                    confirmGasLimit_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(GAS_LIMIT_UPDATER_ROLE, gasLimitUpdater))\\n            revert NoPermit(GAS_LIMIT_UPDATER_ROLE);\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        confirmGasLimit = confirmGasLimit_;\\n        emit UpdatedConfirmGasLimit(confirmGasLimit_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/native/NativeSwitchboardBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../../interfaces/ISwitchboard.sol\\\";\\nimport \\\"../../interfaces/IGasPriceOracle.sol\\\";\\nimport \\\"../../interfaces/ICapacitor.sol\\\";\\n\\nimport \\\"../../utils/AccessControlExtended.sol\\\";\\nimport \\\"../../libraries/SignatureVerifierLib.sol\\\";\\nimport \\\"../../libraries/RescueFundsLib.sol\\\";\\nimport \\\"../../libraries/FeesHelper.sol\\\";\\n\\nimport {GAS_LIMIT_UPDATER_ROLE, GOVERNANCE_ROLE, RESCUE_ROLE, WITHDRAW_ROLE, TRIP_ROLE, UNTRIP_ROLE} from \\\"../../utils/AccessRoles.sol\\\";\\n\\nabstract contract NativeSwitchboardBase is ISwitchboard, AccessControlExtended {\\n    IGasPriceOracle public gasPriceOracle__;\\n\\n    bool public tripGlobalFuse;\\n\\n    ICapacitor public capacitor__;\\n    bool public isInitialised;\\n    uint256 public maxPacketSize;\\n\\n    uint256 public executionOverhead;\\n    uint256 public initiateGasLimit;\\n    address public remoteNativeSwitchboard;\\n    address public socket;\\n\\n    uint256 public immutable chainSlug;\\n\\n    // stores the roots received from native bridge\\n    mapping(bytes32 => bytes32) public packetIdToRoot;\\n    // transmitter => nextNonce\\n    mapping(address => uint256) public nextNonce;\\n\\n    event SwitchboardTripped(bool tripGlobalFuse);\\n    event ExecutionOverheadSet(uint256 executionOverhead);\\n    event InitiateGasLimitSet(uint256 gasLimit);\\n    event CapacitorSet(address capacitor);\\n    event GasPriceOracleSet(address gasPriceOracle);\\n    event InitiatedNativeConfirmation(bytes32 packetId);\\n    event CapacitorRegistered(address capacitor, uint256 maxPacketSize);\\n    event UpdatedRemoteNativeSwitchboard(address remoteNativeSwitchboard);\\n    event RootReceived(bytes32 packetId, bytes32 root);\\n\\n    error FeesNotEnough();\\n    error AlreadyInitialised();\\n    error InvalidSender();\\n    error NoRootFound();\\n    error InvalidNonce();\\n    error OnlySocket();\\n\\n    modifier onlyRemoteSwitchboard() virtual {\\n        _;\\n    }\\n\\n    constructor(\\n        address socket_,\\n        uint256 chainSlug_,\\n        uint256 initiateGasLimit_,\\n        uint256 executionOverhead_,\\n        IGasPriceOracle gasPriceOracle_\\n    ) {\\n        socket = socket_;\\n        chainSlug = chainSlug_;\\n        initiateGasLimit = initiateGasLimit_;\\n        executionOverhead = executionOverhead_;\\n        gasPriceOracle__ = gasPriceOracle_;\\n    }\\n\\n    function _getRoot(bytes32 packetId_) internal view returns (bytes32 root) {\\n        uint64 capacitorPacketCount = uint64(uint256(packetId_));\\n        root = capacitor__.getRootByCount(capacitorPacketCount);\\n        if (root == bytes32(0)) revert NoRootFound();\\n    }\\n\\n    function receivePacket(\\n        bytes32 packetId_,\\n        bytes32 root_\\n    ) external onlyRemoteSwitchboard {\\n        packetIdToRoot[packetId_] = root_;\\n        emit RootReceived(packetId_, root_);\\n    }\\n\\n    /**\\n     * @notice verifies if the packet satisfies needed checks before execution\\n     * @param packetId_ packet id\\n     */\\n    function allowPacket(\\n        bytes32 root_,\\n        bytes32 packetId_,\\n        uint32,\\n        uint256\\n    ) external view override returns (bool) {\\n        if (tripGlobalFuse) return false;\\n        if (packetIdToRoot[packetId_] != root_) return false;\\n\\n        return true;\\n    }\\n\\n    // assumption: natives have 18 decimals\\n    function payFees(uint32 dstChainSlug_) external payable override {}\\n\\n    function getMinFees(\\n        uint32 dstChainSlug_\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 switchboardFee_, uint256 verificationFee_)\\n    {\\n        return _calculateMinFees(dstChainSlug_);\\n    }\\n\\n    function _calculateMinFees(\\n        uint32 dstChainSlug_\\n    )\\n        internal\\n        view\\n        returns (uint256 switchboardFee_, uint256 verificationFee_)\\n    {\\n        (uint256 sourceGasPrice, uint256 dstRelativeGasPrice) = gasPriceOracle__\\n            .getGasPrices(dstChainSlug_);\\n\\n        switchboardFee_ =\\n            _getMinSwitchboardFees(\\n                dstChainSlug_,\\n                dstRelativeGasPrice,\\n                sourceGasPrice\\n            ) /\\n            maxPacketSize;\\n\\n        verificationFee_ = executionOverhead * dstRelativeGasPrice;\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256 dstChainSlug_,\\n        uint256 dstRelativeGasPrice_,\\n        uint256 sourceGasPrice_\\n    ) internal view virtual returns (uint256);\\n\\n    /**\\n     * @notice set capacitor address and packet size\\n     * @param capacitor_ capacitor address\\n     * @param maxPacketSize_ max messages allowed in one packet\\n     */\\n    function registerCapacitor(\\n        uint256,\\n        address capacitor_,\\n        uint256 maxPacketSize_\\n    ) external override {\\n        if (msg.sender != socket) revert OnlySocket();\\n        if (isInitialised) revert AlreadyInitialised();\\n\\n        isInitialised = true;\\n        maxPacketSize = maxPacketSize_;\\n        capacitor__ = ICapacitor(capacitor_);\\n\\n        emit CapacitorRegistered(capacitor_, maxPacketSize_);\\n    }\\n\\n    /**\\n     * @notice pause execution\\n     */\\n    function tripGlobal(uint256 nonce_, bytes memory signature_) external {\\n        address watcher = SignatureVerifierLib.recoverSignerFromDigest(\\n            // it includes trip status at the end\\n            keccak256(abi.encode(\\\"TRIP\\\", chainSlug, nonce_, true)),\\n            signature_\\n        );\\n\\n        if (!_hasRole(TRIP_ROLE, watcher)) revert NoPermit(TRIP_ROLE);\\n\\n        uint256 nonce = nextNonce[watcher]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        tripGlobalFuse = true;\\n        emit SwitchboardTripped(true);\\n    }\\n\\n    /**\\n     * @notice unpause execution\\n     */\\n    function untrip(uint256 nonce_, bytes memory signature_) external {\\n        address watcher = SignatureVerifierLib.recoverSignerFromDigest(\\n            // it includes trip status at the end\\n            keccak256(abi.encode(\\\"UNTRIP\\\", chainSlug, nonce_, false)),\\n            signature_\\n        );\\n\\n        if (!_hasRole(UNTRIP_ROLE, watcher)) revert NoPermit(UNTRIP_ROLE);\\n        uint256 nonce = nextNonce[watcher]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        tripGlobalFuse = false;\\n        emit SwitchboardTripped(false);\\n    }\\n\\n    /**\\n     * @notice updates execution overhead\\n     * @param executionOverhead_ new execution overhead cost\\n     */\\n    function setExecutionOverhead(\\n        uint256 nonce_,\\n        uint256 executionOverhead_,\\n        bytes memory signature_\\n    ) external {\\n        address gasLimitUpdater = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"EXECUTION_OVERHEAD_UPDATE\\\",\\n                    nonce_,\\n                    chainSlug,\\n                    executionOverhead_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(GAS_LIMIT_UPDATER_ROLE, gasLimitUpdater))\\n            revert NoPermit(GAS_LIMIT_UPDATER_ROLE);\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        executionOverhead = executionOverhead_;\\n        emit ExecutionOverheadSet(executionOverhead_);\\n    }\\n\\n    /**\\n     * @notice updates initiateGasLimit\\n     * @param gasLimit_ new gas limit for initiateGasLimit\\n     */\\n    function setInitiateGasLimit(\\n        uint256 nonce_,\\n        uint256 gasLimit_,\\n        bytes memory signature_\\n    ) external {\\n        address gasLimitUpdater = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"INITIAL_CONFIRMATION_GAS_LIMIT_UPDATE\\\",\\n                    chainSlug,\\n                    nonce_,\\n                    gasLimit_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(GAS_LIMIT_UPDATER_ROLE, gasLimitUpdater))\\n            revert NoPermit(GAS_LIMIT_UPDATER_ROLE);\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        initiateGasLimit = gasLimit_;\\n        emit InitiateGasLimitSet(gasLimit_);\\n    }\\n\\n    /**\\n     * @notice updates gasPriceOracle_ address\\n     * @param gasPriceOracle_ new gasPriceOracle_\\n     */\\n    function setGasPriceOracle(\\n        address gasPriceOracle_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        gasPriceOracle__ = IGasPriceOracle(gasPriceOracle_);\\n        emit GasPriceOracleSet(gasPriceOracle_);\\n    }\\n\\n    function updateRemoteNativeSwitchboard(\\n        address remoteNativeSwitchboard_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        remoteNativeSwitchboard = remoteNativeSwitchboard_;\\n        emit UpdatedRemoteNativeSwitchboard(remoteNativeSwitchboard_);\\n    }\\n\\n    function withdrawFees(address account_) external onlyRole(WITHDRAW_ROLE) {\\n        FeesHelper.withdrawFees(account_);\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/native/OptimismSwitchboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/vendor/optimism/ICrossDomainMessenger.sol\\\";\\nimport \\\"./NativeSwitchboardBase.sol\\\";\\n\\ncontract OptimismSwitchboard is NativeSwitchboardBase {\\n    uint256 public receiveGasLimit;\\n    uint256 public confirmGasLimit;\\n\\n    ICrossDomainMessenger public immutable crossDomainMessenger__;\\n\\n    event UpdatedReceiveGasLimit(uint256 receiveGasLimit);\\n    event UpdatedConfirmGasLimit(uint256 confirmGasLimit);\\n\\n    modifier onlyRemoteSwitchboard() override {\\n        if (\\n            msg.sender != address(crossDomainMessenger__) &&\\n            crossDomainMessenger__.xDomainMessageSender() !=\\n            remoteNativeSwitchboard\\n        ) revert InvalidSender();\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 chainSlug_,\\n        uint256 receiveGasLimit_,\\n        uint256 confirmGasLimit_,\\n        uint256 initiateGasLimit_,\\n        uint256 executionOverhead_,\\n        address owner_,\\n        address socket_,\\n        IGasPriceOracle gasPriceOracle_,\\n        address crossDomainMessenger_\\n    )\\n        AccessControlExtended(owner_)\\n        NativeSwitchboardBase(\\n            socket_,\\n            chainSlug_,\\n            initiateGasLimit_,\\n            executionOverhead_,\\n            gasPriceOracle_\\n        )\\n    {\\n        receiveGasLimit = receiveGasLimit_;\\n        confirmGasLimit = confirmGasLimit_;\\n        crossDomainMessenger__ = ICrossDomainMessenger(crossDomainMessenger_);\\n    }\\n\\n    function initiateNativeConfirmation(bytes32 packetId_) external {\\n        bytes memory data = _encodeRemoteCall(packetId_);\\n\\n        crossDomainMessenger__.sendMessage(\\n            remoteNativeSwitchboard,\\n            data,\\n            uint32(receiveGasLimit)\\n        );\\n        emit InitiatedNativeConfirmation(packetId_);\\n    }\\n\\n    function _encodeRemoteCall(\\n        bytes32 packetId_\\n    ) internal view returns (bytes memory data) {\\n        data = abi.encodeWithSelector(\\n            this.receivePacket.selector,\\n            packetId_,\\n            _getRoot(packetId_)\\n        );\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256,\\n        uint256 dstRelativeGasPrice_,\\n        uint256 sourceGasPrice_\\n    ) internal view override returns (uint256) {\\n        // confirmGasLimit will be 0 when switchboard is deployed on L1\\n        return\\n            initiateGasLimit *\\n            sourceGasPrice_ +\\n            confirmGasLimit *\\n            dstRelativeGasPrice_;\\n    }\\n\\n    function updateConfirmGasLimit(\\n        uint256 nonce_,\\n        uint256 confirmGasLimit_,\\n        bytes memory signature_\\n    ) external {\\n        address gasLimitUpdater = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"L1_RECEIVE_GAS_LIMIT_UPDATE\\\",\\n                    chainSlug,\\n                    nonce_,\\n                    confirmGasLimit_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(GAS_LIMIT_UPDATER_ROLE, gasLimitUpdater))\\n            revert NoPermit(GAS_LIMIT_UPDATER_ROLE);\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        confirmGasLimit = confirmGasLimit_;\\n        emit UpdatedConfirmGasLimit(confirmGasLimit_);\\n    }\\n\\n    function updateReceiveGasLimit(\\n        uint256 receiveGasLimit_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        receiveGasLimit = receiveGasLimit_;\\n        emit UpdatedReceiveGasLimit(receiveGasLimit_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/native/PolygonL1Switchboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"lib/contracts/contracts/tunnel/FxBaseRootTunnel.sol\\\";\\nimport \\\"./NativeSwitchboardBase.sol\\\";\\n\\ncontract PolygonL1Switchboard is NativeSwitchboardBase, FxBaseRootTunnel {\\n    event FxChildTunnelSet(address fxChildTunnel, address newFxChildTunnel);\\n\\n    modifier onlyRemoteSwitchboard() override {\\n        require(true, \\\"ONLY_FX_CHILD\\\");\\n\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 chainSlug_,\\n        uint256 initiateGasLimit_,\\n        uint256 executionOverhead_,\\n        address checkpointManager_,\\n        address fxRoot_,\\n        address owner_,\\n        address socket_,\\n        IGasPriceOracle gasPriceOracle_\\n    )\\n        AccessControlExtended(owner_)\\n        NativeSwitchboardBase(\\n            socket_,\\n            chainSlug_,\\n            initiateGasLimit_,\\n            executionOverhead_,\\n            gasPriceOracle_\\n        )\\n        FxBaseRootTunnel(checkpointManager_, fxRoot_)\\n    {}\\n\\n    /**\\n     * @param packetId_ - packet id\\n     */\\n    function initiateNativeConfirmation(bytes32 packetId_) external payable {\\n        bytes memory data = _encodeRemoteCall(packetId_);\\n        _sendMessageToChild(data);\\n        emit InitiatedNativeConfirmation(packetId_);\\n    }\\n\\n    function _encodeRemoteCall(\\n        bytes32 packetId_\\n    ) internal view returns (bytes memory data) {\\n        data = abi.encode(packetId_, _getRoot(packetId_));\\n    }\\n\\n    function _processMessageFromChild(bytes memory message_) internal override {\\n        (bytes32 packetId, bytes32 root) = abi.decode(\\n            message_,\\n            (bytes32, bytes32)\\n        );\\n        packetIdToRoot[packetId] = root;\\n        emit RootReceived(packetId, root);\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256,\\n        uint256,\\n        uint256 sourceGasPrice_\\n    ) internal view override returns (uint256) {\\n        return initiateGasLimit * sourceGasPrice_;\\n    }\\n\\n    // set fxChildTunnel if not set already\\n    function setFxChildTunnel(\\n        address fxChildTunnel_\\n    ) public override onlyRole(GOVERNANCE_ROLE) {\\n        emit FxChildTunnelSet(fxChildTunnel, fxChildTunnel_);\\n        fxChildTunnel = fxChildTunnel_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/switchboard/native/PolygonL2Switchboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"lib/contracts/contracts/tunnel/FxBaseChildTunnel.sol\\\";\\nimport \\\"./NativeSwitchboardBase.sol\\\";\\n\\ncontract PolygonL2Switchboard is NativeSwitchboardBase, FxBaseChildTunnel {\\n    uint256 public confirmGasLimit;\\n\\n    event FxChildUpdate(address oldFxChild, address newFxChild);\\n    event FxRootTunnelSet(address fxRootTunnel, address newFxRootTunnel);\\n    event UpdatedConfirmGasLimit(uint256 confirmGasLimit);\\n\\n    modifier onlyRemoteSwitchboard() override {\\n        require(true, \\\"ONLY_FX_CHILD\\\");\\n\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 chainSlug_,\\n        uint256 confirmGasLimit_,\\n        uint256 initiateGasLimit_,\\n        uint256 executionOverhead_,\\n        address fxChild_,\\n        address owner_,\\n        address socket_,\\n        IGasPriceOracle gasPriceOracle_\\n    )\\n        AccessControlExtended(owner_)\\n        NativeSwitchboardBase(\\n            socket_,\\n            chainSlug_,\\n            initiateGasLimit_,\\n            executionOverhead_,\\n            gasPriceOracle_\\n        )\\n        FxBaseChildTunnel(fxChild_)\\n    {\\n        confirmGasLimit = confirmGasLimit_;\\n    }\\n\\n    /**\\n     * @param packetId_ - packet id\\n     */\\n    function initiateNativeConfirmation(bytes32 packetId_) external payable {\\n        bytes memory data = _encodeRemoteCall(packetId_);\\n\\n        _sendMessageToRoot(data);\\n        emit InitiatedNativeConfirmation(packetId_);\\n    }\\n\\n    function _encodeRemoteCall(\\n        bytes32 packetId_\\n    ) internal view returns (bytes memory data) {\\n        data = abi.encode(packetId_, _getRoot(packetId_));\\n    }\\n\\n    /**\\n     * validate sender verifies if `rootMessageSender` is the root contract (notary) on L1.\\n     */\\n    function _processMessageFromRoot(\\n        uint256,\\n        address rootMessageSender_,\\n        bytes memory data_\\n    ) internal override validateSender(rootMessageSender_) {\\n        (bytes32 packetId, bytes32 root) = abi.decode(\\n            data_,\\n            (bytes32, bytes32)\\n        );\\n        packetIdToRoot[packetId] = root;\\n        emit RootReceived(packetId, root);\\n    }\\n\\n    function _getMinSwitchboardFees(\\n        uint256,\\n        uint256 dstRelativeGasPrice_,\\n        uint256 sourceGasPrice_\\n    ) internal view override returns (uint256) {\\n        return\\n            initiateGasLimit *\\n            sourceGasPrice_ +\\n            confirmGasLimit *\\n            dstRelativeGasPrice_;\\n    }\\n\\n    function updateConfirmGasLimit(\\n        uint256 nonce_,\\n        uint256 confirmGasLimit_,\\n        bytes memory signature_\\n    ) external {\\n        address gasLimitUpdater = SignatureVerifierLib.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"L1_RECEIVE_GAS_LIMIT_UPDATE\\\",\\n                    chainSlug,\\n                    nonce_,\\n                    confirmGasLimit_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(GAS_LIMIT_UPDATER_ROLE, gasLimitUpdater))\\n            revert NoPermit(GAS_LIMIT_UPDATER_ROLE);\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        confirmGasLimit = confirmGasLimit_;\\n        emit UpdatedConfirmGasLimit(confirmGasLimit_);\\n    }\\n\\n    /**\\n     * @notice Update the address of the FxChild\\n     * @param fxChild_ The address of the new FxChild\\n     **/\\n    function updateFxChild(\\n        address fxChild_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        emit FxChildUpdate(fxChild, fxChild_);\\n        fxChild = fxChild_;\\n    }\\n\\n    function setFxRootTunnel(\\n        address fxRootTunnel_\\n    ) external override onlyRole(GOVERNANCE_ROLE) {\\n        emit FxRootTunnelSet(fxRootTunnel, fxRootTunnel_);\\n        fxRootTunnel = fxRootTunnel_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TransmitManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.7;\\n\\nimport \\\"./interfaces/ITransmitManager.sol\\\";\\nimport \\\"./interfaces/ISignatureVerifier.sol\\\";\\nimport \\\"./interfaces/IGasPriceOracle.sol\\\";\\n\\nimport \\\"./utils/AccessControlExtended.sol\\\";\\nimport \\\"./libraries/RescueFundsLib.sol\\\";\\nimport \\\"./libraries/FeesHelper.sol\\\";\\nimport {GOVERNANCE_ROLE, WITHDRAW_ROLE, RESCUE_ROLE, GAS_LIMIT_UPDATER_ROLE} from \\\"./utils/AccessRoles.sol\\\";\\n\\ncontract TransmitManager is ITransmitManager, AccessControlExtended {\\n    ISignatureVerifier public signatureVerifier__;\\n    IGasPriceOracle public gasPriceOracle__;\\n\\n    uint32 public immutable chainSlug;\\n    uint256 public sealGasLimit;\\n    mapping(uint256 => uint256) public proposeGasLimit;\\n\\n    // transmitter => nextNonce\\n    mapping(address => uint256) public nextNonce;\\n\\n    error InsufficientTransmitFees();\\n    error InvalidNonce();\\n\\n    event GasPriceOracleSet(address gasPriceOracle);\\n    event SealGasLimitSet(uint256 gasLimit);\\n    event ProposeGasLimitSet(uint256 dstChainSlug, uint256 gasLimit);\\n\\n    /**\\n     * @notice emits when a new signature verifier contract is set\\n     * @param signatureVerifier address of new verifier contract\\n     */\\n    event SignatureVerifierSet(address signatureVerifier);\\n\\n    constructor(\\n        ISignatureVerifier signatureVerifier_,\\n        IGasPriceOracle gasPriceOracle_,\\n        address owner_,\\n        uint32 chainSlug_,\\n        uint256 sealGasLimit_\\n    ) AccessControlExtended(owner_) {\\n        chainSlug = chainSlug_;\\n        sealGasLimit = sealGasLimit_;\\n        signatureVerifier__ = signatureVerifier_;\\n        gasPriceOracle__ = IGasPriceOracle(gasPriceOracle_);\\n    }\\n\\n    // @param slugs_ packs the siblingChainSlug & sigChainSlug\\n    // @dev signature sent to this function can be reused on other chains\\n    // @dev hence caller should add some identifier to stop this.\\n    // slugs_(256) = siblingChainSlug(128) | sigChainSlug(128)\\n    // @dev sibling chain slug is required to check the transmitter role\\n    // @dev sig chain slug is required by signature. On src, this is sibling slug while on\\n    // destination, it is current chain slug\\n    function checkTransmitter(\\n        uint32 siblingSlug,\\n        bytes32 digest_,\\n        bytes calldata signature_\\n    ) external view override returns (address, bool) {\\n        address transmitter = signatureVerifier__.recoverSignerFromDigest(\\n            digest_,\\n            signature_\\n        );\\n\\n        return (\\n            transmitter,\\n            _hasRole(\\\"TRANSMITTER_ROLE\\\", siblingSlug, transmitter)\\n        );\\n    }\\n\\n    function payFees(uint32 siblingChainSlug_) external payable override {}\\n\\n    function getMinFees(\\n        uint32 siblingChainSlug_\\n    ) external view override returns (uint256) {\\n        return _calculateMinFees(siblingChainSlug_);\\n    }\\n\\n    function _calculateMinFees(\\n        uint32 siblingChainSlug_\\n    ) internal view returns (uint256 minTransmissionFees) {\\n        (\\n            uint256 sourceGasPrice,\\n            uint256 siblingRelativeGasPrice\\n        ) = gasPriceOracle__.getGasPrices(siblingChainSlug_);\\n\\n        minTransmissionFees =\\n            sealGasLimit *\\n            sourceGasPrice +\\n            proposeGasLimit[siblingChainSlug_] *\\n            siblingRelativeGasPrice;\\n    }\\n\\n    function withdrawFees(address account_) external onlyRole(WITHDRAW_ROLE) {\\n        FeesHelper.withdrawFees(account_);\\n    }\\n\\n    /**\\n     * @notice updates seal gas limit\\n     * @param gasLimit_ new seal gas limit\\n     */\\n    function setSealGasLimit(\\n        uint256 nonce_,\\n        uint256 gasLimit_,\\n        bytes calldata signature_\\n    ) external {\\n        address gasLimitUpdater = signatureVerifier__.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"SEAL_GAS_LIMIT_UPDATE\\\",\\n                    chainSlug,\\n                    nonce_,\\n                    gasLimit_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(GAS_LIMIT_UPDATER_ROLE, gasLimitUpdater))\\n            revert NoPermit(GAS_LIMIT_UPDATER_ROLE);\\n\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        sealGasLimit = gasLimit_;\\n        emit SealGasLimitSet(gasLimit_);\\n    }\\n\\n    /**\\n     * @notice updates propose gas limit for `dstChainSlug_`\\n     * @param gasLimit_ new propose gas limit\\n     */\\n    function setProposeGasLimit(\\n        uint256 nonce_,\\n        uint256 dstChainSlug_,\\n        uint256 gasLimit_,\\n        bytes calldata signature_\\n    ) external override {\\n        address gasLimitUpdater = signatureVerifier__.recoverSignerFromDigest(\\n            keccak256(\\n                abi.encode(\\n                    \\\"PROPOSE_GAS_LIMIT_UPDATE\\\",\\n                    chainSlug,\\n                    dstChainSlug_,\\n                    nonce_,\\n                    gasLimit_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        if (!_hasRole(\\\"GAS_LIMIT_UPDATER_ROLE\\\", dstChainSlug_, gasLimitUpdater))\\n            revert NoPermit(\\\"GAS_LIMIT_UPDATER_ROLE\\\");\\n\\n        uint256 nonce = nextNonce[gasLimitUpdater]++;\\n        if (nonce_ != nonce) revert InvalidNonce();\\n\\n        proposeGasLimit[dstChainSlug_] = gasLimit_;\\n        emit ProposeGasLimitSet(dstChainSlug_, gasLimit_);\\n    }\\n\\n    /**\\n     * @notice updates gasPriceOracle__\\n     * @param gasPriceOracle_ address of Gas Price Oracle\\n     */\\n    function setGasPriceOracle(\\n        address gasPriceOracle_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        gasPriceOracle__ = IGasPriceOracle(gasPriceOracle_);\\n        emit GasPriceOracleSet(gasPriceOracle_);\\n    }\\n\\n    /**\\n     * @notice updates signatureVerifier_\\n     * @param signatureVerifier_ address of Signature Verifier\\n     */\\n    function setSignatureVerifier(\\n        address signatureVerifier_\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        signatureVerifier__ = ISignatureVerifier(signatureVerifier_);\\n        emit SignatureVerifierSet(signatureVerifier_);\\n    }\\n\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, userAddress_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\nabstract contract AccessControl is Ownable {\\n    // role => address => permit\\n    mapping(bytes32 => mapping(address => bool)) private _permits;\\n\\n    event RoleGranted(bytes32 indexed role, address indexed grantee);\\n\\n    event RoleRevoked(bytes32 indexed role, address indexed revokee);\\n\\n    error NoPermit(bytes32 role);\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    modifier onlyRole(bytes32 role) {\\n        if (!_permits[role][msg.sender]) revert NoPermit(role);\\n        _;\\n    }\\n\\n    function grantRole(\\n        bytes32 role_,\\n        address grantee_\\n    ) external virtual onlyOwner {\\n        _grantRole(role_, grantee_);\\n    }\\n\\n    function revokeRole(\\n        bytes32 role_,\\n        address revokee_\\n    ) external virtual onlyOwner {\\n        _revokeRole(role_, revokee_);\\n    }\\n\\n    function _grantRole(bytes32 role_, address grantee_) internal {\\n        _permits[role_][grantee_] = true;\\n        emit RoleGranted(role_, grantee_);\\n    }\\n\\n    function _revokeRole(bytes32 role_, address revokee_) internal {\\n        _permits[role_][revokee_] = false;\\n        emit RoleRevoked(role_, revokee_);\\n    }\\n\\n    function hasRole(\\n        bytes32 role_,\\n        address address_\\n    ) external view returns (bool) {\\n        return _hasRole(role_, address_);\\n    }\\n\\n    function _hasRole(\\n        bytes32 role_,\\n        address address_\\n    ) internal view returns (bool) {\\n        return _permits[role_][address_];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AccessControlExtended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"./AccessControl.sol\\\";\\n\\ncontract AccessControlExtended is AccessControl {\\n    modifier onlyRoleWithChainSlug(\\n        string memory roleName_,\\n        uint256 chainSlug_\\n    ) {\\n        bytes32 role = keccak256(abi.encode(roleName_, chainSlug_));\\n        if (!_hasRole(role, msg.sender)) revert NoPermit(role);\\n        _;\\n    }\\n\\n    constructor(address owner_) AccessControl(owner_) {}\\n\\n    function grantRole(\\n        string memory roleName_,\\n        uint256 chainSlug_,\\n        address grantee_\\n    ) external virtual onlyOwner {\\n        _grantRole(roleName_, chainSlug_, grantee_);\\n    }\\n\\n    function grantBatchRole(\\n        bytes32[] calldata roleNames_,\\n        address[] calldata grantees_\\n    ) external virtual onlyOwner {\\n        require(roleNames_.length == grantees_.length);\\n        for (uint256 index = 0; index < roleNames_.length; index++)\\n            _grantRole(roleNames_[index], grantees_[index]);\\n    }\\n\\n    function revokeBatchRole(\\n        bytes32[] calldata roleNames_,\\n        address[] calldata grantees_\\n    ) external virtual onlyOwner {\\n        require(roleNames_.length == grantees_.length);\\n        for (uint256 index = 0; index < roleNames_.length; index++)\\n            _revokeRole(roleNames_[index], grantees_[index]);\\n    }\\n\\n    function _grantRole(\\n        string memory roleName_,\\n        uint256 chainSlug_,\\n        address grantee_\\n    ) internal {\\n        _grantRole(keccak256(abi.encode(roleName_, chainSlug_)), grantee_);\\n    }\\n\\n    function hasRole(\\n        string memory roleName_,\\n        uint256 chainSlug_,\\n        address address_\\n    ) external view returns (bool) {\\n        return _hasRole(roleName_, chainSlug_, address_);\\n    }\\n\\n    function _hasRole(\\n        string memory roleName_,\\n        uint256 chainSlug_,\\n        address address_\\n    ) internal view returns (bool) {\\n        return _hasRole(keccak256(abi.encode(roleName_, chainSlug_)), address_);\\n    }\\n\\n    function revokeRole(\\n        string memory roleName_,\\n        uint256 chainSlug_,\\n        address grantee_\\n    ) external virtual onlyOwner {\\n        _revokeRole(roleName_, chainSlug_, grantee_);\\n    }\\n\\n    function _revokeRole(\\n        string memory roleName_,\\n        uint256 chainSlug_,\\n        address revokee_\\n    ) internal {\\n        _revokeRole(keccak256(abi.encode(roleName_, chainSlug_)), revokee_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AccessRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nbytes32 constant RESCUE_ROLE = keccak256(\\\"RESCUE_ROLE\\\");\\nbytes32 constant WITHDRAW_ROLE = keccak256(\\\"WITHDRAW_ROLE\\\");\\nbytes32 constant TRIP_ROLE = keccak256(\\\"TRIP_ROLE\\\");\\nbytes32 constant UNTRIP_ROLE = keccak256(\\\"UNTRIP_ROLE\\\");\\nbytes32 constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\nbytes32 constant GAS_LIMIT_UPDATER_ROLE = keccak256(\\\"GAS_LIMIT_UPDATER_ROLE\\\");\\nbytes32 constant EXECUTOR_ROLE = keccak256(\\\"EXECUTOR_ROLE\\\");\\n\"\r\n    },\r\n    \"contracts/utils/Hasher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IHasher.sol\\\";\\n\\ncontract Hasher is IHasher {\\n    /// @inheritdoc IHasher\\n    function packMessage(\\n        uint256 srcChainSlug_,\\n        address srcPlug_,\\n        uint256 dstChainSlug_,\\n        address dstPlug_,\\n        bytes32 msgId_,\\n        uint256 msgGasLimit_,\\n        uint256 executionFee_,\\n        bytes calldata payload_\\n    ) external pure override returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    srcChainSlug_,\\n                    srcPlug_,\\n                    dstChainSlug_,\\n                    dstPlug_,\\n                    msgId_,\\n                    msgGasLimit_,\\n                    executionFee_,\\n                    payload_\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nabstract contract Ownable {\\n    address private _owner;\\n    address private _nominee;\\n\\n    event OwnerNominated(address indexed nominee);\\n    event OwnerClaimed(address indexed claimer);\\n\\n    error OnlyOwner();\\n    error OnlyNominee();\\n\\n    constructor(address owner_) {\\n        _claimOwner(owner_);\\n    }\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner) revert OnlyOwner();\\n        _;\\n    }\\n\\n    function owner() external view returns (address) {\\n        return _owner;\\n    }\\n\\n    function nominee() external view returns (address) {\\n        return _nominee;\\n    }\\n\\n    function nominateOwner(address nominee_) external {\\n        if (msg.sender != _owner) revert OnlyOwner();\\n        _nominee = nominee_;\\n        emit OwnerNominated(_nominee);\\n    }\\n\\n    function claimOwner() external {\\n        if (msg.sender != _nominee) revert OnlyNominee();\\n        _claimOwner(msg.sender);\\n    }\\n\\n    function _claimOwner(address claimer_) internal {\\n        _owner = claimer_;\\n        _nominee = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.7;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private _locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(_locked == 1, \\\"REENTRANCY\\\");\\n\\n        _locked = 2;\\n\\n        _;\\n\\n        _locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SignatureVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/ISignatureVerifier.sol\\\";\\nimport \\\"../libraries/SignatureVerifierLib.sol\\\";\\n\\ncontract SignatureVerifier is ISignatureVerifier {\\n    /// @inheritdoc ISignatureVerifier\\n    function recoverSigner(\\n        uint256 destChainSlug_,\\n        uint256 packetId_,\\n        bytes32 root_,\\n        bytes calldata signature_\\n    ) external pure override returns (address signer) {\\n        return\\n            SignatureVerifierLib.recoverSigner(\\n                destChainSlug_,\\n                packetId_,\\n                root_,\\n                signature_\\n            );\\n    }\\n\\n    /**\\n     * @notice returns the address of signer recovered from input signature and digest\\n     */\\n    function recoverSignerFromDigest(\\n        bytes32 digest_,\\n        bytes memory signature_\\n    ) public pure override returns (address signer) {\\n        return\\n            SignatureVerifierLib.recoverSignerFromDigest(digest_, signature_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/lib/ExitPayloadReader.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\n\\nlibrary ExitPayloadReader {\\n    using RLPReader for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct ExitPayload {\\n        RLPReader.RLPItem[] data;\\n    }\\n\\n    struct Receipt {\\n        RLPReader.RLPItem[] data;\\n        bytes raw;\\n        uint256 logIndex;\\n    }\\n\\n    struct Log {\\n        RLPReader.RLPItem data;\\n        RLPReader.RLPItem[] list;\\n    }\\n\\n    struct LogTopics {\\n        RLPReader.RLPItem[] data;\\n    }\\n\\n    // copy paste of private copy() from RLPReader to avoid changing of existing contracts\\n    function copy(\\n        uint256 src,\\n        uint256 dest,\\n        uint256 len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len == 0) return;\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {\\n        RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();\\n\\n        return ExitPayload(payloadData);\\n    }\\n\\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[0].toUint();\\n    }\\n\\n    function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[1].toBytes();\\n    }\\n\\n    function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[2].toUint();\\n    }\\n\\n    function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[3].toUint();\\n    }\\n\\n    function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {\\n        return bytes32(payload.data[4].toUint());\\n    }\\n\\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {\\n        return bytes32(payload.data[5].toUint());\\n    }\\n\\n    function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {\\n        receipt.raw = payload.data[6].toBytes();\\n        RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\\n\\n        if (receiptItem.isList()) {\\n            // legacy tx\\n            receipt.data = receiptItem.toList();\\n        } else {\\n            // pop first byte before parsing receipt\\n            bytes memory typedBytes = receipt.raw;\\n            bytes memory result = new bytes(typedBytes.length - 1);\\n            uint256 srcPtr;\\n            uint256 destPtr;\\n            assembly {\\n                srcPtr := add(33, typedBytes)\\n                destPtr := add(0x20, result)\\n            }\\n\\n            copy(srcPtr, destPtr, result.length);\\n            receipt.data = result.toRlpItem().toList();\\n        }\\n\\n        receipt.logIndex = getReceiptLogIndex(payload);\\n        return receipt;\\n    }\\n\\n    function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[7].toBytes();\\n    }\\n\\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[8].toBytes();\\n    }\\n\\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[8].toUint();\\n    }\\n\\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[9].toUint();\\n    }\\n\\n    // Receipt methods\\n    function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {\\n        return receipt.raw;\\n    }\\n\\n    function getLog(Receipt memory receipt) internal pure returns (Log memory) {\\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\\n        return Log(logData, logData.toList());\\n    }\\n\\n    // Log methods\\n    function getEmitter(Log memory log) internal pure returns (address) {\\n        return RLPReader.toAddress(log.list[0]);\\n    }\\n\\n    function getTopics(Log memory log) internal pure returns (LogTopics memory) {\\n        return LogTopics(log.list[1].toList());\\n    }\\n\\n    function getData(Log memory log) internal pure returns (bytes memory) {\\n        return log.list[2].toBytes();\\n    }\\n\\n    function toRlpBytes(Log memory log) internal pure returns (bytes memory) {\\n        return log.data.toRlpBytes();\\n    }\\n\\n    // LogTopics methods\\n    function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {\\n        return topics.data[index];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/lib/Merkle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Merkle {\\n    function checkMembership(\\n        bytes32 leaf,\\n        uint256 index,\\n        bytes32 rootHash,\\n        bytes memory proof\\n    ) internal pure returns (bool) {\\n        require(proof.length % 32 == 0, \\\"Invalid proof length\\\");\\n        uint256 proofHeight = proof.length / 32;\\n        // Proof of size n means, height of the tree is n+1.\\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\\n        require(index < 2**proofHeight, \\\"Leaf index is too big\\\");\\n\\n        bytes32 proofElement;\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 32; i <= proof.length; i += 32) {\\n            assembly {\\n                proofElement := mload(add(proof, i))\\n            }\\n\\n            if (index % 2 == 0) {\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n\\n            index = index / 2;\\n        }\\n        return computedHash == rootHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/lib/MerklePatriciaProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProof {\\n    /*\\n     * @dev Verifies a merkle patricia proof.\\n     * @param value The terminating value in the trie.\\n     * @param encodedPath The path in the trie leading to value.\\n     * @param rlpParentNodes The rlp encoded stack of nodes.\\n     * @param root The root hash of the trie.\\n     * @return The boolean validity of the proof.\\n     */\\n    function verify(\\n        bytes memory value,\\n        bytes memory encodedPath,\\n        bytes memory rlpParentNodes,\\n        bytes32 root\\n    ) internal pure returns (bool) {\\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\\n\\n        bytes memory currentNode;\\n        RLPReader.RLPItem[] memory currentNodeList;\\n\\n        bytes32 nodeKey = root;\\n        uint256 pathPtr = 0;\\n\\n        bytes memory path = _getNibbleArray(encodedPath);\\n        if (path.length == 0) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < parentNodes.length; i++) {\\n            if (pathPtr > path.length) {\\n                return false;\\n            }\\n\\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\\n            if (nodeKey != keccak256(currentNode)) {\\n                return false;\\n            }\\n            currentNodeList = RLPReader.toList(parentNodes[i]);\\n\\n            if (currentNodeList.length == 17) {\\n                if (pathPtr == path.length) {\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                uint8 nextPathNibble = uint8(path[pathPtr]);\\n                if (nextPathNibble > 16) {\\n                    return false;\\n                }\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\\n                pathPtr += 1;\\n            } else if (currentNodeList.length == 2) {\\n                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\\n                if (pathPtr + traversed == path.length) {\\n                    //leaf node\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                //extension node\\n                if (traversed == 0) {\\n                    return false;\\n                }\\n\\n                pathPtr += traversed;\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    function _nibblesToTraverse(\\n        bytes memory encodedPartialPath,\\n        bytes memory path,\\n        uint256 pathPtr\\n    ) private pure returns (uint256) {\\n        uint256 len = 0;\\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\\n        // and slicedPath have elements that are each one hex character (1 nibble)\\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\\n        bytes memory slicedPath = new bytes(partialPath.length);\\n\\n        // pathPtr counts nibbles in path\\n        // partialPath.length is a number of nibbles\\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\\n            bytes1 pathNibble = path[i];\\n            slicedPath[i - pathPtr] = pathNibble;\\n        }\\n\\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\\n            len = partialPath.length;\\n        } else {\\n            len = 0;\\n        }\\n        return len;\\n    }\\n\\n    // bytes b must be hp encoded\\n    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {\\n        bytes memory nibbles = \\\"\\\";\\n        if (b.length > 0) {\\n            uint8 offset;\\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\\n            if (hpNibble == 1 || hpNibble == 3) {\\n                nibbles = new bytes(b.length * 2 - 1);\\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\\n                nibbles[0] = oddNibble;\\n                offset = 1;\\n            } else {\\n                nibbles = new bytes(b.length * 2 - 2);\\n                offset = 0;\\n            }\\n\\n            for (uint256 i = offset; i < nibbles.length; i++) {\\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\\n            }\\n        }\\n        return nibbles;\\n    }\\n\\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\\n        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/lib/RLPReader.sol\": {\r\n      \"content\": \"/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity ^0.8.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len - _payloadOffset(item.memPtr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded list in bytes\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte < 128 is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        return result == 0 ? false : true;\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 len = item.len - offset;\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + offset;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 len = item.len - offset; // data length\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr + offset, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\\n        else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) return 0;\\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\\n        else if (byte0 < LIST_SHORT_START)\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        else return byte0 - (LIST_LONG_START - 1) + 1;\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(\\n        uint256 src,\\n        uint256 dest,\\n        uint256 len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len == 0) return;\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\\n\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/tunnel/FxBaseChildTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// IFxMessageProcessor represents interface to process message\\ninterface IFxMessageProcessor {\\n    function processMessageFromRoot(\\n        uint256 stateId,\\n        address rootMessageSender,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n * @notice Mock child tunnel contract to receive and send message from L2\\n */\\nabstract contract FxBaseChildTunnel is IFxMessageProcessor {\\n    // MessageTunnel on L1 will get data from this event\\n    event MessageSent(bytes message);\\n\\n    // fx child\\n    address public fxChild;\\n\\n    // fx root tunnel\\n    address public fxRootTunnel;\\n\\n    constructor(address _fxChild) {\\n        fxChild = _fxChild;\\n    }\\n\\n    // Sender must be fxRootTunnel in case of ERC20 tunnel\\n    modifier validateSender(address sender) {\\n        require(sender == fxRootTunnel, \\\"FxBaseChildTunnel: INVALID_SENDER_FROM_ROOT\\\");\\n        _;\\n    }\\n\\n    // set fxRootTunnel if not set already\\n    function setFxRootTunnel(address _fxRootTunnel) external virtual {\\n        require(fxRootTunnel == address(0x0), \\\"FxBaseChildTunnel: ROOT_TUNNEL_ALREADY_SET\\\");\\n        fxRootTunnel = _fxRootTunnel;\\n    }\\n\\n    function processMessageFromRoot(\\n        uint256 stateId,\\n        address rootMessageSender,\\n        bytes calldata data\\n    ) external override {\\n        require(msg.sender == fxChild, \\\"FxBaseChildTunnel: INVALID_SENDER\\\");\\n        _processMessageFromRoot(stateId, rootMessageSender, data);\\n    }\\n\\n    /**\\n     * @notice Emit message that can be received on Root Tunnel\\n     * @dev Call the internal function when need to emit message\\n     * @param message bytes message that will be sent to Root Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToRoot(bytes memory message) internal {\\n        emit MessageSent(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Root Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by onStateReceive function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param stateId unique state id\\n     * @param sender root message sender\\n     * @param message bytes message that was sent from Root Tunnel\\n     */\\n    function _processMessageFromRoot(\\n        uint256 stateId,\\n        address sender,\\n        bytes memory message\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/tunnel/FxBaseRootTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"../lib/RLPReader.sol\\\";\\nimport {MerklePatriciaProof} from \\\"../lib/MerklePatriciaProof.sol\\\";\\nimport {Merkle} from \\\"../lib/Merkle.sol\\\";\\nimport \\\"../lib/ExitPayloadReader.sol\\\";\\n\\ninterface IFxStateSender {\\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\\n}\\n\\ncontract ICheckpointManager {\\n    struct HeaderBlock {\\n        bytes32 root;\\n        uint256 start;\\n        uint256 end;\\n        uint256 createdAt;\\n        address proposer;\\n    }\\n\\n    /**\\n     * @notice mapping of checkpoint header numbers to block details\\n     * @dev These checkpoints are submited by plasma contracts\\n     */\\n    mapping(uint256 => HeaderBlock) public headerBlocks;\\n}\\n\\nabstract contract FxBaseRootTunnel {\\n    using RLPReader for RLPReader.RLPItem;\\n    using Merkle for bytes32;\\n    using ExitPayloadReader for bytes;\\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\\n    using ExitPayloadReader for ExitPayloadReader.Log;\\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\\n\\n    // keccak256(MessageSent(bytes))\\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\\n\\n    // state sender contract\\n    IFxStateSender public fxRoot;\\n    // root chain manager\\n    ICheckpointManager public checkpointManager;\\n    // child tunnel contract which receives and sends messages\\n    address public fxChildTunnel;\\n\\n    // storage to avoid duplicate exits\\n    mapping(bytes32 => bool) public processedExits;\\n\\n    constructor(address _checkpointManager, address _fxRoot) {\\n        checkpointManager = ICheckpointManager(_checkpointManager);\\n        fxRoot = IFxStateSender(_fxRoot);\\n    }\\n\\n    // set fxChildTunnel if not set already\\n    function setFxChildTunnel(address _fxChildTunnel) public virtual {\\n        require(fxChildTunnel == address(0x0), \\\"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\\\");\\n        fxChildTunnel = _fxChildTunnel;\\n    }\\n\\n    /**\\n     * @notice Send bytes message to Child Tunnel\\n     * @param message bytes message that will be sent to Child Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToChild(bytes memory message) internal {\\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\\n    }\\n\\n    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {\\n        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();\\n\\n        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\\n        uint256 blockNumber = payload.getBlockNumber();\\n        // checking if exit has already been processed\\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\\n        bytes32 exitHash = keccak256(\\n            abi.encodePacked(\\n                blockNumber,\\n                // first 2 nibbles are dropped while generating nibble array\\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\\n                // so converting to nibble array and then hashing it\\n                MerklePatriciaProof._getNibbleArray(branchMaskBytes),\\n                payload.getReceiptLogIndex()\\n            )\\n        );\\n        require(processedExits[exitHash] == false, \\\"FxRootTunnel: EXIT_ALREADY_PROCESSED\\\");\\n        processedExits[exitHash] = true;\\n\\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\\n        ExitPayloadReader.Log memory log = receipt.getLog();\\n\\n        // check child tunnel\\n        require(fxChildTunnel == log.getEmitter(), \\\"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\\\");\\n\\n        bytes32 receiptRoot = payload.getReceiptRoot();\\n        // verify receipt inclusion\\n        require(\\n            MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot),\\n            \\\"FxRootTunnel: INVALID_RECEIPT_PROOF\\\"\\n        );\\n\\n        // verify checkpoint inclusion\\n        _checkBlockMembershipInCheckpoint(\\n            blockNumber,\\n            payload.getBlockTime(),\\n            payload.getTxRoot(),\\n            receiptRoot,\\n            payload.getHeaderNumber(),\\n            payload.getBlockProof()\\n        );\\n\\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\\n\\n        require(\\n            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\\n            \\\"FxRootTunnel: INVALID_SIGNATURE\\\"\\n        );\\n\\n        // received message data\\n        bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\\n        return message;\\n    }\\n\\n    function _checkBlockMembershipInCheckpoint(\\n        uint256 blockNumber,\\n        uint256 blockTime,\\n        bytes32 txRoot,\\n        bytes32 receiptRoot,\\n        uint256 headerNumber,\\n        bytes memory blockProof\\n    ) private view {\\n        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);\\n\\n        require(\\n            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(\\n                blockNumber - startBlock,\\n                headerRoot,\\n                blockProof\\n            ),\\n            \\\"FxRootTunnel: INVALID_HEADER\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice receive message from  L2 to L1, validated by proof\\n     * @dev This function verifies if the transaction actually happened on child chain\\n     *\\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\\n     *  2 - blockNumber - Block number containing the reference tx on child chain\\n     *  3 - blockTime - Reference tx block time\\n     *  4 - txRoot - Transactions root of block\\n     *  5 - receiptRoot - Receipts root of block\\n     *  6 - receipt - Receipt of the reference transaction\\n     *  7 - receiptProof - Merkle proof of the reference receipt\\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\\n     *  9 - receiptLogIndex - Log Index to read from the receipt\\n     */\\n    function receiveMessage(bytes memory inputData) public virtual {\\n        bytes memory message = _validateAndExtractMessage(inputData);\\n        _processMessageFromChild(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Child Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by receiveMessage function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param message bytes message that was sent from Child Tunnel\\n     */\\n    function _processMessageFromChild(bytes memory message) internal virtual;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IArbSys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IArbSys.sol)\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/**\\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\n */\\ninterface IArbSys {\\n    /**\\n     * @notice Get internal version number identifying an ArbOS build\\n     * @return version number as int\\n     */\\n    function arbOSVersion() external pure returns (uint256);\\n\\n    function arbChainID() external view returns (uint256);\\n\\n    /**\\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n     * @return block number as int\\n     */\\n    function arbBlockNumber() external view returns (uint256);\\n\\n    /**\\n     * @notice Send given amount of Eth to dest from sender.\\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\n     * @param destination recipient address on L1\\n     * @return unique identifier for this L2-to-L1 transaction.\\n     */\\n    function withdrawEth(address destination) external payable returns (uint256);\\n\\n    /**\\n     * @notice Send a transaction to L1\\n     * @param destination recipient address on L1\\n     * @param calldataForL1 (optional) calldata for L1 contract call\\n     * @return a unique identifier for this L2-to-L1 transaction.\\n     */\\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint256);\\n\\n    /**\\n     * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\n     * @param account target account\\n     * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\n     */\\n    function getTransactionCount(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice get the value of target L2 storage slot\\n     * This function is only callable from address 0 to prevent contracts from being able to call it\\n     * @param account target account\\n     * @param index target index of storage slot\\n     * @return stotage value for the given account at the given index\\n     */\\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @notice check if current call is coming from l1\\n     * @return true if the caller of this was called directly from L1\\n     */\\n    function isTopLevelCall() external view returns (bool);\\n\\n    /**\\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\\n     * @return true iff the caller's address is an alias for an L1 contract address\\n     */\\n    function wasMyCallersAddressAliased() external view returns (bool);\\n\\n    /**\\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\\n     * @return address of the caller's caller, without applying L1 contract address aliasing\\n     */\\n    function myCallersAddressWithoutAliasing() external view returns (address);\\n\\n    /**\\n     * @notice map L1 sender contract address to its L2 alias\\n     * @param sender sender address\\n     * @param dest destination address\\n     * @return aliased sender address\\n     */\\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns (address);\\n\\n    /**\\n     * @notice get the caller's amount of available storage gas\\n     * @return amount of storage gas available to the caller\\n     */\\n    function getStorageGasAvailable() external view returns (uint256);\\n\\n    event L2ToL1Transaction(\\n        address caller,\\n        address indexed destination,\\n        uint256 indexed uniqueId,\\n        uint256 indexed batchNumber,\\n        uint256 indexInBatch,\\n        uint256 arbBlockNum,\\n        uint256 ethBlockNum,\\n        uint256 timestamp,\\n        uint256 callvalue,\\n        bytes data\\n    );\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IBridge.sol)\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    );\\n\\n    event BridgeCallTriggered(address indexed outbox, address indexed destAddr, uint256 amount, bytes data);\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    function deliverMessageToInbox(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function executeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    // View functions\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IInbox.sol)\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IMessageProvider.sol\\\";\\n\\ninterface IInbox is IMessageProvider {\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function createRetryableTicket(\\n        address destAddr,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function createRetryableTicketNoRefundAliasRewrite(\\n        address destAddr,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\\n\\n    function bridge() external view returns (address);\\n\\n    function pauseCreateRetryables() external;\\n\\n    function unpauseCreateRetryables() external;\\n\\n    function startRewriteAddress() external;\\n\\n    function stopRewriteAddress() external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IMessageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IMessageProvider.sol)\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMessageProvider {\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/vendor/arbitrum/IOutbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/arbitrum/IOutbox.sol)\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOutbox {\\n    event OutboxEntryCreated(\\n        uint256 indexed batchNum,\\n        uint256 outboxEntryIndex,\\n        bytes32 outputRoot,\\n        uint256 numInBatch\\n    );\\n    event OutBoxTransactionExecuted(\\n        address indexed destAddr,\\n        address indexed l2Sender,\\n        uint256 indexed outboxEntryIndex,\\n        uint256 transactionIndex\\n    );\\n\\n    function l2ToL1Sender() external view returns (address);\\n\\n    function l2ToL1Block() external view returns (uint256);\\n\\n    function l2ToL1EthBlock() external view returns (uint256);\\n\\n    function l2ToL1Timestamp() external view returns (uint256);\\n\\n    function l2ToL1BatchNum() external view returns (uint256);\\n\\n    function l2ToL1OutputId() external view returns (bytes32);\\n\\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths) external;\\n\\n    function outboxEntryExists(uint256 batchNum) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/vendor/optimism/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/optimism/ICrossDomainMessenger.sol)\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title ICrossDomainMessenger\\n */\\ninterface ICrossDomainMessenger {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"chainSlug_\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidNonce\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"NoPermit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyNominee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransmitterNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"OwnerClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominee\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainSlug\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"relativeGasPrice\",\"type\":\"uint256\"}],\"name\":\"RelativeGasPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"grantee\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"revokee\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sourceGasPrice\",\"type\":\"uint256\"}],\"name\":\"SourceGasPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmitManager\",\"type\":\"address\"}],\"name\":\"TransmitManagerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chainSlug\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"siblingChainSlug_\",\"type\":\"uint32\"}],\"name\":\"getGasPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"roleNames_\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"grantees_\",\"type\":\"address[]\"}],\"name\":\"grantBatchRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"roleName_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainSlug_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"grantee_\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"grantee_\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"roleName_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainSlug_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nominee_\",\"type\":\"address\"}],\"name\":\"nominateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"relativeGasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"roleNames_\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"grantees_\",\"type\":\"address[]\"}],\"name\":\"revokeBatchRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"roleName_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainSlug_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"grantee_\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"revokee_\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"siblingChainSlug_\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relativeGasPrice_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"setRelativeGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sourceGasPrice_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"setSourceGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITransmitManager\",\"name\":\"transmitManager_\",\"type\":\"address\"}],\"name\":\"setTransmitManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sourceGasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmitManager__\",\"outputs\":[{\"internalType\":\"contract ITransmitManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"updatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GasPriceOracle", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000005fd7d0d6b91cc4787bcb86ca47e0bd4ea0346d340000000000000000000000000000000000000000000000000000000000000038", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}