{"SourceCode": "pragma solidity ^0.5.16;\r\ncontract ErrorReporter {\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    enum Error {\r\n        NO_ERROR,\r\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\r\n        UNAUTHORIZED,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW,\r\n        DIVISION_BY_ZERO,\r\n        BAD_INPUT,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_TRANSFER_FAILED,\r\n        MARKET_NOT_SUPPORTED,\r\n        SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_RATE_CALCULATION_FAILED,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_OUT_FAILED,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INSUFFICIENT_BALANCE,\r\n        INVALID_COLLATERAL_RATIO,\r\n        MISSING_ASSET_PRICE,\r\n        EQUITY_INSUFFICIENT_BALANCE,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        ASSET_NOT_PRICED,\r\n        INVALID_LIQUIDATION_DISCOUNT,\r\n        INVALID_COMBINED_RISK_PARAMETERS\r\n    }\r\n\r\n    /*\r\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n     *       This is because FailureInfo grows significantly faster, and\r\n     *       the order of Error has some meaning, while the order of FailureInfo\r\n     *       is entirely arbitrary.\r\n     */\r\n    enum FailureInfo {\r\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        BORROW_MARKET_NOT_SUPPORTED,\r\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\r\n        BORROW_TRANSFER_OUT_FAILED,\r\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\r\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\r\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\r\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\r\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\r\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\r\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_TRANSFER_IN_FAILED,\r\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_ADMIN_OWNER_CHECK,\r\n        SET_ASSET_PRICE_CHECK_ORACLE,\r\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_ORACLE_OWNER_CHECK,\r\n        SET_ORIGINATION_FEE_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_VALIDATION,\r\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_MARKET_NOT_SUPPORTED,\r\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        SUPPLY_TRANSFER_IN_FAILED,\r\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SUPPORT_MARKET_PRICE_CHECK,\r\n        SUSPEND_MARKET_OWNER_CHECK,\r\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\r\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\r\n    }\r\n\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\r\n\r\n        return uint(Error.OPAQUE_ERROR);\r\n    }\r\n\r\n}\r\ncontract CarefulMath is ErrorReporter {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (a == 0) {\r\n            return (Error.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (b == 0) {\r\n            return (Error.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (b <= a) {\r\n            return (Error.NO_ERROR, a - b);\r\n        } else {\r\n            return (Error.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function add(uint a, uint b) internal pure returns (Error, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (Error.NO_ERROR, c);\r\n        } else {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\r\n        (Error err0, uint sum) = add(a, b);\r\n\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return sub(sum, c);\r\n    }\r\n}\r\ncontract Exponential is ErrorReporter, CarefulMath {\r\n\r\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\r\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\r\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\r\n    uint constant expScale = 10**18;\r\n\r\n    // See TODO on expScale\r\n    uint constant halfExpScale = expScale/2;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    uint constant mantissaOne = 10**18;\r\n    uint constant mantissaOneTenth = 10**17;\r\n\r\n    /**\r\n    * @dev Creates an exponential from numerator and denominator values.\r\n    *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n    *            or if `denom` is zero.\r\n    */\r\n    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint scaledNumerator) = mul(num, expScale);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err1, uint rational) = div(scaledNumerator, denom);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two exponentials, returning a new exponential.\r\n    */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        (Error error, uint result) = add(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two exponentials, returning a new exponential.\r\n    */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        (Error error, uint result) = sub(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n    * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n    */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n    * @dev Divide an Exp by a scalar, returning a new Exp.\r\n    */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n    * @dev Divide a scalar by an Exp, returning a new Exp.\r\n    */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Error, Exp memory) {\r\n        /*\r\n            We are doing this as:\r\n            getExp(mul(expScale, scalar), divisor.mantissa)\r\n\r\n            How it works:\r\n            Exp = a / b;\r\n            Scalar = s;\r\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (Error err0, uint numerator) = mul(expScale, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two exponentials, returning a new exponential.\r\n    */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n\r\n        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == Error.NO_ERROR);\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n      * @dev Divides two exponentials, returning a new exponential.\r\n      *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n      *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n      */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n      * @dev Truncates the given exp to a whole number value.\r\n      *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\r\n      */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / 10**18;\r\n    }\r\n\r\n    /**\r\n      * @dev Checks if first Exp is less than second Exp.\r\n      */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\r\n    }\r\n\r\n    /**\r\n      * @dev Checks if left Exp <= right Exp.\r\n      */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n      * @dev Checks if first Exp is greater than second Exp.\r\n      */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n      * @dev returns true if Exp is exactly zero\r\n      */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\ncontract PriceOracle is Exponential {\r\n\r\n    /**\r\n      * @dev flag for whether or not contract is paused\r\n      *\r\n      */\r\n    bool public paused;\r\n\r\n    uint public constant numBlocksPerPeriod = 240; // approximately 1 hour: 60 seconds/minute * 60 minutes/hour * 1 block/15 seconds\r\n\r\n    uint public constant maxSwingMantissa = (10 ** 17); // 0.1\r\n\r\n    /**\r\n      * @dev Mapping of asset addresses and their corresponding price in terms of Eth-Wei\r\n      *      which is simply equal to AssetWeiPrice * 10e18. For instance, if OMG token was\r\n      *      worth 5x Eth then the price for OMG would be 5*10e18 or Exp({mantissa: 5000000000000000000}).\r\n      * map: assetAddress -> Exp\r\n      */\r\n    mapping(address => Exp) public _assetPrices;\r\n\r\n    constructor(address _poster) public {\r\n        anchorAdmin = msg.sender;\r\n        poster = _poster;\r\n        maxSwing = Exp({mantissa : maxSwingMantissa});\r\n    }\r\n\r\n    /**\r\n      * @notice Do not pay into PriceOracle\r\n      */\r\n    function() payable external {\r\n        revert();\r\n    }\r\n\r\n    enum OracleError {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        FAILED_TO_SET_PRICE\r\n    }\r\n\r\n    enum OracleFailureInfo {\r\n        ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK,\r\n        SET_PAUSED_OWNER_CHECK,\r\n        SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_ANCHOR_PERMISSION_CHECK,\r\n        SET_PRICE_CALCULATE_SWING,\r\n        SET_PRICE_CAP_TO_MAX,\r\n        SET_PRICE_MAX_SWING_CHECK,\r\n        SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO,\r\n        SET_PRICE_PERMISSION_CHECK,\r\n        SET_PRICE_ZERO_PRICE,\r\n        SET_PRICES_PARAM_VALIDATION\r\n    }\r\n\r\n    /**\r\n      * @dev `msgSender` is msg.sender; `error` corresponds to enum OracleError; `info` corresponds to enum OracleFailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event OracleFailure(address msgSender, address asset, uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the price oracle or a non-upgradeable collaborator\r\n      *      Using Oracle in name because we already inherit a `fail` function from ErrorReporter.sol via Exponential.sol\r\n      */\r\n    function failOracle(address asset, OracleError err, OracleFailureInfo info) internal returns (uint) {\r\n        emit OracleFailure(msg.sender, asset, uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev Use this when reporting an error from the money market. Give the money market result as `details`\r\n      */\r\n    function failOracleWithDetails(address asset, OracleError err, OracleFailureInfo info, uint details) internal returns (uint) {\r\n        emit OracleFailure(msg.sender, asset, uint(err), uint(info), details);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev An administrator who can set the pending anchor value for assets.\r\n      *      Set in the constructor.\r\n      */\r\n    address public anchorAdmin;\r\n\r\n    /**\r\n      * @dev pending anchor administrator for this contract.\r\n      */\r\n    address public pendingAnchorAdmin;\r\n\r\n    /**\r\n      * @dev Address of the price poster.\r\n      *      Set in the constructor.\r\n      */\r\n    address public poster;\r\n\r\n    /**\r\n      * @dev maxSwing the maximum allowed percentage difference between a new price and the anchor's price\r\n      *      Set only in the constructor\r\n      */\r\n    Exp public maxSwing;\r\n\r\n    struct Anchor {\r\n        // floor(block.number / numBlocksPerPeriod) + 1\r\n        uint period;\r\n\r\n        // Price in ETH, scaled by 10**18\r\n        uint priceMantissa;\r\n    }\r\n\r\n    /**\r\n      * @dev anchors by asset\r\n      */\r\n    mapping(address => Anchor) public anchors;\r\n\r\n    /**\r\n      * @dev pending anchor prices by asset\r\n      */\r\n    mapping(address => uint) public pendingAnchors;\r\n\r\n    /**\r\n      * @dev emitted when a pending anchor is set\r\n      * @param asset Asset for which to set a pending anchor\r\n      * @param oldScaledPrice if an unused pending anchor was present, its value; otherwise 0.\r\n      * @param newScaledPrice the new scaled pending anchor price\r\n      */\r\n    event NewPendingAnchor(address anchorAdmin, address asset, uint oldScaledPrice, uint newScaledPrice);\r\n\r\n    /**\r\n      * @notice provides ability to override the anchor price for an asset\r\n      * @dev Admin function to set the anchor price for an asset\r\n      * @param asset Asset for which to override the anchor price\r\n      * @param newScaledPrice New anchor price\r\n      * @return uint 0=success, otherwise a failure (see enum OracleError for details)\r\n      */\r\n    function _setPendingAnchor(address asset, uint newScaledPrice) public returns (uint) {\r\n        // Check caller = anchorAdmin. Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\r\n        if (msg.sender != anchorAdmin) {\r\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK);\r\n        }\r\n\r\n        uint oldScaledPrice = pendingAnchors[asset];\r\n        pendingAnchors[asset] = newScaledPrice;\r\n\r\n        emit NewPendingAnchor(msg.sender, asset, oldScaledPrice, newScaledPrice);\r\n\r\n        return uint(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @dev emitted for all price changes\r\n      */\r\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\r\n\r\n    /**\r\n      * @dev emitted if this contract successfully posts a capped-to-max price to the money market\r\n      */\r\n    event CappedPricePosted(address asset, uint requestedPriceMantissa, uint anchorPriceMantissa, uint cappedPriceMantissa);\r\n\r\n    /**\r\n      * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\r\n      */\r\n    event SetPaused(bool newState);\r\n\r\n    /**\r\n      * @dev emitted when pendingAnchorAdmin is changed\r\n      */\r\n    event NewPendingAnchorAdmin(address oldPendingAnchorAdmin, address newPendingAnchorAdmin);\r\n\r\n    /**\r\n      * @dev emitted when pendingAnchorAdmin is accepted, which means anchor admin is updated\r\n      */\r\n    event NewAnchorAdmin(address oldAnchorAdmin, address newAnchorAdmin);\r\n\r\n    /**\r\n      * @notice set `paused` to the specified state\r\n      * @dev Admin function to pause or resume the market\r\n      * @param requestedState value to assign to `paused`\r\n      * @return uint 0=success, otherwise a failure\r\n      */\r\n    function _setPaused(bool requestedState) public returns (uint) {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PAUSED_OWNER_CHECK);\r\n        }\r\n\r\n        paused = requestedState;\r\n        emit SetPaused(requestedState);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Begins transfer of anchor admin rights. The newPendingAnchorAdmin must call `_acceptAnchorAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of anchor admin. The newPendingAnchorAdmin must call `_acceptAnchorAdmin` to finalize the transfer.\r\n      * @param newPendingAnchorAdmin New pending anchor admin.\r\n      * @return uint 0=success, otherwise a failure\r\n      *\r\n      * TODO: Should we add a second arg to verify, like a checksum of `newAnchorAdmin` address?\r\n      */\r\n    function _setPendingAnchorAdmin(address newPendingAnchorAdmin) public returns (uint) {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // save current value, if any, for inclusion in log\r\n        address oldPendingAnchorAdmin = pendingAnchorAdmin;\r\n        // Store pendingAdmin = newPendingAdmin\r\n        pendingAnchorAdmin = newPendingAnchorAdmin;\r\n\r\n        emit NewPendingAnchorAdmin(oldPendingAnchorAdmin, newPendingAnchorAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of anchor admin rights. msg.sender must be pendingAnchorAdmin\r\n      * @dev Admin function for pending anchor admin to accept role and update anchor admin\r\n      * @return uint 0=success, otherwise a failure\r\n      */\r\n    function _acceptAnchorAdmin() public returns (uint) {\r\n        // Check caller = pendingAnchorAdmin\r\n        // msg.sender can't be zero\r\n        if (msg.sender != pendingAnchorAdmin) {\r\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current value for inclusion in log\r\n        address oldAnchorAdmin = anchorAdmin;\r\n        // Store admin = pendingAnchorAdmin\r\n        anchorAdmin = pendingAnchorAdmin;\r\n        // Clear the pending value\r\n        pendingAnchorAdmin = address(0);\r\n\r\n        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice retrieves price of an asset\r\n      * @dev function to get price for an asset\r\n      * @param asset Asset for which to get the price\r\n      * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\r\n      */\r\n    function assetPrices(address asset) public view returns (uint) {\r\n        // Note: zero is treated by the money market as an invalid\r\n        //       price and will cease operations with that asset\r\n        //       when zero.\r\n        //\r\n        // We get the price as:\r\n        //\r\n        //  1. If the contract is paused, return 0.\r\n        //  2. Return price in `_assetPrices`, which may be zero.\r\n\r\n        if (paused) {\r\n            return 0;\r\n        }\r\n        return _assetPrices[asset].mantissa;\r\n    }\r\n\r\n    /**\r\n      * @notice retrieves price of an asset\r\n      * @dev function to get price for an asset\r\n      * @param asset Asset for which to get the price\r\n      * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\r\n      */\r\n    function getPrice(address asset) public view returns (uint) {\r\n        return assetPrices(asset);\r\n    }\r\n\r\n    struct SetPriceLocalVars {\r\n        Exp price;\r\n        Exp swing;\r\n        Exp anchorPrice;\r\n        uint anchorPeriod;\r\n        uint currentPeriod;\r\n        bool priceCapped;\r\n        uint cappingAnchorPriceMantissa;\r\n        uint pendingAnchorMantissa;\r\n    }\r\n\r\n    /**\r\n      * @notice entry point for updating prices\r\n      * @dev function to set price for an asset\r\n      * @param asset Asset for which to set the price\r\n      * @param requestedPriceMantissa requested new price, scaled by 10**18\r\n      * @return uint 0=success, otherwise a failure (see enum OracleError for details)\r\n      */\r\n    function setPrice(address asset, uint requestedPriceMantissa) public returns (uint) {\r\n        // Fail when msg.sender is not poster\r\n        if (msg.sender != poster) {\r\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\r\n        }\r\n\r\n        return setPriceInternal(asset, requestedPriceMantissa);\r\n    }\r\n\r\n    function setPriceInternal(address asset, uint requestedPriceMantissa) internal returns (uint) {\r\n        // re-used for intermediate errors\r\n        Error err;\r\n        SetPriceLocalVars memory localVars;\r\n        // We add 1 for currentPeriod so that it can never be zero and there's no ambiguity about an unset value.\r\n        // (It can be a problem in tests with low block numbers.)\r\n        localVars.currentPeriod = (block.number / numBlocksPerPeriod) + 1;\r\n        localVars.pendingAnchorMantissa = pendingAnchors[asset];\r\n        localVars.price = Exp({mantissa : requestedPriceMantissa});\r\n\r\n        if (localVars.pendingAnchorMantissa != 0) {\r\n            // let's explicitly set to 0 rather than relying on default of declaration\r\n            localVars.anchorPeriod = 0;\r\n            localVars.anchorPrice = Exp({mantissa : localVars.pendingAnchorMantissa});\r\n\r\n            // Verify movement is within max swing of pending anchor (currently: 10%)\r\n            (err, localVars.swing) = calculateSwing(localVars.anchorPrice, localVars.price);\r\n            if (err != Error.NO_ERROR) {\r\n                return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_CALCULATE_SWING, uint(err));\r\n            }\r\n\r\n            // Fail when swing > maxSwing\r\n            if (greaterThanExp(localVars.swing, maxSwing)) {\r\n                return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_MAX_SWING_CHECK, localVars.swing.mantissa);\r\n            }\r\n        } else {\r\n            localVars.anchorPeriod = anchors[asset].period;\r\n            localVars.anchorPrice = Exp({mantissa : anchors[asset].priceMantissa});\r\n\r\n            if (localVars.anchorPeriod != 0) {\r\n                (err, localVars.priceCapped, localVars.price) = capToMax(localVars.anchorPrice, localVars.price);\r\n                if (err != Error.NO_ERROR) {\r\n                    return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_CAP_TO_MAX, uint(err));\r\n                }\r\n                if (localVars.priceCapped) {\r\n                    // save for use in log\r\n                    localVars.cappingAnchorPriceMantissa = localVars.anchorPrice.mantissa;\r\n                }\r\n            } else {\r\n                // Setting first price. Accept as is (already assigned above from requestedPriceMantissa) and use as anchor\r\n                localVars.anchorPrice = Exp({mantissa : requestedPriceMantissa});\r\n            }\r\n        }\r\n\r\n        // Fail if anchorPrice or price is zero.\r\n        // zero anchor represents an unexpected situation likely due to a problem in this contract\r\n        // zero price is more likely as the result of bad input from the caller of this function\r\n        if (isZeroExp(localVars.anchorPrice)) {\r\n            // If we get here price could also be zero, but it does not seem worthwhile to distinguish the 3rd case\r\n            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO);\r\n        }\r\n\r\n        if (isZeroExp(localVars.price)) {\r\n            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_ZERO_PRICE);\r\n        }\r\n\r\n        // BEGIN SIDE EFFECTS\r\n\r\n        // Set pendingAnchor = Nothing\r\n        // Pending anchor is only used once.\r\n        if (pendingAnchors[asset] != 0) {\r\n            pendingAnchors[asset] = 0;\r\n        }\r\n\r\n        // If currentPeriod > anchorPeriod:\r\n        //  Set anchors[asset] = (currentPeriod, price)\r\n        //  The new anchor is if we're in a new period or we had a pending anchor, then we become the new anchor\r\n        if (localVars.currentPeriod > localVars.anchorPeriod) {\r\n            anchors[asset] = Anchor({period : localVars.currentPeriod, priceMantissa : localVars.price.mantissa});\r\n        }\r\n\r\n        uint previousPrice = _assetPrices[asset].mantissa;\r\n\r\n        setPriceStorageInternal(asset, localVars.price.mantissa);\r\n\r\n        emit PricePosted(asset, previousPrice, requestedPriceMantissa, localVars.price.mantissa);\r\n\r\n        if (localVars.priceCapped) {\r\n            // We have set a capped price. Log it so we can detect the situation and investigate.\r\n            emit CappedPricePosted(asset, requestedPriceMantissa, localVars.cappingAnchorPriceMantissa, localVars.price.mantissa);\r\n        }\r\n\r\n        return uint(OracleError.NO_ERROR);\r\n    }\r\n\r\n    // As a function to allow harness overrides\r\n    function setPriceStorageInternal(address asset, uint256 priceMantissa) internal {\r\n        _assetPrices[asset] = Exp({mantissa: priceMantissa});\r\n    }\r\n\r\n    // abs(price - anchorPrice) / anchorPrice\r\n    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (Error, Exp memory) {\r\n        Exp memory numerator;\r\n        Error err;\r\n\r\n        if (greaterThanExp(anchorPrice, price)) {\r\n            (err, numerator) = subExp(anchorPrice, price);\r\n            // can't underflow\r\n            assert(err == Error.NO_ERROR);\r\n        } else {\r\n            (err, numerator) = subExp(price, anchorPrice);\r\n            // Given greaterThan check above, price >= anchorPrice so can't underflow.\r\n            assert(err == Error.NO_ERROR);\r\n        }\r\n\r\n        return divExp(numerator, anchorPrice);\r\n    }\r\n\r\n    function capToMax(Exp memory anchorPrice, Exp memory price) view internal returns (Error, bool, Exp memory) {\r\n        Exp memory one = Exp({mantissa : mantissaOne});\r\n        Exp memory onePlusMaxSwing;\r\n        Exp memory oneMinusMaxSwing;\r\n        Exp memory max;\r\n        Exp memory min;\r\n        // re-used for intermediate errors\r\n        Error err;\r\n\r\n        (err, onePlusMaxSwing) = addExp(one, maxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({mantissa : 0}));\r\n        }\r\n\r\n        // max = anchorPrice * (1 + maxSwing)\r\n        (err, max) = mulExp(anchorPrice, onePlusMaxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({mantissa : 0}));\r\n        }\r\n\r\n        // If price > anchorPrice * (1 + maxSwing)\r\n        // Set price = anchorPrice * (1 + maxSwing)\r\n        if (greaterThanExp(price, max)) {\r\n            return (Error.NO_ERROR, true, max);\r\n        }\r\n\r\n        (err, oneMinusMaxSwing) = subExp(one, maxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({mantissa : 0}));\r\n        }\r\n\r\n        // min = anchorPrice * (1 - maxSwing)\r\n        (err, min) = mulExp(anchorPrice, oneMinusMaxSwing);\r\n        // We can't overflow here or we would have already overflowed above when calculating `max`\r\n        assert(err == Error.NO_ERROR);\r\n\r\n        // If  price < anchorPrice * (1 - maxSwing)\r\n        // Set price = anchorPrice * (1 - maxSwing)\r\n        if (lessThanExp(price, min)) {\r\n            return (Error.NO_ERROR, true, min);\r\n        }\r\n\r\n        return (Error.NO_ERROR, false, price);\r\n    }\r\n\r\n    /**\r\n      * @notice entry point for updating multiple prices\r\n      * @dev function to set prices for a variable number of assets.\r\n      * @param assets a list of up to assets for which to set a price. required: 0 < assets.length == requestedPriceMantissas.length\r\n      * @param requestedPriceMantissas requested new prices for the assets, scaled by 10**18. required: 0 < assets.length == requestedPriceMantissas.length\r\n      * @return uint values in same order as inputs. For each: 0=success, otherwise a failure (see enum OracleError for details)\r\n      */\r\n    function setPrices(address[] memory assets, uint[] memory requestedPriceMantissas) public returns (uint[] memory) {\r\n        uint numAssets = assets.length;\r\n        uint numPrices = requestedPriceMantissas.length;\r\n        uint[] memory result;\r\n\r\n        // Fail when msg.sender is not poster\r\n        if (msg.sender != poster) {\r\n            result = new uint[](1);\r\n            result[0] = failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\r\n            return result;\r\n        }\r\n\r\n        if ((numAssets == 0) || (numPrices != numAssets)) {\r\n            result = new uint[](1);\r\n            result[0] = failOracle(address(0), OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICES_PARAM_VALIDATION);\r\n            return result;\r\n        }\r\n\r\n        result = new uint[](numAssets);\r\n\r\n        for (uint i = 0; i < numAssets; i++) {\r\n            result[i] = setPriceInternal(assets[i], requestedPriceMantissas[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poster\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchorPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cappedPriceMantissa\",\"type\":\"uint256\"}],\"name\":\"CappedPricePosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAnchorAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAnchorAdmin\",\"type\":\"address\"}],\"name\":\"NewAnchorAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"anchorAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldScaledPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newScaledPrice\",\"type\":\"uint256\"}],\"name\":\"NewPendingAnchor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAnchorAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAnchorAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAnchorAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"OracleFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"}],\"name\":\"PricePosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"SetPaused\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptAnchorAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_assetPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"requestedState\",\"type\":\"bool\"}],\"name\":\"_setPaused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newScaledPrice\",\"type\":\"uint256\"}],\"name\":\"_setPendingAnchor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAnchorAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAnchorAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anchorAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"anchors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceMantissa\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"assetPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSwing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSwingMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBlocksPerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAnchorAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingAnchors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedPriceMantissa\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"requestedPriceMantissas\",\"type\":\"uint256[]\"}],\"name\":\"setPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PriceOracle", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d830a7413cb25fee57f8115cd64e565b0be466c3", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://91baa10ffbccccffa6cfa855929d2748ca3e71064a1be67685e500109942e27e"}