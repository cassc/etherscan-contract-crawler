{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC721 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IOCNFTMetadata {\r\n    struct DataStorage {\r\n        address[] a;\r\n        uint256[] u;\r\n        string[] s;\r\n        bool[] b;\r\n        bytes[] bt;\r\n    }\r\n    function getNftData(uint256 tokenid,string[] memory key) external view returns (DataStorage[] memory);\r\n    function nftLevel(uint256 tokenid) external view returns (uint256);\r\n}\r\n\r\ninterface IUser {\r\n    function getUserData(address account) external view returns (address,uint256,bool);\r\n    function getUserReferrals(address account,uint256 level) external view returns (address[] memory);\r\n    function registerExt(address account,address referral,uint256 unilevel) external returns (bool);\r\n    function increaseUserData(address account,string[] memory key,uint256[] memory data) external returns (bool);\r\n}\r\n\r\ninterface IDexRouter {\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IWaterPool {\r\n    function drainWater(uint256 tokenid,uint256 amount) external returns (bool);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() { _transferOwnership(_msgSender()); }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract Role is Ownable {\r\n    mapping(address => mapping(string => bool)) _isRole;\r\n\r\n    event updateAccountRole(address indexed account, string indexed role, bool flag);\r\n\r\n    constructor() {}\r\n\r\n    function checkRole(address account,string memory role) public view virtual returns (bool) {\r\n        return _isRole[account][role];\r\n    }\r\n\r\n    modifier onlyRole(string memory role) {\r\n        require(_isRole[_msgSender()][role], \"Ownable: caller have no role permission\");\r\n        _;\r\n    }\r\n\r\n    function updateRole(address account,string memory role,bool flag) public virtual onlyOwner {\r\n       _flagRole(account,role,flag);\r\n    }\r\n\r\n    function _flagRole(address account,string memory role,bool flag) internal virtual {\r\n        _isRole[account][role] = flag;\r\n        emit updateAccountRole(account, role, flag);\r\n    }\r\n}\r\n\r\ncontract MiningContract is Ownable,Role {\r\n\r\n    event Mined(uint256 indexed tokenid,uint256 indexed landid,uint256 slot);\r\n    event Consume(uint256 indexed tokenid,uint256 indexed oasisid,uint256 amount);\r\n\r\n    address PCV2 = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    address userAddress = 0x7C86A967Dd9Acb1CB7FA9236BD532c87BaEd1666;\r\n\r\n    address keekee = 0x042d30df190c68FaA9D2C04A603aA2bA21D6f507;\r\n    address land = 0x4011246e0E1A2Af8Ae5bcbC650285CB8D8650fAE;\r\n    address oasis = 0x9E26Ea944DC18764BF5aE78D820825eC869D27B6;\r\n\r\n    address merge = 0x24BdACe9B0ecA04C8d7f21Ec169474D3f6eFC0be;\r\n    address water = 0x7687c8F1B5F018595f610fcE291681244Ce83B29;\r\n\r\n    address KEE = 0x572E4DdB898Bf5b3A0cCf6146763896b2FA72Fdf;\r\n    address USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n\r\n    IDexRouter router;\r\n    IUser user;\r\n    IERC20 kee;\r\n    IERC20 usdt;\r\n\r\n    IERC721 keeNFT;\r\n    IERC721 landNFT;\r\n    IERC721 OasisNFT;\r\n\r\n    IWaterPool waterPool;\r\n\r\n    address[] path = new address[](3);\r\n\r\n    uint256[] keekeeEarning = [\r\n        5 * 1e18,\r\n        6 * 1e18,\r\n        8 * 1e18,\r\n        10 * 1e18,\r\n        16 * 1e18\r\n    ];\r\n\r\n    uint256[] keekeeTick = [\r\n        360 * 3600,\r\n        192 * 3600,\r\n        112 * 3600,\r\n        72 * 3600,\r\n        40 * 3600\r\n    ];\r\n\r\n    uint256[] keekeeWaterDrain = [\r\n        15 * 1e18,\r\n        18 * 1e18,\r\n        25 * 1e18,\r\n        35 * 1e18,\r\n        50 * 1e18\r\n    ];\r\n\r\n    uint256[] keekeeWaterMax = [\r\n        15 * 1e18,\r\n        36 * 1e18,\r\n        75 * 1e18,\r\n        105 * 1e18,\r\n        150 * 1e18\r\n    ];\r\n\r\n    mapping(uint256 => uint256) public keekeeEnergy;\r\n    mapping(uint256 => uint256) public keekeeFreeBlock;\r\n\r\n    mapping(uint256 => mapping(uint256 => uint256)) public unixLandStamp;\r\n    mapping(uint256 => mapping(uint256 => uint256)) public miningId;\r\n\r\n    constructor() {\r\n        router = IDexRouter(PCV2);\r\n        user = IUser(userAddress);\r\n        kee = IERC20(KEE);\r\n        usdt = IERC20(USDT);\r\n        //\r\n        keeNFT = IERC721(keekee);\r\n        landNFT = IERC721(land);\r\n        OasisNFT = IERC721(oasis);\r\n        //\r\n        waterPool = IWaterPool(water);\r\n        //\r\n        path[0] = 0x572E4DdB898Bf5b3A0cCf6146763896b2FA72Fdf;\r\n        path[1] = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n        path[2] = 0x55d398326f99059fF775485246999027B3197955;\r\n    }\r\n\r\n    function getkeekeeEarning() public view returns (uint256[] memory) {\r\n        return keekeeEarning;\r\n    }\r\n\r\n    function getkeekeeTick() public view returns (uint256[] memory) {\r\n        return keekeeTick;\r\n    }\r\n\r\n    function getkeekeeWaterDrain() public view returns (uint256[] memory) {\r\n        return keekeeWaterDrain;\r\n    }\r\n\r\n    function getkeekeeWaterMax() public view returns (uint256[] memory) {\r\n        return keekeeWaterMax;\r\n    }\r\n\r\n    function updatekeekeeEarning(uint256[] memory input) public onlyOwner returns (bool) {\r\n        keekeeEarning = input;\r\n        return true;\r\n    }\r\n\r\n    function updatekeekeeTick(uint256[] memory input) public onlyOwner returns (bool) {\r\n        keekeeTick = input;\r\n        return true;\r\n    }\r\n\r\n    function updatekeekeeWaterDrain(uint256[] memory input) public onlyOwner returns (bool) {\r\n        keekeeWaterDrain = input;\r\n        return true;\r\n    }\r\n\r\n    function updatekeekeeWaterMax(uint256[] memory input) public onlyOwner returns (bool) {\r\n        keekeeWaterMax = input;\r\n        return true;\r\n    }\r\n\r\n    function Kee2Usdt(uint256 amountUSDT) public view returns (uint256) {\r\n        uint256[] memory result = router.getAmountsIn(amountUSDT,path);\r\n        return result[0];\r\n    }\r\n\r\n    function getLandInfoDeployer(uint256 tokenid) public view returns (uint256[] memory) {\r\n        IOCNFTMetadata fallbackCall = IOCNFTMetadata(land);\r\n        string[] memory key = new string[](1);\r\n        key[0] = \"deploy\";\r\n        IOCNFTMetadata.DataStorage[] memory data = new IOCNFTMetadata.DataStorage[](1);\r\n        data = fallbackCall.getNftData(tokenid,key);\r\n        uint256[] memory u = new uint256[](7);\r\n        u = data[0].u;\r\n        return u;\r\n    }\r\n\r\n    function getLandInfo(uint256 tokenid) public view returns (uint256,uint256) {\r\n        uint256[] memory result = new uint256[](7);\r\n        result = getLandInfoDeployer(tokenid);\r\n        return (result[5],result[6]);\r\n    }\r\n\r\n    function getLandSlotInfo(uint256 tokenid) public view returns (uint256[] memory,uint256[] memory,bool[] memory,uint256[] memory) {\r\n        (uint256 slotMax,) = getLandInfo(tokenid);\r\n        uint256[] memory unix = new uint256[](slotMax);\r\n        uint256[] memory id = new uint256[](slotMax);\r\n        bool[] memory free = new bool[](slotMax);\r\n        uint256[] memory cooldown = new uint256[](slotMax);\r\n        for(uint256 i = 0; i < slotMax; i++){\r\n            unix[i] = unixLandStamp[tokenid][i];\r\n            id[i] = miningId[tokenid][i];\r\n            free[i] = false;\r\n            if(block.timestamp>unixLandStamp[tokenid][i]){\r\n                free[i] = true;\r\n            }else{\r\n                cooldown[i] = unixLandStamp[tokenid][i] - block.timestamp;\r\n            }\r\n        }\r\n        return (unix,id,free,cooldown);\r\n    }\r\n\r\n    function mineOnLand(uint256 tokenid,uint256 landid,uint256 slot) public returns (bool) {\r\n        require(keeNFT.ownerOf(tokenid)==msg.sender,\"Mined: this NFT was not your owned\");\r\n        (uint256 slotMax,uint256 profit) = getLandInfo(landid);\r\n        require(slot<slotMax && slot>0,\"Mined: this land have not that slot\");\r\n        require(keekeeFreeBlock[tokenid]<block.timestamp,\"Mined: tokenid not free\");\r\n        IOCNFTMetadata levelContract = IOCNFTMetadata(merge);\r\n        uint256 level = levelContract.nftLevel(tokenid);\r\n        keekeeEnergy[tokenid] += keekeeWaterDrain[level];\r\n        require(keekeeEnergy[tokenid]<=keekeeWaterMax[level],\"Mined: this NFT so tried\");\r\n        require(block.timestamp>unixLandStamp[landid][slot],\"Mined: this slot in progress\");\r\n        uint256 unlockBlock = block.timestamp + keekeeTick[level];\r\n        unixLandStamp[landid][slot] = unlockBlock;\r\n        keekeeFreeBlock[tokenid] = unlockBlock;\r\n        miningId[landid][slot] = tokenid;\r\n        uint256 reward = Kee2Usdt(keekeeEarning[level]);\r\n        kee.transfer(msg.sender,reward);\r\n        increaseSingleKey(msg.sender,reward,\"TotalKeeKeeMined\");\r\n        kee.transfer(landNFT.ownerOf(landid),reward * profit / 1000);\r\n        increaseSingleKey(landNFT.ownerOf(landid),reward * profit / 1000,\"TotalLandFees\");\r\n        paidUpline(msg.sender,6,reward);\r\n        emit Mined(tokenid,landid,slot);\r\n        return true;\r\n    }\r\n\r\n    function consumeWater(uint256 tokenid,uint256 poolid,uint256 amount) public returns (bool) {\r\n        waterPool.drainWater(poolid,amount);\r\n        keekeeEnergy[tokenid] -= amount;\r\n        uint256 amountUSDT = amount / 10;\r\n        usdt.transferFrom(msg.sender,OasisNFT.ownerOf(poolid),amountUSDT);\r\n        increaseSingleKey(OasisNFT.ownerOf(poolid),amountUSDT,\"TotalOasisFees\");\r\n        emit Consume(tokenid,poolid,amount);\r\n        return true;\r\n    }\r\n\r\n    function paidUpline(address account,uint256 level,uint256 amount) internal {\r\n        address[] memory upline = user.getUserReferrals(account,level);\r\n        string[] memory key = new string[](1);\r\n        uint256[] memory data = new uint256[](1);\r\n        for(uint256 i = 0; i < level; i++){\r\n            if(i==0){\r\n                key[0] = \"level_1\";\r\n                data[0] = amount * 50 / 1000;\r\n                kee.transfer(upline[i],data[0]);\r\n                user.increaseUserData(upline[i],key,data);\r\n            }else{\r\n                if(upline[i]!=address(0)){\r\n                    if(i==1){ key[0] = \"level_2\"; }\r\n                    if(i==2){ key[0] = \"level_3\"; }\r\n                    if(i==3){ key[0] = \"level_4\"; }\r\n                    if(i==4){ key[0] = \"level_5\"; }\r\n                    if(i==5){ key[0] = \"level_6\"; }\r\n                    data[0] = amount * 10 / 1000;\r\n                    kee.transfer(upline[i],data[0]);\r\n                    user.increaseUserData(upline[i],key,data);\r\n                }\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    function increaseSingleKey(address account,uint256 amount,string memory key) internal {\r\n        string[] memory inputKey = new string[](1);\r\n        inputKey[0] = key;\r\n        uint256[] memory data = new uint256[](1);\r\n        data[0] = amount;\r\n        user.increaseUserData(account,inputKey,data);\r\n    }\r\n\r\n    function callFunction(address to,bytes memory data,uint256 value) public onlyOwner returns (bytes memory) {\r\n        if(value>0){\r\n            (bool success,bytes memory result) = to.call{ value: value }(data);\r\n            require(success);\r\n            return result;\r\n        }else{\r\n            (bool success,bytes memory result) = to.call(data);\r\n            require(success);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oasisid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Consume\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"landid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"Mined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"updateAccountRole\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUSDT\",\"type\":\"uint256\"}],\"name\":\"Kee2Usdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"callFunction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"consumeWater\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"getLandInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"getLandInfoDeployer\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"getLandSlotInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getkeekeeEarning\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getkeekeeTick\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getkeekeeWaterDrain\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getkeekeeWaterMax\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keekeeEnergy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keekeeFreeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"landid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"mineOnLand\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"miningId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unixLandStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"input\",\"type\":\"uint256[]\"}],\"name\":\"updatekeekeeEarning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"input\",\"type\":\"uint256[]\"}],\"name\":\"updatekeekeeTick\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"input\",\"type\":\"uint256[]\"}],\"name\":\"updatekeekeeWaterDrain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"input\",\"type\":\"uint256[]\"}],\"name\":\"updatekeekeeWaterMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MiningContract", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a02881d37a9785fc2d988427254ce81882bd89aa3bd526db0c0ecfa2ed7f8c2d"}