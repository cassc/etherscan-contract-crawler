{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract TokenAccessControl {\r\n    bool public paused = false;\r\n    address public owner;\r\n    address public newContractOwner;\r\n    mapping(address => bool) public authorizedContracts;\r\n\r\n    event Pause();\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier ifNotPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not an owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedUser() {\r\n        require(\r\n            authorizedContracts[msg.sender],\r\n            \"caller is not an authorized user\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrAuthorizedUser() {\r\n        require(\r\n            authorizedContracts[msg.sender] || msg.sender == owner,\r\n            \"caller is not an authorized user or an owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newContractOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public ifNotPaused {\r\n        require(msg.sender == newContractOwner);\r\n        emit OwnershipTransferred(owner, newContractOwner);\r\n        owner = newContractOwner;\r\n        newContractOwner = address(0);\r\n    }\r\n\r\n    function setAuthorizedUser(address _operator, bool _approve)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (_approve) {\r\n            authorizedContracts[_operator] = true;\r\n        } else {\r\n            delete authorizedContracts[_operator];\r\n        }\r\n    }\r\n\r\n    function setPause(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n        if (paused) {\r\n            emit Pause();\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC2981 is IERC165 {\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\nabstract contract ERC2981 is IERC2981, ERC165 {\r\n    struct RoyaltyInfo {\r\n        address receiver;\r\n        uint96 royaltyFraction;\r\n    }\r\n\r\n    RoyaltyInfo private _defaultRoyaltyInfo;\r\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(IERC165, ERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC2981).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address, uint256)\r\n    {\r\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\r\n\r\n        if (royalty.receiver == address(0)) {\r\n            royalty = _defaultRoyaltyInfo;\r\n        }\r\n\r\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) /\r\n            _feeDenominator();\r\n\r\n        return (royalty.receiver, royaltyAmount);\r\n    }\r\n\r\n    function _feeDenominator() internal pure virtual returns (uint96) {\r\n        return 10000;\r\n    }\r\n\r\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator)\r\n        internal\r\n        virtual\r\n    {\r\n        require(\r\n            feeNumerator <= _feeDenominator(),\r\n            \"ERC2981: royalty fee will exceed salePrice\"\r\n        );\r\n        require(receiver != address(0), \"ERC2981: invalid receiver\");\r\n\r\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\r\n    }\r\n\r\n    function _deleteDefaultRoyalty() internal virtual {\r\n        delete _defaultRoyaltyInfo;\r\n    }\r\n\r\n    function _setTokenRoyalty(\r\n        uint256 tokenId,\r\n        address receiver,\r\n        uint96 feeNumerator\r\n    ) internal virtual {\r\n        require(\r\n            feeNumerator <= _feeDenominator(),\r\n            \"ERC2981: royalty fee will exceed salePrice\"\r\n        );\r\n        require(receiver != address(0), \"ERC2981: Invalid parameters\");\r\n\r\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\r\n    }\r\n\r\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\r\n        delete _tokenRoyaltyInfo[tokenId];\r\n    }\r\n}\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 value\r\n    );\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed account,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    function balanceOf(address account, uint256 id)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function isApprovedForAll(address account, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ncontract ERC1155 is ERC165, IERC1155 {\r\n    string private _uri;\r\n\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC165, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function uri(uint256) public view returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    function balanceOf(address account, uint256 id)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            account != address(0),\r\n            \"ERC1155: address zero is not a valid owner\"\r\n        );\r\n        return _balances[id][account];\r\n    }\r\n\r\n    function _setBalance(\r\n        address account,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal {\r\n        _balances[id][account] = amount;\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(\r\n            accounts.length == ids.length,\r\n            \"ERC1155: accounts and ids length mismatch\"\r\n        );\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n        return batchBalances;\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        _setApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address account, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            from == msg.sender || isApprovedForAll(from, msg.sender),\r\n            \"ERC1155: caller is not token owner or approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            from == msg.sender || isApprovedForAll(from, msg.sender),\r\n            \"ERC1155: caller is not token owner or approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(\r\n            fromBalance >= amount,\r\n            \"ERC1155: insufficient balance for transfer\"\r\n        );\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(\r\n            ids.length == amounts.length,\r\n            \"ERC1155: ids and amounts length mismatch\"\r\n        );\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(\r\n                fromBalance >= amount,\r\n                \"ERC1155: insufficient balance for transfer\"\r\n            );\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(\r\n            operator,\r\n            from,\r\n            to,\r\n            ids,\r\n            amounts,\r\n            data\r\n        );\r\n    }\r\n\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = msg.sender;\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(\r\n            operator,\r\n            address(0),\r\n            to,\r\n            id,\r\n            amount,\r\n            data\r\n        );\r\n    }\r\n\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(\r\n            ids.length == amounts.length,\r\n            \"ERC1155: ids and amounts length mismatch\"\r\n        );\r\n\r\n        address operator = msg.sender;\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(\r\n            operator,\r\n            address(0),\r\n            to,\r\n            ids,\r\n            amounts,\r\n            data\r\n        );\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = msg.sender;\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n    }\r\n\r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        require(\r\n            ids.length == amounts.length,\r\n            \"ERC1155: ids and amounts length mismatch\"\r\n        );\r\n\r\n        address operator = msg.sender;\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(\r\n                fromBalance >= amount,\r\n                \"ERC1155: burn amount exceeds balance\"\r\n            );\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n    }\r\n\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (isContract(to)) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155Received(\r\n                    operator,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (isContract(to)) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155BatchReceived(\r\n                    operator,\r\n                    from,\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (\r\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\r\n                ) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element)\r\n        private\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\ncontract Shards is ERC1155, ERC2981, TokenAccessControl {\r\n    string private _contractUri;\r\n\r\n    event PayForVirtualAssetMint(\r\n        uint256 indexed paidValue,\r\n        address indexed paidTokenAddress,\r\n        string userId,\r\n        address toAddress,\r\n        uint256 tokenId,\r\n        uint256 amount\r\n    );\r\n\r\n    constructor(string memory uri_, string memory contractUri_) ERC1155(uri_) {\r\n        _contractUri = contractUri_;\r\n    }\r\n\r\n    function contractURI() public view returns (string memory) {\r\n        return _contractUri;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC1155, ERC2981)\r\n        returns (bool)\r\n    {\r\n        return\r\n            ERC1155.supportsInterface(interfaceId) ||\r\n            ERC2981.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator)\r\n        public\r\n        onlyOwner\r\n    {\r\n        _setDefaultRoyalty(receiver, feeNumerator);\r\n    }\r\n\r\n    function setUri(string memory uri) public onlyOwner {\r\n        _setURI(uri);\r\n    }\r\n\r\n    function setContractUri(string memory contractUri) public onlyOwner {\r\n        _contractUri = contractUri;\r\n    }\r\n\r\n    function payMintVA(\r\n        string memory _userId,\r\n        address _mintTo,\r\n        uint256 _tokenId,\r\n        uint256 _amount,\r\n        uint256 _paidTokenAmount,\r\n        address _paidTokenAddress\r\n    ) public payable {\r\n        if(_paidTokenAddress == address(0)){\r\n            emit PayForVirtualAssetMint(\r\n                msg.value,\r\n                address(0),\r\n                _userId,\r\n                _mintTo,\r\n                _tokenId,\r\n                _amount\r\n            );\r\n        }\r\n        else{\r\n            IERC20(_paidTokenAddress).transferFrom(msg.sender, address(this), _paidTokenAmount);\r\n            emit PayForVirtualAssetMint(\r\n                _paidTokenAmount,\r\n                _paidTokenAddress,\r\n                _userId,\r\n                _mintTo,\r\n                _tokenId,\r\n                _amount\r\n            );\r\n        }\r\n    }\r\n\r\n    function mintTo(\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 amount\r\n    ) public onlyOwnerOrAuthorizedUser {\r\n        _mint(to, tokenId, amount, \"\");\r\n    }\r\n\r\n    function mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) public onlyOwnerOrAuthorizedUser {\r\n        _mintBatch(to, ids, amounts, \"\");\r\n    }\r\n\r\n    function withdraw(address contractAddress, uint256 amount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (contractAddress == address(0)) {\r\n            payable(msg.sender).transfer(amount);\r\n        } else {\r\n            if (amount == 0)\r\n                amount = IERC20(contractAddress).balanceOf(address(this));\r\n            IERC20(contractAddress).transfer(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function burn(\r\n        address account,\r\n        uint256 id,\r\n        uint256 value\r\n    ) public virtual {\r\n        require(\r\n            account == msg.sender || isApprovedForAll(account, msg.sender),\r\n            \"ERC1155: caller is not token owner or approved\"\r\n        );\r\n\r\n        _burn(account, id, value);\r\n    }\r\n\r\n    function burn(uint256 tokenId, uint256 amount) external {\r\n        require(\r\n            ERC1155.balanceOf(msg.sender, tokenId) >= amount,\r\n            \"ERC1155: burn amount exceeds balance\"\r\n        );\r\n        _burn(msg.sender, tokenId, amount);\r\n    }\r\n\r\n    function burnBatch(\r\n        address account,\r\n        uint256[] memory ids,\r\n        uint256[] memory values\r\n    ) public virtual {\r\n        require(\r\n            account == msg.sender || isApprovedForAll(account, msg.sender),\r\n            \"ERC1155: caller is not token owner or approved\"\r\n        );\r\n\r\n        _burnBatch(account, ids, values);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractUri_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paidValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paidTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"userId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayForVirtualAssetMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"mintBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newContractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_userId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_mintTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paidTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paidTokenAddress\",\"type\":\"address\"}],\"name\":\"payMintVA\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"setAuthorizedUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractUri\",\"type\":\"string\"}],\"name\":\"setContractUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Shards", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000003068747470733a2f2f6d657461646174612e716f72706f2e776f726c642f63632f7368617264732f7b69647d2e6a736f6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b68747470733a2f2f6d657461646174612e716f72706f2e776f726c642f63632f7368617264732e6a736f6e000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b3bdffc77cf87e1f6789b2c4bb47d86365148d3b0d5be902eaccf02f564df5fd"}