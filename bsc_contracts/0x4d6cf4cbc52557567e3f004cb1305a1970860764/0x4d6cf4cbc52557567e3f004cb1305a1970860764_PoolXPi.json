{"SourceCode": "{\"AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IAccessControl.sol\\\";\\r\\n\\r\\ncontract AccessControl is IAccessControl, Ownable {\\r\\n  struct Role {\\r\\n    mapping(bytes4 =\\u003e bool) permissions;\\r\\n    uint8[] appPermissions;\\r\\n    bytes32 role;\\r\\n  }\\r\\n\\r\\n uint8[] private _allAppPermissions = new uint8[](1);\\r\\n\\r\\n  mapping(bytes32 =\\u003e Role) public _role;\\r\\n  mapping(address =\\u003e bytes32) public _accountRole;\\r\\n  mapping(bytes32 =\\u003e address[]) public _roleAccounts;\\r\\n\\r\\n  bytes4[] public _adminPermissions;\\r\\n  mapping(bytes4 =\\u003e bool) public _allowedSelectors;\\r\\n  \\r\\n  bytes32 private _adminRole;\\r\\n  address private _preventChangesForAddress;\\r\\n\\r\\n  bool private _additionalPermissionsInstalled;\\r\\n  string private _systemAdministratorRole = \\\"systemAdministrator\\\";\\r\\n\\r\\n  modifier checkAccess(bytes4 selector) {\\r\\n    require(\\r\\n      hasPermission(_msgSender(), selector) || _msgSender() == owner(),\\r\\n      \\\"AccessControl: You don\\u0027t have permission to call this function\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor() {\\r\\n    _adminPermissions.push(IAccessControl.createRole.selector);\\r\\n    _allowedSelectors[IAccessControl.createRole.selector] = true;\\r\\n    _adminPermissions.push(IAccessControl.grantRole.selector);\\r\\n    _allowedSelectors[IAccessControl.grantRole.selector] = true;\\r\\n    _adminPermissions.push(IAccessControl.grantRoleBatch.selector);\\r\\n    _allowedSelectors[IAccessControl.grantRoleBatch.selector] = true;\\r\\n    _adminPermissions.push(IAccessControl.revokeRole.selector);\\r\\n    _allowedSelectors[IAccessControl.revokeRole.selector] = true;\\r\\n    _adminPermissions.push(IAccessControl.revokeRoleBatch.selector);\\r\\n    _allowedSelectors[IAccessControl.revokeRoleBatch.selector] = true;\\r\\n    _allAppPermissions.push(100);\\r\\n\\r\\n    _adminRole = bytes32(bytes(\\\"admin\\\"));\\r\\n    _createRole(_adminRole, _adminPermissions, _allAppPermissions);\\r\\n  }\\r\\n\\r\\n  function setAdditionalAdminPermissions(bytes4[] memory selectors) internal {\\r\\n    require(_additionalPermissionsInstalled == false);\\r\\n    for (uint8 i = 0; i \\u003c selectors.length; i++) {\\r\\n      _adminPermissions.push(selectors[i]);\\r\\n      _allowedSelectors[selectors[i]] = true;\\r\\n      _role[bytes32(bytes(\\\"admin\\\"))].permissions[selectors[i]] = true;\\r\\n    }\\r\\n    _additionalPermissionsInstalled = true;\\r\\n    emit ContractPermissions(_adminPermissions);\\r\\n\\r\\n  }\\r\\n\\r\\n  function allowSelectors(bytes4[] memory permissions, bool status) internal {\\r\\n    for (uint8 i = 0; i \\u003c permissions.length; i++) {\\r\\n      _allowedSelectors[permissions[i]] = status;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setSystemAdministrator(address account, bytes4[] memory permissions) internal {\\r\\n    require(_preventChangesForAddress == address(0));\\r\\n    allowSelectors(permissions, true);\\r\\n    _createRole(bytes32(bytes(_systemAdministratorRole)), permissions, new uint8[](0));\\r\\n    _grantRole(account, bytes32(bytes(_systemAdministratorRole)));\\r\\n    allowSelectors(permissions, false);\\r\\n    _preventChangesForAddress = account;\\r\\n    //emit RoleCreated(_systemAdministratorRole, permissions, new uint8[](0));\\r\\n  }\\r\\n\\r\\n  function hasPermission(address account, bytes4 selector) public view returns(bool) {\\r\\n    return _role[_accountRole[account]].permissions[selector];\\r\\n  }\\r\\n\\r\\n  function getAccountRole(address account) public view returns(string memory) {\\r\\n    return string(abi.encodePacked(_accountRole[account]));\\r\\n  }\\r\\n\\r\\n  function createRole(string calldata name, bytes4[] memory selectors, uint8[] memory appPermissions)\\r\\n    external\\r\\n    checkAccess(AccessControl.createRole.selector)\\r\\n  { \\r\\n    bytes32 roleBytes = bytes32(bytes(name));\\r\\n    require(roleBytes != _role[bytes32(bytes(_systemAdministratorRole))].role);\\r\\n    require(roleBytes != _adminRole); //\\\"AccessControl: you can\\u0027t change admin permissions\\\"\\r\\n    _createRole(roleBytes, selectors, appPermissions);\\r\\n    emit RoleCreated(name, selectors, appPermissions);\\r\\n  }\\r\\n\\r\\n  function _createRole(bytes32 name, bytes4[] memory selectors, uint8[] memory appPermissions) internal {\\r\\n    if (_role[name].role != bytes32(0)) {\\r\\n      for (uint8 i = 0; i \\u003c _adminPermissions.length; i++) {\\r\\n        _role[name].permissions[_adminPermissions[i]] = false;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    _role[name].role = name;\\r\\n\\r\\n    for (uint8 i = 0; i \\u003c selectors.length; i++) {\\r\\n      require(_allowedSelectors[selectors[i]]); //\\\"AccessControl: one of the selectors is not allowed\\\"\\r\\n      require(selectors[i] != AccessControl.createRole.selector || _msgSender() == owner());\\r\\n      _role[name].permissions[selectors[i]] = true;\\r\\n    }\\r\\n\\r\\n    _role[name].appPermissions = appPermissions;\\r\\n  }\\r\\n\\r\\n  function removeRole(string calldata name) external onlyOwner {\\r\\n    bytes32 roleBytes = bytes32(bytes(name));\\r\\n    require(roleBytes != _role[bytes32(bytes(_systemAdministratorRole))].role); //\\\"AccessControl: you can\\u0027t remove systemAdministrator role\\\"\\r\\n    require(roleBytes != _adminRole); //\\\"AccessControl: you can\\u0027t remove admin role\\\"\\r\\n    uint256 accountsCount = _roleAccounts[roleBytes].length;\\r\\n    for (uint256 i = 0; i \\u003c accountsCount; i++) {\\r\\n      _accountRole[_roleAccounts[roleBytes][i]] = bytes32(0);\\r\\n    }\\r\\n    delete _role[roleBytes];\\r\\n    emit RoleRemoved(name);\\r\\n  }\\r\\n\\r\\n  function grantRole(address account, string memory role) public checkAccess(IAccessControl.grantRole.selector) {\\r\\n    require(account != address(0)); // \\\"AccessControl: prevent grant zero address\\\"\\r\\n    require(account != _msgSender()); // \\\"AccessControl: you can\\u0027t grant self another role\\\"\\r\\n    require(account != _preventChangesForAddress); // \\\"AccessControl: excluded account\\\"\\r\\n    require(account != owner()); // \\\"AccessControl: you can\\u0027t change owner account\\\"\\r\\n\\r\\n    _grantRole(account, bytes32(bytes(role)));\\r\\n    emit RoleGranted(account, role);\\r\\n  }\\r\\n\\r\\n  function _grantRole(address account, bytes32 role) internal {\\r\\n    if (_accountRole[account] != bytes32(0)) {\\r\\n      uint256 accountsCount = _roleAccounts[_accountRole[account]].length;\\r\\n\\r\\n      if (accountsCount == 1) {\\r\\n        _roleAccounts[_accountRole[account]].pop();\\r\\n      } else {\\r\\n        for (uint256 i = 0; i \\u003c accountsCount; i++) {\\r\\n          if (account == _roleAccounts[_accountRole[account]][i]) {\\r\\n            _roleAccounts[_accountRole[account]][i] = _roleAccounts[_accountRole[account]][accountsCount - 1];\\r\\n            _roleAccounts[_accountRole[account]].pop();\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    _accountRole[account] = role;\\r\\n    _roleAccounts[role].push(account);\\r\\n  }\\r\\n\\r\\n  function grantRoleBatch(address[] calldata accounts, string[] calldata roles) external checkAccess(IAccessControl.grantRoleBatch.selector) {\\r\\n    require(accounts.length == roles.length); //\\\"AccessControl: accounts size not equal to roles size\\\"\\r\\n    for (uint256 i = 0; i \\u003c accounts.length; i++) {\\r\\n      grantRole(accounts[i], roles[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function revokeRole(address account) external checkAccess(IAccessControl.revokeRole.selector) {\\r\\n    require(account != _msgSender()); //\\\"AccessControl: you can\\u0027t revoke your own role\\\"\\r\\n    require(_accountRole[account] != bytes32(0)); //\\\"AccessControl: account already at base role\\\"\\r\\n    grantRole(account, \\\"\\\");\\r\\n  }\\r\\n\\r\\n  function revokeRoleBatch(address[] calldata accounts) external checkAccess(IAccessControl.revokeRoleBatch.selector) {\\r\\n    for (uint256 i = 0; i \\u003c accounts.length; i++) {\\r\\n      grantRole(accounts[i], \\\"\\\");\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        return account.code.length \\u003e 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\ninterface IAccessControl {\\r\\n  event RoleCreated(string name, bytes4[] permissions, uint8[] appPermissions);\\r\\n  event RoleGranted(address indexed account, string role);\\r\\n  event RoleRemoved(string name);\\r\\n  event ContractPermissions(bytes4[] permissions);\\r\\n\\r\\n  function hasPermission(address account, bytes4 selector) external view returns(bool);\\r\\n\\r\\n  function getAccountRole(address account) external view returns(string memory);\\r\\n  \\r\\n  function createRole(string calldata name, bytes4[] memory selectors, uint8[] memory appPermissions) external;\\r\\n\\r\\n  function grantRole(address account, string memory role) external;\\r\\n\\r\\n  function removeRole(string calldata name) external;\\r\\n\\r\\n  function grantRoleBatch(address[] calldata accounts, string[] calldata roles) external;\\r\\n\\r\\n  function revokeRole(address account) external;\\r\\n\\r\\n  function revokeRoleBatch(address[] calldata accounts) external;\\r\\n}\"},\"IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\ninterface IOwnable {\\r\\n    function owner() external returns(address);\\r\\n}\"},\"IPool.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\ninterface IPool {\\r\\n  // function changePoolMeta(string memory name, string memory site) external;\\r\\n\\r\\n  function updatePoolOptions(\\r\\n    string memory name,\\r\\n    string memory site,\\r\\n    uint256 minStakeTokens,\\r\\n    uint256[] memory refLevelsWithPercent,\\r\\n    uint256 poolRefPercent,\\r\\n    address poolAccount\\r\\n  ) external;\\r\\n\\r\\n  function pause(bool status) external;\\r\\n\\r\\n  function calculateClaimReward(address account, uint256 stakeIndex) external returns (uint256);\\r\\n\\r\\n  function stake(uint256 amount, address referer) external;\\r\\n\\r\\n  function offchainClaim(address account, uint256 stakeIndex) external;\\r\\n\\r\\n  function claim() external;\\r\\n\\r\\n  event StakeCreated(uint256 stakeIndex, address referer);\\r\\n\\r\\n  event Claim(uint256 stakeIndex);\\r\\n\\r\\n  // event PoolMetaChanged(string newName, string newSite);\\r\\n\\r\\n  event PoolOptionsChanged(\\r\\n    string name,\\r\\n    string site,\\r\\n    uint256 minStakeTokens,\\r\\n    uint256[] refLevelsWithPercent,\\r\\n    uint256 poolRefPercent,\\r\\n    address poolAccount\\r\\n  );\\r\\n}\\r\\n\\r\\ninterface IPoolXPi {\\r\\n  // function changePoolMeta(string memory name, string memory site) external;\\r\\n\\r\\n  function updatePoolOptions(\\r\\n    string memory name,\\r\\n    string memory site,\\r\\n    uint256 minStakeTokens,\\r\\n    address poolAccount\\r\\n  ) external;\\r\\n\\r\\n  function pause(bool status) external;\\r\\n\\r\\n  function calculateClaimReward(address account, uint256 stakeIndex) external returns (uint256);\\r\\n\\r\\n  function stake(uint256 amount, address referer) external;\\r\\n\\r\\n  function offchainClaim(address account, uint256 stakeIndex) external;\\r\\n\\r\\n  function claim() external;\\r\\n\\r\\n  event StakeCreated(uint256 stakeIndex, address referer);\\r\\n  \\r\\n  event Claim(uint256 stakeIndex);\\r\\n\\r\\n  // event PoolMetaChanged(string newName, string newSite);\\r\\n\\r\\n  event PoolOptionsChanged(\\r\\n    string name,\\r\\n    string site,\\r\\n    uint256 minStakeTokens,\\r\\n    uint256[] refLevelsWithPercent,\\r\\n    uint256 poolRefPercent,\\r\\n    address poolAccount\\r\\n  );\\r\\n}\\r\\n\"},\"IPoolManager.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\ninterface IPoolManager {\\r\\n  \\r\\n  function getStakeProfitTable() external view returns (uint256[][] memory);\\r\\n\\r\\n  function getCurrentStakeProfitPercent() external view returns (uint256);\\r\\n\\r\\n  function transferFrom(address from, address to, uint256 amount) external; \\r\\n  \\r\\n  function transferFromAirdrop(address from, address to, uint256 amount) external; \\r\\n\\r\\n  function mint(address account, uint256 amount) external;\\r\\n\\r\\n  function burn(address account, uint256 amount) external;\\r\\n\\r\\n  function burnAirdrop(address account, uint256 amount) external;\\r\\n\\r\\n  function appendStake(\\r\\n    uint256 body,\\r\\n    uint256 createdAt,\\r\\n    uint256 expiriedAt\\r\\n  ) external;\\r\\n\\r\\n  function pause(bool status) external;\\r\\n\\r\\n  function mintTeamReward() external returns(uint256);\\r\\n\\r\\n\\r\\n  event PoolCreated(\\r\\n    uint256 poolIndex,\\r\\n    uint256 price\\r\\n  );\\r\\n\\r\\n  event TeamWalletChanged(uint256 index, address newWallet);\\r\\n}\\r\\n\"},\"Moment.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nlibrary Moment {\\r\\n  uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n  uint256 constant SECONDS_PER_HOUR = 60 * 60;\\r\\n  //uint256 constant SECONDS_PER_MINUTE = 60;\\r\\n  int256 constant OFFSET19700101 = 2440588;\\r\\n\\r\\n  // uint256 constant DOW_MON = 1;\\r\\n  // uint256 constant DOW_TUE = 2;\\r\\n  // uint256 constant DOW_WED = 3;\\r\\n  // uint256 constant DOW_THU = 4;\\r\\n  // uint256 constant DOW_FRI = 5;\\r\\n  // uint256 constant DOW_SAT = 6;\\r\\n  // uint256 constant DOW_SUN = 7;\\r\\n\\r\\n  function _daysFromDate(\\r\\n    uint256 year,\\r\\n    uint256 month,\\r\\n    uint256 day\\r\\n  ) internal pure returns (uint256 _days) {\\r\\n    require(year \\u003e= 1970);\\r\\n    int256 _year = int256(year);\\r\\n    int256 _month = int256(month);\\r\\n    int256 _day = int256(day);\\r\\n\\r\\n    int256 __days = _day -\\r\\n      32075 +\\r\\n      (1461 * (_year + 4800 + (_month - 14) / 12)) /\\r\\n      4 +\\r\\n      (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\r\\n      12 -\\r\\n      (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\r\\n      4 -\\r\\n      OFFSET19700101;\\r\\n\\r\\n    _days = uint256(__days);\\r\\n  }\\r\\n\\r\\n  function _daysToDate(uint256 _days)\\r\\n    internal\\r\\n    pure\\r\\n    returns (\\r\\n      uint256 year,\\r\\n      uint256 month,\\r\\n      uint256 day\\r\\n    )\\r\\n  {\\r\\n    int256 __days = int256(_days);\\r\\n\\r\\n    int256 L = __days + 68569 + OFFSET19700101;\\r\\n    int256 N = (4 * L) / 146097;\\r\\n    L = L - (146097 * N + 3) / 4;\\r\\n    int256 _year = (4000 * (L + 1)) / 1461001;\\r\\n    L = L - (1461 * _year) / 4 + 31;\\r\\n    int256 _month = (80 * L) / 2447;\\r\\n    int256 _day = L - (2447 * _month) / 80;\\r\\n    L = _month / 11;\\r\\n    _month = _month + 2 - 12 * L;\\r\\n    _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n    year = uint256(_year);\\r\\n    month = uint256(_month);\\r\\n    day = uint256(_day);\\r\\n  }\\r\\n\\r\\n  function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\\r\\n    leapYear = ((year % 4 == 0) \\u0026\\u0026 (year % 100 != 0)) || (year % 400 == 0);\\r\\n  }\\r\\n\\r\\n  function _getDaysInMonth(uint256 year, uint256 month) internal pure returns (uint256 daysInMonth) {\\r\\n    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\r\\n      daysInMonth = 31;\\r\\n    } else if (month != 2) {\\r\\n      daysInMonth = 30;\\r\\n    } else {\\r\\n      daysInMonth = _isLeapYear(year) ? 29 : 28;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function addYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {\\r\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    year += _years;\\r\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\r\\n    if (day \\u003e daysInMonth) {\\r\\n      day = daysInMonth;\\r\\n    }\\r\\n    newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\r\\n    require(newTimestamp \\u003e= timestamp);\\r\\n  }\\r\\n\\r\\n  function diffDays(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _days) {\\r\\n    require(fromTimestamp \\u003c= toTimestamp);\\r\\n    _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\r\\n  }\\r\\n\\r\\n  function diffHours(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _hours) {\\r\\n    require(fromTimestamp \\u003c= toTimestamp);\\r\\n    _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\r\\n  }\\r\\n\\r\\n  function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _seconds) {\\r\\n    require(fromTimestamp \\u003c= toTimestamp);\\r\\n    _seconds = toTimestamp - fromTimestamp;\\r\\n  }\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0));\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"},\"Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\nabstract contract Pausable is Context {\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor() {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused(), \\\"Pausable: paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        require(paused(), \\\"Pausable: not paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(_msgSender());\\r\\n    }\\r\\n}\\r\\n\"},\"PoolXPi.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Moment.sol\\\";\\r\\nimport \\\"./Pausable.sol\\\";\\r\\nimport \\\"./AccessControl.sol\\\";\\r\\nimport \\\"./IPoolManager.sol\\\";\\r\\nimport \\\"./IPool.sol\\\";\\r\\nimport \\\"./IOwnable.sol\\\";\\r\\n\\r\\ncontract PoolXPi is IPoolXPi, AccessControl, Pausable {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  IPoolManager public _poolManager;\\r\\n\\r\\n  uint256 public _minStakeTokens;\\r\\n  uint256 public _burnPercent = 85;\\r\\n  uint256 public _stakeLifetimeInYears = 1;\\r\\n  uint256 public _claimComission = 10;\\r\\n\\r\\n  struct Stake {\\r\\n    uint256 body;\\r\\n    uint256 createdAt;\\r\\n    uint256 expiresIn;\\r\\n    uint256 lastClaim;\\r\\n    bool isDone;\\r\\n  }\\r\\n\\r\\n  Stake[] public _poolStakes;\\r\\n  uint256 private _lastExpiriedStakeIndex;\\r\\n\\r\\n  mapping(address =\\u003e Stake[]) public _stakes;\\r\\n  mapping(address =\\u003e uint256) private _lastAccountExpiriedStakeIndex;\\r\\n\\r\\n  address public _poolAccount;\\r\\n\\r\\n  struct RefererLevel {\\r\\n    uint256 minStakesAmount;\\r\\n    uint256 minReferrals;\\r\\n    uint256 minReferralsStakesAmount;\\r\\n    uint8 depth;\\r\\n  }\\r\\n\\r\\n  uint256 public _maxRefPercent = 15;\\r\\n  uint256 public _maxDepth = 15;\\r\\n  uint256 public _directRefPercent = 9;\\r\\n  uint256 public _poolRefPercent = 1;\\r\\n\\r\\n  RefererLevel[] public _refererLevels;\\r\\n\\r\\n  mapping(address =\\u003e address) public _referralToReferer;\\r\\n  mapping(address =\\u003e address[]) public _refererToReferrals;\\r\\n  mapping(address =\\u003e uint256) private _referralIndex;\\r\\n  \\r\\n  struct RefererStats {\\r\\n    uint256 referralsCount;\\r\\n    uint256 totalActiveStakesSum;\\r\\n  }\\r\\n  \\r\\n  mapping(address =\\u003e mapping(uint256 =\\u003e RefererStats)) public _refererStats;\\r\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) public _onLineReferral;\\r\\n\\r\\n  string public _name;\\r\\n  string public _site;\\r\\n\\r\\n  uint256 _startedAt;\\r\\n\\r\\n  constructor(\\r\\n    IPoolManager poolManager,\\r\\n    uint256 minStakeTokens,\\r\\n    address poolAccount\\r\\n  ) {\\r\\n    updatePoolOptions(\\\"X3.14\\\", \\\"https://x314.site\\\", minStakeTokens, poolAccount);\\r\\n\\r\\n    bytes4[] memory permissions = new bytes4[](1);\\r\\n    \\r\\n    permissions[0] = IPool.pause.selector;\\r\\n    // permissions[1] = IPool.changePoolMeta.selector;\\r\\n    setSystemAdministrator(IOwnable(address(poolManager)).owner(), permissions);\\r\\n\\r\\n    bytes4[] memory additionalAdminPermissions = new bytes4[](1);\\r\\n    additionalAdminPermissions[0] = IPoolXPi.updatePoolOptions.selector;\\r\\n\\r\\n    setAdditionalAdminPermissions(permissions);\\r\\n    \\r\\n    _poolManager = poolManager;\\r\\n\\r\\n    _startedAt = block.timestamp;\\r\\n  }\\r\\n\\r\\n  function updateRefLevel(uint256 minStakesAmount, uint256 minReferrals, uint256 minReferralsStakesAmount, uint8 depth, uint256 index) external onlyOwner {\\r\\n    _refererLevels[index] = RefererLevel({\\r\\n      minStakesAmount: minStakesAmount,\\r\\n      minReferrals: minReferrals,\\r\\n      minReferralsStakesAmount: minReferralsStakesAmount,\\r\\n      depth: depth\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function pushRefLevel(uint256 minStakesAmount, uint256 minReferrals, uint256 minReferralsStakesAmount, uint8 depth) external onlyOwner {\\r\\n    _refererLevels.push(RefererLevel({\\r\\n      minStakesAmount: minStakesAmount,\\r\\n      minReferrals: minReferrals,\\r\\n      minReferralsStakesAmount: minReferralsStakesAmount,\\r\\n      depth: depth\\r\\n    }));\\r\\n  }\\r\\n\\r\\n  // function changePoolMeta(string memory name, string memory site) public checkAccess(IPool.changePoolMeta.selector) {\\r\\n  //   _name = name;\\r\\n  //   _site = site;\\r\\n  //   emit PoolMetaChanged(name, site);\\r\\n  // }\\r\\n\\r\\n  function updatePoolOptions(\\r\\n    string memory name,\\r\\n    string memory site,\\r\\n    uint256 minStakeTokens,\\r\\n    address poolAccount\\r\\n  ) public override checkAccess(IPoolXPi.updatePoolOptions.selector) {\\r\\n    require(minStakeTokens \\u003e 0);\\r\\n    require(poolAccount != address(0));\\r\\n    _minStakeTokens = minStakeTokens;\\r\\n    _poolAccount = poolAccount;\\r\\n    _name = name;\\r\\n    _site = site;\\r\\n    emit PoolOptionsChanged(\\r\\n      name,\\r\\n      site,\\r\\n      minStakeTokens,\\r\\n      new uint256[](0),\\r\\n      0,\\r\\n      poolAccount\\r\\n    );\\r\\n  }\\r\\n\\r\\n\\r\\n  function pause(bool status) external {\\r\\n    require(_msgSender() == address(_poolManager) || hasPermission(_msgSender(), IPool.pause.selector));\\r\\n    status == true ? _pause() : _unpause();\\r\\n  }\\r\\n\\r\\n\\r\\n  /* STAKE SECTION */\\r\\n\\r\\n  function calculateClaimReward(address account, uint256 stakeIndex) public view returns (uint256) {\\r\\n    uint256 currentTimestamp = block.timestamp;\\r\\n    uint256 totalReward = 0;\\r\\n\\r\\n    Stake storage stakeItem = _stakes[account][stakeIndex];\\r\\n\\r\\n    uint256[][] memory stakeProfitTable = _poolManager.getStakeProfitTable();\\r\\n\\r\\n    for (uint256 i = 0; i \\u003c stakeProfitTable.length; i++) {\\r\\n      if (stakeItem.expiresIn \\u003c= stakeProfitTable[i][0] || currentTimestamp \\u003c= stakeProfitTable[i][0]) break;\\r\\n      if (stakeItem.createdAt \\u003e= stakeProfitTable[i][1]) continue;\\r\\n\\r\\n      if (stakeItem.createdAt \\u003e= stakeProfitTable[i][0] || stakeItem.expiresIn \\u003c= stakeProfitTable[i][1]) {\\r\\n        uint256 timeFrom = stakeItem.lastClaim \\u003c stakeProfitTable[i][0] ? stakeProfitTable[i][0] : stakeItem.lastClaim;\\r\\n        uint256 timeTo = currentTimestamp \\u003e stakeProfitTable[i][1] ? stakeProfitTable[i][1] : currentTimestamp;\\r\\n\\r\\n        totalReward = totalReward.add(calculateClaimRewardByPeriod(stakeItem.body, stakeProfitTable[i][2], timeFrom, timeTo));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (currentTimestamp \\u003c stakeItem.expiresIn) {\\r\\n      uint256 comission = totalReward.mul(_claimComission).div(100);\\r\\n      totalReward = totalReward.sub(comission);\\r\\n    }\\r\\n\\r\\n    return totalReward;\\r\\n  }\\r\\n\\r\\n  function calculateClaimRewardByPeriod(\\r\\n    uint256 body,\\r\\n    uint256 profitPercent,\\r\\n    uint256 timeFrom,\\r\\n    uint256 timeTo\\r\\n  ) internal pure returns (uint256) {\\r\\n    uint256 daysPassed = Moment.diffDays(timeFrom, timeTo);\\r\\n    uint256 secondsPassed = Moment.diffSeconds(timeFrom, timeTo);\\r\\n    uint256 perPeriodProfit = body.mul(profitPercent).div(100);\\r\\n    uint256 full30DaysPassed = daysPassed.div(30);\\r\\n    uint256 reward = 0;\\r\\n    if (full30DaysPassed \\u003e= 1) {\\r\\n      reward = reward.add(full30DaysPassed.mul(perPeriodProfit));\\r\\n    }\\r\\n\\r\\n    uint256 remainDays = daysPassed.sub(full30DaysPassed.mul(30));\\r\\n    uint256 remainSeconds = secondsPassed.sub(daysPassed.mul(1 days));\\r\\n    uint256 remainPercentOfPeriod = remainDays.mul(1 days).add(remainSeconds).mul(100).mul(10000).div(30 days);\\r\\n    uint256 remainProfit = (perPeriodProfit.mul(remainPercentOfPeriod)).div(100).div(10000);\\r\\n    return reward.add(remainProfit);\\r\\n  }\\r\\n\\r\\n  function createStake(uint256 amount) internal returns(uint256) {\\r\\n    uint256 createdAt = block.timestamp;\\r\\n    uint256 expiresIn = Moment.addYears(createdAt, _stakeLifetimeInYears);\\r\\n\\r\\n    Stake memory accountStake = Stake({\\r\\n      body: amount,\\r\\n      createdAt: createdAt,\\r\\n      expiresIn: expiresIn,\\r\\n      lastClaim: createdAt,\\r\\n      isDone: false\\r\\n    });\\r\\n\\r\\n    _stakes[_msgSender()].push(accountStake);\\r\\n\\r\\n    uint256 stakeIndex = _stakes[_msgSender()].length - 1;\\r\\n\\r\\n    _poolStakes.push(accountStake);\\r\\n\\r\\n    _poolManager.appendStake(amount, createdAt, expiresIn);\\r\\n\\r\\n    return stakeIndex;\\r\\n  }\\r\\n\\r\\n  function refFlow(uint256 stakeIndex, uint256 amount, address referer, bool isAirdrop) internal {\\r\\n    if (stakeIndex == 0) {\\r\\n      _refererStats[_msgSender()][0] = RefererStats({\\r\\n        referralsCount: 0,\\r\\n        totalActiveStakesSum: amount\\r\\n      });\\r\\n\\r\\n      for (uint256 i = 1; i \\u003c= _maxDepth; i++) {\\r\\n        _refererStats[_msgSender()][i] = RefererStats({\\r\\n          referralsCount: 0,\\r\\n          totalActiveStakesSum: 0\\r\\n        });\\r\\n      }\\r\\n    } else {\\r\\n      _refererStats[_msgSender()][0].totalActiveStakesSum = _refererStats[_msgSender()][0].totalActiveStakesSum.add(amount);\\r\\n    }\\r\\n\\r\\n    if (_msgSender() != referer \\u0026\\u0026 _referralToReferer[_msgSender()] == address(0)) {\\r\\n      registration(_msgSender(), referer);\\r\\n      _refererStats[referer][1].totalActiveStakesSum = _refererStats[referer][1].totalActiveStakesSum.add(amount);\\r\\n    }\\r\\n    distributeRewards(_msgSender(), amount, isAirdrop);\\r\\n  }\\r\\n\\r\\n  function stakeAirdrop(uint256 amount, address referer) external whenNotPaused {\\r\\n    if (referer == address(0)) {\\r\\n      require(block.timestamp \\u003e _startedAt + 24 hours * 3);\\r\\n    }\\r\\n    require(_msgSender() == owner() || (_msgSender() != owner() \\u0026\\u0026 _stakes[owner()].length \\u003e 0));\\r\\n    require(amount \\u003e= _minStakeTokens);\\r\\n    if (_stakes[referer].length == 0 || referer == address(0)) {\\r\\n      referer = owner();\\r\\n    }\\r\\n\\r\\n    uint256 stakeIndex = createStake(amount);\\r\\n\\r\\n    _poolManager.burnAirdrop(_msgSender(), amount);\\r\\n\\r\\n    refFlow(stakeIndex, amount, referer, true);\\r\\n\\r\\n    emit StakeCreated(stakeIndex, referer);\\r\\n  }\\r\\n\\r\\n  function stake(uint256 amount, address referer) external whenNotPaused {\\r\\n    if (referer == address(0)) {\\r\\n      require(block.timestamp \\u003e _startedAt + 24 hours * 3);\\r\\n    }\\r\\n    require(_msgSender() == owner() || (_msgSender() != owner() \\u0026\\u0026 _stakes[owner()].length \\u003e 0));\\r\\n    require(amount \\u003e= _minStakeTokens);\\r\\n    if (_stakes[referer].length == 0 || referer == address(0)) {\\r\\n      referer = owner();\\r\\n    }\\r\\n    \\r\\n    uint256 stakeIndex = createStake(amount);\\r\\n\\r\\n    uint256 burnAmount = amount.mul(_burnPercent).div(100);\\r\\n\\r\\n    _poolManager.burn(_msgSender(), burnAmount);\\r\\n\\r\\n    refFlow(stakeIndex, amount, referer, false);\\r\\n\\r\\n    emit StakeCreated(stakeIndex, referer);\\r\\n  }\\r\\n\\r\\n  function claimFromStake(uint256 stakeIndex) external {\\r\\n    address account = _msgSender();\\r\\n    require(_stakes[account].length \\u003e 0);\\r\\n    require(_stakes[account][stakeIndex].body \\u003e 0 \\u0026\\u0026 !_stakes[account][stakeIndex].isDone);\\r\\n    uint256 reward = calculateClaimReward(account, stakeIndex);\\r\\n    _stakes[account][stakeIndex].lastClaim = block.timestamp;\\r\\n    if (block.timestamp \\u003e= _stakes[account][stakeIndex].expiresIn) {\\r\\n      _lastAccountExpiriedStakeIndex[account] = stakeIndex;\\r\\n      _stakes[account][stakeIndex].isDone = true;\\r\\n    }\\r\\n    _poolManager.mint(account, reward);\\r\\n    emit Claim(stakeIndex);\\r\\n  }\\r\\n\\r\\n  function offchainClaim(address account, uint256 stakeIndex) external {\\r\\n    require(_stakes[account].length \\u003e 0);\\r\\n    require(_stakes[account][stakeIndex].body \\u003e 0 \\u0026\\u0026 block.timestamp \\u003e= _stakes[account][stakeIndex].expiresIn \\u0026\\u0026 !_stakes[account][stakeIndex].isDone, \\\"not expiried now\\\");\\r\\n    uint256 reward = calculateClaimReward(account, stakeIndex);\\r\\n    _stakes[account][stakeIndex].lastClaim = block.timestamp;\\r\\n    _stakes[account][stakeIndex].isDone = true;\\r\\n    _lastAccountExpiriedStakeIndex[account] = stakeIndex;\\r\\n    _poolManager.mint(account, reward);\\r\\n    emit Claim(stakeIndex);\\r\\n  }\\r\\n\\r\\n  function claim() external {\\r\\n    require(_stakes[_msgSender()].length \\u003e 0);\\r\\n    uint256 totalClaimReward = 0;\\r\\n    address account = _msgSender();\\r\\n    for (uint256 i = _lastAccountExpiriedStakeIndex[account]; i \\u003c _stakes[account].length; i++) {\\r\\n      uint256 reward = calculateClaimReward(account, i);\\r\\n      _stakes[account][i].lastClaim = block.timestamp;\\r\\n      if (_stakes[account][i].lastClaim \\u003e= _stakes[account][i].expiresIn) {\\r\\n        _lastAccountExpiriedStakeIndex[account] = i;\\r\\n        _stakes[account][i].isDone = true;\\r\\n      }\\r\\n      totalClaimReward = totalClaimReward.add(reward);\\r\\n      emit Claim(i);\\r\\n    }\\r\\n\\r\\n    _poolManager.mint(account, totalClaimReward);\\r\\n  }\\r\\n\\r\\n  /* \\\\STAKE SECTION */\\r\\n\\r\\n  /* REF SECTION */\\r\\n\\r\\n  function registration(address referral, address referer) internal  {\\r\\n    require(_referralToReferer[referral] == address(0));\\r\\n    _referralToReferer[referral] = referer;\\r\\n    _refererToReferrals[referer].push(referral);\\r\\n    _referralIndex[referral] = _refererToReferrals[referer].length - 1;\\r\\n    _refererStats[referer][1].referralsCount++;\\r\\n  }\\r\\n\\r\\n  function transferFrom(address from, address to, uint256 amount, bool isAirdrop) internal {\\r\\n    if (isAirdrop) {\\r\\n      _poolManager.mint(to, amount);\\r\\n    } else {\\r\\n      _poolManager.transferFrom(from, to, amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function distributeRewards(address referral, uint256 stakeBody, bool isAirdrop) internal {\\r\\n    if (_referralToReferer[referral] == address(0)) {\\r\\n      uint256 rewardAmount = stakeBody.mul(_maxRefPercent).div(100);\\r\\n      transferFrom(referral, _poolAccount, rewardAmount, isAirdrop);\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    uint256 poolReward = stakeBody.mul(_poolRefPercent).div(100);\\r\\n\\r\\n    address referer = _referralToReferer[referral];\\r\\n\\r\\n    uint256 lvl1RefererReward = stakeBody.mul(_directRefPercent).div(100);\\r\\n\\r\\n    transferFrom(referral, referer, lvl1RefererReward, isAirdrop);\\r\\n\\r\\n    uint256 forDistribution = stakeBody.mul(_maxRefPercent).div(100).sub(lvl1RefererReward).sub(poolReward);\\r\\n    uint256 upperLvlReferersReward = forDistribution;\\r\\n    referer = _referralToReferer[referer];\\r\\n\\r\\n    uint256 distributed = 0;\\r\\n\\r\\n    for (uint256 i = 2; i \\u003c= _maxDepth; i++) {\\r\\n      if (referer == address(0)) break;\\r\\n      if (_onLineReferral[referer][referral] == 0) {\\r\\n        _onLineReferral[referer][referral] = i;\\r\\n        _refererStats[referer][0].referralsCount++;\\r\\n        _refererStats[referer][i].referralsCount++; \\r\\n      }\\r\\n      _refererStats[referer][i].totalActiveStakesSum = _refererStats[referer][i].totalActiveStakesSum.add(stakeBody);\\r\\n      uint256 refererLevelIndex = getRefererLevelIndex(referer);\\r\\n      uint256 reward = upperLvlReferersReward.div(3);\\r\\n\\r\\n      upperLvlReferersReward = upperLvlReferersReward.sub(reward);\\r\\n      if (refererLevelIndex == 100 || (refererLevelIndex != 100 \\u0026\\u0026 i \\u003e _refererLevels[refererLevelIndex].depth)) {\\r\\n        referer = _referralToReferer[referer];\\r\\n        continue;\\r\\n      }\\r\\n      transferFrom(referral, referer, reward, isAirdrop);\\r\\n      distributed = distributed.add(reward);\\r\\n      referer = _referralToReferer[referer];\\r\\n    }\\r\\n\\r\\n    poolReward = poolReward.add(forDistribution.sub(distributed));\\r\\n\\r\\n    transferFrom(referral, _poolAccount, poolReward, isAirdrop);\\r\\n  }\\r\\n\\r\\n  function isHigher(\\r\\n    uint256 index,\\r\\n    uint256 stakesAmount,\\r\\n    uint256 referralsCount,\\r\\n    uint256 minReferralsStakesAmount\\r\\n  ) internal view returns (bool) {\\r\\n    return\\r\\n      stakesAmount \\u003e= _refererLevels[index].minStakesAmount \\u0026\\u0026\\r\\n      referralsCount \\u003e= _refererLevels[index].minReferrals \\u0026\\u0026\\r\\n      minReferralsStakesAmount \\u003e= _refererLevels[index].minReferralsStakesAmount;\\r\\n  }\\r\\n\\r\\n  function someoneIsLower(\\r\\n    uint256 index,\\r\\n    uint256 stakesAmount,\\r\\n    uint256 referralsCount,\\r\\n    uint256 minReferralsStakesAmount\\r\\n  ) internal view returns (bool) {\\r\\n    return\\r\\n      stakesAmount \\u003c _refererLevels[index].minStakesAmount ||\\r\\n      referralsCount \\u003c _refererLevels[index].minReferrals ||\\r\\n      minReferralsStakesAmount \\u003c _refererLevels[index].minReferralsStakesAmount;\\r\\n  }\\r\\n\\r\\n  function getSums(address referer, uint256 fromLevel, uint256 toLevel) internal view returns(uint256, uint256) {\\r\\n    uint256 totalReferrals = 0;\\r\\n    uint256 totalReferralsStakesSum = 0;\\r\\n    for (uint256 i = fromLevel; i \\u003c= toLevel; i++) {\\r\\n      totalReferrals = totalReferrals.add(_refererStats[referer][i].referralsCount);\\r\\n      totalReferralsStakesSum = totalReferralsStakesSum.add(_refererStats[referer][i].totalActiveStakesSum);\\r\\n    }\\r\\n    return (totalReferrals, totalReferralsStakesSum);\\r\\n  }\\r\\n\\r\\n  function getRefererLevelIndex(address referer) internal view returns(uint256) {\\r\\n    uint256 refererStakesSum = _refererStats[referer][0].totalActiveStakesSum;\\r\\n    (uint256 totalReferrals, uint256 totalReferralsStakesSum) = getSums(referer, 1, 2);\\r\\n    if (someoneIsLower(0, refererStakesSum, totalReferrals, totalReferralsStakesSum)) return 100;\\r\\n    \\r\\n    for (uint256 i = 0; i \\u003c _refererLevels.length; i++) {\\r\\n      (totalReferrals, totalReferralsStakesSum) = getSums(referer, 1, _refererLevels[i].depth);\\r\\n      bool isHigherCurrent = isHigher(i, refererStakesSum, totalReferrals, totalReferralsStakesSum);\\r\\n      bool hasNextLevel = i + 1 \\u003c _refererLevels.length;\\r\\n      bool someoneIsLowerNext = hasNextLevel \\u0026\\u0026 someoneIsLower(i + 1, refererStakesSum, totalReferrals, totalReferralsStakesSum);\\r\\n      if ((isHigherCurrent \\u0026\\u0026 !hasNextLevel) || (isHigherCurrent \\u0026\\u0026 someoneIsLowerNext)) {\\r\\n        return i;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return 100;\\r\\n  }\\r\\n\\r\\n  /* \\\\REF SECTION */\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003c= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStakeTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"poolAccount\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"permissions\",\"type\":\"bytes4[]\"}],\"name\":\"ContractPermissions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"site\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minStakeTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"refLevelsWithPercent\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolRefPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolAccount\",\"type\":\"address\"}],\"name\":\"PoolOptionsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"permissions\",\"type\":\"bytes4[]\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"appPermissions\",\"type\":\"uint8[]\"}],\"name\":\"RoleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"}],\"name\":\"StakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_accountRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_adminPermissions\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"_allowedSelectors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_claimComission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_directRefPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxDepth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxRefPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minStakeTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_onLineReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_poolAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_poolManager\",\"outputs\":[{\"internalType\":\"contract IPoolManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_poolRefPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_poolStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"body\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDone\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_refererLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minStakesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReferrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReferralsStakesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_refererStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referralsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalActiveStakesSum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_refererToReferrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_referralToReferer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_role\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_roleAccounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_site\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_stakeLifetimeInYears\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"body\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDone\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"calculateClaimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"claimFromStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"},{\"internalType\":\"uint8[]\",\"name\":\"appPermissions\",\"type\":\"uint8[]\"}],\"name\":\"createRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountRole\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"roles\",\"type\":\"string[]\"}],\"name\":\"grantRoleBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"hasPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"offchainClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minStakesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReferrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReferralsStakesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"}],\"name\":\"pushRefLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"removeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"revokeRoleBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"}],\"name\":\"stakeAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"site\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minStakeTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"poolAccount\",\"type\":\"address\"}],\"name\":\"updatePoolOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minStakesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReferrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReferralsStakesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"updateRefLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PoolXPi", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f7c3a8601a1048f6b5de10b00aa1ef0e973d370f0000000000000000000000000000000000000000000000003782dace9d900000000000000000000000000000161576dfb1414c3ecc2b4216d22758f86cd0000f", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5fd0185bc9604ea0aba4367a8f2fbf2dbab8630aaaedcd3484b1c107bf7a3c81"}