{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n   *\\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n   * constructor.\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length \\u003e 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n    require(\\n      success,\\n      \\\"Address: unable to send value, recipient may have reverted\\\"\\n    );\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        \\\"Address: low-level call with value failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance \\u003e= value,\\n      \\\"Address: insufficient balance for call\\\"\\n    );\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return\\n      functionDelegateCall(\\n        target,\\n        data,\\n        \\\"Address: low-level delegate call failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length \\u003e 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"},\"AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n   *\\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n   * constructor.\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length \\u003e 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n    require(\\n      success,\\n      \\\"Address: unable to send value, recipient may have reverted\\\"\\n    );\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        \\\"Address: low-level call with value failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance \\u003e= value,\\n      \\\"Address: insufficient balance for call\\\"\\n    );\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length \\u003e 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"},\"ALP.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\nimport { ERC20Upgradeable } from \\\"./ERC20Upgradeable.sol\\\";\\nimport { OwnableUpgradeable } from \\\"./OwnableUpgradeable.sol\\\";\\n\\ncontract ALP is ERC20Upgradeable, OwnableUpgradeable {\\n  mapping(address =\\u003e bool) public whitelist;\\n  mapping(address =\\u003e uint256) public cooldown;\\n  mapping(address =\\u003e bool) public isMinter;\\n  uint256 public MAX_COOLDOWN_DURATION;\\n  uint256 public liquidityCooldown;\\n\\n  event ALP_SetWhitelist(address whitelisted, bool isActive);\\n  event ALP_SetMinter(address minter, bool prevAllow, bool newAllow);\\n  event ALP_SetLiquidityCooldown(uint256 oldCooldown, uint256 newCooldown);\\n\\n  error ALP_BadLiquidityCooldown(uint256 cooldown);\\n  error ALP_Cooldown(uint256 cooldownExpireAt);\\n  error ALP_NotMinter();\\n\\n  modifier onlyMinter() {\\n    if (!isMinter[msg.sender]) revert ALP_NotMinter();\\n    _;\\n  }\\n\\n  function initialize(uint256 liquidityCooldown_) external initializer {\\n    OwnableUpgradeable.__Ownable_init();\\n    ERC20Upgradeable.__ERC20_init(\\\"Alperp Liquidity Provider\\\", \\\"ALP\\\");\\n\\n    MAX_COOLDOWN_DURATION = 48 hours;\\n    liquidityCooldown = liquidityCooldown_;\\n  }\\n\\n  function setLiquidityCooldown(uint256 newLiquidityCooldown)\\n    external\\n    onlyOwner\\n  {\\n    if (newLiquidityCooldown \\u003e MAX_COOLDOWN_DURATION) {\\n      revert ALP_BadLiquidityCooldown(newLiquidityCooldown);\\n    }\\n    uint256 oldCooldown = liquidityCooldown;\\n    liquidityCooldown = newLiquidityCooldown;\\n    emit ALP_SetLiquidityCooldown(oldCooldown, newLiquidityCooldown);\\n  }\\n\\n  function setWhitelist(address whitelisted, bool isActive) external onlyOwner {\\n    whitelist[whitelisted] = isActive;\\n\\n    emit ALP_SetWhitelist(whitelisted, isActive);\\n  }\\n\\n  function setMinter(address minter, bool allow) external onlyOwner {\\n    isMinter[minter] = allow;\\n    emit ALP_SetMinter(minter, isMinter[minter], allow);\\n  }\\n\\n  function mint(address to, uint256 amount) public onlyMinter {\\n    cooldown[to] = block.timestamp + liquidityCooldown;\\n    _mint(to, amount);\\n  }\\n\\n  function burn(address from, uint256 amount) public onlyMinter {\\n    _burn(from, amount);\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal view override {\\n    if (whitelist[from] || whitelist[to]) return;\\n\\n    uint256 cooldownExpireAt = cooldown[from];\\n    if (amount \\u003e 0 \\u0026\\u0026 block.timestamp \\u003c cooldownExpireAt) {\\n      revert ALP_Cooldown(cooldownExpireAt);\\n    }\\n  }\\n}\\n\"},\"ChainLinkPriceFeedInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\ninterface ChainlinkPriceFeedInterface {\\n  function decimals() external view returns (uint8);\\n\\n  function getRoundData(uint80 roundId)\\n    external\\n    view\\n    returns (\\n      uint80,\\n      int256,\\n      uint256,\\n      uint256,\\n      uint80\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"},\"ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n  function __Context_init() internal onlyInitializing {}\\n\\n  function __Context_init_unchained() internal onlyInitializing {}\\n\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[50] private __gap;\\n}\\n\"},\"DiamondCutInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * \\\\\\n * Author: Nick Mudge(https://twitter.com/mudgen)\\n * EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n * /*****************************************************************************\\n */\\n\\ninterface DiamondCutInterface {\\n  enum FacetCutAction {\\n    Add,\\n    Replace,\\n    Remove\\n  }\\n  // Add=0, Replace=1, Remove=2\\n\\n  struct FacetCut {\\n    address facetAddress;\\n    FacetCutAction action;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"},\"draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account\\u0027s ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\\u0027t\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``\\u0027s tokens,\\n   * given ``owner``\\u0027s signed approval.\\n   *\\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n   * ordering also apply here.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `deadline` must be a timestamp in the future.\\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n   * over the EIP712-formatted function arguments.\\n   * - the signature must use ``owner``\\u0027s current nonce (see {nonces}).\\n   *\\n   * For more information on the signature format, see the\\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n   * section].\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n   * included whenever a signature is generated for {permit}.\\n   *\\n   * Every successful call to {permit} increases ``owner``\\u0027s nonce by one. This\\n   * prevents a signature from being used multiple times.\\n   */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"},\"ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"./ContextUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is\\n  Initializable,\\n  ContextUpgradeable,\\n  IERC20Upgradeable,\\n  IERC20MetadataUpgradeable\\n{\\n  mapping(address =\\u003e uint256) private _balances;\\n\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n\\n  /**\\n   * @dev Sets the values for {name} and {symbol}.\\n   *\\n   * The default value of {decimals} is 18. To select a different value for\\n   * {decimals} you should overload it.\\n   *\\n   * All two of these values are immutable: they can only be set once during\\n   * construction.\\n   */\\n  function __ERC20_init(string memory name_, string memory symbol_)\\n    internal\\n    onlyInitializing\\n  {\\n    __ERC20_init_unchained(name_, symbol_);\\n  }\\n\\n  function __ERC20_init_unchained(string memory name_, string memory symbol_)\\n    internal\\n    onlyInitializing\\n  {\\n    _name = name_;\\n    _symbol = symbol_;\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used to get its user representation.\\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n   *\\n   * Tokens usually opt for a value of 18, imitating the relationship between\\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n   * overridden;\\n   *\\n   * NOTE: This information is only used for _display_ purposes: it in\\n   * no way affects any of the arithmetic of the contract, including\\n   * {IERC20-balanceOf} and {IERC20-transfer}.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return 18;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-totalSupply}.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-balanceOf}.\\n   */\\n  function balanceOf(address account)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `to` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(address to, uint256 amount)\\n    public\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    address owner = _msgSender();\\n    _transfer(owner, to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-allowance}.\\n   */\\n  function allowance(address owner, address spender)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-approve}.\\n   *\\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(address spender, uint256 amount)\\n    public\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    address owner = _msgSender();\\n    _approve(owner, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transferFrom}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\n   * required by the EIP. See the note at the beginning of {ERC20}.\\n   *\\n   * NOTE: Does not update the allowance if the current allowance\\n   * is the maximum `uint256`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` and `to` cannot be the zero address.\\n   * - `from` must have a balance of at least `amount`.\\n   * - the caller must have allowance for ``from``\\u0027s tokens of at least\\n   * `amount`.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    address spender = _msgSender();\\n    _spendAllowance(from, spender, amount);\\n    _transfer(from, to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function increaseAllowance(address spender, uint256 addedValue)\\n    public\\n    virtual\\n    returns (bool)\\n  {\\n    address owner = _msgSender();\\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `spender` must have allowance for the caller of at least\\n   * `subtractedValue`.\\n   */\\n  function decreaseAllowance(address spender, uint256 subtractedValue)\\n    public\\n    virtual\\n    returns (bool)\\n  {\\n    address owner = _msgSender();\\n    uint256 currentAllowance = allowance(owner, spender);\\n    require(\\n      currentAllowance \\u003e= subtractedValue,\\n      \\\"ERC20: decreased allowance below zero\\\"\\n    );\\n    unchecked {\\n      _approve(owner, spender, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Moves `amount` of tokens from `from` to `to`.\\n   *\\n   * This internal function is equivalent to {transfer}, and can be used to\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\n   *\\n   * Emits a {Transfer} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `from` must have a balance of at least `amount`.\\n   */\\n  function _transfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {\\n    require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n    require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n    _beforeTokenTransfer(from, to, amount);\\n\\n    uint256 fromBalance = _balances[from];\\n    require(fromBalance \\u003e= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n    unchecked {\\n      _balances[from] = fromBalance - amount;\\n    }\\n    _balances[to] += amount;\\n\\n    emit Transfer(from, to, amount);\\n\\n    _afterTokenTransfer(from, to, amount);\\n  }\\n\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n   * the total supply.\\n   *\\n   * Emits a {Transfer} event with `from` set to the zero address.\\n   *\\n   * Requirements:\\n   *\\n   * - `account` cannot be the zero address.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n\\n    _afterTokenTransfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * Emits a {Transfer} event with `to` set to the zero address.\\n   *\\n   * Requirements:\\n   *\\n   * - `account` cannot be the zero address.\\n   * - `account` must have at least `amount` tokens.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance \\u003e= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n\\n    _afterTokenTransfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n   *\\n   * This internal function is equivalent to `approve`, and can be used to\\n   * e.g. set automatic allowances for certain subsystems, etc.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `spender` cannot be the zero address.\\n   */\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  /**\\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n   *\\n   * Does not update the allowance amount in case of infinite allowance.\\n   * Revert if not enough allowance is available.\\n   *\\n   * Might emit an {Approval} event.\\n   */\\n  function _spendAllowance(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    uint256 currentAllowance = allowance(owner, spender);\\n    if (currentAllowance != type(uint256).max) {\\n      require(currentAllowance \\u003e= amount, \\\"ERC20: insufficient allowance\\\");\\n      unchecked {\\n        _approve(owner, spender, currentAllowance - amount);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Hook that is called before any transfer of tokens. This includes\\n   * minting and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\n   * will be transferred to `to`.\\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\\n   * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\n   * - `from` and `to` are never both zero.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  /**\\n   * @dev Hook that is called after any transfer of tokens. This includes\\n   * minting and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\n   * has been transferred to `to`.\\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\\n   * - when `to` is zero, `amount` of ``from``\\u0027s tokens have been burned.\\n   * - `from` and `to` are never both zero.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _afterTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[45] private __gap;\\n}\\n\"},\"FarmFacetInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\nimport { StrategyInterface } from \\\"./StrategyInterface.sol\\\";\\n\\ninterface FarmFacetInterface {\\n  function farm(address token, bool isRebalanceNeeded) external;\\n\\n  function setStrategyOf(address token, StrategyInterface newStrategy) external;\\n\\n  function setStrategyTargetBps(address token, uint64 targetBps) external;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"},\"IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\"},\"IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"},\"Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"./AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\\u0027s common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   * @custom:oz-retyped-from bool\\n   */\\n  uint8 private _initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private _initializing;\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n   */\\n  event Initialized(uint8 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n   */\\n  modifier initializer() {\\n    bool isTopLevelCall = !_initializing;\\n    require(\\n      (isTopLevelCall \\u0026\\u0026 _initialized \\u003c 1) ||\\n        (!AddressUpgradeable.isContract(address(this)) \\u0026\\u0026 _initialized == 1),\\n      \\\"Initializable: contract is already initialized\\\"\\n    );\\n    _initialized = 1;\\n    if (isTopLevelCall) {\\n      _initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      _initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n   * contract hasn\\u0027t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n   * used to initialize parent contracts.\\n   *\\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\\n   * initialization.\\n   *\\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n   * a contract, executing them in the right order is up to the developer or operator.\\n   */\\n  modifier reinitializer(uint8 version) {\\n    require(\\n      !_initializing \\u0026\\u0026 _initialized \\u003c version,\\n      \\\"Initializable: contract is already initialized\\\"\\n    );\\n    _initialized = version;\\n    _initializing = true;\\n    _;\\n    _initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n   */\\n  modifier onlyInitializing() {\\n    require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n   * through proxies.\\n   */\\n  function _disableInitializers() internal virtual {\\n    require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n    if (_initialized \\u003c type(uint8).max) {\\n      _initialized = type(uint8).max;\\n      emit Initialized(type(uint8).max);\\n    }\\n  }\\n}\\n\"},\"ISecondaryPriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\ninterface ISecondaryPriceFeed {\\n  function getPrice(\\n    address _token,\\n    uint256 _referencePrice,\\n    bool _maximise\\n  ) external view returns (uint256);\\n}\\n\"},\"LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * \\\\\\n * Author: Nick Mudge \\u003cnick@perfectabstractions.com\\u003e (https://twitter.com/mudgen)\\n * EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n * /*****************************************************************************\\n */\\nimport { DiamondCutInterface } from \\\"./DiamondCutInterface.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nlibrary LibDiamond {\\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\\n    keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n  struct FacetAddressAndPosition {\\n    address facetAddress;\\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n  }\\n\\n  struct FacetFunctionSelectors {\\n    bytes4[] functionSelectors;\\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n  }\\n\\n  struct DiamondStorage {\\n    // maps function selector to the facet address and\\n    // the position of the selector in the facetFunctionSelectors.selectors array\\n    mapping(bytes4 =\\u003e FacetAddressAndPosition) selectorToFacetAndPosition;\\n    // maps facet addresses to function selectors\\n    mapping(address =\\u003e FacetFunctionSelectors) facetFunctionSelectors;\\n    // facet addresses\\n    address[] facetAddresses;\\n    // Used to query if a contract implements an interface.\\n    // Used to implement ERC-165.\\n    mapping(bytes4 =\\u003e bool) supportedInterfaces;\\n    // owner of the contract\\n    address contractOwner;\\n  }\\n\\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  function setContractOwner(address _newOwner) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    address previousOwner = ds.contractOwner;\\n    ds.contractOwner = _newOwner;\\n    emit OwnershipTransferred(previousOwner, _newOwner);\\n  }\\n\\n  function contractOwner() internal view returns (address contractOwner_) {\\n    contractOwner_ = diamondStorage().contractOwner;\\n  }\\n\\n  function enforceIsContractOwner() internal view {\\n    require(\\n      msg.sender == diamondStorage().contractOwner,\\n      \\\"LibDiamond: Must be contract owner\\\"\\n    );\\n  }\\n\\n  event DiamondCut(\\n    DiamondCutInterface.FacetCut[] _diamondCut,\\n    address _init,\\n    bytes _calldata\\n  );\\n\\n  // Internal function version of diamondCut\\n  function diamondCut(\\n    DiamondCutInterface.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    for (uint256 facetIndex; facetIndex \\u003c _diamondCut.length; facetIndex++) {\\n      DiamondCutInterface.FacetCutAction action = _diamondCut[facetIndex]\\n        .action;\\n      if (action == DiamondCutInterface.FacetCutAction.Add) {\\n        addFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else if (action == DiamondCutInterface.FacetCutAction.Replace) {\\n        replaceFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else if (action == DiamondCutInterface.FacetCutAction.Remove) {\\n        removeFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else {\\n        revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n      }\\n    }\\n    emit DiamondCut(_diamondCut, _init, _calldata);\\n    initializeDiamondCut(_init, _calldata);\\n  }\\n\\n  function addFunctions(\\n    address _facetAddress,\\n    bytes4[] memory _functionSelectors\\n  ) internal {\\n    require(\\n      _functionSelectors.length \\u003e 0,\\n      \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n    );\\n    DiamondStorage storage ds = diamondStorage();\\n    require(\\n      _facetAddress != address(0),\\n      \\\"LibDiamondCut: Add facet can\\u0027t be address(0)\\\"\\n    );\\n    uint96 selectorPosition = uint96(\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n    );\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (\\n      uint256 selectorIndex;\\n      selectorIndex \\u003c _functionSelectors.length;\\n      selectorIndex++\\n    ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds\\n        .selectorToFacetAndPosition[selector]\\n        .facetAddress;\\n      require(\\n        oldFacetAddress == address(0),\\n        \\\"LibDiamondCut: Can\\u0027t add function that already exists\\\"\\n      );\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function replaceFunctions(\\n    address _facetAddress,\\n    bytes4[] memory _functionSelectors\\n  ) internal {\\n    require(\\n      _functionSelectors.length \\u003e 0,\\n      \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n    );\\n    DiamondStorage storage ds = diamondStorage();\\n    require(\\n      _facetAddress != address(0),\\n      \\\"LibDiamondCut: Add facet can\\u0027t be address(0)\\\"\\n    );\\n    uint96 selectorPosition = uint96(\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n    );\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (\\n      uint256 selectorIndex;\\n      selectorIndex \\u003c _functionSelectors.length;\\n      selectorIndex++\\n    ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds\\n        .selectorToFacetAndPosition[selector]\\n        .facetAddress;\\n      require(\\n        oldFacetAddress != _facetAddress,\\n        \\\"LibDiamondCut: Can\\u0027t replace function with same function\\\"\\n      );\\n      removeFunction(ds, oldFacetAddress, selector);\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function removeFunctions(\\n    address _facetAddress,\\n    bytes4[] memory _functionSelectors\\n  ) internal {\\n    require(\\n      _functionSelectors.length \\u003e 0,\\n      \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n    );\\n    DiamondStorage storage ds = diamondStorage();\\n    // if function does not exist then do nothing and return\\n    require(\\n      _facetAddress == address(0),\\n      \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n    );\\n    for (\\n      uint256 selectorIndex;\\n      selectorIndex \\u003c _functionSelectors.length;\\n      selectorIndex++\\n    ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds\\n        .selectorToFacetAndPosition[selector]\\n        .facetAddress;\\n      removeFunction(ds, oldFacetAddress, selector);\\n    }\\n  }\\n\\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n    enforceHasContractCode(\\n      _facetAddress,\\n      \\\"LibDiamondCut: New facet has no code\\\"\\n    );\\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\\n      .facetAddresses\\n      .length;\\n    ds.facetAddresses.push(_facetAddress);\\n  }\\n\\n  function addFunction(\\n    DiamondStorage storage ds,\\n    bytes4 _selector,\\n    uint96 _selectorPosition,\\n    address _facetAddress\\n  ) internal {\\n    ds\\n      .selectorToFacetAndPosition[_selector]\\n      .functionSelectorPosition = _selectorPosition;\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n  }\\n\\n  function removeFunction(\\n    DiamondStorage storage ds,\\n    address _facetAddress,\\n    bytes4 _selector\\n  ) internal {\\n    require(\\n      _facetAddress != address(0),\\n      \\\"LibDiamondCut: Can\\u0027t remove function that doesn\\u0027t exist\\\"\\n    );\\n    // an immutable function is a function defined directly in a diamond\\n    require(\\n      _facetAddress != address(this),\\n      \\\"LibDiamondCut: Can\\u0027t remove immutable function\\\"\\n    );\\n    // replace selector with last selector, then delete last selector\\n    uint256 selectorPosition = ds\\n      .selectorToFacetAndPosition[_selector]\\n      .functionSelectorPosition;\\n    uint256 lastSelectorPosition = ds\\n      .facetFunctionSelectors[_facetAddress]\\n      .functionSelectors\\n      .length - 1;\\n    // if not the same then replace _selector with lastSelector\\n    if (selectorPosition != lastSelectorPosition) {\\n      bytes4 lastSelector = ds\\n        .facetFunctionSelectors[_facetAddress]\\n        .functionSelectors[lastSelectorPosition];\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n          selectorPosition\\n        ] = lastSelector;\\n      ds\\n        .selectorToFacetAndPosition[lastSelector]\\n        .functionSelectorPosition = uint96(selectorPosition);\\n    }\\n    // delete the last selector\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n    delete ds.selectorToFacetAndPosition[_selector];\\n\\n    // if no more selectors for facet address then delete the facet address\\n    if (lastSelectorPosition == 0) {\\n      // replace facet address with last facet address and delete last facet address\\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n      uint256 facetAddressPosition = ds\\n        .facetFunctionSelectors[_facetAddress]\\n        .facetAddressPosition;\\n      if (facetAddressPosition != lastFacetAddressPosition) {\\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n        ds\\n          .facetFunctionSelectors[lastFacetAddress]\\n          .facetAddressPosition = facetAddressPosition;\\n      }\\n      ds.facetAddresses.pop();\\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n    }\\n  }\\n\\n  function initializeDiamondCut(address _init, bytes memory _calldata)\\n    internal\\n  {\\n    if (_init == address(0)) {\\n      require(\\n        _calldata.length == 0,\\n        \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\n      );\\n    } else {\\n      require(\\n        _calldata.length \\u003e 0,\\n        \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\n      );\\n      if (_init != address(this)) {\\n        enforceHasContractCode(\\n          _init,\\n          \\\"LibDiamondCut: _init address has no code\\\"\\n        );\\n      }\\n      (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n      if (!success) {\\n        if (error.length \\u003e 0) {\\n          // bubble up the error\\n          revert(string(error));\\n        } else {\\n          revert(\\\"LibDiamondCut: _init function reverted\\\");\\n        }\\n      }\\n    }\\n  }\\n\\n  function enforceHasContractCode(\\n    address _contract,\\n    string memory _errorMessage\\n  ) internal view {\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_contract)\\n    }\\n    require(contractSize \\u003e 0, _errorMessage);\\n  }\\n}\\n\"},\"LibPoolConfigV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\npragma solidity 0.8.17;\\n\\nimport { LinkedList } from \\\"./LinkedList.sol\\\";\\nimport { StrategyInterface } from \\\"./StrategyInterface.sol\\\";\\n\\nlibrary LibPoolConfigV1 {\\n  using LinkedList for LinkedList.List;\\n\\n  // -------------\\n  //    Constants\\n  // -------------\\n  // keccak256(\\\"com.alperp.poolconfigv1.diamond.storage\\\")\\n  bytes32 internal constant POOL_CONFIG_V1_STORAGE_POSITION =\\n    0xe79957f8fffba58090b12475eb755fd4845e0679801ac2bc4f67d7ca9d26b3e8;\\n\\n  // -------------\\n  //    Storage\\n  // -------------\\n  struct TokenConfig {\\n    bool accept;\\n    bool isStable;\\n    bool isShortable;\\n    uint8 decimals;\\n    uint64 weight;\\n    uint64 minProfitBps;\\n    uint256 usdDebtCeiling;\\n    uint256 shortCeiling;\\n    uint256 bufferLiquidity;\\n    uint256 openInterestLongCeiling;\\n  }\\n\\n  struct StrategyData {\\n    uint64 startTimestamp;\\n    uint64 targetBps;\\n    uint128 principle;\\n  }\\n\\n  struct PoolConfigV1DiamondStorage {\\n    // --------\\n    // Treasury\\n    // --------\\n    address treasury;\\n    // --------------------\\n    // Token Configurations\\n    // --------------------\\n    LinkedList.List allowTokens;\\n    mapping(address =\\u003e TokenConfig) tokenMetas;\\n    uint256 totalTokenWeight;\\n    // --------------------------\\n    // Liquidation configurations\\n    // --------------------------\\n    /// @notice liquidation fee in USD with 1e30 precision\\n    uint256 liquidationFeeUsd;\\n    bool isAllowAllLiquidators;\\n    mapping(address =\\u003e bool) allowLiquidators;\\n    // -----------------------\\n    // Leverage configurations\\n    // -----------------------\\n    uint64 maxLeverage;\\n    // ---------------------------\\n    // Funding rate configurations\\n    // ---------------------------\\n    uint64 fundingInterval;\\n    uint64 stableBorrowingRateFactor;\\n    uint64 borrowingRateFactor;\\n    uint64 fundingRateFactor;\\n    // ----------------------\\n    // Fee bps configurations\\n    // ----------------------\\n    uint64 mintBurnFeeBps;\\n    uint64 taxBps;\\n    uint64 stableTaxBps;\\n    uint64 swapFeeBps;\\n    uint64 stableSwapFeeBps;\\n    uint64 positionFeeBps;\\n    uint64 flashLoanFeeBps;\\n    // -----\\n    // Misc.\\n    // -----\\n    uint64 minProfitDuration;\\n    bool isDynamicFeeEnable;\\n    bool isSwapEnable;\\n    bool isLeverageEnable;\\n    address router;\\n    // --------\\n    // Strategy\\n    // --------\\n    mapping(address =\\u003e StrategyInterface) strategyOf;\\n    mapping(address =\\u003e StrategyInterface) pendingStrategyOf;\\n    mapping(address =\\u003e StrategyData) strategyDataOf;\\n  }\\n\\n  function poolConfigV1DiamondStorage()\\n    internal\\n    pure\\n    returns (PoolConfigV1DiamondStorage storage poolConfigV1Ds)\\n  {\\n    assembly {\\n      poolConfigV1Ds.slot := POOL_CONFIG_V1_STORAGE_POSITION\\n    }\\n  }\\n\\n  function fundingInterval() internal view returns (uint256) {\\n    return poolConfigV1DiamondStorage().fundingInterval;\\n  }\\n\\n  function flashLoanFeeBps() internal view returns (uint256) {\\n    return poolConfigV1DiamondStorage().flashLoanFeeBps;\\n  }\\n\\n  function getAllowTokensLength() internal view returns (uint256) {\\n    return poolConfigV1DiamondStorage().allowTokens.size;\\n  }\\n\\n  function getNextAllowTokenOf(address token) internal view returns (address) {\\n    return poolConfigV1DiamondStorage().allowTokens.getNextOf(token);\\n  }\\n\\n  function getStrategyDelta(address token)\\n    internal\\n    view\\n    returns (bool, uint256)\\n  {\\n    // Load pool config diamond storage\\n    PoolConfigV1DiamondStorage\\n      storage poolConfigV1Ds = poolConfigV1DiamondStorage();\\n\\n    if (address(poolConfigV1Ds.strategyOf[token]) == address(0)) {\\n      return (false, 0);\\n    }\\n\\n    return\\n      poolConfigV1DiamondStorage().strategyOf[token].getStrategyDelta(\\n        poolConfigV1Ds.strategyDataOf[token].principle\\n      );\\n  }\\n\\n  function getTokenBufferLiquidityOf(address token)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].bufferLiquidity;\\n  }\\n\\n  function getTokenDecimalsOf(address token) internal view returns (uint8) {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].decimals;\\n  }\\n\\n  function getTokenMinProfitBpsOf(address token)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].minProfitBps;\\n  }\\n\\n  function getTokenWeightOf(address token) internal view returns (uint256) {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].weight;\\n  }\\n\\n  function getTokenUsdDebtCeilingOf(address token)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].usdDebtCeiling;\\n  }\\n\\n  function getTokenShortCeilingOf(address token)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].shortCeiling;\\n  }\\n\\n  function getTokenOpenInterestLongCeilingOf(address token)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return\\n      poolConfigV1DiamondStorage().tokenMetas[token].openInterestLongCeiling;\\n  }\\n\\n  function isAcceptToken(address token) internal view returns (bool) {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].accept;\\n  }\\n\\n  function isAllowedLiquidators(address liquidator)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    // Load PoolConfigV1 diamond storage\\n    PoolConfigV1DiamondStorage\\n      storage poolConfigV1Ds = poolConfigV1DiamondStorage();\\n\\n    return\\n      poolConfigV1Ds.isAllowAllLiquidators\\n        ? true\\n        : poolConfigV1Ds.allowLiquidators[liquidator];\\n  }\\n\\n  function isDynamicFeeEnable() internal view returns (bool) {\\n    return poolConfigV1DiamondStorage().isDynamicFeeEnable;\\n  }\\n\\n  function isLeverageEnable() internal view returns (bool) {\\n    return poolConfigV1DiamondStorage().isLeverageEnable;\\n  }\\n\\n  function isStableToken(address token) internal view returns (bool) {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].isStable;\\n  }\\n\\n  function isShortableToken(address token) internal view returns (bool) {\\n    return poolConfigV1DiamondStorage().tokenMetas[token].isShortable;\\n  }\\n\\n  function isSwapEnable() internal view returns (bool) {\\n    return poolConfigV1DiamondStorage().isSwapEnable;\\n  }\\n\\n  function liquidationFeeUsd() internal view returns (uint256) {\\n    return poolConfigV1DiamondStorage().liquidationFeeUsd;\\n  }\\n\\n  function maxLeverage() internal view returns (uint64) {\\n    return poolConfigV1DiamondStorage().maxLeverage;\\n  }\\n\\n  function strategyOf(address token) internal view returns (StrategyInterface) {\\n    return poolConfigV1DiamondStorage().strategyOf[token];\\n  }\\n\\n  function treasury() internal view returns (address) {\\n    return poolConfigV1DiamondStorage().treasury;\\n  }\\n}\\n\"},\"LibPoolV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\npragma solidity 0.8.17;\\n\\nimport { StrategyInterface } from \\\"./StrategyInterface.sol\\\";\\nimport { ALP } from \\\"./ALP.sol\\\";\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"./SafeERC20.sol\\\";\\nimport { SafeCast } from \\\"./SafeCast.sol\\\";\\nimport { PoolOracle } from \\\"./PoolOracle.sol\\\";\\nimport { FarmFacetInterface } from \\\"./FarmFacetInterface.sol\\\";\\nimport { LibPoolConfigV1 } from \\\"./LibPoolConfigV1.sol\\\";\\n\\nlibrary LibPoolV1 {\\n  using SafeERC20 for IERC20;\\n  using SafeCast for uint256;\\n\\n  error LibPoolV1_BadSubAccountId();\\n  error LibPoolV1_Forbidden();\\n  error LibPoolV1_LiquidityMismatch();\\n  error LibPoolV1_InsufficientLiquidity();\\n  error LibPoolV1_OverUsdDebtCeiling();\\n  error LibPoolV1_OverShortCeiling();\\n  error LibPoolV1_OverOpenInterestLongCeiling();\\n  error LibPoolV1_ForbiddenPlugin();\\n\\n  // -------------\\n  //   Constants\\n  // -------------\\n  // POOL_V1_STORAGE_POSITION = keccak256(\\\"com.alperp.poolv1.diamond.storage\\\")\\n  bytes32 internal constant POOL_V1_STORAGE_POSITION =\\n    0x08ea6422ce99418d00e8263f9b0197bfe0b74fd7e7dd9b1fcb2ad20910f18b27;\\n\\n  enum MinMax {\\n    MIN,\\n    MAX\\n  }\\n\\n  // -------------\\n  //    Storage\\n  // -------------\\n  struct Position {\\n    address primaryAccount;\\n    uint256 size;\\n    uint256 collateral; // collateral value in USD\\n    uint256 averagePrice;\\n    uint256 entryBorrowingRate;\\n    int256 entryFundingRate;\\n    uint256 reserveAmount;\\n    int256 realizedPnl;\\n    uint256 lastIncreasedTime;\\n    uint256 openInterest;\\n    int256 fundingFeeDebt;\\n  }\\n\\n  struct PoolV1DiamondStorage {\\n    // Dependent contracts\\n    ALP alp;\\n    PoolOracle oracle;\\n    // Liquidity\\n    mapping(address =\\u003e uint256) totalOf;\\n    mapping(address =\\u003e uint256) liquidityOf;\\n    mapping(address =\\u003e uint256) reservedOf;\\n    mapping(address =\\u003e uint256) sumBorrowingRateOf;\\n    mapping(address =\\u003e uint256) lastFundingTimeOf;\\n    // Short\\n    mapping(address =\\u003e uint256) shortSizeOf;\\n    mapping(address =\\u003e uint256) shortAveragePriceOf;\\n    // Fee\\n    mapping(address =\\u003e uint256) feeReserveOf;\\n    // Debt\\n    uint256 totalUsdDebt;\\n    mapping(address =\\u003e uint256) usdDebtOf;\\n    mapping(address =\\u003e uint256) guaranteedUsdOf;\\n    // AUM\\n    uint256 additionalAum;\\n    uint256 discountedAum;\\n    // Position\\n    mapping(bytes32 =\\u003e Position) positions;\\n    // Open Interests in token amount with that token decimals\\n    mapping(address =\\u003e uint256) openInterestLong;\\n    mapping(address =\\u003e uint256) openInterestShort;\\n    // Funding Rate\\n    mapping(address =\\u003e int256) accumFundingRateLong;\\n    mapping(address =\\u003e int256) accumFundingRateShort;\\n    // Funding Fee Accounting\\n    uint256 fundingFeePayable;\\n    uint256 fundingFeeReceivable;\\n    // Plugins\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) approvedPlugins;\\n    mapping(address =\\u003e bool) plugins;\\n  }\\n\\n  // -----------\\n  //   Events\\n  // -----------\\n  event DecreaseGuaranteedUsd(address token, uint256 amount);\\n  event DecreasePoolLiquidity(address token, uint256 amount);\\n  event DecreaseUsdDebt(address token, uint256 amount);\\n  event DecreaseReserved(address token, uint256 amount);\\n  event DecreaseShortSize(address token, uint256 amount);\\n  event IncreaseGuaranteedUsd(address token, uint256 amount);\\n  event IncreasePoolLiquidity(address token, uint256 amount);\\n  event IncreaseUsdDebt(address token, uint256 amount);\\n  event IncreaseReserved(address token, uint256 amount);\\n  event IncreaseShortSize(address token, uint256 amount);\\n  event SetPoolConfig(address prevPoolConfig, address newPoolConfig);\\n  event SetPoolOracle(address prevPoolOracle, address newPoolOracle);\\n  event IncreaseOpenInterest(bool isLong, address indexToken, uint256 value);\\n  event DecreaseOpenInterest(bool isLong, address indexToken, uint256 value);\\n  event StrategyDivest(address token, uint256 actualAmountIn);\\n\\n  function poolV1DiamondStorage()\\n    internal\\n    pure\\n    returns (PoolV1DiamondStorage storage poolV1ds)\\n  {\\n    assembly {\\n      poolV1ds.slot := POOL_V1_STORAGE_POSITION\\n    }\\n  }\\n\\n  function setALP(ALP newALP) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n    poolV1ds.alp = newALP;\\n  }\\n\\n  function setPoolOracle(PoolOracle newOracle) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n    emit SetPoolOracle(address(poolV1ds.oracle), address(newOracle));\\n    poolV1ds.oracle = newOracle;\\n  }\\n\\n  // --------------\\n  // Access Control\\n  // --------------\\n  function allowed(address account) internal view {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n    // Load PoolConfigV1 diamond storage\\n    LibPoolConfigV1.PoolConfigV1DiamondStorage\\n      storage poolConfigds = LibPoolConfigV1.poolConfigV1DiamondStorage();\\n\\n    if (account != msg.sender \\u0026\\u0026 poolConfigds.router != msg.sender) {\\n      if (!poolV1ds.plugins[msg.sender]) {\\n        revert LibPoolV1_ForbiddenPlugin();\\n      }\\n      if (!poolV1ds.approvedPlugins[account][msg.sender]) {\\n        revert LibPoolV1_Forbidden();\\n      }\\n    }\\n  }\\n\\n  // -----------------\\n  // Queries functions\\n  // -----------------\\n  function getPositionId(\\n    address account,\\n    address collateralToken,\\n    address indexToken,\\n    bool isLong\\n  ) internal pure returns (bytes32) {\\n    return\\n      keccak256(abi.encodePacked(account, collateralToken, indexToken, isLong));\\n  }\\n\\n  function getSubAccount(address primary, uint256 subAccountId)\\n    internal\\n    pure\\n    returns (address)\\n  {\\n    if (subAccountId \\u003e 255) revert LibPoolV1_BadSubAccountId();\\n    return address(uint160(primary) ^ uint160(subAccountId));\\n  }\\n\\n  // ------------------------------\\n  // Liquidity alteration functions\\n  // ------------------------------\\n\\n  function increasePoolLiquidity(address token, uint256 amount) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n    LibPoolConfigV1.PoolConfigV1DiamondStorage\\n      storage poolConfigDs = LibPoolConfigV1.poolConfigV1DiamondStorage();\\n\\n    LibPoolConfigV1.StrategyData memory strategyData = poolConfigDs\\n      .strategyDataOf[token];\\n\\n    poolV1ds.liquidityOf[token] += amount;\\n    if (\\n      IERC20(token).balanceOf(address(this)) + strategyData.principle \\u003c\\n      poolV1ds.liquidityOf[token]\\n    ) revert LibPoolV1_LiquidityMismatch();\\n    emit IncreasePoolLiquidity(token, amount);\\n  }\\n\\n  function decreasePoolLiquidity(address token, uint256 amount) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    poolV1ds.liquidityOf[token] -= amount;\\n    if (poolV1ds.liquidityOf[token] \\u003c poolV1ds.reservedOf[token]) {\\n      revert LibPoolV1_InsufficientLiquidity();\\n    }\\n    emit DecreasePoolLiquidity(token, amount);\\n  }\\n\\n  function increaseUsdDebt(address token, uint256 amount) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    poolV1ds.usdDebtOf[token] += amount;\\n\\n    // SLOAD\\n    uint256 newUsdDebt = poolV1ds.usdDebtOf[token];\\n    uint256 usdDebtCeiling = LibPoolConfigV1.getTokenUsdDebtCeilingOf(token);\\n\\n    if (usdDebtCeiling != 0) {\\n      if (newUsdDebt \\u003e usdDebtCeiling) revert LibPoolV1_OverUsdDebtCeiling();\\n    }\\n\\n    emit IncreaseUsdDebt(token, amount);\\n  }\\n\\n  function decreaseUsdDebt(address token, uint256 amount) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    uint256 usdDebt = poolV1ds.usdDebtOf[token];\\n    if (usdDebt \\u003c= amount) {\\n      poolV1ds.usdDebtOf[token] = 0;\\n      emit DecreaseUsdDebt(token, usdDebt);\\n      return;\\n    }\\n\\n    poolV1ds.usdDebtOf[token] = usdDebt - amount;\\n\\n    emit DecreaseUsdDebt(token, amount);\\n  }\\n\\n  function increaseReserved(address token, uint256 amount) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    poolV1ds.reservedOf[token] += amount;\\n    if (poolV1ds.reservedOf[token] \\u003e poolV1ds.liquidityOf[token]) {\\n      revert LibPoolV1_InsufficientLiquidity();\\n    }\\n    emit IncreaseReserved(token, amount);\\n  }\\n\\n  function decreaseReserved(address token, uint256 amount) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    poolV1ds.reservedOf[token] -= amount;\\n    emit DecreaseReserved(token, amount);\\n  }\\n\\n  function increaseGuaranteedUsd(address token, uint256 amountUsd) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    poolV1ds.guaranteedUsdOf[token] += amountUsd;\\n    emit IncreaseGuaranteedUsd(token, amountUsd);\\n  }\\n\\n  function decreaseGuaranteedUsd(address token, uint256 amountUsd) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    poolV1ds.guaranteedUsdOf[token] -= amountUsd;\\n    emit DecreaseGuaranteedUsd(token, amountUsd);\\n  }\\n\\n  function increaseShortSize(address token, uint256 amountUsd) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    // SLOAD\\n    uint256 shortCeiling = LibPoolConfigV1.getTokenShortCeilingOf(token);\\n    poolV1ds.shortSizeOf[token] += amountUsd;\\n\\n    if (shortCeiling != 0) {\\n      if (poolV1ds.shortSizeOf[token] \\u003e shortCeiling) {\\n        revert LibPoolV1_OverShortCeiling();\\n      }\\n    }\\n\\n    emit IncreaseShortSize(token, amountUsd);\\n  }\\n\\n  function decreaseShortSize(address token, uint256 amountUsd) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    uint256 shortSize = poolV1ds.shortSizeOf[token];\\n    if (amountUsd \\u003e shortSize) {\\n      poolV1ds.shortSizeOf[token] = 0;\\n      return;\\n    }\\n\\n    poolV1ds.shortSizeOf[token] -= amountUsd;\\n\\n    emit DecreaseShortSize(token, amountUsd);\\n  }\\n\\n  function updateTotalOf(address token) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n    poolV1ds.totalOf[token] = IERC20(token).balanceOf(address(this));\\n  }\\n\\n  // ------------------------------\\n  // Farmable liquidity alteration functions\\n  // ------------------------------\\n  function realizedFarmPnL(address token) internal {\\n    // Load PoolConfigV1 diamond storage\\n    LibPoolConfigV1.PoolConfigV1DiamondStorage\\n      storage poolConfigV1ds = LibPoolConfigV1.poolConfigV1DiamondStorage();\\n\\n    StrategyInterface strategy = poolConfigV1ds.strategyOf[token];\\n\\n    if (address(strategy) != address(0)) {\\n      FarmFacetInterface(address(this)).farm(token, false);\\n    }\\n  }\\n\\n  function tokenOut(\\n    address token,\\n    address to,\\n    uint256 amountOut\\n  ) internal {\\n    // Load PoolV1 diamond storage\\n    LibPoolV1.PoolV1DiamondStorage storage poolV1ds = LibPoolV1\\n      .poolV1DiamondStorage();\\n\\n    // Load PoolConfigV1 diamond storage\\n    LibPoolConfigV1.PoolConfigV1DiamondStorage\\n      storage poolConfigV1ds = LibPoolConfigV1.poolConfigV1DiamondStorage();\\n\\n    StrategyInterface strategy = poolConfigV1ds.strategyOf[token];\\n    uint256 balance = IERC20(token).balanceOf(address(this));\\n    uint256 feeReserve = poolV1ds.feeReserveOf[token];\\n    if (address(strategy) != address(0)) {\\n      // Find amountIn for strategy\\u0027s withdrawal\\n      uint256 amountIn;\\n      // If balance is not enough, need to withdraw from strategy\\n      // - If balance is not even enough for feeReserve, withdraw based on amountOut + extraAmount for the feeReserve\\n      // - If balance is enough for feeReserve, withdraw based on amountOut - balance excluded the feeReserve\\n      if (feeReserve \\u003e balance) {\\n        uint256 feeOut = feeReserve - balance;\\n        amountIn = amountOut + feeOut;\\n      } else if (balance - feeReserve \\u003c amountOut) {\\n        uint256 poolBalance = balance - feeReserve;\\n        amountIn = amountOut - poolBalance;\\n      }\\n\\n      // If amount to be withdrawn \\u003e 0, withdraw from strategy\\n      if (amountIn \\u003e 0) {\\n        // Handle when physical tokens in Pool \\u003c amountOut, then we need to withdraw from strategy.\\n        LibPoolConfigV1.StrategyData storage strategyData = poolConfigV1ds\\n          .strategyDataOf[token];\\n\\n        // Witthdraw funds from strategy\\n        uint256 actualAmountIn = strategy.withdraw(amountIn);\\n        // Update totalOf[token] to sync physical balance with pool state\\n        updateTotalOf(token);\\n\\n        // Update how much pool put in the strategy\\n        strategyData.principle -= actualAmountIn.toUint128();\\n      }\\n    }\\n\\n    pushTokens(token, to, amountOut);\\n  }\\n\\n  /// ---------------------------\\n  /// ERC20 interaction functions\\n  /// ---------------------------\\n\\n  function pullTokens(address token) internal returns (uint256) {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    uint256 prevBalance = poolV1ds.totalOf[token];\\n    uint256 nextBalance = IERC20(token).balanceOf(address(this));\\n\\n    poolV1ds.totalOf[token] = nextBalance;\\n\\n    return nextBalance - prevBalance;\\n  }\\n\\n  function pushTokens(\\n    address token,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    IERC20(token).safeTransfer(to, amount);\\n    poolV1ds.totalOf[token] = IERC20(token).balanceOf(address(this));\\n  }\\n\\n  /// --------------------\\n  /// Conversion functions\\n  /// --------------------\\n  function convertTokenDecimals(\\n    uint256 fromTokenDecimals,\\n    uint256 toTokenDecimals,\\n    uint256 amount\\n  ) internal pure returns (uint256) {\\n    return (amount * 10**toTokenDecimals) / 10**fromTokenDecimals;\\n  }\\n\\n  function convertUsde30ToTokens(\\n    address token,\\n    uint256 amountUsd,\\n    bool isUseMaxPrice\\n  ) internal view returns (uint256) {\\n    if (amountUsd == 0) return 0;\\n\\n    // Load PoolV1 diamond storage\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    return\\n      (amountUsd * (10**LibPoolConfigV1.getTokenDecimalsOf(token))) /\\n      poolV1ds.oracle.getPrice(token, isUseMaxPrice);\\n  }\\n\\n  function convertUsde30ToTokens(\\n    address token,\\n    int256 amountUsd,\\n    bool isUseMaxPrice\\n  ) internal view returns (int256) {\\n    if (amountUsd == 0) return 0;\\n\\n    // Load PoolV1 diamond storage\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    return\\n      (amountUsd * int256(10**LibPoolConfigV1.getTokenDecimalsOf(token))) /\\n      int256(poolV1ds.oracle.getPrice(token, isUseMaxPrice));\\n  }\\n\\n  function convertTokensToUsde30(\\n    address token,\\n    uint256 amountTokens,\\n    bool isUseMaxPrice\\n  ) internal view returns (uint256) {\\n    if (amountTokens == 0) return 0;\\n\\n    // Load PoolV1 diamond storage\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    return\\n      (amountTokens * poolV1ds.oracle.getPrice(token, isUseMaxPrice)) /\\n      (10**LibPoolConfigV1.getTokenDecimalsOf(token));\\n  }\\n\\n  function increaseOpenInterest(\\n    bool isLong,\\n    address indexToken,\\n    uint256 amount\\n  ) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    if (isLong) {\\n      poolV1ds.openInterestLong[indexToken] += amount;\\n      uint256 openInterestLongCeiling = LibPoolConfigV1\\n        .getTokenOpenInterestLongCeilingOf(indexToken);\\n      if (\\n        openInterestLongCeiling \\u003e 0 \\u0026\\u0026\\n        poolV1ds.openInterestLong[indexToken] \\u003e openInterestLongCeiling\\n      ) {\\n        revert LibPoolV1_OverOpenInterestLongCeiling();\\n      }\\n    } else {\\n      poolV1ds.openInterestShort[indexToken] += amount;\\n    }\\n    emit IncreaseOpenInterest(isLong, indexToken, amount);\\n  }\\n\\n  function decreaseOpenInterest(\\n    bool isLong,\\n    address indexToken,\\n    uint256 amount\\n  ) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    if (isLong) {\\n      poolV1ds.openInterestLong[indexToken] -= amount;\\n    } else {\\n      poolV1ds.openInterestShort[indexToken] -= amount;\\n    }\\n    emit DecreaseOpenInterest(isLong, indexToken, amount);\\n  }\\n\\n  function updateFundingFeeAccounting(int256 fundingFee) internal {\\n    PoolV1DiamondStorage storage poolV1ds = poolV1DiamondStorage();\\n\\n    if (fundingFee \\u003c 0) {\\n      poolV1ds.fundingFeeReceivable += uint256(-fundingFee);\\n    } else {\\n      poolV1ds.fundingFeePayable += uint256(fundingFee);\\n    }\\n\\n    if (poolV1ds.fundingFeeReceivable \\u003e 0 \\u0026\\u0026 poolV1ds.fundingFeePayable \\u003e 0) {\\n      if (poolV1ds.fundingFeeReceivable \\u003e poolV1ds.fundingFeePayable) {\\n        poolV1ds.fundingFeeReceivable -= poolV1ds.fundingFeePayable;\\n        poolV1ds.fundingFeePayable = 0;\\n      } else {\\n        poolV1ds.fundingFeePayable -= poolV1ds.fundingFeeReceivable;\\n        poolV1ds.fundingFeeReceivable = 0;\\n      }\\n    }\\n  }\\n}\\n\"},\"LibReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\nlibrary LibReentrancyGuard {\\n  error LibReentrancyGuard_ReentrantCall();\\n\\n  // -------------\\n  //    Constants\\n  // -------------\\n  // keccak256(\\\"com.alperp.reentrancyguard.diamond.storage\\\")\\n  bytes32 internal constant REENTRANCY_GUARD_STORAGE_POSITION =\\n    0x2fa1652744cd206d89d3e37a86d4d33cb54d0f086079f57f9749f40bf12e0ed9;\\n\\n  uint256 internal constant _NOT_ENTERED = 1;\\n  uint256 internal constant _ENTERED = 2;\\n\\n  // -------------\\n  //    Storage\\n  // -------------\\n  struct ReentrancyGuardDiamondStorage {\\n    uint256 status;\\n  }\\n\\n  function reentrancyGuardDiamondStorage()\\n    internal\\n    pure\\n    returns (ReentrancyGuardDiamondStorage storage reentrancyGuardDs)\\n  {\\n    assembly {\\n      reentrancyGuardDs.slot := REENTRANCY_GUARD_STORAGE_POSITION\\n    }\\n  }\\n\\n  function lock() internal {\\n    ReentrancyGuardDiamondStorage\\n      storage reentrancyGuardDs = reentrancyGuardDiamondStorage();\\n    if (reentrancyGuardDs.status == _ENTERED) {\\n      revert LibReentrancyGuard_ReentrantCall();\\n    }\\n\\n    reentrancyGuardDs.status = _ENTERED;\\n  }\\n\\n  function unlock() internal {\\n    ReentrancyGuardDiamondStorage\\n      storage reentrancyGuardDs = reentrancyGuardDiamondStorage();\\n    reentrancyGuardDs.status = _NOT_ENTERED;\\n  }\\n}\\n\"},\"LinkedList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\nlibrary LinkedList {\\n  error LinkedList_Existed();\\n  error LinkedList_NotExisted();\\n  error LinkedList_NotInitialized();\\n  error LinkedList_WrongPrev();\\n\\n  address internal constant START = address(1);\\n  address internal constant END = address(1);\\n  address internal constant EMPTY = address(0);\\n\\n  struct List {\\n    uint256 size;\\n    mapping(address =\\u003e address) next;\\n  }\\n\\n  function init(List storage list) internal returns (List storage) {\\n    list.next[START] = END;\\n    return list;\\n  }\\n\\n  function has(List storage list, address addr) internal view returns (bool) {\\n    return list.next[addr] != EMPTY;\\n  }\\n\\n  function add(List storage list, address addr)\\n    internal\\n    returns (List storage)\\n  {\\n    // Check\\n    if (has(list, addr)) revert LinkedList_Existed();\\n\\n    // Effect\\n    list.next[addr] = list.next[START];\\n    list.next[START] = addr;\\n    list.size++;\\n\\n    return list;\\n  }\\n\\n  function remove(\\n    List storage list,\\n    address addr,\\n    address prevAddr\\n  ) internal returns (List storage) {\\n    // Check\\n    if (!has(list, addr)) revert LinkedList_NotExisted();\\n    if (list.next[prevAddr] != addr) revert LinkedList_WrongPrev();\\n\\n    // Effect\\n    list.next[prevAddr] = list.next[addr];\\n    list.next[addr] = EMPTY;\\n    list.size--;\\n\\n    return list;\\n  }\\n\\n  function getAll(List storage list) internal view returns (address[] memory) {\\n    address[] memory addrs = new address[](list.size);\\n    address curr = list.next[START];\\n    for (uint256 i = 0; curr != END; i++) {\\n      addrs[i] = curr;\\n      curr = list.next[curr];\\n    }\\n    return addrs;\\n  }\\n\\n  function getPreviousOf(List storage list, address addr)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    address curr = list.next[START];\\n    if (curr == EMPTY) revert LinkedList_NotInitialized();\\n    for (uint256 i = 0; curr != END; i++) {\\n      if (list.next[curr] == addr) return curr;\\n      curr = list.next[curr];\\n    }\\n    return END;\\n  }\\n\\n  function getNextOf(List storage list, address curr)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return list.next[curr];\\n  }\\n\\n  function length(List storage list) internal view returns (uint256) {\\n    return list.size;\\n  }\\n}\\n\"},\"OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ContextUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  function __Ownable_init() internal onlyInitializing {\\n    __Ownable_init_unchained();\\n  }\\n\\n  function __Ownable_init_unchained() internal onlyInitializing {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[49] private __gap;\\n}\\n\"},\"PoolDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\npragma solidity 0.8.17;\\n\\nimport { PoolOracle } from \\\"./PoolOracle.sol\\\";\\nimport { ALP } from \\\"./ALP.sol\\\";\\n\\nimport { LibReentrancyGuard } from \\\"./LibReentrancyGuard.sol\\\";\\nimport { LibDiamond } from \\\"./LibDiamond.sol\\\";\\nimport { LibPoolV1 } from \\\"./LibPoolV1.sol\\\";\\nimport { DiamondCutInterface } from \\\"./DiamondCutInterface.sol\\\";\\n\\n/// @title Pool with ERC-2535 Diamond Standard.\\n/// Core logic of Diamond Standard is taken from https://github.com/mudgen/diamond-3-hardhat\\ncontract PoolDiamond {\\n  constructor(\\n    address diamondCutFacet,\\n    ALP alp,\\n    PoolOracle poolOracle\\n  ) payable {\\n    // Set contract owner\\n    LibDiamond.setContractOwner(msg.sender);\\n\\n    // Set LibPool dependencies\\n    LibPoolV1.setALP(alp);\\n    LibPoolV1.setPoolOracle(poolOracle);\\n\\n    // Set LibReentrancyGuard\\n    LibReentrancyGuard.unlock();\\n\\n    // Add the diamondCut external function from the diamondCutFacet\\n    DiamondCutInterface.FacetCut[]\\n      memory cut = new DiamondCutInterface.FacetCut[](1);\\n    bytes4[] memory functionSelectors = new bytes4[](1);\\n    functionSelectors[0] = DiamondCutInterface.diamondCut.selector;\\n    cut[0] = DiamondCutInterface.FacetCut({\\n      facetAddress: diamondCutFacet,\\n      action: DiamondCutInterface.FacetCutAction.Add,\\n      functionSelectors: functionSelectors\\n    });\\n    LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n  }\\n\\n  // Find facet for function that is called and execute the\\n  // function if a facet is found and return any value.\\n  fallback() external payable {\\n    LibDiamond.DiamondStorage storage ds;\\n    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n    // get diamond storage\\n    assembly {\\n      ds.slot := position\\n    }\\n    // get facet from function selector\\n    address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n    require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n    // Execute external function from facet using delegatecall and return any value.\\n    assembly {\\n      // copy function selector and any arguments\\n      calldatacopy(0, 0, calldatasize())\\n      // execute function call using the facet\\n      let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n      // get any return value\\n      returndatacopy(0, 0, returndatasize())\\n      // return any return value or error back to the caller\\n      switch result\\n      case 0 {\\n        revert(0, returndatasize())\\n      }\\n      default {\\n        return(0, returndatasize())\\n      }\\n    }\\n  }\\n\\n  receive() external payable {}\\n}\\n\"},\"PoolOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\npragma solidity 0.8.17;\\n\\nimport { OwnableUpgradeable } from \\\"./OwnableUpgradeable.sol\\\";\\nimport { SafeCast } from \\\"./SafeCast.sol\\\";\\nimport { ChainlinkPriceFeedInterface } from \\\"./ChainLinkPriceFeedInterface.sol\\\";\\nimport { ISecondaryPriceFeed } from \\\"./ISecondaryPriceFeed.sol\\\";\\n\\ncontract PoolOracle is OwnableUpgradeable {\\n  using SafeCast for int256;\\n\\n  error PoolOracle_BadArguments();\\n  error PoolOracle_PriceFeedNotAvailable();\\n  error PoolOracle_UnableFetchPrice();\\n\\n  uint256 internal constant PRICE_PRECISION = 10**30;\\n  uint256 internal constant ONE_USD = PRICE_PRECISION;\\n  uint256 internal constant BPS = 10000;\\n  address public secondaryPriceFeed;\\n  bool public isSecondaryPriceEnabled;\\n\\n  struct PriceFeedInfo {\\n    ChainlinkPriceFeedInterface priceFeed;\\n    uint8 decimals;\\n    uint64 spreadBps;\\n    bool isStrictStable;\\n  }\\n\\n  mapping(address =\\u003e PriceFeedInfo) public priceFeedInfo;\\n  uint80 public roundDepth;\\n  uint256 public maxStrictPriceDeviation;\\n\\n  event SetMaxStrictPriceDeviation(\\n    uint256 prevMaxStrictPriceDeviation,\\n    uint256 newMaxStrictPriceDeviation\\n  );\\n  event SetPriceFeed(\\n    address token,\\n    PriceFeedInfo prevPriceFeedInfo,\\n    PriceFeedInfo newPriceFeedInfo\\n  );\\n  event SetRoundDepth(uint80 prevRoundDepth, uint80 newRoundDepth);\\n  event SetSecondaryPriceFeed(\\n    address oldSecondaryPriceFeed,\\n    address newSecondaryPriceFeed\\n  );\\n  event SetIsSecondaryPriceEnabled(bool oldFlag, bool newFlag);\\n\\n  function initialize(uint80 _roundDepth) external initializer {\\n    OwnableUpgradeable.__Ownable_init();\\n\\n    if (_roundDepth \\u003c 2) revert PoolOracle_BadArguments();\\n    roundDepth = _roundDepth;\\n\\n    isSecondaryPriceEnabled = false;\\n  }\\n\\n  function setSecondaryPriceFeed(address newPriceFeed) external onlyOwner {\\n    emit SetSecondaryPriceFeed(secondaryPriceFeed, newPriceFeed);\\n    secondaryPriceFeed = newPriceFeed;\\n  }\\n\\n  function setIsSecondaryPriceEnabled(bool flag) external onlyOwner {\\n    emit SetIsSecondaryPriceEnabled(isSecondaryPriceEnabled, flag);\\n    isSecondaryPriceEnabled = flag;\\n  }\\n\\n  function _getPrice(address token, bool isUseMaxPrice)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    uint256 price = _getPrimaryPrice(token, isUseMaxPrice);\\n\\n    if (isSecondaryPriceEnabled) {\\n      price = getSecondaryPrice(token, price, isUseMaxPrice);\\n    }\\n\\n    // Handle strict stable price deviation.\\n    // SLOAD\\n    PriceFeedInfo memory priceFeed = priceFeedInfo[token];\\n    if (address(priceFeed.priceFeed) == address(0)) {\\n      revert PoolOracle_PriceFeedNotAvailable();\\n    }\\n    if (priceFeed.isStrictStable) {\\n      uint256 delta;\\n      unchecked {\\n        delta = price \\u003e ONE_USD ? price - ONE_USD : ONE_USD - price;\\n      }\\n\\n      if (delta \\u003c= maxStrictPriceDeviation) return ONE_USD;\\n\\n      if (isUseMaxPrice \\u0026\\u0026 price \\u003e ONE_USD) return price;\\n\\n      if (!isUseMaxPrice \\u0026\\u0026 price \\u003c ONE_USD) return price;\\n\\n      return ONE_USD;\\n    }\\n\\n    // Handle spreadBasisPoint\\n    if (isUseMaxPrice) return (price * (BPS + priceFeed.spreadBps)) / BPS;\\n\\n    return (price * (BPS - priceFeed.spreadBps)) / BPS;\\n  }\\n\\n  function _getPrimaryPrice(address token, bool isUseMaxPrice)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    // SLOAD\\n    PriceFeedInfo memory priceFeed = priceFeedInfo[token];\\n    if (address(priceFeed.priceFeed) == address(0)) {\\n      revert PoolOracle_PriceFeedNotAvailable();\\n    }\\n\\n    uint256 price = 0;\\n    int256 _priceCursor = 0;\\n    uint256 priceCursor = 0;\\n    (uint80 latestRoundId, int256 latestAnswer, , , ) = priceFeed\\n      .priceFeed\\n      .latestRoundData();\\n\\n    for (uint80 i = 0; i \\u003c roundDepth; i++) {\\n      if (i \\u003e= latestRoundId) break;\\n\\n      if (i == 0) {\\n        priceCursor = latestAnswer.toUint256();\\n      } else {\\n        (, _priceCursor, , , ) = priceFeed.priceFeed.getRoundData(\\n          latestRoundId - i\\n        );\\n        priceCursor = _priceCursor.toUint256();\\n      }\\n\\n      if (price == 0) {\\n        price = priceCursor;\\n        continue;\\n      }\\n\\n      if (isUseMaxPrice \\u0026\\u0026 price \\u003c priceCursor) {\\n        price = priceCursor;\\n        continue;\\n      }\\n\\n      if (!isUseMaxPrice \\u0026\\u0026 price \\u003e priceCursor) {\\n        price = priceCursor;\\n      }\\n    }\\n\\n    if (price == 0) revert PoolOracle_UnableFetchPrice();\\n    return (price * PRICE_PRECISION) / 10**priceFeed.decimals;\\n  }\\n\\n  function getSecondaryPrice(\\n    address _token,\\n    uint256 _referencePrice,\\n    bool _maximise\\n  ) public view returns (uint256) {\\n    if (secondaryPriceFeed == address(0)) {\\n      return _referencePrice;\\n    }\\n    return\\n      ISecondaryPriceFeed(secondaryPriceFeed).getPrice(\\n        _token,\\n        _referencePrice,\\n        _maximise\\n      );\\n  }\\n\\n  function getLatestPrimaryPrice(address token)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    // SLOAD\\n    PriceFeedInfo memory priceFeed = priceFeedInfo[token];\\n    if (address(priceFeed.priceFeed) == address(0)) {\\n      revert PoolOracle_PriceFeedNotAvailable();\\n    }\\n\\n    (, int256 price, , , ) = priceFeed.priceFeed.latestRoundData();\\n\\n    if (price == 0) revert PoolOracle_UnableFetchPrice();\\n\\n    return uint256(price);\\n  }\\n\\n  function getPrice(address token, bool isUseMaxPrice)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _getPrice(token, isUseMaxPrice);\\n  }\\n\\n  function getMaxPrice(address token) external view returns (uint256) {\\n    return _getPrice(token, true);\\n  }\\n\\n  function getMinPrice(address token) external view returns (uint256) {\\n    return _getPrice(token, false);\\n  }\\n\\n  function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation)\\n    external\\n    onlyOwner\\n  {\\n    emit SetMaxStrictPriceDeviation(\\n      maxStrictPriceDeviation,\\n      _maxStrictPriceDeviation\\n    );\\n    maxStrictPriceDeviation = _maxStrictPriceDeviation;\\n  }\\n\\n  function setPriceFeed(\\n    address[] calldata token,\\n    PriceFeedInfo[] calldata feedInfo\\n  ) external onlyOwner {\\n    if (token.length != feedInfo.length) revert PoolOracle_BadArguments();\\n\\n    for (uint256 i = 0; i \\u003c token.length; ) {\\n      emit SetPriceFeed(token[i], priceFeedInfo[token[i]], feedInfo[i]);\\n\\n      // Sanity check\\n      feedInfo[i].priceFeed.latestRoundData();\\n\\n      priceFeedInfo[token[i]] = feedInfo[i];\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  function setRoundDepth(uint80 _roundDepth) external onlyOwner {\\n    if (_roundDepth \\u003c 2) revert PoolOracle_BadArguments();\\n\\n    emit SetRoundDepth(roundDepth, _roundDepth);\\n    roundDepth = _roundDepth;\\n  }\\n\\n  /// @custom:oz-upgrades-unsafe-allow constructor\\n  constructor() {\\n    _disableInitializers();\\n  }\\n}\\n\"},\"SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n  /**\\n   * @dev Returns the downcasted uint248 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint248).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint248` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 248 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint248(uint256 value) internal pure returns (uint248) {\\n    require(\\n      value \\u003c= type(uint248).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 248 bits\\\"\\n    );\\n    return uint248(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint240 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint240).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint240` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 240 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint240(uint256 value) internal pure returns (uint240) {\\n    require(\\n      value \\u003c= type(uint240).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 240 bits\\\"\\n    );\\n    return uint240(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint232 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint232).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint232` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 232 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint232(uint256 value) internal pure returns (uint232) {\\n    require(\\n      value \\u003c= type(uint232).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 232 bits\\\"\\n    );\\n    return uint232(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint224 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint224).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint224` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 224 bits\\n   *\\n   * _Available since v4.2._\\n   */\\n  function toUint224(uint256 value) internal pure returns (uint224) {\\n    require(\\n      value \\u003c= type(uint224).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 224 bits\\\"\\n    );\\n    return uint224(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint216 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint216).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint216` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 216 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint216(uint256 value) internal pure returns (uint216) {\\n    require(\\n      value \\u003c= type(uint216).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 216 bits\\\"\\n    );\\n    return uint216(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint208 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint208).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint208` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 208 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint208(uint256 value) internal pure returns (uint208) {\\n    require(\\n      value \\u003c= type(uint208).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 208 bits\\\"\\n    );\\n    return uint208(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint200 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint200).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint200` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 200 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint200(uint256 value) internal pure returns (uint200) {\\n    require(\\n      value \\u003c= type(uint200).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 200 bits\\\"\\n    );\\n    return uint200(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint192 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint192).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint192` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 192 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint192(uint256 value) internal pure returns (uint192) {\\n    require(\\n      value \\u003c= type(uint192).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 192 bits\\\"\\n    );\\n    return uint192(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint184 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint184).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint184` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 184 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint184(uint256 value) internal pure returns (uint184) {\\n    require(\\n      value \\u003c= type(uint184).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 184 bits\\\"\\n    );\\n    return uint184(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint176 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint176).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint176` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 176 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint176(uint256 value) internal pure returns (uint176) {\\n    require(\\n      value \\u003c= type(uint176).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 176 bits\\\"\\n    );\\n    return uint176(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint168 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint168).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint168` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 168 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint168(uint256 value) internal pure returns (uint168) {\\n    require(\\n      value \\u003c= type(uint168).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 168 bits\\\"\\n    );\\n    return uint168(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint160 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint160).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint160` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 160 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint160(uint256 value) internal pure returns (uint160) {\\n    require(\\n      value \\u003c= type(uint160).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 160 bits\\\"\\n    );\\n    return uint160(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint152 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint152).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint152` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 152 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint152(uint256 value) internal pure returns (uint152) {\\n    require(\\n      value \\u003c= type(uint152).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 152 bits\\\"\\n    );\\n    return uint152(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint144 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint144).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint144` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 144 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint144(uint256 value) internal pure returns (uint144) {\\n    require(\\n      value \\u003c= type(uint144).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 144 bits\\\"\\n    );\\n    return uint144(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint136 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint136).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint136` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 136 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint136(uint256 value) internal pure returns (uint136) {\\n    require(\\n      value \\u003c= type(uint136).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 136 bits\\\"\\n    );\\n    return uint136(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint128 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint128).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint128` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 128 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint128(uint256 value) internal pure returns (uint128) {\\n    require(\\n      value \\u003c= type(uint128).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 128 bits\\\"\\n    );\\n    return uint128(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint120 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint120).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint120` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 120 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint120(uint256 value) internal pure returns (uint120) {\\n    require(\\n      value \\u003c= type(uint120).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 120 bits\\\"\\n    );\\n    return uint120(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint112 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint112).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint112` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 112 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint112(uint256 value) internal pure returns (uint112) {\\n    require(\\n      value \\u003c= type(uint112).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 112 bits\\\"\\n    );\\n    return uint112(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint104 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint104).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint104` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 104 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint104(uint256 value) internal pure returns (uint104) {\\n    require(\\n      value \\u003c= type(uint104).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 104 bits\\\"\\n    );\\n    return uint104(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint96 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint96).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint96` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 96 bits\\n   *\\n   * _Available since v4.2._\\n   */\\n  function toUint96(uint256 value) internal pure returns (uint96) {\\n    require(\\n      value \\u003c= type(uint96).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 96 bits\\\"\\n    );\\n    return uint96(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint88 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint88).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint88` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 88 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint88(uint256 value) internal pure returns (uint88) {\\n    require(\\n      value \\u003c= type(uint88).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 88 bits\\\"\\n    );\\n    return uint88(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint80 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint80).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint80` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 80 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint80(uint256 value) internal pure returns (uint80) {\\n    require(\\n      value \\u003c= type(uint80).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 80 bits\\\"\\n    );\\n    return uint80(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint72 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint72).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint72` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 72 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint72(uint256 value) internal pure returns (uint72) {\\n    require(\\n      value \\u003c= type(uint72).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 72 bits\\\"\\n    );\\n    return uint72(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint64 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint64).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint64` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 64 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint64(uint256 value) internal pure returns (uint64) {\\n    require(\\n      value \\u003c= type(uint64).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 64 bits\\\"\\n    );\\n    return uint64(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint56 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint56).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint56` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 56 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint56(uint256 value) internal pure returns (uint56) {\\n    require(\\n      value \\u003c= type(uint56).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 56 bits\\\"\\n    );\\n    return uint56(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint48 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint48).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint48` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 48 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint48(uint256 value) internal pure returns (uint48) {\\n    require(\\n      value \\u003c= type(uint48).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 48 bits\\\"\\n    );\\n    return uint48(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint40 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint40).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint40` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 40 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint40(uint256 value) internal pure returns (uint40) {\\n    require(\\n      value \\u003c= type(uint40).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 40 bits\\\"\\n    );\\n    return uint40(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint32 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint32).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint32` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 32 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint32(uint256 value) internal pure returns (uint32) {\\n    require(\\n      value \\u003c= type(uint32).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 32 bits\\\"\\n    );\\n    return uint32(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint24 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint24).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint24` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 24 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint24(uint256 value) internal pure returns (uint24) {\\n    require(\\n      value \\u003c= type(uint24).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 24 bits\\\"\\n    );\\n    return uint24(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint16 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint16).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint16` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 16 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint16(uint256 value) internal pure returns (uint16) {\\n    require(\\n      value \\u003c= type(uint16).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 16 bits\\\"\\n    );\\n    return uint16(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint8 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint8).\\n   *\\n   * Counterpart to Solidity\\u0027s `uint8` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 8 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint8(uint256 value) internal pure returns (uint8) {\\n    require(value \\u003c= type(uint8).max, \\\"SafeCast: value doesn\\u0027t fit in 8 bits\\\");\\n    return uint8(value);\\n  }\\n\\n  /**\\n   * @dev Converts a signed int256 into an unsigned uint256.\\n   *\\n   * Requirements:\\n   *\\n   * - input must be greater than or equal to 0.\\n   *\\n   * _Available since v3.0._\\n   */\\n  function toUint256(int256 value) internal pure returns (uint256) {\\n    require(value \\u003e= 0, \\\"SafeCast: value must be positive\\\");\\n    return uint256(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int248 from int256, reverting on\\n   * overflow (when the input is less than smallest int248 or\\n   * greater than largest int248).\\n   *\\n   * Counterpart to Solidity\\u0027s `int248` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 248 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt248(int256 value) internal pure returns (int248) {\\n    require(\\n      value \\u003e= type(int248).min \\u0026\\u0026 value \\u003c= type(int248).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 248 bits\\\"\\n    );\\n    return int248(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int240 from int256, reverting on\\n   * overflow (when the input is less than smallest int240 or\\n   * greater than largest int240).\\n   *\\n   * Counterpart to Solidity\\u0027s `int240` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 240 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt240(int256 value) internal pure returns (int240) {\\n    require(\\n      value \\u003e= type(int240).min \\u0026\\u0026 value \\u003c= type(int240).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 240 bits\\\"\\n    );\\n    return int240(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int232 from int256, reverting on\\n   * overflow (when the input is less than smallest int232 or\\n   * greater than largest int232).\\n   *\\n   * Counterpart to Solidity\\u0027s `int232` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 232 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt232(int256 value) internal pure returns (int232) {\\n    require(\\n      value \\u003e= type(int232).min \\u0026\\u0026 value \\u003c= type(int232).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 232 bits\\\"\\n    );\\n    return int232(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int224 from int256, reverting on\\n   * overflow (when the input is less than smallest int224 or\\n   * greater than largest int224).\\n   *\\n   * Counterpart to Solidity\\u0027s `int224` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 224 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt224(int256 value) internal pure returns (int224) {\\n    require(\\n      value \\u003e= type(int224).min \\u0026\\u0026 value \\u003c= type(int224).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 224 bits\\\"\\n    );\\n    return int224(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int216 from int256, reverting on\\n   * overflow (when the input is less than smallest int216 or\\n   * greater than largest int216).\\n   *\\n   * Counterpart to Solidity\\u0027s `int216` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 216 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt216(int256 value) internal pure returns (int216) {\\n    require(\\n      value \\u003e= type(int216).min \\u0026\\u0026 value \\u003c= type(int216).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 216 bits\\\"\\n    );\\n    return int216(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int208 from int256, reverting on\\n   * overflow (when the input is less than smallest int208 or\\n   * greater than largest int208).\\n   *\\n   * Counterpart to Solidity\\u0027s `int208` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 208 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt208(int256 value) internal pure returns (int208) {\\n    require(\\n      value \\u003e= type(int208).min \\u0026\\u0026 value \\u003c= type(int208).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 208 bits\\\"\\n    );\\n    return int208(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int200 from int256, reverting on\\n   * overflow (when the input is less than smallest int200 or\\n   * greater than largest int200).\\n   *\\n   * Counterpart to Solidity\\u0027s `int200` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 200 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt200(int256 value) internal pure returns (int200) {\\n    require(\\n      value \\u003e= type(int200).min \\u0026\\u0026 value \\u003c= type(int200).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 200 bits\\\"\\n    );\\n    return int200(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int192 from int256, reverting on\\n   * overflow (when the input is less than smallest int192 or\\n   * greater than largest int192).\\n   *\\n   * Counterpart to Solidity\\u0027s `int192` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 192 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt192(int256 value) internal pure returns (int192) {\\n    require(\\n      value \\u003e= type(int192).min \\u0026\\u0026 value \\u003c= type(int192).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 192 bits\\\"\\n    );\\n    return int192(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int184 from int256, reverting on\\n   * overflow (when the input is less than smallest int184 or\\n   * greater than largest int184).\\n   *\\n   * Counterpart to Solidity\\u0027s `int184` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 184 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt184(int256 value) internal pure returns (int184) {\\n    require(\\n      value \\u003e= type(int184).min \\u0026\\u0026 value \\u003c= type(int184).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 184 bits\\\"\\n    );\\n    return int184(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int176 from int256, reverting on\\n   * overflow (when the input is less than smallest int176 or\\n   * greater than largest int176).\\n   *\\n   * Counterpart to Solidity\\u0027s `int176` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 176 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt176(int256 value) internal pure returns (int176) {\\n    require(\\n      value \\u003e= type(int176).min \\u0026\\u0026 value \\u003c= type(int176).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 176 bits\\\"\\n    );\\n    return int176(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int168 from int256, reverting on\\n   * overflow (when the input is less than smallest int168 or\\n   * greater than largest int168).\\n   *\\n   * Counterpart to Solidity\\u0027s `int168` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 168 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt168(int256 value) internal pure returns (int168) {\\n    require(\\n      value \\u003e= type(int168).min \\u0026\\u0026 value \\u003c= type(int168).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 168 bits\\\"\\n    );\\n    return int168(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int160 from int256, reverting on\\n   * overflow (when the input is less than smallest int160 or\\n   * greater than largest int160).\\n   *\\n   * Counterpart to Solidity\\u0027s `int160` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 160 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt160(int256 value) internal pure returns (int160) {\\n    require(\\n      value \\u003e= type(int160).min \\u0026\\u0026 value \\u003c= type(int160).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 160 bits\\\"\\n    );\\n    return int160(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int152 from int256, reverting on\\n   * overflow (when the input is less than smallest int152 or\\n   * greater than largest int152).\\n   *\\n   * Counterpart to Solidity\\u0027s `int152` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 152 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt152(int256 value) internal pure returns (int152) {\\n    require(\\n      value \\u003e= type(int152).min \\u0026\\u0026 value \\u003c= type(int152).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 152 bits\\\"\\n    );\\n    return int152(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int144 from int256, reverting on\\n   * overflow (when the input is less than smallest int144 or\\n   * greater than largest int144).\\n   *\\n   * Counterpart to Solidity\\u0027s `int144` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 144 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt144(int256 value) internal pure returns (int144) {\\n    require(\\n      value \\u003e= type(int144).min \\u0026\\u0026 value \\u003c= type(int144).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 144 bits\\\"\\n    );\\n    return int144(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int136 from int256, reverting on\\n   * overflow (when the input is less than smallest int136 or\\n   * greater than largest int136).\\n   *\\n   * Counterpart to Solidity\\u0027s `int136` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 136 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt136(int256 value) internal pure returns (int136) {\\n    require(\\n      value \\u003e= type(int136).min \\u0026\\u0026 value \\u003c= type(int136).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 136 bits\\\"\\n    );\\n    return int136(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int128 from int256, reverting on\\n   * overflow (when the input is less than smallest int128 or\\n   * greater than largest int128).\\n   *\\n   * Counterpart to Solidity\\u0027s `int128` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 128 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt128(int256 value) internal pure returns (int128) {\\n    require(\\n      value \\u003e= type(int128).min \\u0026\\u0026 value \\u003c= type(int128).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 128 bits\\\"\\n    );\\n    return int128(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int120 from int256, reverting on\\n   * overflow (when the input is less than smallest int120 or\\n   * greater than largest int120).\\n   *\\n   * Counterpart to Solidity\\u0027s `int120` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 120 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt120(int256 value) internal pure returns (int120) {\\n    require(\\n      value \\u003e= type(int120).min \\u0026\\u0026 value \\u003c= type(int120).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 120 bits\\\"\\n    );\\n    return int120(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int112 from int256, reverting on\\n   * overflow (when the input is less than smallest int112 or\\n   * greater than largest int112).\\n   *\\n   * Counterpart to Solidity\\u0027s `int112` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 112 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt112(int256 value) internal pure returns (int112) {\\n    require(\\n      value \\u003e= type(int112).min \\u0026\\u0026 value \\u003c= type(int112).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 112 bits\\\"\\n    );\\n    return int112(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int104 from int256, reverting on\\n   * overflow (when the input is less than smallest int104 or\\n   * greater than largest int104).\\n   *\\n   * Counterpart to Solidity\\u0027s `int104` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 104 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt104(int256 value) internal pure returns (int104) {\\n    require(\\n      value \\u003e= type(int104).min \\u0026\\u0026 value \\u003c= type(int104).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 104 bits\\\"\\n    );\\n    return int104(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int96 from int256, reverting on\\n   * overflow (when the input is less than smallest int96 or\\n   * greater than largest int96).\\n   *\\n   * Counterpart to Solidity\\u0027s `int96` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 96 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt96(int256 value) internal pure returns (int96) {\\n    require(\\n      value \\u003e= type(int96).min \\u0026\\u0026 value \\u003c= type(int96).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 96 bits\\\"\\n    );\\n    return int96(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int88 from int256, reverting on\\n   * overflow (when the input is less than smallest int88 or\\n   * greater than largest int88).\\n   *\\n   * Counterpart to Solidity\\u0027s `int88` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 88 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt88(int256 value) internal pure returns (int88) {\\n    require(\\n      value \\u003e= type(int88).min \\u0026\\u0026 value \\u003c= type(int88).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 88 bits\\\"\\n    );\\n    return int88(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int80 from int256, reverting on\\n   * overflow (when the input is less than smallest int80 or\\n   * greater than largest int80).\\n   *\\n   * Counterpart to Solidity\\u0027s `int80` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 80 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt80(int256 value) internal pure returns (int80) {\\n    require(\\n      value \\u003e= type(int80).min \\u0026\\u0026 value \\u003c= type(int80).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 80 bits\\\"\\n    );\\n    return int80(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int72 from int256, reverting on\\n   * overflow (when the input is less than smallest int72 or\\n   * greater than largest int72).\\n   *\\n   * Counterpart to Solidity\\u0027s `int72` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 72 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt72(int256 value) internal pure returns (int72) {\\n    require(\\n      value \\u003e= type(int72).min \\u0026\\u0026 value \\u003c= type(int72).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 72 bits\\\"\\n    );\\n    return int72(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int64 from int256, reverting on\\n   * overflow (when the input is less than smallest int64 or\\n   * greater than largest int64).\\n   *\\n   * Counterpart to Solidity\\u0027s `int64` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 64 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt64(int256 value) internal pure returns (int64) {\\n    require(\\n      value \\u003e= type(int64).min \\u0026\\u0026 value \\u003c= type(int64).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 64 bits\\\"\\n    );\\n    return int64(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int56 from int256, reverting on\\n   * overflow (when the input is less than smallest int56 or\\n   * greater than largest int56).\\n   *\\n   * Counterpart to Solidity\\u0027s `int56` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 56 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt56(int256 value) internal pure returns (int56) {\\n    require(\\n      value \\u003e= type(int56).min \\u0026\\u0026 value \\u003c= type(int56).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 56 bits\\\"\\n    );\\n    return int56(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int48 from int256, reverting on\\n   * overflow (when the input is less than smallest int48 or\\n   * greater than largest int48).\\n   *\\n   * Counterpart to Solidity\\u0027s `int48` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 48 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt48(int256 value) internal pure returns (int48) {\\n    require(\\n      value \\u003e= type(int48).min \\u0026\\u0026 value \\u003c= type(int48).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 48 bits\\\"\\n    );\\n    return int48(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int40 from int256, reverting on\\n   * overflow (when the input is less than smallest int40 or\\n   * greater than largest int40).\\n   *\\n   * Counterpart to Solidity\\u0027s `int40` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 40 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt40(int256 value) internal pure returns (int40) {\\n    require(\\n      value \\u003e= type(int40).min \\u0026\\u0026 value \\u003c= type(int40).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 40 bits\\\"\\n    );\\n    return int40(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int32 from int256, reverting on\\n   * overflow (when the input is less than smallest int32 or\\n   * greater than largest int32).\\n   *\\n   * Counterpart to Solidity\\u0027s `int32` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 32 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt32(int256 value) internal pure returns (int32) {\\n    require(\\n      value \\u003e= type(int32).min \\u0026\\u0026 value \\u003c= type(int32).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 32 bits\\\"\\n    );\\n    return int32(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int24 from int256, reverting on\\n   * overflow (when the input is less than smallest int24 or\\n   * greater than largest int24).\\n   *\\n   * Counterpart to Solidity\\u0027s `int24` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 24 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt24(int256 value) internal pure returns (int24) {\\n    require(\\n      value \\u003e= type(int24).min \\u0026\\u0026 value \\u003c= type(int24).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 24 bits\\\"\\n    );\\n    return int24(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int16 from int256, reverting on\\n   * overflow (when the input is less than smallest int16 or\\n   * greater than largest int16).\\n   *\\n   * Counterpart to Solidity\\u0027s `int16` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 16 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt16(int256 value) internal pure returns (int16) {\\n    require(\\n      value \\u003e= type(int16).min \\u0026\\u0026 value \\u003c= type(int16).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 16 bits\\\"\\n    );\\n    return int16(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int8 from int256, reverting on\\n   * overflow (when the input is less than smallest int8 or\\n   * greater than largest int8).\\n   *\\n   * Counterpart to Solidity\\u0027s `int8` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 8 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt8(int256 value) internal pure returns (int8) {\\n    require(\\n      value \\u003e= type(int8).min \\u0026\\u0026 value \\u003c= type(int8).max,\\n      \\\"SafeCast: value doesn\\u0027t fit in 8 bits\\\"\\n    );\\n    return int8(value);\\n  }\\n\\n  /**\\n   * @dev Converts an unsigned uint256 into a signed int256.\\n   *\\n   * Requirements:\\n   *\\n   * - input must be less than or equal to maxInt256.\\n   *\\n   * _Available since v3.0._\\n   */\\n  function toInt256(uint256 value) internal pure returns (int256) {\\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n    require(\\n      value \\u003c= uint256(type(int256).max),\\n      \\\"SafeCast: value doesn\\u0027t fit in an int256\\\"\\n    );\\n    return int256(value);\\n  }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./draft-IERC20Permit.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n   * {IERC20-approve}, and its usage is discouraged.\\n   *\\n   * Whenever possible, use {safeIncreaseAllowance} and\\n   * {safeDecreaseAllowance} instead.\\n   */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      require(\\n        oldAllowance \\u003e= value,\\n        \\\"SafeERC20: decreased allowance below zero\\\"\\n      );\\n      uint256 newAllowance = oldAllowance - value;\\n      _callOptionalReturn(\\n        token,\\n        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n      );\\n    }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n    // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(\\n      data,\\n      \\\"SafeERC20: low-level call failed\\\"\\n    );\\n    if (returndata.length \\u003e 0) {\\n      // Return data is optional\\n      require(\\n        abi.decode(returndata, (bool)),\\n        \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n      );\\n    }\\n  }\\n}\\n\"},\"StrategyInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n *   \u2229~~~~\u2229\\n *   \u03be \uff65\u00d7\uff65 \u03be\\n *   \u03be\u3000~\u3000\u03be\\n *   \u03be\u3000\u3000 \u03be\\n *   \u03be\u3000\u3000 \u201c~\uff5e~\uff5e\u3007\\n *   \u03be\u3000\u3000\u3000\u3000\u3000\u3000 \u03be\\n *   \u03be \u03be \u03be~\uff5e~\u03be \u03be \u03be\\n * \u3000 \u03be_\u03be\u03be_\u03be\u3000\u03be_\u03be\u03be_\u03be\\n * Alpaca Fin Corporation\\n */\\n\\npragma solidity 0.8.17;\\n\\ninterface StrategyInterface {\\n  /// @notice Send the tokens to the strategy and call run to perform the actual strategy logic\\n  function run(uint256 amount) external;\\n\\n  /// @notice Realized any profits/losses and send them to the caller.\\n  /// @param principle The amount of tokens that Pool thinks the strategy has\\n  function realized(uint256 principle) external returns (int256 amountDelta);\\n\\n  /// @notice Withdraw tokens from the strategy.\\n  function withdraw(uint256 amount) external returns (uint256 actualAmount);\\n\\n  /// @notice Withdraw all tokens from the strategy.\\n  /// @param principle The amount of tokens that Pool thinks the strategy has\\n  function exit(uint256 principle) external returns (int256 amountDelta);\\n\\n  function getStrategyDelta(uint256 principle)\\n    external\\n    view\\n    returns (bool isProfit, uint256 amountDelta);\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"diamondCutFacet\",\"type\":\"address\"},{\"internalType\":\"contract ALP\",\"name\":\"alp\",\"type\":\"address\"},{\"internalType\":\"contract PoolOracle\",\"name\":\"poolOracle\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PoolDiamond", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "000000000000000000000000fe3cb354e80f209088f854c6a10b7afe1d0dac5100000000000000000000000086a0384836bd6fd6ad7da9ebba0f330300a6b2a80000000000000000000000009fd00faef95cc028bc343bac1fc11e870635b974", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x976537d5e8bf201d313ed2590302563c9437954b", "SwarmSource": "ipfs://93afcc8900859838836ebe63ebf806d33f94ae3251980300ebbea1e1db7e3681"}