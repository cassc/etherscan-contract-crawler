{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: Tokensale.sol\r\n\r\n\r\npragma solidity ^0.8.19;\r\n\r\n\r\ninterface IPriceFeed {\r\n    function latestAnswer() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint256);\r\n}\r\n\r\ncontract TokenSale {\r\n    address public priceFeed ;\r\n    struct User {\r\n        uint256 levelIncome;\r\n        uint256 referralIncome;\r\n        address referrer;\r\n        bool tokensReceived;\r\n        uint256 nextWithdrawnTime;\r\n    }\r\n\r\n    uint256 private levelsIncome = 500 ether;\r\n    bool public isWithdrawEnabled = false;\r\n    address public owner;\r\n\r\n    mapping(address => User) public users;\r\n    IERC20 public token;\r\n\r\n    uint256 price = 6 ether;\r\n    uint256 tokenToBeSent = 5000 ether;\r\n    uint256 withdrawTime = 30 days;\r\n\r\n    constructor(\r\n        uint256 _price,\r\n        address _priceFeed,\r\n        IERC20 _token\r\n    ) {\r\n        price = _price;\r\n        priceFeed = _priceFeed;\r\n        token = _token;\r\n        owner = msg.sender;\r\n        users[msg.sender].referrer = address(0);\r\n    }\r\n\r\n    function setToken(IERC20 newToken) external {\r\n        require(msg.sender == owner, \"You are not an owner\");\r\n        token = newToken;\r\n    }\r\n\r\n    function setPrice(uint256 newPrice) external {\r\n        require(msg.sender == owner, \"You are not an owner\");\r\n        price = newPrice;\r\n    }\r\n\r\n    function enableWithdraw() external {\r\n        require(msg.sender == owner, \"You are not an owner\");\r\n        isWithdrawEnabled = true;\r\n    }\r\n\r\n    function buyToken(address _referrer) external payable {\r\n        require(msg.sender != _referrer, \"caller cannot be referrer\");\r\n        require(_referrer != address(0), \"referrer must be original account\");\r\n    require(users[_referrer].tokensReceived==true || _referrer==owner, \"Referrer should buy tokens first\");\r\n        if (msg.value < getAmountToBePaid()) {\r\n            revert(\"Amount should be greater or equal to price\");\r\n        }\r\n\r\n        users[msg.sender] = User({\r\n            levelIncome: 0,\r\n            referralIncome: 0,\r\n            referrer: _referrer,\r\n            tokensReceived: true,\r\n            nextWithdrawnTime: block.timestamp\r\n        });\r\n\r\n        token.transfer(_referrer, levelsIncome);\r\n        users[_referrer].referralIncome =\r\n            users[_referrer].referralIncome +\r\n            levelsIncome;\r\n        address ref = _referrer;\r\n        for (uint256 i = 0; i < 9; i++) {\r\n            if (ref == address(0)) break;\r\n            ref = users[ref].referrer;\r\n            users[ref].levelIncome = users[ref].levelIncome + levelsIncome;\r\n        }\r\n        token.transfer(msg.sender, tokenToBeSent);\r\n        // if (msg.value > getAmountToBePaid()) {\r\n        //     payable(msg.sender).transfer(msg.value - getAmountToBePaid());\r\n        // }\r\n    }\r\n\r\n    function getAmountToBePaid() public view returns (uint256) {\r\n        uint256 _price = IPriceFeed(priceFeed).latestAnswer();\r\n        uint256 priceOfUsd = (price * 1e8) / _price;\r\n        return priceOfUsd;\r\n    }\r\n\r\n    function withdrawLevelIncome() external {\r\n        require(\r\n            token.balanceOf(address(this)) >= users[msg.sender].levelIncome,\r\n            \"Contract don't have sufficient tokens\"\r\n        );\r\n        require(\r\n            block.timestamp >= users[msg.sender].nextWithdrawnTime,\r\n            \"Withraw can be done after 30 days\"\r\n        );\r\n        require(isWithdrawEnabled, \"Withdrawing token is not allowed by owner\");\r\n        if (users[msg.sender].levelIncome > 0) {\r\n            token.transfer(msg.sender, users[msg.sender].levelIncome / 10);\r\n            users[msg.sender].levelIncome =\r\n                users[msg.sender].levelIncome -\r\n                users[msg.sender].levelIncome /\r\n                10;\r\n            users[msg.sender].nextWithdrawnTime =\r\n                block.timestamp +\r\n                withdrawTime;\r\n        }\r\n    }\r\n\r\n    function withdrawDumpedtokens(IERC20 _token) external {\r\n        require(msg.sender == owner, \"You are not an owner\");\r\n        require(\r\n            _token.balanceOf(address(this)) > 0,\r\n            \"No token balance available\"\r\n        );\r\n        _token.transfer(msg.sender, _token.balanceOf(address(this)));\r\n    }\r\n\r\n  function WithdrawBNB(address receiver) external  {\r\n      require(msg.sender == owner, \"You are not an owner\");\r\n    payable(receiver).transfer(address(this).balance);\r\n  }\r\n\r\n    function setWithdrawTime(uint256 newTime) external payable {\r\n        require(msg.sender == owner, \"You are not an owner\");\r\n        withdrawTime = newTime;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"WithdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAmountToBePaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWithdrawEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"setWithdrawTime\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"levelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralIncome\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"tokensReceived\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdrawnTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawDumpedtokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLevelIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenSale", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000053444835ec5800000000000000000000000000000567f2323251f0aab15c8dfb1967e4e8a7d42aee00000000000000000000000033854f5f98ccc9ee7507539c807950d8c1a0dae2", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://38c8067e3d1ab284a69bd4adacf87c7ecce54c1c0ec2ff2c038b501316ac7f84"}