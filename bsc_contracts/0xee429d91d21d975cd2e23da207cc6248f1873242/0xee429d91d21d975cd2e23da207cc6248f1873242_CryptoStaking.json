{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Resources/IContractsLibraryV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"./IUniswapV2Router02.sol\\\";\\n\\nabstract contract IContractsLibraryV2 {\\n    function BUSD() external view virtual returns (address);\\n\\n    function WBNB() external view virtual returns (address);\\n\\n    function ROUTER() external view virtual returns (IUniswapV2Router02);\\n\\n    function getBusdToBNBToToken(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getTokensToBNBtoBusd(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getTokensToBnb(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getBnbToTokens(\\n        address token,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getTokenToBnbToAltToken(\\n        address token,\\n        address altToken,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getLpPrice(\\n        address token,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getUsdToBnB(uint amount) external view virtual returns (uint256);\\n\\n    function getBnbToUsd(uint amount) external view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Resources/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/Resources/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/stakingV3/CryptoStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../Resources/IContractsLibraryV2.sol\\\";\\nimport \\\"./StakingState.sol\\\";\\n\\ncontract CryptoStaking  is StakingState, ReentrancyGuard, Ownable {\\n    IContractsLibraryV2 public contractsLibrary;\\n    // PERCENT_DIVIDER = 10_000; // 10_000 = 100%, 1_000 = 10%, 100 = 1%, 10 = 0.1%, 1 = 0.01%\\n    mapping(address => RefData) public referrers;\\n\\n    uint public constant minPool = 1;\\n    uint public poolsLength = 0;\\n    uint public flatFee;\\n    uint public devFee;\\n    mapping(uint => mapping(address => UserInfo)) public users;\\n\\n    mapping(address => uint) public lastBlock;\\n    mapping(uint => Pool) public pools;\\n\\n    modifier enoughFee() {\\n        require(msg.value >= flatFee, \\\"Flat fee\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _library,\\n        address _token,\\n        address _devFeeWallet,\\n        address _oWallet,\\n        address _proyectWallet\\n    ) Ownable(msg.sender) {\\n        contractsLibrary = IContractsLibraryV2(_library);\\n        devFeeWallet = _devFeeWallet;\\n        oWallet = _oWallet;\\n        proyectWallet = _proyectWallet;\\n        flatFee = 0.0047 ether;\\n        devFee = 1_000;\\n        FORCE_WITHDRAW_FEE = 50_000;\\n        referrer_is_allowed = true;\\n\\n        // 30 d\u00edas 0.125% diario reinvets 24h+  -1 \\n        // 45 dias 0.25% diario reinvets 24h+ -2\\n        // 60 d\u00edas 0.375% diario reinvets 24h+ -3\\n        // 90 d\u00edas 0.5% diario reinvets 24h+ -4\\n        // 120 d\u00edas 0.625% diario reinvets 24h+ -5\\n        // 150 d\u00edas 0.75% diario reinvets 24h+ -6\\n        // 180 d\u00edas 0.875% diario reinvets 12h+ -7\\n        // 360 d\u00edas 1% diario reinvets 6h+ -8\\n        // PERCENT_DIVIDER = 100_000; // 100_000 = 100%, 10_000 = 10%, 1_000 = 1%, 100 = 0.1%, 10 = 0.01%, 1 = 0.001%\\n        uint defaultFee = 6_000;\\n        pools[1] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 125,\\n            fee: defaultFee,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 2,\\n            isActived: true\\n        });\\n\\n        pools[2] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 250,\\n            fee: defaultFee,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 3,\\n            isActived: true\\n        });\\n\\n        pools[3] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 375,\\n            fee: defaultFee,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 4,\\n            isActived: true\\n        });\\n\\n        pools[4] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 500,\\n            fee: defaultFee,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 6,\\n            isActived: true\\n        });\\n\\n        pools[5] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 625,\\n            fee: defaultFee,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 8,\\n            isActived: true\\n        });\\n\\n        pools[6] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 750,\\n            fee: defaultFee,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 10,\\n            isActived: true\\n        });\\n\\n        pools[7] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 875,\\n            fee: defaultFee,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 12,\\n            isActived: true\\n        });\\n\\n        pools[8] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 1_000,\\n            fee: defaultFee,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 24,\\n            isActived: true\\n        });\\n\\n        poolsLength = 8;\\n    }\\n\\n    function setoWallet(address _oWallet) external onlyOwner {\\n        oWallet = _oWallet;\\n    }\\n\\n    function setmWallet(address _mWallet) external onlyOwner {\\n        oWallet = _mWallet;\\n    }\\n\\n    function setdevFeeWallet(address _devFeeWallet) external onlyOwner {\\n        devFeeWallet = _devFeeWallet;\\n    }\\n\\n    function stopProduction() external onlyOwner {\\n        stopProductionVar = true;\\n        stopProductionDate = block.timestamp;\\n    }\\n\\n    function unpause() external whenPaused onlyOwner {\\n        initDate = block.timestamp;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    function setReferrerIsAllowed(\\n        bool _referrer_is_allowed\\n    ) external onlyOwner {\\n        referrer_is_allowed = _referrer_is_allowed;\\n    }\\n\\n    modifier tenBlocks() {\\n        require(block.number - lastBlock[msg.sender] > 10, \\\"wait 10 blocks\\\");\\n        _;\\n        lastBlock[msg.sender] = block.number;\\n    }\\n\\n    function isContract(address addr) internal view returns (bool) {\\n        uint size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    modifier isNotContract() {\\n        require(!isContract(msg.sender), \\\"contract not allowed\\\");\\n        _;\\n    }\\n\\n    function invest(\\n        uint _pool,\\n        uint amount,\\n        address _referrer\\n    )\\n        external\\n        payable\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        payFee();\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        UserInfo storage user = users[_pool][msg.sender];\\n        Pool memory pool = pools[_pool];\\n        require(pool.isActived, \\\"Pool is not actived\\\");\\n        if (pool.rquirePool > 0) {\\n            require(\\n                users[pool.rquirePool][msg.sender].totalDeposit >=\\n                    pool.requireAmount,\\n                \\\"Require amount\\\"\\n            );\\n        }\\n        if (pool.minimumDeposit > 0) {\\n            require(amount >= pool.minimumDeposit, \\\"Minimum deposit\\\");\\n        }\\n\\n        IERC20(pool.token).transferFrom(msg.sender, address(this), amount);\\n\\n        RefData storage refData = referrers[msg.sender];\\n        if (!refData.exists) {\\n            refData.exists = true;\\n            totalUsers++;\\n            emit Newbie(msg.sender);\\n            if (\\n                refData.referrer == address(0) &&\\n                _referrer != address(0) &&\\n                _referrer != msg.sender &&\\n                msg.sender != referrers[_referrer].referrer\\n            ) {\\n                refData.referrer = _referrer;\\n            }\\n        }\\n\\n        if (referrer_is_allowed && refData.referrer != address(0)) {\\n            uint refAmount = (amount * pool.referrerPercent) / PERCENT_DIVIDER;\\n            referrers[refData.referrer].amount += refAmount;\\n            IERC20(pools[_pool].token).transfer(refData.referrer, refAmount);\\n            emit RefBonus(refData.referrer, msg.sender, 1, refAmount);\\n        }\\n\\n        if (user.user == address(0)) {\\n            user.user = msg.sender;\\n            investors[_pool][totalUsers] = msg.sender;\\n        }\\n        updateDeposit(msg.sender, _pool);\\n\\n        users[_pool][msg.sender].investment += amount;\\n\\n        if (pool.token == pool.rewardToken) {\\n            users[_pool][msg.sender].stakingValue += amount;\\n        } else if (pool.rewardToken == address(0)) {\\n            users[_pool][msg.sender].stakingValue += contractsLibrary\\n                .getTokensToBnb(pool.token, amount);\\n        } else {\\n            users[_pool][msg.sender].stakingValue += contractsLibrary\\n                .getTokenToBnbToAltToken(pool.token, pool.rewardToken, amount);\\n        }\\n        users[_pool][msg.sender].totalDeposit += amount;\\n\\n        totalInvested[_pool] += amount;\\n        totalDeposits[_pool]++;\\n\\n        if (user.nextWithdraw == 0) {\\n            user.nextWithdraw = block.timestamp + HARVEST_DELAY;\\n        }\\n\\n        user.unlockDate = block.timestamp + pool.blockTimeStep;\\n\\n        emit NewDeposit(msg.sender, amount);\\n    }\\n\\n    function payToUser(uint _pool, bool _withdraw) internal {\\n        require(userCanwithdraw(msg.sender, _pool), \\\"User cannot withdraw\\\");\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        require(pools[_pool].isActived, \\\"Pool is not actived\\\");\\n        updateDeposit(msg.sender, _pool);\\n        uint fromVault;\\n        if (_withdraw) {\\n            require(\\n                block.timestamp >= users[_pool][msg.sender].unlockDate,\\n                \\\"Token is locked\\\"\\n            );\\n            fromVault = users[_pool][msg.sender].investment;\\n            delete users[_pool][msg.sender].investment;\\n            delete users[_pool][msg.sender].stakingValue;\\n            delete users[_pool][msg.sender].nextWithdraw;\\n        } else {\\n            users[_pool][msg.sender].nextWithdraw =\\n                block.timestamp +\\n                HARVEST_DELAY;\\n        }\\n        uint formThis = users[_pool][msg.sender].rewardLockedUp;\\n        delete users[_pool][msg.sender].rewardLockedUp;\\n        if (fromVault > 0) {\\n            require(\\n                IERC20(pools[_pool].token).balanceOf(address(this)) >=\\n                    fromVault,\\n                \\\"Not enough tokens in contract\\\"\\n            );\\n            IERC20(pools[_pool].token).transfer(msg.sender, fromVault);\\n        }\\n\\n        totalWithdrawn[_pool] += formThis;\\n        users[_pool][msg.sender].totalWithdrawn += formThis;\\n        address tokenReward = pools[_pool].rewardToken;\\n        Pool memory pool = pools[_pool];\\n\\n        uint _fee;\\n        uint toDev;\\n        uint toOwallet;\\n        uint toProyect;\\n        if (pool.fee > 0) {\\n            _fee = (formThis * pool.fee) / PERCENT_DIVIDER;\\n            toDev = _fee / 6;\\n            toOwallet = _fee / 3;\\n            toProyect = _fee - toDev - toOwallet;\\n        }\\n        require(\\n            IERC20(tokenReward).balanceOf(address(this)) >= formThis,\\n            \\\"Not enough tokens in contract\\\"\\n        );\\n\\n        if (tokenReward == address(0)) {\\n            payable(oWallet).transfer(toOwallet);\\n            payable(proyectWallet).transfer(toProyect);\\n            payable(devFeeWallet).transfer(toDev);\\n            payable(msg.sender).transfer(formThis - _fee);\\n        } else {\\n            IERC20(tokenReward).transfer(oWallet, toOwallet);\\n            IERC20(tokenReward).transfer(proyectWallet, toProyect);\\n            IERC20(tokenReward).transfer(devFeeWallet, toDev);\\n            IERC20(tokenReward).transfer(msg.sender, formThis - _fee);\\n        }\\n\\n        emit FeePayed(msg.sender, _fee);\\n        emit Withdrawn(msg.sender, formThis);\\n    }\\n\\n    function harvest(\\n        uint _pool\\n    )\\n        external\\n        payable\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        payFee();\\n        payToUser(_pool, false);\\n    }\\n\\n    function withdraw(\\n        uint _pool\\n    )\\n        external\\n        payable\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        payFee();\\n        payToUser(_pool, true);\\n    }\\n\\n    function reinvest(\\n        uint _pool\\n    )\\n        external\\n        payable\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        payFee();\\n        require(userCanwithdraw(msg.sender, _pool), \\\"User cannot withdraw\\\");\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        require(pools[_pool].isActived, \\\"Pool is not actived\\\");\\n        updateDeposit(msg.sender, _pool);\\n        users[_pool][msg.sender].nextWithdraw = block.timestamp + HARVEST_DELAY;\\n        uint pending = users[_pool][msg.sender].rewardLockedUp;\\n        delete users[_pool][msg.sender].rewardLockedUp;\\n        users[_pool][msg.sender].stakingValue += pending;\\n        Pool memory pool = pools[_pool];\\n        users[_pool][msg.sender].unlockDate =\\n            block.timestamp +\\n            pool.blockTimeStep;\\n        if (pool.rewardToken != address(0) && pool.token == pool.rewardToken) {\\n            users[_pool][msg.sender].investment += pending;\\n        }\\n        emit Reinvestment(msg.sender, pending);\\n    }\\n\\n    function forceWithdraw(\\n        uint _pool\\n    ) external nonReentrant whenNotPaused tenBlocks isNotContract {\\n        payFee();\\n        require(userCanwithdraw(msg.sender, _pool), \\\"User cannot withdraw\\\");\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        require(\\n            block.timestamp >= users[_pool][msg.sender].unlockDate,\\n            \\\"Token is locked\\\"\\n        );\\n        uint toTransfer = users[_pool][msg.sender].investment;\\n        delete users[_pool][msg.sender].rewardLockedUp;\\n        delete users[_pool][msg.sender].investment;\\n        delete users[_pool][msg.sender].stakingValue;\\n        delete users[_pool][msg.sender].nextWithdraw;\\n        delete users[_pool][msg.sender].unlockDate;\\n        users[_pool][msg.sender].totalWithdrawn += toTransfer;\\n        delete users[_pool][msg.sender].depositCheckpoint;\\n        totalWithdrawn[_pool] += toTransfer;\\n        require(\\n            IERC20(pools[_pool].token).balanceOf(address(this)) >= toTransfer,\\n            \\\"Not enough tokens in contract\\\"\\n        );\\n\\n        uint _fee;\\n        uint toDev;\\n        uint toOwallet;\\n        uint toProyect;\\n        if (FORCE_WITHDRAW_FEE > 0) {\\n            _fee = (toTransfer * FORCE_WITHDRAW_FEE) / PERCENT_DIVIDER;\\n            toDev = _fee / 6;\\n            toOwallet = _fee / 3;\\n            toProyect = _fee - toDev - toOwallet;\\n        }\\n\\n        IERC20(pools[_pool].token).transfer(oWallet, toOwallet);\\n        IERC20(pools[_pool].token).transfer(proyectWallet, toProyect);\\n        IERC20(pools[_pool].token).transfer(devFeeWallet, toDev);\\n        IERC20(pools[_pool].token).transfer(msg.sender, toTransfer - _fee);\\n    }\\n\\n    function getReward(\\n        uint _weis,\\n        uint _seconds,\\n        uint _pool\\n    ) public view returns (uint) {\\n        return\\n            (_weis * _seconds * pools[_pool].roi) /\\n            (TIME_STEP * PERCENT_DIVIDER);\\n    }\\n\\n    function userCanwithdraw(\\n        address user,\\n        uint _pool\\n    ) public view returns (bool) {\\n        if (block.timestamp > users[_pool][user].nextWithdraw) {\\n            if (users[_pool][user].stakingValue > 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function getDeltaPendingRewards(\\n        address _user,\\n        uint _pool\\n    ) public view returns (uint) {\\n        if (users[_pool][_user].depositCheckpoint == 0) {\\n            return 0;\\n        }\\n        uint time = block.timestamp;\\n        if (stopProductionDate > 0 && time > stopProductionDate) {\\n            time = stopProductionDate;\\n        }\\n        return\\n            getReward(\\n                users[_pool][_user].stakingValue,\\n                time - users[_pool][_user].depositCheckpoint,\\n                _pool\\n            );\\n    }\\n\\n    function getUserTotalPendingRewards(\\n        address _user,\\n        uint _pool\\n    ) public view returns (uint) {\\n        return\\n            users[_pool][_user].rewardLockedUp +\\n            getDeltaPendingRewards(_user, _pool);\\n    }\\n\\n    function updateDeposit(address _user, uint _pool) internal {\\n        users[_pool][_user].rewardLockedUp = getUserTotalPendingRewards(\\n            _user,\\n            _pool\\n        );\\n        users[_pool][_user].depositCheckpoint = block.timestamp;\\n    }\\n\\n    function getUser(\\n        address _user,\\n        uint _pool\\n    ) external view returns (UserInfo memory userInfo_, uint pendingRewards) {\\n        userInfo_ = users[_pool][_user];\\n        pendingRewards = getUserTotalPendingRewards(_user, _pool);\\n    }\\n\\n    function getAllUsers(uint _pool) external view returns (UserInfo[] memory) {\\n        UserInfo[] memory result = new UserInfo[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            result[i] = users[_pool][investors[_pool][i]];\\n        }\\n        return result;\\n    }\\n\\n    function getUserByIndex(\\n        uint _pool,\\n        uint _index\\n    ) external view returns (UserInfo memory) {\\n        require(_index < totalUsers, \\\"Index out of bounds\\\");\\n        return users[_pool][investors[_pool][_index]];\\n    }\\n\\n    function addPool(\\n        address _token,\\n        address _rewardToken,\\n        uint _minimumDeposit,\\n        uint roi,\\n        uint _fee,\\n        uint _referrerPercent,\\n        uint _requirePool,\\n        uint _requireAmount,\\n        uint _blockDuration\\n    ) external onlyOwner {\\n        poolsLength++;\\n        pools[poolsLength] = Pool({\\n            token: _token,\\n            rewardToken: _rewardToken,\\n            minimumDeposit: _minimumDeposit,\\n            roi: roi,\\n            fee: _fee,\\n            referrerPercent: _referrerPercent,\\n            rquirePool: _requirePool,\\n            requireAmount: _requireAmount,\\n            blockTimeStep: _blockDuration,\\n            isActived: true\\n        });\\n    }\\n\\n    function changeFee(uint _pool, uint _fee) external onlyOwner {\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        pools[_pool].fee = _fee;\\n    }\\n\\n    function setRefPercent(uint _pool, uint _percent) external onlyOwner {\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        require(_percent < PERCENT_DIVIDER, \\\"Invalid percent\\\");\\n        pools[_pool].referrerPercent = _percent;\\n    }\\n\\n    function setPoolStatus(uint _pool, bool _isActive) external onlyOwner {\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        pools[_pool].isActived = _isActive;\\n    }\\n\\n    fallback() external payable {}\\n\\n    receive() external payable {}\\n\\n    function takeBNB() external onlyOwner {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function takeTokens(address _token, uint _bal) external onlyOwner {\\n        IERC20(_token).transfer(msg.sender, _bal);\\n    }\\n\\n    function setDevFee(uint256 _devFee) external onlyOwner {\\n        require(_devFee <= PERCENT_DIVIDER, \\\"flat fee exceeds 100%\\\");\\n        devFee = _devFee;\\n    }\\n\\n    function setFlatFee(uint256 _flatFee) external onlyOwner {\\n        flatFee = _flatFee;\\n    }\\n\\n    function payFee() internal enoughFee {\\n        if (flatFee > 0) {\\n            uint256 devFeeAmount = (flatFee * devFee) / PERCENT_DIVIDER;\\n            uint256 feeAmount = flatFee - devFeeAmount;\\n            payable(oWallet).transfer(feeAmount);\\n            payable(devFeeWallet).transfer(devFeeAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/stakingV3/Istaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ninterface Istaking {\\n    struct Pool {\\n        address token;\\n        address rewardToken;\\n        uint minimumDeposit;\\n        uint roi;\\n        uint fee;\\n        uint referrerPercent;\\n        uint rquirePool;\\n        uint requireAmount;\\n        uint blockTimeStep;\\n        bool isActived;\\n    }\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        address user;\\n        address referrer;\\n        uint investment;\\n        uint stakingValue;\\n        uint rewardLockedUp;\\n        uint totalDeposit;\\n        uint totalWithdrawn;\\n        uint nextWithdraw;\\n        uint unlockDate;\\n        uint depositCheckpoint;\\n        uint busdTotalDeposit;\\n    }\\n\\n    struct RefData {\\n        address referrer;\\n        uint amount;\\n        bool exists;\\n    }\\n\\n    event Newbie(address user);\\n    event NewDeposit(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RefBonus(\\n        address indexed referrer,\\n        address indexed referral,\\n        uint256 indexed level,\\n        uint256 amount\\n    );\\n    event FeePayed(address indexed user, uint256 totalAmount);\\n    event Reinvestment(address indexed user, uint256 amount);\\n    event ForceWithdraw(address indexed user, uint256 amount);\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/stakingV3/StakingState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"./Istaking.sol\\\";\\n\\ncontract StakingState is Istaking {\\n    address public devFeeWallet;\\n    address public oWallet;\\n    address public proyectWallet;\\n    mapping(uint => mapping(uint => address)) public investors;\\n    uint public constant TIME_STEP = 1 days;\\n    uint public constant HARVEST_DELAY = TIME_STEP;\\n    uint public constant BLOCK_TIME_STEP = 15 * TIME_STEP;\\n    uint public constant PERCENT_DIVIDER = 100_000;\\n    uint public constant REFERRER_PERCENTS = 5_000;\\n    uint public FORCE_WITHDRAW_FEE;\\n\\n    uint public initDate;\\n\\n    uint public totalUsers;\\n    mapping(uint => uint) public totalInvested;\\n    mapping(uint => uint) public totalWithdrawn;\\n    mapping(uint => uint) public totalReinvested;\\n    mapping(uint => uint) public totalDeposits;\\n    mapping(uint => uint) public totalReinvestCount;\\n    uint public stopProductionDate;\\n    bool public stopProductionVar;\\n    bool public referrer_is_allowed;\\n\\n    modifier hasStoppedProduction() {\\n        require(hasStoppedProductionView(), \\\"Production is not stopped\\\");\\n        _;\\n    }\\n\\n    modifier hasNotStoppedProduction() {\\n        require(!hasStoppedProductionView(), \\\"Production is stopped\\\");\\n        _;\\n    }\\n\\n    function hasStoppedProductionView() public view returns (bool) {\\n        return stopProductionVar;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(initDate > 0, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(initDate == 0, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    function isPaused() public view returns (bool) {\\n        return initDate == 0;\\n    }\\n\\n    function getDAte() external view returns (uint) {\\n        return block.timestamp;\\n    }\\n\\n    function getPublicData(uint _pool)\\n        external\\n        view\\n        returns (\\n            uint totalUsers_,\\n            uint totalInvested_,\\n            uint totalDeposits_,\\n            uint totalReinvested_,\\n            uint totalReinvestCount_,\\n            uint totalWithdrawn_,\\n            bool isPaused_\\n        )\\n    {\\n        totalUsers_ = totalUsers;\\n        totalInvested_ = totalInvested[_pool];\\n        totalDeposits_ = totalDeposits[_pool];\\n        totalReinvested_ = totalReinvested[_pool];\\n        totalReinvestCount_ = totalReinvestCount[_pool];\\n        totalWithdrawn_ = totalWithdrawn[_pool];\\n        isPaused_ = isPaused();\\n    }\\n\\n    function getAllInvestors(\\n        uint _pool\\n    ) external view returns (address[] memory) {\\n        address[] memory investorsList = new address[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            investorsList[i] = investors[_pool][i];\\n        }\\n        return investorsList;\\n    }\\n\\n    function getInvestorByIndex(\\n        uint _pool,\\n        uint index\\n    ) external view returns (address) {\\n        require(index < totalUsers, \\\"Index out of range\\\");\\n        return investors[_pool][index];\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_library\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devFeeWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proyectWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ForceWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BLOCK_TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FORCE_WITHDRAW_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HARVEST_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRER_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referrerPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requirePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requireAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockDuration\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractsLibrary\",\"outputs\":[{\"internalType\":\"contract IContractsLibraryV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFeeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flatFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"forceWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getAllInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getAllUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct Istaking.UserInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDAte\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getDeltaPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInvestorByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getPublicData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUsers_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvested_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvestCount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPaused_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct Istaking.UserInfo\",\"name\":\"userInfo_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"pendingRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct Istaking.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUserTotalPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasStoppedProductionView\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rquirePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requireAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeStep\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActived\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proyectWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrer_is_allowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_devFee\",\"type\":\"uint256\"}],\"name\":\"setDevFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_flatFee\",\"type\":\"uint256\"}],\"name\":\"setFlatFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setPoolStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setRefPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_referrer_is_allowed\",\"type\":\"bool\"}],\"name\":\"setReferrerIsAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devFeeWallet\",\"type\":\"address\"}],\"name\":\"setdevFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mWallet\",\"type\":\"address\"}],\"name\":\"setmWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oWallet\",\"type\":\"address\"}],\"name\":\"setoWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProduction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProductionDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProductionVar\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"takeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalReinvestCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalReinvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"userCanwithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CryptoStaking", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000007020e75a4a0d0af507f21327f4228a84500e50a7000000000000000000000000c215e3c09a718962b3daba5147ed5a9991d51b52000000000000000000000000f833fc31264ce78d44720593611cbc91a3d2da700000000000000000000000002bbfb635171c0e1caabdacb69130fbdb197c39c1000000000000000000000000ac0e786497337195af2440352d86d0633f12b6e1", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}