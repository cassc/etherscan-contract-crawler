{"SourceCode": "pragma solidity ^0.8.17;\r\ninterface IERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Dakaochang{\r\n    using SafeMath for uint;\r\n\r\n\r\n    mapping(address => bool) public whitelist;\r\n    mapping(address => uint) public expirationInfo;\r\n\r\n    mapping(address => uint) public leaderInfo;\r\n    address public owner = 0xD814e22f89e3B67B465af2795b7cdfC24dEB5d52;\r\n    address public USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n    uint256 public Amount = 1500000000000000000;\r\n    uint256 public WhitelistAmount = 300000000000000000000;\r\n\r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setLeader(address _address,uint percent) external onlyowner{\r\n        leaderInfo[_address] = percent;\r\n    }\r\n    function setwhiletlist(address _address) external onlyowner{\r\n        whitelist[_address] = true;\r\n    }\r\n    function multiwhitelist(address[] calldata _addlist) external onlyowner{\r\n        uint len = _addlist.length;\r\n        for(uint i = 0; i< len; ++i){\r\n            whitelist[_addlist[i]] = true;\r\n        }\r\n    }\r\n    function changeAmount(uint256 amount) external onlyowner{\r\n        Amount = amount;\r\n    }\r\n    function changeWhiteListAmount(uint256 amount) external onlyowner{\r\n        WhitelistAmount = amount;\r\n    }\r\n\r\n    function removewhitelist(address _add) external onlyowner{\r\n        whitelist[_add] = false;\r\n    }\r\n    function withdraw(address _coin) external payable onlyowner{\r\n        IERC20(_coin).transfer(owner,IERC20(_coin).balanceOf(address(this)));\r\n    }\r\n\r\n    function toWhiteList(address _invitor) external payable{\r\n        require(!whitelist[msg.sender]);\r\n        require(msg.sender != _invitor,\"cant yourself\");\r\n        IERC20(USDT).transferFrom(msg.sender,owner,WhitelistAmount.mul(100-leaderInfo[_invitor]).div(100));\r\n        IERC20(USDT).transferFrom(msg.sender,_invitor,WhitelistAmount.mul(leaderInfo[_invitor]).div(100));\r\n        whitelist[msg.sender] = true;\r\n    }\r\n\r\n    function Deposit(address _invitor,uint256 dayTimes) public payable{\r\n        require(dayTimes>0,\"dayTimes need > 0 \");\r\n        require(_invitor!=address(0));\r\n        require(msg.sender != _invitor,\"cant yourself\");\r\n        uint transferAmount = dayTimes*Amount;\r\n        if(dayTimes==7){\r\n            transferAmount = transferAmount.mul(9).div(10);\r\n        }\r\n        if(dayTimes==30){\r\n            transferAmount = transferAmount.mul(8).div(10);\r\n        }\r\n\r\n        IERC20(USDT).transferFrom(msg.sender,owner,transferAmount.mul(100-leaderInfo[_invitor]).div(100));\r\n        IERC20(USDT).transferFrom(msg.sender,_invitor,transferAmount.mul(leaderInfo[_invitor]).div(100));\r\n        expirationInfo[msg.sender]=block.timestamp+60*60*24*dayTimes;\r\n\r\n    }\r\n    function getUserExpired(address user) public view returns (bool expired)\r\n    {\r\n        if(expirationInfo[user]>block.timestamp){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n        \r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"Amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_invitor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dayTimes\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WhitelistAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"changeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"changeWhiteListAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"expirationInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"expired\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"leaderInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addlist\",\"type\":\"address[]\"}],\"name\":\"multiwhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"removewhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setLeader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setwhiletlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_invitor\",\"type\":\"address\"}],\"name\":\"toWhiteList\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coin\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Dakaochang", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ec23327d7c1218336abde87ec16f42e6229050ee17ee78ecd76c38c362995872"}