{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1500\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overloaded;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AbstractBridgeAgent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/**\\n * @title Base implementation of the Bridge Agent\\n *\\n * Chain-specific Bridge Agents are meant to extend from this class\\n * and also implement deposit() and claim() functions.\\n *\\n * Besides maximizing code reuse, bridge agents from different chains also\\n * implement the same interface. The Bridge Backend uses the ABI of this class\\n * to read agent data from blockchain, without relying on chain-specific\\n * implementation details of agents.\\n */\\nabstract contract AbstractBridgeAgent is Ownable, Pausable {\\n\\tusing SafeERC20 for IERC20;\\n\\tusing ECDSA for bytes32;\\n\\n\\t// Each new release of bridge agent would have a new version\\n\\tuint8 public constant VERSION = 1;\\n\\n\\t// Public key of signer that is used to sign bridge operations\\n\\taddress public bridgeSigner;\\n\\t// Wallet where the bridge fee will be transferred\\n\\taddress payable public treasurer;\\n\\n\\t// Map that holds current token registrations, tokenSigners[token] = signer\\n\\tmapping(address => address) public tokenSigners;\\n\\t// Stores the list of paused tokens\\n\\tmapping(address => bool) public tokenPaused;\\n\\t// Remembers used signatures to avoid reuse and re-entry\\n\\tmapping(bytes32 => bool) internal signatureUsed;\\n\\n\\t// Emitted when bridge signer is changed\\n\\tevent SetBridgeSigner(\\n\\t\\taddress indexed previousBridgeSigner,\\n\\t\\taddress indexed newBridgeSigner\\n\\t);\\n\\n\\t// Emitted when treasurer is changed\\n\\tevent SetTreasurer(\\n\\t\\taddress payable indexed previousTreasurer,\\n\\t\\taddress payable indexed newTreasurer\\n\\t);\\n\\n\\t// Emitted when a new token is registered or existing registration is updated\\n\\tevent Register(\\n\\t\\taddress indexed token,\\n\\t\\taddress indexed baseToken,\\n\\t\\taddress indexed signer\\n\\t);\\n\\n\\t// Emitted when amount of registered token is deposited\\n\\tevent Deposit(\\n\\t\\tuint256 toChain,\\n\\t\\taddress indexed token,\\n\\t\\taddress indexed fromWallet,\\n\\t\\taddress indexed toWallet,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 fee\\n\\t);\\n\\n\\t// Emitted when amount of registered token is claimed\\n\\tevent Claim(\\n\\t\\tbytes32 indexed depositTx,\\n\\t\\taddress indexed token,\\n\\t\\taddress indexed toWallet,\\n\\t\\tuint256 amount\\n\\t);\\n\\n\\t// Emitted when a token is migrated to a new agent contract version\\n\\tevent Migrate(\\n\\t\\taddress indexed token,\\n\\t\\taddress indexed newAgent,\\n\\t\\tuint256 balance\\n\\t);\\n\\n\\t// Emitted when token is paused for this agent\\n\\tevent TokenPaused(address indexed token, address indexed account);\\n\\n\\t// Emitted when token is unpaused for this agent\\n\\tevent TokenUnpaused(address indexed token, address indexed account);\\n\\n\\t/**\\n\\t * @dev Initializes the agent\\n\\t * @param _bridgeSigner Public key of signer that is used to sign bridge operations\\n\\t * @param _treasurer Wallet where the bridge fee will be transferred\\n\\t */\\n\\tconstructor(address _bridgeSigner, address payable _treasurer) Ownable() {\\n\\t\\tsetBridgeSigner(_bridgeSigner);\\n\\t\\tsetTreasurer(_treasurer);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Pauses the whole agent\\n\\t * All user-facing operations are not be possible while the agent is paused.\\n\\t *\\n\\t * Emits {Paused()}\\n\\t *\\n\\t * Requirements:\\n\\t * - The agent should not be paused\\n\\t * - Can only be called by the brigde agent owner\\n\\t */\\n\\tfunction pause() external onlyOwner {\\n\\t\\t_pause();\\n\\t}\\n\\n\\t/**\\n\\t * @notice Unpauses the agent\\n\\t *\\n\\t * Emits {Unpaused()}\\n\\t *\\n\\t * Requirements:\\n\\t * - The agent should be paused\\n\\t * - Can only be called by the brigde agent owner\\n\\t */\\n\\tfunction unpause() external onlyOwner {\\n\\t\\t_unpause();\\n\\t}\\n\\n\\t/**\\n\\t * @notice Pauses a token\\n\\t *\\n\\t * @param token token to be paused\\n\\t *\\n\\t * Emits {TokenPaused()}\\n\\t *\\n\\t * No user-facing operations are available on a token when it's paused.\\n\\t * The token also gets paused when it's being migrated to a newer version\\n\\t * agent contract, see migrate().\\n\\t *\\n\\t * Requirements:\\n\\t * - A token should not be currently paused\\n\\t * - A token _doesn't_ have to be registered to be paused\\n\\t * - Can only be called by the brigde agent owner\\n\\t */\\n\\tfunction pauseToken(address token) external onlyOwner {\\n\\t\\t_pauseToken(token);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Unpauses a token\\n\\t *\\n\\t * @param token token to be unpaused\\n\\t *\\n\\t * Emits {TokenUnpaused()}\\n\\t *\\n\\t * Requirements:\\n\\t * - A token should be paused\\n\\t * - Can only be called by the brigde agent owner\\n\\t */\\n\\tfunction unpauseToken(address token) external onlyOwner {\\n\\t\\t_unpauseToken(token);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Pauses a token \u2013 internal calls only\\n\\t */\\n\\tfunction _pauseToken(address token) internal {\\n\\t\\trequire(!tokenPaused[token], \\\"token is already paused\\\");\\n\\t\\ttokenPaused[token] = true;\\n\\t\\temit TokenPaused(token, msg.sender);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Unpauses a token \u2013 internal calls only\\n\\t */\\n\\tfunction _unpauseToken(address token) internal {\\n\\t\\trequire(tokenPaused[token], \\\"token is not paused\\\");\\n\\t\\ttokenPaused[token] = false;\\n\\t\\temit TokenUnpaused(token, msg.sender);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets a new bridge signer\\n\\t *\\n\\t * @param newBrigdeSigner Public key of signer that is used to sign bridge operations\\n\\t *\\n\\t * Emits {SetBridgeSigner()}\\n\\t *\\n\\t * Requirements:\\n\\t * - Can only be called by the brigde agent owner\\n\\t */\\n\\tfunction setBridgeSigner(address newBrigdeSigner) public onlyOwner {\\n\\t\\trequire(newBrigdeSigner != address(0), \\\"empty bridge signer\\\");\\n\\t\\temit SetBridgeSigner(bridgeSigner, newBrigdeSigner);\\n\\t\\tbridgeSigner = newBrigdeSigner;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets a new bridge treasurer\\n\\t *\\n\\t * @param newTreasurer Wallet where the bridge fee will be transferred\\n\\t *\\n\\t * Emits {SetTreasurer()}\\n\\t *\\n\\t * Requirements:\\n\\t * - Can only be called by the brigde agent owner\\n\\t */\\n\\tfunction setTreasurer(address payable newTreasurer) public onlyOwner {\\n\\t\\trequire(newTreasurer != address(0), \\\"empty treasurer\\\");\\n\\t\\temit SetTreasurer(treasurer, newTreasurer);\\n\\t\\ttreasurer = newTreasurer;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Used to prevent signature reuse, re-entry, and check it's not expired\\n\\t *\\n\\t * @param sig signature\\n\\t * @param sigExpire timestamp in milliseconds\\n\\t *\\n\\t * This modifier reverts if a signature is reused or expired\\n\\t */\\n\\tmodifier useSignature(bytes memory sig, uint256 sigExpire) {\\n\\t\\tbytes32 sigHash = keccak256(sig);\\n\\n\\t\\trequire(!signatureUsed[sigHash], \\\"reused signature\\\");\\n\\t\\tsignatureUsed[sigHash] = true;\\n\\n\\t\\tif (sigExpire > 0) {\\n\\t\\t\\t// sigExpire is in millis\\n\\t\\t\\trequire(sigExpire > block.timestamp * 1000, \\\"expired signature\\\");\\n\\t\\t}\\n\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Registers a token in this agent.\\n\\t *\\n\\t * @param token address of a token to be registered\\n\\t * @param baseToken address of a token in the main chain\\n\\t * @param signer public key of a signer owned by token owner to sign token operations\\n\\t * @param bridgeSig signature issued by the Bridge Service\\n\\t * @param sigExpire nonce/expiration issued by the Bridge Service\\n\\t *\\n\\t * Emits {Register()}\\n\\t *\\n\\t * Prior to cross-chain transfer opertaions been made, a token needs to be\\n\\t * registered in the agent, presumably by its owner. It cannot be called directly\\n\\t * by anyone though. The Bridge Service validates token ownership and issues\\n\\t * a signature {bridgeSig} that allows registration.\\n\\t *\\n\\t * This function can also be used to \\\"re-register\\\" a token that is already\\n\\t * registered. This can be needed in two cases:\\n\\t * 1. To set a new {signer} for a token.\\n\\t * 2. To unregister a token. For this, pass address(0) as a {signer}.\\n\\t *\\n\\t * This function is payable(), receiving service fee in the form of ether.\\n\\t * The actual fee value is obtained from the Bridge Service along with {bridgeSig}\\n\\t * and {sigExpire}.\\n\\t *\\n\\t * NOTE: In the main chain (ETH) the {baseToken} parameter should have the\\n\\t * same value as {token}. This parameter is needed for sub-chains like BSC\\n\\t * so that the Bridge Service can index Register events and make proper routing\\n\\t * for the users.\\n\\t *\\n\\t * Requirements:\\n\\t * - Agent must not be paused.\\n\\t * - {token} must not be paused.\\n\\t * - {token} and {baseToken} cannot be empty addresses.\\n\\t * - {bridgeSig} cannot be reused and {sigExpire} must be after the current block time.\\n\\t */\\n\\tfunction register(\\n\\t\\taddress token,\\n\\t\\taddress baseToken,\\n\\t\\taddress signer,\\n\\t\\tbytes memory bridgeSig,\\n\\t\\tuint256 sigExpire\\n\\t) external payable useSignature(bridgeSig, sigExpire) whenNotPaused {\\n\\t\\trequire(token != address(0), \\\"token is empty\\\");\\n\\t\\trequire(baseToken != address(0), \\\"baseToken is empty\\\");\\n\\t\\trequire(!tokenPaused[token], \\\"token is paused\\\");\\n\\n\\t\\t// Check signature\\n\\t\\t{\\n\\t\\t\\tbytes32 messageHash = keccak256(\\n\\t\\t\\t\\tabi.encode(\\n\\t\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\t\\ttoken,\\n\\t\\t\\t\\t\\tbaseToken,\\n\\t\\t\\t\\t\\tsigner,\\n\\t\\t\\t\\t\\tmsg.value,\\n\\t\\t\\t\\t\\tsigExpire\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t\\t\\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tethHash.recover(bridgeSig) == bridgeSigner,\\n\\t\\t\\t\\t\\\"invalid bridge signature\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\ttokenSigners[token] = signer;\\n\\n\\t\\t// User pays fee to the bridge\\n\\t\\tif (msg.value > 0) {\\n\\t\\t\\ttreasurer.transfer(msg.value);\\n\\t\\t}\\n\\n\\t\\temit Register(token, baseToken, signer);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Migrates a token to another agent contract\\n\\t *\\n\\t * @param token registered token to be migrated\\n\\t * @param newAgent address of a new agent to transfer balance to\\n\\t * @param tokenSig signature issued by a token owner\\n\\t * @param bridgeSig signature issued by the Bridge Service\\n\\t * @param sigExpire nonce/expiration issued by the Bridge Service\\n\\t *\\n\\t * Emits {Migrate()}\\n\\t *\\n\\t * This function is mostly needed when a new agent contract version is released.\\n\\t * The token owner is responsible to call this function before registering a\\n\\t * token {register()} on a new agent.\\n\\t *\\n\\t * Any token balance holded by this agent will be transferred to {newAgent}.\\n\\t * Note that there is balance only in the ETH chain \u2013 in other subchains the balance\\n\\t * is holded by the represented {SubchainToken}.\\n\\t *\\n\\t * Requirements:\\n\\t * - Agent must not be paused.\\n\\t * - {token} must be registered in this agent.\\n\\t * - {token} must not be paused.\\n\\t * - {tokenSig} and {bridgeSig} cannot be reused.\\n\\t * - {sigExpire} must be after the current block time.\\n\\t */\\n\\tfunction migrate(\\n\\t\\taddress token,\\n\\t\\taddress newAgent,\\n\\t\\tbytes memory tokenSig,\\n\\t\\tbytes memory bridgeSig,\\n\\t\\tuint256 sigExpire\\n\\t)\\n\\t\\texternal\\n\\t\\tuseSignature(tokenSig, sigExpire)\\n\\t\\tuseSignature(bridgeSig, sigExpire)\\n\\t\\twhenNotPaused\\n\\t{\\n\\t\\trequire(!tokenPaused[token], \\\"token is paused\\\");\\n\\t\\trequire(tokenSigners[token] != address(0), \\\"token not registered\\\");\\n\\n\\t\\t// check signature\\n\\t\\t{\\n\\t\\t\\tbytes32 messageHash = keccak256(\\n\\t\\t\\t\\tabi.encode(address(this), token, newAgent, sigExpire)\\n\\t\\t\\t);\\n\\t\\t\\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tethHash.recover(tokenSig) == tokenSigners[token],\\n\\t\\t\\t\\t\\\"invalid token signature\\\"\\n\\t\\t\\t);\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tethHash.recover(bridgeSig) == bridgeSigner,\\n\\t\\t\\t\\t\\\"invalid bridge signature\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t_pauseToken(token);\\n\\n\\t\\t// Transfer all the withhold balance of token to the new agent\\n\\t\\tuint256 amount = IERC20(token).balanceOf(address(this));\\n\\t\\tif (amount > 0) {\\n\\t\\t\\tIERC20(token).safeTransfer(newAgent, amount);\\n\\t\\t}\\n\\n\\t\\temit Migrate(token, newAgent, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Deposit a given amount to be claimed in another chain\\n\\t *\\n\\t * @param toChain chain ID in which the token amount will be claimed\\n\\t * @param token address of a registered token to be deposited\\n\\t * @param toWallet caller address that will claim the token from the {toChain}\\n\\t * @param amount wei amount of token to be deposited/claimed\\n\\t * @param bridgeSig signature issued by the Bridge Service\\n\\t * @param sigExpire nonce/expiration issued by the Bridge Service\\n\\t *\\n\\t * See chain-specific implementation for more documentation.\\n\\t */\\n\\tfunction deposit(\\n\\t\\tuint256 toChain,\\n\\t\\taddress token,\\n\\t\\taddress toWallet,\\n\\t\\tuint256 amount,\\n\\t\\tbytes memory bridgeSig,\\n\\t\\tuint256 sigExpire\\n\\t) external payable virtual;\\n\\n\\t/**\\n\\t * @dev Transfers a given amount of token from agent to a user\\n\\t *\\n\\t * @param depositTx deposit transaction hash from another chain\\n\\t * @param token address of the local token to be claimed\\n\\t * @param amount wei amount of token to be claimed\\n\\t * @param tokenSig signature of the Token Owner (obtained via Bridge Service)\\n\\t * @param bridgeSig signature of the Bridge Service\\n\\t *\\n\\t * See chain-specific implementation for more documentation.\\n\\t */\\n\\tfunction claim(\\n\\t\\tbytes32 depositTx,\\n\\t\\taddress token,\\n\\t\\tuint256 amount,\\n\\t\\tbytes memory tokenSig,\\n\\t\\tbytes memory bridgeSig\\n\\t) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/BSCBridgeAgent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./SubchainBridgeAgent.sol\\\";\\n\\n/**\\n * @title BSC implementation of the bridge agent\\n * See {SubchainBridgeAgent} for more documentation.\\n */\\ncontract BSCBridgeAgent is SubchainBridgeAgent {\\n\\tconstructor(address _bridgeSigner, address payable _treasurer)\\n\\t\\tSubchainBridgeAgent(_bridgeSigner, _treasurer)\\n\\t// solhint-disable-next-line no-empty-blocks\\n\\t{\\n\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/SubchainBridgeAgent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./AbstractBridgeAgent.sol\\\";\\nimport \\\"./interfaces/IClaimable.sol\\\";\\nimport \\\"./SubchainToken.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/**\\n * @title Non-ETH implementation for the bridge agent\\n *\\n * It's done mainly for BSC, but it can work with other Ethereum-compatible chains.\\n *\\n * In the main chain, the agent deals with a real token contract. In a subchain like BSC,\\n * however, we create a contract to represent a token there - {SubchainToken}.\\n * The amount of a subchain token is minted on-demand when claimed by a user. It is\\n * immediately burned when a user transfers the amount back to the main chain.\\n *\\n * A subchain token can be created independently or exist already. For example, when\\n * a new version of an bridge agent is released. In this case, calling {register()}\\n * and passing the existing subchain token contract is sufficient. Of course, the token\\n * should be properly suspended in the old contract by using {migrate()}.\\n *\\n * As a bonus, this contract implements a subchain token factory {createAndRegister()}\\n * that simplifies the initial creation and registration.\\n */\\nabstract contract SubchainBridgeAgent is AbstractBridgeAgent {\\n\\tusing SafeERC20 for IERC20;\\n\\tusing ECDSA for bytes32;\\n\\n\\tconstructor(address _bridgeSigner, address payable _treasurer)\\n\\t\\tAbstractBridgeAgent(_bridgeSigner, _treasurer)\\n\\t// solhint-disable-next-line no-empty-blocks\\n\\t{\\n\\n\\t}\\n\\n\\t/**\\n\\t * @notice Subchain token factory that also registers a newly-created token\\n\\t *\\n\\t * @param name name of a subchain token contract, see {IERC20.name()}\\n\\t * @param symbol symbol name of a subchain token contract, see {IERC20.symbol()}\\n\\t * @param baseToken address of the main token in the main chain\\n\\t * @param signer public key of a signer owned by token owner to sign token operations\\n\\t * @param bridgeSig signature issued by the Bridge Service\\n\\t * @param sigExpire nonce/expiration issued by the Bridge Service\\n\\t *\\n\\t * Emits {Register()}\\n\\t *\\n\\t * This function is payable(), receiving service fee in the form of ether.\\n\\t * The actual fee value is obtained from the Bridge Service along with {bridgeSig}\\n\\t * and {sigExpire}.\\n\\t *\\n\\t * Requirements:\\n\\t * - Agent must not be paused.\\n\\t * - {token} must not be paused.\\n\\t * - {name} and {symbol} cannot be empty.\\n\\t * - {baseToken} and {signer} cannot be empty address.\\n\\t * - {bridgeSig} cannot be reused and {sigExpire} must be after the current block time.\\n\\t */\\n\\tfunction createAndRegister(\\n\\t\\tstring memory name,\\n\\t\\tstring memory symbol,\\n\\t\\taddress baseToken,\\n\\t\\taddress signer,\\n\\t\\tbytes memory bridgeSig,\\n\\t\\tuint256 sigExpire\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\tuseSignature(bridgeSig, sigExpire)\\n\\t\\twhenNotPaused\\n\\t\\treturns (address)\\n\\t{\\n\\t\\trequire(bytes(name).length > 0, \\\"empty name\\\");\\n\\t\\trequire(bytes(symbol).length > 0, \\\"empty symbol\\\");\\n\\t\\trequire(signer != address(0), \\\"empty signer\\\");\\n\\t\\trequire(baseToken != address(0), \\\"baseToken is empty\\\");\\n\\n\\t\\t// We cannot reuse register() here because it requires the\\n\\t\\t// token address to be known in advance\\n\\n\\t\\t// Check signature\\n\\t\\t{\\n\\t\\t\\tbytes32 messageHash = keccak256(\\n\\t\\t\\t\\tabi.encode(\\n\\t\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\t\\tname,\\n\\t\\t\\t\\t\\tsymbol,\\n\\t\\t\\t\\t\\tbaseToken,\\n\\t\\t\\t\\t\\tsigner,\\n\\t\\t\\t\\t\\tmsg.value,\\n\\t\\t\\t\\t\\tsigExpire\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t\\t\\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tethHash.recover(bridgeSig) == bridgeSigner,\\n\\t\\t\\t\\t\\\"invalid bridge signature\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tSubchainToken token = new SubchainToken(\\n\\t\\t\\tname,\\n\\t\\t\\tsymbol,\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\tsigner\\n\\t\\t);\\n\\n\\t\\ttokenSigners[address(token)] = signer;\\n\\n\\t\\t// User pays fee to the bridge\\n\\t\\tif (msg.value != 0) {\\n\\t\\t\\ttreasurer.transfer(msg.value);\\n\\t\\t}\\n\\n\\t\\temit Register(address(token), baseToken, signer);\\n\\t\\treturn address(token);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Deposits a given amount of token that can be claimed in another chain.\\n\\t *\\n\\t * @param toChain target chain ID where the token amount will be claimed\\n\\t * @param token address of a registered token to be deposited\\n\\t * @param toWallet caller address that will claim the token from the {toChain}\\n\\t * @param amount wei amount of token to be deposited/claimed\\n\\t * @param bridgeSig signature issued by the Bridge Service\\n\\t * @param sigExpire nonce/expiration issued by the Bridge Service\\n\\t *\\n\\t * This function is payable(), receiving service fee in the form of ether.\\n\\t * The actual fee value is obtained from the Bridge Service along with {bridgeSig}\\n\\t * and {sigExpire}.\\n\\t *\\n\\t * This Subchain-specific implementation transfers the given amount of subchain token\\n\\t * from a user to this contract and burns it immediately.\\n\\t *\\n\\t * The Bridge Service monitors the chain and issue bridge/token signatures\\n\\t * once the deposit transaction gets enough confirmations. The two signatures\\n\\t * can later be obtained from the Bridge Service and used to claim the\\n\\t * token amount in another chain.\\n\\t *\\n\\t * Requirements:\\n\\t * - Agent must not be paused.\\n\\t * - {token} must be registered in this agent.\\n\\t * - {token} must not be paused.\\n\\t * - {bridgeSig} cannot be reused and {sigExpire} must be after the current block time.\\n\\t * - Caller should have enough {token} balance to afford the deposited {amount}.\\n\\t */\\n\\tfunction deposit(\\n\\t\\tuint256 toChain,\\n\\t\\taddress token,\\n\\t\\taddress toWallet,\\n\\t\\tuint256 amount,\\n\\t\\tbytes memory bridgeSig,\\n\\t\\tuint256 sigExpire\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\toverride\\n\\t\\tuseSignature(bridgeSig, sigExpire)\\n\\t\\twhenNotPaused\\n\\t{\\n\\t\\trequire(!tokenPaused[token], \\\"token is paused\\\");\\n\\t\\trequire(tokenSigners[token] != address(0), \\\"token not registered\\\");\\n\\n\\t\\t// check signature\\n\\t\\tbytes32 messageHash = keccak256(\\n\\t\\t\\tabi.encode(\\n\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\ttoChain,\\n\\t\\t\\t\\ttoken,\\n\\t\\t\\t\\ttoWallet,\\n\\t\\t\\t\\tamount,\\n\\t\\t\\t\\tmsg.value,\\n\\t\\t\\t\\tsigExpire\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\\n\\t\\trequire(\\n\\t\\t\\tethHash.recover(bridgeSig) == bridgeSigner,\\n\\t\\t\\t\\\"invalid bridge signature\\\"\\n\\t\\t);\\n\\n\\t\\tIERC20(token).safeTransferFrom(_msgSender(), address(this), amount);\\n\\t\\tIClaimable(token).burn(amount);\\n\\n\\t\\tif (msg.value != 0) {\\n\\t\\t\\ttreasurer.transfer(msg.value);\\n\\t\\t}\\n\\n\\t\\temit Deposit(toChain, token, _msgSender(), toWallet, amount, msg.value);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers a given amount of token from agent to a user\\n\\t *\\n\\t * @param depositTx deposit transaction hash from another chain\\n\\t * @param token address of the local token to be claimed\\n\\t * @param amount wei amount of token to be claimed\\n\\t * @param tokenSig signature of the Token Owner (obtained via Bridge Service)\\n\\t * @param bridgeSig signature of the Bridge Service\\n\\t *\\n\\t * Once the deposit is done in another chain and the Bridge Service has\\n\\t * issued token/bridge signature pair, the user can claim their token\\n\\t * in this chain, by calling this function.\\n\\t *\\n\\t * This Subchain-specific implementation calls {claim()} on subchain token\\n\\t * contract. The key point is that the bridge does not have control over\\n\\t * the token, and all {mint()} operations are controlled by the token owner\\n\\t * by checking {tokenSig} signatures.\\n\\t *\\n\\t * Requirements:\\n\\t * - Agent must not be paused.\\n\\t * - {token} must be registered in this agent.\\n\\t * - {token} must not be paused.\\n\\t * - Caller should be the wallet that was specified in {toWallet} during {deposit()}\\n\\t * - Valid {tokenSig} and {bridgeSig} obtained from the Bridge Service\\n\\t */\\n\\tfunction claim(\\n\\t\\tbytes32 depositTx,\\n\\t\\taddress token,\\n\\t\\tuint256 amount,\\n\\t\\tbytes memory tokenSig,\\n\\t\\tbytes memory bridgeSig\\n\\t)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tuseSignature(tokenSig, 0)\\n\\t\\tuseSignature(bridgeSig, 0)\\n\\t\\twhenNotPaused\\n\\t{\\n\\t\\trequire(!tokenPaused[token], \\\"token is paused\\\");\\n\\t\\trequire(tokenSigners[token] != address(0), \\\"token not registered\\\");\\n\\n\\t\\t// check signature\\n\\t\\t{\\n\\t\\t\\tbytes32 messageHash = keccak256(\\n\\t\\t\\t\\tabi.encode(\\n\\t\\t\\t\\t\\taddress(this), // calling contract\\n\\t\\t\\t\\t\\tdepositTx,\\n\\t\\t\\t\\t\\ttoken,\\n\\t\\t\\t\\t\\tblock.chainid,\\n\\t\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\t\\tamount\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t\\t\\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\\n\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tethHash.recover(bridgeSig) == bridgeSigner,\\n\\t\\t\\t\\t\\\"invalid bridge signature\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tIClaimable(token).claim(amount, _msgSender(), depositTx, tokenSig);\\n\\n\\t\\temit Claim(depositTx, token, _msgSender(), amount);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/SubchainToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./interfaces/IClaimable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/**\\n * @title Implementation of a contract that acts a token in a non-main chain\\n *\\n * This is a ERC20 token implementation with one slight difference:\\n * It mints a given amount for a user who deposited this amount in the ETH chain.\\n * The amount is burned when a user transfers value back to the main chain.\\n * The mint operation is checked by Signer, the signature is validated by the\\n * Bridge Service making sure that the deposit has been made in another chain.\\n *\\n * HINT: you can set signer to address(0) to pause claims.\\n *\\n * See {SubchainBridgeAgent} and {claim()} for more information.\\n */\\ncontract SubchainToken is ERC20, Ownable, IClaimable {\\n\\tusing ECDSA for bytes32;\\n\\n\\t// Remembers used signatures to avoid reuse and re-entry\\n\\tmapping(bytes32 => bool) internal signatureUsed;\\n\\t// Signer that is used to validate {claim()} operations\\n\\taddress internal signer;\\n\\n\\t// Emitted when amount of this token has been minted\\n\\tevent Claim(\\n\\t\\tbytes32 indexed depositTx,\\n\\t\\taddress indexed receiver,\\n\\t\\tuint256 amount\\n\\t);\\n\\n\\t// Emitted when a token being deposited back and the amount is burned\\n\\tevent Burn(address indexed wallet, uint256 amount);\\n\\n\\t// Emitted when the signer is changed\\n\\tevent SetSigner(\\n\\t\\taddress indexed changedBy,\\n\\t\\taddress indexed previousSigner,\\n\\t\\taddress indexed newSigner\\n\\t);\\n\\n\\t/**\\n\\t * @dev Initializes the subchain token contract\\n\\t *\\n\\t * @param name_ name of a subchain token contract, see {IERC20.name()}\\n\\t * @param symbol_ symbol name of a subchain token contract, see {IERC20.symbol()}\\n\\t * @param owner_ owner who can change signer\\n\\t * @param signer_ signer that is used to validate {claim()} operations\\n\\t */\\n\\tconstructor(\\n\\t\\tstring memory name_,\\n\\t\\tstring memory symbol_,\\n\\t\\taddress owner_,\\n\\t\\taddress signer_\\n\\t) ERC20(name_, symbol_) {\\n\\t\\ttransferOwnership(owner_);\\n\\t\\tsigner = signer_;\\n\\t}\\n\\n\\t/**\\n\\t * @notice sets a new signer\\n\\t *\\n\\t * Emits {SetSigner}\\n\\t *\\n\\t * HINT: set signer to address(0) to pause claims.\\n\\t *\\n\\t * Requirements\\n\\t * - Caller must be token owner\\n\\t */\\n\\tfunction setSigner(address newSigner) external onlyOwner {\\n\\t\\temit SetSigner(_msgSender(), signer, newSigner);\\n\\t\\tsigner = newSigner;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns current token signer\\n\\t * @return address\\n\\t */\\n\\tfunction getSigner() external view returns (address) {\\n\\t\\treturn signer;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Mints the amount for a given {receiver}\\n\\t *\\n\\t * @param amount wei amount to be minted\\n\\t * @param receiver walled to be minted to\\n\\t * @param depositHash hash of the deposit transaction in another chain\\n\\t * @param tokenSig signature of the {signer} that validates the deposit\\n\\t *\\n\\t * Emits {Claim}\\n\\t *\\n\\t * The {signer} signature is checked in order to validate the\\n\\t * amount about to claim is being deposited in another chain.\\n\\t *\\n\\t * Requirements:\\n\\t * - Valid {tokenSig} obtained from the Bridge Srvice, cannot be reused.\\n\\t * - {signer} currently set for the token cannot be empty address(0).\\n\\t */\\n\\tfunction claim(\\n\\t\\tuint256 amount,\\n\\t\\taddress receiver,\\n\\t\\tbytes32 depositHash,\\n\\t\\tbytes memory tokenSig\\n\\t) external override {\\n\\t\\tbytes32 sigHash = keccak256(tokenSig);\\n\\t\\trequire(!signatureUsed[sigHash], \\\"cannot reuse signature\\\");\\n\\t\\tsignatureUsed[sigHash] = true;\\n\\n\\t\\t// Can set signer to address(0) to pause claims\\n\\t\\trequire(signer != address(0), \\\"empty signer\\\");\\n\\n\\t\\t// check signature\\n\\t\\tbytes32 messageHash = keccak256(\\n\\t\\t\\tabi.encode(\\n\\t\\t\\t\\tmsg.sender, // calling contract\\n\\t\\t\\t\\tdepositHash,\\n\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\tblock.chainid,\\n\\t\\t\\t\\treceiver,\\n\\t\\t\\t\\tamount\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\\n\\t\\trequire(ethHash.recover(tokenSig) == signer, \\\"invalid token signature\\\");\\n\\n\\t\\temit Claim(depositHash, receiver, amount);\\n\\t\\t_mint(receiver, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Burns the amount for a caller\\n\\t *\\n\\t * @param amount wei amount to be burned\\n\\t *\\n\\t * Emits {Burn}\\n\\t *\\n\\t * Requirements:\\n\\t * - Caller should have enough balance to burn the given amount\\n\\t */\\n\\tfunction burn(uint256 amount) external override {\\n\\t\\temit Burn(_msgSender(), amount);\\n\\t\\t_burn(_msgSender(), amount);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Used to represent the claim and burn operations of the\\n * Subchain token for the Subchain agent.\\n */\\ninterface IClaimable {\\n\\t// See {SubchainToken.claim()}\\n\\tfunction claim(\\n\\t\\tuint256 amount,\\n\\t\\taddress receiver,\\n\\t\\tbytes32 depositTx,\\n\\t\\tbytes memory tokenSig\\n\\t) external;\\n\\n\\t// See {SubchainToken.burn()}\\n\\tfunction burn(uint256 amount) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bridgeSigner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_treasurer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"depositTx\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAgent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousBridgeSigner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBridgeSigner\",\"type\":\"address\"}],\"name\":\"SetBridgeSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address payable\",\"name\":\"previousTreasurer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address payable\",\"name\":\"newTreasurer\",\"type\":\"address\"}],\"name\":\"SetTreasurer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TokenPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TokenUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"depositTx\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tokenSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"bridgeSig\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"bridgeSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sigExpire\",\"type\":\"uint256\"}],\"name\":\"createAndRegister\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bridgeSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sigExpire\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAgent\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tokenSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"bridgeSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sigExpire\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"pauseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"bridgeSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sigExpire\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBrigdeSigner\",\"type\":\"address\"}],\"name\":\"setBridgeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newTreasurer\",\"type\":\"address\"}],\"name\":\"setTreasurer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenSigners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasurer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unpauseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BSCBridgeAgent", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1500", "ConstructorArguments": "00000000000000000000000072c509b36f734567b86e6b624ba4d53ea5043718000000000000000000000000d020f2160cef2e4d70431c2f3bba506ea6a618d4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}