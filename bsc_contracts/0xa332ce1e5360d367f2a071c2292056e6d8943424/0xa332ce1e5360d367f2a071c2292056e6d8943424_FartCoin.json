{"SourceCode": "//SPDX-License-Identifier: No License\r\npragma solidity ^0.8.0;\r\n \r\n// Made in partnership with Tokify\r\n \r\n/**\r\n * SAFEMATH LIBRARY\r\n */\r\nlibrary SafeMath {\r\n \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n}\r\n \r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n \r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n \r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n \r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n \r\n    /**\r\n     * Function modifier to require caller to be authorized\r\n     */\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n \r\n    /**\r\n     * Authorize address. Owner only\r\n     */\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n \r\n    /**\r\n     * Remove address' authorization. Owner only\r\n     */\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n \r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n \r\n    /**\r\n     * Return address' authorization status\r\n     */\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n \r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n \r\n    event OwnershipTransferred(address owner);\r\n}\r\n \r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n \r\ninterface IDEXPair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 bassetPoolLockTimestampLast);\r\n    function token0() external view returns (address);\r\n}\r\n \r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n \r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n \r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n \r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n \r\n/** @dev this token is backed by BNB, which can be sent to the contract by anyone and can be redeemed by burning the token. \r\n \r\nWhen burning the token, the amount of BNB given is calculated by taking (token amount)/(circulating supply) and giving that fraction of the asset pool BNB.\r\n*/ \r\n \r\ncontract FartCoin is IBEP20, Auth {\r\n    using SafeMath for uint256;\r\n \r\n    uint256 public constant MASK = type(uint128).max;\r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n    address DEAD_NON_CHECKSUM = 0x000000000000000000000000000000000000dEaD;\r\n \r\n    string constant _name = \"Fart Coin\";\r\n    string constant _symbol = \"FART\";\r\n    uint8 constant _decimals = 18;\r\n \r\n    uint256 private _totalSupply = 8000000000000000000000000000000;\r\n    uint256 public _maxTxAmount = _totalSupply.div(400); // 0.25%\r\n \r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n \r\n    mapping (address => bool) isFeeExempt;\r\n    mapping (address => bool) isTxLimitExempt;\r\n    mapping (address => bool) isExcludedFromPause;\r\n    mapping (address => bool) isBlacklisted;\r\n \r\n    /// @dev liquidityFee determines tax to send to the liquidity pool\r\n    uint256 liquidityFee = 200;\r\n    /// @dev backingFee determines tax to send to the asset pool, which backs the token\r\n    uint256 backingFee = 200;\r\n    /// @dev marketingFee determines tax to send to the marketing wallet\r\n    uint256 marketingFee = 400;\r\n    uint256 totalFee = liquidityFee.add(backingFee).add(marketingFee);\r\n    /// @dev fee denominator allows taxes to be decimal number percentages\r\n    uint256 feeDenominator = 10000;\r\n    uint256 public maxSellFee = 3000;\r\n    uint256 public maxSellMultiplier = 50000;\r\n\r\n    uint256 public baseTaxesAccumulated;\r\n    uint256 public sellingTaxAccumulated;\r\n \r\n    address public autoLiquidityReceiver;\r\n    address public marketingFeeReceiver;\r\n    address generatorFeeReceiver = 0xF6bF36933149030ed4B212F0a79872306690e48e;\r\n    uint256 generatorFee = 500;\r\n \r\n    /// @dev takeFeeActive allows to temporarily pause any taxes\r\n    bool takeFeeActive = true;\r\n \r\n    uint256 targetLiquidity = 25;\r\n    uint256 targetLiquidityDenominator = 100;\r\n \r\n    IDEXRouter public router;\r\n    address public pair;\r\n\r\n    uint256 public assetPoolLockTimestamp;\r\n    uint256 public assetPoolLockTime;\r\n    bool public isPaused;\r\n \r\n    /// @dev before processing taxes in BNB, the taxed token is accumulated in the contract to save on gas fees\r\n    /// @dev the swap to BNB will only occur once the swapThreshold is reached\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply / 2000; // 0.05%\r\n    uint256 public sellingSwapThreshold = _totalSupply / 2000; // 0.05%\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n \r\n    constructor (\r\n        address _dexRouter,\r\n        address _marketingFeeReceiver\r\n        ) Auth(msg.sender) {\r\n        /// @dev set the router address and create pair\r\n        router = IDEXRouter(_dexRouter);\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n        WBNB = router.WETH();\r\n \r\n        isFeeExempt[msg.sender] = true;\r\n        isExcludedFromPause[msg.sender] = true;\r\n        isTxLimitExempt[msg.sender] = true;\r\n \r\n        autoLiquidityReceiver = msg.sender;\r\n        marketingFeeReceiver = _marketingFeeReceiver;\r\n \r\n        approve(_dexRouter, _totalSupply);\r\n        approve(address(pair), _totalSupply);\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n \r\n    receive() external payable {}\r\n \r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n \r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n \r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, _totalSupply);\r\n    }\r\n \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n \r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != _totalSupply){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n \r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n \r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(isBlacklisted[sender] == false && isBlacklisted[recipient] == false,\"WARNING: either sender or recipient is blacklisted, contact an administrator for assitance\");\r\n        if(isPaused){\r\n          require(isExcludedFromPause[sender] == true || isExcludedFromPause[recipient] == true,\"WARNING: contract is in pause for maintenance\");\r\n        }\r\n        /// @dev if the token is currently being swapped by the contract into BNB, then no taxes apply\r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n        /// @dev if the token is being burned then the recipient will be reimbursed with BNB according to the amount in the asset pool\r\n        if(recipient == DEAD){ return _burnForBNB(sender, amount); }\r\n        /// @dev check that the size of the transaction is not over the transaction limit\r\n        checkTxLimit(sender, amount);\r\n        /// @dev check if enough of the token has been accumulated in the contract to swap into BNB and if so then swap the token accumulated in contract to BNB\r\n        /// @dev only do either selling or base tax swap back at a single time\r\n        if(shouldSwapBack()){ swapBack(); }\r\n        else if(shouldSwapBackSelling()){ swapBackSelling(); }\r\n \r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n \r\n        uint256 amountReceived = shouldTakeFee(sender) ? takeFee(sender, recipient, amount) : amount;\r\n \r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n        if(recipient == address(this)) {sellingTaxAccumulated = sellingTaxAccumulated.add(amount);}\r\n \r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n//        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n \r\n    function checkTxLimit(address sender, uint256 amount) internal view {\r\n        require(amount <= _maxTxAmount || isTxLimitExempt[sender], \"TX Limit Exceeded\");\r\n    }\r\n \r\n    /// @dev check if taking fee is active and if yes if the sender is exempt from the fee\r\n    function shouldTakeFee(address sender) internal view returns (bool) {\r\n        if (takeFeeActive == false) {\r\n            return false;\r\n        }\r\n        return !isFeeExempt[sender];\r\n    }\r\n \r\n    /// @dev multiply fee by selling multiplier if person is selling the token\r\n    /// @dev sell multiplier is set depending on the current gap ratio proportionally\r\n    function getSellMultipliedFee() public view returns (uint256) {\r\n        uint256 sellMultiplier = getCurrentGapRatio(feeDenominator);\r\n        if(sellMultiplier <= feeDenominator){\r\n            sellMultiplier = feeDenominator;\r\n        }\r\n        if(sellMultiplier >= maxSellMultiplier){\r\n            sellMultiplier = maxSellMultiplier;\r\n        }\r\n        uint256 sellFee = totalFee.mul(sellMultiplier).div(feeDenominator);\r\n        /// @dev allow a maximum sell fee of 5000\r\n        if(sellFee > maxSellFee){\r\n            sellFee = maxSellFee;\r\n        }\r\n        return sellFee;\r\n    }\r\n \r\n    /// @dev check ratio of LP price and the floor price determined by the BNB held in asset pool\r\n    function getCurrentGapRatio(uint256 denominator) public view returns (uint256) {\r\n        IDEXPair routerPair = IDEXPair(pair);\r\n        address token0 = routerPair.token0();\r\n        uint256 reservesBNB;\r\n        uint256 reservesToken;\r\n        if(token0 == WBNB) {\r\n            (reservesBNB, reservesToken,) = routerPair.getReserves();\r\n        } else if (token0 == address(this)) {\r\n            (reservesToken, reservesBNB,) = routerPair.getReserves();\r\n        }\r\n        uint256 bnbAsset = getAmountBNBInAssetPool();\r\n        if(bnbAsset == 0) {\r\n            bnbAsset = 1;\r\n        }\r\n        uint256 gapRatio = denominator.mul(getCirculatingSupply().mul(reservesBNB)).div(reservesToken.mul(bnbAsset));\r\n        return gapRatio;\r\n    }\r\n\r\n    /// @dev calculae the total fee to be taken on the transaction\r\n    function getTotalFee(bool selling) public view returns (uint256) {\r\n        if(selling){ return getSellMultipliedFee(); }\r\n        return totalFee;\r\n    }\r\n\r\n    /// @dev figure out the amount transferred when taxes are deducted and add the taxes to this contract\r\n    function takeFee(address sender, address receiver, uint256 amount) internal returns (uint256) {\r\n        bool selling = receiver == pair;\r\n        uint256 feeAmount = amount.mul(getTotalFee(selling)).div(feeDenominator);\r\n        if (selling) {\r\n            uint256 baseFee = amount.mul(totalFee).div(feeDenominator);\r\n            uint256 sellingFee = feeAmount.sub(baseFee);\r\n            sellingTaxAccumulated = sellingTaxAccumulated.add(sellingFee);\r\n            baseTaxesAccumulated = baseTaxesAccumulated.add(baseFee);\r\n        } else {\r\n            baseTaxesAccumulated = baseTaxesAccumulated.add(feeAmount);\r\n        }\r\n \r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n\r\n\r\n        emit Transfer(sender, address(this), feeAmount);\r\n \r\n        return amount.sub(feeAmount);\r\n    }\r\n \r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        && !isPaused\r\n        && !inSwap\r\n        && swapEnabled\r\n        && baseTaxesAccumulated >= swapThreshold;\r\n    }\r\n \r\n    /// @dev function to swap the token accumulated in the contract through taxes into BNB\r\n    /// @dev the BNB is then accordingly distributed into the rewards pool, the liquidity pool and the marketing wallet\r\n    function swapBack() internal swapping {\r\n        uint256 dynamicLiquidityFee = isOverLiquified(targetLiquidity, targetLiquidityDenominator) ? 0 : liquidityFee;\r\n        uint256 amountToLiquify = swapThreshold.mul(dynamicLiquidityFee).div(totalFee).div(2);\r\n        uint256 amountToSwap = swapThreshold.sub(amountToLiquify);\r\n \r\n        /// @dev set the path through which the contract exchanges the token to BNB\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WBNB;\r\n        uint256 balanceBefore = address(this).balance;\r\n \r\n        /// @dev exchange the token for BNB\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        baseTaxesAccumulated = balanceOf(address(this)).sub(sellingTaxAccumulated);\r\n \r\n        /// @dev caluculate how much new BNB has been converted\r\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\r\n \r\n        uint256 totalBNBFee = totalFee.sub(dynamicLiquidityFee.div(2));\r\n \r\n        /// @dev since adding to liquidity pool requires both BNB and the token, we only convert half of it\r\n        uint256 amountBNBLiquidity = amountBNB.mul(dynamicLiquidityFee).div(totalBNBFee).div(2);\r\n        uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(totalBNBFee);\r\n        /// @dev there is no value here for the backing fee in BNB, since it would be in the contract after conversion to BNB anyway\r\n \r\n        sendSwappedBNB(amountBNBMarketing);\r\n \r\n        /// @dev transfer the portion of taxes taken for liquidity pool to the liquidity pool\r\n        if(amountToLiquify > 0){\r\n            router.addLiquidityETH{value: amountBNBLiquidity}(\r\n                address(this),\r\n                amountToLiquify,\r\n                0,\r\n                0,\r\n                autoLiquidityReceiver,\r\n                block.timestamp\r\n            );\r\n            baseTaxesAccumulated = balanceOf(address(this)).sub(sellingTaxAccumulated);\r\n            emit AutoLiquify(amountBNBLiquidity, amountToLiquify);\r\n        }\r\n    }\r\n\r\n    function shouldSwapBackSelling() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        && !isPaused\r\n        && !inSwap\r\n        && swapEnabled\r\n        && sellingTaxAccumulated >= sellingSwapThreshold;\r\n    }\r\n\r\n    /// @dev function to swap the token accumulated in extra selling taxes to go to asset pool\r\n    function swapBackSelling() internal swapping {\r\n \r\n        /// @dev set the path through which the contract exchanges the token to BNB\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WBNB;\r\n \r\n        /// @dev exchange the token for BNB\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            sellingSwapThreshold,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        sellingTaxAccumulated = balanceOf(address(this)).sub(baseTaxesAccumulated);\r\n    }\r\n\r\n    function sendSwappedBNB(uint256 amountBNBMarketing) internal {\r\n \r\n        /// @dev tax on the marketing wallet going towards the contract generator platform\r\n        uint256 generatorAmount = amountBNBMarketing.mul(generatorFee).div(\r\n            feeDenominator\r\n        );\r\n        uint256 marketingAmount = amountBNBMarketing.sub(generatorAmount);\r\n \r\n        (bool marketingTransferSuccess,) = address(marketingFeeReceiver).call{value: marketingAmount}(\"\");\r\n        require(marketingTransferSuccess);\r\n        (bool generatorTransferSuccess,) = address(generatorFeeReceiver).call{value: generatorAmount}(\"\");\r\n        require(generatorTransferSuccess);\r\n    }\r\n \r\n    /// @dev set the transaction limit\r\n    function setTxLimit(uint256 amount) external authorized {\r\n        require(amount >= _totalSupply / 1000);\r\n        _maxTxAmount = amount;\r\n    }\r\n\r\n    /// @dev set the maximum sell fee that can be applied with a denominator of 10,000\r\n    function setMaxSellFeeDenominator10000(uint256 _maxSellFee) external authorized {\r\n        require(_maxSellFee <= 5000, \"Value too high\");\r\n        require(_maxSellFee >= totalFee, \"Value too low\");\r\n        maxSellFee = _maxSellFee;\r\n    }\r\n\r\n    /// @dev set the maximum sell multiplier that can be applied with a denominator of 10,000\r\n    function setMaxSellMultiplierDenominator10000(uint256 _maxSellMultiplier) external authorized {\r\n        require(_maxSellMultiplier <= 100000, \"Value too high\");\r\n        require(_maxSellMultiplier >= 10000, \"Value too low\");\r\n        maxSellMultiplier = _maxSellMultiplier;\r\n    }\r\n \r\n    /// @dev set whether an address is exempt from the fee\r\n    function excludeFromFee(address[] memory accounts) public authorized {\r\n        uint256 length = accounts.length;\r\n        for (uint i=0; i<length; i++) {\r\n            isFeeExempt[accounts[i]] = true;\r\n        }\r\n    }\r\n\r\n    /// @dev set whether an address is exempt from the fee\r\n    function includeInFee(address[] memory accounts) public authorized {\r\n        uint256 length = accounts.length;\r\n        for (uint i=0; i<length; i++) {\r\n            isFeeExempt[accounts[i]] = false;\r\n        }\r\n    }\r\n \r\n    /// @dev set whether an address is exempt from the maximum transaction limit\r\n    function setIsTxLimitExempt(address holder, bool exempt) external authorized {\r\n        isTxLimitExempt[holder] = exempt;\r\n    }\r\n \r\n    /// @dev set the fees with a denominator of 10000\r\n    function setFeesWithDenominator10000(\r\n        uint256 _liquidityFee,\r\n        uint256 _backingFee,\r\n        uint256 _marketingFee\r\n    ) external authorized {\r\n        liquidityFee = _liquidityFee;\r\n        backingFee = _backingFee;\r\n        marketingFee = _marketingFee;\r\n        totalFee = _liquidityFee.add(_backingFee).add(_marketingFee);\r\n        if(totalFee > maxSellFee) {\r\n            maxSellFee = totalFee;\r\n        }\r\n        require(totalFee < feeDenominator / 4);\r\n    }\r\n \r\n    /// @dev set the addresses that benefit from the marketing fee and those that receive the liquidity\r\n    function setFeeReceivers(address _autoLiquidityReceiver, address _marketingFeeReceiver) external authorized {\r\n        autoLiquidityReceiver = _autoLiquidityReceiver;\r\n        marketingFeeReceiver = _marketingFeeReceiver;\r\n    }\r\n \r\n    /// @dev set whether the contract can swap back its accumulated token into BNB and set the threshold for this\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount, uint256 _sellingAmount) external authorized {\r\n        swapEnabled = _enabled;\r\n        swapThreshold = _amount;\r\n        sellingSwapThreshold = _sellingAmount;\r\n    }\r\n\r\n    /// @dev set the maximum amount of liquidity up to which taxes keep being sent to the pool\r\n    function setTargetLiquidity(uint256 _target, uint256 _denominator) external authorized {\r\n        targetLiquidity = _target;\r\n        targetLiquidityDenominator = _denominator;\r\n    }\r\n\r\n    /// @dev enable or disable the fee\r\n    function setFeeActive(bool setTakeFeeActive) external authorized {\r\n        takeFeeActive = setTakeFeeActive;\r\n    }\r\n \r\n    /// @dev get the token supply not stored in the burn wallets\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n \r\n    /// @dev check whether too much of the token is in the liquidity pool\r\n    function isOverLiquified(uint256 target, uint256 accuracy) public view returns (bool) {\r\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply()) > target;\r\n    }\r\n \r\n    /// @dev get amount of BNB stored in the asset pool (this contract)\r\n    function getAmountBNBInAssetPool() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function lockAssetRewardPools(uint256 _numberOfDays) external onlyOwner {\r\n        assetPoolLockTimestamp = block.timestamp;\r\n        assetPoolLockTime = _numberOfDays.mul(1 days);\r\n    }\r\n\r\n    /// @dev necessary for contract upgrades. Can do at most every 10 days\r\n    function pauseContract() external onlyOwner {\r\n        isPaused = true;\r\n    }\r\n\r\n    /// @dev necessary for contract upgrades. Can do at most every 10 days\r\n    function unpauseContract() external onlyOwner {\r\n        isPaused = false;\r\n    }\r\n\r\n    /// @dev exclude specific wallets from the pause\r\n    function excludeFromPause(address[] memory accounts) public authorized {\r\n        uint256 length = accounts.length;\r\n        for (uint i=0; i<length; i++) {\r\n            isExcludedFromPause[accounts[i]] = true;\r\n        }\r\n    }\r\n\r\n    /// @dev include and address in the pause\r\n    function includeInPause(address[] memory accounts) public authorized {\r\n        uint256 length = accounts.length;\r\n        for (uint i=0; i<length; i++) {\r\n            require(isOwner(accounts[i]) == false, \"ERR: owner can't be included\");\r\n            isExcludedFromPause[accounts[i]] = false;\r\n        }\r\n    }\r\n\r\n    /// @dev exclude specific wallets from the pause\r\n    function excludeFromBlacklist(address account) public authorized {\r\n        isBlacklisted[account] = false;\r\n    }\r\n\r\n    /// @dev include and address in the pause\r\n    function includeInBlacklist(address account) public authorized {\r\n        isBlacklisted[account] = true;\r\n    }\r\n\r\n    /// @dev necessary for contract upgrades\r\n    function moveAssetPool(address recipient) external onlyOwner {\r\n        require(block.timestamp >= assetPoolLockTimestamp + assetPoolLockTime, \"Asset pool currently locked\");\r\n        uint256 amountAssetPoolBNBToTransfer = address(this).balance;\r\n        (bool success,) = address(recipient).call{value: amountAssetPoolBNBToTransfer}(\"\");\r\n        require(success);\r\n    }\r\n \r\n    /// @dev allow holders to burn their token in exchange for BNB stored in the asset and rewards pool\r\n    function burnForBNB(uint256 amount) external returns (bool) {\r\n        address sender = msg.sender;\r\n        return _burnForBNB(sender, amount);\r\n    }\r\n \r\n    /// @dev function to process the sending of BNB to person burning the token\r\n    function _burnForBNB(address sender, uint256 amount) internal returns (bool) {\r\n        require(isBlacklisted[sender] == false,\"WARNING: this account is blacklisted, contact an administrator for assitance\");\r\n        if(isPaused){\r\n          require(isExcludedFromPause[sender] == true,\"WARNING: contract is in pause for upgrade\");\r\n        }\r\n        /// @dev calculate amount BNB to transfer to wallet burning the token\r\n        /// @dev this is done by taking the fraction of the circulating supply being burned and multiplying it with the BNB stored in the asset pool\r\n        uint256 amountBNBToTransfer = getAmountBNBInAssetPool().mul(amount).div(getCirculatingSupply());\r\n \r\n        address recipient = DEAD;\r\n        /// @dev if not enough token to burn then transaction will be reverted and BNB will not be sent\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n \r\n        /// @dev send BNB from asset pool to function callr\r\n        (bool success,) = address(sender).call{value: amountBNBToTransfer}(\"\");\r\n        require(success);\r\n\r\n        /// @dev check if enough of the token has been accumulated in the contract to swap into BNB and if so then swap the token accumulated in contract to BNB\r\n        /// @dev only do either selling or base tax swap back at a single time\r\n        if(shouldSwapBack()){ swapBack(); }\r\n        else if(shouldSwapBackSelling()){ swapBackSelling(); }\r\n \r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n \r\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetPoolLockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetPoolLockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTaxesAccumulated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnForBNB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"excludeFromPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAmountBNBInAssetPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"getCurrentGapRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellMultipliedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"selling\",\"type\":\"bool\"}],\"name\":\"getTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"includeInPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfDays\",\"type\":\"uint256\"}],\"name\":\"lockAssetRewardPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"moveAssetPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellingSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellingTaxAccumulated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"setTakeFeeActive\",\"type\":\"bool\"}],\"name\":\"setFeeActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_backingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"}],\"name\":\"setFeesWithDenominator10000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSellFee\",\"type\":\"uint256\"}],\"name\":\"setMaxSellFeeDenominator10000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSellMultiplier\",\"type\":\"uint256\"}],\"name\":\"setMaxSellMultiplierDenominator10000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellingAmount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"setTargetLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FartCoin", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000009638bd315ab3a04c0d44d6fef091ae62ccc97b7e", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ab7312c279c642a748d33fefc00157738bd27d149cb6f1c207b25dc48fc55b81"}