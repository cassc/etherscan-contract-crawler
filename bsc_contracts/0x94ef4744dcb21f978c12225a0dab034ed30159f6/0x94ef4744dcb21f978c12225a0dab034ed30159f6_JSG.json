{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal pure virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor(){\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ncontract JSG is Ownable{\r\n\r\n    using SafeMath for uint256; \r\n    IERC20 public BUSD;\r\n    IERC20 public JUTTO;\r\n\r\n    uint256 private constant feePercents = 200; \r\n    uint256 private constant minDeposit = 50e18;\r\n    uint256 private constant maxDeposit = 2000e18;\r\n    uint256 private constant ROIpercents = 3000;\r\n\r\n    uint256 private constant baseDivider = 10000;\r\n\r\n    uint256 private constant timeStep = 1 days;\r\n    uint256 private constant dayPerCycle = 7 days;\r\n    uint256 private constant dayRewardPercents = 214290000000000000000;\r\n\r\n    uint256 private constant maxAddFreeze = 36 days;\r\n    uint256 private constant referDepth = 14;\r\n\r\n    uint256 private constant directPercents = 600;\r\n    uint256 private constant level2Percents = 300;\r\n    uint256 private constant level3_6Percents = 200;\r\n    uint256 private constant level7_10Percents = 100;\r\n    uint256 private constant level11_14Percents = 50;\r\n\r\n    uint256 private constant level2Share = 25;\r\n    uint256 private constant level3Share = 50;\r\n    uint256 private constant level4Share = 75;\r\n    uint256 private constant level5Share = 100;\r\n    uint256 private constant topPoolShare = 60;\r\n\r\n\r\n    uint256[5] private balDown = [10e10, 30e10, 100e10, 500e10, 1000e10];\r\n    uint256[5] private balDownRate = [1000, 1500, 2000, 5000, 6000]; \r\n    uint256[5] private balRecover = [15e10, 50e10, 150e10, 500e10, 1000e10];\r\n\r\n    address[3] public feeReceivers;\r\n    address[] public depositors;\r\n\r\n    address[] public level2;\r\n    address[] public level3;\r\n    address[] public level4;\r\n    address[] public level5;\r\n\r\n    address public defaultRefer;\r\n    uint256 public startTime;\r\n    uint256 public lastDistribute;\r\n    uint256 public totalUser; \r\n\r\n    uint256 public DailyPool;\r\n    uint256 public tokenper = 23;\r\n\r\n    bool public isFreezeReward;\r\n\r\n\r\n\r\n    struct UserInfo\r\n    {\r\n        address referrer;\r\n        uint256 start;\r\n        uint256 level;\r\n        uint256 maxDeposit;\r\n        uint256 totalDeposit;\r\n        uint256 directsNum;\r\n        uint256 teamNum;\r\n        uint256 maxDirectDeposit;\r\n        uint256 teamTotalDeposit;\r\n        uint256 totalFreezed;\r\n        uint256 totalRevenue;\r\n    }\r\n\r\n    mapping (address => UserInfo) public userInfo;\r\n\r\n    struct RewardInfo\r\n    {\r\n        uint256 capitals;\r\n        uint256 statics;\r\n        uint256 directs;\r\n        uint256 level2Income;\r\n        uint256 level3_6Income;\r\n        uint256 level7_10Income;\r\n        uint256 level11_14Income;\r\n        uint256 top;\r\n        uint256 totalWithdrawlsBUSD;\r\n        uint256 totalWithdrawlsJUTTO;\r\n    }\r\n\r\n    mapping (address => RewardInfo) public rewardInfo;\r\n\r\n    struct OrderInfo\r\n    {\r\n        uint256 amount; \r\n        uint256 start;\r\n        uint256 unfreeze; \r\n        bool isUnfreezed;\r\n        uint256 statics;\r\n        bool isRewarded;\r\n    }\r\n\r\n    mapping (address => OrderInfo[]) public orderInfos;\r\n\r\n\r\n    struct CTOInfo \r\n    {\r\n        uint256 level2CTO;\r\n        uint256 level3CTO;\r\n        uint256 level4CTO;\r\n        uint256 level5CTO;\r\n    }\r\n\r\n    mapping (address => CTOInfo) public CTO;\r\n    mapping (address => bool) public eligibleL2;\r\n    mapping (address => bool) public eligibleL3;\r\n    mapping (address => bool) public eligibleL4;\r\n    mapping (address => bool) public eligibleL5;\r\n\r\n    mapping (uint256 => mapping (address => uint256)) public userLayer1DayDeposit;\r\n    mapping (address => mapping (uint256 => address[])) public teamUsers;\r\n\r\n\r\n    mapping (address => bool) private isAlreadyDeposited;\r\n    mapping (uint256 => uint256) public dailyDistributedTime;\r\n\r\n    mapping (uint256 => address[3]) public dayTopUsers;\r\n    mapping (uint256=>bool) public balStatus;\r\n\r\n\r\n    event Register(address user, address referral);\r\n    event Deposit(address user, uint256 amount);\r\n    event DepositBySplit(address user, uint256 amount);\r\n    event TransferBySplit(address user, address receiver, uint256 amount);\r\n    event Withdraw(address user, uint256 withdrawable);\r\n\r\n\r\n    constructor()\r\n    {\r\n        BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n        JUTTO = IERC20(0xd3C93C8de541a3dABeE4CBD2d2403dc3521F2dBF);\r\n        feeReceivers = [0x3b584384062D4F2F33aC133Dcae2B8592436688d , 0x20661D6498Be104AF56e2911A14CfC006fFf2D4A , 0xEE71cEC512Bd6f567a644f9fbd21790737183c4E ];\r\n        startTime = block.timestamp;\r\n        lastDistribute = block.timestamp;\r\n        defaultRefer = 0x2e82128206d800Af79DE383DAdDf30bf0b4C8fcc;\r\n    }\r\n\r\n    function register(address _referral)\r\n    external\r\n    {\r\n        require(userInfo[_referral].totalDeposit > 0 || _referral == defaultRefer, \" invalid refer \");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        require(user.referrer == address(0), \" referrer bonded \");\r\n        user.referrer = _referral;\r\n        userInfo[user.referrer].directsNum = userInfo[user.referrer].directsNum.add(1) ;\r\n        user.start = block.timestamp;\r\n        _updateTeamNum(msg.sender);\r\n        totalUser = totalUser.add(1);\r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n    function packagePriceJutto(uint256 package)\r\n    private\r\n    view\r\n    returns(uint256)\r\n    {   return package.div(tokenper);   }\r\n\r\n    function juttoDeposit(uint256 _tokenAmount, address _tokenAddress)\r\n    private\r\n    {\r\n        require(!isAlreadyDeposited[msg.sender], \" Already Deposited \");\r\n        uint256 newAmount = _tokenAmount;\r\n        JUTTO.transferFrom(msg.sender, address(this), packagePriceJutto(_tokenAmount));\r\n        isAlreadyDeposited[msg.sender] = true;\r\n        _deposit(msg.sender, newAmount, _tokenAddress);\r\n    }\r\n\r\n    function busdDeposit(uint256 _tokenAmount, address _tokenAddress)\r\n    private\r\n    {\r\n        BUSD.transferFrom(msg.sender, address(this), _tokenAmount);\r\n        isAlreadyDeposited[msg.sender] = true;\r\n        _deposit(msg.sender, _tokenAmount, _tokenAddress);\r\n    }\r\n\r\n    function deposit(address _tokenAddress, uint256 _tokenAmount)\r\n    external\r\n    {\r\n        require(_tokenAmount > 0,\"Ent mul of 50\");\r\n        if(IERC20(_tokenAddress) == JUTTO )\r\n        {   juttoDeposit(_tokenAmount, _tokenAddress);    }\r\n        else\r\n        {   busdDeposit(_tokenAmount, _tokenAddress);     }\r\n        emit Deposit(msg.sender, _tokenAmount);\r\n    }\r\n\r\n    function Withdrawal()\r\n    external\r\n    {\r\n        distributeRewards();\r\n\r\n        (uint256 staticTotalBUSDReward, uint256 staticTotalJUTTOReward) = _calCurStaticRewards(msg.sender);\r\n        uint256 withdrawableBUSD = staticTotalBUSDReward;\r\n        uint256 withdrawableJUTTO = staticTotalJUTTOReward;\r\n\r\n        (uint256 dynamicTotalBUSDReward, uint256 dynamicTotalJUTTOReward) = _calCurDynamicRewards(msg.sender);\r\n        (uint256 CTOTotalBUSDReward, uint256 CTOTotalJUTTOReward) = _calCurAllCTO(msg.sender);\r\n\r\n        withdrawableBUSD = withdrawableBUSD.add(dynamicTotalBUSDReward).add(CTOTotalBUSDReward);\r\n        withdrawableJUTTO = (withdrawableJUTTO.add(dynamicTotalJUTTOReward).add(CTOTotalJUTTOReward)).div(tokenper);\r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n\r\n        withdrawableBUSD = withdrawableBUSD.add(userRewards.capitals);\r\n\r\n        BUSD.transfer(msg.sender, withdrawableBUSD);\r\n        JUTTO.transfer(msg.sender, withdrawableJUTTO);\r\n\r\n        userRewards.directs = 0;\r\n        userRewards.level2Income = 0;\r\n        userRewards.level3_6Income = 0;\r\n        userRewards.level7_10Income = 0;\r\n        userRewards.level11_14Income = 0;\r\n\r\n        userRewards.statics = 0;\r\n        userRewards.capitals = 0;\r\n        userRewards.top = 0;\r\n\r\n        userRewards.totalWithdrawlsBUSD += withdrawableBUSD;\r\n        userRewards.totalWithdrawlsJUTTO += withdrawableJUTTO;\r\n\r\n        CTO[msg.sender].level2CTO = 0;\r\n        CTO[msg.sender].level3CTO = 0;\r\n        CTO[msg.sender].level4CTO = 0;\r\n        CTO[msg.sender].level5CTO = 0;\r\n\r\n    }\r\n\r\n    function getCurDay()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {       return (block.timestamp.sub(startTime)).div(timeStep);      }\r\n\r\n    function getTeamUsersLength(address _user, uint256 _layer)\r\n    external\r\n    view\r\n    returns(uint256)\r\n    {   return teamUsers[_user][_layer].length;     }\r\n\r\n    function getOrderLength(address _user)\r\n    external\r\n    view\r\n    returns(uint256)\r\n    {       return orderInfos[_user].length;        }\r\n\r\n    function getDepositorsLength()\r\n    external\r\n    view\r\n    returns(uint256)\r\n    {       return depositors.length;       }\r\n\r\n    function getMaxFreezing(address _user)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 maxFreezing;\r\n        for(uint256 i = orderInfos[_user].length; i > 0; i--){\r\n            OrderInfo storage order = orderInfos[_user][i - 1];\r\n            if(order.unfreeze > block.timestamp){\r\n                if(order.amount > maxFreezing){\r\n                    maxFreezing = order.amount;\r\n                }\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n        return maxFreezing;\r\n    }\r\n\r\n    function getTeamDeposit(address _user)\r\n    public\r\n    view\r\n    returns(uint256,uint256,uint256)\r\n    {\r\n        uint256 totalTeam;\r\n        uint256 maxTeam;\r\n        uint256 otherTeam;\r\n        for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\r\n            uint256 userTotalTeam = userInfo[teamUsers[_user][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_user][0][i]].totalDeposit);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam > maxTeam)\r\n            {\r\n                maxTeam = userTotalTeam;\r\n            }\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n        return(maxTeam,otherTeam,totalTeam);\r\n    }\r\n\r\n\r\n    function _calCurAllCTO(address _user)\r\n    public\r\n    view\r\n    returns(uint256,uint256)\r\n    {\r\n        uint256 allCTO = CTO[_user].level2CTO.add(CTO[_user].level3CTO).add(CTO[_user].level4CTO).add(CTO[_user].level5CTO);\r\n        uint256 withdrawableJUTTO = allCTO.mul(ROIpercents).div(baseDivider);\r\n        uint256 withdrawableBUSD = allCTO.sub(withdrawableJUTTO);\r\n        return(withdrawableBUSD, withdrawableJUTTO);\r\n    }\r\n\r\n\r\n\r\n    function _calCurStaticRewards(address _user)\r\n    private\r\n    view\r\n    returns(uint256,uint256)\r\n    {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        uint256 totalRewards = userRewards.statics;\r\n        uint256 withdrawableJUTTO = totalRewards.mul(ROIpercents).div(baseDivider);\r\n        uint256 withdrawableBUSD = totalRewards.sub(withdrawableJUTTO);\r\n        return(withdrawableBUSD, withdrawableJUTTO);\r\n    }\r\n\r\n    function _calCurDynamicRewards(address _user)\r\n    private\r\n    view\r\n    returns(uint256,uint256)\r\n    {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        uint256 totalRewards = userRewards.directs.add(userRewards.level2Income).add(userRewards.level3_6Income).\r\n        add(userRewards.level7_10Income).add(userRewards.level11_14Income).add(userRewards.top);\r\n        uint256 withdrawableJUTTO = totalRewards.mul(ROIpercents).div(baseDivider);\r\n        uint256 withdrawableBUSD = totalRewards.sub(withdrawableJUTTO);\r\n        return(withdrawableBUSD, withdrawableJUTTO);\r\n    }\r\n\r\n\r\n    function _updateTeamNum(address _user)\r\n    private\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\r\n                teamUsers[upline][i].push(_user);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function _updateTopUser(address _user, uint256 _amount, uint256 _dayNow)\r\n    private\r\n    {\r\n        userLayer1DayDeposit[_dayNow][_user] = userLayer1DayDeposit[_dayNow][_user].add(_amount);\r\n        bool updated;\r\n        for(uint256 i = 0; i < 3; i++){\r\n            address topUser = dayTopUsers[_dayNow][i];\r\n            if(topUser == _user){\r\n                _reOrderTop(_dayNow);\r\n                updated = true;\r\n                break;\r\n            }\r\n        }\r\n        if(!updated){\r\n            address lastUser = dayTopUsers[_dayNow][2];\r\n            if(userLayer1DayDeposit[_dayNow][lastUser] < userLayer1DayDeposit[_dayNow][_user]){\r\n                dayTopUsers[_dayNow][2] = _user;\r\n                _reOrderTop(_dayNow);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _reOrderTop(uint256 _dayNow)\r\n    private\r\n    {\r\n        for(uint256 i = 3; i > 1; i--){\r\n            address topUser1 = dayTopUsers[_dayNow][i - 1];\r\n            address topUser2 = dayTopUsers[_dayNow][i - 2];\r\n            uint256 amount1 = userLayer1DayDeposit[_dayNow][topUser1];\r\n            uint256 amount2 = userLayer1DayDeposit[_dayNow][topUser2];\r\n            if(amount1 > amount2){\r\n                dayTopUsers[_dayNow][i - 1] = topUser2;\r\n                dayTopUsers[_dayNow][i - 2] = topUser1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _removeInvalidDeposit(address _user, uint256 _amount)\r\n    private\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                if(userInfo[upline].teamTotalDeposit > _amount){\r\n                    userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.sub(_amount);\r\n                }else{\r\n                    userInfo[upline].teamTotalDeposit = 0;\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateReferInfo(address _user, uint256 _amount)\r\n    private\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.add(_amount);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function checkLevel2(address _address)\r\n    private\r\n    view\r\n    returns(bool,uint256)\r\n    {\r\n        for (uint256 i = 0; i < level2.length; i++)\r\n        {\r\n            if (_address == level2[i])\r\n            {   return (true,i);    } \r\n        }\r\n        return (false,0);\r\n    }\r\n\r\n    function checkLevel3(address _address)\r\n    private\r\n    view\r\n    returns(bool,uint256)\r\n    {\r\n        for (uint256 i = 0; i < level3.length; i++)\r\n        {\r\n            if (_address == level3[i])\r\n            {   return (true,i);    } \r\n        }\r\n        return (false,0);\r\n    }\r\n\r\n    function checkLevel4(address _address)\r\n    private\r\n    view\r\n    returns(bool,uint256)\r\n    {\r\n        for (uint256 i = 0; i < level4.length; i++)\r\n        {\r\n            if (_address == level4[i])\r\n            {   return (true,i);    } \r\n        }\r\n        return (false,0);\r\n    }\r\n\r\n    function checkLevel5(address _address)\r\n    private\r\n    view\r\n    returns(bool,uint256)\r\n    {\r\n        for (uint256 i = 0; i < level5.length; i++)\r\n        {\r\n            if (_address == level5[i])\r\n            {   return (true,i);    } \r\n        }\r\n        return (false,0);\r\n    }\r\n\r\n\r\n    function getAvailablity(address _user)\r\n    public\r\n    view\r\n    returns(bool,bool,bool,bool)\r\n    {\r\n        (bool _isAvailable5,) = checkLevel5(_user);\r\n        (bool _isAvailable4,) = checkLevel4(_user);\r\n        (bool _isAvailable3,) = checkLevel3(_user);\r\n        (bool _isAvailable2,) = checkLevel2(_user);\r\n        return(_isAvailable5,_isAvailable4,_isAvailable3,_isAvailable2);\r\n    }\r\n\r\n\r\n    function _updateLevel(address _user)\r\n    private\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 levelNow = _calLevelNow(_user);\r\n        if(levelNow > user.level){\r\n            user.level = levelNow;\r\n\r\n            (bool _isAvailable5,bool _isAvailable4,bool _isAvailable3,bool _isAvailable2)=getAvailablity(_user);\r\n\r\n            if(!_isAvailable5 && levelNow == 5)\r\n            {\r\n                level5.push(_user);\r\n                eligibleL5[_user] = true;\r\n                eligibleL4[_user] = false;\r\n                eligibleL3[_user] = false;\r\n                eligibleL2[_user] = false;\r\n            }\r\n\r\n            else\r\n            if(!_isAvailable4 && levelNow == 4)\r\n            {    level4.push(_user);\r\n                eligibleL4[_user] = true;\r\n                eligibleL3[_user] = false;\r\n                eligibleL2[_user] = false;\r\n            }\r\n\r\n            else\r\n            if(!_isAvailable3 && levelNow == 3)\r\n            {    level3.push(_user);\r\n                eligibleL3[_user] = true;\r\n                eligibleL2[_user] = false;\r\n            }\r\n\r\n            else\r\n            if(!_isAvailable2 && levelNow == 2)\r\n            {    level2.push(_user);\r\n                eligibleL2[_user] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _calLevelNow(address _user)\r\n    private\r\n    view\r\n    returns(uint256)\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 total = user.totalDeposit;\r\n        uint256 levelNow;\r\n\r\n        if(total >= 200e18){\r\n        (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_user);\r\n\r\n            if(total >= 2000e18 && user.teamNum >= 500 && user.directsNum >= 8 && maxTeam >= 50000e18 && otherTeam >= 50000e18){\r\n                levelNow = 5;\r\n            }else if(total >= 1000e18 && user.teamNum >= 200 && user.directsNum >= 7 && maxTeam >= 25000e18 && otherTeam >= 25000e18){\r\n                levelNow = 4;\r\n            }else if(total >= 500e18 && user.teamNum >= 50 && user.directsNum >= 6 && maxTeam >= 10000e18 && otherTeam >= 10000e18){\r\n                levelNow = 3;\r\n            }else if(total >= 200e18 && user.teamNum >= 10 && user.directsNum >= 5 && maxTeam >= 1000e18 && otherTeam >= 1000e18){\r\n            levelNow = 2;}\r\n        }\r\n        else if(total >= 50e18)\r\n        {   levelNow = 1;   }\r\n        \r\n        return levelNow;\r\n    }\r\n\r\n\r\n    function _deposit(address _user, uint256 _amount, address _tokenAddress)\r\n    private\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n        require(user.referrer != address(0), \"register first\");\r\n        require(_amount >= minDeposit, \"less than min\");\r\n        require(_amount <= maxDeposit, \"amount exceeds\");\r\n        require(_amount.mod(minDeposit) == 0 && _amount >= minDeposit, \"mod err\");\r\n        require(user.maxDeposit == 0 || _amount >= user.maxDeposit, \"less before\");\r\n\r\n        if(user.maxDeposit == 0){\r\n            user.maxDeposit = _amount;\r\n        }else if(user.maxDeposit < _amount){\r\n            user.maxDeposit = _amount;\r\n        }\r\n\r\n        DailyPool = DailyPool.add(_amount);\r\n\r\n        _distributeDeposit(_amount, _tokenAddress);\r\n\r\n        if(user.totalDeposit == 0){\r\n            uint256 dayNow = getCurDay();\r\n            _updateTopUser(user.referrer, _amount, dayNow);\r\n        }\r\n\r\n        depositors.push(_user);\r\n        \r\n        user.totalDeposit = user.totalDeposit.add(_amount);\r\n        user.totalFreezed = user.totalFreezed.add(_amount);\r\n\r\n        _updateLevel(_user);\r\n\r\n        uint256 addFreeze = (orderInfos[_user].length.div(2)).mul(timeStep);\r\n        if(addFreeze > maxAddFreeze){\r\n            addFreeze = maxAddFreeze;\r\n        }\r\n        uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\r\n        orderInfos[_user].push(OrderInfo(\r\n            _amount, \r\n            block.timestamp, \r\n            unfreezeTime,\r\n            false,\r\n            0,\r\n            false\r\n        ));\r\n\r\n        _unfreezeFundAndUpdateReward(msg.sender, _amount);\r\n        _updateReferInfo(msg.sender, _amount);\r\n        _updateReward(msg.sender, _amount);\r\n\r\n        distributeRewards();\r\n\r\n        uint256 bal = BUSD.balanceOf(address(this));\r\n        _balActived(bal);\r\n        if(isFreezeReward){\r\n            _setFreezeReward(bal);\r\n        }\r\n    }\r\n\r\n\r\n    function distributeRewards()\r\n    public\r\n    {\r\n        if(block.timestamp > lastDistribute.add(timeStep))\r\n        {\r\n            level5BalanceDistribution_();  \r\n            level4BalanceDistribution_();  \r\n            level3BalanceDistribution_();  \r\n            level2BalanceDistribution_();\r\n\r\n            uint256 dayNow = getCurDay();\r\n            _distributetopPool(dayNow);\r\n            lastDistribute = block.timestamp;\r\n            dailyDistributedTime[dayNow] = DailyPool ;\r\n            DailyPool = 0;\r\n        }\r\n    }\r\n\r\n\r\n    function _distributetopPool(uint256 _dayNow)\r\n    private\r\n    {\r\n        uint16[3] memory rates = [5000, 3000, 2000];\r\n        uint72[3] memory maxReward = [2000e18, 1000e18, 500e18];\r\n\r\n        for(uint256 i = 0; i < 3; i++){\r\n            address userAddr = dayTopUsers[_dayNow - 1][i];\r\n            if(userAddr != address(0)){\r\n                uint256 levelDistribution = (DailyPool.mul(topPoolShare)).div(baseDivider);\r\n                uint256 reward = levelDistribution.mul(rates[i]).div(baseDivider);\r\n                if(reward > maxReward[i]){\r\n                    reward = maxReward[i];\r\n                }\r\n                rewardInfo[userAddr].top = rewardInfo[userAddr].top.add(reward);\r\n                userInfo[userAddr].totalRevenue = userInfo[userAddr].totalRevenue.add(reward);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function level5BalanceDistribution_()\r\n    private\r\n    {\r\n        uint256 level5Count;\r\n        for(uint256 i = 0; i < level5.length; i++){\r\n            if(userInfo[level5[i]].level == 5 && eligibleL5[level5[i]]){\r\n                level5Count = level5Count.add(1);\r\n            }\r\n        }\r\n        if(level5Count > 0){\r\n            uint256 levelDistribution = (DailyPool.mul(level5Share)).div(baseDivider);\r\n            uint256 reward = levelDistribution.div(level5Count);\r\n            for(uint256 i = 0; i < level5.length; i++){\r\n                if(userInfo[level5[i]].level == 5 && eligibleL5[level5[i]]){\r\n                    CTO[level5[i]].level5CTO = CTO[level5[i]].level5CTO.add(reward);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function level4BalanceDistribution_()\r\n    private\r\n    {\r\n        uint256 level4Count;\r\n        for(uint256 i = 0; i < level4.length; i++){\r\n            if(userInfo[level4[i]].level == 4 && eligibleL4[level4[i]]){\r\n                level4Count = level4Count.add(1);\r\n            }\r\n        }\r\n        if(level4Count > 0){\r\n            uint256 levelDistribution = (DailyPool.mul(level4Share)).div(baseDivider);\r\n            uint256 reward = levelDistribution.div(level4Count);\r\n            for(uint256 i = 0; i < level4.length; i++){\r\n                if(userInfo[level4[i]].level == 4 && eligibleL4[level4[i]]){\r\n                    CTO[level4[i]].level4CTO = CTO[level4[i]].level4CTO.add(reward);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function level3BalanceDistribution_()\r\n    private\r\n    {\r\n        uint256 level3Count;\r\n        for(uint256 i = 0; i < level3.length; i++){\r\n            if(userInfo[level3[i]].level == 3 && eligibleL3[level3[i]]){\r\n                level3Count = level3Count.add(1);\r\n            }\r\n        }\r\n        if(level3Count > 0){\r\n            uint256 levelDistribution = (DailyPool.mul(level3Share)).div(baseDivider);\r\n            uint256 reward = levelDistribution.div(level3Count);\r\n            for(uint256 i = 0; i < level3.length; i++){\r\n                if(userInfo[level3[i]].level == 3 && eligibleL3[level3[i]]){\r\n                    CTO[level3[i]].level3CTO = CTO[level3[i]].level3CTO.add(reward);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function level2BalanceDistribution_()\r\n    private\r\n    {\r\n        uint256 level2Count;\r\n        for(uint256 i = 0; i < level2.length; i++){\r\n            if(userInfo[level2[i]].level == 2 && eligibleL2[level2[i]]){\r\n                level2Count = level2Count.add(1);\r\n            }\r\n        }\r\n        if(level2Count > 0){\r\n            uint256 levelDistribution = (DailyPool.mul(level2Share)).div(baseDivider);\r\n            uint256 reward = levelDistribution.div(level2Count);\r\n            for(uint256 i = 0; i < level2.length; i++){\r\n                if(userInfo[level2[i]].level == 2 && eligibleL2[level2[i]]){\r\n                    CTO[level2[i]].level2CTO = CTO[level2[i]].level2CTO.add(reward);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function _unfreezeFundAndUpdateReward(address _user, uint256 _amount)\r\n    private\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n        bool isUnfreezeCapital;\r\n        uint256 staticReward;\r\n\r\n        for(uint256 i = 0; i < orderInfos[_user].length; i++){\r\n            OrderInfo storage order = orderInfos[_user][i];\r\n            if(block.timestamp > order.unfreeze  && order.isUnfreezed == false && _amount >= order.amount)\r\n            {\r\n                order.isUnfreezed = true;\r\n                isUnfreezeCapital = true;\r\n                \r\n                if(user.totalFreezed > order.amount){\r\n                    user.totalFreezed = user.totalFreezed.sub(order.amount);\r\n                }else{\r\n                    user.totalFreezed = 0;\r\n                }\r\n                \r\n                _removeInvalidDeposit(_user, order.amount);\r\n\r\n                staticReward = (order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDivider)).div(1e18);\r\n                \r\n                order.statics = staticReward;\r\n               \r\n                if(isFreezeReward) {\r\n                    if(user.totalFreezed > user.totalRevenue) {\r\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\r\n                        if(staticReward > leftCapital) {\r\n                            staticReward = leftCapital;\r\n                        }\r\n                    }else{\r\n                        staticReward = 0;\r\n                    }\r\n                }\r\n                rewardInfo[_user].capitals = rewardInfo[_user].capitals.add(order.amount);\r\n                rewardInfo[_user].statics = rewardInfo[_user].statics.add(staticReward);\r\n                user.totalRevenue = user.totalRevenue.add(staticReward);\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _calculateDepositReward(uint256 pacakage)\r\n    private\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 amount = packagePriceJutto(pacakage).mul(1e18);\r\n        uint256 fee = amount.mul(feePercents).div(baseDivider);\r\n        packagePriceJutto(pacakage);\r\n        return fee.div(1e18);\r\n    }\r\n\r\n    function _distributeDeposit(uint256 _amount, address _tokenAddress)\r\n    private\r\n    {\r\n        uint256 fee = _amount.mul(feePercents).div(baseDivider);\r\n        if(BUSD == IERC20(_tokenAddress)){\r\n            BUSD.transfer(feeReceivers[0], fee.div(2));\r\n            BUSD.transfer(feeReceivers[1], fee.div(2));\r\n            BUSD.transfer(feeReceivers[2], fee);\r\n        }\r\n        else{\r\n            fee = _calculateDepositReward(_amount);\r\n            JUTTO.transfer(feeReceivers[0], fee.div(2));\r\n            JUTTO.transfer(feeReceivers[1], fee.div(2));\r\n            JUTTO.transfer(feeReceivers[2], fee);\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    function _updateReward(address _user, uint256 _amount)\r\n    private\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 1; i <= referDepth; i++){\r\n            if(upline != address(0)){\r\n                uint256 newAmount = _amount;\r\n                if(upline != defaultRefer){\r\n                    uint256 maxFreezing = getMaxFreezing(upline);\r\n                    if(maxFreezing < _amount){\r\n                        newAmount = maxFreezing;\r\n                    }\r\n                }\r\n                RewardInfo storage upRewards = rewardInfo[upline];\r\n                uint256 reward;\r\n                if(i >= 11){\r\n                    if(userInfo[upline].level > 4){\r\n                        reward = newAmount.mul(level11_14Percents).div(baseDivider);\r\n                        upRewards.level11_14Income = upRewards.level11_14Income.add(reward);\r\n                    }\r\n                }else if(i >= 7 ){\r\n                    if( userInfo[upline].level > 3){\r\n                        reward =  newAmount.mul(level7_10Percents).div(baseDivider);\r\n                        upRewards.level7_10Income = upRewards.level7_10Income.add(reward);\r\n                    }\r\n                }\r\n                else if(i >= 3){\r\n                    if( userInfo[upline].level > 2){\r\n                        reward =  newAmount.mul(level3_6Percents).div(baseDivider);\r\n                        upRewards.level3_6Income = upRewards.level3_6Income.add(reward);\r\n                    }\r\n                }\r\n                else if(i >= 2){\r\n                    if( userInfo[upline].level > 1){\r\n                        reward =  newAmount.mul(level2Percents).div(baseDivider);\r\n                        upRewards.level2Income = upRewards.level2Income.add(reward);\r\n                    }\r\n                }\r\n                else{\r\n                    reward =  newAmount.mul(directPercents).div(baseDivider);\r\n                    upRewards.directs = upRewards.directs.add(reward);\r\n                    userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _balActived(uint256 _bal)\r\n    private\r\n    {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(_bal >= balDown[i - 1]){\r\n                balStatus[balDown[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function _setFreezeReward(uint256 _bal)\r\n    private\r\n    {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(balStatus[balDown[i - 1]]){\r\n                uint256 maxDown = balDown[i - 1].mul(balDownRate[i - 1]).div(baseDivider);\r\n                if(_bal < balDown[i - 1].sub(maxDown)){\r\n                    isFreezeReward = true;\r\n                }else if(isFreezeReward && _bal >= balRecover[i - 1]){\r\n                    isFreezeReward = false;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    ////////////////////////// OWNER FUCNTION ////////////////////\r\n    function JuttoPrice(uint256 _price)\r\n    public\r\n    onlyOwner\r\n    {       tokenper = _price;      }\r\n\r\n    function Split(address Address, uint256 _splitamount)\r\n    public\r\n    onlyOwner\r\n    {\r\n        if(IERC20(Address) == JUTTO )\r\n        {   JUTTO.transfer(owner(),_splitamount);     }\r\n        else\r\n        {    BUSD.transfer(owner(),_splitamount);     }\r\n    }\r\n\r\n    /////////////////// CHECK HOW MANY PLAYERS IN ANY RANK /////////////////\r\n    function checkRankScorerLength() public view returns(uint256){\r\n        return level2.length;\r\n    }\r\n    function checkRankAllRounderLength() public view returns(uint256){\r\n        return level3.length;\r\n    }\r\n    function checkRankViceCaptainLength() public view returns(uint256){\r\n        return level4.length;\r\n    }\r\n    function checkRankCaptainLength() public view returns(uint256){\r\n        return level5.length;\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"CTO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"level2CTO\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level3CTO\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level4CTO\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5CTO\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DailyPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"JUTTO\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"JuttoPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_splitamount\",\"type\":\"uint256\"}],\"name\":\"Split\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Withdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"_calCurAllCTO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkRankAllRounderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkRankCaptainLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkRankScorerLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkRankViceCaptainLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyDistributedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayTopUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"eligibleL2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"eligibleL3\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"eligibleL4\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"eligibleL5\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeReceivers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAvailablity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositorsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxFreezing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFreezeReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"level2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"level3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"level4\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"level5\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRewarded\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level2Income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level3_6Income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level7_10Income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level11_14Income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawlsBUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawlsJUTTO\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directsNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDirectDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLayer1DayDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "JSG", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f573dd30e84558fc69af7d4d003cfa8aadc140b1cc6493c7e15bb819404b3901"}