{"SourceCode": "// File: contracts/interfaces/IERC20.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IPancakeV3Factory.sol\r\n\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/// @title The interface for the PancakeSwap V3 Factory\r\n/// @notice The PancakeSwap V3 Factory facilitates creation of PancakeSwap V3 pools and control over the protocol fees\r\ninterface IPancakeV3Factory {\r\n    struct TickSpacingExtraInfo {\r\n        bool whitelistRequested;\r\n        bool enabled;\r\n    }\r\n\r\n    /// @notice Emitted when the owner of the factory is changed\r\n    /// @param oldOwner The owner before the owner was changed\r\n    /// @param newOwner The owner after the owner was changed\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @notice Emitted when a pool is created\r\n    /// @param token0 The first token of the pool by address sort order\r\n    /// @param token1 The second token of the pool by address sort order\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\r\n    /// @param pool The address of the created pool\r\n    event PoolCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        uint24 indexed fee,\r\n        int24 tickSpacing,\r\n        address pool\r\n    );\r\n\r\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip\r\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\r\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\r\n\r\n    event FeeAmountExtraInfoUpdated(uint24 indexed fee, bool whitelistRequested, bool enabled);\r\n\r\n    event WhiteListAdded(address indexed user, bool verified);\r\n\r\n    /// @notice Emitted when LM pool deployer is set\r\n    event SetLmPoolDeployer(address indexed lmPoolDeployer);\r\n\r\n    /// @notice Returns the current owner of the factory\r\n    /// @dev Can be changed by the current owner via setOwner\r\n    /// @return The address of the factory owner\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\r\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\r\n    /// @return The tick spacing\r\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\r\n\r\n    /// @notice Returns the tick spacing extra info\r\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\r\n    /// @return whitelistRequested The flag whether should be created by white list users only\r\n    function feeAmountTickSpacingExtraInfo(uint24 fee) external view returns (bool whitelistRequested, bool enabled);\r\n\r\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\r\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n    /// @param tokenA The contract address of either token0 or token1\r\n    /// @param tokenB The contract address of the other token\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @return pool The pool address\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n\r\n    /// @notice Creates a pool for the given two tokens and fee\r\n    /// @param tokenA One of the two tokens in the desired pool\r\n    /// @param tokenB The other of the two tokens in the desired pool\r\n    /// @param fee The desired fee for the pool\r\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\r\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\r\n    /// are invalid.\r\n    /// @return pool The address of the newly created pool\r\n    function createPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external returns (address pool);\r\n\r\n    /// @notice Updates the owner of the factory\r\n    /// @dev Must be called by the current owner\r\n    /// @param _owner The new owner of the factory\r\n    function setOwner(address _owner) external;\r\n\r\n    /// @notice Enables a fee amount with the given tickSpacing\r\n    /// @dev Fee amounts may never be removed once enabled\r\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\r\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\r\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\r\n\r\n    /// @notice Set an address into white list\r\n    /// @dev Address can be updated by owner with boolean value false\r\n    /// @param user The user address that add into white list\r\n    function setWhiteListAddress(address user, bool verified) external;\r\n\r\n    /// @notice Set a fee amount extra info\r\n    /// @dev Fee amounts can be updated by owner with extra info\r\n    /// @param whitelistRequested The flag whether should be created by owner only\r\n    /// @param enabled The flag is the fee is enabled or not\r\n    function setFeeAmountExtraInfo(\r\n        uint24 fee,\r\n        bool whitelistRequested,\r\n        bool enabled\r\n    ) external;\r\n\r\n    function setLmPoolDeployer(address _lmPoolDeployer) external;\r\n\r\n    function setFeeProtocol(address pool, uint32 feeProtocol0, uint32 feeProtocol1) external;\r\n\r\n    function collectProtocol(\r\n        address pool,\r\n        address recipient,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n    function setLmPool(address pool, address lmPool) external;\r\n}\r\n// File: @pancakeswap/v3-core/contracts/interfaces/callback/IPancakeV3SwapCallback.sol\r\n\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Callback for IPancakeV3PoolActions#swap\r\n/// @notice Any contract that calls IPancakeV3PoolActions#swap must implement this interface\r\ninterface IPancakeV3SwapCallback {\r\n    /// @notice Called to `msg.sender` after executing a swap via IPancakeV3Pool#swap.\r\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n    /// The caller of this method must be checked to be a PancakeV3Pool deployed by the canonical PancakeV3Factory.\r\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n    /// @param data Any data passed through by the caller via the IPancakeV3PoolActions#swap call\r\n    function pancakeV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts/interfaces/IV3SwapRouter.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via PancakeSwap V3\r\ninterface IV3SwapRouter is IPancakeV3SwapCallback {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// that may remain in the router after the swap.\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// that may remain in the router after the swap.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n}\r\n// File: contracts/Staking.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ncontract Staking {\r\n  address owner;\r\n\r\n  mapping(bytes32 => address) public whitelistedTokens;\r\n  mapping(bytes32 => address) public receivedTokens;\r\n  mapping(address => mapping(bytes32 => uint256)) public accountBalances;\r\n  address private constant PANCAKE_FACTORY =0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865;\r\n  address private constant PANCAKE_ROUTER =0x13f4EA83D0bd40E75C8222255bc855a974568Dd4;\r\n  uint256 private deadline = block.timestamp + 1 days;\r\n  uint256 private constant MAX_INT =115792089237316195423570985008687907853269984665640564039457584007913129639935;\r\n  constructor()  {\r\n    owner = msg.sender;\r\n    \r\n  }\r\n\r\n  function whitelistToken(bytes32 symbol, address tokenAddress) external {\r\n    require(msg.sender == owner, \"This function is not public\");\r\n    whitelistedTokens[symbol] = tokenAddress;\r\n  }\r\n  function setReceivedToken(bytes32 symbol, address tokenAddress) external {\r\n    require(msg.sender == owner, \"This function is not public\");\r\n    receivedTokens[symbol] = tokenAddress;\r\n  }\r\n\r\n \r\n  function getWhitelistedTokenAddresses(bytes32 token) view  external returns(address) {\r\n    return whitelistedTokens[token];\r\n  }\r\n\r\n  function getReceivedTokenAddresses(bytes32 token) view  external returns(address) {\r\n    return receivedTokens[token];\r\n  }\r\n function placeTrade(address _fromToken,address _toToken,uint256 _amountIn,address _to) private returns(uint){\r\n        address pair = IPancakeV3Factory(PANCAKE_FACTORY).getPool(\r\n            _fromToken,\r\n            _toToken,\r\n            500\r\n        );\r\n        require(pair != address(0), \"Pool does not exist\");\r\n \r\n        // // Calculate Amount Out\r\n        // address[] memory path = new address[](2);\r\n        // path[0] = _fromToken;\r\n        // path[1] = _toToken;\r\n\r\n        IV3SwapRouter.ExactInputSingleParams memory params =\r\n                    IV3SwapRouter.ExactInputSingleParams({\r\n                        tokenIn: _fromToken,\r\n                        tokenOut: _toToken,\r\n                        fee: 500,\r\n                        recipient: _to,     \r\n                        amountIn: _amountIn,\r\n                        amountOutMinimum: 0,\r\n                        sqrtPriceLimitX96: 0\r\n                    });\r\n \r\n \r\n\r\n    \r\n        uint256 amountReceived = IV3SwapRouter(PANCAKE_ROUTER).exactInputSingle(params);\r\n\r\n\r\n        require(amountReceived > 0, \"Transaction Abort\");\r\n\r\n        return amountReceived;\r\n    }\r\n  function depositTokens(uint256 stakeAmount,uint256 amountIn, bytes32 symbolIn,bytes32 symbolOut) external {\r\n    require(stakeAmount > 0, \"Stake amount greater then 0\");\r\n    require(amountIn > 0, \"Trade amount greater then 0\");\r\n    uint256 tradAmount=placeTrade(receivedTokens[symbolIn], whitelistedTokens[symbolOut], amountIn,msg.sender);       \r\n    IERC20(whitelistedTokens[symbolOut]).transferFrom(msg.sender, address(this), tradAmount);\r\n    accountBalances[msg.sender][symbolOut] += stakeAmount;    \r\n  }\r\n\r\n  function withdrawTokens(uint256 amount, bytes32 symbol) external {\r\n    require(accountBalances[msg.sender][symbol] >= amount, \"Insufficent funds\");\r\n    accountBalances[msg.sender][symbol] -= amount;\r\n    IERC20(whitelistedTokens[symbol]).transfer(msg.sender, amount);\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"accountBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"symbolIn\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"symbolOut\",\"type\":\"bytes32\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"token\",\"type\":\"bytes32\"}],\"name\":\"getReceivedTokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"token\",\"type\":\"bytes32\"}],\"name\":\"getWhitelistedTokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"receivedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setReceivedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"whitelistToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"whitelistedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ae240b51d8ec5e33ef2abc43298162cf0cd4bd844bb50d4b7f8324f9ccc9c6ff"}