{"SourceCode": "/**\r\nDollar Beans official links:\r\nWebsite: https://harvtoken.com\r\nTelegram: https://t.me/\r\n\r\nOriginal contract (Baked Beans 2.0) was written by FrostFlakes Dev JackT: https://t.me/.\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = msgSender;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n      emit OwnershipTransferred(_owner, address(0));\r\n      _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\nlibrary Math {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a ** b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\npragma solidity 0.8.17;\r\n\r\ncontract HARV is Context, Ownable {\r\n\r\n    using Math for uint256;\r\n    address public OWNER_ADDRESS;\r\n    bool private initialized = false;\r\n    address USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public DEV_ADDRESS = 0x04061009DAb9ae0b87ae2f187a31819cb5C62fFA;\r\n    address public MARKETING_ADDRESS = 0x55489A14a293b05E0e99B7D5920c2C7ED9AAdBE8;\r\n    address public CEO_ADDRESS = 0xd3CBdB63Bd2755f720f0C52482839c989f31681E;\r\n    address public GIVEAWAY_ADDRESS = 0x7b3055955ED9f037f22c4ff73B656576F39928b2;\r\n    address _dev = DEV_ADDRESS;\r\n    address _marketing = MARKETING_ADDRESS;\r\n    address _ceo = CEO_ADDRESS;\r\n    address _giveAway = GIVEAWAY_ADDRESS;\r\n    address _owner = OWNER_ADDRESS;\r\n    uint136 BNB_PER_BEAN = 1000000000000;\r\n    uint32 SECONDS_PER_DAY = 86400;\r\n    uint8 DEPOSIT_FEE = 5;\r\n    uint8 AIRDROP_FEE = 1;\r\n    uint8 WITHDRAWAL_FEE = 5;\r\n    uint16 DEV_FEE = 10;\r\n    uint16 MARKETING_FEE = 19;\r\n    uint8 CEO_FEE = 66;\r\n    uint8 REF_BONUS = 5;\r\n    uint8 FIRST_DEPOSIT_REF_BONUS = 5;\r\n    uint256 MIN_DEPOSIT = 10 ether; // 10 USDT\r\n    uint256 MIN_BAKE = 1 ether; // 1 USDT\r\n    uint256 MAX_WALLET_TVL_IN_BNB = 100000 ether; // 100000 USDT\r\n    uint256 MAX_DAILY_REWARDS_IN_BNB = 6500 ether; // 6500 USDT\r\n    uint256 MIN_REF_DEPOSIT_FOR_BONUS = 150 ether; // 150 USDT\r\n\r\n    mapping(uint256 => address) public bakerAddress;\r\n    uint256 public totalBakers;\r\n\r\n    struct Baker {\r\n        address adr;\r\n        uint256 beans;\r\n        uint256 bakedAt;\r\n        uint256 ateAt;\r\n        address upline;\r\n        bool hasReferred;\r\n        address[] referrals;\r\n        address[] bonusEligibleReferrals;\r\n        uint256 firstDeposit;\r\n        uint256 totalDeposit;\r\n        uint256 totalPayout;\r\n    }\r\n\r\n    mapping(address => Baker) internal bakers;\r\n\r\n    event EmitBoughtBeans(\r\n        address indexed adr,\r\n        address indexed ref,\r\n        uint256 bnbamount,\r\n        uint256 beansFrom,\r\n        uint256 beansTo\r\n    );\r\n    event EmitBaked(\r\n        address indexed adr,\r\n        address indexed ref,\r\n        uint256 beansFrom,\r\n        uint256 beansTo\r\n    );\r\n    event EmitAte(\r\n        address indexed adr,\r\n        uint256 bnbToEat,\r\n        uint256 beansBeforeFee\r\n    );\r\n\r\n        constructor() {\r\n        OWNER_ADDRESS=msg.sender;\r\n    }\r\n\r\n    function user(address adr) public view returns (Baker memory) {\r\n        return bakers[adr];\r\n    }\r\n\r\n    function buyBeans(address ref, uint256 _amount) public {\r\n        require(initialized);\r\n        Baker storage baker = bakers[msg.sender];\r\n        Baker storage upline = bakers[ref];\r\n        require(\r\n            _amount >= MIN_DEPOSIT,\r\n            \"Deposit doesn't meet the minimum requirements\"\r\n        );\r\n        require(\r\n            Math.add(baker.totalDeposit, _amount) <= MAX_WALLET_TVL_IN_BNB,\r\n            \"Max total deposit reached\"\r\n        );\r\n        require(\r\n            ref == address(0) || ref == msg.sender || hasInvested(upline.adr),\r\n            \"Ref must be investor to set as upline\"\r\n        );\r\n        IERC20(USDT).transferFrom(msg.sender, address(this), _amount);\r\n        baker.adr = msg.sender;\r\n        uint256 beansFrom = baker.beans;\r\n\r\n        uint256 totalBnbFee = percentFromAmount(_amount, DEPOSIT_FEE);\r\n        uint256 bnbValue = Math.sub(_amount, totalBnbFee);\r\n        uint256 beansBought = bnbToBeans(bnbValue);\r\n\r\n        uint256 totalBeansBought = addBeans(baker.adr, beansBought);\r\n        baker.beans = totalBeansBought;\r\n\r\n        if (\r\n            !baker.hasReferred &&\r\n            ref != msg.sender &&\r\n            ref != address(0) &&\r\n            baker.upline != msg.sender\r\n        ) {\r\n            baker.upline = ref;\r\n            baker.hasReferred = true;\r\n\r\n            upline.referrals.push(msg.sender);\r\n            if (hasInvested(baker.adr) == false) {\r\n                uint256 refBonus = percentFromAmount(\r\n                    bnbToBeans(_amount),\r\n                    FIRST_DEPOSIT_REF_BONUS\r\n                );\r\n                upline.beans = addBeans(upline.adr, refBonus);\r\n            }\r\n        }\r\n\r\n        if (hasInvested(baker.adr) == false) {\r\n            baker.firstDeposit = block.timestamp;\r\n            bakerAddress[totalBakers] = baker.adr;\r\n            totalBakers++;\r\n        }\r\n\r\n        baker.totalDeposit = Math.add(baker.totalDeposit, _amount);\r\n        if (\r\n            baker.hasReferred &&\r\n            baker.totalDeposit >= MIN_REF_DEPOSIT_FOR_BONUS &&\r\n            refExists(baker.adr, baker.upline) == false\r\n        ) {\r\n            upline.bonusEligibleReferrals.push(msg.sender);\r\n        }\r\n\r\n        sendFees(totalBnbFee, 0);\r\n        handleBake(false);\r\n\r\n        emit EmitBoughtBeans(msg.sender, ref, _amount, beansFrom, baker.beans);\r\n    }\r\n\r\n    function refExists(\r\n        address ref,\r\n        address upline\r\n    ) private view returns (bool) {\r\n        for (\r\n            uint256 i = 0;\r\n            i < bakers[upline].bonusEligibleReferrals.length;\r\n            i++\r\n        ) {\r\n            if (bakers[upline].bonusEligibleReferrals[i] == ref) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function sendFees(uint256 totalFee, uint256 giveAway) private {\r\n        uint256 dev = percentFromAmount(totalFee, DEV_FEE);\r\n        uint256 marketing = percentFromAmount(totalFee, MARKETING_FEE);\r\n        uint256 ceo = percentFromAmount(totalFee, CEO_FEE);\r\n\r\n        IERC20(USDT).transfer(_dev, dev);\r\n        IERC20(USDT).transfer(_marketing, marketing);\r\n        IERC20(USDT).transfer(_ceo, ceo);\r\n\r\n        if (giveAway > 0) {\r\n            IERC20(USDT).transfer(_giveAway, giveAway);\r\n        }\r\n    }\r\n\r\n    function handleBake(bool onlyRebaking) private {\r\n        Baker storage baker = bakers[msg.sender];\r\n        require(maxTvlReached(baker.adr) == false, \"Total wallet TVL reached\");\r\n        require(hasInvested(baker.adr), \"Must be invested to bake\");\r\n        if (onlyRebaking == true) {\r\n            require(\r\n                beansToBnb(rewardedBeans(baker.adr)) >= MIN_BAKE,\r\n                \"Rewards must be equal or higher than 1 USDT to bake\"\r\n            );\r\n        }\r\n\r\n        uint256 beansFrom = baker.beans;\r\n        uint256 beansFromRewards = rewardedBeans(baker.adr);\r\n\r\n        uint256 totalBeans = addBeans(baker.adr, beansFromRewards);\r\n        baker.beans = totalBeans;\r\n        baker.bakedAt = block.timestamp;\r\n\r\n        emit EmitBaked(msg.sender, baker.upline, beansFrom, baker.beans);\r\n    }\r\n\r\n    function bake() public {\r\n        handleBake(true);\r\n    }\r\n\r\n    function eat() public {\r\n        Baker storage baker = bakers[msg.sender];\r\n        require(hasInvested(baker.adr), \"Must be invested to eat\");\r\n        require(\r\n            maxPayoutReached(baker.adr) == false,\r\n            \"You have reached max payout\"\r\n        );\r\n\r\n        uint256 beansBeforeFee = rewardedBeans(baker.adr);\r\n        uint256 beansInBnbBeforeFee = beansToBnb(beansBeforeFee);\r\n\r\n        uint256 totalBnbFee = percentFromAmount(\r\n            beansInBnbBeforeFee,\r\n            WITHDRAWAL_FEE\r\n        );\r\n\r\n        uint256 bnbToEat = Math.sub(beansInBnbBeforeFee, totalBnbFee);\r\n        uint256 forGiveAway = calcGiveAwayAmount(baker.adr, bnbToEat);\r\n        bnbToEat = addWithdrawalTaxes(baker.adr, bnbToEat);\r\n\r\n        if (\r\n            Math.add(beansInBnbBeforeFee, baker.totalPayout) >=\r\n            maxPayout(baker.adr)\r\n        ) {\r\n            bnbToEat = Math.sub(maxPayout(baker.adr), baker.totalPayout);\r\n            baker.totalPayout = maxPayout(baker.adr);\r\n        } else {\r\n            uint256 afterTax = addWithdrawalTaxes(\r\n                baker.adr,\r\n                beansInBnbBeforeFee\r\n            );\r\n            baker.totalPayout = Math.add(baker.totalPayout, afterTax);\r\n        }\r\n\r\n        baker.ateAt = block.timestamp;\r\n        baker.bakedAt = block.timestamp;\r\n\r\n        sendFees(totalBnbFee, forGiveAway);\r\n        IERC20(USDT).transfer(msg.sender, bnbToEat);\r\n\r\n        emit EmitAte(msg.sender, bnbToEat, beansBeforeFee);\r\n    }\r\n\r\n    function maxPayoutReached(address adr) public view returns (bool) {\r\n        return bakers[adr].totalPayout >= maxPayout(adr);\r\n    }\r\n\r\n    function maxPayout(address adr) public view returns (uint256) {\r\n        return Math.mul(bakers[adr].totalDeposit, 3);\r\n    }\r\n\r\n    function addWithdrawalTaxes(\r\n        address adr,\r\n        uint256 bnbWithdrawalAmount\r\n    ) private view returns (uint256) {\r\n        return\r\n            percentFromAmount(\r\n                bnbWithdrawalAmount,\r\n                Math.sub(100, hasBeanTaxed(adr))\r\n            );\r\n    }\r\n\r\n    function calcGiveAwayAmount(\r\n        address adr,\r\n        uint256 bnbWithdrawalAmount\r\n    ) private view returns (uint256) {\r\n        return (percentFromAmount(bnbWithdrawalAmount, hasBeanTaxed(adr)));\r\n    }\r\n\r\n    function hasBeanTaxed(address adr) public view returns (uint256) {\r\n        uint256 daysPassed = daysSinceLastEat(adr);\r\n        uint256 lastDigit = daysPassed % 10;\r\n        if (lastDigit <= 0) return 90;\r\n        if (lastDigit <= 1) return 80;\r\n        if (lastDigit <= 2) return 70;\r\n        if (lastDigit <= 3) return 60;\r\n        if (lastDigit <= 4) return 50;\r\n        if (lastDigit <= 5) return 40;\r\n        if (lastDigit <= 6) return 30;\r\n        if (lastDigit <= 7) return 20;\r\n        if (lastDigit <= 8) return 10;\r\n        return 0;\r\n    }\r\n\r\n    function secondsSinceLastEat(address adr) public view returns (uint256) {\r\n        uint256 lastAteOrFirstDeposit = bakers[adr].ateAt;\r\n        if (bakers[adr].ateAt == 0) {\r\n            lastAteOrFirstDeposit = bakers[adr].firstDeposit;\r\n        }\r\n\r\n        uint256 secondsPassed = Math.sub(\r\n            block.timestamp,\r\n            lastAteOrFirstDeposit\r\n        );\r\n\r\n        return secondsPassed;\r\n    }\r\n\r\n    function userBonusEligibleReferrals(\r\n        address adr\r\n    ) public view returns (address[] memory) {\r\n        return bakers[adr].bonusEligibleReferrals;\r\n    }\r\n\r\n    function userReferrals(address adr) public view returns (address[] memory) {\r\n        return bakers[adr].referrals;\r\n    }\r\n\r\n    function daysSinceLastEat(address adr) private view returns (uint256) {\r\n        uint256 secondsPassed = secondsSinceLastEat(adr);\r\n        return Math.div(secondsPassed, SECONDS_PER_DAY);\r\n    }\r\n\r\n    function addBeans(\r\n        address adr,\r\n        uint256 beansToAdd\r\n    ) private view returns (uint256) {\r\n        uint256 totalBeans = Math.add(bakers[adr].beans, beansToAdd);\r\n        uint256 maxBeans = bnbToBeans(MAX_WALLET_TVL_IN_BNB);\r\n        if (totalBeans >= maxBeans) {\r\n            return maxBeans;\r\n        }\r\n        return totalBeans;\r\n    }\r\n\r\n    function maxTvlReached(address adr) public view returns (bool) {\r\n        return bakers[adr].beans >= bnbToBeans(MAX_WALLET_TVL_IN_BNB);\r\n    }\r\n\r\n    function hasInvested(address adr) public view returns (bool) {\r\n        return bakers[adr].firstDeposit != 0;\r\n    }\r\n\r\n    function bnbRewards(address adr) public view returns (uint256) {\r\n        uint256 beansRewarded = rewardedBeans(adr);\r\n        uint256 bnbinWei = beansToBnb(beansRewarded);\r\n        return bnbinWei;\r\n    }\r\n\r\n    function bnbTvl(address adr) public view returns (uint256) {\r\n        uint256 bnbinWei = beansToBnb(bakers[adr].beans);\r\n        return bnbinWei;\r\n    }\r\n\r\n    function beansToBnb(uint256 beansToCalc) private view returns (uint256) {\r\n        uint256 bnbInWei = Math.mul(beansToCalc, BNB_PER_BEAN);\r\n        return bnbInWei;\r\n    }\r\n\r\n    function bnbToBeans(uint256 bnbInWei) private view returns (uint256) {\r\n        uint256 beansFromBnb = Math.div(bnbInWei, BNB_PER_BEAN);\r\n        return beansFromBnb;\r\n    }\r\n\r\n    function percentFromAmount(\r\n        uint256 amount,\r\n        uint256 fee\r\n    ) private pure returns (uint256) {\r\n        return Math.div(Math.mul(amount, fee), 100);\r\n    }\r\n\r\n    function contractBalance() public view returns (uint256) {\r\n        return IERC20(USDT).balanceOf(address(this));\r\n    }\r\n\r\n    function dailyReward(address adr) public view returns (uint256) {\r\n        uint256 referralsCount = bakers[adr].bonusEligibleReferrals.length;\r\n        if (referralsCount < 10) return 35000;\r\n        if (referralsCount < 25) return (40000);\r\n        if (referralsCount < 50) return (45000);\r\n        if (referralsCount < 100) return (50000);\r\n        if (referralsCount < 150) return (55000);\r\n        if (referralsCount < 250) return (60000);\r\n        return 65000;\r\n    }\r\n\r\n    function secondsSinceLastAction(\r\n        address adr\r\n    ) private view returns (uint256) {\r\n        uint256 lastTimeStamp = bakers[adr].bakedAt;\r\n        if (lastTimeStamp == 0) {\r\n            lastTimeStamp = bakers[adr].ateAt;\r\n        }\r\n\r\n        if (lastTimeStamp == 0) {\r\n            lastTimeStamp = bakers[adr].firstDeposit;\r\n        }\r\n\r\n        return Math.sub(block.timestamp, lastTimeStamp);\r\n    }\r\n\r\n    function rewardedBeans(address adr) private view returns (uint256) {\r\n        uint256 secondsPassed = secondsSinceLastAction(adr);\r\n        uint256 dailyRewardFactor = dailyReward(adr);\r\n        uint256 beansRewarded = calcBeansReward(\r\n            secondsPassed,\r\n            dailyRewardFactor,\r\n            adr\r\n        );\r\n\r\n        if (beansRewarded >= bnbToBeans(MAX_DAILY_REWARDS_IN_BNB)) {\r\n            return bnbToBeans(MAX_DAILY_REWARDS_IN_BNB);\r\n        }\r\n\r\n        return beansRewarded;\r\n    }\r\n\r\n    function calcBeansReward(\r\n        uint256 secondsPassed,\r\n        uint256 dailyRewardFactor,\r\n        address adr\r\n    ) private view returns (uint256) {\r\n        uint256 rewardsPerDay = percentFromAmount(\r\n            Math.mul(bakers[adr].beans, 100000000),\r\n            dailyRewardFactor\r\n        );\r\n        uint256 rewardsPerSecond = Math.div(rewardsPerDay, SECONDS_PER_DAY);\r\n        uint256 beansRewarded = Math.mul(rewardsPerSecond, secondsPassed);\r\n        beansRewarded = Math.div(beansRewarded, 1000000000000);\r\n        return beansRewarded;\r\n    }\r\n\r\n    function initializeContract() public onlyOwner {\r\n        initialized = true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbToEat\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansBeforeFee\",\"type\":\"uint256\"}],\"name\":\"EmitAte\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansTo\",\"type\":\"uint256\"}],\"name\":\"EmitBaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbamount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansTo\",\"type\":\"uint256\"}],\"name\":\"EmitBoughtBeans\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CEO_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEV_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GIVEAWAY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARKETING_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bakerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"bnbRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"bnbTvl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyBeans\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"dailyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"hasBeanTaxed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"hasInvested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"maxPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"maxPayoutReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"maxTvlReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"secondsSinceLastEat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"beans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ateAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasReferred\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"bonusEligibleReferrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"firstDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"}],\"internalType\":\"struct HARV.Baker\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"userBonusEligibleReferrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"userReferrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HARV", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d57034bf5697074c35cc2bb2680fa34a6e2be7a51a24fa4c527c15850e5c105a"}