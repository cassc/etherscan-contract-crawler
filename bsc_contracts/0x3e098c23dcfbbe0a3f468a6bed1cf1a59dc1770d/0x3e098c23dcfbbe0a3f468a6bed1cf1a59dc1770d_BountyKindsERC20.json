{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/BountyKindERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {\\n    AccessControlEnumerable\\n} from \\\"oz-custom/contracts/oz/access/AccessControlEnumerable.sol\\\";\\n\\nimport {\\n    ERC20,\\n    ERC20Permit\\n} from \\\"oz-custom/contracts/oz/token/ERC20/extensions/ERC20Permit.sol\\\";\\n\\nimport {\\n    ERC20Burnable\\n} from \\\"oz-custom/contracts/oz/token/ERC20/extensions/ERC20Burnable.sol\\\";\\n\\nimport {\\n    Pausable,\\n    ERC20Pausable\\n} from \\\"oz-custom/contracts/oz/token/ERC20/extensions/ERC20Pausable.sol\\\";\\n\\nimport {\\n    Taxable,\\n    FixedPointMathLib\\n} from \\\"oz-custom/contracts/internal/Taxable.sol\\\";\\nimport {Transferable} from \\\"oz-custom/contracts/internal/Transferable.sol\\\";\\nimport {ProxyChecker} from \\\"oz-custom/contracts/internal/ProxyChecker.sol\\\";\\nimport {Blacklistable} from \\\"oz-custom/contracts/internal/Blacklistable.sol\\\";\\n\\nimport {IWNT} from \\\"oz-custom/contracts/presets/token/interfaces/IWNT.sol\\\";\\n\\nimport {\\n    IUniswapV2Pair,\\n    IBountyKindsERC20\\n} from \\\"./interfaces/IBountyKindsERC20.sol\\\";\\nimport {\\n    AggregatorV3Interface\\n} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nimport {ErrorHandler} from \\\"oz-custom/contracts/libraries/ErrorHandler.sol\\\";\\n\\ncontract BountyKindsERC20 is\\n    Taxable,\\n    ERC20Permit,\\n    Transferable,\\n    ProxyChecker,\\n    Blacklistable,\\n    ERC20Burnable,\\n    ERC20Pausable,\\n    IBountyKindsERC20,\\n    AccessControlEnumerable\\n{\\n    using ErrorHandler for bool;\\n    using FixedPointMathLib for uint256;\\n\\n    bytes32 public constant PAUSER_ROLE =\\n        0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a;\\n    bytes32 public constant MINTER_ROLE =\\n        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\\n    bytes32 public constant OPERATOR_ROLE =\\n        0x97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b929;\\n\\n    IWNT public immutable wnt;\\n    AggregatorV3Interface public immutable priceFeed;\\n\\n    IUniswapV2Pair public pool;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address admin_,\\n        address beneficiary_,\\n        uint256 initialSupply_,\\n        IWNT wnt_,\\n        AggregatorV3Interface priceFeed_\\n    ) payable Pausable() Taxable(beneficiary_) ERC20Permit(name_, symbol_) {\\n        wnt = wnt_;\\n        priceFeed = priceFeed_;\\n\\n        address operator = _msgSender();\\n\\n        bytes32 pauserRole = PAUSER_ROLE;\\n        bytes32 minterRole = MINTER_ROLE;\\n        bytes32 operatorRole = OPERATOR_ROLE;\\n\\n        _grantRole(pauserRole, operator);\\n        _grantRole(minterRole, operator);\\n        _grantRole(operatorRole, operator);\\n\\n        _grantRole(pauserRole, admin_);\\n        _grantRole(minterRole, admin_);\\n        _grantRole(operatorRole, admin_);\\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\\n\\n        _mint(beneficiary_, initialSupply_ * 1 ether);\\n    }\\n\\n    /// @inheritdoc IBountyKindsERC20\\n    function setPool(\\n        IUniswapV2Pair pool_\\n    ) external whenPaused onlyRole(OPERATOR_ROLE) {\\n        _setPool(pool_);\\n    }\\n\\n    function setUserStatus(\\n        address account_,\\n        bool status_\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        _setUserStatus(account_, status_);\\n    }\\n\\n    function pause() external onlyRole(PAUSER_ROLE) {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyRole(PAUSER_ROLE) {\\n        _unpause();\\n    }\\n\\n    function toggleTax() external whenPaused onlyRole(PAUSER_ROLE) {\\n        _toggleTax();\\n    }\\n\\n    function setTaxBeneficiary(\\n        address beneficiary_\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        _setTaxBeneficiary(beneficiary_);\\n    }\\n\\n    /// @inheritdoc IBountyKindsERC20\\n    function mint(address to_, uint256 amount_) external onlyRole(MINTER_ROLE) {\\n        _mint(to_, amount_);\\n    }\\n\\n    /// @inheritdoc IBountyKindsERC20\\n    //  @dev minimal function to recover lost funds\\n    function execute(\\n        address target_,\\n        uint256 value_,\\n        bytes calldata calldata_\\n    ) external whenPaused onlyRole(OPERATOR_ROLE) {\\n        (bool success, bytes memory returnOrRevertData) = target_.call{\\n            value: value_\\n        }(calldata_);\\n        success.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        emit Executed(\\n            _msgSender(),\\n            target_,\\n            value_,\\n            calldata_,\\n            returnOrRevertData\\n        );\\n    }\\n\\n    function tax(\\n        address pool_,\\n        uint256 amount_\\n    ) public view override returns (uint256) {\\n        uint256 tokenReserve;\\n        uint256 nativeReserve;\\n        if (IUniswapV2Pair(pool_).token1() == address(this))\\n            (nativeReserve, tokenReserve, ) = IUniswapV2Pair(pool_)\\n                .getReserves();\\n        else\\n            (tokenReserve, nativeReserve, ) = IUniswapV2Pair(pool_)\\n                .getReserves();\\n\\n        // amount token => amount native\\n        uint256 amtNative = amount_.mulDivUp(nativeReserve, tokenReserve);\\n        AggregatorV3Interface _priceFeed = priceFeed;\\n        (, int256 usd, , , ) = _priceFeed.latestRoundData();\\n        // amount native => amount usd\\n        uint256 amtUSD = amtNative.mulDivUp(\\n            uint256(usd),\\n            10 ** _priceFeed.decimals()\\n        );\\n\\n        // usd tax amount\\n        uint256 usdTax = amtUSD.mulDivUp(\\n            taxFraction(address(0)),\\n            percentageFraction()\\n        );\\n        // native tax amount\\n        return usdTax.mulDivUp(1 ether, uint256(usd));\\n    }\\n\\n    function taxEnabledDuration() public pure override returns (uint256) {\\n        return 20 minutes;\\n    }\\n\\n    function taxFraction(address) public pure override returns (uint256) {\\n        return 2500;\\n    }\\n\\n    function percentageFraction() public pure override returns (uint256) {\\n        return 10_000;\\n    }\\n\\n    function _setPool(IUniswapV2Pair pool_) internal {\\n        if (address(pool_) == address(0) || !_isProxy(address(pool_)))\\n            revert BountyKindsERC20__InvalidArguments();\\n\\n        emit PoolSet(_msgSender(), pool, pool_);\\n        pool = pool_;\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from_,\\n        address to_,\\n        uint256 amount_\\n    ) internal override(ERC20, ERC20Pausable) {\\n        if (\\n            isBlacklisted(to_) ||\\n            isBlacklisted(from_) ||\\n            isBlacklisted(_msgSender())\\n        ) revert BountyKindsERC20__Blacklisted();\\n\\n        if (isTaxEnabled()) {\\n            uint256 _tax = tax(address(pool), amount_);\\n            IWNT _wnt = wnt;\\n\\n            if (msg.value != 0) {\\n                //  @dev will throw underflow error if msg.value < _tax\\n                uint256 refund = msg.value - _tax;\\n                _wnt.deposit{value: _tax}();\\n\\n                address spender = _msgSender();\\n                if (refund != 0) {\\n                    _safeNativeTransfer(spender, refund, \\\"\\\");\\n                    emit Refunded(spender, refund);\\n                }\\n            }\\n\\n            _safeERC20TransferFrom(_wnt, address(this), taxBeneficiary, _tax);\\n        }\\n\\n        super._beforeTokenTransfer(from_, to_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBountyKindsERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {\\n    IUniswapV2Pair\\n} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\n/**\\n *@title IBountyKindsERC20\\n *@dev This interface defines the methods and events for a contract that manages a ERC20 token and allows executing calls to external contracts.\\n */\\ninterface IBountyKindsERC20 {\\n    error BountyKindsERC20__Blacklisted();\\n    error BountyKindsERC20__InvalidArguments();\\n\\n    /**\\n     * @dev Emitted when a refund is made to an operator.\\n     * @param operator The address of the operator that receives the refund.\\n     * @param refund The amount of tokens refunded.\\n     */\\n    event Refunded(address indexed operator, uint256 indexed refund);\\n\\n    /**\\n     * @dev Emitted when a call to an external contract is executed.\\n     * @param operator The address of the operator that executed the call.\\n     * @param target The address of the external contract that was called.\\n     * @param value_ The amount of ether sent in the call.\\n     * @param callData The data sent in the call.\\n     * @param returnData The data returned by the external contract.\\n     */\\n    event Executed(\\n        address indexed operator,\\n        address indexed target,\\n        uint256 indexed value_,\\n        bytes callData,\\n        bytes returnData\\n    );\\n\\n    /**\\n     * @dev Emitted when the Uniswap V2 pair is updated.\\n     * @param operator The address of the operator that updated the Uniswap V2 pair.\\n     * @param poolOld The old Uniswap V2 pair address.\\n     * @param poolNew The new Uniswap V2 pair address.\\n     */\\n    event PoolSet(\\n        address indexed operator,\\n        IUniswapV2Pair indexed poolOld,\\n        IUniswapV2Pair indexed poolNew\\n    );\\n\\n    /**\\n     * @dev Sets the Uniswap V2 pair address.\\n     * @param pool_ The address of the new Uniswap V2 pair.\\n     */\\n    function setPool(IUniswapV2Pair pool_) external;\\n\\n    /**\\n     * @dev Mints tokens to the specified address.\\n     * @param to_ The address that will receive the tokens.\\n     * @param amount_ The amount of tokens to mint.\\n     */\\n    function mint(address to_, uint256 amount_) external;\\n\\n    /**\\n     * @dev Executes a call to an external contract.\\n     * @param target_ The address of the external contract to call.\\n     * @param value_ The amount of ether to send with the call.\\n     * @param calldata_ The data to send with the call.\\n     */\\n    function execute(\\n        address target_,\\n        uint256 value_,\\n        bytes calldata calldata_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/Blacklistable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../oz/utils/Context.sol\\\";\\n\\nimport {IBlacklistable} from \\\"./interfaces/IBlacklistable.sol\\\";\\n\\nimport {BitMaps} from \\\"../oz/utils/structs/BitMaps.sol\\\";\\nimport {Bytes32Address} from \\\"../libraries/Bytes32Address.sol\\\";\\n\\n/**\\n * @title Blacklistable\\n * @dev Abstract contract that provides blacklist functionality.\\n * Users of this contract can add or remove an address from the blacklist.\\n * Users can check if an address is blacklisted.\\n */\\nabstract contract Blacklistable is Context, IBlacklistable {\\n    using Bytes32Address for address;\\n    using BitMaps for BitMaps.BitMap;\\n\\n    BitMaps.BitMap private __blacklisted;\\n\\n    /// @inheritdoc IBlacklistable\\n    function isBlacklisted(\\n        address account_\\n    ) public view virtual returns (bool) {\\n        return __blacklisted.get(account_.fillLast96Bits());\\n    }\\n\\n    function areBlacklisted(\\n        address[] calldata accounts_\\n    ) public view virtual returns (bool) {\\n        uint256 length = accounts_.length;\\n        for (uint256 i; i < length; ) {\\n            if (__blacklisted.get(accounts_[i].fillLast96Bits())) return true;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the status of an account.\\n     * @param account_ The address to change the status of.\\n     * @param status_ The new status for the address. True for blacklisted, false for not blacklisted.\\n     */\\n    function _setUserStatus(address account_, bool status_) internal virtual {\\n        __blacklisted.setTo(account_.fillLast96Bits(), status_);\\n        emit UserStatusSet(_msgSender(), account_, status_);\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/interfaces/IBlacklistable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IBlacklistable {\\n    event UserStatusSet(\\n        address indexed operator,\\n        address indexed account,\\n        bool indexed isBlacklisted\\n    );\\n\\n    /**\\n     * @dev Set the status of an account to either blacklisted or not blacklisted.\\n     * @param account_ The address to change the status of.\\n     * @param status The new status for the address. True for blacklisted, false for not blacklisted.\\n     */\\n    function setUserStatus(address account_, bool status) external;\\n\\n    /**\\n     * @dev Check if an address is blacklisted.\\n     * @param account_ The address to check.\\n     * @return True if the address is blacklisted, false otherwise.\\n     */\\n    function isBlacklisted(address account_) external view returns (bool);\\n\\n    function areBlacklisted(\\n        address[] calldata accounts_\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/interfaces/ISignable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface ISignable {\\n    error Signable__InvalidSignature();\\n\\n    event NonceIncremented(\\n        address indexed operator,\\n        bytes32 indexed id,\\n        uint256 indexed value\\n    );\\n\\n    /**\\n     * @dev Returns the domain separator for EIP712 v4\\n     * @return Domain separator for EIP712 v4\\n     */\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/interfaces/ITaxable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface ITaxable {\\n    error Taxable__TaxDisabled();\\n    error Taxable__AlreadyEnabled();\\n    error Taxable__InvalidArguments();\\n\\n    event TaxEnabled(\\n        address indexed operator,\\n        uint256 indexed start,\\n        uint256 indexed stop\\n    );\\n\\n    event TaxBeneficiarySet(\\n        address indexed operator,\\n        address indexed oldBeneficiary,\\n        address indexed newBeneficiary\\n    );\\n\\n    function toggleTax() external;\\n\\n    function setTaxBeneficiary(address taxBeneficiary_) external;\\n\\n    function tax(\\n        address token_,\\n        uint256 amount_\\n    ) external view returns (uint256);\\n\\n    function taxFraction(address token_) external pure returns (uint256);\\n\\n    function percentageFraction() external pure returns (uint256);\\n\\n    function isTaxEnabled() external view returns (bool);\\n\\n    function taxEnabledDuration() external pure returns (uint256);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/ProxyChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Revert error if call is made from a proxy contract\\n */\\nerror ProxyChecker__EOAUnallowed();\\n/**\\n * @dev Revert error if call is made from an externally owned account\\n */\\nerror ProxyChecker__ProxyUnallowed();\\n\\n/**\\n * @title ProxyChecker\\n * @dev Abstract contract for checking if a call was made by a proxy contract or an externally owned account.\\n */\\nabstract contract ProxyChecker {\\n    modifier onlyProxy() {\\n        _onlyProxy(msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to allow a function to be called only by an externally owned account\\n     */\\n    modifier onlyEOA() {\\n        _onlyEOA(msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if the sender is an externally owned account\\n     * @param sender_ Address of the sender\\n     */\\n    function _onlyEOA(address sender_) internal view {\\n        _onlyEOA(sender_, _txOrigin());\\n    }\\n\\n    /**\\n     * @dev Check if the sender is an externally owned account\\n     * @param msgSender_ Address of the sender\\n     * @param txOrigin_ Origin of the transaction\\n     */\\n    function _onlyEOA(address msgSender_, address txOrigin_) internal pure {\\n        if (_isProxyCall(msgSender_, txOrigin_))\\n            revert ProxyChecker__ProxyUnallowed();\\n    }\\n\\n    /**\\n     * @dev Check if the sender is a proxy contract\\n     * @param sender_ Address of the sender\\n     */\\n    function _onlyProxy(address sender_) internal view {\\n        if (!(_isProxyCall(sender_, _txOrigin()) || _isProxy(sender_)))\\n            revert ProxyChecker__EOAUnallowed();\\n    }\\n\\n    /**\\n     * @dev Check if the sender is a proxy contract\\n     * @param msgSender_ Address of the sender\\n     * @param txOrigin_ Origin of the transaction\\n     */\\n    function _onlyProxy(address msgSender_, address txOrigin_) internal view {\\n        if (!(_isProxyCall(msgSender_, txOrigin_) || _isProxy(msgSender_)))\\n            revert ProxyChecker__EOAUnallowed();\\n    }\\n\\n    /**\\n     * @dev Check if the call was made by a proxy contract\\n     * @param msgSender_ Address of the sender\\n     * @param txOrigin_ Origin of the transaction\\n     * @return True if the call was made by a proxy contract, false otherwise\\n     */\\n    function _isProxyCall(\\n        address msgSender_,\\n        address txOrigin_\\n    ) internal pure returns (bool) {\\n        return msgSender_ != txOrigin_;\\n    }\\n\\n    /**\\n     * @dev Check if the caller is a proxy contract\\n     * @param caller_ Address of the caller\\n     * @return True if the caller is a proxy contract, false otherwise\\n     */\\n    function _isProxy(address caller_) internal view returns (bool) {\\n        return caller_.code.length != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the origin of the transaction\\n     * @return Origin of the transaction\\n     */\\n    function _txOrigin() internal view returns (address) {\\n        return tx.origin;\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/Signable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../oz/utils/Context.sol\\\";\\nimport {ECDSA, EIP712} from \\\"../oz/utils/cryptography/draft-EIP712.sol\\\";\\n\\nimport {ISignable} from \\\"./interfaces/ISignable.sol\\\";\\n\\nimport {Bytes32Address} from \\\"../libraries/Bytes32Address.sol\\\";\\n\\n/**\\n * @title Signable\\n * @dev Abstract contract for signing and verifying typed data.\\n */\\nabstract contract Signable is Context, EIP712, ISignable {\\n    using ECDSA for bytes32;\\n    using Bytes32Address for address;\\n\\n    /**\\n     * @dev Mapping of nonces for each id\\n     */\\n    mapping(bytes32 => uint256) internal _nonces;\\n\\n    /**\\n     * @dev Constructor that initializes EIP712 with the given name and version\\n     * @param name_ Name of the typed data\\n     * @param version_ Version of the typed data\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory version_\\n    ) payable EIP712(name_, version_) {}\\n\\n    /**\\n     * @dev Verifies that the signer of the typed data is the given address\\n     * @param verifier_ Address to verify\\n     * @param structHash_ Hash of the typed data\\n     * @param signature_ Signature of the typed data\\n     */\\n    function _verify(\\n        address verifier_,\\n        bytes32 structHash_,\\n        bytes calldata signature_\\n    ) internal view virtual {\\n        if (_recoverSigner(structHash_, signature_) != verifier_)\\n            revert Signable__InvalidSignature();\\n    }\\n\\n    /**\\n     * @dev Verifies that the signer of the typed data is the given address\\n     * @param verifier_ Address to verify\\n     * @param structHash_ Hash of the typed data\\n     * @param v ECDSA recovery value\\n     * @param r ECDSA r value\\n     * @param s ECDSA s value\\n     */\\n    function _verify(\\n        address verifier_,\\n        bytes32 structHash_,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view virtual {\\n        if (_recoverSigner(structHash_, v, r, s) != verifier_)\\n            revert Signable__InvalidSignature();\\n    }\\n\\n    /**\\n     * @dev Recovers the signer of the typed data from the signature\\n     * @param structHash_ Hash of the typed data\\n     * @param signature_ Signature of the typed data\\n     * @return Address of the signer\\n     */\\n    function _recoverSigner(\\n        bytes32 structHash_,\\n        bytes calldata signature_\\n    ) internal view returns (address) {\\n        return _hashTypedDataV4(structHash_).recover(signature_);\\n    }\\n\\n    /**\\n     * @dev Recovers the signer of the typed data from the signature\\n     * @param structHash_ Hash of the typed data\\n     * @param v ECDSA recovery value\\n     * @param r ECDSA r value\\n     * @param s ECDSA s value\\n     * @return Address of the signer\\n     */\\n    function _recoverSigner(\\n        bytes32 structHash_,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address) {\\n        return _hashTypedDataV4(structHash_).recover(v, r, s);\\n    }\\n\\n    /**\\n     * @dev Increases the nonce for the given account by 1\\n     * @param id_ ID to increase the nonce for\\n     * @return nonce The new nonce for the account\\n     */\\n    function _useNonce(bytes32 id_) internal virtual returns (uint256 nonce) {\\n        assembly {\\n            mstore(0x00, id_)\\n            mstore(0x20, _nonces.slot)\\n            let key := keccak256(0x00, 0x40)\\n            nonce := sload(key)\\n            sstore(key, add(nonce, 1))\\n        }\\n\\n        emit NonceIncremented(_msgSender(), id_, nonce);\\n    }\\n\\n    /// @inheritdoc ISignable\\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/Taxable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../oz/utils/Context.sol\\\";\\n\\nimport {ITaxable} from \\\"./interfaces/ITaxable.sol\\\";\\n\\nimport {FixedPointMathLib} from \\\"../libraries/FixedPointMathLib.sol\\\";\\n\\nabstract contract Taxable is Context, ITaxable {\\n    using FixedPointMathLib for uint256;\\n\\n    address public taxBeneficiary;\\n    uint256 public taxEnabledTimestamp;\\n\\n    modifier whenTaxEnabled() virtual {\\n        _checkTaxEnabled();\\n        _;\\n    }\\n\\n    constructor(address taxBeneficiary_) payable {\\n        _setTaxBeneficiary(taxBeneficiary_);\\n    }\\n\\n    function _setTaxBeneficiary(address taxBeneficiary_) internal virtual {\\n        if (taxBeneficiary_ == address(0)) revert Taxable__InvalidArguments();\\n\\n        emit TaxBeneficiarySet(_msgSender(), taxBeneficiary, taxBeneficiary_);\\n\\n        taxBeneficiary = taxBeneficiary_;\\n    }\\n\\n    function _toggleTax() internal virtual {\\n        if (taxEnabledTimestamp != 0) revert Taxable__AlreadyEnabled();\\n        taxEnabledTimestamp = block.timestamp;\\n\\n        emit TaxEnabled(\\n            _msgSender(),\\n            block.timestamp,\\n            block.timestamp + taxEnabledDuration()\\n        );\\n    }\\n\\n    function tax(\\n        address token_,\\n        uint256 amount_\\n    ) public view virtual returns (uint256) {\\n        return amount_.mulDivUp(taxFraction(token_), percentageFraction());\\n    }\\n\\n    function taxFraction(address token_) public pure virtual returns (uint256);\\n\\n    function percentageFraction() public pure virtual returns (uint256);\\n\\n    function taxEnabledDuration() public pure virtual returns (uint256);\\n\\n    function _checkTaxEnabled() internal view {\\n        if (!isTaxEnabled()) revert Taxable__TaxDisabled();\\n    }\\n\\n    function isTaxEnabled() public view virtual returns (bool) {\\n        return taxEnabledTimestamp + taxEnabledDuration() > block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/Transferable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IERC20} from \\\"../oz/token/ERC20/IERC20.sol\\\";\\n\\nerror Transferable__TransferFailed();\\nerror Transferable__InvalidArguments();\\n\\n/**\\n * @dev Library for transferring Ether and tokens between accounts\\n */\\nabstract contract Transferable {\\n    /**\\n     * @dev Reverts the transaction if the transfer fails\\n     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.\\n     * @param from_ Address to transfer from\\n     * @param to_ Address to transfer to\\n     * @param value_ Amount of tokens or Ether to transfer\\n     */\\n    function _safeTransferFrom(\\n        address token_,\\n        address from_,\\n        address to_,\\n        uint256 value_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, value_);\\n\\n        if (\\n            token_ == address(0)\\n                ? _nativeTransfer(to_, value_, data_)\\n                : _ERC20TransferFrom(IERC20(token_), from_, to_, value_)\\n        ) return;\\n\\n        revert Transferable__TransferFailed();\\n    }\\n\\n    /**\\n     * @dev Reverts the transaction if the transfer fails\\n     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.\\n     * @param to_ Address to transfer to\\n     * @param value_ Amount of tokens or Ether to transfer\\n     */\\n    function _safeTransfer(\\n        address token_,\\n        address to_,\\n        uint256 value_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, value_);\\n\\n        if (\\n            token_ == address(0)\\n                ? _nativeTransfer(to_, value_, data_)\\n                : _ERC20Transfer(IERC20(token_), to_, value_)\\n        ) return;\\n\\n        revert Transferable__TransferFailed();\\n    }\\n\\n    /**\\n     * @dev Reverts the transaction if the Ether transfer fails\\n     * @param to_ Address to transfer to\\n     * @param amount_ Amount of Ether to transfer\\n     */\\n    function _safeNativeTransfer(\\n        address to_,\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n        if (!_nativeTransfer(to_, amount_, data_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _safeERC20Transfer(\\n        IERC20 token_,\\n        address to_,\\n        uint256 amount_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n        if (!_ERC20Transfer(token_, to_, amount_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _safeERC20TransferFrom(\\n        IERC20 token_,\\n        address from_,\\n        address to_,\\n        uint256 amount_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n\\n        if (!_ERC20TransferFrom(token_, from_, to_, amount_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _nativeTransfer(\\n        address to_,\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal virtual returns (bool success) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(\\n                gas(),\\n                to_,\\n                amount_,\\n                add(data_, 32),\\n                mload(data_),\\n                0,\\n                0\\n            )\\n        }\\n    }\\n\\n    function _ERC20Transfer(\\n        IERC20 token_,\\n        address to_,\\n        uint256 value_\\n    ) internal virtual returns (bool success) {\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), to_) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), value_) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n    }\\n\\n    function _ERC20TransferFrom(\\n        IERC20 token_,\\n        address from_,\\n        address to_,\\n        uint256 value_\\n    ) internal virtual returns (bool success) {\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), from_)\\n            mstore(add(freeMemoryPointer, 36), to_)\\n            mstore(add(freeMemoryPointer, 68), value_)\\n\\n            success := and(\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n    }\\n\\n    function __checkValidTransfer(address to_, uint256 value_) private pure {\\n        if (to_ == address(0) || value_ == 0)\\n            revert Transferable__InvalidArguments();\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/libraries/ArrayUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {BitMap256} from \\\"./structs/BitMap256.sol\\\";\\n\\n/**\\n *@title ArrayUtil\\n *@dev Utility library for working with arrays. This library contains functions for trimming an array and removing duplicate elements from an array by converting it to a set using a bitmap.\\n */\\nlibrary ArrayUtil {\\n    using BitMap256 for uint256;\\n\\n    /*\\n     *@dev Converts an array to a set by removing duplicate elements. Uses a bitmap to store the seen elements for efficiency.\\n     *@param arr_ The input array to convert to a set.\\n     *@return An array with the duplicate elements removed.\\n     */\\n    function toSet(\\n        uint256[] memory arr_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256 length = arr_.length;\\n        uint256 seenBitmap;\\n        uint256 valI;\\n        unchecked {\\n            for (uint256 i; i < length; ++i) {\\n                //  @dev cache element to stack\\n                valI = arr_[i];\\n\\n                //  @dev remove dupplicated element by moving it to the end of the array and reduce the length, break the loop only if we found an unseen element (x)\\n                while (\\n                    length > i &&\\n                    seenBitmap.get({value_: valI, shouldHash_: true})\\n                ) valI = arr_[--length];\\n\\n                // @dev set seen element in the bitmap and replace dupplicated one with unseen element (x)\\n                seenBitmap = seenBitmap.set({value_: valI, shouldHash_: true});\\n                arr_[i] = valI;\\n            }\\n        }\\n\\n        // Shorten the dynamic array by the reduced length.\\n        assembly {\\n            mstore(arr_, length)\\n        }\\n        return arr_;\\n    }\\n\\n    /**\\n     *@dev Trims an array by removing all elements that match a given value.\\n     *@param trimVal_ The value to remove from the array.\\n     *@param arr_ The input array to trim.\\n     *@return trimmed An array with the specified elements removed.\\n     */\\n    function trim(\\n        uint256[256] storage arr_,\\n        uint256 trimVal_\\n    ) internal view returns (uint256[] memory trimmed) {\\n        trimmed = new uint256[](256);\\n\\n        uint8 j;\\n        uint256 valI;\\n        unchecked {\\n            for (uint256 i; i < 256; ++i) {\\n                valI = arr_[i];\\n                if (valI == trimVal_) continue;\\n\\n                trimmed[j] = valI;\\n                ++j;\\n            }\\n        }\\n\\n        // Shorten the `trimmed` dynamic array by new length.\\n        assembly {\\n            mstore(trimmed, j)\\n        }\\n    }\\n\\n    /**\\n     *@dev Trims an array by removing all elements that match a given value.\\n     *@param trimVal_ The value to remove from the array.\\n     *@param arr_ The input array to trim.\\n     *@return trimmed An array with the specified elements removed.\\n     */\\n    function trim(\\n        uint256[] memory arr_,\\n        uint256 trimVal_\\n    ) internal pure returns (uint256[] memory trimmed) {\\n        uint256 length = arr_.length;\\n        trimmed = new uint256[](length);\\n\\n        uint256 j;\\n        uint256 valI;\\n        unchecked {\\n            for (uint256 i; i < length; ++i) {\\n                valI = arr_[i];\\n                if (valI == trimVal_) continue;\\n\\n                trimmed[j] = valI;\\n                ++j;\\n            }\\n        }\\n\\n        // Shorten the `trimmed` dynamic array by new length.\\n        assembly {\\n            mstore(trimmed, j)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/libraries/Bytes32Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary Bytes32Address {\\n    function fromFirst20Bytes(\\n        bytes32 bytesValue\\n    ) internal pure returns (address addr) {\\n        assembly {\\n            addr := bytesValue\\n        }\\n    }\\n\\n    function fillLast12Bytes(\\n        address addressValue\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            value := addressValue\\n        }\\n    }\\n\\n    function fromFirst160Bits(\\n        uint256 uintValue\\n    ) internal pure returns (address addr) {\\n        assembly {\\n            addr := uintValue\\n        }\\n    }\\n\\n    function fillLast96Bits(\\n        address addressValue\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := addressValue\\n        }\\n    }\\n\\n    function fromLast160Bits(\\n        uint256 uintValue\\n    ) internal pure returns (address addr) {\\n        assembly {\\n            addr := shr(0x60, uintValue)\\n        }\\n    }\\n\\n    function fillFirst96Bits(\\n        address addressValue\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := shl(0x60, addressValue)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/libraries/ErrorHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nerror ErrorHandler__ExecutionFailed();\\n\\nlibrary ErrorHandler {\\n    function handleRevertIfNotSuccess(\\n        bool ok_,\\n        bytes memory revertData_\\n    ) internal pure {\\n        if (!ok_)\\n            if (revertData_.length != 0)\\n                assembly {\\n                    revert(\\n                        // Start of revert data bytes. The 0x20 offset is always the same.\\n                        add(revertData_, 0x20),\\n                        // Length of revert data.\\n                        mload(revertData_)\\n                    )\\n                }\\n            else revert ErrorHandler__ExecutionFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/libraries/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = (1 << 256) - 1;\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(\\n                mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(\\n                mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            // Add 1 to the result if x * y mod denominator != 0.\\n            z := add(\\n                gt(mod(mul(x, y), denominator), 0),\\n                div(mul(x, y), denominator)\\n            )\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/libraries/structs/BitMap256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n *@title BitMap256 Library\\n *@dev A library for storing a bitmap of 256 slots, where each slot is represented by a single bit. This allows for efficient storage and manipulation of large amounts of boolean data.\\n */\\nlibrary BitMap256 {\\n    /**\\n     * @dev Struct for holding a 256-bit bitmap.\\n     */\\n    struct BitMap {\\n        uint256 data;\\n    }\\n\\n    /**\\n     *@dev Calculate the index for a given value in the bitmap.\\n     *@param value_ The value for which the index needs to be calculated.\\n     *@param shouldHash_ A boolean flag indicating if the value should be hashed.\\n     *@return idx The calculated index for the given value.\\n     */\\n    function index(\\n        uint256 value_,\\n        bool shouldHash_\\n    ) internal pure returns (uint256 idx) {\\n        assembly {\\n            if shouldHash_ {\\n                mstore(0x00, value_)\\n                value_ := keccak256(0x00, 0x20)\\n            }\\n            idx := and(0xff, value_)\\n        }\\n    }\\n\\n    /**\\n     *@dev Get the value of a bit at a given index in the bitmap.\\n     *@param bitmap_ The storage bitmap to get the value from.\\n     *@param value_ The value for which the index needs to be calculated.\\n     *@param shouldHash_ A boolean flag indicating if the value should be hashed.\\n     *@return isSet A boolean indicating if the bit at the given index is set.\\n     */\\n    function get(\\n        BitMap storage bitmap_,\\n        uint256 value_,\\n        bool shouldHash_\\n    ) internal view returns (bool isSet) {\\n        assembly {\\n            if shouldHash_ {\\n                mstore(0x00, value_)\\n                value_ := keccak256(0x00, 0x20)\\n            }\\n            isSet := and(sload(bitmap_.slot), shl(and(value_, 0xff), 1))\\n        }\\n    }\\n\\n    /**\\n     *@dev Get the value of a bit at a given index in the bitmap.\\n     *@param bitmap_ The storage bitmap to get the value from.\\n     *@param value_ The value for which the index needs to be calculated.\\n     *@param shouldHash_ A boolean flag indicating if the value should be hashed.\\n     *@return isSet A boolean indicating if the bit at the given index is set.\\n     */\\n    function get(\\n        uint256 bitmap_,\\n        uint256 value_,\\n        bool shouldHash_\\n    ) internal pure returns (bool isSet) {\\n        assembly {\\n            if shouldHash_ {\\n                mstore(0x00, value_)\\n                value_ := keccak256(0x00, 0x20)\\n            }\\n            isSet := and(bitmap_, shl(and(value_, 0xff), 1))\\n        }\\n    }\\n\\n    /**\\n     *@dev Set the data of the storage bitmap to a given value.\\n     *@param bitmap_ The storage bitmap to set the data of.\\n     *@param value The value to set the data of the bitmap to.\\n     */\\n    function setData(BitMap storage bitmap_, uint256 value) internal {\\n        assembly {\\n            sstore(bitmap_.slot, value)\\n        }\\n    }\\n\\n    /**\\n     *@dev Set or unset the bit at a given index in the bitmap based on the status flag.\\n     *@param bitmap_ The storage bitmap to set or unset the bit in.\\n     *@param value_ The value for which the index needs to be calculated.\\n     *@param shouldHash_ A boolean flag indicating if the value should be hashed.\\n     *@param status_ A boolean flag indicating if the bit should be set or unset.\\n     */\\n    function setTo(\\n        BitMap storage bitmap_,\\n        uint256 value_,\\n        bool shouldHash_,\\n        bool status_\\n    ) internal {\\n        if (status_) set(bitmap_, value_, shouldHash_);\\n        else unset(bitmap_, value_, shouldHash_);\\n    }\\n\\n    /**\\n     * @dev Sets the bit at the given index in the bitmap to the given value.\\n     * If `shouldHash_` is `true`, the value is hashed before computing the index.\\n     * @param bitmap_ The bitmap to set the bit in.\\n     * @param value_ The value for which the index needs to be calculated.\\n     * @param shouldHash_ A boolean flag indicating if the value should be hashed.\\n     */\\n    function set(\\n        BitMap storage bitmap_,\\n        uint256 value_,\\n        bool shouldHash_\\n    ) internal {\\n        assembly {\\n            if shouldHash_ {\\n                mstore(0x00, value_)\\n                value_ := keccak256(0, 0x20)\\n            }\\n            sstore(\\n                bitmap_.slot,\\n                or(sload(bitmap_.slot), shl(and(value_, 0xff), 1))\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at the given index in the bitmap to the given value.\\n     * If `shouldHash_` is `true`, the value is hashed before computing the index.\\n     * @param bitmap_ The bitmap to set the bit in.\\n     * @param value_ The value for which the index needs to be calculated.\\n     * @param shouldHash_ A boolean flag indicating if the value should be hashed.\\n     */\\n    function set(\\n        uint256 bitmap_,\\n        uint256 value_,\\n        bool shouldHash_\\n    ) internal pure returns (uint256 bitmap) {\\n        assembly {\\n            if shouldHash_ {\\n                mstore(0x00, value_)\\n                value_ := keccak256(0x00, 0x20)\\n            }\\n            bitmap := or(bitmap_, shl(and(value_, 0xff), 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at the given index in the bitmap to the given value.\\n     * If `shouldHash_` is `true`, the value is hashed before computing the index.\\n     * @param bitmap_ The bitmap to set the bit in.\\n     * @param value_ The value for which the index needs to be calculated.\\n     * @param shouldHash_ A boolean flag indicating if the value should be hashed.\\n     */\\n    function unset(\\n        BitMap storage bitmap_,\\n        uint256 value_,\\n        bool shouldHash_\\n    ) internal {\\n        assembly {\\n            if shouldHash_ {\\n                mstore(0x00, value_)\\n                value_ := keccak256(0x00, 0x20)\\n            }\\n\\n            sstore(\\n                bitmap_.slot,\\n                and(sload(bitmap_.slot), not(shl(and(value_, 0xff), 1)))\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at the given index in the bitmap to the given value.\\n     * If `shouldHash_` is `true`, the value is hashed before computing the index.\\n     * @param bitmap_ The bitmap to set the bit in.\\n     * @param value_ The value for which the index needs to be calculated.\\n     * @param shouldHash_ A boolean flag indicating if the value should be hashed.\\n     */\\n    function unset(\\n        uint256 bitmap_,\\n        uint256 value_,\\n        bool shouldHash_\\n    ) internal pure returns (uint256 bitmap) {\\n        assembly {\\n            if shouldHash_ {\\n                mstore(0x00, value_)\\n                value_ := keccak256(0x00, 32)\\n            }\\n            bitmap := and(bitmap_, not(shl(and(value_, 0xff), 1)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/libraries/structs/EnumerableSet256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {ArrayUtil, BitMap256} from \\\"../ArrayUtil.sol\\\";\\n\\nlibrary EnumerableSet256 {\\n    using BitMap256 for *;\\n    using ArrayUtil for *;\\n\\n    struct Set {\\n        uint8 length;\\n        // Storage of set values\\n        uint256[256] _values;\\n        // Position of the value in the `values`\\n        BitMap256.BitMap _indexes;\\n    }\\n\\n    function _add(Set storage set, uint256 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values[value.index({shouldHash_: false})] = value;\\n            unchecked {\\n                ++set.length;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, uint256 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 idx = value.index({shouldHash_: false});\\n        uint256 valueIndex = set._values[idx] == value ? idx : 0;\\n\\n        if (valueIndex == 0) return false;\\n\\n        delete set._values[valueIndex];\\n        unchecked {\\n            --set.length;\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(\\n        Set storage set,\\n        uint256 value\\n    ) private view returns (bool) {\\n        return set._values[value.index({shouldHash_: false})] == value;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (uint256) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (uint256[] memory) {\\n        return set._values.trim(0);\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        uint256 val;\\n        assembly {\\n            val := value\\n        }\\n        return _add(set._inner, val);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        uint256 val;\\n        assembly {\\n            val := value\\n        }\\n        return _remove(set._inner, val);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        uint256 val;\\n        assembly {\\n            val := value\\n        }\\n        return _contains(set._inner, val);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        uint256 val = _at(set._inner, index);\\n        bytes32 val_;\\n        assembly {\\n            val_ := val\\n        }\\n        return val_;\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory res) {\\n        uint256[] memory val = _values(set._inner);\\n        assembly {\\n            res := val\\n        }\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        uint256 store;\\n        assembly {\\n            store := value\\n        }\\n        return _add(set._inner, store);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        uint256 store;\\n        assembly {\\n            store := value\\n        }\\n        return _remove(set._inner, store);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        uint256 store;\\n        assembly {\\n            store := value\\n        }\\n        return _contains(set._inner, store);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address addr) {\\n        uint256 value = _at(set._inner, index);\\n        assembly {\\n            addr := value\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory res) {\\n        uint256[] memory store = _values(set._inner);\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            res := store\\n        }\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        return _values(set._inner);\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\n\\nimport {BitMap256} from \\\"../../libraries/structs/BitMap256.sol\\\";\\nimport {Bytes32Address} from \\\"../../libraries/Bytes32Address.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    using Bytes32Address for address;\\n    using BitMap256 for BitMap256.BitMap;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    // role => admin\\n    mapping(bytes32 => bytes32) internal _adminRoles;\\n    // user => roles\\n    mapping(address => BitMap256.BitMap) internal _roles;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IAccessControl).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) public view virtual override returns (bool) {\\n        return\\n            _roles[account].get({value_: uint256(role), shouldHash_: false});\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account))\\n            revert AccessControl__RoleMissing(role, account);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(\\n        bytes32 role\\n    ) public view virtual override returns (bytes32 admin) {\\n        assembly {\\n            mstore(0, role)\\n            mstore(32, _adminRoles.slot)\\n            admin := sload(keccak256(0, 64))\\n        }\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(\\n        bytes32 role,\\n        address account\\n    ) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(\\n        bytes32 role,\\n        address account\\n    ) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(\\n        bytes32 role,\\n        address account\\n    ) public virtual override {\\n        if (account != _msgSender()) revert AccessControl__Unauthorized();\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        assembly {\\n            mstore(0, role)\\n            mstore(32, _adminRoles.slot)\\n            sstore(keccak256(0, 64), adminRole)\\n        }\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[account].set({value_: uint256(role), shouldHash_: false});\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[account].unset({value_: uint256(role), shouldHash_: false});\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/access/AccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\n\\nimport {IAccessControlEnumerable} from \\\"./IAccessControlEnumerable.sol\\\";\\n\\nimport {EnumerableSet256} from \\\"../../libraries/structs/EnumerableSet256.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerable is\\n    IAccessControlEnumerable,\\n    AccessControl\\n{\\n    using EnumerableSet256 for EnumerableSet256.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSet256.AddressSet) internal _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IAccessControlEnumerable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function getAllRoleMembers(\\n        bytes32 role_\\n    ) public view virtual override returns (address[] memory) {\\n        return _roleMembers[role_].values();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(\\n        bytes32 role,\\n        uint256 index\\n    ) public view virtual override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(\\n        bytes32 role\\n    ) public view virtual override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {_grantRole} to track enumerable memberships\\n     */\\n    function _grantRole(\\n        bytes32 role,\\n        address account\\n    ) internal virtual override {\\n        super._grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(\\n        bytes32 role,\\n        address account\\n    ) internal virtual override {\\n        super._revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    error AccessControl__Unauthorized();\\n    error AccessControl__RoleMissing(bytes32 role, address account);\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n\\n    function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/access/IAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerable is IAccessControl {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(\\n        bytes32 role,\\n        uint256 index\\n    ) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n\\n    function getAllRoleMembers(\\n        bytes32 role_\\n    ) external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\ninterface IPausable {\\n    error Pausable__Paused();\\n    error Pausable__NotPaused();\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev Pauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Unpauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.\\n     */\\n    function unpause() external;\\n\\n    function paused() external view returns (bool isPaused);\\n}\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context, IPausable {\\n    uint256 private __paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() payable {\\n        __paused = 1;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool isPaused) {\\n        assembly {\\n            isPaused := eq(2, sload(__paused.slot))\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) revert Pausable__Paused();\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) revert Pausable__NotPaused();\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        __paused = 2;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        __paused = 1;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata {\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    string public name;\\n    string public symbol;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) internal _allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory name_, string memory symbol_) payable {\\n        if (bytes(symbol_).length > 32 || bytes(name_).length > 32)\\n            revert ERC20__StringTooLong();\\n\\n        name = name_;\\n        symbol = symbol_;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    function decimals() public pure virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        address sender = _msgSender();\\n\\n        assembly {\\n            mstore(0, sender)\\n            mstore(32, _allowance.slot)\\n            mstore(32, keccak256(0, 64))\\n            mstore(0, spender)\\n            sstore(keccak256(0, 64), amount)\\n        }\\n\\n        emit Approval(sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        address sender = _msgSender();\\n        _beforeTokenTransfer(sender, to, amount);\\n        _balanceOf[sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            _balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(sender, to, amount);\\n\\n        _afterTokenTransfer(sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        _spendAllowance(from, _msgSender(), amount);\\n\\n        _balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            _balanceOf[to] += amount;\\n        }\\n\\n        assembly {\\n            mstore(0, amount)\\n            log3(\\n                0,\\n                0x20,\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                from,\\n                to\\n            )\\n        }\\n\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function balanceOf(\\n        address account\\n    ) external view override returns (uint256 _balance) {\\n        assembly {\\n            mstore(0, account)\\n            mstore(32, _balanceOf.slot)\\n            _balance := sload(keccak256(0, 64))\\n        }\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view override returns (uint256 allowance_) {\\n        assembly {\\n            mstore(0, owner)\\n            mstore(32, _allowance.slot)\\n            mstore(32, keccak256(0, 64))\\n            mstore(0, spender)\\n            allowance_ := sload(keccak256(0, 64))\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    function _spendAllowance(\\n        address owner_,\\n        address spender_,\\n        uint256 amount_\\n    ) internal virtual {\\n        bytes32 allowanceKey;\\n        uint256 allowed;\\n        assembly {\\n            mstore(0, owner_)\\n            mstore(32, _allowance.slot)\\n            mstore(32, keccak256(0, 64))\\n            mstore(0, spender_)\\n            allowanceKey := keccak256(0, 64)\\n            allowed := sload(allowanceKey)\\n        }\\n\\n        if (allowed == ~uint256(0)) return;\\n\\n        allowed -= amount_;\\n        assembly {\\n            sstore(allowanceKey, allowed)\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            _balanceOf[to] += amount;\\n        }\\n\\n        assembly {\\n            mstore(0, amount)\\n            log3(\\n                0,\\n                0x20,\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                0,\\n                to\\n            )\\n        }\\n\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n\\n        _balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        assembly {\\n            mstore(0, amount)\\n            log3(\\n                0,\\n                0x20,\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                from,\\n                0\\n            )\\n        }\\n\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {ERC20, IERC20} from \\\"../ERC20.sol\\\";\\n\\ninterface IERC20Burnabble is IERC20 {\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is ERC20, IERC20Burnabble {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) external virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/extensions/ERC20Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {ERC20} from \\\"../ERC20.sol\\\";\\nimport {Pausable} from \\\"../../../security/Pausable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n */\\nabstract contract ERC20Pausable is ERC20, Pausable {\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override whenNotPaused {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/extensions/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ERC20} from \\\"../ERC20.sol\\\";\\n\\nimport {Signable, Bytes32Address} from \\\"../../../../internal/Signable.sol\\\";\\n\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, Signable {\\n    using Bytes32Address for address;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    /// @dev value is equal to keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")\\n    bytes32 private constant __PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_\\n    ) payable Signable(name_, \\\"1\\\") ERC20(name_, symbol_) {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override {\\n        if (block.timestamp > deadline) revert ERC20Permit__Expired();\\n\\n        bytes32 digest;\\n        bytes32 allowanceKey;\\n        assembly {\\n            mstore(0, owner)\\n            mstore(32, _nonces.slot)\\n            let nonceKey := keccak256(0, 64)\\n            let nonce := sload(nonceKey)\\n\\n            let freeMemPtr := mload(0x40)\\n\\n            mstore(freeMemPtr, __PERMIT_TYPEHASH)\\n            mstore(add(freeMemPtr, 32), owner)\\n            mstore(add(freeMemPtr, 64), spender)\\n            mstore(add(freeMemPtr, 96), value)\\n            mstore(add(freeMemPtr, 128), nonce)\\n            mstore(add(freeMemPtr, 160), deadline)\\n            digest := keccak256(freeMemPtr, 192)\\n\\n            sstore(nonceKey, add(1, nonce))\\n\\n            mstore(32, _allowance.slot)\\n            allowanceKey := keccak256(0, 64)\\n        }\\n\\n        _verify(owner, digest, v, r, s);\\n\\n        assembly {\\n            mstore(0, spender)\\n            mstore(32, allowanceKey)\\n            sstore(keccak256(0, 64), value)\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     *\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR()\\n        external\\n        view\\n        override(IERC20Permit, Signable)\\n        returns (bytes32)\\n    {\\n        return _domainSeparatorV4();\\n    }\\n\\n    function nonces(address account_) external view returns (uint256) {\\n        return _nonces[account_.fillLast12Bytes()];\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    error ERC20Permit__Expired();\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    error ERC20__Expired();\\n    error ERC20__StringTooLong();\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address sender) {\\n        assembly {\\n            sender := caller()\\n        }\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ECDSA, EIP712} from \\\"./EIP712.sol\\\";\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\nlibrary ECDSA {\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address result) {\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            mstore(0x20, v)\\n            // If `s` in lower half order, such that the signature is not malleable.\\n            // prettier-ignore\\n            if iszero(gt(s, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0)) {\\n                mstore(0x00, hash)\\n                mstore(0x40, r)\\n                mstore(0x60, s)\\n                pop(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        0x01, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x40, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                result := mload(sub(0x60, returndatasize()))\\n            }\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    function recover(\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (address result) {\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            // Directly load `s` from the calldata.\\n            let s := calldataload(add(signature.offset, 0x20))\\n\\n            switch signature.length\\n            case 64 {\\n                // Here, `s` is actually `vs` that needs to be recovered into `v` and `s`.\\n                // Compute `v` and store it in the scratch space.\\n                mstore(0x20, add(shr(255, s), 27))\\n                // prettier-ignore\\n                s := and(s, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            }\\n            case 65 {\\n                // Compute `v` and store it in the scratch space.\\n                mstore(\\n                    0x20,\\n                    byte(0, calldataload(add(signature.offset, 0x40)))\\n                )\\n            }\\n\\n            // If `s` in lower half order, such that the signature is not malleable.\\n            // prettier-ignore\\n            if iszero(gt(s, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0)) {\\n                mstore(0x00, hash)\\n                calldatacopy(0x40, signature.offset, 0x20) // Directly copy `r` over.\\n                mstore(0x60, s)\\n                pop(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        0x01, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x40, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                result := mload(sub(0x60, returndatasize()))\\n            }\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    function toTypedDataHash(\\n        bytes32 domainSeparator,\\n        bytes32 structHash\\n    ) internal pure returns (bytes32 result) {\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(\\n                memPtr,\\n                0x1901000000000000000000000000000000000000000000000000000000000000\\n            ) // EIP191 header\\n            mstore(add(memPtr, 2), domainSeparator) // EIP712 domain hash\\n            mstore(add(memPtr, 34), structHash) // Hash of struct\\n\\n            // Compute hash\\n            result := keccak256(memPtr, 66)\\n        }\\n    }\\n\\n    function toEthSignedMessageHash(\\n        bytes32 hash\\n    ) internal pure returns (bytes32 result) {\\n        assembly {\\n            // Store into scratch space for keccak256.\\n            mstore(0x20, hash)\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            // 0x40 - 0x04 = 0x3c\\n            result := keccak256(0x04, 0x3c)\\n        }\\n    }\\n\\n    function toEthSignedMessageHash(\\n        bytes memory s\\n    ) internal pure returns (bytes32 result) {\\n        assembly {\\n            // We need at most 128 bytes for Ethereum signed message header.\\n            // The max length of the ASCII reprenstation of a uint256 is 78 bytes.\\n            // The length of \\\"\\\\x19Ethereum Signed Message:\\\\n\\\" is 26 bytes.\\n            // The next multiple of 32 above 78 + 26 is 128.\\n\\n            // Instead of allocating, we temporarily copy the 128 bytes before the\\n            // start of `s` data to some variables.\\n            let m3 := mload(sub(s, 0x60))\\n            let m2 := mload(sub(s, 0x40))\\n            let m1 := mload(sub(s, 0x20))\\n            // The length of `s` is in bytes.\\n            let sLength := mload(s)\\n\\n            let ptr := add(s, 0x20)\\n\\n            // `end` marks the end of the memory which we will compute the keccak256 of.\\n            let end := add(ptr, sLength)\\n\\n            // Convert the length of the bytes to ASCII decimal representation\\n            // and store it into the memory.\\n            for {\\n                let temp := sLength\\n                ptr := sub(ptr, 1)\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n            } temp {\\n                temp := div(temp, 10)\\n            } {\\n                ptr := sub(ptr, 1)\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n            }\\n\\n            // Move the pointer 32 bytes lower to make room for the string.\\n            // `start` marks the start of the memory which we will compute the keccak256 of.\\n            let start := sub(ptr, 32)\\n            // Copy the header over to the memory.\\n            mstore(\\n                start,\\n                \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n\\\"\\n            )\\n            start := add(start, 6)\\n\\n            // Compute the keccak256 of the memory.\\n            result := keccak256(start, sub(end, start))\\n\\n            // Restore the previous memory.\\n            mstore(s, sLength)\\n            mstore(sub(s, 0x20), m1)\\n            mstore(sub(s, 0x40), m2)\\n            mstore(sub(s, 0x60), m3)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/cryptography/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {ECDSA} from \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) payable {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        ///@dev 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f is equal to keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\\n            0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\\n            hashedName,\\n            hashedVersion\\n        );\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID)\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        else\\n            return\\n                _buildDomainSeparator(\\n                    _TYPE_HASH,\\n                    _HASHED_NAME,\\n                    _HASHED_VERSION\\n                );\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32 domainSeparatorV4) {\\n        assembly {\\n            mstore(0, typeHash)\\n            mstore(32, nameHash)\\n            mstore(64, versionHash)\\n            mstore(96, chainid())\\n            mstore(128, address())\\n            domainSeparatorV4 := keccak256(0, 160)\\n        }\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(\\n        bytes32 structHash\\n    ) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/structs/BitMaps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMaps {\\n    struct BitMap {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(\\n        BitMap storage bitmap,\\n        uint256 index\\n    ) internal view returns (bool isSet) {\\n        assembly {\\n            mstore(0, shr(8, index))\\n            mstore(32, bitmap.slot)\\n            // Assign isSet to whether the value is non zero.\\n            isSet := and(sload(keccak256(0, 64)), shl(and(index, 0xff), 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(\\n        BitMap storage bitmap,\\n        uint256 index,\\n        bool shouldSet\\n    ) internal {\\n        assembly {\\n            mstore(0, shr(8, index))\\n            mstore(32, bitmap.slot)\\n            let mapKey := keccak256(0, 64)\\n            let value := sload(mapKey)\\n\\n            // The following sets the bit at `shift` without branching.\\n            let shift := and(index, 0xff)\\n            // Isolate the bit at `shift`.\\n            let x := and(shr(shift, value), 1)\\n            // Xor it with `shouldSet`. Results in 1 if both are different, else 0.\\n            x := xor(x, shouldSet)\\n            // Shifts the bit back. Then, xor with value.\\n            // Only the bit at `shift` will be flipped if they differ.\\n            // Every other bit will stay the same, as they are xor'ed with zeroes.\\n            value := xor(value, shl(shift, x))\\n\\n            sstore(mapKey, value)\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        assembly {\\n            mstore(0, shr(8, index))\\n            mstore(32, bitmap.slot)\\n            let key := keccak256(0, 64)\\n            let value := sload(key)\\n            value := or(value, shl(and(index, 0xff), 1))\\n            sstore(key, value)\\n        }\\n    }\\n\\n    function setBatch(\\n        BitMap storage bitmap_,\\n        uint256[] calldata values_\\n    ) internal {\\n        assembly {\\n            let length := values_.length\\n            let i := add(calldataload(values_.offset), 0x20)\\n            mstore(0x20, bitmap_.slot)\\n            for {\\n                let end := add(i, shl(5, length))\\n            } lt(i, end) {\\n                i := add(i, 0x20)\\n            } {\\n                mstore(0x00, shr(8, mload(i)))\\n                let key := keccak256(0x00, 0x40)\\n                sstore(key, or(sload(key), shl(and(mload(i), 0xff), 1)))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/presets/token/interfaces/IWNT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IERC20} from \\\"../../../oz/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWNT is IERC20 {\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialSupply_\",\"type\":\"uint256\"},{\"internalType\":\"contract IWNT\",\"name\":\"wnt_\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"priceFeed_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccessControl__RoleMissing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AccessControl__Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BountyKindsERC20__Blacklisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BountyKindsERC20__InvalidArguments\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Permit__Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20__Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20__StringTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorHandler__ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__NotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Signable__InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Taxable__AlreadyEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Taxable__InvalidArguments\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Taxable__TaxDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Transferable__InvalidArguments\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Transferable__TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NonceIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"poolOld\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"poolNew\",\"type\":\"address\"}],\"name\":\"PoolSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldBeneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"TaxBeneficiarySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"TaxEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isBlacklisted\",\"type\":\"bool\"}],\"name\":\"UserStatusSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts_\",\"type\":\"address[]\"}],\"name\":\"areBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"calldata_\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role_\",\"type\":\"bytes32\"}],\"name\":\"getAllRoleMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"admin\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTaxEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"}],\"name\":\"setTaxBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status_\",\"type\":\"bool\"}],\"name\":\"setUserStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxEnabledDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxEnabledTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"taxFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wnt\",\"outputs\":[{\"internalType\":\"contract IWNT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BountyKindsERC20", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000c065ee0cab9ecbd0b80f3a3cc219acce441573c6000000000000000000000000ee0f91b31c883f98c6bf73d3db27eca2be807e430000000000000000000000000000000000000000000000000000000000989680000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c0000000000000000000000000567f2323251f0aab15c8dfb1967e4e8a7d42aee0000000000000000000000000000000000000000000000000000000000000016464f5242494444454e20465255495420454e455247590000000000000000000000000000000000000000000000000000000000000000000000000000000000034646450000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}