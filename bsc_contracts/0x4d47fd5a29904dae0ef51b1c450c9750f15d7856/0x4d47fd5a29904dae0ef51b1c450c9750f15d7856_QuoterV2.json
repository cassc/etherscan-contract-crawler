{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/periphery/QuoterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\npragma abicoder v2;\\n\\nimport {SafeCast} from '../libraries/SafeCast.sol';\\nimport {TickMath} from '../libraries/TickMath.sol';\\nimport {PathHelper} from './libraries/PathHelper.sol';\\nimport {PoolAddress} from './libraries/PoolAddress.sol';\\nimport {PoolTicksCounter} from './libraries/PoolTicksCounter.sol';\\n\\nimport {IPool} from '../interfaces/IPool.sol';\\nimport {IFactory} from '../interfaces/IFactory.sol';\\nimport {ISwapCallback} from '../interfaces/callback/ISwapCallback.sol';\\nimport {IQuoterV2} from '../interfaces/periphery/IQuoterV2.sol';\\n\\n/// @title Provides quotes for swaps\\n/// @notice Allows getting the expected amount out or amount in for a given swap without executing the swap\\n/// @dev These functions are not gas efficient and should _not_ be called on chain. Instead, optimistically execute\\n/// the swap and check the amounts in the callback.\\ncontract QuoterV2 is IQuoterV2, ISwapCallback {\\n  using PathHelper for bytes;\\n  using SafeCast for uint256;\\n\\n  address public immutable factory;\\n  bytes32 internal immutable poolInitHash;\\n\\n  /// @dev Transient storage variable used to check a safety condition in exact output swaps.\\n  uint256 private amountOutCached;\\n\\n  constructor(address _factory) {\\n    factory = _factory;\\n    poolInitHash = IFactory(_factory).poolInitHash();\\n  }\\n\\n  /**\\n   * @dev Returns the pool address for the requested token pair swap fee\\n   * Because the function calculates it instead of fetching the address from the factory,\\n   * the returned pool address may not be in existence yet\\n   */\\n  function _getPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 feeUnits\\n  ) private view returns (IPool) {\\n    return IPool(PoolAddress.computeAddress(factory, tokenA, tokenB, feeUnits, poolInitHash));\\n  }\\n\\n  /// @inheritdoc ISwapCallback\\n  function swapCallback(\\n    int256 amount0Delta,\\n    int256 amount1Delta,\\n    bytes memory path\\n  ) external view override {\\n    require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\\n    (address tokenIn, address tokenOut, uint24 feeUnits) = path.decodeFirstPool();\\n    IPool pool = _getPool(tokenIn, tokenOut, feeUnits);\\n    require(address(pool) == msg.sender, 'invalid sender');\\n    (uint160 afterSqrtP, , int24 nearestCurrentTickAfter, ) = pool.getPoolState();\\n\\n    (bool isExactInput, uint256 amountToPay, uint256 amountReceived) = amount0Delta > 0\\n      ? (tokenIn < tokenOut, uint256(amount0Delta), uint256(-amount1Delta))\\n      : (tokenOut < tokenIn, uint256(amount1Delta), uint256(-amount0Delta));\\n\\n    if (isExactInput) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(ptr, amountToPay)\\n        mstore(add(ptr, 0x20), amountReceived)\\n        mstore(add(ptr, 0x40), afterSqrtP)\\n        mstore(add(ptr, 0x60), nearestCurrentTickAfter)\\n        revert(ptr, 128)\\n      }\\n    } else {\\n      // if the cache has been populated, ensure that the full output amount has been received\\n      if (amountOutCached != 0) require(amountReceived == amountOutCached);\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(ptr, amountReceived)\\n        mstore(add(ptr, 0x20), amountToPay)\\n        mstore(add(ptr, 0x40), afterSqrtP)\\n        mstore(add(ptr, 0x60), nearestCurrentTickAfter)\\n        revert(ptr, 128)\\n      }\\n    }\\n  }\\n\\n  /// @dev Parses a revert reason that should contain the numeric quote\\n  function _parseRevertReason(bytes memory reason)\\n    private\\n    pure\\n    returns (\\n      uint256 usedAmount,\\n      uint256 returnedAmount,\\n      uint160 afterSqrtP,\\n      int24 tickAfter\\n    )\\n  {\\n    if (reason.length != 128) {\\n      if (reason.length < 68) revert('Unexpected error');\\n      assembly {\\n        reason := add(reason, 0x04)\\n      }\\n      revert(abi.decode(reason, (string)));\\n    }\\n    return abi.decode(reason, (uint256, uint256, uint160, int24));\\n  }\\n\\n  function _handleRevert(\\n    bytes memory reason,\\n    IPool pool,\\n    uint256 gasEstimate\\n  ) private view returns (QuoteOutput memory output) {\\n    int24 nearestCurrentTickBefore;\\n    int24 nearestCurrentTickAfter;\\n    (, , nearestCurrentTickBefore, ) = pool.getPoolState();\\n    (\\n      output.usedAmount,\\n      output.returnedAmount,\\n      output.afterSqrtP,\\n      nearestCurrentTickAfter\\n    ) = _parseRevertReason(reason);\\n    output.initializedTicksCrossed = PoolTicksCounter.countInitializedTicksCrossed(\\n      pool,\\n      nearestCurrentTickBefore,\\n      nearestCurrentTickAfter\\n    );\\n    output.gasEstimate = gasEstimate;\\n  }\\n\\n  function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\\n    public\\n    override\\n    returns (QuoteOutput memory output)\\n  {\\n    // if tokenIn < tokenOut, token input and specified token is token0, swap from 0 to 1\\n    bool isToken0 = params.tokenIn < params.tokenOut;\\n    IPool pool = _getPool(params.tokenIn, params.tokenOut, params.feeUnits);\\n    bytes memory data = abi.encodePacked(params.tokenIn, params.feeUnits, params.tokenOut);\\n    uint160 priceLimit = params.limitSqrtP == 0\\n      ? (isToken0 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\\n      : params.limitSqrtP;\\n    uint256 gasBefore = gasleft();\\n    try pool.swap(address(this), params.amountIn.toInt256(), isToken0, priceLimit, data) {} catch (\\n      bytes memory reason\\n    ) {\\n      uint256 gasEstimate = gasBefore - gasleft();\\n      output = _handleRevert(reason, pool, gasEstimate);\\n    }\\n  }\\n\\n  function quoteExactInput(bytes memory path, uint256 amountIn)\\n    public\\n    override\\n    returns (\\n      uint256 amountOut,\\n      uint160[] memory afterSqrtPList,\\n      uint32[] memory initializedTicksCrossedList,\\n      uint256 gasEstimate\\n    )\\n  {\\n    afterSqrtPList = new uint160[](path.numPools());\\n    initializedTicksCrossedList = new uint32[](path.numPools());\\n\\n    uint256 i = 0;\\n    while (true) {\\n      (address tokenIn, address tokenOut, uint24 feeUnits) = path.decodeFirstPool();\\n\\n      // the outputs of prior swaps become the inputs to subsequent ones\\n      QuoteOutput memory quoteOutput = quoteExactInputSingle(\\n        QuoteExactInputSingleParams({\\n          tokenIn: tokenIn,\\n          tokenOut: tokenOut,\\n          feeUnits: feeUnits,\\n          amountIn: amountIn,\\n          limitSqrtP: 0\\n        })\\n      );\\n\\n      afterSqrtPList[i] = quoteOutput.afterSqrtP;\\n      initializedTicksCrossedList[i] = quoteOutput.initializedTicksCrossed;\\n      amountIn = quoteOutput.returnedAmount;\\n      gasEstimate += quoteOutput.gasEstimate;\\n      i++;\\n\\n      // decide whether to continue or terminate\\n      if (path.hasMultiplePools()) {\\n        path = path.skipToken();\\n      } else {\\n        return (amountIn, afterSqrtPList, initializedTicksCrossedList, gasEstimate);\\n      }\\n    }\\n  }\\n\\n  function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\\n    public\\n    override\\n    returns (QuoteOutput memory output)\\n  {\\n    // if tokenIn > tokenOut, output token and specified token is token0, swap from token1 to token0\\n    bool isToken0 = params.tokenIn > params.tokenOut;\\n    IPool pool = _getPool(params.tokenIn, params.tokenOut, params.feeUnits);\\n\\n    // if no price limit has been specified, cache the output amount for comparison in the swap callback\\n    if (params.limitSqrtP == 0) amountOutCached = params.amount;\\n    uint256 gasBefore = gasleft();\\n    try\\n      pool.swap(\\n        address(this), // address(0) might cause issues with some tokens\\n        -params.amount.toInt256(),\\n        isToken0,\\n        params.limitSqrtP == 0\\n          ? (isToken0 ? TickMath.MAX_SQRT_RATIO - 1 : TickMath.MIN_SQRT_RATIO + 1)\\n          : params.limitSqrtP,\\n        abi.encodePacked(params.tokenOut, params.feeUnits, params.tokenIn)\\n      )\\n    {} catch (bytes memory reason) {\\n      uint256 gasEstimate = gasBefore - gasleft();\\n      if (params.limitSqrtP == 0) delete amountOutCached; // clear cache\\n      output = _handleRevert(reason, pool, gasEstimate);\\n    }\\n  }\\n\\n  function quoteExactOutput(bytes memory path, uint256 amountOut)\\n    public\\n    override\\n    returns (\\n      uint256 amountIn,\\n      uint160[] memory afterSqrtPList,\\n      uint32[] memory initializedTicksCrossedList,\\n      uint256 gasEstimate\\n    )\\n  {\\n    afterSqrtPList = new uint160[](path.numPools());\\n    initializedTicksCrossedList = new uint32[](path.numPools());\\n\\n    uint256 i = 0;\\n    while (true) {\\n      (address tokenOut, address tokenIn, uint24 feeUnits) = path.decodeFirstPool();\\n\\n      // the inputs of prior swaps become the outputs of subsequent ones\\n      QuoteOutput memory quoteOutput = quoteExactOutputSingle(\\n        QuoteExactOutputSingleParams({\\n          tokenIn: tokenIn,\\n          tokenOut: tokenOut,\\n          amount: amountOut,\\n          feeUnits: feeUnits,\\n          limitSqrtP: 0\\n        })\\n      );\\n      afterSqrtPList[i] = quoteOutput.afterSqrtP;\\n      initializedTicksCrossedList[i] = quoteOutput.initializedTicksCrossed;\\n      amountOut = quoteOutput.returnedAmount;\\n      gasEstimate += quoteOutput.gasEstimate;\\n      i++;\\n\\n      // decide whether to continue or terminate\\n      if (path.hasMultiplePools()) {\\n        path = path.skipToken();\\n      } else {\\n        return (amountOut, afterSqrtPList, initializedTicksCrossedList, gasEstimate);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n  /// @notice Cast a uint256 to uint32, revert on overflow\\n  /// @param y The uint256 to be downcasted\\n  /// @return z The downcasted integer, now type uint32\\n  function toUint32(uint256 y) internal pure returns (uint32 z) {\\n    require((z = uint32(y)) == y);\\n  }\\n\\n  /// @notice Cast a uint128 to a int128, revert on overflow\\n  /// @param y The uint256 to be casted\\n  /// @return z The casted integer, now type int256\\n  function toInt128(uint128 y) internal pure returns (int128 z) {\\n    require(y < 2**127);\\n    z = int128(y);\\n  }\\n\\n  /// @notice Cast a uint256 to a uint128, revert on overflow\\n  /// @param y the uint256 to be downcasted\\n  /// @return z The downcasted integer, now type uint128\\n  function toUint128(uint256 y) internal pure returns (uint128 z) {\\n    require((z = uint128(y)) == y);\\n  }\\n\\n  /// @notice Cast a int128 to a uint128 and reverses the sign.\\n  /// @param y The int128 to be casted\\n  /// @return z = -y, now type uint128\\n  function revToUint128(int128 y) internal pure returns (uint128 z) {\\n    unchecked {\\n      return type(uint128).max - uint128(y) + 1;\\n    }\\n  }\\n\\n  /// @notice Cast a uint256 to a uint160, revert on overflow\\n  /// @param y The uint256 to be downcasted\\n  /// @return z The downcasted integer, now type uint160\\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\\n    require((z = uint160(y)) == y);\\n  }\\n\\n  /// @notice Cast a uint256 to a int256, revert on overflow\\n  /// @param y The uint256 to be casted\\n  /// @return z The casted integer, now type int256\\n  function toInt256(uint256 y) internal pure returns (int256 z) {\\n    require(y < 2**255);\\n    z = int256(y);\\n  }\\n\\n  /// @notice Cast a uint256 to a int256 and reverses the sign, revert on overflow\\n  /// @param y The uint256 to be casted\\n  /// @return z = -y, now type int256\\n  function revToInt256(uint256 y) internal pure returns (int256 z) {\\n    require(y < 2**255);\\n    z = -int256(y);\\n  }\\n\\n  /// @notice Cast a int256 to a uint256 and reverses the sign.\\n  /// @param y The int256 to be casted\\n  /// @return z = -y, now type uint256\\n  function revToUint256(int256 y) internal pure returns (uint256 z) {\\n    unchecked {\\n      return type(uint256).max - uint256(y) + 1;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n  int24 internal constant MIN_TICK = -887272;\\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n  int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n  /// @dev Throws if |tick| > max tick\\n  /// @param tick The input tick for the above formula\\n  /// @return sqrtP A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n  /// at the given tick\\n  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtP) {\\n    unchecked {\\n      uint256 absTick = uint256(tick < 0 ? -int256(tick) : int256(tick));\\n      require(absTick <= uint256(int256(MAX_TICK)), 'T');\\n\\n      // do bitwise comparison, if i-th bit is turned on,\\n      // multiply ratio by hardcoded values of sqrt(1.0001^-(2^i)) * 2^128\\n      // where 0 <= i <= 19\\n      uint256 ratio = (absTick & 0x1 != 0)\\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\\n        : 0x100000000000000000000000000000000;\\n      if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n      if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n      if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n      if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n      if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n      if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n      if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n      if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n      if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n      if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n      if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n      if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n      if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n      if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n      if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n      if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n      if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n      if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n      if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n      // take reciprocal for positive tick values\\n      if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n      // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n      // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n      // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n      sqrtP = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n  }\\n\\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n  /// @dev Throws in case sqrtP < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n  /// ever return.\\n  /// @param sqrtP The sqrt ratio for which to compute the tick as a Q64.96\\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n  function getTickAtSqrtRatio(uint160 sqrtP) internal pure returns (int24 tick) {\\n    // second inequality must be < because the price can never reach the price at the max tick\\n    require(sqrtP >= MIN_SQRT_RATIO && sqrtP < MAX_SQRT_RATIO, 'R');\\n    uint256 ratio = uint256(sqrtP) << 32;\\n\\n    uint256 r = ratio;\\n    uint256 msb = 0;\\n\\n    unchecked {\\n      assembly {\\n        let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(5, gt(r, 0xFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(4, gt(r, 0xFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(3, gt(r, 0xFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(2, gt(r, 0xF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(1, gt(r, 0x3))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := gt(r, 0x1)\\n        msb := or(msb, f)\\n      }\\n\\n      if (msb >= 128) r = ratio >> (msb - 127);\\n      else r = ratio << (127 - msb);\\n\\n      int256 log_2 = (int256(msb) - 128) << 64;\\n\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(63, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(62, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(61, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(60, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(59, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(58, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(57, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(56, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(55, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(54, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(53, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(52, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(51, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(50, f))\\n      }\\n\\n      int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n      int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n      int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n      tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtP ? tickHi : tickLow;\\n    }\\n  }\\n\\n  function getMaxNumberTicks(int24 _tickDistance) internal pure returns (uint24 numTicks) {\\n    return uint24(TickMath.MAX_TICK / _tickDistance) * 2;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/libraries/PathHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\nimport './BytesLib.sol';\\n\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary PathHelper {\\n  using BytesLib for bytes;\\n\\n  /// @dev The length of the bytes encoded address\\n  uint256 private constant ADDR_SIZE = 20;\\n  /// @dev The length of the bytes encoded fee\\n  uint256 private constant FEE_SIZE = 3;\\n\\n  /// @dev The offset of a single token address and pool fee\\n  uint256 private constant TOKEN_AND_POOL_OFFSET = ADDR_SIZE + FEE_SIZE;\\n  /// @dev The offset of an encoded pool data\\n  uint256 private constant POOL_DATA_OFFSET = TOKEN_AND_POOL_OFFSET + ADDR_SIZE;\\n  /// @dev The minimum length of an encoding that contains 2 or more pools\\n  uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POOL_DATA_OFFSET + TOKEN_AND_POOL_OFFSET;\\n\\n  /// @notice Returns true iff the path contains two or more pools\\n  /// @param path The encoded swap path\\n  /// @return True if path contains two or more pools, otherwise false\\n  function hasMultiplePools(bytes memory path) internal pure returns (bool) {\\n    return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\\n  }\\n\\n  /// @notice Returns the number of pools in the path\\n  /// @param path The encoded swap path\\n  /// @return The number of pools in the path\\n  function numPools(bytes memory path) internal pure returns (uint256) {\\n    // Ignore the first token address. From then on every fee and token offset indicates a pool.\\n    return ((path.length - ADDR_SIZE) / TOKEN_AND_POOL_OFFSET);\\n  }\\n\\n  /// @notice Decodes the first pool in path\\n  /// @param path The bytes encoded swap path\\n  /// @return tokenA The first token of the given pool\\n  /// @return tokenB The second token of the given pool\\n  /// @return fee The fee level of the pool\\n  function decodeFirstPool(bytes memory path)\\n    internal\\n    pure\\n    returns (\\n      address tokenA,\\n      address tokenB,\\n      uint24 fee\\n    )\\n  {\\n    tokenA = path.toAddress(0);\\n    fee = path.toUint24(ADDR_SIZE);\\n    tokenB = path.toAddress(TOKEN_AND_POOL_OFFSET);\\n  }\\n\\n  /// @notice Gets the segment corresponding to the first pool in the path\\n  /// @param path The bytes encoded swap path\\n  /// @return The segment containing all data necessary to target the first pool in the path\\n  function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\\n    return path.slice(0, POOL_DATA_OFFSET);\\n  }\\n\\n  /// @notice Skips a token + fee element from the buffer and returns the remainder\\n  /// @param path The swap path\\n  /// @return The remaining token + fee elements in the path\\n  function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n    return path.slice(TOKEN_AND_POOL_OFFSET, path.length - TOKEN_AND_POOL_OFFSET);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/libraries/PoolAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\n/// @title Provides a function for deriving a pool address from the factory, tokens, and swap fee\\nlibrary PoolAddress {\\n  /// @notice Deterministically computes the pool address from the given data\\n  /// @param factory the factory address\\n  /// @param token0 One of the tokens constituting the token pair, regardless of order\\n  /// @param token1 The other token constituting the token pair, regardless of order\\n  /// @param swapFee Fee to be collected upon every swap in the pool, in fee units\\n  /// @param poolInitHash The keccak256 hash of the Pool creation code\\n  /// @return pool the pool address\\n  function computeAddress(\\n    address factory,\\n    address token0,\\n    address token1,\\n    uint24 swapFee,\\n    bytes32 poolInitHash\\n  ) internal pure returns (address pool) {\\n    (token0, token1) = token0 < token1 ? (token0, token1) : (token1, token0);\\n    bytes32 hashed = keccak256(\\n      abi.encodePacked(\\n        hex'ff',\\n        factory,\\n        keccak256(abi.encode(token0, token1, swapFee)),\\n        poolInitHash\\n      )\\n    );\\n    pool = address(uint160(uint256(hashed)));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/libraries/PoolTicksCounter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\nimport {IPool} from '../../interfaces/IPool.sol';\\n\\nlibrary PoolTicksCounter {\\n  function countInitializedTicksCrossed(\\n    IPool self,\\n    int24 nearestCurrentTickBefore,\\n    int24 nearestCurrentTickAfter\\n  ) internal view returns (uint32 initializedTicksCrossed) {\\n    initializedTicksCrossed = 0;\\n    (int24 tickLower, int24 tickUpper) = (nearestCurrentTickBefore < nearestCurrentTickAfter)\\n      ? (nearestCurrentTickBefore, nearestCurrentTickAfter)\\n      : (nearestCurrentTickAfter, nearestCurrentTickBefore);\\n    while (tickLower != tickUpper) {\\n      initializedTicksCrossed++;\\n      (, tickLower) = self.initializedTicks(tickLower);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IPoolActions} from './pool/IPoolActions.sol';\\nimport {IPoolEvents} from './pool/IPoolEvents.sol';\\nimport {IPoolStorage} from './pool/IPoolStorage.sol';\\n\\ninterface IPool is IPoolActions, IPoolEvents, IPoolStorage {}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title KyberSwap v2 factory\\n/// @notice Deploys KyberSwap v2 pools and manages control over government fees\\ninterface IFactory {\\n  /// @notice Emitted when a pool is created\\n  /// @param token0 First pool token by address sort order\\n  /// @param token1 Second pool token by address sort order\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\n  /// @param tickDistance Minimum number of ticks between initialized ticks\\n  /// @param pool The address of the created pool\\n  event PoolCreated(\\n    address indexed token0,\\n    address indexed token1,\\n    uint24 indexed swapFeeUnits,\\n    int24 tickDistance,\\n    address pool\\n  );\\n\\n  /// @notice Emitted when a new fee is enabled for pool creation via the factory\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\n  /// @param tickDistance Minimum number of ticks between initialized ticks for pools created with the given fee\\n  event SwapFeeEnabled(uint24 indexed swapFeeUnits, int24 indexed tickDistance);\\n\\n  /// @notice Emitted when vesting period changes\\n  /// @param vestingPeriod The maximum time duration for which LP fees\\n  /// are proportionally burnt upon LP removals\\n  event VestingPeriodUpdated(uint32 vestingPeriod);\\n\\n  /// @notice Emitted when configMaster changes\\n  /// @param oldConfigMaster configMaster before the update\\n  /// @param newConfigMaster configMaster after the update\\n  event ConfigMasterUpdated(address oldConfigMaster, address newConfigMaster);\\n\\n  /// @notice Emitted when fee configuration changes\\n  /// @param feeTo Recipient of government fees\\n  /// @param governmentFeeUnits Fee amount, in fee units,\\n  /// to be collected out of the fee charged for a pool swap\\n  event FeeConfigurationUpdated(address feeTo, uint24 governmentFeeUnits);\\n\\n  /// @notice Emitted when whitelist feature is enabled\\n  event WhitelistEnabled();\\n\\n  /// @notice Emitted when whitelist feature is disabled\\n  event WhitelistDisabled();\\n\\n  /// @notice Returns the maximum time duration for which LP fees\\n  /// are proportionally burnt upon LP removals\\n  function vestingPeriod() external view returns (uint32);\\n\\n  /// @notice Returns the tick distance for a specified fee.\\n  /// @dev Once added, cannot be updated or removed.\\n  /// @param swapFeeUnits Swap fee, in fee units.\\n  /// @return The tick distance. Returns 0 if fee has not been added.\\n  function feeAmountTickDistance(uint24 swapFeeUnits) external view returns (int24);\\n\\n  /// @notice Returns the address which can update the fee configuration\\n  function configMaster() external view returns (address);\\n\\n  /// @notice Returns the keccak256 hash of the Pool creation code\\n  /// This is used for pre-computation of pool addresses\\n  function poolInitHash() external view returns (bytes32);\\n\\n  /// @notice Returns the pool oracle contract for twap\\n  function poolOracle() external view returns (address);\\n\\n  /// @notice Fetches the recipient of government fees\\n  /// and current government fee charged in fee units\\n  function feeConfiguration() external view returns (address _feeTo, uint24 _governmentFeeUnits);\\n\\n  /// @notice Returns the status of whitelisting feature of NFT managers\\n  /// If true, anyone can mint liquidity tokens\\n  /// Otherwise, only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  function whitelistDisabled() external view returns (bool);\\n\\n  //// @notice Returns all whitelisted NFT managers\\n  /// If the whitelisting feature is turned on,\\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  function getWhitelistedNFTManagers() external view returns (address[] memory);\\n\\n  /// @notice Checks if sender is a whitelisted NFT manager\\n  /// If the whitelisting feature is turned on,\\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  /// @param sender address to be checked\\n  /// @return true if sender is a whistelisted NFT manager, false otherwise\\n  function isWhitelistedNFTManager(address sender) external view returns (bool);\\n\\n  /// @notice Returns the pool address for a given pair of tokens and a swap fee\\n  /// @dev Token order does not matter\\n  /// @param tokenA Contract address of either token0 or token1\\n  /// @param tokenB Contract address of the other token\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\n  /// @return pool The pool address. Returns null address if it does not exist\\n  function getPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 swapFeeUnits\\n  ) external view returns (address pool);\\n\\n  /// @notice Fetch parameters to be used for pool creation\\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\\n  /// @return factory The factory address\\n  /// @return poolOracle The pool oracle for twap\\n  /// @return token0 First pool token by address sort order\\n  /// @return token1 Second pool token by address sort order\\n  /// @return swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\n  /// @return tickDistance Minimum number of ticks between initialized ticks\\n  function parameters()\\n    external\\n    view\\n    returns (\\n      address factory,\\n      address poolOracle,\\n      address token0,\\n      address token1,\\n      uint24 swapFeeUnits,\\n      int24 tickDistance\\n    );\\n\\n  /// @notice Creates a pool for the given two tokens and fee\\n  /// @param tokenA One of the two tokens in the desired pool\\n  /// @param tokenB The other of the two tokens in the desired pool\\n  /// @param swapFeeUnits Desired swap fee for the pool, in fee units\\n  /// @dev Token order does not matter. tickDistance is determined from the fee.\\n  /// Call will revert under any of these conditions:\\n  ///     1) pool already exists\\n  ///     2) invalid swap fee\\n  ///     3) invalid token arguments\\n  /// @return pool The address of the newly created pool\\n  function createPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 swapFeeUnits\\n  ) external returns (address pool);\\n\\n  /// @notice Enables a fee amount with the given tickDistance\\n  /// @dev Fee amounts may never be removed once enabled\\n  /// @param swapFeeUnits The fee amount to enable, in fee units\\n  /// @param tickDistance The distance between ticks to be enforced for all pools created with the given fee amount\\n  function enableSwapFee(uint24 swapFeeUnits, int24 tickDistance) external;\\n\\n  /// @notice Updates the address which can update the fee configuration\\n  /// @dev Must be called by the current configMaster\\n  function updateConfigMaster(address) external;\\n\\n  /// @notice Updates the vesting period\\n  /// @dev Must be called by the current configMaster\\n  function updateVestingPeriod(uint32) external;\\n\\n  /// @notice Updates the address receiving government fees and fee quantity\\n  /// @dev Only configMaster is able to perform the update\\n  /// @param feeTo Address to receive government fees collected from pools\\n  /// @param governmentFeeUnits Fee amount, in fee units,\\n  /// to be collected out of the fee charged for a pool swap\\n  function updateFeeConfiguration(address feeTo, uint24 governmentFeeUnits) external;\\n\\n  /// @notice Enables the whitelisting feature\\n  /// @dev Only configMaster is able to perform the update\\n  function enableWhitelist() external;\\n\\n  /// @notice Disables the whitelisting feature\\n  /// @dev Only configMaster is able to perform the update\\n  function disableWhitelist() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/callback/ISwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title Callback for IPool#swap\\n/// @notice Any contract that calls IPool#swap must implement this interface\\ninterface ISwapCallback {\\n  /// @notice Called to `msg.sender` after swap execution of IPool#swap.\\n  /// @dev This function's implementation must pay tokens owed to the pool for the swap.\\n  /// The caller of this method must be checked to be a Pool deployed by the canonical Factory.\\n  /// deltaQty0 and deltaQty1 can both be 0 if no tokens were swapped.\\n  /// @param deltaQty0 The token0 quantity that was sent (negative) or must be received (positive) by the pool by\\n  /// the end of the swap. If positive, the callback must send deltaQty0 of token0 to the pool.\\n  /// @param deltaQty1 The token1 quantity that was sent (negative) or must be received (positive) by the pool by\\n  /// the end of the swap. If positive, the callback must send deltaQty1 of token1 to the pool.\\n  /// @param data Data passed through by the caller via the IPool#swap call\\n  function swapCallback(\\n    int256 deltaQty0,\\n    int256 deltaQty1,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/periphery/IQuoterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\npragma abicoder v2;\\n\\n/// @title QuoterV2 Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoterV2 {\\n  struct QuoteOutput {\\n    uint256 usedAmount;\\n    uint256 returnedAmount;\\n    uint160 afterSqrtP;\\n    uint32 initializedTicksCrossed;\\n    uint256 gasEstimate;\\n  }\\n\\n  /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\\n  /// @param amountIn The amount of the first token to swap\\n  /// @return amountOut The amount of the last token that would be received\\n  /// @return afterSqrtPList List of the sqrt price after the swap for each pool in the path\\n  /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\\n  /// @return gasEstimate The estimate of the gas that the swap consumes\\n  function quoteExactInput(bytes memory path, uint256 amountIn)\\n    external\\n    returns (\\n      uint256 amountOut,\\n      uint160[] memory afterSqrtPList,\\n      uint32[] memory initializedTicksCrossedList,\\n      uint256 gasEstimate\\n    );\\n\\n  struct QuoteExactInputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint256 amountIn;\\n    uint24 feeUnits;\\n    uint160 limitSqrtP;\\n  }\\n\\n  /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n  /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\\n  /// tokenIn The token being swapped in\\n  /// tokenOut The token being swapped out\\n  /// fee The fee of the token pool to consider for the pair\\n  /// amountIn The desired input amount\\n  /// limitSqrtP The price limit of the pool that cannot be exceeded by the swap\\n  function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\\n    external\\n    returns (QuoteOutput memory);\\n\\n  /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n  /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n  /// @param amountOut The amount of the last token to receive\\n  /// @return amountIn The amount of first token required to be paid\\n  /// @return afterSqrtPList List of the sqrt price after the swap for each pool in the path\\n  /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\\n  /// @return gasEstimate The estimate of the gas that the swap consumes\\n  function quoteExactOutput(bytes memory path, uint256 amountOut)\\n    external\\n    returns (\\n      uint256 amountIn,\\n      uint160[] memory afterSqrtPList,\\n      uint32[] memory initializedTicksCrossedList,\\n      uint256 gasEstimate\\n    );\\n\\n  struct QuoteExactOutputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint256 amount;\\n    uint24 feeUnits;\\n    uint160 limitSqrtP;\\n  }\\n\\n  /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n  /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\\n  /// tokenIn The token being swapped in\\n  /// tokenOut The token being swapped out\\n  /// fee The fee of the token pool to consider for the pair\\n  /// amountOut The desired output amount\\n  /// limitSqrtP The price limit of the pool that cannot be exceeded by the swap\\n  function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\\n    external\\n    returns (QuoteOutput memory);\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity 0.8.9;\\n\\nlibrary BytesLib {\\n  function slice(\\n    bytes memory _bytes,\\n    uint256 _start,\\n    uint256 _length\\n  ) internal pure returns (bytes memory) {\\n    require(_length + 31 >= _length, 'slice_overflow');\\n    require(_bytes.length >= _start + _length, 'slice_outOfBounds');\\n\\n    bytes memory tempBytes;\\n\\n    assembly {\\n      switch iszero(_length)\\n      case 0 {\\n        // Get a location of some free memory and store it in tempBytes as\\n        // Solidity does for memory variables.\\n        tempBytes := mload(0x40)\\n\\n        // The first word of the slice result is potentially a partial\\n        // word read from the original array. To read it, we calculate\\n        // the length of that partial word and start copying that many\\n        // bytes into the array. The first word we copy will start with\\n        // data we don't care about, but the last `lengthmod` bytes will\\n        // land at the beginning of the contents of the new array. When\\n        // we're done copying, we overwrite the full first word with\\n        // the actual length of the slice.\\n        let lengthmod := and(_length, 31)\\n\\n        // The multiplication in the next line is necessary\\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\\n        // the following copy loop was copying the origin's length\\n        // and then ending prematurely not copying everything it should.\\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n        let end := add(mc, _length)\\n\\n        for {\\n          // The multiplication in the next line has the same exact purpose\\n          // as the one above.\\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n        } lt(mc, end) {\\n          mc := add(mc, 0x20)\\n          cc := add(cc, 0x20)\\n        } {\\n          mstore(mc, mload(cc))\\n        }\\n\\n        mstore(tempBytes, _length)\\n\\n        // update free-memory pointer\\n        // allocating the array padded to 32 bytes like the compiler does now\\n        mstore(0x40, and(add(mc, 31), not(31)))\\n      }\\n      //if we want a zero-length slice let's just return a zero-length array\\n      default {\\n        tempBytes := mload(0x40)\\n        // zero out the 32 bytes slice we are about to return\\n        // we need to do it because Solidity does not garbage collect\\n        mstore(tempBytes, 0)\\n\\n        mstore(0x40, add(tempBytes, 0x20))\\n      }\\n    }\\n    return tempBytes;\\n  }\\n\\n  function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n    require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\\n    address tempAddress;\\n\\n    assembly {\\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n    }\\n\\n    return tempAddress;\\n  }\\n\\n  function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n    require(_bytes.length >= _start + 2, 'toUint16_outOfBounds');\\n    uint16 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x2), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n    require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\\n    uint24 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x3), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pool/IPoolActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPoolActions {\\n  /// @notice Sets the initial price for the pool and seeds reinvestment liquidity\\n  /// @dev Assumes the caller has sent the necessary token amounts\\n  /// required for initializing reinvestment liquidity prior to calling this function\\n  /// @param initialSqrtP the initial sqrt price of the pool\\n  /// @param qty0 token0 quantity sent to and locked permanently in the pool\\n  /// @param qty1 token1 quantity sent to and locked permanently in the pool\\n  function unlockPool(uint160 initialSqrtP) external returns (uint256 qty0, uint256 qty1);\\n\\n  /// @notice Adds liquidity for the specified recipient/tickLower/tickUpper position\\n  /// @dev Any token0 or token1 owed for the liquidity provision have to be paid for when\\n  /// the IMintCallback#mintCallback is called to this method's caller\\n  /// The quantity of token0/token1 to be sent depends on\\n  /// tickLower, tickUpper, the amount of liquidity, and the current price of the pool.\\n  /// Also sends reinvestment tokens (fees) to the recipient for any fees collected\\n  /// while the position is in range\\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\\n  /// @param recipient Address for which the added liquidity is credited to\\n  /// @param tickLower Recipient position's lower tick\\n  /// @param tickUpper Recipient position's upper tick\\n  /// @param ticksPrevious The nearest tick that is initialized and <= the lower & upper ticks\\n  /// @param qty Liquidity quantity to mint\\n  /// @param data Data (if any) to be passed through to the callback\\n  /// @return qty0 token0 quantity sent to the pool in exchange for the minted liquidity\\n  /// @return qty1 token1 quantity sent to the pool in exchange for the minted liquidity\\n  /// @return feeGrowthInside position's updated feeGrowthInside value\\n  function mint(\\n    address recipient,\\n    int24 tickLower,\\n    int24 tickUpper,\\n    int24[2] calldata ticksPrevious,\\n    uint128 qty,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      uint256 qty0,\\n      uint256 qty1,\\n      uint256 feeGrowthInside\\n    );\\n\\n  /// @notice Remove liquidity from the caller\\n  /// Also sends reinvestment tokens (fees) to the caller for any fees collected\\n  /// while the position is in range\\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\\n  /// @param tickLower Position's lower tick for which to burn liquidity\\n  /// @param tickUpper Position's upper tick for which to burn liquidity\\n  /// @param qty Liquidity quantity to burn\\n  /// @return qty0 token0 quantity sent to the caller\\n  /// @return qty1 token1 quantity sent to the caller\\n  /// @return feeGrowthInside position's updated feeGrowthInside value\\n  function burn(\\n    int24 tickLower,\\n    int24 tickUpper,\\n    uint128 qty\\n  )\\n    external\\n    returns (\\n      uint256 qty0,\\n      uint256 qty1,\\n      uint256 feeGrowthInside\\n    );\\n\\n  /// @notice Burns reinvestment tokens in exchange to receive the fees collected in token0 and token1\\n  /// @param qty Reinvestment token quantity to burn\\n  /// @param isLogicalBurn true if burning rTokens without returning any token0/token1\\n  ///         otherwise should transfer token0/token1 to sender\\n  /// @return qty0 token0 quantity sent to the caller for burnt reinvestment tokens\\n  /// @return qty1 token1 quantity sent to the caller for burnt reinvestment tokens\\n  function burnRTokens(uint256 qty, bool isLogicalBurn)\\n    external\\n    returns (uint256 qty0, uint256 qty1);\\n\\n  /// @notice Swap token0 -> token1, or vice versa\\n  /// @dev This method's caller receives a callback in the form of ISwapCallback#swapCallback\\n  /// @dev swaps will execute up to limitSqrtP or swapQty is fully used\\n  /// @param recipient The address to receive the swap output\\n  /// @param swapQty The swap quantity, which implicitly configures the swap as exact input (>0), or exact output (<0)\\n  /// @param isToken0 Whether the swapQty is specified in token0 (true) or token1 (false)\\n  /// @param limitSqrtP the limit of sqrt price after swapping\\n  /// could be MAX_SQRT_RATIO-1 when swapping 1 -> 0 and MIN_SQRT_RATIO+1 when swapping 0 -> 1 for no limit swap\\n  /// @param data Any data to be passed through to the callback\\n  /// @return qty0 Exact token0 qty sent to recipient if < 0. Minimally received quantity if > 0.\\n  /// @return qty1 Exact token1 qty sent to recipient if < 0. Minimally received quantity if > 0.\\n  function swap(\\n    address recipient,\\n    int256 swapQty,\\n    bool isToken0,\\n    uint160 limitSqrtP,\\n    bytes calldata data\\n  ) external returns (int256 qty0, int256 qty1);\\n\\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n  /// @dev The caller of this method receives a callback in the form of IFlashCallback#flashCallback\\n  /// @dev Fees collected are sent to the feeTo address if it is set in Factory\\n  /// @param recipient The address which will receive the token0 and token1 quantities\\n  /// @param qty0 token0 quantity to be loaned to the recipient\\n  /// @param qty1 token1 quantity to be loaned to the recipient\\n  /// @param data Any data to be passed through to the callback\\n  function flash(\\n    address recipient,\\n    uint256 qty0,\\n    uint256 qty1,\\n    bytes calldata data\\n  ) external;\\n\\n\\n  /// @notice sync fee of position\\n  /// @param tickLower Position's lower tick\\n  /// @param tickUpper Position's upper tick\\n  function tweakPosZeroLiq(int24 tickLower, int24 tickUpper)\\n    external returns(uint256 feeGrowthInsideLast);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pool/IPoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPoolEvents {\\n  /// @notice Emitted only once per pool when #initialize is first called\\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n  /// @param sqrtP The initial price of the pool\\n  /// @param tick The initial tick of the pool\\n  event Initialize(uint160 sqrtP, int24 tick);\\n\\n  /// @notice Emitted when liquidity is minted for a given position\\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\\n  /// @param sender address that minted the liquidity\\n  /// @param owner address of owner of the position\\n  /// @param tickLower position's lower tick\\n  /// @param tickUpper position's upper tick\\n  /// @param qty liquidity minted to the position range\\n  /// @param qty0 token0 quantity needed to mint the liquidity\\n  /// @param qty1 token1 quantity needed to mint the liquidity\\n  event Mint(\\n    address sender,\\n    address indexed owner,\\n    int24 indexed tickLower,\\n    int24 indexed tickUpper,\\n    uint128 qty,\\n    uint256 qty0,\\n    uint256 qty1\\n  );\\n\\n  /// @notice Emitted when a position's liquidity is removed\\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\\n  /// @param owner address of owner of the position\\n  /// @param tickLower position's lower tick\\n  /// @param tickUpper position's upper tick\\n  /// @param qty liquidity removed\\n  /// @param qty0 token0 quantity withdrawn from removal of liquidity\\n  /// @param qty1 token1 quantity withdrawn from removal of liquidity\\n  event Burn(\\n    address indexed owner,\\n    int24 indexed tickLower,\\n    int24 indexed tickUpper,\\n    uint128 qty,\\n    uint256 qty0,\\n    uint256 qty1\\n  );\\n\\n  /// @notice Emitted when reinvestment tokens are burnt\\n  /// @param owner address which burnt the reinvestment tokens\\n  /// @param qty reinvestment token quantity burnt\\n  /// @param qty0 token0 quantity sent to owner for burning reinvestment tokens\\n  /// @param qty1 token1 quantity sent to owner for burning reinvestment tokens\\n  event BurnRTokens(address indexed owner, uint256 qty, uint256 qty0, uint256 qty1);\\n\\n  /// @notice Emitted for swaps by the pool between token0 and token1\\n  /// @param sender Address that initiated the swap call, and that received the callback\\n  /// @param recipient Address that received the swap output\\n  /// @param deltaQty0 Change in pool's token0 balance\\n  /// @param deltaQty1 Change in pool's token1 balance\\n  /// @param sqrtP Pool's sqrt price after the swap\\n  /// @param liquidity Pool's liquidity after the swap\\n  /// @param currentTick Log base 1.0001 of pool's price after the swap\\n  event Swap(\\n    address indexed sender,\\n    address indexed recipient,\\n    int256 deltaQty0,\\n    int256 deltaQty1,\\n    uint160 sqrtP,\\n    uint128 liquidity,\\n    int24 currentTick\\n  );\\n\\n  /// @notice Emitted by the pool for any flash loans of token0/token1\\n  /// @param sender The address that initiated the flash loan, and that received the callback\\n  /// @param recipient The address that received the flash loan quantities\\n  /// @param qty0 token0 quantity loaned to the recipient\\n  /// @param qty1 token1 quantity loaned to the recipient\\n  /// @param paid0 token0 quantity paid for the flash, which can exceed qty0 + fee\\n  /// @param paid1 token1 quantity paid for the flash, which can exceed qty0 + fee\\n  event Flash(\\n    address indexed sender,\\n    address indexed recipient,\\n    uint256 qty0,\\n    uint256 qty1,\\n    uint256 paid0,\\n    uint256 paid1\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pool/IPoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IFactory} from '../IFactory.sol';\\nimport {IPoolOracle} from '../oracle/IPoolOracle.sol';\\n\\ninterface IPoolStorage {\\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\\n  /// @return The contract address\\n  function factory() external view returns (IFactory);\\n\\n  /// @notice The oracle contract that stores necessary data for price oracle\\n  /// @return The contract address\\n  function poolOracle() external view returns (IPoolOracle);\\n\\n  /// @notice The first of the two tokens of the pool, sorted by address\\n  /// @return The token contract address\\n  function token0() external view returns (IERC20);\\n\\n  /// @notice The second of the two tokens of the pool, sorted by address\\n  /// @return The token contract address\\n  function token1() external view returns (IERC20);\\n\\n  /// @notice The fee to be charged for a swap in basis points\\n  /// @return The swap fee in basis points\\n  function swapFeeUnits() external view returns (uint24);\\n\\n  /// @notice The pool tick distance\\n  /// @dev Ticks can only be initialized and used at multiples of this value\\n  /// It remains an int24 to avoid casting even though it is >= 1.\\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\\n  /// @return The tick distance\\n  function tickDistance() external view returns (int24);\\n\\n  /// @notice Maximum gross liquidity that an initialized tick can have\\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n  /// @return The max amount of liquidity per tick\\n  function maxTickLiquidity() external view returns (uint128);\\n\\n  /// @notice Look up information about a specific tick in the pool\\n  /// @param tick The tick to look up\\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\\n  /// secondsPerLiquidityOutside the seconds per unit of liquidity  spent on the other side of the tick relative to the current tick\\n  function ticks(int24 tick)\\n    external\\n    view\\n    returns (\\n      uint128 liquidityGross,\\n      int128 liquidityNet,\\n      uint256 feeGrowthOutside,\\n      uint128 secondsPerLiquidityOutside\\n    );\\n\\n  /// @notice Returns the previous and next initialized ticks of a specific tick\\n  /// @dev If specified tick is uninitialized, the returned values are zero.\\n  /// @param tick The tick to look up\\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\\n\\n  /// @notice Returns the information about a position by the position's key\\n  /// @return liquidity the liquidity quantity of the position\\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\\n  function getPositions(\\n    address owner,\\n    int24 tickLower,\\n    int24 tickUpper\\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\\n\\n  /// @notice Fetches the pool's prices, ticks and lock status\\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\\n  /// @return currentTick pool's current tick\\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\\n  /// @return locked true if pool is locked, false otherwise\\n  function getPoolState()\\n    external\\n    view\\n    returns (\\n      uint160 sqrtP,\\n      int24 currentTick,\\n      int24 nearestCurrentTick,\\n      bool locked\\n    );\\n\\n  /// @notice Fetches the pool's liquidity values\\n  /// @return baseL pool's base liquidity without reinvest liqudity\\n  /// @return reinvestL the liquidity is reinvested into the pool\\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\\n  function getLiquidityState()\\n    external\\n    view\\n    returns (\\n      uint128 baseL,\\n      uint128 reinvestL,\\n      uint128 reinvestLLast\\n    );\\n\\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\\n  function getFeeGrowthGlobal() external view returns (uint256);\\n\\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\\n  function getSecondsPerLiquidityData()\\n    external\\n    view\\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\\n\\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\\n  /// @param tickLower The lower tick (of a position)\\n  /// @param tickUpper The upper tick (of a position)\\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\\n  /// between the 2 ticks, per unit of liquidity.\\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\\n    external\\n    view\\n    returns (uint128 secondsPerLiquidityInside);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/oracle/IPoolOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPoolOracle {\\n  /// @notice Owner withdrew funds in the pool oracle in case some funds are stuck there\\n  event OwnerWithdrew(\\n    address indexed owner,\\n    address indexed token,\\n    uint256 indexed amount\\n  );\\n\\n  /// @notice Emitted by the Pool Oracle for increases to the number of observations that can be stored\\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\n  /// just before a mint/swap/burn.\\n  /// @param pool The pool address to update\\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n  event IncreaseObservationCardinalityNext(\\n    address pool,\\n    uint16 observationCardinalityNextOld,\\n    uint16 observationCardinalityNextNew\\n  );\\n\\n  /// @notice Initalize observation data for the caller.\\n  function initializeOracle(uint32 time)\\n    external\\n    returns (uint16 cardinality, uint16 cardinalityNext);\\n\\n  /// @notice Write a new oracle entry into the array\\n  ///   and update the observation index and cardinality\\n  /// Read the Oralce.write function for more details\\n  function writeNewEntry(\\n    uint16 index,\\n    uint32 blockTimestamp,\\n    int24 tick,\\n    uint128 liquidity,\\n    uint16 cardinality,\\n    uint16 cardinalityNext\\n  )\\n    external\\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\\n\\n  /// @notice Write a new oracle entry into the array, take the latest observaion data as inputs\\n  ///   and update the observation index and cardinality\\n  /// Read the Oralce.write function for more details\\n  function write(\\n    uint32 blockTimestamp,\\n    int24 tick,\\n    uint128 liquidity\\n  )\\n    external\\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\\n\\n  /// @notice Increase the maximum number of price observations that this pool will store\\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\n  /// the input observationCardinalityNext.\\n  /// @param pool The pool address to be updated\\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\n  function increaseObservationCardinalityNext(\\n    address pool,\\n    uint16 observationCardinalityNext\\n  )\\n    external;\\n\\n  /// @notice Returns the accumulator values as of each time seconds ago from the latest block time in the array of `secondsAgos`\\n  /// @dev Reverts if `secondsAgos` > oldest observation\\n  /// @dev It fetches the latest current tick data from the pool\\n  /// Read the Oracle.observe function for more details\\n  function observeFromPool(\\n    address pool,\\n    uint32[] memory secondsAgos\\n  )\\n    external view\\n    returns (int56[] memory tickCumulatives);\\n\\n  /// @notice Returns the accumulator values as the time seconds ago from the latest block time of secondsAgo\\n  /// @dev Reverts if `secondsAgo` > oldest observation\\n  /// @dev It fetches the latest current tick data from the pool\\n  /// Read the Oracle.observeSingle function for more details\\n  function observeSingleFromPool(\\n    address pool,\\n    uint32 secondsAgo\\n  )\\n    external view\\n    returns (int56 tickCumulative);\\n\\n  /// @notice Return the latest pool observation data given the pool address\\n  function getPoolObservation(address pool)\\n    external view\\n    returns (bool initialized, uint16 index, uint16 cardinality, uint16 cardinalityNext);\\n\\n  /// @notice Returns data about a specific observation index\\n  /// @param pool The pool address of the observations array to fetch\\n  /// @param index The element of the observations array to fetch\\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n  /// ago, rather than at a specific index in the array.\\n  /// @return blockTimestamp The timestamp of the observation,\\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\\n  function getObservationAt(address pool, uint256 index)\\n    external view\\n    returns (\\n      uint32 blockTimestamp,\\n      int56 tickCumulative,\\n      bool initialized\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"quoteExactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint160[]\",\"name\":\"afterSqrtPList\",\"type\":\"uint160[]\"},{\"internalType\":\"uint32[]\",\"name\":\"initializedTicksCrossedList\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"gasEstimate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"feeUnits\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"limitSqrtP\",\"type\":\"uint160\"}],\"internalType\":\"struct IQuoterV2.QuoteExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"quoteExactInputSingle\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"usedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"afterSqrtP\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"initializedTicksCrossed\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"gasEstimate\",\"type\":\"uint256\"}],\"internalType\":\"struct IQuoterV2.QuoteOutput\",\"name\":\"output\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"quoteExactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint160[]\",\"name\":\"afterSqrtPList\",\"type\":\"uint160[]\"},{\"internalType\":\"uint32[]\",\"name\":\"initializedTicksCrossedList\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"gasEstimate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"feeUnits\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"limitSqrtP\",\"type\":\"uint160\"}],\"internalType\":\"struct IQuoterV2.QuoteExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"quoteExactOutputSingle\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"usedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"afterSqrtP\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"initializedTicksCrossed\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"gasEstimate\",\"type\":\"uint256\"}],\"internalType\":\"struct IQuoterV2.QuoteOutput\",\"name\":\"output\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"name\":\"swapCallback\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "QuoterV2", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "000000000000000000000000c7a590291e07b9fe9e64b86c58fd8fc764308c4a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}