{"SourceCode": "// File: contracts/openzeppelin/token/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/openzeppelin/token/extensions/IERC20Metadata.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: contracts/openzeppelin/utils/Address.sol\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/openzeppelin/token/utils/SafeERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n    unchecked {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n        uint256 newAllowance = oldAllowance - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/flavours/Context.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/flavours/Ownable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the pending owner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(_pendingOwner == _msgSender(), \"Ownable: caller is not the pending owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Prepare ownership transfer of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pending owner to finalize the transfer.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        _transferOwnership(_pendingOwner);\r\n        _pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/GlobalsAndUtility.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract GlobalsAndUtility is Ownable {\r\n    event APRCoefficientUpdate(\r\n        address indexed updaterAddr,\r\n        uint40 timestamp,\r\n        uint16 stakedDays,\r\n        uint256 coefficient\r\n    );\r\n\r\n    event StakeStart(\r\n        address indexed stakerAddr,\r\n        uint40 indexed stakeId,\r\n        uint40 timestamp,\r\n        uint128 stakedAmount,\r\n        uint16 stakedDays,\r\n        uint16 startIndexAPR\r\n    );\r\n\r\n    event StakeEnd(\r\n        address indexed stakerAddr,\r\n        uint40 indexed stakeId,\r\n        uint40 timestamp,\r\n        uint128 stakedAmount,\r\n        uint128 stakeReward,\r\n        uint16 servedDays,\r\n        uint16 startIndexAPR\r\n    );\r\n\r\n    event RewardsFund(\r\n        uint128 amount\r\n    );\r\n\r\n    IERC20 public stakingToken;\r\n    uint256 public launchTime;\r\n\r\n    uint256 internal constant TOKEN_DECIMALS = 18;\r\n    uint256 internal constant ONE_TOKEN = 1e18;\r\n\r\n    uint256 internal constant APR_BASIS = 3;\r\n    uint256 internal constant APR_MULTIPLIER = 1e5;\r\n\r\n    uint16[] public stakePeriods;\r\n\r\n    struct APR {\r\n        uint256 changeDay;\r\n        uint256 coefficient;\r\n    }\r\n\r\n    mapping(uint16 => APR[]) public aprCoefficient;\r\n    mapping(uint16 => uint256) public aprDivider;\r\n    mapping(uint16 => uint40) public activeStakes;\r\n\r\n    /* Globals expanded for memory (except _latestStakeId) and compact for storage */\r\n    struct GlobalsCache {\r\n        uint256 _rewardTotal;\r\n        uint256 _lockedStakeTotal;\r\n        uint40 _latestStakeId;\r\n        uint256 _currentDay;\r\n        uint40 _activeStakesTotal;\r\n        uint40 _averageLockPeriod;\r\n    }\r\n\r\n    struct GlobalsStore {\r\n        uint128 rewardTotal;\r\n        uint128 lockedStakeTotal;\r\n        uint40 latestStakeId;\r\n        uint40 activeStakesTotal;\r\n    }\r\n\r\n    GlobalsStore public globals;\r\n\r\n    /* Stake expanded for memory (except _stakeId) and compact for storage */\r\n    struct StakeCache {\r\n        uint256 _stakedAmount;\r\n        uint40 _stakeId;\r\n        uint256 _lockedDay;\r\n        uint16 _stakedDays;\r\n        uint16 _startIndexAPR;\r\n    }\r\n\r\n    struct StakeStore {\r\n        uint128 stakedAmount;\r\n        uint40 stakeId;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 startIndexAPR;\r\n    }\r\n\r\n    mapping(address => StakeStore[]) public stakeLists;\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Updates coefficient for specified stake period.\r\n     * @param stakeDays - period of stake\r\n     * @param coefficientWithMultiplier - value of percent should be multiplied by 1e5\r\n     */\r\n    function updateAPRCoefficient(uint16 stakeDays, uint256 coefficientWithMultiplier) external onlyOwner {\r\n        require(aprDivider[stakeDays] != 0, \"New stake period is not allowed\");\r\n        // 1000 minimum (1e5/100)\r\n        require(coefficientWithMultiplier * 100 >= APR_MULTIPLIER, \"Coefficient is too small\");\r\n\r\n        uint256 coefficient = coefficientWithMultiplier * APR_BASIS;\r\n        _changeAPR(stakeDays, _currentDay(), coefficient);\r\n\r\n        emit APRCoefficientUpdate(\r\n            msg.sender,\r\n            uint40(block.timestamp),\r\n            uint16(stakeDays),\r\n            coefficient\r\n        );\r\n    }\r\n\r\n    function _changeAPR(uint16 stakeDays, uint256 changeDay, uint256 coefficient) internal {\r\n        aprCoefficient[stakeDays].push(\r\n            APR(\r\n                uint256(changeDay),\r\n                uint256(coefficient)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _loadAPR(APR[] storage aprRef, uint256 aprIndex, APR memory apr) internal view {\r\n        apr.coefficient = aprRef[aprIndex].coefficient;\r\n        apr.changeDay = aprRef[aprIndex].changeDay;\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Returns the count of stake periods\r\n     */\r\n    function stakePeriodsCount() external view returns (uint256) {\r\n        return stakePeriods.length;\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Returns the current aprCoefficient count for a stakeDays\r\n     * @param stakeDays stake duration\r\n     */\r\n    function aprCoefficientCount(uint16 stakeDays) external view returns (uint256) {\r\n        return aprCoefficient[stakeDays].length;\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: External helper to return most global info with a single call.\r\n     * @return global variables\r\n     */\r\n    function globalInfo() external view returns (GlobalsCache memory) {\r\n        GlobalsCache memory g;\r\n        _globalsLoad(g);\r\n\r\n        return g;\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: External helper for the current day number since launch time\r\n     * @return Current day number (zero-based)\r\n     */\r\n    function currentDay() external view returns (uint256) {\r\n        return _currentDay();\r\n    }\r\n\r\n    function _currentDay() internal view returns (uint256) {\r\n        return (block.timestamp - launchTime) / 1 days;\r\n    }\r\n\r\n    function _globalsLoad(GlobalsCache memory g) internal view {\r\n        g._rewardTotal = globals.rewardTotal;\r\n        g._lockedStakeTotal = globals.lockedStakeTotal;\r\n        g._latestStakeId = globals.latestStakeId;\r\n        g._currentDay = _currentDay();\r\n        g._activeStakesTotal = globals.activeStakesTotal;\r\n\r\n        if (globals.activeStakesTotal != 0) {\r\n            g._averageLockPeriod = (activeStakes[30] * 30 + activeStakes[60] * 60 + activeStakes[90] * 90\r\n            + activeStakes[180] * 180 + activeStakes[365] * 365 + activeStakes[700] * 700) / globals.activeStakesTotal;\r\n        } else {\r\n            g._averageLockPeriod = 0;\r\n        }\r\n    }\r\n\r\n    function _globalsSync(GlobalsCache memory g) internal {\r\n        globals.rewardTotal = uint128(g._rewardTotal);\r\n        globals.lockedStakeTotal = uint128(g._lockedStakeTotal);\r\n        globals.latestStakeId = g._latestStakeId;\r\n        globals.activeStakesTotal = g._activeStakesTotal;\r\n    }\r\n\r\n    function _stakeLoad(StakeStore storage stRef, uint40 stakeIdParam, StakeCache memory st) internal view {\r\n        /* Ensure caller's stakeIndex is still current */\r\n        require(stakeIdParam == stRef.stakeId, \"STAKING: stakeIdParam not in stake\");\r\n\r\n        st._stakedAmount = stRef.stakedAmount;\r\n        st._stakeId = stRef.stakeId;\r\n        st._lockedDay = stRef.lockedDay;\r\n        st._stakedDays = stRef.stakedDays;\r\n        st._startIndexAPR = stRef.startIndexAPR;\r\n    }\r\n\r\n    function _stakeAdd(\r\n        StakeStore[] storage stakeListRef,\r\n        uint40 newStakeId,\r\n        uint256 newStakedAmount,\r\n        uint256 newLockedDay,\r\n        uint16 newStakedDays,\r\n        uint16 startIndexAPR\r\n    ) internal {\r\n        stakeListRef.push(\r\n            StakeStore(\r\n                uint128(newStakedAmount),\r\n                newStakeId,\r\n                uint16(newLockedDay),\r\n                uint16(newStakedDays),\r\n                uint16(startIndexAPR)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Efficiently delete from an unordered array by moving the last element\r\n     * to the \"hole\" and reducing the array length. Can change the order of the list\r\n     * and invalidate previously held indexes.\r\n     * @notice stakeListRef length and stakeIndex are already ensured valid in stakeEnd()\r\n     * @param stakeListRef Reference to stakeLists[stakerAddr] array in storage\r\n     * @param stakeIndex Index of the element to delete\r\n     */\r\n    function _stakeRemove(StakeStore[] storage stakeListRef, uint256 stakeIndex) internal {\r\n        uint256 lastIndex = stakeListRef.length - 1;\r\n\r\n        /* Skip the copy if element to be removed is already the last element */\r\n        if (stakeIndex != lastIndex) {\r\n            /* Copy last element to the requested element's \"hole\" */\r\n            stakeListRef[stakeIndex] = stakeListRef[lastIndex];\r\n        }\r\n\r\n        stakeListRef.pop();\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/flavours/Withdrawal.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title Withdrawal\r\n * @dev The Withdrawal contract has an owner address, and provides method for withdraw funds and tokens, if any\r\n */\r\ncontract Withdrawal is Ownable {\r\n\r\n    address private _restrictedToken;\r\n\r\n    function setRestrictedToken(address restrictedToken) internal {\r\n        require(restrictedToken != address(0), \"Restricted token cannot be zero\");\r\n        require(_restrictedToken == address(0), \"Restricted token is unchangeable\");\r\n        _restrictedToken = restrictedToken;\r\n    }\r\n\r\n    // withdraw funds, if any, only for owner\r\n    function withdraw() public onlyOwner {\r\n        payable(owner()).transfer(address(this).balance);\r\n    }\r\n\r\n    // withdraw stuck tokens, if any, only for owner\r\n    function withdrawTokens(address _someToken) public onlyOwner {\r\n        require(_restrictedToken != _someToken, \"Restricted token is forbidden to withdraw\");\r\n        IERC20 someToken = IERC20(_someToken);\r\n        uint balance = someToken.balanceOf(address(this));\r\n        someToken.transfer(owner(), balance);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/flavours/SelfDestructible.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SelfDestructible\r\n * @dev The SelfDestructible contract has an owner address, and provides selfDestruct method\r\n * in case of deployment error.\r\n */\r\ncontract SelfDestructible is Ownable {\r\n\r\n    function selfDestruct(uint8 v, bytes32 r, bytes32 s) public onlyOwner {\r\n        if (ecrecover(prefixedHash(), v, r, s) != owner()) {\r\n            revert();\r\n        }\r\n        selfdestruct(payable(owner()));\r\n    }\r\n\r\n    function originalHash() internal view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\r\n                \"Signed for SelfDestruct\",\r\n                address(this),\r\n                msg.sender\r\n            ));\r\n    }\r\n\r\n    function prefixedHash() internal view returns (bytes32) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        return keccak256(abi.encodePacked(prefix, originalHash()));\r\n    }\r\n}\r\n\r\n// File: contracts/flavours/Stoppable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract Stoppable is Ownable {\r\n\r\n    event StakeDisabled(\r\n        address indexed updaterAddr,\r\n        uint40 timestamp\r\n    );\r\n\r\n    bool public active;\r\n\r\n    constructor() {\r\n        active = true;\r\n    }\r\n\r\n    function disable() public onlyOwner onlyActive {\r\n        active = false;\r\n\r\n        emit StakeDisabled(\r\n            msg.sender,\r\n            uint40(block.timestamp)\r\n        );\r\n    }\r\n\r\n    modifier onlyActive() {\r\n        require(active, \"Staking not available anymore\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDisabled() {\r\n        require(!active, \"Staking is active\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Staking.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Staking is GlobalsAndUtility, Withdrawal, SelfDestructible, Stoppable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    constructor(IERC20 _stakingToken) {\r\n        require(IERC20Metadata(address(_stakingToken)).decimals() == TOKEN_DECIMALS, \"STAKING: incompatible token decimals\");\r\n\r\n        setRestrictedToken(address(_stakingToken));\r\n        stakingToken = _stakingToken;\r\n        launchTime = block.timestamp;\r\n\r\n        // 3 * 1% 1/12\r\n        _changeAPR(30, 0, APR_BASIS * 1 * 1e5);\r\n        aprDivider[30] = 12 * 1e5;\r\n        stakePeriods.push(30);\r\n        // 3 * 1.5% 1/6\r\n        _changeAPR(60, 0, APR_BASIS * 15e4);\r\n        aprDivider[60] = 6 * 1e5;\r\n        stakePeriods.push(60);\r\n        // 3 * 1.9% 1/4\r\n        _changeAPR(90, 0, APR_BASIS * 19e4);\r\n        aprDivider[90] = 4 * 1e5;\r\n        stakePeriods.push(90);\r\n        // 3 * 3% 1/2\r\n        _changeAPR(180, 0, APR_BASIS * 3 * 1e5);\r\n        aprDivider[180] = 2 * 1e5;\r\n        stakePeriods.push(180);\r\n        // 3 * 5% 1\r\n        _changeAPR(365, 0, APR_BASIS * 5 * 1e5);\r\n        aprDivider[365] = 1 * 1e5;\r\n        stakePeriods.push(365);\r\n        // 3 * 12% 2\r\n        _changeAPR(700, 0, APR_BASIS * 12 * 1e5);\r\n        aprDivider[700] = 1 * 5e4;\r\n        stakePeriods.push(700);\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Open a stake.\r\n     * Requires allowance of specified amount (at least) on token contract for staking contract.\r\n     * @param newStakedAmount Amount of staking token to stake\r\n     * @param newStakedDays Number of days to stake\r\n     * @return stakeId id of created stake\r\n     */\r\n    function stakeStart(uint256 newStakedAmount, uint16 newStakedDays) external onlyActive returns (uint40 stakeId) {\r\n        /* Enforce the fixed stake time */\r\n        require(aprDivider[newStakedDays] != 0, \"STAKING: newStakedDays value is not allowed\");\r\n\r\n        GlobalsCache memory g;\r\n        _globalsLoad(g);\r\n\r\n        stakeId = _stakeStart(g, newStakedAmount, newStakedDays);\r\n\r\n        /* Remove staked amount from balance of staker */\r\n        stakingToken.safeTransferFrom(msg.sender, address(this), newStakedAmount);\r\n\r\n        _globalsSync(g);\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Closes a stake. The order of the stake list can change so\r\n     * a stake id is used to reject stale indexes.\r\n     * @param stakeIndex Index of stake within stake list\r\n     * @param stakeIdParam The stake's id\r\n     * @return stakeReturn payout\r\n     */\r\n    function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam) external returns (uint256 stakeReturn, uint256 payout) {\r\n        return _stakeEnd(stakeIndex, stakeIdParam, false);\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Closes a unfinished stake. The order of the stake list can change so\r\n     * a stake id is used to reject stale indexes.\r\n     * @param stakeIndex Index of stake within stake list\r\n     * @param stakeIdParam The stake's id\r\n     * @return stakeReturn payout\r\n     */\r\n    function stakeEarlyEnd(uint256 stakeIndex, uint40 stakeIdParam) external returns (uint256 stakeReturn, uint256 payout) {\r\n        return _stakeEnd(stakeIndex, stakeIdParam, true);\r\n    }\r\n\r\n    function _stakeEnd(uint256 stakeIndex, uint40 stakeIdParam, bool early) internal returns (uint256 stakeReturn, uint256 payout) {\r\n        GlobalsCache memory g;\r\n        StakeCache memory st;\r\n        _globalsLoad(g);\r\n\r\n        StakeStore[] storage stakeListRef = stakeLists[msg.sender];\r\n\r\n        uint16 servedDays;\r\n        if (early) {\r\n            require(stakeListRef.length != 0, \"STAKING: Empty stake list\");\r\n            require(stakeIndex < stakeListRef.length, \"STAKING: stakeIndex invalid\");\r\n\r\n            StakeStore storage stRef = stakeListRef[stakeIndex];\r\n\r\n            /* Get stake copy */\r\n            _stakeLoad(stRef, stakeIdParam, st);\r\n\r\n            stakeReturn = st._stakedAmount;\r\n            payout = 0;\r\n            servedDays = 0;\r\n        } else {\r\n            (stakeReturn, payout) = _getStakeStatus(stakeIndex, stakeIdParam, stakeListRef, true, g, st);\r\n            servedDays = uint16(st._stakedDays);\r\n        }\r\n\r\n        emit StakeEnd(\r\n            msg.sender,\r\n            stakeIdParam,\r\n            uint40(block.timestamp),\r\n            uint128(st._stakedAmount),\r\n            uint128(payout),\r\n            servedDays,\r\n            uint16(st._startIndexAPR)\r\n        );\r\n\r\n        /* Pay the stake return to the staker */\r\n        stakingToken.safeTransfer(msg.sender, stakeReturn);\r\n\r\n        g._rewardTotal -= payout;\r\n        g._lockedStakeTotal -= st._stakedAmount;\r\n        g._activeStakesTotal -= 1;\r\n        activeStakes[st._stakedDays] -= 1;\r\n\r\n        _stakeRemove(stakeListRef, stakeIndex);\r\n\r\n        _globalsSync(g);\r\n\r\n        return (stakeReturn, payout);\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Funds reward tokens to staking contract.\r\n     * Requires allowance of specified amount (at least) on token contract for staking contract.\r\n     * @param amount value of tokens to fund\r\n     */\r\n    function fundRewards(uint128 amount) external {\r\n        GlobalsCache memory g;\r\n        _globalsLoad(g);\r\n\r\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\r\n\r\n        g._rewardTotal += amount;\r\n        _globalsSync(g);\r\n\r\n        emit RewardsFund(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Withdraws specified amount of reward tokens to owner. Only for owner.\r\n     */\r\n    function fundsWithdraw(uint256 amount) external onlyOwner {\r\n        GlobalsCache memory g;\r\n        _globalsLoad(g);\r\n\r\n        require(g._rewardTotal >= amount, \"Amount exceeds balance\");\r\n        stakingToken.transfer(owner(), amount);\r\n\r\n        g._rewardTotal -= amount;\r\n        _globalsSync(g);\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Withdraws all unused reward tokens to owner. Only for owner and only after staking is stopped.\r\n     */\r\n    function fundsWithdrawFull() external onlyOwner onlyDisabled {\r\n        GlobalsCache memory g;\r\n        _globalsLoad(g);\r\n        require(g._activeStakesTotal == 0, \"Not all stakes closed\");\r\n        uint256 balance = stakingToken.balanceOf(address(this));\r\n        require(balance > 0, \"Nothing to withdraw\");\r\n        stakingToken.transfer(owner(), balance);\r\n\r\n        // it's possible to withdraw more than _rewardTotal,\r\n        // if someone send tokens directly to contract, not via fundRewards\r\n        g._rewardTotal = 0;\r\n        _globalsSync(g);\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING: Returns the current stake count for a staker address\r\n     * @param stakerAddr Address of staker\r\n     */\r\n    function stakeCount(address stakerAddr) external view returns (uint256) {\r\n        return stakeLists[stakerAddr].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Open a stake.\r\n     * @param g Cache of stored globals\r\n     * @param newStakedAmount Amount of staking token to stake\r\n     * @param newStakedDays Number of days to stake\r\n     * @return newStakeId id of created stake\r\n     */\r\n    function _stakeStart(GlobalsCache memory g, uint256 newStakedAmount, uint16 newStakedDays) internal returns (uint40 newStakeId) {\r\n        APR[] storage aprArr = aprCoefficient[newStakedDays];\r\n        APR memory apr;\r\n        uint16 startIndexAPR = uint16(aprArr.length) - 1;\r\n        _loadAPR(aprArr, startIndexAPR, apr);\r\n\r\n        uint256 newStakeReward = newStakedAmount * apr.coefficient / (100 * aprDivider[newStakedDays]);\r\n\r\n        /* Ensure newStakedAmount is enough for at least one reward token */\r\n        require(newStakeReward >= ONE_TOKEN, \"STAKING: newStakedAmount must be enough to get one reward token\");\r\n\r\n        /*\r\n            The stakeStart timestamp will always be part-way through the current\r\n            day, so it needs to be rounded-up to the next day to ensure all\r\n            stakes align with the same fixed calendar days. The current day is\r\n            already rounded-down, so rounded-up is current day + 1.\r\n        */\r\n        uint256 newLockedDay = g._currentDay + 1;\r\n\r\n        /* Create Stake */\r\n        newStakeId = ++g._latestStakeId;\r\n        _stakeAdd(\r\n            stakeLists[msg.sender],\r\n            newStakeId,\r\n            newStakedAmount,\r\n            newLockedDay,\r\n            newStakedDays,\r\n            startIndexAPR\r\n        );\r\n\r\n        emit StakeStart(\r\n            msg.sender,\r\n            newStakeId,\r\n            uint40(block.timestamp),\r\n            uint128(newStakedAmount),\r\n            uint16(newStakedDays),\r\n            uint16(startIndexAPR)\r\n        );\r\n\r\n        /* Track total staked amount */\r\n        g._lockedStakeTotal += newStakedAmount;\r\n\r\n        g._activeStakesTotal += 1;\r\n        activeStakes[newStakedDays] += 1;\r\n    }\r\n\r\n    /*\r\n    Returns the same values as function stakeEnd. However, this function makes\r\n    it possible to anyone view the stakeReturn etc. for any staker.\r\n    */\r\n    function getStakeStatus(address staker, uint256 stakeIndex, uint40 stakeIdParam) external view\r\n    returns (uint256 stakeReturn, uint256 payout)\r\n    {\r\n        GlobalsCache memory g;\r\n        StakeCache memory st;\r\n        _globalsLoad(g);\r\n\r\n        StakeStore[] storage stakeListRef = stakeLists[staker];\r\n\r\n        (stakeReturn, payout) = _getStakeStatus(stakeIndex, stakeIdParam, stakeListRef, false, g, st);\r\n    }\r\n\r\n    function _getStakeStatus(uint256 stakeIndex, uint40 stakeIdParam, StakeStore[] storage stakeListRef,\r\n        bool failOnUnfinished, GlobalsCache memory g, StakeCache memory st)\r\n    internal view returns (uint256 stakeReturn, uint256 payout) {\r\n        require(stakeListRef.length != 0, \"STAKING: Empty stake list\");\r\n        require(stakeIndex < stakeListRef.length, \"STAKING: stakeIndex invalid\");\r\n\r\n        StakeStore storage stRef = stakeListRef[stakeIndex];\r\n\r\n        /* Get stake copy */\r\n        _stakeLoad(stRef, stakeIdParam, st);\r\n\r\n        /* Stake must have served full term */\r\n        require(g._currentDay >= st._lockedDay + st._stakedDays || !failOnUnfinished, \"STAKING: Stake not fully served\");\r\n\r\n        payout = 0;\r\n        stakeReturn = st._stakedAmount;\r\n        if (g._currentDay < st._lockedDay) {\r\n            return (stakeReturn, payout);\r\n        }\r\n\r\n        uint16 stakedDays = st._stakedDays;\r\n        APR[] storage aprArr = aprCoefficient[stakedDays];\r\n        APR memory apr;\r\n        APR memory aprPrev;\r\n        for (uint16 i = st._startIndexAPR; i <= aprArr.length - 1; i++) {\r\n            _loadAPR(aprArr, i, apr);\r\n            if (apr.changeDay <= st._lockedDay) {\r\n                // rewind to first apr, that have affect on stake\r\n                aprPrev.changeDay = apr.changeDay;\r\n                aprPrev.coefficient = apr.coefficient;\r\n                continue;\r\n            }\r\n            if (apr.changeDay > st._lockedDay + st._stakedDays || apr.changeDay > g._currentDay) {\r\n                // stop after last related apr\r\n                break;\r\n            }\r\n\r\n            payout += st._stakedAmount * aprPrev.coefficient\r\n            * (apr.changeDay - (aprPrev.changeDay <= st._lockedDay ? st._lockedDay : aprPrev.changeDay));\r\n            aprPrev.changeDay = apr.changeDay;\r\n            aprPrev.coefficient = apr.coefficient;\r\n        }\r\n\r\n        // add part after last APR change\r\n        uint256 startDay = aprPrev.changeDay <= st._lockedDay ? st._lockedDay : aprPrev.changeDay;\r\n        uint256 endDay = g._currentDay >= st._lockedDay + stakedDays ? st._lockedDay + stakedDays : g._currentDay;\r\n        payout += st._stakedAmount * aprPrev.coefficient * (endDay - startDay);\r\n\r\n        payout = payout / (100 * aprDivider[stakedDays] * stakedDays);\r\n\r\n        stakeReturn += payout;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_stakingToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updaterAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"stakedDays\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coefficient\",\"type\":\"uint256\"}],\"name\":\"APRCoefficientUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"RewardsFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updaterAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"}],\"name\":\"StakeDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"stakedAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"stakeReward\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"servedDays\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"startIndexAPR\",\"type\":\"uint16\"}],\"name\":\"StakeEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"stakedAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"stakedDays\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"startIndexAPR\",\"type\":\"uint16\"}],\"name\":\"StakeStart\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"activeStakes\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aprCoefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"changeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coefficient\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"stakeDays\",\"type\":\"uint16\"}],\"name\":\"aprCoefficientCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"aprDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"fundRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fundsWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundsWithdrawFull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"stakeIdParam\",\"type\":\"uint40\"}],\"name\":\"getStakeStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_rewardTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockedStakeTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"_latestStakeId\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"_currentDay\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"_activeStakesTotal\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"_averageLockPeriod\",\"type\":\"uint40\"}],\"internalType\":\"struct GlobalsAndUtility.GlobalsCache\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globals\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"rewardTotal\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lockedStakeTotal\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"latestStakeId\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"activeStakesTotal\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddr\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"stakeIdParam\",\"type\":\"uint40\"}],\"name\":\"stakeEarlyEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"stakeIdParam\",\"type\":\"uint40\"}],\"name\":\"stakeEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeLists\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"stakedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"lockedDay\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stakedDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"startIndexAPR\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakePeriods\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakePeriodsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"newStakedDays\",\"type\":\"uint16\"}],\"name\":\"stakeStart\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"stakeDays\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"coefficientWithMultiplier\",\"type\":\"uint256\"}],\"name\":\"updateAPRCoefficient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_someToken\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007f6ee7e043d12c2de15e9b4bb6bc0921e86361a9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://72b629ab9a8cacf566a542dce02004a71784e3bd0d136fd18758d92f8137fb73"}