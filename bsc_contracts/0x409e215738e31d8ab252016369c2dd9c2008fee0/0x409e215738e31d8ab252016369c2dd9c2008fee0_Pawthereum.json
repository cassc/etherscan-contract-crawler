{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.6.12;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n            data\r\n        );\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function sync() external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n}\r\n\r\ncontract Pawthereum is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    string private _name = \"Pawthereum\";\r\n    string private _symbol = \"PAWTH\";\r\n\r\n    uint8 private _decimals = 9;\r\n\r\n    mapping(address => uint256) internal _reflectionBalance;\r\n    mapping(address => uint256) internal _tokenBalance;\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n    mapping (address => bool) public automatedMarketMakerPairs;\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n    uint256 internal _tokenTotal = 1000000000e9;\r\n    uint256 internal _reflectionTotal = (MAX - (MAX % _tokenTotal));\r\n\r\n    mapping(address => bool) isTaxless;\r\n    mapping(address => bool) internal _isExcluded;\r\n    address[] internal _excluded;\r\n\r\n    uint256 public _feeDecimal = 2;\r\n    // 200 = 2%\r\n    uint256 public _taxFee = 200;\r\n    uint256 public _liquidityFee = 200;\r\n    uint256 public _burnFee = 0;\r\n    uint256 public _marketingFee = 200;\r\n    uint256 public _charityFee = 200;\r\n    uint256 public _stakingFee = 0;\r\n    uint256 public _maxTotalFee = 1200;\r\n\r\n    struct Purr {\r\n        uint256 buyTaxFee;\r\n        uint256 buyLiquidityFee;\r\n        uint256 buyBurnFee;\r\n        uint256 buyMarketingFee;\r\n        uint256 buyCharityFee;\r\n        uint256 buyStakingFee;\r\n        uint256 sellTaxFee;\r\n        uint256 sellLiquidityFee;\r\n        uint256 sellBurnFee;\r\n        uint256 sellMarketingFee;\r\n        uint256 sellCharityFee;\r\n        uint256 sellStakingFee;\r\n    }\r\n\r\n    Purr public _purr = Purr(100, 100, 0, 100, 100, 0, 400, 200, 0, 200, 400, 0);\r\n\r\n    uint256 public _taxFeeTotal;\r\n    uint256 public _burnFeeTotal;\r\n    uint256 public _liquidityFeeTotal;\r\n    uint256 public _marketingFeeTotal;\r\n    uint256 public _charityFeeTotal;\r\n    uint256 public _stakingFeeTotal;\r\n\r\n    uint256 public _liquidityTokensToSwap;\r\n    uint256 public _marketingTokensToSwap;\r\n    uint256 public _charityTokensToSwap;\r\n\r\n    address public marketingWallet;\r\n    address public charityWallet;\r\n    address public stakingWallet;\r\n\r\n    address public lpTokenHolder = address(this);\r\n\r\n    bool public _isPurrEnabled = false;\r\n\r\n    bool public isTaxActive = false;\r\n    bool private inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled = false;\r\n    bool public swapAndLiquifyMarketing = true;\r\n    bool public swapAndLiquifyCharity = true;\r\n    bool public isLpInitialized = false;\r\n\r\n    uint256 public maxTxAmount = _tokenTotal;\r\n    uint256 public maxTokensInSwap = 100_000e9;\r\n    uint256 public minTokensBeforeSwap = 10_000e9;\r\n\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n\r\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiqudity,\r\n        uint256 ethIntoLiquidity,\r\n        uint256 ethForMarketing,\r\n        uint256 ethForCharity\r\n    );\r\n    event PurrUpdated(\r\n        bool enabled,\r\n        uint256 buyTaxFee,\r\n        uint256 buyLiquidityFee,\r\n        uint256 buyBurnFee,\r\n        uint256 buyMarketingFee,\r\n        uint256 buyCharityFee,\r\n        uint256 buyStakingFee,\r\n        uint256 sellTaxFee,\r\n        uint256 sellLiquidityFee,\r\n        uint256 sellBurnFee,\r\n        uint256 sellMarketingFee,\r\n        uint256 sellCharityFee,\r\n        uint256 sellStakingFee\r\n    );\r\n\r\n    modifier lockTheSwap() {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n    constructor() public {\r\n        marketingWallet = 0x6DFcd4331b0d86bfe0318706C76B832dA4C03C1B;\r\n        stakingWallet = 0x9036464e4ecD2d40d21EE38a0398AEdD6805a09B;\r\n        charityWallet = 0xa56891cfBd0175E6Fc46Bf7d647DE26100e95C78;\r\n\r\n        isTaxless[_msgSender()] = true;\r\n        isTaxless[address(this)] = true;\r\n\r\n        _reflectionBalance[_msgSender()] = _reflectionTotal;\r\n        emit Transfer(address(0), _msgSender(), _tokenTotal);\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n        );\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        automatedMarketMakerPairs[uniswapV2Pair] = true;\r\n        uniswapV2Router = _uniswapV2Router;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tokenTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _tokenBalance[account];\r\n        return tokenFromReflection(_reflectionBalance[account]);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].sub(\r\n                subtractedValue,\r\n                \"ERC20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function isExcluded(address account) public view returns (bool) {\r\n        return _isExcluded[account];\r\n    }\r\n  \r\n    function isTaxlessAccount(address account) public view returns (bool) {\r\n        return isTaxless[account];\r\n    }\r\n\r\n    function reflectionFromToken(uint256 tokenAmount, bool deductTransferFee)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(tokenAmount <= _tokenTotal, \"Amount must be less than supply\");\r\n        if (!deductTransferFee) {\r\n            return tokenAmount.mul(_getReflectionRate());\r\n        } else {\r\n            return\r\n                tokenAmount\r\n                    .sub(tokenAmount.mul(_taxFee).div(10**(_feeDecimal + 2)))\r\n                    .mul(_getReflectionRate());\r\n        }\r\n    }\r\n\r\n    function tokenFromReflection(uint256 reflectionAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            reflectionAmount <= _reflectionTotal,\r\n            \"Amount must be less than total reflections\"\r\n        );\r\n        uint256 currentRate = _getReflectionRate();\r\n        return reflectionAmount.div(currentRate);\r\n    }\r\n\r\n    function excludeAccount(address account) external onlyOwner {\r\n        require(\r\n            account != address(uniswapV2Router),\r\n            \"ERC20: We can not exclude Uniswap router.\"\r\n        );\r\n        require(!_isExcluded[account], \"ERC20: Account is already excluded\");\r\n        if (_reflectionBalance[account] > 0) {\r\n            _tokenBalance[account] = tokenFromReflection(\r\n                _reflectionBalance[account]\r\n            );\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n    function includeAccount(address account) external onlyOwner {\r\n        require(_isExcluded[account], \"ERC20: Account is already included\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _tokenBalance[account] = 0;\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        require(amount <= maxTxAmount, \"Transfer Limit exceeded!\");\r\n\r\n        // total amount of tokens to swap is the accrued taxes\r\n        uint256 totalTokensToSwap = _liquidityTokensToSwap.add(\r\n            _marketingTokensToSwap\r\n        ).add(\r\n            _charityTokensToSwap\r\n        );\r\n\r\n        bool overMinTokenBalance = totalTokensToSwap >= minTokensBeforeSwap;\r\n        if (\r\n            !inSwapAndLiquify &&\r\n            overMinTokenBalance &&\r\n            sender != uniswapV2Pair &&\r\n            swapAndLiquifyEnabled\r\n        ) {\r\n            swapAndLiquify(totalTokensToSwap);\r\n        }\r\n\r\n        uint256 transferAmount = amount;\r\n        uint256 rate = _getReflectionRate();\r\n\r\n        if (\r\n            isTaxActive &&\r\n            !isTaxless[_msgSender()] &&\r\n            !isTaxless[recipient] &&\r\n            !inSwapAndLiquify\r\n        ) {\r\n            transferAmount = collectFee(sender, recipient, amount, rate);\r\n        }\r\n\r\n        _reflectionBalance[sender] = _reflectionBalance[sender].sub(\r\n            amount.mul(rate)\r\n        );\r\n        _reflectionBalance[recipient] = _reflectionBalance[recipient].add(\r\n            transferAmount.mul(rate)\r\n        );\r\n\r\n        if (_isExcluded[sender]) {\r\n            _tokenBalance[sender] = _tokenBalance[sender].sub(amount);\r\n        }\r\n        if (_isExcluded[recipient]) {\r\n            _tokenBalance[recipient] = _tokenBalance[recipient].add(\r\n                transferAmount\r\n            );\r\n        }\r\n\r\n        emit Transfer(sender, recipient, transferAmount);\r\n    }\r\n\r\n    function collectFee(\r\n        address account,\r\n        address recipient,\r\n        uint256 amount,\r\n        uint256 rate\r\n    ) private returns (uint256) {\r\n        uint256 transferAmount = amount;\r\n\r\n        uint256 pTaxFee = _taxFee;\r\n        uint256 pLiquidityFee = _liquidityFee;\r\n        uint256 pBurnFee = _burnFee;\r\n        uint256 pMarketingFee = _marketingFee;\r\n        uint256 pCharityFee = _charityFee;\r\n        uint256 pStakingFee = _stakingFee;\r\n    \r\n        // if purr is enabled and this is a buy, use special taxes\r\n        if (_isPurrEnabled && automatedMarketMakerPairs[account]) {\r\n            pTaxFee = _purr.buyTaxFee;\r\n            pLiquidityFee = _purr.buyLiquidityFee;\r\n            pBurnFee = _purr.buyBurnFee;\r\n            pMarketingFee = _purr.buyMarketingFee;\r\n            pCharityFee = _purr.buyCharityFee;\r\n            pStakingFee = _purr.buyStakingFee;\r\n        }\r\n\r\n        // if purr is enabled and this is a sell, use special taxes\r\n        if (_isPurrEnabled && automatedMarketMakerPairs[recipient]) {\r\n            pTaxFee = _purr.sellTaxFee;\r\n            pLiquidityFee = _purr.sellLiquidityFee;\r\n            pBurnFee = _purr.sellBurnFee;\r\n            pMarketingFee = _purr.sellMarketingFee;\r\n            pCharityFee = _purr.sellCharityFee;\r\n            pStakingFee = _purr.sellStakingFee;\r\n        }\r\n\r\n        //@dev tax fee\r\n        if (pTaxFee != 0) {\r\n            uint256 taxFee = amount.mul(pTaxFee).div(10**(_feeDecimal + 2));\r\n            transferAmount = transferAmount.sub(taxFee);\r\n            _reflectionTotal = _reflectionTotal.sub(taxFee.mul(rate));\r\n            _taxFeeTotal = _taxFeeTotal.add(taxFee);\r\n        }\r\n\r\n        //@dev liquidity fee\r\n        if (pLiquidityFee != 0) {\r\n            uint256 liquidityFee = amount.mul(pLiquidityFee).div(\r\n                10**(_feeDecimal + 2)\r\n            );\r\n            transferAmount = transferAmount.sub(liquidityFee);\r\n            _reflectionBalance[address(this)] = _reflectionBalance[\r\n                address(this)\r\n            ].add(liquidityFee.mul(rate));\r\n            if (_isExcluded[address(this)]) {\r\n                _tokenBalance[address(this)] = _tokenBalance[address(this)].add(\r\n                    liquidityFee\r\n                );\r\n            }\r\n            _liquidityTokensToSwap = _liquidityTokensToSwap.add(liquidityFee);\r\n            _liquidityFeeTotal = _liquidityFeeTotal.add(liquidityFee);\r\n            emit Transfer(account, address(this), liquidityFee);\r\n        }\r\n\r\n        //@dev burn fee\r\n        if (pBurnFee != 0) {\r\n            uint256 burnFee = amount.mul(pBurnFee).div(10**(_feeDecimal + 2));\r\n            transferAmount = transferAmount.sub(burnFee);\r\n            _tokenTotal = _tokenTotal.sub(burnFee);\r\n            _reflectionTotal = _reflectionTotal.sub(burnFee.mul(rate));\r\n            _burnFeeTotal = _burnFeeTotal.add(burnFee);\r\n            emit Transfer(account, address(0), burnFee);\r\n        }\r\n\r\n        //@dev Marketing fee\r\n        if (pMarketingFee != 0) {\r\n            uint256 marketingFee = amount.mul(pMarketingFee).div(\r\n                10**(_feeDecimal + 2)\r\n            );\r\n            transferAmount = transferAmount.sub(marketingFee);\r\n\r\n            if (swapAndLiquifyMarketing == false) {\r\n                _reflectionBalance[marketingWallet] = _reflectionBalance[\r\n                    marketingWallet\r\n                ].add(marketingFee.mul(rate));\r\n                if (_isExcluded[marketingWallet]) {\r\n                    _tokenBalance[marketingWallet] = _tokenBalance[\r\n                        marketingWallet\r\n                    ].add(marketingFee);\r\n                }\r\n                emit Transfer(account, marketingWallet, marketingFee);\r\n            } else {\r\n                _reflectionBalance[address(this)] = _reflectionBalance[\r\n                    address(this)\r\n                ].add(marketingFee.mul(rate));\r\n                if (_isExcluded[address(this)]) {\r\n                    _tokenBalance[address(this)] = _tokenBalance[address(this)].add(\r\n                        marketingFee\r\n                    );\r\n                }\r\n                _marketingTokensToSwap = _marketingTokensToSwap.add(marketingFee);\r\n                emit Transfer(account, address(this), marketingFee);\r\n            }\r\n\r\n            _marketingFeeTotal = _marketingFeeTotal.add(marketingFee);\r\n        }\r\n\r\n        //@dev Charity fee\r\n        if (pCharityFee != 0) {\r\n            uint256 charityFee = amount.mul(pCharityFee).div(\r\n                10**(_feeDecimal + 2)\r\n            );\r\n            transferAmount = transferAmount.sub(charityFee);\r\n\r\n            if (swapAndLiquifyCharity == false) {\r\n                _reflectionBalance[charityWallet] = _reflectionBalance[\r\n                    charityWallet\r\n                ].add(charityFee.mul(rate));\r\n                if (_isExcluded[charityWallet]) {\r\n                    _tokenBalance[charityWallet] = _tokenBalance[\r\n                        charityWallet\r\n                    ].add(charityFee);\r\n                }\r\n                emit Transfer(account, charityWallet, charityFee);\r\n            } else {\r\n                _reflectionBalance[address(this)] = _reflectionBalance[\r\n                    address(this)\r\n                ].add(charityFee.mul(rate));\r\n                if (_isExcluded[address(this)]) {\r\n                    _tokenBalance[address(this)] = _tokenBalance[address(this)].add(\r\n                        charityFee\r\n                    );\r\n                }\r\n                _charityTokensToSwap = _charityTokensToSwap.add(charityFee);\r\n                emit Transfer(account, address(this), charityFee);\r\n            }\r\n\r\n            _charityFeeTotal = _charityFeeTotal.add(charityFee);\r\n        }\r\n\r\n        //@dev Staking fee\r\n        if (pStakingFee != 0) {\r\n            uint256 stakingFee = amount.mul(pStakingFee).div(\r\n                10**(_feeDecimal + 2)\r\n            );\r\n            transferAmount = transferAmount.sub(stakingFee);\r\n            _reflectionBalance[stakingWallet] = _reflectionBalance[\r\n                stakingWallet\r\n            ].add(stakingFee.mul(rate));\r\n            if (_isExcluded[stakingWallet]) {\r\n                _tokenBalance[stakingWallet] = _tokenBalance[stakingWallet].add(\r\n                    stakingFee\r\n                );\r\n            }\r\n            _stakingFeeTotal = _stakingFeeTotal.add(stakingFee);\r\n            emit Transfer(account, stakingWallet, stakingFee);\r\n        }\r\n\r\n        return transferAmount;\r\n    }\r\n\r\n    function _getReflectionRate() private view returns (uint256) {\r\n        uint256 reflectionSupply = _reflectionTotal;\r\n        uint256 tokenSupply = _tokenTotal;\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (\r\n                _reflectionBalance[_excluded[i]] > reflectionSupply ||\r\n                _tokenBalance[_excluded[i]] > tokenSupply\r\n            ) return _reflectionTotal.div(_tokenTotal);\r\n            reflectionSupply = reflectionSupply.sub(\r\n                _reflectionBalance[_excluded[i]]\r\n            );\r\n            tokenSupply = tokenSupply.sub(_tokenBalance[_excluded[i]]);\r\n        }\r\n        if (reflectionSupply < _reflectionTotal.div(_tokenTotal))\r\n            return _reflectionTotal.div(_tokenTotal);\r\n        return reflectionSupply.div(tokenSupply);\r\n    }\r\n\r\n    function swapAndLiquify(uint256 totalTokensToSwap) private lockTheSwap {\r\n        // percentage of the total tokens swapped for each tax\r\n        uint256 liquidityRate = _liquidityTokensToSwap.mul(10**(_feeDecimal + 2)).div(totalTokensToSwap);\r\n        uint256 marketingRate = _marketingTokensToSwap.mul(10**(_feeDecimal + 2)).div(totalTokensToSwap);\r\n        uint256 charityRate = _charityTokensToSwap.mul(10**(_feeDecimal + 2)).div(totalTokensToSwap);\r\n\r\n        // cannot swap more than what is in the contract address balance\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        if (totalTokensToSwap > contractBalance) {\r\n            totalTokensToSwap = contractBalance;\r\n        }\r\n\r\n        // never swap more than the max tokens allowed in a swap\r\n        if (totalTokensToSwap > maxTokensInSwap) {\r\n            totalTokensToSwap = maxTokensInSwap;\r\n        }\r\n\r\n        // derive how many tokens we are actually going to swap\r\n        // based on the new total amount (in case it was over the maximum)\r\n        uint256 liquidityAmount = totalTokensToSwap.mul(liquidityRate).div(10**(_feeDecimal + 2));\r\n        uint256 marketingAmount = totalTokensToSwap.mul(marketingRate).div(10**(_feeDecimal + 2));\r\n        uint256 charityAmount = totalTokensToSwap.mul(charityRate).div(10**(_feeDecimal + 2));\r\n\r\n        // halve the amount of liquidity tokens\r\n        uint256 tokensForLiquidity = liquidityAmount.div(2);\r\n        uint256 amountToSwapForEth = totalTokensToSwap.sub(tokensForLiquidity);\r\n\r\n        uint256 initialBalance = address(this).balance;\r\n\r\n        swapTokensForEth(amountToSwapForEth);\r\n\r\n        uint256 newBalance = address(this).balance.sub(initialBalance);\r\n\r\n        // divy up the eth based on the rates\r\n        uint256 ethForMarketing = newBalance.mul(marketingAmount).div(amountToSwapForEth);\r\n        uint256 ethForCharity = newBalance.mul(charityAmount).div(amountToSwapForEth);\r\n        uint256 ethForLiquidity = newBalance.mul(tokensForLiquidity).div(amountToSwapForEth);\r\n\r\n        payable(marketingWallet).transfer(ethForMarketing);\r\n        payable(charityWallet).transfer(ethForCharity);\r\n\r\n        addLiquidity(tokensForLiquidity, ethForLiquidity);\r\n\r\n        // reset values based on how much was used\r\n        _liquidityTokensToSwap = _liquidityTokensToSwap.sub(liquidityAmount);\r\n        _marketingTokensToSwap = _marketingTokensToSwap.sub(marketingAmount);\r\n        _charityTokensToSwap = _charityTokensToSwap.sub(charityAmount);\r\n\r\n        emit SwapAndLiquify(\r\n            amountToSwapForEth, \r\n            newBalance, \r\n            tokensForLiquidity,\r\n            ethForLiquidity,\r\n            ethForMarketing,\r\n            ethForCharity\r\n        );\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            lpTokenHolder,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function setLpTokenHolder(address _newLpTokenHolder) external onlyOwner {\r\n        lpTokenHolder = _newLpTokenHolder;\r\n    }\r\n\r\n    function setPair(address pair) external onlyOwner {\r\n        uniswapV2Pair = pair;\r\n    }\r\n\r\n    function setMarketingWallet(address account) external onlyOwner {\r\n        marketingWallet = account;\r\n    }\r\n\r\n    function setCharityWallet(address account) external onlyOwner {\r\n        charityWallet = account;\r\n    }\r\n  \r\n    function setStakingWallet(address account) external onlyOwner {\r\n        stakingWallet = account;\r\n    }\r\n\r\n    function setTaxless(address account, bool value) external onlyOwner {\r\n        isTaxless[account] = value;\r\n    }\r\n\r\n    function setSwapAndLiquifyEnabled(bool enabled) external onlyOwner {\r\n        swapAndLiquifyEnabled = enabled;\r\n        emit SwapAndLiquifyEnabledUpdated(enabled);\r\n    }\r\n\r\n    function setTaxActive(bool value) external onlyOwner {\r\n        isTaxActive = value;\r\n    }\r\n\r\n    function setTaxFee(uint256 fee) external onlyOwner {\r\n        _taxFee = fee;\r\n        uint feeTotal = _burnFee.add(_liquidityFee).add(_marketingFee).add(_stakingFee).add(_charityFee).add(_taxFee);\r\n        require(feeTotal <= _maxTotalFee, \"Total fee cannot exceed maximum\");\r\n    }\r\n\r\n    function setBurnFee(uint256 fee) external onlyOwner {\r\n        _burnFee = fee;\r\n        uint feeTotal = _burnFee.add(_liquidityFee).add(_marketingFee).add(_stakingFee).add(_charityFee).add(_taxFee);\r\n        require(feeTotal <= _maxTotalFee, \"Total fee cannot exceed maximum\");\r\n    }\r\n\r\n    function setLiquidityFee(uint256 fee) external onlyOwner {\r\n        _liquidityFee = fee;\r\n        uint feeTotal = _burnFee.add(_liquidityFee).add(_marketingFee).add(_stakingFee).add(_charityFee).add(_taxFee);\r\n        require(feeTotal <= _maxTotalFee, \"Total fee cannot exceed maximum\");\r\n    }\r\n\r\n    function setMarketingFee(uint256 fee) external onlyOwner {\r\n        _marketingFee = fee;\r\n        uint feeTotal = _burnFee.add(_liquidityFee).add(_marketingFee).add(_stakingFee).add(_charityFee).add(_taxFee);\r\n        require(feeTotal <= _maxTotalFee, \"Total fee cannot exceed maximum\");\r\n    }\r\n\r\n    function setCharityFee(uint256 fee) external onlyOwner {\r\n        _charityFee = fee;\r\n        uint feeTotal = _burnFee.add(_liquidityFee).add(_marketingFee).add(_stakingFee).add(_charityFee).add(_taxFee);\r\n        require(feeTotal <= _maxTotalFee, \"Total fee cannot exceed maximum\");\r\n    }\r\n\r\n    function setMaxTxAmount(uint256 amount) external onlyOwner {\r\n        maxTxAmount = amount;\r\n    }\r\n  \r\n    function setMaxTokensInSwap(uint256 amount) external onlyOwner {\r\n        maxTokensInSwap = amount;\r\n    }\r\n\r\n    function setMinTokensBeforeSwap(uint256 amount) external onlyOwner {\r\n        minTokensBeforeSwap = amount;\r\n    }\r\n\r\n    function setSwapAndLiquifyMarketing(bool enabled) external onlyOwner {\r\n        swapAndLiquifyMarketing = enabled;\r\n    }\r\n\r\n    function setSwapAndLiquifyCharity(bool enabled) external onlyOwner {\r\n        swapAndLiquifyCharity = enabled;\r\n    }\r\n\r\n    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {\r\n        require(automatedMarketMakerPairs[pair] != value, \"Automated market maker pair is already set to that value\");\r\n        automatedMarketMakerPairs[pair] = value;\r\n    }\r\n  \r\n    function setRouterAddress(address newAddress) external onlyOwner {\r\n        require(newAddress != address(uniswapV2Router), \"The router already has that address\");\r\n        uniswapV2Router = IUniswapV2Router02(newAddress);\r\n    }\r\n\r\n    function setPurr(\r\n        bool enabled,\r\n        uint256 buyTaxFee,\r\n        uint256 buyLiquidityFee,\r\n        uint256 buyBurnFee,\r\n        uint256 buyMarketingFee,\r\n        uint256 buyCharityFee,\r\n        uint256 buyStakingFee,\r\n        uint256 sellTaxFee,\r\n        uint256 sellLiquidityFee,\r\n        uint256 sellBurnFee,\r\n        uint256 sellMarketingFee,\r\n        uint256 sellCharityFee,\r\n        uint256 sellStakingFee\r\n    ) external onlyOwner {\r\n        require(enabled != _isPurrEnabled, \"Purr value already set\");\r\n\r\n        uint256 totalBuyFee = _addThreeUints(buyTaxFee, buyLiquidityFee, buyBurnFee).add(\r\n            _addThreeUints(buyMarketingFee, buyCharityFee, buyStakingFee)\r\n        );\r\n        require(totalBuyFee <= _maxTotalFee, \"Total fee cannot exceed maximum\");\r\n\r\n        uint256 totalSellFee = _addThreeUints(sellTaxFee, sellLiquidityFee, sellBurnFee).add(\r\n            _addThreeUints(sellMarketingFee, sellCharityFee, sellStakingFee)\r\n        );\r\n        require(totalSellFee <= _maxTotalFee, \"Total fee cannot exceed maximum\");\r\n\r\n        _purr = Purr(\r\n            buyTaxFee,\r\n            buyLiquidityFee,\r\n            buyBurnFee,\r\n            buyMarketingFee,\r\n            buyCharityFee,\r\n            buyStakingFee,\r\n            sellTaxFee,\r\n            sellLiquidityFee,\r\n            sellBurnFee,\r\n            sellMarketingFee,\r\n            sellCharityFee,\r\n            sellStakingFee\r\n        );\r\n\r\n        _isPurrEnabled = enabled;\r\n\r\n        emit PurrUpdated(\r\n            enabled, \r\n            buyTaxFee, \r\n            buyLiquidityFee,\r\n            buyBurnFee,\r\n            buyMarketingFee,\r\n            buyCharityFee,\r\n            buyStakingFee,\r\n            sellTaxFee,\r\n            sellLiquidityFee,\r\n            sellBurnFee,\r\n            sellMarketingFee,\r\n            sellCharityFee,\r\n            sellStakingFee\r\n        );\r\n    }\r\n\r\n    function _addThreeUints(uint256 a, uint256 b, uint256 c) private pure returns (uint256) {\r\n        return a.add(b).add(c);\r\n    }\r\n  \r\n    function withdrawTokenToOwner(address tokenAddress, uint256 amount) external onlyOwner {\r\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\r\n        require(balance >= amount, \"Insufficient token balance\");\r\n\r\n        if (tokenAddress == address(this)) {\r\n            uint256 tokensToSwap = _liquidityTokensToSwap.add(_marketingTokensToSwap).add(_charityTokensToSwap);\r\n            uint256 remainingTokens = balance.sub(amount);\r\n\r\n            // if removing more tokens than what is set aside to swap,\r\n            // update the amount set aside while keeping proportions\r\n            if (remainingTokens < tokensToSwap) {\r\n                uint256 liquidityRate = _liquidityTokensToSwap.mul(10**(_feeDecimal + 2)).div(tokensToSwap);\r\n                uint256 marketingRate = _marketingTokensToSwap.mul(10**(_feeDecimal + 2)).div(tokensToSwap);\r\n                uint256 charityRate = _charityTokensToSwap.mul(10**(_feeDecimal + 2)).div(tokensToSwap);\r\n\r\n                uint256 newLiquidityAmountToSwap = remainingTokens.mul(liquidityRate).div(10**(_feeDecimal + 2));\r\n                uint256 newMarketingAmountToSwap = remainingTokens.mul(marketingRate).div(10**(_feeDecimal + 2));\r\n                uint256 newCharityAmountToSwap = remainingTokens.mul(charityRate).div(10**(_feeDecimal + 2));\r\n\r\n                _liquidityFeeTotal = _liquidityFeeTotal.sub(_liquidityTokensToSwap).add(newLiquidityAmountToSwap);\r\n                _marketingFeeTotal = _marketingFeeTotal.sub(_marketingTokensToSwap).add(newMarketingAmountToSwap);\r\n                _charityFeeTotal = _charityFeeTotal.sub(_charityTokensToSwap).add(newCharityAmountToSwap);\r\n\r\n                _liquidityTokensToSwap = newLiquidityAmountToSwap;\r\n                _marketingTokensToSwap = newMarketingAmountToSwap;\r\n                _charityTokensToSwap = newCharityAmountToSwap;\r\n            }\r\n        }\r\n\r\n        IERC20(tokenAddress).transfer(_msgSender(), amount);\r\n    }\r\n\r\n    function withdrawEthToOwner (uint256 _amount) external onlyOwner {\r\n        payable(_msgSender()).transfer(_amount);\r\n    }\r\n\r\n    function initLp () external payable onlyOwner {\r\n        require(isLpInitialized == false, \"LP already initialized\");\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        addLiquidity(contractTokenBalance, msg.value);\r\n        _liquidityFee = 9000;\r\n        isTaxActive = true;\r\n        swapAndLiquifyEnabled = true;\r\n        isLpInitialized = true;\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTaxFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyLiquidityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyBurnFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyMarketingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyCharityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyStakingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellTaxFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellLiquidityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellBurnFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellMarketingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellCharityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellStakingFee\",\"type\":\"uint256\"}],\"name\":\"PurrUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethIntoLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethForMarketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethForCharity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_charityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_charityFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_charityTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_feeDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isPurrEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_purr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyTaxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyMarketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyCharityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyStakingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTaxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellMarketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellCharityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellStakingFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_stakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_stakingFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initLp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLpInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTaxActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isTaxlessAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpTokenHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokensInSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokensBeforeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setBurnFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setCharityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setCharityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newLpTokenHolder\",\"type\":\"address\"}],\"name\":\"setLpTokenHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setMarketingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTokensInSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinTokensBeforeSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"setPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"buyTaxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyMarketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyCharityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyStakingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTaxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellMarketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellCharityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellStakingFee\",\"type\":\"uint256\"}],\"name\":\"setPurr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setStakingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyCharity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyMarketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setTaxActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setTaxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setTaxless\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyCharity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyMarketing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reflectionAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEthToOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenToOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Pawthereum", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4b83c2e03d1a40e7ad21374de10969004f8df313fb51fb703bfb16612144aabd"}