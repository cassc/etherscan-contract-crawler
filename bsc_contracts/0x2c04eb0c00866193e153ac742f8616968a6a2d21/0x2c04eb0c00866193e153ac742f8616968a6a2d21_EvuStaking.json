{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract EvuStaking {\r\n    using SafeMath for uint;\r\n    //Estableces contrato del token para Staking\r\n    IERC20 public stakingToken;\r\n    //Estrutura de variable deposito de staking\r\n    //Amount : monto depositados del usuario\r\n    //initTime ; Fecha de deposito del token\r\n    //endLock: Fecha de debloqueo de token\r\n    //status: Estado de la wallet para ganar o no\r\n    //wrewars: Token Retirado de gancia\r\n    //rewars: Token Ganado\r\n    struct Staking{\r\n        uint amount;\r\n        uint rewards;\r\n        uint initTime;\r\n        uint endLock;\r\n        uint wreward;\r\n        uint lastrewards;\r\n        uint initpcent;\r\n    }\r\n    /////POR CIENTO DEL API %/////////////////\r\n    uint private Percent = 250;\r\n    uint private Status = 1;\r\n    uint public CountWallet = 0;\r\n    //Establecer porcentaje de ganacias por mes\r\n    //Cada nuemero representa un % y un mes desde la posicion 0\r\n\r\n    uint[] private Meses = [350,400,480,560,650,800,940,1040,1100,1150,1240,1290];\r\n  \r\n    address[] public qwallets;\r\n\r\n    mapping(uint => address) private _wallets;\r\n\r\n    mapping(address => bool) private _existe;\r\n    /////Estableces Variables Necesarias/////\r\n    // 14 DIAS, 30 DIAS, 90 DIAS, 180 DIAS, 180 DIAS\r\n    uint private undia = 1 days;\r\n    uint public currentTime = block.timestamp;\r\n    mapping(address => Staking[]) public qTokenStake;\r\n    uint public _totalSupply;\r\n    uint public _balances;\r\n    ///Declarar owen\r\n    address public owen;\r\n   //VARIABLE DE ESTADO True and False\r\n    bool private active = true;\r\n    \r\n    constructor(address _addresToken,address _addressOwen){\r\n        stakingToken = IERC20(_addresToken);\r\n        owen = _addressOwen;\r\n    }\r\n    event ClainEvent(address wallet, uint reward);\r\n    event StakingEvent(address wallet, uint amount);\r\n    event UnStakingEvent(address wallet, uint amount);\r\n\r\n     function getSegundos(uint _lastrewards) internal view returns(uint){\r\n        uint total_sedundos = block.timestamp.sub(_lastrewards);\r\n        return total_sedundos;\r\n   }\r\n\r\n    function getEndlock(uint _lock, uint _lastrewards) internal pure  returns(uint){\r\n        uint endlock = _lock.sub(_lastrewards);\r\n        return endlock;\r\n    }\r\n\r\n    function getSegundoRewards(uint _segundosReward, uint _lock) internal pure  returns(uint){\r\n        uint qmes = 1;\r\n        if(_segundosReward > 30 days){\r\n            qmes = (_segundosReward / 30 days) +1;\r\n        }\r\n        if(_segundosReward > _lock && _lock > 30 days){\r\n            qmes = _lock / 30 days;\r\n        }\r\n        if(_segundosReward < 30 days){\r\n            qmes = 1;\r\n        }\r\n        return qmes;\r\n     }\r\n    ///porcentages por meses\r\n    function getTotalRewards(address _addr, uint _index) public view returns(uint) {\r\n        ///  require(qTokenStake[_addr][_index].amount > 0,\"getTotalRewards: No tienes fondos suficientes...\");\r\n        //Multiplicar monto  de stake por el porciento del mes =  renta mensual / 30 dias\r\n        ///PROBLEMA SE RECIBE UN DECIMAL POR TANTO NO ES SOLUCION\r\n       // uint _tamount = qTokenStake[_addr][_index].amount.div(100);\r\n        uint _tamount = qTokenStake[_addr][_index].amount;\r\n        uint _result = 0;\r\n      \r\n         _result+=(qTokenStake[_addr][_index].rewards);\r\n         if(qTokenStake[_addr][_index].endLock > qTokenStake[_addr][_index].lastrewards){\r\n                uint lastrewards = qTokenStake[_addr][_index].lastrewards;\r\n                uint lock = qTokenStake[_addr][_index].endLock;\r\n                uint _rewardSec = getSegundos(lastrewards);\r\n                uint endlock = getEndlock(lock,lastrewards);\r\n                uint qmes = getSegundoRewards(_rewardSec,lock);\r\n    \r\n                if(_rewardSec > endlock){\r\n                    _rewardSec = endlock;\r\n                }\r\n  \r\n                uint totals;\r\n                uint _c = qTokenStake[_addr][_index].initpcent;\r\n              \r\n                totals = _rewardSec;//gs.sub(_mdias);\r\n                for(uint i = 1; i<=qmes; i++){      \r\n                        if(_c >= 11 ){\r\n                            _c = 11;\r\n                          }\r\n                          if(i<2){\r\n                            if(_rewardSec < 30 days){\r\n                              _result  += _rewardSec * getPaymonSec(_tamount,_c);  \r\n                              \r\n                            }else{\r\n                                _result  += 30 days * getPaymonSec(_tamount,_c);  \r\n                                totals -= 30 days;\r\n                            }\r\n                          }else{\r\n                              \r\n                              if(totals >= 30 days){\r\n                                  _result += 30 days * getPaymonSec(_tamount,_c);  \r\n                                  totals -= 30 days;\r\n                              }else{\r\n                                  _result += totals * getPaymonSec(_tamount,_c);  \r\n                              }\r\n                          }\r\n                  \r\n                      _c++;\r\n                  }\r\n\r\n            }\r\n       \r\n            return _result;\r\n        \r\n    } \r\n    //////////////OPTENER POR CIENTO/////////////////////\r\n    function getPercent(uint _mes) public view returns(uint){\r\n      ///  uint _pg = Percent / 100;\r\n       return  Percent * Meses[_mes];\r\n    }\r\n    ////////////Optener Monto pagado por segundo////////////////\r\n    function getPaymonSec(uint _amount,uint _mes) public view returns(uint){ \r\n       return ((_amount * getPercent(_mes)) / 1000000) / 30 days;\r\n       // 1000,000,000,000 * (250 * 350) / 1000000 / 30 = 60*60*24*30\r\n    }\r\n      /////////modificador administrador///////////\r\n       /////////Para bonos ICO///////////\r\n    modifier stakingAllow() {\r\n            require(Status > 0,\"This Staking is Close...\");\r\n        _;\r\n    }\r\n    /////////Desposito al contrato de Staking//////////////\r\n    /////////Bloqueando wallet/////////\r\n    function stake(uint _amount,uint _dias) external stakingAllow() {\r\n        require(_dias > 7,\"Stake invalid: Min 7 days\");\r\n         uint qdias = _dias.mul(undia) + block.timestamp;\r\n         qTokenStake[msg.sender].push(Staking(_amount,0,block.timestamp,qdias,0,block.timestamp,0)); \r\n        _totalSupply += _amount;\r\n         stakingToken.transferFrom(msg.sender, address(this), _amount);\r\n          if (!_existe[msg.sender]) {\r\n             qwallets.push(msg.sender);\r\n             CountWallet = CountWallet + 1;\r\n            _wallets[CountWallet] = msg.sender;\r\n          }\r\n         emit StakingEvent(msg.sender,_amount);\r\n         _existe[msg.sender] = true;\r\n            \r\n    }\r\n    //////////Retirar Dinero del Staking//////////////////\r\n    function unStaking(uint _index) public returns(bool) {\r\n         require(qTokenStake[msg.sender][_index].amount > 0,\"unStaking: Insufficient funds\");\r\n        // require(block.timestamp > qTokenStake[msg.sender][_index].endLock,\"unStaking: funds still locked...\");\r\n        uint totalAmount;\r\n        uint wreward = 0;\r\n         if(block.timestamp >= qTokenStake[msg.sender][_index].endLock){\r\n              totalAmount = qTokenStake[msg.sender][_index].amount;  \r\n         }else{\r\n              totalAmount = (qTokenStake[msg.sender][_index].amount).sub(qTokenStake[msg.sender][_index].wreward);\r\n              wreward = qTokenStake[msg.sender][_index].wreward;\r\n         }\r\n          _balances += wreward;\r\n          _totalSupply -= (totalAmount + wreward);\r\n          uint totalg =  totalAmount;\r\n          stakingToken.transfer(msg.sender,totalg);\r\n          qTokenStake[msg.sender][_index].amount = 0;\r\n          qTokenStake[msg.sender][_index].rewards = 0;\r\n          qTokenStake[msg.sender][_index].initTime = 0;\r\n          qTokenStake[msg.sender][_index].endLock = 0;\r\n          qTokenStake[msg.sender][_index].lastrewards = 0;\r\n          qTokenStake[msg.sender][_index].initpcent = 0;\r\n          emit UnStakingEvent(msg.sender,totalg);\r\n         return true;\r\n    }\r\n    ////////Reclamar recompensas ganadas por Staking/////////////////////\r\n    function ClaimReward(uint _index) public returns(bool) {\r\n        uint reward = getTotalRewards(msg.sender, _index);\r\n        require(reward > 0,\"ClaimReward: You have no rewards...\");\r\n        require(_balances > 0,\"ClaimReward: Insufficient funds...\");\r\n        _balances -= reward;\r\n        stakingToken.transfer(msg.sender, reward);\r\n        qTokenStake[msg.sender][_index].wreward += reward;\r\n        qTokenStake[msg.sender][_index].rewards = 0;\r\n        qTokenStake[msg.sender][_index].lastrewards = block.timestamp;\r\n        qTokenStake[msg.sender][_index].initpcent = (block.timestamp.sub(qTokenStake[msg.sender][_index].initTime) / 30 days);\r\n         emit ClainEvent(msg.sender, reward);\r\n        return true;\r\n    }\r\n\r\n    /** Xcen de wallet por index*/\r\n    function getXcentMywallet(address _wallet, uint _index) public view returns(uint){\r\n        return (block.timestamp.sub(qTokenStake[_wallet][_index].initTime) / 30 days);\r\n    }\r\n\r\n    /////////modificador administrador///////////\r\n    modifier AdminOwen(address _admin) {\r\n            require(_admin == owen,\"You do not have authorization\");\r\n        _;\r\n    }\r\n    //////PORCENTAJE PUBLICO////////\r\n   function ShowPercent() public  view returns(uint) {\r\n          return Percent;\r\n    }\r\n \r\n   function walletShow(uint _position) public  view returns(address) {\r\n          return _wallets[_position];\r\n    }\r\n     //////PORCENTAJE change////////\r\n    function setPercent(uint _porcent) external AdminOwen(msg.sender) {\r\n          Percent = _porcent;\r\n    }\r\n     event SetEwallet(address from, uint value);\r\n     //////MODIFICAR POR CIENTO ANUAL - SOLO ADMIN////////\r\n    function setWalletxCent( uint[] memory _num) external AdminOwen(msg.sender) {\r\n        uint len = _num.length;\r\n        uint init = _num[0];\r\n        uint fin = _num[1];\r\n        require(len > 0); \r\n        ///////Parsea todas las walllet/////////\r\n        for (uint256 i = init; i <= fin; i++) {\r\n          \r\n            address _recipient = _wallets[i];\r\n             \r\n            uint _cadr = qTokenStake[_recipient].length;\r\n             \r\n              emit SetEwallet(_recipient, i);\r\n            //////parseas las wallet por usuarios//////////\r\n            for(uint _index = 0; _index < _cadr; _index++){\r\n                uint reward = getTotalRewards(_recipient, _index);\r\n               \r\n                if(reward > 0){ \r\n                    qTokenStake[_recipient][_index].rewards = reward;\r\n                    qTokenStake[_recipient][_index].lastrewards = block.timestamp;\r\n                }\r\n            }\r\n        }\r\n \r\n    }\r\n \r\n     //////MODIFICAR POR CIENTO ANUAL - SOLO ADMIN////////\r\n    function UpdatePercentRewards(address[] memory _targets,uint xcent) external AdminOwen(msg.sender) {\r\n        uint len = _targets.length;\r\n        require(len > 0); \r\n        ///////Parsea todas las walllet/////////\r\n        for (uint256 i = 0; i < len; i++) {\r\n            address _recipient = _targets[i];\r\n            uint _cadr = qTokenStake[_recipient].length;\r\n            //////parseas las wallet por usuarios//////////\r\n            for(uint _index = 0; _index < _cadr; _index++){\r\n                uint reward = getTotalRewards(_recipient, _index);\r\n                if(reward > 0){ \r\n                    qTokenStake[_recipient][_index].rewards = reward;\r\n                    qTokenStake[_recipient][_index].lastrewards = block.timestamp;\r\n                }\r\n            }\r\n        }\r\n        Percent = xcent;\r\n    }\r\n   //////Get lista de inversion////////\r\n    function getAccounts(address _addr, uint _index) public view returns(uint,uint,uint,uint,uint,uint){\r\n       return (\r\n              qTokenStake[_addr][_index].amount,\r\n              qTokenStake[_addr][_index].rewards,\r\n              qTokenStake[_addr][_index].initTime,\r\n              qTokenStake[_addr][_index].endLock,\r\n              qTokenStake[_addr][_index].wreward,\r\n              qTokenStake[_addr][_index].lastrewards\r\n              );\r\n    }\r\n    ///////Contar lista de inversion//////\r\n     function getCount(address _addr) public view returns(uint){\r\n        return qTokenStake[_addr].length;\r\n    }\r\n    /////////DEPOSITO DE BALANCE///////////////\r\n     function deposit(uint _amount) public {\r\n         stakingToken.transferFrom(msg.sender, address(this), _amount);\r\n         _balances += _amount;\r\n      }\r\n    /////////RETIRAR BALANCE///////////////\r\n    function retrieveTokens() external AdminOwen(msg.sender) {\r\n         stakingToken.transfer(msg.sender, _balances);\r\n         _balances = 0;\r\n     }\r\n   /////////OPEN AND CLOSE///////////////\r\n      function setStatus(uint _value) public AdminOwen(msg.sender) {\r\n              Status = _value;\r\n      }\r\n    \r\n}\r\n  ////INTERFACE NECESARIA PARA LAS RELAIZACION DE TRANZACIONES EN EL STAKING\r\n  interface IERC20 {\r\n      function totalSupply() external view returns (uint);\r\n\r\n      function balanceOf(address account) external view returns (uint);\r\n\r\n      function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n      function allowance(address owner, address spender) external view returns (uint);\r\n\r\n      function approve(address spender, uint amount) external returns (bool);\r\n\r\n      function transferFrom(\r\n          address sender,\r\n          address recipient,\r\n          uint amount\r\n      ) external returns (bool);\r\n\r\n      event Transfer(address indexed from, address indexed to, uint value);\r\n      event Approval(address indexed owner, address indexed spender, uint value);\r\n  }", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addresToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressOwen\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"ClainEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetEwallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakingEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnStakingEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CountWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ShowPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"xcent\",\"type\":\"uint256\"}],\"name\":\"UpdatePercentRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mes\",\"type\":\"uint256\"}],\"name\":\"getPaymonSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mes\",\"type\":\"uint256\"}],\"name\":\"getPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getXcentMywallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owen\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"qTokenStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endLock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastrewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initpcent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"qwallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_porcent\",\"type\":\"uint256\"}],\"name\":\"setPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_num\",\"type\":\"uint256[]\"}],\"name\":\"setWalletxCent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dias\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"unStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"walletShow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EvuStaking", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000018b5f22266343ccd180c6285a66cc9a23dc262e90000000000000000000000005ef6c19a2854c9c75fa96971e23efe9caa9c73d6", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8a4af42d5aecd814b9c2a95a4a479214d50614feece5e017991a63b7ec43f1f0"}