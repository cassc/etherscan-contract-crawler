{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contractBsc/swapBinanceV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ninterface IUniswapRouterV2 {\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline) external\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapRouterV3{\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    struct ExactInputParams {\\r\\n        bytes path;\\r\\n        address recipient;  \\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n    }\\r\\n\\r\\n    function exactInputSingle(ExactInputSingleParams memory params) external payable returns (uint256 amountOut);\\r\\n    function exactInput(ExactInputParams memory params) external returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouterV3{\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;}\\r\\n\\r\\n    function exactInputSingle(ExactInputSingleParams memory params) external payable returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\ninterface IUniswapPoolV2{\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function token0()external view returns(address);\\r\\n}\\r\\n\\r\\ninterface IUniswapPoolsV3 {\\r\\n    function slot0()external view returns (uint160 sqrtPriceX96 , \\r\\n                                      int24 tick, uint16 observationIndex,\\r\\n                                      uint16 observationCardinality,\\r\\n                                      uint16 observationCardinalityNext,\\r\\n                                      uint8 feeProtocol,\\r\\n                                      bool unlocked);// use for uniswap contracts\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function token0()external view returns(address);\\r\\n}\\r\\n\\r\\ninterface IERC20{\\r\\n    function decimals() external view returns(uint8);\\r\\n    function balanceOf(address owner)external view returns(uint);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address to , uint value)external;\\r\\n\\r\\n}\\r\\n\\r\\n interface IWERC20{\\r\\n    function deposit()external payable;\\r\\n    function withdraw(uint256 amount) external payable;\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function balanceOf(address owner)external view returns(uint);\\r\\n    function transfer(address to , uint value)external view;\\r\\n }\\r\\n\\r\\ninterface IswapData{\\r\\n\\r\\n    struct SwapInputs{\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    address middleWareToken;\\r\\n    address receiver;\\r\\n    bytes pathV3;\\r\\n    uint amountIn;\\r\\n    uint24 fee;\\r\\n    bool isCoin;\\r\\n    uint deadline;\\r\\n    uint amountOutMinimum;\\r\\n    string contractType;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract swapBinanceV1{\\r\\n\\r\\n    mapping(string =>mapping(string => address)) dexsToSymbols;\\r\\n    mapping(string => uint24)feeOfTheDex;\\r\\n\\r\\n    address immutable admin;\\r\\n    address Wbnb = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\r\\n    address bnb = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\r\\n\\r\\n    event SetNewAddress(string , string);\\r\\n    event Swap(address indexed user,uint amountIn, address tokenIn , uint indexed amountOut , address indexed tokenOut);\\r\\n    event SetFeeDex(string , uint24);\\r\\n\\r\\n\\r\\n    modifier onlyAdmin(){\\r\\n        require(msg.sender == admin , \\\"not the admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isAmount(){\\r\\n        require(msg.value > 0 , \\\"amount does not exist\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isToken(address token){\\r\\n        require(token !=address(0) , \\\"address token does not exits\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(){\\r\\n        admin = msg.sender;\\r\\n    }\\r\\n\\r\\n    receive()external payable{}\\r\\n\\r\\n    function setDexSymbolContracts(string calldata dexName,string calldata symbol,address contractAddress) external onlyAdmin{\\r\\n        require(dexsToSymbols[dexName][symbol] == address(0) , \\\"dex address is set\\\");\\r\\n        dexsToSymbols[dexName][symbol] = contractAddress;\\r\\n        emit SetNewAddress(dexName , symbol);\\r\\n    }\\r\\n\\r\\n    function setFeeOfDex(string memory contractType , uint24 feeAmount)external onlyAdmin{\\r\\n        require(feeOfTheDex[contractType] == 0 ,\\\"fee is set\\\");\\r\\n        feeOfTheDex[contractType] = feeAmount;\\r\\n        emit SetFeeDex(contractType , feeAmount);\\r\\n    }\\r\\n\\r\\n    function removeFeeOfDex(string memory contractType)external onlyAdmin{\\r\\n        delete feeOfTheDex[contractType];\\r\\n    }\\r\\n\\r\\n    function deletedexContractAddress(string  memory dex , string memory contractType)external onlyAdmin returns(bool){\\r\\n        \\r\\n        bool status = dexsToSymbols[dex][contractType] == address(0) ? false : true;\\r\\n        \\r\\n        delete dexsToSymbols[dex][contractType];\\r\\n\\r\\n        return status;\\r\\n    }\\r\\n\\r\\n    function executeSwap(IswapData.SwapInputs memory swapInput)\\r\\n    public payable \\r\\n    isToken(swapInput.tokenIn)\\r\\n    returns(uint amountOut){\\r\\n      if(swapInput.tokenIn != Wbnb && swapInput.isCoin != true)require(msg.value == 0 , \\\"no funds accepted\\\");\\r\\n\\r\\n      if(checkDexName(swapInput.contractType , \\\"UNISWAPV3\\\")){\\r\\n            \\r\\n            amountOut = UniswapV3Execute(swapInput);\\r\\n\\r\\n      }else if(checkDexName(swapInput.contractType , \\\"PANCAKESWAPV3\\\")){\\r\\n\\r\\n            amountOut = PancakeSwapExecuteV3(swapInput);\\r\\n\\r\\n      }else{\\r\\n            amountOut = UniswapV2Execute(swapInput);\\r\\n        }\\r\\n\\r\\n      emit Swap(msg.sender , swapInput.amountIn, swapInput.tokenIn , amountOut , swapInput.tokenOut);\\r\\n    } \\r\\n\\r\\n    function UniswapV2Execute(IswapData.SwapInputs memory swapInput)\\r\\n    public payable \\r\\n    isToken(swapInput.tokenIn)\\r\\n    returns(uint){\\r\\n        \\r\\n        address payable RouterV2 = payable (dexToContractAddress(swapInput.contractType ,\\\"ROUTERV2\\\"));\\r\\n        address [] memory path;\\r\\n        uint [] memory amountOut;\\r\\n        address sender = msg.sender;\\r\\n\\r\\n        require(RouterV2 != address(0) , \\\"address for dex not found\\\");\\r\\n        if(swapInput.tokenIn == Wbnb && swapInput.isCoin)require(msg.value > 0 ,\\\"not enough ETH\\\");\\r\\n\\r\\n        if(swapInput.middleWareToken != address(0)){\\r\\n            path = new address[](3);\\r\\n            path[0] = swapInput.tokenIn;\\r\\n            path[1] = swapInput.middleWareToken;\\r\\n            path[2] = swapInput.tokenOut; \\r\\n        }else{\\r\\n            path = new address[](2);\\r\\n            \\r\\n            path[0] = swapInput.tokenIn;\\r\\n            path[1] = swapInput.tokenOut; \\r\\n        }\\r\\n\\r\\n        if(swapInput.tokenIn == Wbnb && msg.value > 0 && swapInput.isCoin){\\r\\n            require(msg.value > 0 ,\\\"not enough ETH\\\");\\r\\n            amountOut = IUniswapRouterV2(RouterV2).swapExactETHForTokens{value: msg.value}(swapInput.amountOutMinimum , path, swapInput.receiver , swapInput.deadline);\\r\\n            \\r\\n\\r\\n        }\\r\\n        else if(swapInput.tokenOut == Wbnb && swapInput.isCoin){\\r\\n            require(IERC20(swapInput.tokenIn).balanceOf(sender)  >= swapInput.amountIn , \\\"not enough tokens\\\");\\r\\n\\r\\n            approving(swapInput.tokenIn , sender , RouterV2 , swapInput.amountIn);\\r\\n            \\r\\n\\r\\n            amountOut = IUniswapRouterV2(RouterV2).swapExactTokensForETH(swapInput.amountIn , swapInput.amountOutMinimum ,path ,swapInput.receiver ,swapInput.deadline);\\r\\n        }\\r\\n        else{\\r\\n            require(msg.value == 0 , \\\"eth must not be send\\\");\\r\\n            \\r\\n            require(IERC20(swapInput.tokenIn).balanceOf(sender)  >= swapInput.amountIn , \\\"not enough tokens\\\");\\r\\n            \\r\\n            approving(swapInput.tokenIn , sender , RouterV2 , swapInput.amountIn);\\r\\n\\r\\n            amountOut = IUniswapRouterV2(RouterV2).swapExactTokensForTokens(swapInput.amountIn ,swapInput.amountOutMinimum , path , swapInput.receiver ,swapInput.deadline);\\r\\n        } \\r\\n        return amountOut[path.length - 1];\\r\\n    }\\r\\n\\r\\n    function bnbToWbnb( uint amount , bool zeroToOne)public payable returns(bool){\\r\\n        //zero for withdraw , one for deposit\\r\\n        if(zeroToOne){\\r\\n            require(amount == msg.value ,\\\"not the same amount for deposit\\\");\\r\\n            IWERC20(Wbnb).deposit{value:msg.value}();\\r\\n            return true;\\r\\n        }else{\\r\\n            IWERC20(Wbnb).withdraw(amount);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function UniswapV3Execute(IswapData.SwapInputs memory swapInput)\\r\\n    public payable\\r\\n    isToken(swapInput.tokenIn) \\r\\n    returns(uint){\\r\\n\\r\\n        if(swapInput.tokenIn == Wbnb && swapInput.isCoin) require(msg.value == swapInput.amountIn , \\\"not correct amount\\\");\\r\\n        \\r\\n        address  RouterV3 = dexToContractAddress(swapInput.contractType , \\\"ROUTERV3\\\");\\r\\n        address sender = msg.sender;\\r\\n        address receiver = swapInput.receiver;\\r\\n        uint amountOut; \\r\\n        uint160 sqrtPriceLimitX96 = 0;//for testing\\r\\n        IUniswapRouterV3.ExactInputSingleParams memory params;\\r\\n\\r\\n        if(swapInput.tokenOut == Wbnb && swapInput.isCoin)receiver = address(this);\\r\\n\\r\\n        params = IUniswapRouterV3.ExactInputSingleParams(swapInput.tokenIn , swapInput.tokenOut , swapInput.fee \\r\\n                                                        , receiver , swapInput.amountIn \\r\\n                                                        , swapInput.amountOutMinimum ,sqrtPriceLimitX96);\\r\\n\\r\\n        if(swapInput.tokenIn == Wbnb && swapInput.isCoin){\\r\\n            \\r\\n            amountOut = IUniswapRouterV3(RouterV3).exactInputSingle{value : msg.value}(params);\\r\\n        }\\r\\n        else {\\r\\n            \\r\\n            approving(swapInput.tokenIn , sender , RouterV3 , swapInput.amountIn);\\r\\n\\r\\n            if(swapInput.middleWareToken == address(0) && (swapInput.pathV3).length == 0){\\r\\n                \\r\\n                amountOut = IUniswapRouterV3(RouterV3).exactInputSingle(params);\\r\\n\\r\\n            }else if((swapInput.pathV3).length != 0){\\r\\n                \\r\\n                amountOut = multiHopSwapV3(swapInput,receiver);\\r\\n                if(receiver != address(this))return(amountOut);\\r\\n\\r\\n            }\\r\\n\\r\\n            if(swapInput.tokenOut == Wbnb && swapInput.isCoin){\\r\\n                bnbToWbnb(amountOut , false);\\r\\n                (payable(swapInput.receiver)).transfer(amountOut);\\r\\n            }\\r\\n        }\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    function PancakeSwapExecuteV3(IswapData.SwapInputs memory swapInput)\\r\\n    public payable \\r\\n    isToken(swapInput.tokenIn) \\r\\n    returns(uint){ \\r\\n\\r\\n    if(swapInput.tokenIn == Wbnb && swapInput.isCoin) require(msg.value == swapInput.amountIn , \\\"not correct amount\\\");\\r\\n    \\r\\n    address  RouterV3 = dexToContractAddress(swapInput.contractType , \\\"ROUTERV3\\\");\\r\\n    address sender = msg.sender;\\r\\n    address receiver = swapInput.receiver;\\r\\n    uint amountOut;\\r\\n    uint160 sqrtPriceLimitX96 = 0;//for testing\\r\\n    IPancakeRouterV3.ExactInputSingleParams memory params;\\r\\n\\r\\n    if(swapInput.tokenOut == Wbnb && swapInput.isCoin)receiver = address(this);\\r\\n\\r\\n\\r\\n    params = IPancakeRouterV3.ExactInputSingleParams(swapInput.tokenIn , swapInput.tokenOut , swapInput.fee \\r\\n                                                    ,receiver , swapInput.amountIn , swapInput.amountOutMinimum \\r\\n                                                    ,sqrtPriceLimitX96);\\r\\n\\r\\n\\r\\n    if(swapInput.tokenIn == Wbnb && swapInput.isCoin){\\r\\n            amountOut = IPancakeRouterV3(RouterV3).exactInputSingle{value : msg.value}(params);\\r\\n            return amountOut;\\r\\n        \\r\\n        }else {\\r\\n\\r\\n            approving(swapInput.tokenIn , sender , RouterV3 , swapInput.amountIn);\\r\\n\\r\\n            if(swapInput.middleWareToken == address(0) && (swapInput.pathV3).length == 0){\\r\\n                amountOut = IPancakeRouterV3(RouterV3).exactInputSingle(params);\\r\\n            }else if((swapInput.pathV3).length != 0){\\r\\n                amountOut =  multiHopSwapV3(swapInput,receiver);\\r\\n                if(amountOut > 0)return amountOut;\\r\\n            }\\r\\n\\r\\n            if(swapInput.tokenOut == Wbnb && swapInput.isCoin){\\r\\n                bnbToWbnb(amountOut , false);\\r\\n                (payable(swapInput.receiver)).transfer(amountOut);\\r\\n            }\\r\\n        }\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    function multiHopSwapV3(IswapData.SwapInputs memory swapInput , address recipient)public returns(uint){\\r\\n        address routerV3 = dexToContractAddress(swapInput.contractType, \\\"ROUTERV3\\\");\\r\\n        uint amount;\\r\\n        require(routerV3 !=address(0),\\\"no address for router set\\\");\\r\\n        if((swapInput.pathV3).length != 0){\\r\\n            IUniswapRouterV3.ExactInputParams memory params = IUniswapRouterV3.ExactInputParams(swapInput.pathV3 , recipient,swapInput.amountIn,swapInput.amountOutMinimum);\\r\\n            amount = IUniswapRouterV3(routerV3).exactInput(params);\\r\\n            \\r\\n        }\\r\\n        require(amount > 0 , \\\"not swapped\\\");\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function approving(address token,address sender,address approveAddress,uint amountIn)internal {\\r\\n        IERC20(token).transferFrom(sender , address(this) , amountIn);\\r\\n            IERC20(token).approve(approveAddress ,amountIn); \\r\\n    }\\r\\n\\r\\n    function checkDexName(string memory name , string memory dex)public pure returns(bool){\\r\\n        return keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked(dex));\\r\\n    }\\r\\n\\r\\n    function dexToContractAddress(string  memory dex , string memory contractType)public view returns(address){\\r\\n        return dexsToSymbols[dex][contractType];\\r\\n    }\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"SetFeeDex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"SetNewAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"middleWareToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pathV3\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"internalType\":\"struct IswapData.SwapInputs\",\"name\":\"swapInput\",\"type\":\"tuple\"}],\"name\":\"PancakeSwapExecuteV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"middleWareToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pathV3\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"internalType\":\"struct IswapData.SwapInputs\",\"name\":\"swapInput\",\"type\":\"tuple\"}],\"name\":\"UniswapV2Execute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"middleWareToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pathV3\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"internalType\":\"struct IswapData.SwapInputs\",\"name\":\"swapInput\",\"type\":\"tuple\"}],\"name\":\"UniswapV3Execute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"zeroToOne\",\"type\":\"bool\"}],\"name\":\"bnbToWbnb\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"dex\",\"type\":\"string\"}],\"name\":\"checkDexName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"dex\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"deletedexContractAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"dex\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"dexToContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"middleWareToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pathV3\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"internalType\":\"struct IswapData.SwapInputs\",\"name\":\"swapInput\",\"type\":\"tuple\"}],\"name\":\"executeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"middleWareToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pathV3\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"internalType\":\"struct IswapData.SwapInputs\",\"name\":\"swapInput\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"multiHopSwapV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"removeFeeOfDex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"dexName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setDexSymbolContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"feeAmount\",\"type\":\"uint24\"}],\"name\":\"setFeeOfDex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "swapBinanceV1", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}