{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TransitSwapRouterV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/ReentrancyGuard.sol\\\";\\nimport \\\"./libraries/RevertReasonParser.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./libraries/TransitStructs.sol\\\";\\nimport \\\"./libraries/Ownable.sol\\\";\\nimport \\\"./libraries/Pausable.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/ITransitSwapFees.sol\\\";\\n\\ncontract TransitSwapRouterV4 is Ownable, ReentrancyGuard, Pausable {\\n\\n    using SafeMath for uint256;\\n\\n    address private _transit_swap;\\n    address private _transit_cross;\\n    address private _transit_fees;\\n    //default: Pre-trade fee model\\n    mapping(uint8 => bool) private _swap_type_mode;\\n    //whitelist wrapped\\n    mapping(address => bool) private _wrapped_allowed;\\n\\n    event Receipt(address from, uint256 amount);\\n    event Withdraw(address indexed token, address indexed executor, address indexed recipient, uint amount);\\n    event ChangeTransitSwap(address indexed previousTransit, address indexed newTransit);\\n    event ChangeTransitCross(address indexed previousTransit, address indexed newTransit);\\n    event ChangeTransitFees(address indexed previousTransitFees, address indexed newTransitFees);\\n    event ChangeSwapTypeMode(uint8[] types, bool[] newModes);\\n    event ChangeWrappedAllowed(address[] wrappeds, bool[] newAllowed);\\n    event TransitSwapped(address indexed srcToken, address indexed dstToken, address indexed dstReceiver, address trader, bool feeMode, uint256 amount, uint256 returnAmount, uint256 minReturnAmount, uint256 fee, uint256 toChainID, string channel, uint256 time);\\n\\n\\n    constructor(address transitSwap_, address transitCross_, address transitFees_, address executor) Ownable (executor) {\\n        _transit_swap = transitSwap_;\\n        _transit_cross = transitCross_;\\n        _transit_fees = transitFees_;\\n    }\\n\\n    receive() external payable {\\n        emit Receipt(msg.sender, msg.value);\\n    }\\n\\n    function transitSwap() external view returns (address) {\\n        return _transit_swap;\\n    }\\n\\n    function transitCross() external view returns (address) {\\n        return _transit_cross;\\n    }\\n\\n    function transitFees() external view returns (address) {\\n        return _transit_fees;\\n    }\\n\\n    function swapTypeMode(uint8 swapType) external view returns (bool) {\\n        return _swap_type_mode[swapType];\\n    }\\n\\n    function wrappedAllowed(address wrapped) external view returns (bool) {\\n        return _wrapped_allowed[wrapped];\\n    }\\n\\n    function changeTransitSwap(address newTransit) external onlyExecutor {\\n        address oldTransit = _transit_swap;\\n        _transit_swap = newTransit;\\n        emit ChangeTransitSwap(oldTransit, newTransit);\\n    }\\n\\n    function changeTransitCross(address newTransit) external onlyExecutor {\\n        address oldTransit = _transit_cross;\\n        _transit_cross = newTransit;\\n        emit ChangeTransitCross(oldTransit, newTransit);\\n    }\\n\\n    function changeTransitFees(address newTransitFees) external onlyExecutor {\\n        address oldTransitFees = _transit_fees;\\n        _transit_fees = newTransitFees;\\n        emit ChangeTransitFees(oldTransitFees, newTransitFees);\\n    }\\n\\n    function changeSwapTypeMode(uint8[] memory swapTypes) external onlyExecutor {\\n        bool[] memory newModes = new bool[](swapTypes.length);\\n        for (uint index; index < swapTypes.length; index++) {\\n            _swap_type_mode[swapTypes[index]] = !_swap_type_mode[swapTypes[index]];\\n            newModes[index] = _swap_type_mode[swapTypes[index]];\\n        }\\n        emit ChangeSwapTypeMode(swapTypes, newModes);\\n    }\\n\\n    function changeWrappedAllowed(address[] calldata wrappeds) external onlyExecutor {\\n        bool[] memory newAllowed = new bool[](wrappeds.length);\\n        for (uint index; index < wrappeds.length; index++) {\\n            _wrapped_allowed[wrappeds[index]] = !_wrapped_allowed[wrappeds[index]];\\n            newAllowed[index] = _wrapped_allowed[wrappeds[index]];\\n        }\\n        emit ChangeWrappedAllowed(wrappeds, newAllowed);\\n    }\\n\\n    function changePause(bool paused) external onlyExecutor {\\n        if (paused) {\\n            _pause();\\n        } else {\\n            _unpause();\\n        }\\n    }\\n\\n    function _beforeSwap(bool preTradeModel, TransitStructs.TransitSwapDescription calldata desc) private returns (uint256 swapAmount, uint256 fee, uint256 beforeBalance) {\\n        if (preTradeModel) {\\n            fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, desc.amount, desc.swapType, desc.channel);\\n        }\\n        if (TransferHelper.isETH(desc.srcToken)) {\\n            require(msg.value == desc.amount, \\\"TransitSwap: invalid msg.value\\\");\\n            swapAmount = desc.amount.sub(fee);\\n        } else {\\n            if (preTradeModel) {\\n                TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\\n                TransferHelper.safeTransfer(desc.srcToken, desc.srcReceiver, desc.amount.sub(fee));\\n            } else {\\n                TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, desc.srcReceiver, desc.amount);\\n            }\\n        }\\n        if (TransferHelper.isETH(desc.dstToken)) {\\n            if (preTradeModel) {\\n                beforeBalance = desc.dstReceiver.balance;\\n            } else {\\n                if (desc.swapType == uint8(TransitStructs.SwapTypes.swap)) {\\n                    require(_wrapped_allowed[desc.wrappedNative], \\\"TransitSwap: invalid wrapped address\\\");\\n                    beforeBalance = IERC20(desc.wrappedNative).balanceOf(address(this));\\n                } else {\\n                    beforeBalance = address(this).balance;\\n                }\\n            }\\n        } else {\\n            if (preTradeModel) {\\n                beforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\\n            } else {\\n                beforeBalance = IERC20(desc.dstToken).balanceOf(address(this));\\n            }\\n        }\\n    }\\n\\n    function _afterSwap(bool preTradeModel, TransitStructs.TransitSwapDescription calldata desc, uint256 beforeBalance) private returns (uint256 returnAmount, uint256 fee) {\\n        if (TransferHelper.isETH(desc.dstToken)) {\\n            if (preTradeModel) {\\n                returnAmount = desc.dstReceiver.balance.sub(beforeBalance);\\n                require(returnAmount >= desc.minReturnAmount, \\\"TransitSwap: insufficient return amount\\\");\\n            } else {\\n                if (desc.swapType == uint8(TransitStructs.SwapTypes.swap)) {\\n                    returnAmount = IERC20(desc.wrappedNative).balanceOf(address(this)).sub(beforeBalance);\\n                    require(_wrapped_allowed[desc.wrappedNative], \\\"TransitSwap: invalid wrapped address\\\");\\n                    TransferHelper.safeWithdraw(desc.wrappedNative, returnAmount);\\n                } else {\\n                    returnAmount = address(this).balance.sub(beforeBalance);\\n                }\\n                fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, returnAmount, desc.swapType, desc.channel);\\n                returnAmount = returnAmount.sub(fee);\\n                require(returnAmount >= desc.minReturnAmount, \\\"TransitSwap: insufficient return amount\\\");\\n                TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);\\n            }\\n        } else {\\n            if (preTradeModel) {\\n                returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(beforeBalance);\\n                require(returnAmount >= desc.minReturnAmount, \\\"TransitSwap: insufficient return amount\\\");\\n            } else {\\n                returnAmount = IERC20(desc.dstToken).balanceOf(address(this)).sub(beforeBalance);\\n                fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, returnAmount, desc.swapType, desc.channel);\\n                returnAmount = returnAmount.sub(fee);\\n                uint256 receiverBeforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\\n                TransferHelper.safeTransfer(desc.dstToken, desc.dstReceiver, returnAmount);\\n                returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(receiverBeforeBalance);\\n                require(returnAmount >= desc.minReturnAmount, \\\"TransitSwap: insufficient return amount\\\");\\n            }\\n        }        \\n    }\\n\\n    function swap(TransitStructs.TransitSwapDescription calldata desc, TransitStructs.CallbytesDescription calldata callbytesDesc) external payable nonReentrant whenNotPaused {\\n        require(callbytesDesc.calldatas.length > 0, \\\"TransitSwap: data should be not zero\\\");\\n        require(desc.amount > 0, \\\"TransitSwap: amount should be greater than 0\\\");\\n        require(desc.dstReceiver != address(0), \\\"TransitSwap: receiver should be not address(0)\\\");\\n        require(desc.minReturnAmount > 0, \\\"TransitSwap: minReturnAmount should be greater than 0\\\");\\n        if (callbytesDesc.flag == uint8(TransitStructs.Flag.aggregate)) {\\n            require(desc.srcToken == callbytesDesc.srcToken, \\\"TransitSwap: invalid callbytesDesc\\\");\\n        }\\n        bool preTradeModel = !_swap_type_mode[desc.swapType];\\n        (uint256 swapAmount, uint256 fee, uint256 beforeBalance) = _beforeSwap(preTradeModel, desc);\\n\\n        {\\n            //bytes4(keccak256(bytes('callbytes(TransitStructs.CallbytesDescription)')));\\n            (bool success, bytes memory result) = _transit_swap.call{value:swapAmount}(abi.encodeWithSelector(0xccbe4007, callbytesDesc));\\n            if (!success) {\\n                revert(RevertReasonParser.parse(result,\\\"TransitSwap:\\\"));\\n            }\\n        }\\n\\n        (uint256 returnAmount, uint256 postFee) = _afterSwap(preTradeModel, desc, beforeBalance);\\n        if (postFee > fee) {\\n            fee = postFee;\\n        }\\n        _emitTransit(desc, preTradeModel, fee, returnAmount);\\n    }\\n\\n    function _beforeCross(TransitStructs.TransitSwapDescription calldata desc) private returns (uint256 swapAmount, uint256 fee, uint256 beforeBalance) {\\n        fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, desc.amount, desc.swapType, desc.channel);\\n        if (TransferHelper.isETH(desc.srcToken)) {\\n            require(msg.value == desc.amount, \\\"TransitSwap: invalid msg.value\\\");\\n            swapAmount = desc.amount.sub(fee);\\n        } else {\\n            beforeBalance = IERC20(desc.srcToken).balanceOf(_transit_cross);\\n            if (fee == 0) {\\n                TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, _transit_cross, desc.amount);\\n            } else {\\n                TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\\n                TransferHelper.safeTransfer(desc.srcToken, _transit_cross, desc.amount.sub(fee));\\n            }\\n        }\\n    }\\n\\n    function cross(TransitStructs.TransitSwapDescription calldata desc, TransitStructs.CallbytesDescription calldata callbytesDesc) external payable nonReentrant whenNotPaused {\\n        require(callbytesDesc.calldatas.length > 0, \\\"TransitSwap: data should be not zero\\\");\\n        require(desc.amount > 0, \\\"TransitSwap: amount should be greater than 0\\\");\\n        require(desc.srcToken == callbytesDesc.srcToken, \\\"TransitSwap: invalid callbytesDesc\\\");\\n        (uint256 swapAmount, uint256 fee, uint256 beforeBalance) = _beforeCross(desc);\\n        \\n        {\\n            //bytes4(keccak256(bytes('callbytes(TransitStructs.CallbytesDescription)')));\\n            (bool success, bytes memory result) = _transit_cross.call{value:swapAmount}(abi.encodeWithSelector(0xccbe4007, callbytesDesc));\\n            if (!success) {\\n                revert(RevertReasonParser.parse(result,\\\"TransitSwap:\\\"));\\n            }\\n        }\\n        \\n        if (!TransferHelper.isETH(desc.srcToken)) {\\n            require(IERC20(desc.srcToken).balanceOf(_transit_cross) >= beforeBalance, \\\"TransitSwap: invalid cross\\\");\\n        }\\n\\n        _emitTransit(desc, true, fee, 0);\\n    }\\n\\n    function _emitTransit(TransitStructs.TransitSwapDescription calldata desc, bool preTradeModel, uint256 fee, uint256 returnAmount) private {\\n        emit TransitSwapped(\\n            desc.srcToken, \\n            desc.dstToken, \\n            desc.dstReceiver, \\n            msg.sender, \\n            preTradeModel, \\n            desc.amount, \\n            returnAmount, \\n            desc.minReturnAmount, \\n            fee, \\n            desc.toChainID, \\n            desc.channel,\\n            block.timestamp\\n        );\\n    }\\n\\n    function withdrawTokens(address[] memory tokens, address recipient) external onlyExecutor {\\n        for(uint index; index < tokens.length; index++) {\\n            uint amount;\\n            if(TransferHelper.isETH(tokens[index])) {\\n                amount = address(this).balance;\\n                TransferHelper.safeTransferETH(recipient, amount);\\n            } else {\\n                amount = IERC20(tokens[index]).balanceOf(address(this));\\n                TransferHelper.safeTransferWithoutRequire(tokens[index], recipient, amount);\\n            }\\n            emit Withdraw(tokens[index], msg.sender, recipient, amount);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITransitSwapFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.9;\\n\\ninterface ITransitSwapFees {\\n    \\n    function getFeeRate(address trader, uint256 tradeAmount, uint8 swapType, string memory channel) external  view returns (uint payFees);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.9;\\n\\ninterface IERC20 {\\n    \\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n \\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n    \\n    function div(uint x, uint y) internal pure returns (uint z) {\\n        require(y != 0 , 'ds-math-div-zero');\\n        z = x / y;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n// Add executor extension\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n    address private _pendingOwner;\\n    address private _executor;\\n    address private _pendingExecutor;\\n    bool internal _initialized;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event ExecutorshipTransferStarted(address indexed previousExecutor, address indexed newExecutor);\\n    event ExecutorshipTransferred(address indexed previousExecutor, address indexed newExecutor);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor(address newExecutor) {\\n        require(!_initialized, \\\"Ownable: initialized\\\");\\n        _transferOwnership(msg.sender);\\n        _transferExecutorship(newExecutor);\\n        _initialized = true;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the executor.\\n     */\\n    modifier onlyExecutor() {\\n        _checkExecutor();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current executor.\\n     */\\n    function executor() public view virtual returns (address) {\\n        return _executor;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the pending executor.\\n     */\\n    function pendingExecutor() public view virtual returns (address) {\\n        return _pendingExecutor;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the executor.\\n     */\\n    function _checkExecutor() internal view virtual {\\n        require(executor() == msg.sender, \\\"Ownable: caller is not the executor\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers executorship of the contract to a new account (`newExecutor`).\\n     * Can only be called by the current executor.\\n     */\\n    function transferExecutorship(address newExecutor) public virtual onlyExecutor {\\n        _pendingExecutor = newExecutor;\\n        emit ExecutorshipTransferStarted(executor(), newExecutor);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        delete _pendingOwner;\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    function _transferExecutorship(address newExecutor) internal virtual {\\n        delete _pendingExecutor;\\n        address oldExecutor = _executor;\\n        _executor = newExecutor;\\n        emit ExecutorshipTransferred(oldExecutor, newExecutor);\\n    }\\n\\n    function acceptOwnership() external {\\n        address sender = msg.sender;\\n        require(pendingOwner() == sender, \\\"Ownable: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    function acceptExecutorship() external {\\n        address sender = msg.sender;\\n        require(pendingExecutor() == sender, \\\"Ownable: caller is not the new executor\\\");\\n        _transferExecutorship(sender);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/TransitStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary TransitStructs {\\n\\n    enum SwapTypes {aggregatePreMode, aggregatePostMode, swap, cross}\\n    enum Flag {aggregate, swap, cross}\\n\\n    struct TransitSwapDescription {\\n        uint8 swapType;\\n        address srcToken;\\n        address dstToken;\\n        address srcReceiver;\\n        address dstReceiver;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        string channel;\\n        uint256 toChainID;\\n        address wrappedNative;\\n    }\\n\\n    struct CallbytesDescription {\\n        uint8 flag;\\n        address srcToken;\\n        bytes calldatas;\\n    }\\n\\n    struct AggregateDescription {\\n        address dstToken;\\n        address receiver;\\n        uint[] amounts;\\n        uint[] needTransfer;\\n        address[] callers;\\n        address[] approveProxy;\\n        bytes[] calls;\\n    }\\n\\n    struct SwapDescription {\\n        address[][] paths;\\n        address[][] pairs;\\n        uint[] fees;\\n        address receiver;\\n        uint deadline;\\n    }\\n\\n    struct CrossDescription {\\n        address caller;\\n        uint256 amount;\\n        bool needWrapped;\\n        bytes calls;\\n    }\\n\\n    function decodeAggregateDesc(bytes calldata calldatas) internal pure returns (AggregateDescription memory desc) {\\n        desc = abi.decode(calldatas, (AggregateDescription));\\n    }\\n\\n    function decodeSwapDesc(bytes calldata calldatas) internal pure returns (SwapDescription memory desc) {\\n        desc = abi.decode(calldatas, (SwapDescription));\\n    }\\n\\n    function decodeCrossDesc(bytes calldata calldatas) internal pure returns (CrossDescription memory desc) {\\n        desc = abi.decode(calldatas, (CrossDescription));\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nlibrary TransferHelper {\\n    \\n    address private constant _ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n    address private constant _ZERO_ADDRESS = address(0);\\n    \\n    function isETH(address token) internal pure returns (bool) {\\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\\n    }\\n    \\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_TOKEN_FAILED');\\n    }\\n    \\n    function safeTransferWithoutRequire(address token, address to, uint256 value) internal returns (bool) {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        // solium-disable-next-line\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeDeposit(address wrapped, uint value) internal {\\n        // bytes4(keccak256(bytes('deposit()')));\\n        (bool success, bytes memory data) = wrapped.call{value:value}(abi.encodeWithSelector(0xd0e30db0));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: DEPOSIT_FAILED');\\n    }\\n\\n    function safeWithdraw(address wrapped, uint value) internal {\\n        // bytes4(keccak256(bytes('withdraw(uint256 wad)')));\\n        (bool success, bytes memory data) = wrapped.call{value:0}(abi.encodeWithSelector(0x2e1a7d4d, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: WITHDRAW_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/RevertReasonParser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nlibrary RevertReasonParser {\\n        function parse(bytes memory data, string memory prefix) internal pure returns (string memory) {\\n        // https://solidity.readthedocs.io/en/latest/control-structures.html#revert\\n        // We assume that revert reason is abi-encoded as Error(string)\\n\\n        // 68 = 4-byte selector 0x08c379a0 + 32 bytes offset + 32 bytes length\\n        if (data.length >= 68 && data[0] == \\\"\\\\x08\\\" && data[1] == \\\"\\\\xc3\\\" && data[2] == \\\"\\\\x79\\\" && data[3] == \\\"\\\\xa0\\\") {\\n            string memory reason;\\n            // solhint-disable no-inline-assembly\\n            assembly {\\n                // 68 = 32 bytes data length + 4-byte selector + 32 bytes offset\\n                reason := add(data, 68)\\n            }\\n            /*\\n                revert reason is padded up to 32 bytes with ABI encoder: Error(string)\\n                also sometimes there is extra 32 bytes of zeros padded in the end:\\n                https://github.com/ethereum/solidity/issues/10170\\n                because of that we can't check for equality and instead check\\n                that string length + extra 68 bytes is less than overall data length\\n            */\\n            require(data.length >= 68 + bytes(reason).length, \\\"Invalid revert reason\\\");\\n            return string(abi.encodePacked(prefix, \\\"Error(\\\", reason, \\\")\\\"));\\n        }\\n        // 36 = 4-byte selector 0x4e487b71 + 32 bytes integer\\n        else if (data.length == 36 && data[0] == \\\"\\\\x4e\\\" && data[1] == \\\"\\\\x48\\\" && data[2] == \\\"\\\\x7b\\\" && data[3] == \\\"\\\\x71\\\") {\\n            uint256 code;\\n            // solhint-disable no-inline-assembly\\n            assembly {\\n                // 36 = 32 bytes data length + 4-byte selector\\n                code := mload(add(data, 36))\\n            }\\n            return string(abi.encodePacked(prefix, \\\"Panic(\\\", _toHex(code), \\\")\\\"));\\n        }\\n\\n        return string(abi.encodePacked(prefix, \\\"Unknown(\\\", _toHex(data), \\\")\\\"));\\n    }\\n    \\n    function _toHex(uint256 value) private pure returns(string memory) {\\n        return _toHex(abi.encodePacked(value));\\n    }\\n\\n    function _toHex(bytes memory data) private pure returns(string memory) {\\n        bytes16 alphabet = 0x30313233343536373839616263646566;\\n        bytes memory str = new bytes(2 + data.length * 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < data.length; i++) {\\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\\n        }\\n        return string(str);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transitSwap_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"transitCross_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"transitFees_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"newModes\",\"type\":\"bool[]\"}],\"name\":\"ChangeSwapTypeMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTransit\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTransit\",\"type\":\"address\"}],\"name\":\"ChangeTransitCross\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTransitFees\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTransitFees\",\"type\":\"address\"}],\"name\":\"ChangeTransitFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTransit\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTransit\",\"type\":\"address\"}],\"name\":\"ChangeTransitSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"wrappeds\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"newAllowed\",\"type\":\"bool[]\"}],\"name\":\"ChangeWrappedAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"ExecutorshipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"ExecutorshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Receipt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"feeMode\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChainID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TransitSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptExecutorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"changePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"swapTypes\",\"type\":\"uint8[]\"}],\"name\":\"changeSwapTypeMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTransit\",\"type\":\"address\"}],\"name\":\"changeTransitCross\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTransitFees\",\"type\":\"address\"}],\"name\":\"changeTransitFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTransit\",\"type\":\"address\"}],\"name\":\"changeTransitSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wrappeds\",\"type\":\"address[]\"}],\"name\":\"changeWrappedAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"toChainID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wrappedNative\",\"type\":\"address\"}],\"internalType\":\"struct TransitStructs.TransitSwapDescription\",\"name\":\"desc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldatas\",\"type\":\"bytes\"}],\"internalType\":\"struct TransitStructs.CallbytesDescription\",\"name\":\"callbytesDesc\",\"type\":\"tuple\"}],\"name\":\"cross\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"toChainID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wrappedNative\",\"type\":\"address\"}],\"internalType\":\"struct TransitStructs.TransitSwapDescription\",\"name\":\"desc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldatas\",\"type\":\"bytes\"}],\"internalType\":\"struct TransitStructs.CallbytesDescription\",\"name\":\"callbytesDesc\",\"type\":\"tuple\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"swapType\",\"type\":\"uint8\"}],\"name\":\"swapTypeMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"transferExecutorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transitCross\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transitFees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transitSwap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wrapped\",\"type\":\"address\"}],\"name\":\"wrappedAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TransitSwapRouterV4", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000661d4d4785c302a56d7cb8a92f130d319bc25e4a000000000000000000000000172b409987b7a9648df4606490c1726dc2cd174c0000000000000000000000001f6e41c47349634fe261403a18f8515546f58826000000000000000000000000280333c41a9302448ebc070ed0300ad2ed4b8244", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}