{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"DddLpStaker.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IDddToken.sol\\\";\\n\\n\\ncontract DddLpStaker is Ownable {\\n\\n    struct Deposit {\\n        uint256 timestamp;\\n        uint256 amount;\\n    }\\n\\n    struct UserBalance {\\n        uint256 total;\\n        uint256 depositIndex;\\n        Deposit[] deposits;\\n    }\\n\\n    uint256 public periodFinish;\\n    uint256 public rewardRate;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n\\n    uint256 constant WEEK = 604800;\\n    uint256 public constant rewardsDuration = WEEK;\\n\\n    uint256 public totalSupply;\\n\\n    // this contract has no concept of weekly periods\\n    uint256 public startTime;\\n\\n    // amount of DDD minted as initial incentives\\n    uint256 public immutable INITIAL_DDD_MINT_AMOUNT;\\n    // seconds between the first deposit and minting the initial DDD incentives\\n    uint256 public immutable INITIAL_DEPOSIT_GRACE_PERIOD;\\n\\n    bool public initialMintCompleted;\\n\\n    IERC20 public stakingToken;\\n    IDddToken public rewardToken;\\n    address public lpDepositor;\\n    address public treasury;\\n\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    mapping(address => uint256) public rewards;\\n    mapping (address => UserBalance) userBalances;\\n\\n    event FeeAdded(uint256 reward);\\n    event Deposited(address indexed caller, address indexed receiver, uint256 stakeAmount, uint256 feeAmount);\\n    event Withdrawn(address indexed user, address indexed receiver, uint256 withdrawAmount, uint256 feeAmount);\\n    event FeeClaimed(address indexed user, address indexed receiver, uint256 reward);\\n\\n    constructor(uint256 _initialAmount, uint256 _gracePeriod) {\\n        INITIAL_DDD_MINT_AMOUNT = _initialAmount;\\n        INITIAL_DEPOSIT_GRACE_PERIOD = _gracePeriod;\\n    }\\n\\n    function setAddresses(\\n        IERC20 _stakingToken,\\n        IDddToken _rewardToken,\\n        address _lpDepositor,\\n        address _treasury\\n    ) external onlyOwner {\\n        lpDepositor = _lpDepositor;\\n        stakingToken = _stakingToken;\\n        rewardToken = _rewardToken;\\n        treasury = _treasury;\\n\\n        renounceOwnership();\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return userBalances[account].total;\\n    }\\n\\n    function userDeposits(address account) external view returns (Deposit[] memory deposits) {\\n        UserBalance storage user = userBalances[account];\\n        deposits = new Deposit[](user.deposits.length - user.depositIndex);\\n\\n        for (uint256 i = 0; i < deposits.length; i++) {\\n            deposits[i] = user.deposits[user.depositIndex + i];\\n        }\\n        return deposits;\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (totalSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        uint256 duration = lastTimeRewardApplicable() - lastUpdateTime;\\n        return rewardPerTokenStored + duration * rewardRate * 1e18 / totalSupply;\\n    }\\n\\n    function claimable(address account) public view returns (uint256) {\\n        uint256 delta = rewardPerToken() - userRewardPerTokenPaid[account];\\n        return userBalances[account].total * delta / 1e18 + rewards[account];\\n    }\\n\\n    function getRewardForDuration() external view returns (uint256) {\\n        return rewardRate * rewardsDuration;\\n    }\\n\\n    /**\\n        @notice The current deposit fee percent as an integer out of 10000\\n        @dev The deposit fee is fixed, starting at 2% and reducing by 0.25%\\n             every 8 weeks until reaching 0\\n     */\\n    function depositFee() public view returns (uint256) {\\n        uint256 start = startTime;\\n        if (start == 0) return 200;\\n        uint256 timeSinceStart = block.timestamp - start;\\n        if (timeSinceStart >= WEEK * 8 * 8) return 0;\\n        return 200 - (timeSinceStart / (WEEK * 8) * 25);\\n    }\\n\\n    /**\\n        @notice Fee amount paid when depositing `amount` based on the current deposit fee\\n     */\\n    function depositFeeOnAmount(uint256 amount) public view returns (uint256) {\\n        uint256 fee = depositFee();\\n        return amount * fee / 10000;\\n    }\\n\\n    /**\\n        @notice Fee amount paid for `account` to deposit `amount`\\n        @dev The withdrawal fee is variable, starting at 8% and reducing by 1% each week\\n             that the funds have been deposited. Withdrawals are always made starting from\\n             the oldest deposit, in order to minimize the fee paid.\\n     */\\n    function withdrawFeeOnAmount(address account, uint256 amount) external view returns (uint256 feeAmount) {\\n        UserBalance storage user = userBalances[account];\\n        require(user.total >= amount, \\\"Amount exceeds user deposit\\\");\\n\\n        uint256 remaining = amount;\\n        uint256 timestamp = block.timestamp / 86400 * 86400;\\n        for (uint256 i = user.depositIndex; ; i++) {\\n            Deposit storage dep = user.deposits[i];\\n            uint256 weeklyAmount = dep.amount;\\n            if (weeklyAmount > remaining) {\\n                weeklyAmount = remaining;\\n            }\\n            uint256 weeksSinceDeposit = (timestamp - dep.timestamp) / 604800;\\n            if (weeksSinceDeposit < 8) {\\n                // for balances deposited less than 8 weeks ago, a withdrawal\\n                // fee is applied starting at 8% and decreasing by 1% every week\\n                uint feeMultiplier = 8 - weeksSinceDeposit;\\n                feeAmount += weeklyAmount * feeMultiplier / 100;\\n            }\\n            remaining -= weeklyAmount;\\n            if (remaining == 0) {\\n                return feeAmount;\\n            }\\n        }\\n        revert();\\n    }\\n\\n    /**\\n        @notice Deposit LP tokens\\n        @dev `amount` is the total amount to transfer from the caller, inclusive of\\n             the deposit fee. the final deposited balance may be up to 2% less than\\n             the given amount.\\n        @param receiver Address to credit for the deposit\\n        @param amount Amount to deposit (inclusive of fee)\\n        @param claim If true, also claims any pending rewards. Cannot be true when\\n                     the caller is not the receiver.\\n     */\\n    function deposit(address receiver, uint256 amount, bool claim) external {\\n        if (claim) require (msg.sender == receiver, \\\"Cannot trigger claim for another user\\\");\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\n\\n        if (!initialMintCompleted) {\\n            uint256 start = startTime;\\n            if (start == 0) {\\n                // the first deposit sets the start time\\n                startTime = block.timestamp;\\n            } else if (block.timestamp - INITIAL_DEPOSIT_GRACE_PERIOD > start) {\\n                // first deposit after grace period triggers the initial incentive mint\\n                initialMintCompleted = true;\\n                rewardToken.mint(address(this), INITIAL_DDD_MINT_AMOUNT);\\n                _notifyFeeAmount(INITIAL_DDD_MINT_AMOUNT);\\n            }\\n        }\\n\\n        _updateReward(receiver, receiver, claim);\\n        stakingToken.transferFrom(msg.sender, address(this), amount);\\n\\n        // apply deposit fee, if any\\n        uint256 feeAmount = depositFeeOnAmount(amount);\\n        if (feeAmount > 0) {\\n            stakingToken.transfer(treasury, feeAmount);\\n            amount -= feeAmount;\\n        }\\n\\n        totalSupply += amount;\\n        UserBalance storage user = userBalances[receiver];\\n        user.total += amount;\\n        uint256 timestamp = block.timestamp / 86400 * 86400;\\n        uint256 length = user.deposits.length;\\n        if (length == 0 || user.deposits[length-1].timestamp < timestamp) {\\n            user.deposits.push(Deposit({timestamp: timestamp, amount: amount}));\\n        } else {\\n            user.deposits[length-1].amount += amount;\\n        }\\n        emit Deposited(msg.sender, receiver, amount, feeAmount);\\n    }\\n\\n    /**\\n        @notice Withdraw LP tokens\\n        @dev `amount` is the total amount to deduct from the caller's balance,\\n             inclusive of the withdrawal fee. the final received amount may be\\n             up to 8% less than the given amount.\\n        @param receiver Address to send the withdrawn tokens to\\n        @param amount Amount to withdraw (inclusive of fee)\\n        @param claim If true, also claims any pending rewards\\n     */\\n    function withdraw(address receiver, uint256 amount, bool claim) public {\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        _updateReward(msg.sender, receiver, claim);\\n        totalSupply -= amount;\\n\\n        UserBalance storage user = userBalances[msg.sender];\\n        user.total -= amount;\\n\\n        uint256 amountAfterFee = 0;\\n        uint256 remaining = amount;\\n        uint256 timestamp = block.timestamp / 86400 * 86400;\\n        for (uint256 i = user.depositIndex; ; i++) {\\n            Deposit storage dep = user.deposits[i];\\n            uint256 weeklyAmount = dep.amount;\\n            if (weeklyAmount > remaining) {\\n                weeklyAmount = remaining;\\n            }\\n            uint256 weeksSinceDeposit = (timestamp - dep.timestamp) / 604800;\\n            if (weeksSinceDeposit < 8) {\\n                // for balances deposited less than 8 weeks ago, a withdrawal\\n                // fee is applied starting at 8% and decreasing by 1% every week\\n                uint feeMultiplier = 100 - (8 - weeksSinceDeposit);\\n                amountAfterFee += weeklyAmount * feeMultiplier / 100;\\n            } else {\\n                amountAfterFee += weeklyAmount;\\n            }\\n            remaining -= weeklyAmount;\\n            dep.amount -= weeklyAmount;\\n            if (remaining == 0) {\\n                user.depositIndex = i;\\n                break;\\n            }\\n        }\\n\\n        stakingToken.transfer(receiver, amountAfterFee);\\n        uint256 feeAmount = amount - amountAfterFee;\\n        if (feeAmount > 0) {\\n            stakingToken.transfer(treasury, feeAmount);\\n        }\\n        emit Withdrawn(msg.sender, receiver, amount, feeAmount);\\n    }\\n\\n    /**\\n        @notice Claim pending rewards for the caller\\n        @param receiver Address to transfer claimed rewards to\\n     */\\n    function claim(address receiver) external {\\n        _updateReward(msg.sender, receiver, true);\\n    }\\n\\n    /**\\n        @notice Claim pending rewards and withdraw all tokens\\n        @param receiver Address to transfer LP tokens and rewards to\\n     */\\n    function exit(address receiver) external {\\n        withdraw(receiver, userBalances[msg.sender].total, true);\\n    }\\n\\n    function notifyFeeAmount(uint256 amount) external returns (bool) {\\n        require(msg.sender == lpDepositor);\\n        _notifyFeeAmount(amount);\\n        return true;\\n    }\\n\\n    function _notifyFeeAmount(uint256 amount) internal {\\n        rewardPerTokenStored = rewardPerToken();\\n\\n        if (block.timestamp >= periodFinish) {\\n            rewardRate = amount / rewardsDuration;\\n        } else {\\n            uint256 remaining = periodFinish - block.timestamp;\\n            uint256 leftover = remaining * rewardRate;\\n            rewardRate = (amount + leftover) / rewardsDuration;\\n        }\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp + rewardsDuration;\\n        emit FeeAdded(amount);\\n    }\\n\\n    function _updateReward(address account, address receiver, bool claim) internal {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n\\n        uint256 pending = claimable(account);\\n        if (pending > 0) {\\n            if (claim) {\\n                rewardToken.transfer(receiver, pending);\\n                emit FeeClaimed(account, receiver, pending);\\n                pending = 0;\\n            }\\n            rewards[account] = pending;\\n        }\\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n    }\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.12;\\n\\n/**\\n * Based on the OpenZeppelin IER20 interface:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"IDddToken.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"IERC20.sol\\\";\\n\\ninterface IDddToken is IERC20 {\\n    function mint(address _to, uint256 _value) external returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"DddLpStaker.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gracePeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"FeeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"FeeClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_DDD_MINT_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_DEPOSIT_GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claim\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositFeeOnAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardForDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialMintCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpDepositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyFeeAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IDddToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"contract IDddToken\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpDepositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DddLpStaker.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claim\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFeeOnAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DddLpStaker", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000002116545850052128000000000000000000000000000000000000000000000000000000000000000005460", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}