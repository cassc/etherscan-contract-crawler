{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface INFT {\r\n    function addTokenReward(uint256 rewardAmount) external;\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n}\r\n\r\ninterface ISwapFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface ISwapPair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface IToken {\r\n    function giveMintReward() external;\r\n\r\n    function addUserLPAmount(address account, uint256 lpAmount) external;\r\n}\r\n\r\nabstract contract AbsLPPool is Ownable {\r\n    struct UserInfo {\r\n        bool isActive;\r\n        uint256 amount;\r\n        uint256 rewardMintDebt;\r\n        uint256 calMintReward;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        uint256 totalAmount;\r\n        uint256 accMintPerShare;\r\n        uint256 accMintReward;\r\n        uint256 mintPerSec;\r\n        uint256 lastMintTime;\r\n        uint256 totalMintReward;\r\n    }\r\n\r\n    struct UserLPInfo {\r\n        uint256 lockAmount;\r\n        uint256 calAmount;\r\n        uint256 claimedAmount;\r\n        uint256 lastReleaseTime;\r\n        //\r\n        uint256 releaseInitAmount;\r\n        //\r\n        uint256 releaseDuration;\r\n        uint256 speedUpTime;\r\n    }\r\n\r\n    PoolInfo private poolInfo;\r\n    mapping(address => UserInfo) private userInfo;\r\n    mapping(address => UserLPInfo) private _userLPInfo;\r\n\r\n    ISwapRouter private immutable _swapRouter;\r\n    address private immutable _usdt;\r\n    uint256 private _minAmount;\r\n    address private immutable _mintRewardToken;\r\n    address public immutable _lp;\r\n    INFT public _nft;\r\n\r\n    mapping(address => address) public _invitor;\r\n    mapping(address => address[]) public _binder;\r\n    mapping(uint256 => uint256) public _inviteFee;\r\n    uint256 private constant _inviteLen = 5;\r\n    address private _defaultInvitor;\r\n\r\n    mapping(address => uint256) private _inviteAmount;\r\n    mapping(address => uint256) private _teamAmount;\r\n    mapping(address => uint256) private _teamNum;\r\n\r\n    bool public _pauseSell;\r\n    uint256 public _sellSelfRate = 5000;\r\n    uint256 public _sellJoinRate = 4000;\r\n    uint256 public _sellNFTRate = 500;\r\n    address public _sellLPReceiver;\r\n    mapping(address => uint256) private _sellJoinAmount;\r\n    address public _fundAddress;\r\n\r\n    function setPauseSell(bool p) external onlyWhiteList {\r\n        _pauseSell = p;\r\n    }\r\n\r\n    function setSellSelfRate(uint256 r) external onlyWhiteList {\r\n        _sellSelfRate = r;\r\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"T1w\");\r\n    }\r\n\r\n    function setSellJoinRate(uint256 r) external onlyWhiteList {\r\n        _sellJoinRate = r;\r\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"T1w\");\r\n    }\r\n\r\n    function setSellNFTRate(uint256 r) external onlyWhiteList {\r\n        _sellNFTRate = r;\r\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"T1w\");\r\n    }\r\n\r\n    function setSellLPReceiver(address a) external onlyWhiteList {\r\n        _sellLPReceiver = a;\r\n    }\r\n\r\n    function setFundAddress(address a) external onlyWhiteList {\r\n        _fundAddress = a;\r\n    }\r\n\r\n    //\r\n    function sell(uint256 tokenAmount) public {\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n\r\n        _bindInvitor(account, _defaultInvitor);\r\n\r\n        require(!_pauseSell, \"PS\");\r\n        _takeToken(_mintRewardToken, account, address(this), tokenAmount);\r\n\r\n        address usdt = _usdt;\r\n        IERC20 USDT = IERC20(usdt);\r\n        uint256 usdtBalanceBefore = USDT.balanceOf(address(this));\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = _mintRewardToken;\r\n        path[1] = usdt;\r\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount, 0, path, address(this), block.timestamp\r\n        );\r\n\r\n        uint256 usdtAmount = USDT.balanceOf(address(this)) - usdtBalanceBefore;\r\n        uint256 selfUsdt = usdtAmount * _sellSelfRate / 10000;\r\n        _giveToken(usdt, account, selfUsdt);\r\n\r\n        uint256 sellJoinUsdt = usdtAmount * _sellJoinRate / 10000;\r\n        addLP(account, sellJoinUsdt, 0, false);\r\n\r\n        _updatePool();\r\n        uint256 sellJoinAmount = sellJoinUsdt * _lastAmountRate / _divFactor;\r\n        _addUserAmount(account, sellJoinAmount, false);\r\n        _sellJoinAmount[account] += sellJoinAmount;\r\n\r\n        uint256 nftUsdt = usdtAmount * _sellNFTRate / 10000;\r\n        _giveToken(usdt, address(_nft), nftUsdt);\r\n        _nft.addTokenReward(nftUsdt);\r\n\r\n        uint256 fundUsdt = usdtAmount - selfUsdt - sellJoinUsdt - nftUsdt;\r\n        _giveToken(usdt, _fundAddress, fundUsdt);\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    bool private _pauseJoin = true;\r\n    uint256 public _lastDailyUpTime;\r\n    uint256 public _lastAmountRate = 10000;\r\n    uint256 public _amountDailyUp = 10100;\r\n    uint256 private constant _divFactor = 10000;\r\n    uint256 private constant _dailyDuration = 1 days;\r\n\r\n    uint256 public _lpReleaseDuration = 183 days;\r\n    //\r\n    uint256 private _speedUpCost;\r\n    uint256 public _speedUpDuration = 30 days;\r\n    address public _speedUpReceiver = address(0x000000000000000000000000000000000000dEaD);\r\n    uint256 private _speedUpMaxTime = 3;\r\n\r\n    function setSpeedUpMaxTime(uint256 mt) external onlyWhiteList {\r\n        _speedUpMaxTime = mt;\r\n    }\r\n\r\n    function setSpeedUpCost(uint256 c) external onlyWhiteList {\r\n        _speedUpCost = c;\r\n    }\r\n\r\n    function setSpeedUpDuration(uint256 d) external onlyWhiteList {\r\n        _speedUpDuration = d;\r\n    }\r\n\r\n    function setSeedUpReceiver(address a) external onlyWhiteList {\r\n        _speedUpReceiver = a;\r\n    }\r\n\r\n    function setLPReleaseDuration(uint256 d) external onlyWhiteList {\r\n        require(d > 0, \"gt0\");\r\n        _lpReleaseDuration = d;\r\n    }\r\n\r\n    function setAmountDailyUp(uint256 r) external onlyWhiteList {\r\n        _amountDailyUp = r;\r\n    }\r\n\r\n    function setLastDailyUpTime(uint256 t) external onlyWhiteList {\r\n        _lastDailyUpTime = t;\r\n    }\r\n\r\n    function setLastAmountRate(uint256 r) external onlyWhiteList {\r\n        _lastAmountRate = r;\r\n    }\r\n\r\n    function _updateDailyUpRate() public {\r\n        uint256 lastDailyUpTime = _lastDailyUpTime;\r\n        if (0 == lastDailyUpTime) {\r\n            return;\r\n        }\r\n        uint256 dailyDuration = _dailyDuration;\r\n        uint256 nowTime = block.timestamp;\r\n        if (nowTime < lastDailyUpTime + dailyDuration) {\r\n            return;\r\n        }\r\n        uint256 ds = (nowTime - lastDailyUpTime) / dailyDuration;\r\n        _lastDailyUpTime = lastDailyUpTime + ds * dailyDuration;\r\n\r\n        uint256 lastAmountRate = _lastAmountRate;\r\n        uint256 amountDailyUp = _amountDailyUp;\r\n        for (uint256 i; i < ds; ++i) {\r\n            lastAmountRate = lastAmountRate * amountDailyUp / _divFactor;\r\n        }\r\n        _lastAmountRate = lastAmountRate;\r\n    }\r\n\r\n    function getDailyRate() private view returns (uint256) {\r\n        uint256 lastAmountRate = _lastAmountRate;\r\n        uint256 lastDailyUpTime = _lastDailyUpTime;\r\n        if (0 == lastDailyUpTime) {\r\n            return lastAmountRate;\r\n        }\r\n        uint256 dailyDuration = _dailyDuration;\r\n        uint256 nowTime = block.timestamp;\r\n        if (nowTime < lastDailyUpTime + dailyDuration) {\r\n            return lastAmountRate;\r\n        }\r\n        uint256 ds = (nowTime - lastDailyUpTime) / dailyDuration;\r\n\r\n        uint256 amountDailyUp = _amountDailyUp;\r\n        for (uint256 i; i < ds; ++i) {\r\n            lastAmountRate = lastAmountRate * amountDailyUp / _divFactor;\r\n        }\r\n        return lastAmountRate;\r\n    }\r\n\r\n    function open() external onlyWhiteList {\r\n        if (0 == _lastDailyUpTime) {\r\n            _lastDailyUpTime = block.timestamp;\r\n        }\r\n        _pauseJoin = false;\r\n    }\r\n\r\n    function close() external onlyWhiteList {\r\n        _pauseJoin = true;\r\n    }\r\n\r\n    constructor(\r\n        address SwapRouter,\r\n        address USDT,\r\n        address MintRewardToken,\r\n        address NFT,\r\n        address DefaultInvitor,\r\n        address FundAddress\r\n    ){\r\n        _swapRouter = ISwapRouter(SwapRouter);\r\n        _usdt = USDT;\r\n        _minAmount = 100 * 10 ** IERC20(USDT).decimals();\r\n        _nft = INFT(NFT);\r\n        _mintRewardToken = MintRewardToken;\r\n        _lp = ISwapFactory(_swapRouter.factory()).getPair(USDT, MintRewardToken);\r\n        poolInfo.lastMintTime = block.timestamp;\r\n        _defaultInvitor = DefaultInvitor;\r\n        userInfo[DefaultInvitor].isActive = true;\r\n        _inviteFee[0] = 1000;\r\n        _inviteFee[1] = 800;\r\n        _inviteFee[2] = 600;\r\n        _inviteFee[3] = 500;\r\n        _inviteFee[4] = 400;\r\n        _speedUpCost = 300 * 10 ** IERC20(_usdt).decimals();\r\n\r\n        safeApprove(USDT, SwapRouter, ~uint256(0));\r\n        safeApprove(MintRewardToken, SwapRouter, ~uint256(0));\r\n\r\n        _sellLPReceiver = FundAddress;\r\n        _fundAddress = FundAddress;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    uint256 private _totalUsdt;\r\n\r\n    //\r\n    function deposit(uint256 amount, uint256 minTokenAmount, address invitor) external {\r\n        require(!_pauseJoin, \"pause\");\r\n\r\n        require(amount >= _minAmount, \"m\");\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n\r\n        _totalUsdt += amount;\r\n\r\n        _bindInvitor(account, invitor);\r\n\r\n        _takeToken(_usdt, account, address(this), amount);\r\n\r\n        addLP(account, amount, minTokenAmount, true);\r\n\r\n        _updatePool();\r\n        _addUserAmount(account, amount * _lastAmountRate / _divFactor, true);\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    //\r\n    function addLP(address account, uint256 usdtAmount, uint256 minTokenAmount, bool lockLP) private {\r\n        address token = _mintRewardToken;\r\n        IERC20 Token = IERC20(token);\r\n        uint256 tokenBalanceBefore = Token.balanceOf(address(this));\r\n\r\n        address usdt = _usdt;\r\n        address[] memory path = new address[](2);\r\n        path[0] = usdt;\r\n        path[1] = token;\r\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            usdtAmount / 2, minTokenAmount, path, address(this), block.timestamp\r\n        );\r\n\r\n        uint256 tokenAmount = Token.balanceOf(address(this)) - tokenBalanceBefore;\r\n\r\n        address lpReceiver = lockLP ? address(this) : _sellLPReceiver;\r\n        (, , uint liquidity) = _swapRouter.addLiquidity(\r\n            usdt, token,\r\n            usdtAmount / 2, tokenAmount,\r\n            0, 0,\r\n            lpReceiver, block.timestamp\r\n        );\r\n        //\r\n        if (lockLP) {\r\n            _addLockLP(account, liquidity);\r\n        } else {\r\n            IToken(_mintRewardToken).addUserLPAmount(lpReceiver, liquidity);\r\n        }\r\n    }\r\n\r\n    //\r\n    function _addLockLP(address account, uint liquidity) private {\r\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\r\n        uint256 lastReleaseTime = userLPInfo.lastReleaseTime;\r\n        uint256 nowTime = block.timestamp;\r\n        if (lastReleaseTime > 0 && nowTime > lastReleaseTime) {\r\n            uint256 releaseAmount = userLPInfo.releaseInitAmount * (nowTime - lastReleaseTime) / userLPInfo.releaseDuration;\r\n            uint256 maxAmount = userLPInfo.lockAmount - userLPInfo.calAmount - userLPInfo.claimedAmount;\r\n            if (releaseAmount > maxAmount) {\r\n                releaseAmount = maxAmount;\r\n            }\r\n            userLPInfo.calAmount += releaseAmount;\r\n        }\r\n        uint256 remainAmount = userLPInfo.lockAmount - userLPInfo.calAmount - userLPInfo.claimedAmount;\r\n        userLPInfo.lockAmount += liquidity;\r\n        userLPInfo.releaseInitAmount = remainAmount + liquidity;\r\n        userLPInfo.releaseDuration = _lpReleaseDuration;\r\n\r\n        if (nowTime > lastReleaseTime) {\r\n            userLPInfo.lastReleaseTime = nowTime;\r\n        }\r\n    }\r\n\r\n    //\r\n    function claimLP() public {\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\r\n        uint256 lastReleaseTime = userLPInfo.lastReleaseTime;\r\n        uint256 nowTime = block.timestamp;\r\n        if (lastReleaseTime > 0 && nowTime > lastReleaseTime) {\r\n            uint256 releaseAmount = userLPInfo.releaseInitAmount * (nowTime - lastReleaseTime) / userLPInfo.releaseDuration;\r\n            uint256 maxAmount = userLPInfo.lockAmount - userLPInfo.calAmount - userLPInfo.claimedAmount;\r\n            if (releaseAmount > maxAmount) {\r\n                releaseAmount = maxAmount;\r\n            }\r\n            userLPInfo.calAmount += releaseAmount;\r\n        }\r\n\r\n        uint256 calAmount = userLPInfo.calAmount;\r\n        if (calAmount > 0) {\r\n            _giveToken(_lp, account, calAmount);\r\n            userLPInfo.calAmount = 0;\r\n            userLPInfo.claimedAmount += calAmount;\r\n            IToken(_mintRewardToken).addUserLPAmount(account, calAmount);\r\n        }\r\n\r\n        if (nowTime > lastReleaseTime) {\r\n            userLPInfo.lastReleaseTime = nowTime;\r\n        }\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    //\r\n    function speedUpLP(uint256 maxTokenAmount) public {\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\r\n        uint256 lastReleaseTime = userLPInfo.lastReleaseTime;\r\n        uint256 nowTime = block.timestamp;\r\n        if (lastReleaseTime > 0 && nowTime > lastReleaseTime) {\r\n            uint256 releaseAmount = userLPInfo.releaseInitAmount * (nowTime - lastReleaseTime) / userLPInfo.releaseDuration;\r\n            uint256 maxAmount = userLPInfo.lockAmount - userLPInfo.calAmount - userLPInfo.claimedAmount;\r\n            if (releaseAmount > maxAmount) {\r\n                releaseAmount = maxAmount;\r\n            }\r\n            userLPInfo.calAmount += releaseAmount;\r\n        }\r\n\r\n        if (nowTime > lastReleaseTime) {\r\n            userLPInfo.lastReleaseTime = nowTime;\r\n        }\r\n\r\n        require(userLPInfo.speedUpTime < _speedUpMaxTime, \"MT\");\r\n        userLPInfo.speedUpTime++;\r\n        uint256 tokenAmount = getSpeedUpTokenAmount();\r\n        require(tokenAmount <= maxTokenAmount, \"MA\");\r\n        _takeToken(_mintRewardToken, account, _speedUpReceiver, tokenAmount);\r\n\r\n        //\r\n        uint256 remainAmount = userLPInfo.lockAmount - userLPInfo.calAmount - userLPInfo.claimedAmount;\r\n        uint256 remainDuration = remainAmount * userLPInfo.releaseDuration / userLPInfo.releaseInitAmount;\r\n\r\n        //\r\n        userLPInfo.releaseInitAmount = remainAmount;\r\n        uint256 speedUpDuration = _speedUpDuration;\r\n        require(remainDuration > speedUpDuration, \"RltS\");\r\n        userLPInfo.releaseDuration = remainDuration - speedUpDuration;\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    function getSpeedUpTokenAmount() private view returns (uint256 tokenAmount){\r\n        (uint256 rUsdt, uint256 rToken) = _getReserves();\r\n        tokenAmount = _speedUpCost * rToken / rUsdt;\r\n    }\r\n\r\n    function _getReserves() public view returns (uint256 rUsdt, uint256 rToken){\r\n        ISwapPair pair = ISwapPair(_lp);\r\n        (uint r0, uint256 r1,) = pair.getReserves();\r\n\r\n        if (_usdt < _mintRewardToken) {\r\n            rUsdt = r0;\r\n            rToken = r1;\r\n        } else {\r\n            rUsdt = r1;\r\n            rToken = r0;\r\n        }\r\n    }\r\n\r\n    function getJoinTokenAmountOut(uint256 usdtAmount) public view returns (uint256 tokenAmount){\r\n        address[] memory path = new address[](2);\r\n        path[0] = _usdt;\r\n        path[1] = _mintRewardToken;\r\n        uint256[] memory amounts = _swapRouter.getAmountsOut(usdtAmount / 2, path);\r\n        tokenAmount = amounts[1];\r\n    }\r\n\r\n    function getSellUsdtOut(uint256 tokenAmount) public view returns (\r\n        uint256 usdtAmount, uint256 selfUsdt, uint256 mintAmount\r\n    ){\r\n        address[] memory path = new address[](2);\r\n        path[0] = _mintRewardToken;\r\n        path[1] = _usdt;\r\n        uint256[] memory amounts = _swapRouter.getAmountsOut(tokenAmount, path);\r\n        usdtAmount = amounts[1];\r\n        selfUsdt = usdtAmount * _sellSelfRate / 10000;\r\n        mintAmount = usdtAmount * _sellJoinRate / 10000;\r\n        mintAmount = mintAmount * getDailyRate() / 10000;\r\n    }\r\n\r\n    //\r\n    function _addUserAmount(address account, uint256 amount, bool calInvite) private {\r\n        UserInfo storage user = userInfo[account];\r\n        _calReward(user, false);\r\n\r\n        uint256 userAmount = user.amount;\r\n        userAmount += amount;\r\n        user.amount = userAmount;\r\n\r\n        uint256 poolTotalAmount = poolInfo.totalAmount;\r\n        poolTotalAmount += amount;\r\n\r\n        uint256 poolAccMintPerShare = poolInfo.accMintPerShare;\r\n        user.rewardMintDebt = userAmount * poolAccMintPerShare / 1e18;\r\n\r\n        if (calInvite) {\r\n            uint256 len = _inviteLen;\r\n            UserInfo storage invitorInfo;\r\n            address current = account;\r\n            address invitor;\r\n            uint256 invitorTotalAmount;\r\n            for (uint256 i; i < len; ++i) {\r\n                invitor = _invitor[current];\r\n                if (address(0) == invitor) {\r\n                    break;\r\n                }\r\n                invitorInfo = userInfo[invitor];\r\n                _calReward(invitorInfo, false);\r\n                uint256 inviteAmount = amount * _inviteFee[i] / 10000;\r\n                _inviteAmount[invitor] += inviteAmount;\r\n                _teamAmount[invitor] += amount;\r\n\r\n                invitorTotalAmount = invitorInfo.amount;\r\n                invitorTotalAmount += inviteAmount;\r\n                invitorInfo.amount = invitorTotalAmount;\r\n                invitorInfo.rewardMintDebt = invitorTotalAmount * poolAccMintPerShare / 1e18;\r\n\r\n                poolTotalAmount += inviteAmount;\r\n                current = invitor;\r\n            }\r\n        }\r\n        poolInfo.totalAmount = poolTotalAmount;\r\n    }\r\n\r\n    //\r\n    function addUserAmount(address account, uint256 amount, bool calInvite) public {\r\n        require(_inProject[msg.sender], \"rq project\");\r\n        _bindInvitor(account, _defaultInvitor);\r\n        _updatePool();\r\n        _addUserAmount(account, amount, calInvite);\r\n    }\r\n\r\n    //\r\n    function addMintAmount(address account, uint256 amount) external onlyWhiteList {\r\n        _bindInvitor(account, _defaultInvitor);\r\n        _updatePool();\r\n        _addUserAmount(account, amount, false);\r\n    }\r\n\r\n    //\r\n    function claim() public {\r\n        address account = msg.sender;\r\n        UserInfo storage user = userInfo[account];\r\n        _calReward(user, true);\r\n        uint256 pendingMint = user.calMintReward;\r\n        if (pendingMint > 0) {\r\n            _giveToken(_mintRewardToken, account, pendingMint);\r\n            user.calMintReward = 0;\r\n        }\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    //\r\n    function _updatePool() private {\r\n        _updateDailyUpRate();\r\n        PoolInfo storage pool = poolInfo;\r\n        uint256 blockTime = block.timestamp;\r\n        uint256 lastRewardTime = pool.lastMintTime;\r\n        if (blockTime <= lastRewardTime) {\r\n            return;\r\n        }\r\n        pool.lastMintTime = blockTime;\r\n\r\n        uint256 accReward = pool.accMintReward;\r\n        uint256 totalReward = pool.totalMintReward;\r\n        if (accReward >= totalReward) {\r\n            return;\r\n        }\r\n\r\n        uint256 totalAmount = pool.totalAmount;\r\n        uint256 rewardPerSec = pool.mintPerSec;\r\n        if (0 < totalAmount && 0 < rewardPerSec) {\r\n            uint256 reward = rewardPerSec * (blockTime - lastRewardTime);\r\n            uint256 remainReward = totalReward - accReward;\r\n            if (reward > remainReward) {\r\n                reward = remainReward;\r\n            }\r\n            pool.accMintPerShare += reward * 1e18 / totalAmount;\r\n            pool.accMintReward += reward;\r\n        }\r\n    }\r\n\r\n    //\r\n    function _calReward(UserInfo storage user, bool updatePool) private {\r\n        if (updatePool) {\r\n            _updatePool();\r\n        }\r\n        if (user.amount > 0) {\r\n            uint256 accMintReward = user.amount * poolInfo.accMintPerShare / 1e18;\r\n            uint256 pendingMintAmount = accMintReward - user.rewardMintDebt;\r\n            if (pendingMintAmount > 0) {\r\n                user.rewardMintDebt = accMintReward;\r\n                user.calMintReward += pendingMintAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getPendingMintReward(address account) public view returns (uint256 reward) {\r\n        reward = 0;\r\n        PoolInfo storage pool = poolInfo;\r\n        UserInfo storage user = userInfo[account];\r\n        if (user.amount > 0) {\r\n            uint256 poolPendingReward;\r\n            uint256 blockTime = block.timestamp;\r\n            uint256 lastRewardTime = pool.lastMintTime;\r\n            if (blockTime > lastRewardTime) {\r\n                poolPendingReward = pool.mintPerSec * (blockTime - lastRewardTime);\r\n                uint256 totalReward = pool.totalMintReward;\r\n                uint256 accReward = pool.accMintReward;\r\n                uint256 remainReward;\r\n                if (totalReward > accReward) {\r\n                    remainReward = totalReward - accReward;\r\n                }\r\n                if (poolPendingReward > remainReward) {\r\n                    poolPendingReward = remainReward;\r\n                }\r\n            }\r\n            reward = user.amount * (pool.accMintPerShare + poolPendingReward * 1e18 / pool.totalAmount) / 1e18 - user.rewardMintDebt;\r\n        }\r\n    }\r\n\r\n    function viewPoolInfo() public view returns (\r\n        uint256 totalAmount,\r\n        uint256 accMintPerShare, uint256 accMintReward,\r\n        uint256 mintPerSec, uint256 lastMintTime, uint256 totalMintReward\r\n    ) {\r\n        totalAmount = poolInfo.totalAmount;\r\n        accMintPerShare = poolInfo.accMintPerShare;\r\n        accMintReward = poolInfo.accMintReward;\r\n        mintPerSec = poolInfo.mintPerSec;\r\n        lastMintTime = poolInfo.lastMintTime;\r\n        totalMintReward = poolInfo.totalMintReward;\r\n    }\r\n\r\n    function viewUserInfo(address account) public view returns (\r\n        bool isActive, uint256 amount,\r\n        uint256 calMintReward, uint256 rewardMintDebt\r\n    ) {\r\n        UserInfo storage user = userInfo[account];\r\n        isActive = user.isActive;\r\n        amount = user.amount;\r\n        calMintReward = user.calMintReward;\r\n        rewardMintDebt = user.rewardMintDebt;\r\n    }\r\n\r\n    function getUserLPInfo(address account) public view returns (\r\n        uint256 lockAmount,\r\n        uint256 calAmount,\r\n        uint256 claimedAmount,\r\n        uint256 lastReleaseTime,\r\n        uint256 releaseInitAmount,\r\n        uint256 releaseDuration,\r\n        uint256 speedUpTime,\r\n        uint256 tokenBalance,\r\n        uint256 tokenAllowance\r\n    ) {\r\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\r\n        lockAmount = userLPInfo.lockAmount;\r\n        calAmount = userLPInfo.calAmount;\r\n        claimedAmount = userLPInfo.claimedAmount;\r\n        releaseInitAmount = userLPInfo.releaseInitAmount;\r\n        releaseDuration = userLPInfo.releaseDuration;\r\n        speedUpTime = userLPInfo.speedUpTime;\r\n        lastReleaseTime = userLPInfo.lastReleaseTime;\r\n        tokenBalance = IERC20(_mintRewardToken).balanceOf(account);\r\n        tokenAllowance = IERC20(_mintRewardToken).allowance(account, address(this));\r\n    }\r\n\r\n    function getUserInfo(address account) public view returns (\r\n        uint256 amount, uint256 usdtBalance, uint256 usdtAllowance,\r\n        uint256 pendingMintReward, uint256 inviteAmount, uint256 sellJoinAmount,\r\n        uint256 teamNum, uint256 teamAmount\r\n    ) {\r\n        UserInfo storage user = userInfo[account];\r\n        amount = user.amount;\r\n        usdtBalance = IERC20(_usdt).balanceOf(account);\r\n        usdtAllowance = IERC20(_usdt).allowance(account, address(this));\r\n        pendingMintReward = getPendingMintReward(account) + user.calMintReward;\r\n        inviteAmount = _inviteAmount[account];\r\n        sellJoinAmount = _sellJoinAmount[account];\r\n        teamNum = _teamNum[account];\r\n        teamAmount = _teamAmount[account];\r\n    }\r\n\r\n    function getBaseInfo() external view returns (\r\n        address usdt,\r\n        uint256 usdtDecimals,\r\n        address mintRewardToken,\r\n        uint256 mintRewardTokenDecimals,\r\n        uint256 totalUsdt,\r\n        uint256 totalAmount,\r\n        uint256 lastDailyReward,\r\n        uint256 dailyAmountRate,\r\n        uint256 minAmount,\r\n        address defaultInvitor,\r\n        bool pauseJoin\r\n    ){\r\n        usdt = _usdt;\r\n        usdtDecimals = IERC20(usdt).decimals();\r\n        mintRewardToken = _mintRewardToken;\r\n        mintRewardTokenDecimals = IERC20(mintRewardToken).decimals();\r\n        totalUsdt = _totalUsdt;\r\n        totalAmount = poolInfo.totalAmount;\r\n        lastDailyReward = _lastDailyReward;\r\n        dailyAmountRate = getDailyRate();\r\n        minAmount = _minAmount;\r\n        defaultInvitor = _defaultInvitor;\r\n        pauseJoin = _pauseJoin;\r\n    }\r\n\r\n    function getLPInfo() external view returns (\r\n        uint256 totalLP,\r\n        uint256 lockLP,\r\n        uint256 speedUpMaxTime,\r\n        uint256 speedCostUsdt,\r\n        uint256 speedCostToken\r\n    ){\r\n        totalLP = IERC20(_lp).totalSupply();\r\n        lockLP = IERC20(_lp).balanceOf(address(this));\r\n        speedUpMaxTime = _speedUpMaxTime;\r\n        speedCostUsdt = _speedUpCost;\r\n        speedCostToken = getSpeedUpTokenAmount();\r\n    }\r\n\r\n    function getBinderLength(address account) public view returns (uint256){\r\n        return _binder[account].length;\r\n    }\r\n\r\n    //\r\n    function setMintPerSec(uint256 mintPerSec) external onlyWhiteList {\r\n        _updatePool();\r\n        poolInfo.mintPerSec = mintPerSec;\r\n    }\r\n\r\n    uint256 private _lastDailyReward;\r\n\r\n    //\r\n    function addTotalMintReward(uint256 reward) external {\r\n        require(_inProject[msg.sender], \"rq project\");\r\n        _updatePool();\r\n        poolInfo.totalMintReward += reward;\r\n        poolInfo.mintPerSec = reward / _dailyDuration;\r\n        _lastDailyReward = reward;\r\n    }\r\n\r\n    //\r\n    function setInviteFee(uint256 i, uint256 fee) external onlyWhiteList {\r\n        _inviteFee[i] = fee;\r\n    }\r\n\r\n    function claimBalance(address to, uint256 amount) external onlyWhiteList {\r\n        safeTransferETH(to, amount);\r\n    }\r\n\r\n    function claimToken(address token, address to, uint256 amount) external onlyWhiteList {\r\n        _giveToken(token, to, amount);\r\n    }\r\n\r\n    function setDefaultInvitor(address adr) external onlyWhiteList {\r\n        _defaultInvitor = adr;\r\n        userInfo[adr].isActive = true;\r\n    }\r\n\r\n    mapping(address => bool) public _inProject;\r\n\r\n    function setInProject(address adr, bool enable) external onlyWhiteList {\r\n        _inProject[adr] = enable;\r\n    }\r\n\r\n    function bindInvitor(address account, address invitor) public {\r\n        address caller = msg.sender;\r\n        require(_inProject[caller], \"NA\");\r\n        _bindInvitor(account, invitor);\r\n    }\r\n\r\n    function _bindInvitor(address account, address invitor) private {\r\n        UserInfo storage user = userInfo[account];\r\n        if (!user.isActive) {\r\n            require(address(0) != invitor, \"invitor 0\");\r\n            require(userInfo[invitor].isActive, \"invitor !Active\");\r\n            _invitor[account] = invitor;\r\n            _binder[invitor].push(account);\r\n            for (uint256 i; i < _inviteLen;) {\r\n                _teamNum[invitor] += 1;\r\n                invitor = _invitor[invitor];\r\n                if (address(0) == invitor) {\r\n                    break;\r\n                }\r\n            unchecked{\r\n                ++i;\r\n            }\r\n            }\r\n            user.isActive = true;\r\n        }\r\n    }\r\n\r\n    function getBinderList(\r\n        address account,\r\n        uint256 start,\r\n        uint256 length\r\n    ) external view returns (\r\n        uint256 returnCount,\r\n        address[] memory binders\r\n    ){\r\n        address[] storage _binders = _binder[account];\r\n        uint256 recordLen = _binders.length;\r\n        if (0 == length) {\r\n            length = recordLen;\r\n        }\r\n        returnCount = length;\r\n        binders = new address[](length);\r\n        uint256 index = 0;\r\n        for (uint256 i = start; i < start + length; i++) {\r\n            if (i >= recordLen) {\r\n                return (index, binders);\r\n            }\r\n            binders[index] = _binders[i];\r\n            index++;\r\n        }\r\n    }\r\n\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'AF');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'ETF');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TFF');\r\n    }\r\n\r\n    function _giveToken(address tokenAddress, address account, uint256 amount) private {\r\n        if (0 == amount) {\r\n            return;\r\n        }\r\n        IERC20 token = IERC20(tokenAddress);\r\n        require(token.balanceOf(address(this)) >= amount, \"PTNE\");\r\n        safeTransfer(tokenAddress, account, amount);\r\n    }\r\n\r\n    function _takeToken(address tokenAddress, address from, address to, uint256 tokenNum) private {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        require(token.balanceOf(address(from)) >= tokenNum, \"TNE\");\r\n        safeTransferFrom(tokenAddress, from, to, tokenNum);\r\n    }\r\n\r\n    modifier onlyWhiteList() {\r\n        address msgSender = msg.sender;\r\n        require(msgSender == _fundAddress || msgSender == _owner, \"nw\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MintPool is AbsLPPool {\r\n    constructor() AbsLPPool(\r\n    //SwapRouter\r\n        address(0x10ED43C718714eb63d5aA57B78B54704E256024E),\r\n    //USDT\r\n        address(0x55d398326f99059fF775485246999027B3197955),\r\n    //BOS\r\n        address(0x55F467206f2C06120D7bD1d98F9F470FE8511366),\r\n    //NFT\r\n        address(0x8aCD218a3354Eb35988684C75b85b7D9e6ee17B7),\r\n    //DefaultInvitor\r\n        address(0xBaFA8C9BC60CCbB5BA0dB2977d58AAD7f94855AC),\r\n    //Fund\r\n        address(0xb7F0CA77f123E83094BBCD0D06aE8c3e7Dce0569)\r\n    ){\r\n\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_amountDailyUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_binder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inProject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_inviteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_invitor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastAmountRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastDailyUpTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lpReleaseDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_nft\",\"outputs\":[{\"internalType\":\"contract INFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pauseSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellJoinRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellLPReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellNFTRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellSelfRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_speedUpDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_speedUpReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_updateDailyUpRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addMintAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"addTotalMintReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"calInvite\",\"type\":\"bool\"}],\"name\":\"addUserAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"}],\"name\":\"bindInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdtDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"mintRewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintRewardTokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDailyReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyAmountRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"defaultInvitor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"pauseJoin\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBinderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getBinderList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnCount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"binders\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"getJoinTokenAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speedUpMaxTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speedCostUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speedCostToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingMintReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getSellUsdtOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellJoinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserLPInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastReleaseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseInitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speedUpTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAllowance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setAmountDailyUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setDefaultInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setInProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setInviteFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"setLPReleaseDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setLastAmountRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"setLastDailyUpTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPerSec\",\"type\":\"uint256\"}],\"name\":\"setMintPerSec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"p\",\"type\":\"bool\"}],\"name\":\"setPauseSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setSeedUpReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setSellJoinRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setSellLPReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setSellNFTRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setSellSelfRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"name\":\"setSpeedUpCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"setSpeedUpDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mt\",\"type\":\"uint256\"}],\"name\":\"setSpeedUpMaxTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTokenAmount\",\"type\":\"uint256\"}],\"name\":\"speedUpLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPoolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accMintPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPerSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastMintTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMintReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"viewUserInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardMintDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MintPool", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://195e61125c23c17cbfe3d6a530495346a1246fe11b1327b26d41980508d12d08"}