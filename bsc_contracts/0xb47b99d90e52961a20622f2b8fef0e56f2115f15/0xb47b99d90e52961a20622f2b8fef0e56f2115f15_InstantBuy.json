{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\nabstract contract ERC20 {\r\n    function name() external view virtual returns (string memory);\r\n    function symbol() external view virtual returns (string memory);\r\n    function decimals() external view virtual returns (uint8);\r\n    function totalSupply() external view virtual returns (uint256);\r\n    function balanceOf(address _owner) external view virtual returns (uint256);\r\n    function allowance(address _owner, address _spender) external view virtual returns (uint256);\r\n    function transfer(address _to, uint256 _value) external virtual returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external virtual returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external virtual returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ncontract InstantBuy\r\n{\r\n    uint PRICE_CONVERT_DECIMALS = 18;\r\n    uint256 ONE_HUNDRED = 100000000000000000000;\r\n\r\n    address public networkcoinaddress;\r\n    address public owner;\r\n    address public feeTo;\r\n    address public chainWrapToken;\r\n    address public swapFactory;\r\n    // uint256 public marginPercent;\r\n    //uint public marginSign; // 0/1 = positive/negative\r\n\r\n    //Instant Buy Price in BUSD\r\n    // mapping(address => uint256) public instantbuyprice;\r\n\r\n    //Instant Buy: Allow To Buy Token (0/1 = false/true)\r\n    mapping(address => uint) public instantbuyallowtobuytoken;\r\n\r\n    //Token Fee Percent\r\n    mapping(address => uint256) public tokenfeepercent;\r\n\r\n    mapping(address => uint256) public marginPercent;\r\n    mapping(address => uint) public marginSign; // 0/1 = positive/negative\r\n\r\n    event OnBuy(address tokenSource, address tokenDestination, uint256 quotePrice, uint256 txPrice, uint256 buyFee, uint256 amountReceived);\r\n\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        feeTo = owner;\r\n        networkcoinaddress = address(0x1110000000000000000100000000000000000111);\r\n\r\n        /*\r\n        56: WBNB\r\n        1: WETH9\r\n        43114: WAVAX\r\n        97: WBNB testnet\r\n        */\r\n        chainWrapToken = block.chainid == 56 ?  address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c) : \r\n                    (block.chainid == 1 ?       address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) : \r\n                    (block.chainid == 43114 ?   address(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7) : \r\n                    (block.chainid == 97 ?      address(0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd) : \r\n                                                address(0) ) ) );\r\n\r\n        /*\r\n        56: PancakeFactory\r\n        1: UniswapV2Factory\r\n        43114: PangolinFactory\r\n        97: PancakeFactory testnet\r\n        */\r\n        swapFactory = block.chainid == 56 ?     address(0xBCfCcbde45cE874adCB698cC183deBcF17952812) : \r\n                    (block.chainid == 1 ?       address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f) : \r\n                    (block.chainid == 43114 ?   address(0xefa94DE7a4656D787667C749f7E1223D71E9FD88) : \r\n                    (block.chainid == 97 ?      address(0xB7926C0430Afb07AA7DEfDE6DA862aE0Bde767bc) : \r\n                                                address(0) ) ) );\r\n    }\r\n\r\n    function supplyNetworkCoin() payable external {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        // nothing else to do!\r\n    }\r\n\r\n    function transferFund(ERC20 token, address to, uint256 amountInWei) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        //Withdraw of deposit value\r\n        if(address(token) != networkcoinaddress)\r\n        {\r\n            //Withdraw token\r\n            token.transfer(to, amountInWei);\r\n        }\r\n        else\r\n        {\r\n            //Withdraw Network Coin\r\n            payable(to).transfer(amountInWei);\r\n        }\r\n    }\r\n\r\n    function setOwner(address newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        owner = newValue;\r\n        return true;\r\n    }\r\n\r\n    function setFeeTo(address newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        feeTo = newValue;\r\n        return true;\r\n    }\r\n\r\n    function setMarginSign(address token, uint newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        marginSign[token] = newValue;\r\n        return true;\r\n    }\r\n\r\n    function getMarginSign(address token) external view returns (uint)\r\n    {\r\n        return marginSign[token];\r\n    }\r\n\r\n    function setMarginPercent(address token, uint256 newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        marginPercent[token] = newValue;\r\n        return true;\r\n    }\r\n\r\n    function getMarginPercent(address token) external view returns (uint256)\r\n    {\r\n        return marginPercent[token];\r\n    }\r\n\r\n    function setNetworkCoinAddress(address newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        networkcoinaddress = newValue;\r\n        return true;\r\n    }\r\n\r\n    // function getInstantBuyPrice(address tokenAddress) external view returns (uint256 value)\r\n    // {\r\n    //     return instantbuyprice[tokenAddress];\r\n    // }\r\n\r\n    // function setInstantBuyPrice(address tokenAddress, uint256 newValue) external returns (bool success)\r\n    // {\r\n    //     require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n    //     instantbuyprice[tokenAddress] = newValue;\r\n    //     return true;\r\n    // }\r\n\r\n    function getInstantBuyFee(address tokenAddress) external view returns (uint256 value)\r\n    {\r\n        return tokenfeepercent[tokenAddress];\r\n    }\r\n\r\n    function setInstantBuyFee(address tokenAddress, uint256 newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        tokenfeepercent[tokenAddress] = newValue;\r\n        return true;\r\n    }\r\n\r\n    // function getInstantBuyPriceQuote(address tokenAddressSource, address tokenAddressDestination) public view returns (uint256 value)\r\n    // {\r\n    //     if(instantbuyprice[tokenAddressSource] == 0)\r\n    //     {\r\n    //         return 0;\r\n    //     }\r\n\r\n    //     if(instantbuyprice[tokenAddressDestination] == 0)\r\n    //     {\r\n    //         return 0;\r\n    //     }\r\n\r\n    //     uint256 result = safeDivFloat(instantbuyprice[tokenAddressSource], instantbuyprice[tokenAddressDestination], PRICE_CONVERT_DECIMALS);\r\n\r\n    //     return result;\r\n    // }\r\n\r\n    function getInstantBuyPriceQuote(address source, address destination) public view returns (uint256 value)\r\n    {\r\n        uint256 result;\r\n\r\n        if(swapFactory == address(0))\r\n        {\r\n            return result;\r\n        }\r\n\r\n        if(source == networkcoinaddress)\r\n        {\r\n            source = chainWrapToken;\r\n        }\r\n\r\n        if(destination == networkcoinaddress)\r\n        {\r\n            destination = chainWrapToken;\r\n        }\r\n\r\n        address pairLP = IUniswapV2Factory(swapFactory).getPair(source, destination);\r\n\r\n        if(pairLP == address(0))\r\n        {\r\n            return result;\r\n        }\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairLP).getReserves();\r\n\r\n        if(reserve0 == 0 || reserve1 == 0)\r\n        {\r\n            return result;\r\n        }\r\n\r\n        if(IUniswapV2Pair(pairLP).token0() == source)\r\n        {\r\n            // result = SafeMath.safeDivFloat(reserve1, reserve0, ERC20(source).decimals());\r\n            result = SafeMath.safeDivFloat(reserve0, reserve1, ERC20(source).decimals());\r\n        }\r\n        else\r\n        {\r\n            // result = SafeMath.safeDivFloat(reserve0, reserve1, ERC20(source).decimals());\r\n            result = SafeMath.safeDivFloat(reserve1, reserve0, ERC20(source).decimals());\r\n        }\r\n\r\n        result = getPriceQuoteWithMargin(destination, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    function getPriceQuoteWithMargin(address token, uint256 amount) internal view returns (uint256 value)\r\n    {        \r\n        uint256 margin = 0;\r\n        uint256 calculatedAmount = 0;\r\n        \r\n        if(marginPercent[token] > 0)\r\n        {\r\n            margin = SafeMath.safeDiv(SafeMath.safeMul(amount, marginPercent[token]), ONE_HUNDRED);            \r\n        }\r\n\r\n        if(marginSign[token] == 0) //marginSing positive\r\n        {\r\n            calculatedAmount = SafeMath.safeAdd(amount, margin);\r\n        }\r\n        else if(marginSign[token] == 1)\r\n        {\r\n            if(amount > margin)\r\n            {\r\n                calculatedAmount = SafeMath.safeSub(amount, margin);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            calculatedAmount = amount;\r\n        }\r\n\r\n        return calculatedAmount;\r\n    }\r\n\r\n    function getInstantBuyTokenAllowedToBuy(address tokenAddress) external view returns (bool value)\r\n    {\r\n        return instantbuyallowtobuytoken[tokenAddress] == 1;\r\n    }\r\n\r\n    function setInstantBuyTokenAllowedToBuy(address tokenAddress, uint newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        instantbuyallowtobuytoken[tokenAddress] = newValue;\r\n        return true;\r\n    }\r\n\r\n    function getBuyForecast(address tokenSource, address tokenDestination, uint256 amountInWei) external view returns (uint256 value)\r\n    {\r\n        uint256 quote = getInstantBuyPriceQuote(tokenSource, tokenDestination);\r\n        uint256 result = SafeMath.safeMulFloat( quote, amountInWei, PRICE_CONVERT_DECIMALS);\r\n\r\n        return result;\r\n    }\r\n\r\n    function getBuyForecastWithFee(address tokenSource, address tokenDestination, uint256 amountInWei) public view returns (uint256 value)\r\n    {\r\n        uint256 feePercent = tokenfeepercent[tokenDestination]; //Eg 10% (10000000000000000000)\r\n        uint256 fee = 0;\r\n        if(feePercent > 0)\r\n        {\r\n            fee = SafeMath.safeDiv(SafeMath.safeMul(amountInWei, feePercent), ONE_HUNDRED);\r\n            amountInWei = SafeMath.safeAdd(amountInWei, fee);\r\n        }\r\n\r\n        uint256 quote = getInstantBuyPriceQuote(tokenSource, tokenDestination);\r\n        uint256 result = SafeMath.safeMulFloat( quote, amountInWei, PRICE_CONVERT_DECIMALS);\r\n\r\n        return result;\r\n    }\r\n\r\n    function instantBuyUsingToken(address tokenSource, address tokenDestination, uint256 amountInWei, uint256 amountDestinationInWei) external returns (bool success)\r\n    {\r\n        require(ERC20(tokenSource).allowance(msg.sender, address(this)) >= amountInWei, \"AL\"); //STAKE: Check the token allowance. Use approve function.\r\n        // require(instantbuyprice[tokenSource] > 0, \"SNI\"); //STAKE: Token Source not initialized\r\n        // require(instantbuyprice[tokenDestination] > 0, \"DNI\"); //STAKE: Token Destination not initialized\r\n        require(instantbuyallowtobuytoken[tokenDestination] == 1, \"N\"); //STAKE: Token not allowed to buy\r\n        require(amountInWei > 0, \"ZERO\"); //STAKE: Zero Amount\r\n\r\n        //Receive payment\r\n        ERC20(tokenSource).transferFrom(msg.sender, feeTo, amountInWei);\r\n\r\n        uint256 forecastWithFee = getBuyForecastWithFee(tokenSource, tokenDestination, amountDestinationInWei);\r\n        // require(amountInWei >= forecastWithFee, strConcatenate(strConcatenate(strConcatenate(\"LOW \", uint2str(amountInWei)), \" EXPECTED \"), uint2str(forecastWithFee)) );\r\n        require(amountInWei >= forecastWithFee, \"LOW\");\r\n\r\n        //Reduce admin fee to swap\r\n        uint256 feePercent = tokenfeepercent[tokenDestination]; //Eg 10% (10000000000000000000)\r\n        uint256 fee = 0;\r\n        if(feePercent > 0)\r\n        {\r\n            require(feePercent <= ONE_HUNDRED, \"IF\"); //STAKE: Invalid percent fee value\r\n\r\n            fee = SafeMath.safeDiv(SafeMath.safeMul(amountInWei, feePercent), ONE_HUNDRED);\r\n            amountInWei = SafeMath.safeSub(amountInWei, fee);\r\n        }\r\n\r\n        //Send paid token amount\r\n        uint256 quote = getInstantBuyPriceQuote(tokenSource, tokenDestination);\r\n        // uint256 result = SafeMath.safeMulFloat( quote, amountInWei, PRICE_CONVERT_DECIMALS);\r\n        // uint256 result = SafeMath.safeDivFloat( amountInWei, quote, PRICE_CONVERT_DECIMALS);\r\n        // uint256 result = SafeMath.safeDiv( amountInWei, quote);\r\n\r\n        uint256 contractBalance = ERC20(tokenDestination).balanceOf(address(this));\r\n        require(contractBalance >= amountDestinationInWei, \"NE\"); //STAKE: Not enough balance\r\n\r\n        ERC20(tokenDestination).transfer(msg.sender, amountDestinationInWei);\r\n\r\n        //Event Buy Trigger: tokenSource, tokenDestination, quotePrice, txPrice, buyFee, amountReceived\r\n        emit OnBuy(tokenSource, tokenDestination, quote, amountInWei, fee, amountDestinationInWei);\r\n\r\n        return true;\r\n    }\r\n\r\n    function instantBuyUsingNetworkCoin(address tokenDestination, uint256 amountDestinationInWei) external payable returns (bool success)\r\n    {\r\n        require(instantbuyallowtobuytoken[tokenDestination] == 1, \"N\"); //STAKE: Token not allowed to buy\r\n        require(msg.value > 0, \"ZERO\"); //STAKE: Zero Amount\r\n\r\n        //Receive payment\r\n        payable(feeTo).transfer(msg.value);\r\n\r\n        //Reduce admin fee to swap\r\n        uint256 feePercent = tokenfeepercent[tokenDestination]; //Eg 10% (10000000000000000000)\r\n        uint256 fee = 0;\r\n        uint256 amountInWei = msg.value;\r\n\r\n        uint256 forecastWithFee = getBuyForecastWithFee(networkcoinaddress, tokenDestination, amountDestinationInWei);\r\n        require(amountInWei >= forecastWithFee, \"LOW \");\r\n\r\n        if(feePercent > 0)\r\n        {\r\n            require(feePercent <= ONE_HUNDRED, \"IF\"); //STAKE: Invalid percent fee value\r\n\r\n            fee = SafeMath.safeDiv(SafeMath.safeMul(amountInWei, feePercent), ONE_HUNDRED);\r\n            amountInWei = SafeMath.safeSub(amountInWei, fee);\r\n        }\r\n\r\n        //Send paid token amount\r\n        //uint256 quote = safeDivFloat(instantbuyprice[networkcoinaddress], instantbuyprice[tokenDestination], PRICE_CONVERT_DECIMALS);\r\n        uint256 quote = getInstantBuyPriceQuote(networkcoinaddress, tokenDestination);\r\n        // uint256 result = SafeMath.safeMulFloat( quote, amountInWei, PRICE_CONVERT_DECIMALS);\r\n        // uint256 result = SafeMath.safeDivFloat( amountInWei, quote, PRICE_CONVERT_DECIMALS);\r\n        // uint256 result = SafeMath.safeDiv( amountInWei, quote);\r\n\r\n        uint256 contractBalance = ERC20(tokenDestination).balanceOf(address(this));\r\n        require(contractBalance >= amountDestinationInWei, \"NE\"); //STAKE: Not enough balance\r\n\r\n        ERC20(tokenDestination).transfer(msg.sender, amountDestinationInWei);\r\n\r\n        //Event Buy Trigger: tokenSource, tokenDestination, quotePrice, txPrice, buyFee, amountReceived\r\n        emit OnBuy(networkcoinaddress, tokenDestination, quote, amountInWei, fee, amountDestinationInWei);\r\n\r\n        return true;\r\n    }\r\n\r\n    function setChainWrapToken(address newValue) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        chainWrapToken = newValue;\r\n    }\r\n\r\n    function setSwapFactory(address newValue) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        swapFactory = newValue;\r\n    }\r\n\r\n    // function strConcatenate(string memory s1, string memory s2) internal pure returns (string memory) \r\n    // {\r\n    //     return string(abi.encodePacked(s1, s2));\r\n    // }\r\n\r\n    // function uint2str(uint _i) internal pure returns (string memory _uintAsString) \r\n    // {\r\n    //     if (_i == 0) \r\n    //     {\r\n    //         return \"0\";\r\n    //     }\r\n\r\n    //     uint j = _i;\r\n    //     uint len;\r\n\r\n    //     while (j != 0) \r\n    //     {\r\n    //         len++;\r\n    //         j /= 10;\r\n    //     }\r\n\r\n    //     bytes memory bstr = new bytes(len);\r\n    //     uint k = len;\r\n\r\n    //     while (_i != 0) \r\n    //     {\r\n    //         k = k-1;\r\n    //         uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n    //         bytes1 b1 = bytes1(temp);\r\n    //         bstr[k] = b1;\r\n    //         _i /= 10;\r\n    //     }\r\n\r\n    //     return string(bstr);\r\n    // }\r\n\r\n}\r\n\r\n// *****************************************************\r\n// **************** SAFE MATH FUNCTIONS ****************\r\n// *****************************************************\r\nlibrary SafeMath {\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"OADD\"); //STAKE: SafeMath: addition overflow\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeSub(a, b, \"OSUB\"); //STAKE: subtraction overflow\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0) \r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"OMUL\"); //STAKE: multiplication overflow\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeMulFloat(uint256 a, uint256 b, uint decimals) internal pure returns(uint256)\r\n    {\r\n        if (a == 0 || decimals == 0)  \r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint result = safeDiv(safeMul(a, b), safePow(10, uint256(decimals)));\r\n\r\n        return result;\r\n    }\r\n\r\n    function safePow(uint256 n, uint256 e) internal pure returns(uint256)\r\n    {\r\n\r\n        if (e == 0) \r\n        {\r\n            return 1;\r\n        } \r\n        else if (e == 1) \r\n        {\r\n            return n;\r\n        } \r\n        else \r\n        {\r\n            uint256 p = safePow(n,  safeDiv(e, 2));\r\n            p = safeMul(p, p);\r\n\r\n            if (safeMod(e, 2) == 1) \r\n            {\r\n                p = safeMul(p, n);\r\n            }\r\n\r\n            return p;\r\n        }\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeDiv(a, b, \"ZDIV\"); //STAKE: division by zero\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeDivFloat(uint256 a, uint256 b, uint256 decimals) internal pure returns (uint256)\r\n    {\r\n        return safeDiv(safeMul(a, safePow(10,decimals)), b);\r\n    }\r\n\r\n    function safeMod(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeMod(a, b, \"ZMOD\"); //STAKE: modulo by zero\r\n    }\r\n\r\n    function safeMod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenSource\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenDestination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quotePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"name\":\"OnBuy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chainWrapToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenSource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"getBuyForecast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenSource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"getBuyForecastWithFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getInstantBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"getInstantBuyPriceQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getInstantBuyTokenAllowedToBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMarginPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMarginSign\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountDestinationInWei\",\"type\":\"uint256\"}],\"name\":\"instantBuyUsingNetworkCoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenSource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDestinationInWei\",\"type\":\"uint256\"}],\"name\":\"instantBuyUsingToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"instantbuyallowtobuytoken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marginPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marginSign\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkcoinaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setChainWrapToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setInstantBuyFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setInstantBuyTokenAllowedToBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMarginPercent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMarginSign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setNetworkCoinAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setSwapFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyNetworkCoin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenfeepercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"transferFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "InstantBuy", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://84b45c19c122cf47d07e6915fccd9f80933520a8d0f89d477b9613c7489fc08f"}