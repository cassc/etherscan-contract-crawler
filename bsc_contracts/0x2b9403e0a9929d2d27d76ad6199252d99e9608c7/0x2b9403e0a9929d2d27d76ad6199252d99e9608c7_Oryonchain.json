{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Oryonchain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20Metadata, IERC20} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @title Oryonchain\\n * @notice Oryon is an international giving programme, which aims to\\n * redistribute wealth and generate passive income, making the world a\\n * better place by creating a unique chain of favours around the world.\\n * @notice Oryonchain is the smart contract for Oryon, this contract\\n * allows users to register and donate to the programme, as well as be\\n * rewarded by participating in this programme.\\n */\\ncontract Oryonchain is Ownable {\\n    IERC20 public STABLECOIN;\\n\\n    // Structs and Mappings\\n    struct UserInfo {\\n        bool specialUser;\\n        address promoter;\\n        uint256 registrationChain;\\n        uint256 registrationContract;\\n        uint256 registeredAt;\\n    }\\n\\n    struct ContractInfo {\\n        uint256 status; /* 1 inactive, 2 active, 3 completed */\\n        uint256 purchasedAt;\\n        address donor1;\\n        address donor2;\\n        address donor3;\\n    }\\n\\n    mapping(address => UserInfo) private _userInfo;\\n    mapping(address => mapping(uint256 => mapping(uint256 => ContractInfo))) private _contractInfo;\\n    mapping(address => mapping(uint256 => uint256)) private _contractCounterByPromoter;\\n    mapping(address => mapping(uint256 => uint256)) private _lastActiveContractByPromoter;\\n    mapping(address => mapping(uint256 => address[])) private _specialContractInfo;\\n    mapping(address => mapping(uint256 => uint256)) private _registrationContract;\\n    mapping(address => address[]) private _usersByPromoter;\\n\\n    // Donations Variables\\n    address private constant _master = 0x01630A08d2738062d3e66F83C5407f0cA0d2EC81;\\n    address private constant _start = 0x61838416694b116A43ac36adb91021bcd67D7C16;\\n    address private constant _specialPromoter = 0x2a2DF296e685E659304c049683C26f07b9236aF1;\\n    address private constant _temporalPromoter = 0xCe75A009189f68eb5ECa3Feb46a4AdD4bFb64081;\\n    address[10] private _bridge = [\\n        _master,\\n        0xe29bd72d824615D86A7A6f64a602B885b7E44525,\\n        0x13D04d5E0D0AC087601d35F0DE189F8bDD1D4B40,\\n        0x546843BdbEE54a32d8239834be2aF2D0f984ecFa,\\n        0x7F789Ee6C9639A307be59504675f90846E5Ee6F1,\\n        0x5EcD8CF4Ac04885CE91A77936397D490b11f59ba,\\n        0x0f0DAb1d06A494bA6766141DB5ceAC00575C6EAF,\\n        0xC18381d68F71d6aCe4b74Ccd0747607012196979,\\n        0x27A3182fA1e89acE4fFC7fb5242a9B9538227d28,\\n        0x7C7783CbE74f1913B56516fAa2AD0F652928ddfD\\n    ];\\n    uint256[9] private _chainPrice = [\\n        12 ether,\\n        60 ether,\\n        120 ether,\\n        300 ether,\\n        600 ether,\\n        1200 ether,\\n        3000 ether,\\n        6000 ether,\\n        12000 ether\\n    ];\\n\\n    // Events\\n    event NewDonor(\\n        address user,\\n        bool specialUser,\\n        address promoter,\\n        uint256 registrationChain,\\n        uint256 registrationContract,\\n        uint256 registeredAt\\n    );\\n    event NewContractState(\\n        address user,\\n        uint256 chain,\\n        uint256 contractId,\\n        uint256 status,\\n        uint256 purchasedAt,\\n        address donor1,\\n        address donor2,\\n        address donor3\\n    );\\n    event NewSpecialContractState(\\n        address specialUser,\\n        uint256 chain,\\n        uint256 contractId,\\n        address newDonor\\n    );\\n    event SetNewStablecoin(address newStablecoin);\\n\\n    /**\\n     * @notice Transfers ownership to the contract creator, configures\\n     * the initial positions and declares all the contract variables.\\n     * @param usdt_ The address of the USDT contract.\\n     */\\n    constructor(address usdt_) Ownable(msg.sender) {\\n        STABLECOIN = IERC20(usdt_);\\n\\n        address promoter_;\\n        for (uint256 i = 0; i < 10; i++) {\\n            _userInfo[_bridge[i]] = UserInfo(true, promoter_, 0, 0, 0);\\n            _usersByPromoter[promoter_] = [_bridge[i]];\\n            emit NewDonor(_bridge[i], true, promoter_, 0, 0, 0);\\n            promoter_ = _bridge[i];\\n        }\\n        _userInfo[_start] = UserInfo(true, _bridge[9], 0, 0, block.timestamp);\\n        _userInfo[_temporalPromoter] = UserInfo(true, _start, 0, 0, block.timestamp);\\n        _userInfo[_specialPromoter] = UserInfo(true, _start, 0, 0, block.timestamp);\\n        _usersByPromoter[_bridge[9]] = [_start];\\n        _usersByPromoter[_start] = [_temporalPromoter, _specialPromoter];\\n        emit NewDonor(_start, true, _bridge[9], 0, 0, block.timestamp);\\n        emit NewDonor(_temporalPromoter, true, _start, 0, 0, block.timestamp);\\n        emit NewDonor(_specialPromoter, true, _start, 0, 0, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Public Functions\\n     *\\n     * @notice External function to register new users with an existing\\n     * registered promoter. If the promoter does not have an active\\n     * contract in this chain, the registration is temporally on hold.\\n     * @param chain_ The chain id.\\n     * @param promoter_ The promoter address.\\n     */\\n    function donateWithPromoter(uint256 chain_, address promoter_) external {\\n        UserInfo memory promoter = _userInfo[promoter_];\\n        if (promoter.registeredAt == 0) revert Oryonchain__InvalidPromoter();\\n        if (_userInfo[msg.sender].registeredAt > 0) revert Oryonchain__AlreadyRegistered();\\n        if (chain_ > 8) revert Oryonchain__InvalidChain();\\n\\n        // Find the contract.\\n        uint256 contract_ = _lastActiveContractByPromoter[promoter_][chain_];\\n        if (promoter.specialUser) contract_ = 1;\\n        else if (_contractInfo[promoter_][chain_][contract_].status != 2) contract_ = 0;\\n\\n        // Update the users state.\\n        _registrationContract[msg.sender][chain_] = contract_;\\n        _userInfo[msg.sender] = UserInfo(false, promoter_, chain_, contract_, block.timestamp);\\n        _usersByPromoter[promoter_].push(msg.sender);\\n        emit NewDonor(msg.sender, false, promoter_, chain_, contract_, block.timestamp);\\n\\n        // Update the new user contract state.\\n        _contractCounterByPromoter[msg.sender][chain_] = 1;\\n        _lastActiveContractByPromoter[msg.sender][chain_] = 1;\\n        _contractInfo[msg.sender][chain_][1] = ContractInfo(2, block.timestamp, address(0), address(0), address(0));\\n\\n        // Occupy a spot in the contract if available.\\n        if (_contractInfo[promoter_][chain_][contract_].status == 2) {\\n            _userInfo[msg.sender].registrationContract = contract_;\\n\\n            if (_contractInfo[promoter_][chain_][contract_].donor1 == address(0)) {\\n                _contractInfo[promoter_][chain_][contract_].donor1 = msg.sender;\\n            } else if (_contractInfo[promoter_][chain_][contract_].donor2 == address(0)) {\\n                _contractInfo[promoter_][chain_][contract_].donor2 = msg.sender;\\n            } else {\\n                _contractInfo[promoter_][chain_][contract_].donor3 = msg.sender;\\n                _contractInfo[promoter_][chain_][contract_].status = 3;\\n                uint256 nextContract = contract_ + 1;\\n                if (_contractInfo[promoter_][chain_][nextContract].status == 1) {\\n                    _contractInfo[promoter_][chain_][nextContract].status = 2;\\n                    _lastActiveContractByPromoter[promoter_][chain_] = nextContract;\\n                    ContractInfo memory nextInfo = _contractInfo[promoter_][chain_][nextContract];\\n                    emit NewContractState(\\n                        promoter_, chain_, nextContract, 2, nextInfo.purchasedAt, address(0), address(0), address(0)\\n                    );\\n                } else {\\n                    _lastActiveContractByPromoter[promoter_][chain_] = 0;\\n                }\\n            }\\n            ContractInfo memory currentInfo = _contractInfo[promoter_][chain_][contract_];\\n            emit NewContractState(\\n                promoter_,\\n                chain_,\\n                contract_,\\n                currentInfo.status,\\n                currentInfo.purchasedAt,\\n                currentInfo.donor1,\\n                currentInfo.donor2,\\n                currentInfo.donor3\\n            );\\n        } else if (promoter.specialUser) {\\n            // Update the promoter contract state.\\n            _specialContractInfo[promoter_][chain_].push(msg.sender);\\n            emit NewSpecialContractState(promoter_, chain_, 1, msg.sender);\\n        }\\n\\n        // Emit the new user contract event.\\n        emit NewContractState(msg.sender, chain_, 1, 2, block.timestamp, address(0), address(0), address(0));\\n\\n        _donate(chain_);\\n    }\\n\\n    /**\\n     * @notice External function that allows old users to donate or new users to register.\\n     * @notice If the user is new, then the special promoter is used as promoter. \\n     * @notice If the user is old and is donating to a different chain than the chain\\n     * this user registered, if the promoter does not have an active contract in the chain,\\n     * the temporal promoter receives the donations.\\n     * @param chain_ The chain id.\\n     */\\n    function donate(uint256 chain_) external {\\n        UserInfo memory user = _userInfo[msg.sender];\\n        if (chain_ > 8) revert Oryonchain__InvalidChain();\\n\\n        // New users register with special promoter, old users donate as already registered.\\n        if (user.promoter == address(0) && !user.specialUser) {\\n            // Update the user state.\\n            _registrationContract[msg.sender][chain_] = 1; \\n            _userInfo[msg.sender] = UserInfo(false, _specialPromoter, chain_, 1, block.timestamp);\\n            _usersByPromoter[_specialPromoter].push(msg.sender);\\n            emit NewDonor(msg.sender, false, _specialPromoter, chain_, 1, block.timestamp);\\n\\n            // Update the new user contract state.\\n            _contractCounterByPromoter[msg.sender][chain_] = 1;\\n            _lastActiveContractByPromoter[msg.sender][chain_] = 1;\\n            _contractInfo[msg.sender][chain_][1] = ContractInfo(2, block.timestamp, address(0), address(0), address(0));\\n\\n            // Update the promoter contract state.\\n            _specialContractInfo[_specialPromoter][chain_].push(msg.sender);\\n            emit NewSpecialContractState(_specialPromoter, chain_, 1, msg.sender);\\n\\n            // Emit the new user contract event.\\n            emit NewContractState(msg.sender, chain_, 1, 2, block.timestamp, address(0), address(0), address(0));\\n\\n        } else {\\n            // Create a new contract.\\n            _contractCounterByPromoter[msg.sender][chain_]++;\\n            uint256 newContract = _contractCounterByPromoter[msg.sender][chain_];\\n            _contractInfo[msg.sender][chain_][newContract] =\\n                ContractInfo(1, block.timestamp, address(0), address(0), address(0));\\n            ContractInfo memory previousInfo = _contractInfo[msg.sender][chain_][newContract - 1];\\n            uint256 newStatus;\\n            if (previousInfo.status == 0 || previousInfo.status == 3) {\\n                _contractInfo[msg.sender][chain_][newContract].status = 2;\\n                _lastActiveContractByPromoter[msg.sender][chain_] = newContract;\\n                newStatus = 2;\\n            } else {\\n                newStatus = 1; \\n            }\\n\\n            // Occupy a spot in the contract if available.\\n            address promoter = user.promoter;\\n            uint256 activeContract = _lastActiveContractByPromoter[promoter][chain_];\\n            if (_registrationContract[msg.sender][chain_] == 0) {\\n                if (_contractInfo[promoter][chain_][activeContract].status == 2 ){\\n                    // Update user state.\\n                    _registrationContract[msg.sender][chain_] = activeContract;\\n\\n                    // Complete the registration for the same registered chain.\\n                    if (user.registrationChain == chain_) {\\n                        _userInfo[msg.sender].registrationContract = activeContract;\\n                        emit NewDonor(msg.sender, false, promoter, chain_, activeContract, user.registeredAt);\\n                    }\\n\\n                    // Update the promoter contract state.\\n                    if (_contractInfo[promoter][chain_][activeContract].donor1 == address(0)) {\\n                        _contractInfo[promoter][chain_][activeContract].donor1 = msg.sender;\\n                    } else if (_contractInfo[promoter][chain_][activeContract].donor2 == address(0)) {\\n                        _contractInfo[promoter][chain_][activeContract].donor2 = msg.sender;\\n                    } else {\\n                        _contractInfo[promoter][chain_][activeContract].donor3 = msg.sender;\\n                        _contractInfo[promoter][chain_][activeContract].status = 3;\\n\\n                        uint256 nextContract = activeContract + 1;\\n                        if (_contractInfo[promoter][chain_][nextContract].status == 1) {\\n                            _contractInfo[promoter][chain_][nextContract].status = 2;\\n                            _lastActiveContractByPromoter[promoter][chain_] = nextContract;\\n                            ContractInfo memory nextInfo = _contractInfo[promoter][chain_][nextContract];\\n                            emit NewContractState(\\n                                promoter, chain_, nextContract, 2, nextInfo.purchasedAt, address(0), address(0), address(0)\\n                            );\\n                        } else {\\n                            _lastActiveContractByPromoter[promoter][chain_] = 0;\\n                        }\\n                    }\\n                    ContractInfo memory currentInfo = _contractInfo[promoter][chain_][activeContract];\\n                    emit NewContractState(\\n                        promoter,\\n                        chain_,\\n                        activeContract,\\n                        currentInfo.status,\\n                        currentInfo.purchasedAt,\\n                        currentInfo.donor1,\\n                        currentInfo.donor2,\\n                        currentInfo.donor3\\n                    );\\n                } else if (_userInfo[promoter].specialUser) {\\n                    // Update the user state.\\n                    _registrationContract[msg.sender][chain_] = 1;\\n                    \\n                    // Update the promoter contract state.\\n                    _specialContractInfo[promoter][chain_].push(msg.sender);\\n                    emit NewSpecialContractState(promoter, chain_, 1, msg.sender);\\n                }\\n            }\\n\\n            // Emit the new user contract event.\\n            emit NewContractState(\\n                    msg.sender, chain_, newContract, newStatus, block.timestamp, address(0), address(0), address(0)\\n                );\\n        }\\n\\n        _donate(chain_);\\n    }\\n\\n    /**\\n     * @notice Internal function to find the extended upline and perform donations.\\n     * @param chain_ The chain id.\\n     */\\n    function _donate(uint256 chain_) internal {\\n        uint256 amount = _chainPrice[chain_] / 12;\\n        address[10] memory upline = getUpline(msg.sender, chain_);\\n        address[12] memory extendedUpline;\\n        extendedUpline[0] = owner();\\n        extendedUpline[1] = _master;\\n        for (uint256 i = 0; i < 10; i++) {\\n            extendedUpline[i + 2] = upline[i];\\n        }\\n\\n        for (uint256 i = 0; i < 12; i++) {\\n            bool success = STABLECOIN.transferFrom(msg.sender, extendedUpline[i], amount);\\n            if (!success) revert Oryonchain__TransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Owner functions\\n     *\\n     * @notice Allows the contract owner to set a new special user.\\n     * @param specialUser_ The new special user.\\n     */\\n    function setNewSpecialUser(address specialUser_) external onlyOwner {\\n        if (specialUser_ == address(0)) revert Oryonchain__InvalidZeroAddress();\\n        if (_userInfo[specialUser_].registeredAt != 0 || _userInfo[specialUser_].specialUser) {\\n            revert Oryonchain__AlreadyRegistered();\\n        }\\n\\n        _userInfo[specialUser_] = UserInfo(true, _start, 0, 1, block.timestamp);\\n        emit NewDonor(specialUser_, true, _start, 0, 1, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set a new stablecoin. \\n     * This new stablecoin must have 18 decimals in order to be \\n     * compatible with this smart contract.\\n     * @param stablecoin_ The new stablecoin.\\n     */\\n    function setNewStablecoin(address stablecoin_) external onlyOwner {\\n        if (IERC20Metadata(stablecoin_).decimals() != 18) revert Oryonchain__StablecoinNotCompatible();\\n        \\n        STABLECOIN = IERC20(stablecoin_);\\n        emit SetNewStablecoin(stablecoin_);\\n    }\\n\\n    /**\\n     * @notice View / Pure Functions\\n     *\\n     * @notice Returns the 10 addresses of the promoter line. If the \\n     * primary promoter fits the requirements, continues the primary line.\\n     * Otherwise, the line switches to the temporal promoter upline. \\n     * @param user_ The user address.\\n     * @param chain_ The chain id.\\n     */\\n    function getUpline(address user_, uint256 chain_) public view returns (address[10] memory) {\\n        address[10] memory promoters;\\n        address donor = user_;\\n        for (uint256 i = 0; i < 10; i++) {\\n            address promoter = _userInfo[donor].promoter;\\n            if (promoterContractOk(donor, promoter, chain_)) {\\n                promoters[i] = promoter;\\n                donor = promoter;\\n            } else {\\n                promoters[i] = _temporalPromoter;\\n                donor = _temporalPromoter;\\n            }\\n        }\\n        return promoters;\\n    }\\n\\n    /**\\n     * @notice Internal function that returns true if the upper promoter is valid, and false if not valid.\\n     * Case A: When promoter is a special user.\\n     * Case B: When donor registered with this promoter and chain.\\n     * @param donor_ The donor address.\\n     * @param promoter_ The promoter address.\\n     * @param chain_ The chain id.\\n     */\\n    function promoterContractOk(address donor_, address promoter_, uint256 chain_) internal view returns (bool) {\\n        if (_userInfo[promoter_].specialUser) return true;\\n        UserInfo memory donor = _userInfo[donor_];\\n        if (donor.promoter == promoter_ && _registrationContract[donor_][chain_] != 0) return true;\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Returns: specialUser, promoter, registrationChain, registrationContract, registeredAt.\\n     * @param user_ The user address.\\n     */\\n    function userInfo(address user_) external view returns (UserInfo memory) {\\n        return _userInfo[user_];\\n    }\\n\\n    /**\\n     * @notice Returns: status, purchasedAt, donor1, donor2, donor3.\\n     * @param promoter_ The promoter address.\\n     * @param chain_ The chain id.\\n     * @param contractId_ The contract id.\\n     */\\n    function contractInfo(address promoter_, uint256 chain_, uint256 contractId_) external view returns (ContractInfo memory) {\\n        return _contractInfo[promoter_][chain_][contractId_];\\n    }\\n\\n    /**\\n     * @notice Returns the special promoter donors in a specific chain.\\n     * @param specialPromoter_ The promoter address.\\n     * @param chain_ The chain id.\\n     */\\n    function specialContractInfo(address specialPromoter_, uint256 chain_) external view returns (address[] memory) {\\n        return _specialContractInfo[specialPromoter_][chain_];\\n    }\\n\\n    /**\\n     * @notice Returns the prices of the chains.\\n     * @param chain_ The chain id.\\n     */\\n    function chainPrice(uint256 chain_) external view returns (uint256) {\\n        return _chainPrice[chain_];\\n    }\\n\\n    /**\\n     * @notice Returns the first level in the tree.\\n     * @param promoter_ The promoter address.\\n     */\\n    function usersByPromoter(address promoter_) external view returns (address[] memory) {\\n        return _usersByPromoter[promoter_];\\n    }\\n\\n    /**\\n     * @notice Returns the number of contracts of a promoter in a specific chain.\\n     * @param promoter_ The promoter address.\\n     * @param chain_ The chain id.\\n     */\\n    function contractCounterByPromoter(address promoter_, uint256 chain_) external view returns (uint256) {\\n        return _contractCounterByPromoter[promoter_][chain_];\\n    }\\n\\n    /**\\n     * @notice Returns the last active contract of a promoter in a specific chain.\\n     * @param promoter_ The promoter address.\\n     * @param chain_ The chain id.\\n     */\\n    function lastActiveContractByPromoter(address promoter_, uint256 chain_) external view returns (uint256) { \\n        return _lastActiveContractByPromoter[promoter_][chain_];\\n    }\\n\\n    /**\\n     * @notice Returns the registration contract id for a given donor and chain.\\n     * @param donor_ The donor address.\\n     * @param chain_ The chain id.\\n     */\\n    function registrationContractByChain(address donor_, uint256 chain_) external view returns (uint256) {\\n        return _registrationContract[donor_][chain_];\\n    }\\n\\n    /**\\n     * @notice Oryonchain custom errors.\\n     */\\n    error Oryonchain__TransferFailed();\\n    error Oryonchain__StablecoinNotCompatible();\\n    error Oryonchain__AlreadyRegistered();\\n    error Oryonchain__InvalidPromoter();\\n    error Oryonchain__InvalidZeroAddress();\\n    error Oryonchain__InvalidChain();\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usdt_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Oryonchain__AlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Oryonchain__InvalidChain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Oryonchain__InvalidPromoter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Oryonchain__InvalidZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Oryonchain__StablecoinNotCompatible\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Oryonchain__TransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchasedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"donor1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"donor2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"donor3\",\"type\":\"address\"}],\"name\":\"NewContractState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"specialUser\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"promoter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registrationChain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registrationContract\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registeredAt\",\"type\":\"uint256\"}],\"name\":\"NewDonor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"specialUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDonor\",\"type\":\"address\"}],\"name\":\"NewSpecialContractState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStablecoin\",\"type\":\"address\"}],\"name\":\"SetNewStablecoin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"STABLECOIN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"}],\"name\":\"chainPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"promoter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"}],\"name\":\"contractCounterByPromoter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"promoter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractId_\",\"type\":\"uint256\"}],\"name\":\"contractInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchasedAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"donor1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"donor2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"donor3\",\"type\":\"address\"}],\"internalType\":\"struct Oryonchain.ContractInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"promoter_\",\"type\":\"address\"}],\"name\":\"donateWithPromoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"}],\"name\":\"getUpline\",\"outputs\":[{\"internalType\":\"address[10]\",\"name\":\"\",\"type\":\"address[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"promoter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"}],\"name\":\"lastActiveContractByPromoter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"donor_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"}],\"name\":\"registrationContractByChain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"specialUser_\",\"type\":\"address\"}],\"name\":\"setNewSpecialUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stablecoin_\",\"type\":\"address\"}],\"name\":\"setNewStablecoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"specialPromoter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chain_\",\"type\":\"uint256\"}],\"name\":\"specialContractInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"specialUser\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"promoter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"registrationChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationContract\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registeredAt\",\"type\":\"uint256\"}],\"internalType\":\"struct Oryonchain.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"promoter_\",\"type\":\"address\"}],\"name\":\"usersByPromoter\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Oryonchain", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}