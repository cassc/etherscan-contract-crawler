{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IController.sol\":{\"content\":\"/*\\r\\n    Copyright 2020 Set Labs Inc.\\r\\n\\r\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n    you may not use this file except in compliance with the License.\\r\\n    You may obtain a copy of the License at\\r\\n\\r\\n    http://www.apache.org/licenses/LICENSE-2.0\\r\\n\\r\\n    Unless required by applicable law or agreed to in writing, software\\r\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n    See the License for the specific language governing permissions and\\r\\n    limitations under the License.\\r\\n\\r\\n    SPDX-License-Identifier: Apache License, Version 2.0\\r\\n*/\\r\\npragma solidity 0.6.10;\\r\\n\\r\\ninterface IController {\\r\\n    function addSet(address _setToken) external;\\r\\n    function feeRecipient() external view returns(address);\\r\\n    function getModuleFee(address _module, uint256 _feeType) external view returns(uint256);\\r\\n    function isModule(address _module) external view returns(bool);\\r\\n    function isSet(address _setToken) external view returns(bool);\\r\\n    function isSystemContract(address _contractAddress) external view returns (bool);\\r\\n    function resourceId(uint256 _id) external view returns(address);\\r\\n}\"},\"Integration_registry.sol\":{\"content\":\"/*\\r\\n    Copyright 2020 Set Labs Inc.\\r\\n\\r\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n    you may not use this file except in compliance with the License.\\r\\n    You may obtain a copy of the License at\\r\\n\\r\\n    http://www.apache.org/licenses/LICENSE-2.0\\r\\n\\r\\n    Unless required by applicable law or agreed to in writing, software\\r\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n    See the License for the specific language governing permissions and\\r\\n    limitations under the License.\\r\\n\\r\\n    SPDX-License-Identifier: Apache License, Version 2.0\\r\\n*/\\r\\n\\r\\npragma solidity 0.6.10;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport { IController } from \\\"./IController.sol\\\";\\r\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IntegrationRegistry\\r\\n * @author Set Protocol\\r\\n *\\r\\n * The IntegrationRegistry holds state relating to the Modules and the integrations they are connected with.\\r\\n * The state is combined into a single Registry to allow governance updates to be aggregated to one contract.\\r\\n */\\r\\ncontract IntegrationRegistry is Ownable {\\r\\n\\r\\n    /* ============ Events ============ */\\r\\n\\r\\n    event IntegrationAdded(address indexed _module, address indexed _adapter, string _integrationName);\\r\\n    event IntegrationRemoved(address indexed _module, address indexed _adapter, string _integrationName);\\r\\n    event IntegrationEdited(\\r\\n        address indexed _module,\\r\\n        address _newAdapter,\\r\\n        string _integrationName\\r\\n    );\\r\\n\\r\\n    /* ============ State Variables ============ */\\r\\n\\r\\n    // Address of the Controller contract\\r\\n    IController public controller;\\r\\n\\r\\n    // Mapping of module =\\u003e integration identifier =\\u003e adapter address\\r\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e address)) private integrations;\\r\\n\\r\\n    /* ============ Constructor ============ */\\r\\n\\r\\n    /**\\r\\n     * Initializes the controller\\r\\n     *\\r\\n     * @param _controller          Instance of the controller\\r\\n     */\\r\\n    constructor(IController _controller) public {\\r\\n        controller = _controller;\\r\\n    }\\r\\n\\r\\n    /* ============ External Functions ============ */\\r\\n\\r\\n    /**\\r\\n     * GOVERNANCE FUNCTION: Add a new integration to the registry\\r\\n     *\\r\\n     * @param  _module       The address of the module associated with the integration\\r\\n     * @param  _name         Human readable string identifying the integration\\r\\n     * @param  _adapter      Address of the adapter contract to add\\r\\n     */\\r\\n    function addIntegration(\\r\\n        address _module,\\r\\n        string memory _name,\\r\\n        address _adapter\\r\\n    )\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        bytes32 hashedName = _nameHash(_name);\\r\\n        require(controller.isModule(_module), \\\"Must be valid module.\\\");\\r\\n        require(integrations[_module][hashedName] == address(0), \\\"Integration exists already.\\\");\\r\\n        require(_adapter != address(0), \\\"Adapter address must exist.\\\");\\r\\n\\r\\n        integrations[_module][hashedName] = _adapter;\\r\\n\\r\\n        emit IntegrationAdded(_module, _adapter, _name);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * GOVERNANCE FUNCTION: Batch add new adapters. Reverts if exists on any module and name\\r\\n     *\\r\\n     * @param  _modules      Array of addresses of the modules associated with integration\\r\\n     * @param  _names        Array of human readable strings identifying the integration\\r\\n     * @param  _adapters     Array of addresses of the adapter contracts to add\\r\\n     */\\r\\n    function batchAddIntegration(\\r\\n        address[] memory _modules,\\r\\n        string[] memory _names,\\r\\n        address[] memory _adapters\\r\\n    )\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        // Storing modules count to local variable to save on invocation\\r\\n        uint256 modulesCount = _modules.length;\\r\\n\\r\\n        require(modulesCount \\u003e 0, \\\"Modules must not be empty\\\");\\r\\n        require(modulesCount == _names.length, \\\"Module and name lengths mismatch\\\");\\r\\n        require(modulesCount == _adapters.length, \\\"Module and adapter lengths mismatch\\\");\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c modulesCount; i++) {\\r\\n            // Add integrations to the specified module. Will revert if module and name combination exists\\r\\n            addIntegration(\\r\\n                _modules[i],\\r\\n                _names[i],\\r\\n                _adapters[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * GOVERNANCE FUNCTION: Edit an existing integration on the registry\\r\\n     *\\r\\n     * @param  _module       The address of the module associated with the integration\\r\\n     * @param  _name         Human readable string identifying the integration\\r\\n     * @param  _adapter      Address of the adapter contract to edit\\r\\n     */\\r\\n    function editIntegration(\\r\\n        address _module,\\r\\n        string memory _name,\\r\\n        address _adapter\\r\\n    )\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        bytes32 hashedName = _nameHash(_name);\\r\\n\\r\\n        require(controller.isModule(_module), \\\"Must be valid module.\\\");\\r\\n        require(integrations[_module][hashedName] != address(0), \\\"Integration does not exist.\\\");\\r\\n        require(_adapter != address(0), \\\"Adapter address must exist.\\\");\\r\\n\\r\\n        integrations[_module][hashedName] = _adapter;\\r\\n\\r\\n        emit IntegrationEdited(_module, _adapter, _name);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * GOVERNANCE FUNCTION: Batch edit adapters for modules. Reverts if module and\\r\\n     * adapter name don\\u0027t map to an adapter address\\r\\n     *\\r\\n     * @param  _modules      Array of addresses of the modules associated with integration\\r\\n     * @param  _names        Array of human readable strings identifying the integration\\r\\n     * @param  _adapters     Array of addresses of the adapter contracts to add\\r\\n     */\\r\\n    function batchEditIntegration(\\r\\n        address[] memory _modules,\\r\\n        string[] memory _names,\\r\\n        address[] memory _adapters\\r\\n    )\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        // Storing name count to local variable to save on invocation\\r\\n        uint256 modulesCount = _modules.length;\\r\\n\\r\\n        require(modulesCount \\u003e 0, \\\"Modules must not be empty\\\");\\r\\n        require(modulesCount == _names.length, \\\"Module and name lengths mismatch\\\");\\r\\n        require(modulesCount == _adapters.length, \\\"Module and adapter lengths mismatch\\\");\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c modulesCount; i++) {\\r\\n            // Edits integrations to the specified module. Will revert if module and name combination does not exist\\r\\n            editIntegration(\\r\\n                _modules[i],\\r\\n                _names[i],\\r\\n                _adapters[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * GOVERNANCE FUNCTION: Remove an existing integration on the registry\\r\\n     *\\r\\n     * @param  _module       The address of the module associated with the integration\\r\\n     * @param  _name         Human readable string identifying the integration\\r\\n     */\\r\\n    function removeIntegration(address _module, string memory _name) external onlyOwner {\\r\\n        bytes32 hashedName = _nameHash(_name);\\r\\n        require(integrations[_module][hashedName] != address(0), \\\"Integration does not exist.\\\");\\r\\n\\r\\n        address oldAdapter = integrations[_module][hashedName];\\r\\n        delete integrations[_module][hashedName];\\r\\n\\r\\n        emit IntegrationRemoved(_module, oldAdapter, _name);\\r\\n    }\\r\\n\\r\\n    /* ============ External Getter Functions ============ */\\r\\n\\r\\n    /**\\r\\n     * Get integration adapter address associated with passed human readable name\\r\\n     *\\r\\n     * @param  _module       The address of the module associated with the integration\\r\\n     * @param  _name         Human readable adapter name\\r\\n     *\\r\\n     * @return               Address of adapter\\r\\n     */\\r\\n    function getIntegrationAdapter(address _module, string memory _name) external view returns (address) {\\r\\n        return integrations[_module][_nameHash(_name)];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Get integration adapter address associated with passed hashed name\\r\\n     *\\r\\n     * @param  _module       The address of the module associated with the integration\\r\\n     * @param  _nameHash     Hash of human readable adapter name\\r\\n     *\\r\\n     * @return               Address of adapter\\r\\n     */\\r\\n    function getIntegrationAdapterWithHash(address _module, bytes32 _nameHash) external view returns (address) {\\r\\n        return integrations[_module][_nameHash];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Check if adapter name is valid\\r\\n     *\\r\\n     * @param  _module       The address of the module associated with the integration\\r\\n     * @param  _name         Human readable string identifying the integration\\r\\n     *\\r\\n     * @return               Boolean indicating if valid\\r\\n     */\\r\\n    function isValidIntegration(address _module, string memory _name) external view returns (bool) {\\r\\n        return integrations[_module][_nameHash(_name)] != address(0);\\r\\n    }\\r\\n\\r\\n    /* ============ Internal Functions ============ */\\r\\n\\r\\n    /**\\r\\n     * Hashes the string and returns a bytes32 value\\r\\n     */\\r\\n    function _nameHash(string memory _name) internal pure returns(bytes32) {\\r\\n        return keccak256(bytes(_name));\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.6.10;\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () internal {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IController\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newAdapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"addIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_adapters\",\"type\":\"address[]\"}],\"name\":\"batchAddIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_adapters\",\"type\":\"address[]\"}],\"name\":\"batchEditIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"editIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getIntegrationAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nameHash\",\"type\":\"bytes32\"}],\"name\":\"getIntegrationAdapterWithHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"isValidIntegration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"removeIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IntegrationRegistry", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000943898261c618250f8e13c4ed0b86a4ba8c51f9e", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7fd8c13a1d50d6a71f40f468fc8684ebe3ff767fca104d6d5139e9286b47acdd"}