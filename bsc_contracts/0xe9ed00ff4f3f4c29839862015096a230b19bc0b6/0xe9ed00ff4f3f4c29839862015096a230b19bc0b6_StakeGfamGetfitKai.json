{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/MiningV6/StakeGFAM_V2.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\ncontract StakeGfamGetfitKai is Ownable, Pausable {\r\n\r\n    mapping ( address => bool ) private  allowedContracts;\r\n    \r\n    IERC20 public gfamToken;\r\n    IERC20 public busdToken; \r\n    ITokenTrade public tokenTrade;\r\n    address public feesWallet;\r\n\r\n    uint public rewardRate;\r\n    uint public commissionRate;\r\n    uint public feesRate;\r\n    uint public earningDate;\r\n    uint public offset;\r\n\r\n    uint public totalGfam;\r\n    uint public globalGfamValue;\r\n    uint public totaRequestedBusd;\r\n    uint public rewardBusdPool;\r\n    uint public rewardDistributionBalance;\r\n    uint public ReferralClaimsBalance;\r\n\r\n    mapping(address => Stake[]) public stakes;\r\n    mapping(address => uint) public stakesPerUser;\r\n    mapping(address => address) public referrals;\r\n    mapping(address => uint) public referralClaims;\r\n    uint public currentStakes = 0;\r\n    bool public lockedUnstake;\r\n    bool public lockedWithdrawReward;\r\n    bool public allowRef;\r\n\r\n\r\n    constructor() {\r\n        feesWallet = 0x09C6FC900bfDF6702FaF72535d7dc5f75f23E852;\r\n        gfamToken = IERC20(0x65186232D45f933BE75ECF76ab0592DDD31d302A);\r\n        busdToken = IERC20(0x95d429480DF802b2178E5814C3ea80E9394b0b78);\r\n        tokenTrade = ITokenTrade(0xB33F6deC56eE4123d12202d469b157360Dd72f44);\r\n        rewardRate = 25;\r\n        commissionRate = 10;\r\n        feesRate = 5;\r\n        lockedUnstake = true;\r\n        lockedWithdrawReward = false;\r\n        allowRef = true;\r\n        offset = 1;\r\n\r\n    }\r\n\r\n    struct Stake {\r\n        uint256 initialAmount;\r\n        uint256 gfamValue;\r\n        uint256 stakeValue;\r\n        uint256 rewardGoal;\r\n        uint256 rewardGoalNet;\r\n        uint256 startDay;\r\n        uint256 lastClaimDay;\r\n        uint256 rewardClaimed;\r\n        uint256 rewardClaimedNet;\r\n        bool ended;\r\n    }\r\n\r\n    struct TokensData {\r\n        uint totalGfam;\r\n        uint rewardBusdPool;\r\n        uint rewardDistributionBalance;\r\n        uint totaRequestedBusd;\r\n        uint ReferralClaimsBalance;\r\n    }\r\n\r\n    event stakeEvent(address _user, uint _amount, uint _gfamValue);\r\n    event claimEvent(address _user, uint _amount, uint _goal);\r\n    event restakeEvent(address _user, uint _amount, uint _gfamValue);\r\n    event claimRewardEvent(address _user, uint _amount, uint _gfamValue);\r\n\r\n    //STAKE\r\n    function stake(uint256 _amount, address _referral) public whenNotPaused {\r\n        require(msg.sender != referrals[_referral], \"Circular referral\");\r\n        address finRef;\r\n        if(referrals[msg.sender] == address(0) && _referral != address(0)){referrals[msg.sender] = _referral;}\r\n        if(referrals[msg.sender] != address(0)){finRef = referrals[msg.sender];}else{finRef = feesWallet;}\r\n        if(allowRef){\r\n            referralClaims[finRef] += _amount*commissionRate/100;\r\n            ReferralClaimsBalance +=  _amount*commissionRate/100;\r\n        }\r\n        gfamToken.transferFrom(msg.sender, address(this), _amount);\r\n        Stake memory _stake = __stake(_amount);\r\n        stakes[msg.sender].push(_stake);\r\n        stakesPerUser[msg.sender] += 1;\r\n        //GLOBAL\r\n        totaRequestedBusd += _stake.rewardGoal;\r\n        totalGfam += _stake.initialAmount;\r\n        currentStakes += 1;\r\n        globalGfamValue += _stake.stakeValue;\r\n        emit stakeEvent(msg.sender, _amount, getPrice(0));\r\n    }\r\n    function adminSt(address _user, uint256 _amount, address _referral) public onlyOwner {\r\n        require(_user != referrals[_referral], \"Circular referral\");\r\n        address finRef;\r\n        if(referrals[_user] == address(0) && _referral != address(0)){referrals[_user] = _referral;}\r\n        if(referrals[_user] != address(0)){finRef = referrals[_user];}else{finRef = feesWallet;}\r\n        if(allowRef){\r\n            referralClaims[finRef] += _amount*commissionRate/100;\r\n            ReferralClaimsBalance +=  _amount*commissionRate/100;\r\n        }\r\n        Stake memory _stake = __stake(_amount);\r\n        stakes[_user].push(_stake);\r\n        stakesPerUser[_user] += 1;\r\n        //GLOBAL\r\n        totaRequestedBusd += _stake.rewardGoal;\r\n        totalGfam += _stake.initialAmount;\r\n        currentStakes += 1;\r\n        globalGfamValue += _stake.stakeValue;\r\n        emit stakeEvent(_user, _amount, getPrice(0));\r\n    }\r\n    function restake(uint _stakeIndex) public whenNotPaused {\r\n        Stake storage _stake = stakes[msg.sender][_stakeIndex];\r\n        require(_stake.rewardClaimedNet >= _stake.rewardGoalNet, \"Claim your reward before restaking\");\r\n        uint gfamValue = getPrice(0);\r\n        uint _amount = _stake.stakeValue*1e18/gfamValue;\r\n        _stake.initialAmount = _amount;\r\n        _stake.gfamValue = gfamValue;\r\n        _stake.startDay = block.timestamp;\r\n        _stake.rewardClaimed = 0;\r\n        _stake.rewardClaimedNet = 0;\r\n        _stake.ended = false;\r\n        //GLOBAL\r\n        totaRequestedBusd += _stake.rewardGoal;\r\n        emit restakeEvent(msg.sender, _amount, gfamValue);\r\n\r\n    }\r\n    function __stake(uint256 _amount) internal view returns(Stake memory) {\r\n        uint gfamValue = getPrice(_amount);\r\n        uint stakeValue = _amount*gfamValue/1e18;\r\n        uint goal = (stakeValue*rewardRate)/100;\r\n        uint _rewardGoalNet = (goal*100)/(100-feesRate);\r\n        Stake memory newStake = Stake({\r\n            initialAmount: _amount,\r\n            gfamValue: gfamValue,\r\n            stakeValue: stakeValue,\r\n            startDay: block.timestamp,\r\n            rewardGoal: goal,\r\n            rewardGoalNet: _rewardGoalNet,\r\n            lastClaimDay: block.timestamp,\r\n            rewardClaimed: 0,\r\n            rewardClaimedNet: 0,\r\n            ended: false\r\n        });\r\n        return newStake;\r\n    }\r\n    \r\n    function claim(uint256 _stakeIndex) public whenNotPaused {\r\n        require(_stakeIndex < stakes[msg.sender].length, \"Invalid stake index\");\r\n        require(lockedWithdrawReward, \"Locked\");\r\n        Stake storage _stake = stakes[msg.sender][_stakeIndex];\r\n        require(!_stake.ended, \"Stake Ended\");\r\n        require(_stake.startDay>earningDate, \"Earning didn't start\");\r\n        require( block.timestamp + (1 days * offset) > _stake.startDay , \"Waiting to start\");\r\n        _stake.lastClaimDay = block.timestamp;\r\n        uint availableReward = getRewardPatial(_stake.rewardGoalNet);\r\n        if(availableReward >= (_stake.rewardGoalNet - _stake.rewardClaimed)){\r\n            availableReward = _stake.rewardGoalNet - _stake.rewardClaimed;\r\n            _stake.ended = true;\r\n        }\r\n        uint _fees = (availableReward * feesRate)/100;\r\n        _stake.rewardClaimed = availableReward - _fees;\r\n        _stake.rewardClaimedNet = availableReward;\r\n        busdToken.transfer(msg.sender, (availableReward - _fees));\r\n        busdToken.transfer(feesWallet, _fees);\r\n        //GLOBAL\r\n        totaRequestedBusd -= availableReward;\r\n        emit claimEvent(msg.sender, availableReward - _fees, _stake.rewardGoalNet);\r\n    }\r\n    function unstake(address _user, uint _stakeIndex) public onlyOwner {\r\n        require(!lockedUnstake, \"Locked\");\r\n        Stake storage _stake = stakes[msg.sender][_stakeIndex];\r\n        require(_stake.rewardClaimedNet >= _stake.rewardGoalNet, \"Claim your reward before unstaking\");\r\n        totalGfam -= _stake.initialAmount;\r\n        currentStakes -= 1;\r\n        globalGfamValue -= _stake.gfamValue;\r\n        _removeStake(_user, _stakeIndex);\r\n        gfamToken.transfer(_user, _stake.initialAmount * _stake.gfamValue / getPrice(0));\r\n    }\r\n\r\n    function _removeStake (address _user, uint _stakeIndex) private {\r\n        removeItemFromArray(stakes[_user], _stakeIndex);\r\n        if(stakesPerUser[_user]>0) stakesPerUser[_user] -= 1;\r\n        currentStakes -= 1;\r\n    }\r\n    \r\n    function getRewardPatial (uint _totalReward) public view returns (uint) {\r\n        return (_totalReward * rewardBusdPool) / totaRequestedBusd;\r\n    }\r\n    //\r\n\r\n    //REFERRAL\r\n    function claimReferralCom() public {\r\n        uint _amount = referralClaims[msg.sender];\r\n        require(_amount > 0, \"Nothing to claim\");\r\n        Stake memory _stake = __stake(_amount);\r\n        stakes[msg.sender].push(_stake); \r\n        stakesPerUser[msg.sender] += 1;\r\n        //GLOBAL\r\n        totaRequestedBusd += _stake.rewardGoal;\r\n        totalGfam += _stake.initialAmount;\r\n        currentStakes += 1;\r\n        globalGfamValue += _stake.stakeValue;\r\n        referralClaims[msg.sender] = 0;\r\n        ReferralClaimsBalance -= _stake.initialAmount;\r\n        emit claimRewardEvent(msg.sender, referralClaims[msg.sender], _stake.gfamValue);\r\n    }\r\n    \r\n    function getTokensData() public view returns (TokensData memory){\r\n        return TokensData(\r\n            totalGfam,\r\n            rewardBusdPool,\r\n            rewardDistributionBalance,\r\n            totaRequestedBusd,\r\n            ReferralClaimsBalance\r\n        );\r\n    }\r\n\r\n    function getCurrentDay() public view returns (uint){\r\n        return block.timestamp / 1 days;\r\n    }\r\n    \r\n    function getPrice(uint _amount) public view returns(uint){\r\n        return tokenTrade.getPrice(_amount);\r\n    }\r\n\r\n    function removeItemFromArray(Stake[] storage array, uint256 index) internal {\r\n        require(index < array.length, \"Invalid index\");\r\n        if (index < array.length - 1) {array[index] = array[array.length - 1];}\r\n        array.pop();\r\n    }   \r\n\r\n    //ADMIN\r\n    function setTokenTradeContract (address _addr) public onlyOwner {tokenTrade = ITokenTrade(_addr);}\r\n    function setFeesWallet (address _addr) public onlyOwner {feesWallet = _addr;}\r\n    function setRewardRate (uint _value) public onlyOwner {rewardRate = _value;}\r\n    function setFeesRate (uint _value) public onlyOwner {feesRate = _value;}\r\n    function setCommissionRate (uint _value) public onlyOwner {commissionRate = _value;}\r\n    function setReferral (address _user, address _ref) public onlyOwner {referrals[_user] = _ref;}\r\n    function setLockedRewardWithdraw (bool _value) public onlyOwner {lockedWithdrawReward = _value;}\r\n    function setLockedUnstake (bool _value) public onlyOwner {lockedUnstake = _value;}\r\n    function setAllowRef (bool _value) public onlyOwner {allowRef = _value;}\r\n    function setUserRef (address _user, address _ref) public onlyOwner {referrals[_user] = _ref;}\r\n    function setOffset (uint _value) public onlyOwner {offset = _value;}\r\n    function addToRewardPool (uint _value) public onlyOwner {\r\n        rewardBusdPool += _value;\r\n        earningDate = block.timestamp;\r\n    }\r\n    function substractFromRewardPool (uint _value) public onlyOwner {rewardBusdPool -= _value;}\r\n    //ADMIN\r\n    function busdBalance () public view returns(uint){return busdToken.balanceOf(address(this));}\r\n    function gfamBalance () public view returns(uint){return gfamToken.balanceOf(address(this));}\r\n    function withdrawGfam (uint _amount) public onlyOwner {gfamToken.transfer(msg.sender, _amount);}\r\n    function withdrawBusd (uint _amount) public onlyOwner {busdToken.transfer(msg.sender, _amount);}\r\n    function withdrawAllGfam () public onlyOwner {gfamToken.transfer(msg.sender, gfamBalance());}\r\n    function withdrawAllBusd () public onlyOwner {busdToken.transfer(msg.sender, busdBalance());}\r\n    //ALLOW\r\n    function pause() public onlyOwner {_pause();}\r\n    function unpause() public onlyOwner {_unpause();}\r\n    modifier onlyAllowedContract (){require(allowedContracts[msg.sender] == true);_;}\r\n    function allowContract ( address _addr ) onlyOwner public  {allowedContracts[_addr ] = true;}    \r\n    function disallowContract ( address _addr ) onlyOwner public  {allowedContracts[_addr ] = false;}    \r\n}\r\n\r\ninterface ITokenTrade {\r\n    function getPrice(uint256 _amount) external view returns (uint256);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_goal\",\"type\":\"uint256\"}],\"name\":\"claimEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gfamValue\",\"type\":\"uint256\"}],\"name\":\"claimRewardEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gfamValue\",\"type\":\"uint256\"}],\"name\":\"restakeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gfamValue\",\"type\":\"uint256\"}],\"name\":\"stakeEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ReferralClaimsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addToRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"adminSt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"allowContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowRef\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReferralCom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commissionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"disallowContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earningDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalReward\",\"type\":\"uint256\"}],\"name\":\"getRewardPatial\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalGfam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardBusdPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDistributionBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totaRequestedBusd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ReferralClaimsBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeGfamGetfitKai.TokensData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gfamBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gfamToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalGfamValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedUnstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedWithdrawReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralClaims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"restake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBusdPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDistributionBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setAllowRef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setCommissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setFeesRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeesWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setLockedRewardWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setLockedUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setOffset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"setReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTokenTradeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"setUserRef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gfamValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardGoal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardGoalNet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardClaimedNet\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ended\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakesPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"substractFromRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenTrade\",\"outputs\":[{\"internalType\":\"contract ITokenTrade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totaRequestedBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGfam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllBusd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllGfam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBusd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawGfam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeGfamGetfitKai", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://053541476f89e566f381f0fb6ec1938553afe4156cb4721ba538a06dad727ae1"}