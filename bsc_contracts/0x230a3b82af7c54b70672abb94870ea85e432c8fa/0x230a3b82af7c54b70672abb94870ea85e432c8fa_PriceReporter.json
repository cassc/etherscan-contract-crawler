{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/oracle/PriceReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.15;\\n\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\nimport {IOrderManager} from \\\"../interfaces/IOrderManager.sol\\\";\\n\\ninterface IPriceFeed {\\n    function postPrices(address[] calldata tokens, uint256[] calldata prices, uint256[] calldata timestamps) external;\\n}\\n\\n/**\\n * @title PriceReporter\\n * @notice Utility contract to call post prices and execute orders on a single transaction\\n */\\ncontract PriceReporter is Ownable {\\n    IPriceFeed public immutable oracle;\\n    IOrderManager public immutable orderManager;\\n    mapping(address => bool) public isReporter;\\n    address[] public reporters;\\n\\n    constructor(address _oracle, address _orderManager) {\\n        if (_oracle == address(0)) revert InvalidAddress();\\n        if (_orderManager == address(0)) revert InvalidAddress();\\n\\n        oracle = IPriceFeed(_oracle);\\n        orderManager = IOrderManager(_orderManager);\\n    }\\n\\n    function postPriceAndExecuteOrders(\\n        address[] calldata tokens,\\n        uint256[] calldata prices,\\n        uint256[] calldata priceTimestamps,\\n        uint256[] calldata leverageOrders,\\n        uint256[] calldata swapOrders,\\n        uint256[] calldata liquidityOrders\\n    ) external {\\n        if (!isReporter[msg.sender]) revert Unauthorized();\\n\\n        oracle.postPrices(tokens, prices, priceTimestamps);\\n\\n        for (uint256 i = 0; i < leverageOrders.length;) {\\n            try orderManager.executeOrder(leverageOrders[i], payable(msg.sender)) {} catch {}\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < swapOrders.length;) {\\n            try orderManager.executeSwapOrder(swapOrders[i], payable(msg.sender)) {} catch {}\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < liquidityOrders.length;) {\\n            try orderManager.executeLiquidityOrder(liquidityOrders[i], payable(msg.sender)) {} catch {}\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function addReporter(address reporter) external onlyOwner {\\n        if (reporter == address(0)) revert InvalidAddress();\\n        if (isReporter[reporter]) revert ReporterAlreadyAdded();\\n\\n        isReporter[reporter] = true;\\n        reporters.push(reporter);\\n    }\\n\\n    function removeReporter(address reporter) external onlyOwner {\\n        if (!isReporter[reporter]) revert ReporterNotExists();\\n\\n        isReporter[reporter] = false;\\n        for (uint256 i = 0; i < reporters.length; i++) {\\n            if (reporters[i] == reporter) {\\n                reporters[i] = reporters[reporters.length - 1];\\n                break;\\n            }\\n        }\\n        reporters.pop();\\n    }\\n\\n    error Unauthorized();\\n    error InvalidAddress();\\n    error ReporterAlreadyAdded();\\n    error ReporterNotExists();\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOrderManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.15;\\n\\nimport {IPool} from \\\"./IPool.sol\\\";\\n\\nstruct Order {\\n    IPool pool;\\n    address owner;\\n    address indexToken;\\n    address collateralToken;\\n    address payToken;\\n    uint256 expiresAt;\\n    uint256 submissionBlock;\\n    uint256 price;\\n    uint256 executionFee;\\n    bool triggerAboveThreshold;\\n}\\n\\nstruct SwapOrder {\\n    IPool pool;\\n    address owner;\\n    address tokenIn;\\n    address tokenOut;\\n    uint256 amountIn;\\n    uint256 minAmountOut;\\n    uint256 price;\\n    uint256 executionFee;\\n}\\n\\nenum OrderStatus {\\n    OPEN,\\n    FILLED,\\n    EXPIRED,\\n    CANCELLED\\n}\\n\\nstruct LiquidityOrder {\\n    bool isAddLiquidity;\\n    OrderStatus status;\\n    uint64 executionFee;\\n    address owner;\\n    address token;\\n    address lpToken;\\n    uint64 submissionTimestamp;\\n    address to;\\n    uint64 expiresAt;\\n    uint256 amountIn;\\n    uint256 minAmountOut;\\n}\\n\\ninterface IOrderManager {\\n    function orders(uint256 id) external view returns (Order memory);\\n\\n    function swapOrders(uint256 id) external view returns (SwapOrder memory);\\n\\n    function executeOrder(uint256 _key, address payable _feeTo) external;\\n\\n    function executeSwapOrder(uint256 _orderId, address payable _feeTo) external;\\n\\n    function executeLiquidityOrder(uint256 _orderId, address payable _feeTo) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport {SignedInt} from \\\"../lib/SignedInt.sol\\\";\\n\\nenum Side {\\n    LONG,\\n    SHORT\\n}\\n\\nstruct TokenWeight {\\n    address token;\\n    uint256 weight;\\n}\\n\\ninterface IPool {\\n    function increasePosition(\\n        address _account,\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _sizeChanged,\\n        Side _side\\n    ) external;\\n\\n    function decreasePosition(\\n        address _account,\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _desiredCollateralReduce,\\n        uint256 _sizeChanged,\\n        Side _side,\\n        address _receiver\\n    ) external;\\n\\n    function liquidatePosition(address _account, address _indexToken, address _collateralToken, Side _side) external;\\n\\n    function validateToken(address indexToken, address collateralToken, Side side, bool isIncrease)\\n        external\\n        view\\n        returns (bool);\\n\\n    function swap(address _tokenIn, address _tokenOut, uint256 _minOut, address _to, bytes calldata extradata)\\n        external;\\n\\n    function addLiquidity(address _tranche, address _token, uint256 _amountIn, uint256 _minLpAmount, address _to)\\n        external;\\n\\n    function removeLiquidity(address _tranche, address _tokenOut, uint256 _lpAmount, uint256 _minOut, address _to)\\n        external;\\n\\n    // =========== EVENTS ===========\\n    event SetOrderManager(address indexed orderManager);\\n    event IncreasePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        uint256 collateralValue,\\n        uint256 sizeChanged,\\n        Side side,\\n        uint256 indexPrice,\\n        uint256 feeValue\\n    );\\n    event UpdatePosition(\\n        bytes32 indexed key,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 entryPrice,\\n        uint256 entryInterestRate,\\n        uint256 reserveAmount,\\n        uint256 indexPrice\\n    );\\n    event DecreasePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        uint256 collateralChanged,\\n        uint256 sizeChanged,\\n        Side side,\\n        uint256 indexPrice,\\n        SignedInt pnl,\\n        uint256 feeValue\\n    );\\n    event ClosePosition(\\n        bytes32 indexed key,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 entryPrice,\\n        uint256 entryInterestRate,\\n        uint256 reserveAmount\\n    );\\n    event LiquidatePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        Side side,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 reserveAmount,\\n        uint256 indexPrice,\\n        SignedInt pnl,\\n        uint256 feeValue\\n    );\\n    event DaoFeeWithdrawn(address indexed token, address recipient, uint256 amount);\\n    event DaoFeeReduced(address indexed token, uint256 amount);\\n    event FeeDistributorSet(address indexed feeDistributor);\\n    event LiquidityAdded(\\n        address indexed tranche, address indexed sender, address token, uint256 amount, uint256 lpAmount, uint256 fee\\n    );\\n    event LiquidityRemoved(\\n        address indexed tranche, address indexed sender, address token, uint256 lpAmount, uint256 amountOut, uint256 fee\\n    );\\n    event TokenWeightSet(TokenWeight[]);\\n    event Swap(\\n        address indexed sender, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, uint256 fee\\n    );\\n    event PositionFeeSet(uint256 positionFee, uint256 liquidationFee);\\n    event DaoFeeSet(uint256 value);\\n    event SwapFeeSet(\\n        uint256 baseSwapFee, uint256 taxBasisPoint, uint256 stableCoinBaseSwapFee, uint256 stableCoinTaxBasisPoint\\n    );\\n    event InterestAccrued(address indexed token, uint256 borrowIndex);\\n    event MaxLeverageChanged(uint256 maxLeverage);\\n    event TokenWhitelisted(address indexed token);\\n    event TokenDelisted(address indexed token);\\n    event OracleChanged(address indexed oldOracle, address indexed newOracle);\\n    event InterestRateSet(uint256 interestRate, uint256 interval);\\n    event PoolHookChanged(address indexed hook);\\n    event TrancheAdded(address indexed lpToken);\\n    event TokenRiskFactorUpdated(address indexed token);\\n    event PnLDistributed(address indexed asset, address indexed tranche, uint256 amount, bool hasProfit);\\n    event MaintenanceMarginChanged(uint256 ratio);\\n    event AddRemoveLiquidityFeeSet(uint256 value);\\n    event MaxGlobalPositionSizeSet(address indexed token, uint256 maxLongRatios, uint256 maxShortSize);\\n    event PoolControllerChanged(address controller);\\n    event AssetRebalanced();\\n    event MaxLiquiditySet(address token, uint256 maxLiquidity);\\n    event SwapAllowanceChanged(address sender, bool allowed);\\n}\\n\"\r\n    },\r\n    \"src/lib/SignedInt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.0;\\n\\nimport {SafeCast} from \\\"../lib/SafeCast.sol\\\";\\n\\nuint256 constant POS = 1;\\nuint256 constant NEG = 0;\\n\\n/// SignedInt is integer number with sign. It value range is -(2 ^ 256 - 1) to (2 ^ 256 - 1)\\nstruct SignedInt {\\n    /// @dev sig = 1 -> positive, sig = 0 is negative\\n    /// using uint256 which take up full word to optimize gas and contract size\\n    uint256 sig;\\n    uint256 abs;\\n}\\n\\nlibrary SignedIntOps {\\n    using SafeCast for uint256;\\n\\n    function frac(int256 a, uint256 num, uint256 denom) internal pure returns (int256) {\\n        return a * num.toInt256() / denom.toInt256();\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return x < 0 ? uint256(-x) : uint256(x);\\n    }\\n\\n    function asTuple(int256 x) internal pure returns (SignedInt memory) {\\n        return SignedInt({abs: abs(x), sig: x < 0 ? NEG : POS});\\n    }\\n\\n    function lowerCap(int256 x, uint256 maxAbs) internal pure returns (int256) {\\n        int256 min = -maxAbs.toInt256();\\n        return x > min ? x : min;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/ma/SafeCast.solth)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Extract from OpenZeppelin SafeCast to shorten revert message\\n */\\nlibrary SafeCast {\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value < 0\\\");\\n        return uint256(value);\\n    }\\n\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value > int256.max\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orderManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReporterAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReporterNotExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reporter\",\"type\":\"address\"}],\"name\":\"addReporter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReporter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderManager\",\"outputs\":[{\"internalType\":\"contract IOrderManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceTimestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"leverageOrders\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"swapOrders\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"liquidityOrders\",\"type\":\"uint256[]\"}],\"name\":\"postPriceAndExecuteOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reporter\",\"type\":\"address\"}],\"name\":\"removeReporter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reporters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PriceReporter", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000347a868537c96650608b0c38a40d65fa8668bb61000000000000000000000000f584a17df21afd9de84f47842eceaf6042b1bb5b", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}