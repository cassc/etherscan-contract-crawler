{"SourceCode": "{\"HungerToken.sol\":{\"content\":\"// SPDX-License-Identifier: X11\\r\\n/*\\r\\n    ???  ??????   ???????   ??? ??????? ???????????????\\r\\n    ???  ??????   ????????  ??????????? ????????????????\\r\\n    ???????????   ????????? ??????  ??????????  ????????\\r\\n    ???????????   ????????????????   ?????????  ????????\\r\\n    ???  ??????????????? ??????????????????????????  ???\\r\\n    ???  ??? ??????? ???  ????? ??????? ???????????  ???\\r\\n\\r\\n            ????????? ??????? ???  ???????????????   ???\\r\\n            ????????????????????? ?????????????????  ???\\r\\n               ???   ???   ?????????? ??????  ?????? ???\\r\\n               ???   ???   ?????????? ??????  ??????????\\r\\n               ???   ????????????  ?????????????? ??????\\r\\n*/\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./ThirdParty.sol\\\";\\r\\n\\r\\ncontract HungerToken is Context, IERC20, Ownable {\\r\\n    using Address for address;\\r\\n\\r\\n    struct ContractRates {\\r\\n        uint16 combinedBuyRate;\\r\\n        uint16 reflectionBuyRate;\\r\\n        uint16 luckyShotBuyRate;\\r\\n        uint16 combinedSellRate;\\r\\n        uint16 reflectionSellRate;\\r\\n        uint16 luckyShotSellRate;\\r\\n        uint16 combinedSendRate;\\r\\n        uint16 antiWhaleRate;\\r\\n    }\\r\\n\\r\\n    struct IsExcluded {\\r\\n        bool fromFee;\\r\\n        bool fromReward;\\r\\n        bool forVendor;\\r\\n    }\\r\\n\\r\\n    struct LuckyShot {\\r\\n        bool enabled;\\r\\n        uint16 chanceToWin;\\r\\n        uint64 minimumSpendAmount;\\r\\n        uint128 minimumPoolThreshold;\\r\\n        address previousWinner;\\r\\n        uint256 previousWinAmount;\\r\\n        uint256 previousWinTime;\\r\\n        uint256 pool;\\r\\n        uint256 lastRoll;\\r\\n        uint256 rolls;\\r\\n    }\\r\\n\\r\\n    struct Reflections {\\r\\n        uint256 totalSupply;\\r\\n        uint256 inCirculation;\\r\\n        uint256 reflectionFeesEarned;\\r\\n    }\\r\\n\\r\\n    modifier LockSwap() {\\r\\n        _lockSwap = true;\\r\\n        _;\\r\\n        _lockSwap = false;\\r\\n    }\\r\\n\\r\\n    bool private _lockSwap;\\r\\n\\r\\n    ContractRates private _contractRates;\\r\\n\\r\\n    uint128 private constant _MAX = ~uint128(0);\\r\\n    uint128 private _tokenSupply = 10**9 * 10**9;\\r\\n\\r\\n    address private _pancakePair;\\r\\n    address private immutable _burnAddress =\\r\\n        0x000000000000000000000000000000000000dEaD;\\r\\n    address payable public charityAddress =\\r\\n        payable(0x580C0343cb96dd6B4E24Dbe516a5cAbF872A1e9f);\\r\\n    address payable public marketingAddress =\\r\\n        payable(0x8a8E03d0C8eA6451A883F27969Cd198D5Dfd371C);\\r\\n    address private _projectLayer2;\\r\\n\\r\\n    uint256 private _tokensForInitialSupport;\\r\\n\\r\\n    mapping(address =\\u003e IsExcluded) private _isExcluded;\\r\\n    mapping(address =\\u003e uint256) private _tokenBalance;\\r\\n    mapping(address =\\u003e uint256) private _reflectionBalance;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    Reflections private _reflections;\\r\\n    IPancakeRouter02 private _pancakeRouter;\\r\\n    LuckyShot private _luckyShot;\\r\\n\\r\\n    event TokensReflected(uint256 tokensReflected);\\r\\n    event SendToWallet(string wallet, address walletAddress, uint256 bnbForLP);\\r\\n    event AddLiquidity(uint256 tokensIn, uint256 bnbIn, address path);\\r\\n    event SwapTokensForBNB(uint128 amountIn, uint128 amountOut);\\r\\n    event SetRates(\\r\\n        uint16 combinedBuyRate,\\r\\n        uint16 reflectionBuyRate,\\r\\n        uint16 luckyShotBuyRate,\\r\\n        uint16 combinedSellRate,\\r\\n        uint16 reflectionSellRate,\\r\\n        uint16 luckyShotSellRate,\\r\\n        uint16 combinedSendRate,\\r\\n        uint16 antiWhaleRate\\r\\n    );\\r\\n    event SetRates(uint16 antiWhalerate);\\r\\n    event LuckyShotWon(\\r\\n        address indexed winner,\\r\\n        uint256 indexed blockTime,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\\r\\n             0x10ED43C718714eb63d5aA57B78B54704E256024E // (mainnet)\\r\\n           // 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3 // (testnet router)\\r\\n        );\\r\\n        _pancakeRouter = pancakeRouter;\\r\\n        address pancakePair = IPancakeFactory(pancakeRouter.factory())\\r\\n            .createPair(address(this), pancakeRouter.WETH());\\r\\n        _pancakePair = pancakePair;\\r\\n\\r\\n        __approveAllowance(address(this), address(pancakeRouter), ~uint256(0));\\r\\n\\r\\n        _isExcluded[marketingAddress].fromFee = true;\\r\\n        _isExcluded[owner()].fromFee = true;\\r\\n\\r\\n        _isExcluded[_burnAddress].fromReward = true;\\r\\n        _isExcluded[pancakePair].fromReward = true;\\r\\n        _isExcluded[marketingAddress].fromReward = true;\\r\\n        _isExcluded[address(this)].fromReward = true;\\r\\n\\r\\n        uint128 initialSupportTokens = (_tokenSupply * 10000) / 100000;\\r\\n        _tokensForInitialSupport = initialSupportTokens;\\r\\n\\r\\n        _tokenBalance[address(this)] = initialSupportTokens; // 10% of initial supply\\r\\n        _tokenBalance[marketingAddress] = _tokenSupply - initialSupportTokens;\\r\\n\\r\\n        _projectLayer2 = address(this);\\r\\n\\r\\n        emit Transfer(address(0), address(this), _tokenBalance[address(this)]);\\r\\n        emit Transfer(\\r\\n            address(0),\\r\\n            marketingAddress,\\r\\n            _tokenBalance[marketingAddress]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function transfer(address to, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        __verify(_msgSender(), to);\\r\\n        __transfer(_msgSender(), to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[from][_msgSender()];\\r\\n\\r\\n        __transfer(from, to, amount);\\r\\n\\r\\n        if (currentAllowance \\u003c ~uint256(0)) {\\r\\n            __approveAllowance(\\r\\n                from,\\r\\n                _msgSender(),\\r\\n                _allowances[from][_msgSender()] -= amount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        __approveAllowance(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue)\\r\\n        external\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        __approveAllowance(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender] += addedValue\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n        external\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        if (subtractedValue \\u003e _allowances[_msgSender()][spender]) {\\r\\n            subtractedValue = _allowances[_msgSender()][spender]; // Zero\\u0027s out the allowance\\r\\n        }\\r\\n\\r\\n        __approveAllowance(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender] -= subtractedValue\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// Only Owner methods\\r\\n    /**\\r\\n     * Can only be in 1 fee list\\r\\n     * @param listIndex 0 = 0% fee list; 1 = 3% vendor list\\r\\n     */\\r\\n    function _addToFeeList(uint8 listIndex, address account)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(listIndex \\u003c= 1, \\\"Index too high\\\");\\r\\n\\r\\n        if (listIndex == 0) {\\r\\n            _isExcluded[account].fromFee = true;\\r\\n            _isExcluded[account].forVendor = false;\\r\\n        } else if (listIndex == 1) {\\r\\n            _isExcluded[account].forVendor = true;\\r\\n            _isExcluded[account].fromFee = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Include address back in a transactions fees\\r\\n     */\\r\\n    function _removeFromFeeLists(address account) external onlyOwner {\\r\\n        _isExcluded[account].fromFee = false;\\r\\n        _isExcluded[account].forVendor = false;\\r\\n    }\\r\\n\\r\\n    function _addToRewards(address account) external onlyOwner {\\r\\n        require(_isExcluded[account].fromReward, \\\"Account is already included\\\");\\r\\n\\r\\n        uint256 tokenBalance = _tokenBalance[account];\\r\\n\\r\\n        if (tokenBalance \\u003e 0) {\\r\\n            _reflectionBalance[account] = tokenBalance * __getReflectionRate();\\r\\n\\r\\n            _reflections.inCirculation += _reflectionBalance[account];\\r\\n            _reflections.totalSupply += tokenBalance;\\r\\n\\r\\n            _tokenBalance[account] = 0;\\r\\n        }\\r\\n        _isExcluded[account].fromReward = false;\\r\\n    }\\r\\n\\r\\n    function _removeFromRewards(address account) external onlyOwner {\\r\\n        require(\\r\\n            !_isExcluded[account].fromReward,\\r\\n            \\\"Account is already excluded\\\"\\r\\n        );\\r\\n\\r\\n        uint256 reflectionBalance = _reflectionBalance[account];\\r\\n\\r\\n        if (reflectionBalance \\u003e 0) {\\r\\n            _tokenBalance[account] = reflectionBalance / __getReflectionRate();\\r\\n\\r\\n            unchecked {\\r\\n                _reflections.inCirculation -= reflectionBalance;\\r\\n                _reflections.totalSupply -= _tokenBalance[account];\\r\\n            }\\r\\n\\r\\n            _reflectionBalance[account] = 0;\\r\\n        }\\r\\n        _isExcluded[account].fromReward = true;\\r\\n    }\\r\\n\\r\\n    function _setContractRates(\\r\\n        uint16 combinedBuyRate,\\r\\n        uint16 reflectionBuyRate,\\r\\n        uint16 luckyShotBuyRate,\\r\\n        uint16 combinedSellRate,\\r\\n        uint16 reflectionSellRate,\\r\\n        uint16 luckyShotSellRate,\\r\\n        uint16 combinedSendRate,\\r\\n        uint16 antiWhaleRate\\r\\n    ) external onlyOwner {\\r\\n        ContractRates storage contractRates = _contractRates;\\r\\n\\r\\n        require(\\r\\n            combinedBuyRate \\u003c= 15000 \\u0026\\u0026 combinedSellRate \\u003c= 15000,\\r\\n            \\\"Combined Sell/Buy Fee Rate must be equal to or lower than 15% (15000)\\\"\\r\\n        );\\r\\n        require(\\r\\n            combinedSendRate \\u003c= 10000,\\r\\n            \\\"Send Fee Rate must be equal to or lower than 10% (10000)\\\"\\r\\n        );\\r\\n        require(\\r\\n            reflectionBuyRate \\u003c= 5000 \\u0026\\u0026\\r\\n                luckyShotBuyRate \\u003c= 5000 \\u0026\\u0026\\r\\n                reflectionSellRate \\u003c= 5000 \\u0026\\u0026\\r\\n                luckyShotSellRate \\u003c= 5000,\\r\\n            \\\"Reflection/LuckyShot Pool Fee Rate must be equal to or lower than 6% (6000)\\\"\\r\\n        );\\r\\n\\r\\n        contractRates.combinedBuyRate = combinedBuyRate;\\r\\n        contractRates.reflectionBuyRate = reflectionBuyRate;\\r\\n        contractRates.luckyShotBuyRate = luckyShotBuyRate;\\r\\n\\r\\n        contractRates.combinedSellRate = combinedSellRate;\\r\\n        contractRates.reflectionSellRate = reflectionSellRate;\\r\\n        contractRates.luckyShotSellRate = luckyShotSellRate;\\r\\n\\r\\n        contractRates.combinedSendRate = combinedSendRate;\\r\\n\\r\\n        contractRates.antiWhaleRate = antiWhaleRate;\\r\\n\\r\\n        emit SetRates(\\r\\n            combinedBuyRate,\\r\\n            reflectionBuyRate,\\r\\n            luckyShotBuyRate,\\r\\n            combinedSellRate,\\r\\n            reflectionSellRate,\\r\\n            luckyShotSellRate,\\r\\n            combinedSendRate,\\r\\n            antiWhaleRate\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// Same as setting _setContractRates(7, 0)\\r\\n    function _turnOffAntiWhale() external onlyOwner {\\r\\n        _contractRates.antiWhaleRate = 0;\\r\\n\\r\\n        emit SetRates(0);\\r\\n    }\\r\\n\\r\\n    function _setCharityAddress(address newAddress) external onlyOwner {\\r\\n        charityAddress = payable(newAddress);\\r\\n    }\\r\\n\\r\\n    function _setMarketingAddress(address newAddress) external onlyOwner {\\r\\n        marketingAddress = payable(newAddress);\\r\\n    }\\r\\n\\r\\n    function _setProjectLayer2Address(address layer2Address)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(layer2Address.isContract(), \\\"Address must be a contract\\\");\\r\\n\\r\\n        _isExcluded[layer2Address].fromReward = true;\\r\\n        _isExcluded[layer2Address].fromFee = true;\\r\\n        _projectLayer2 = layer2Address;\\r\\n    }\\r\\n\\r\\n    /// Configures default rates\\r\\n    function _setsDefaultRates() external onlyOwner {\\r\\n        _contractRates.combinedBuyRate = 9000;\\r\\n        _contractRates.reflectionBuyRate = 2000;\\r\\n        _contractRates.luckyShotBuyRate = 1000;\\r\\n        _contractRates.combinedSellRate = 12000;\\r\\n        _contractRates.reflectionSellRate = 3000;\\r\\n        _contractRates.luckyShotSellRate = 1000;\\r\\n        _contractRates.combinedSendRate = 6000;\\r\\n        _contractRates.antiWhaleRate = 2000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Will sell given amount of tokens to be used by `useContractBNB`\\r\\n     */\\r\\n    function _spendAvailableFunds(uint256 amount) external onlyOwner {\\r\\n        if (!_lockSwap) {\\r\\n            uint256 tokensMinusInitialSupport;\\r\\n            unchecked {\\r\\n                tokensMinusInitialSupport =\\r\\n                    _tokenBalance[address(this)] -\\r\\n                    _tokensForInitialSupport;\\r\\n            }\\r\\n\\r\\n            require(\\r\\n                tokensMinusInitialSupport \\u003e= amount \\u0026\\u0026\\r\\n                    _tokenBalance[address(this)] \\u003e= amount,\\r\\n                \\\"Not enough tokens allowed for swapping\\\"\\r\\n            );\\r\\n\\r\\n            __swapTokens(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Uses given rates to determine where BNB from the contract is going\\r\\n     * RATES should be simple small versions totaling to 100 or less. (ex: 25 = 25%).\\r\\n     *\\r\\n     * Rates do not need to equal 100 or all be used here are some examples:\\r\\n     *\\r\\n     * useContractBNB(30, 30, 30, 5, \\u003crandom avaiable BNB amount\\u003e);\\r\\n     * This will leave 5% BNB inside the contract.\\r\\n     *\\r\\n     * useContractBNB(0, 0, 75, 0, \\u003crandom avaiable BNB amount\\u003e);\\r\\n     * This buyback using 75% of the BNB supply, 25% remains\\r\\n     */\\r\\n    function _useContractBNB(\\r\\n        uint128 charityRate,\\r\\n        uint128 marketingRate,\\r\\n        uint128 buybackRate,\\r\\n        uint128 liquidityRate,\\r\\n        uint256 amount\\r\\n    ) external onlyOwner {\\r\\n        if (!_lockSwap) {\\r\\n            require(\\r\\n                address(this).balance \\u003e= amount,\\r\\n                \\\"Not enough BNB in the contract\\\"\\r\\n            );\\r\\n            require(\\r\\n                charityRate + marketingRate + buybackRate + liquidityRate \\u003c=\\r\\n                    100,\\r\\n                \\\"Total must be less than 100%\\\"\\r\\n            );\\r\\n\\r\\n            bool success;\\r\\n\\r\\n            if (charityRate \\u003e 0) {\\r\\n                uint256 charityBNB = (amount * (charityRate * 1000)) / 100000;\\r\\n\\r\\n                (success, ) = charityAddress.call{value: charityBNB}(\\r\\n                    new bytes(0)\\r\\n                );\\r\\n\\r\\n                if (success)\\r\\n                    emit SendToWallet(\\\"Charity\\\", charityAddress, charityBNB);\\r\\n            }\\r\\n\\r\\n            if (marketingRate \\u003e 0) {\\r\\n                uint256 marketingBNB = (amount * (marketingRate * 1000)) /\\r\\n                    100000;\\r\\n\\r\\n                (success, ) = marketingAddress.call{value: marketingBNB}(\\r\\n                    new bytes(0)\\r\\n                );\\r\\n\\r\\n                if (success)\\r\\n                    emit SendToWallet(\\r\\n                        \\\"Marketing\\\",\\r\\n                        marketingAddress,\\r\\n                        marketingBNB\\r\\n                    );\\r\\n            }\\r\\n\\r\\n            if (buybackRate \\u003e 0) {\\r\\n                __buybackAndBurn(buybackRate, amount);\\r\\n            }\\r\\n\\r\\n            if (liquidityRate \\u003e 0) {\\r\\n                uint256 amountAvailable;\\r\\n                uint256 tokensForInitialSupport = _tokensForInitialSupport;\\r\\n                uint256 liquidtyFee = (amount * (liquidityRate * 1000)) /\\r\\n                    100000;\\r\\n\\r\\n                if (tokensForInitialSupport \\u003e= liquidtyFee) {\\r\\n                    amountAvailable = tokensForInitialSupport;\\r\\n                    _tokensForInitialSupport -= liquidtyFee;\\r\\n                } else {\\r\\n                    unchecked {\\r\\n                        amountAvailable =\\r\\n                            _tokenBalance[address(this)] -\\r\\n                            tokensForInitialSupport;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (amountAvailable \\u003e 0)\\r\\n                    __addLiquidity(amountAvailable, liquidtyFee);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// Burn tokens from the initial support stream(0) or extra tokens in contract(1)\\r\\n    function burnTokens(uint8 index, uint64 amount) external onlyOwner {\\r\\n        require(index \\u003c= 1, \\\"Index must be 0 or 1\\\");\\r\\n        uint256 tokensMinusInitialSupport;\\r\\n\\r\\n        unchecked {\\r\\n            tokensMinusInitialSupport =\\r\\n                _tokenBalance[address(this)] -\\r\\n                _tokensForInitialSupport;\\r\\n        }\\r\\n\\r\\n        if (index == 0) {\\r\\n            require(\\r\\n                _tokenBalance[address(this)] \\u003e= amount \\u0026\\u0026\\r\\n                    _tokensForInitialSupport \\u003e= amount,\\r\\n                \\\"Balance must be greater than amount\\\"\\r\\n            );\\r\\n\\r\\n            __burn(amount);\\r\\n            _tokensForInitialSupport -= amount;\\r\\n        } else if (tokensMinusInitialSupport \\u003e= amount) {\\r\\n            __burn(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Setup Lucky Shot variables, must turn fees to 0 or POOL will still get tokens.\\r\\n     *\\r\\n     * @param chance Chance BUYER has to win, the higher the chance the easier to win\\r\\n     * @param enabled Enable or disable the luckyShot functionality\\r\\n     * @param minimumSpendAmount Amount of tokens needed to be spend by BUYER for CHANCE to win.\\r\\n     * @param minimumTokensAccumulated Minimum number of tokens accumulated in the POOL before the luckyShot can be triggered\\r\\n     */\\r\\n    function luckyShotConfig(\\r\\n        bool enabled,\\r\\n        uint16 chance,\\r\\n        uint64 minimumSpendAmount,\\r\\n        uint128 minimumTokensAccumulated\\r\\n    ) external onlyOwner {\\r\\n        require(chance \\u003c= 65535, \\\"Chance must be less than max settable\\\");\\r\\n\\r\\n        _luckyShot.enabled = enabled;\\r\\n        _luckyShot.chanceToWin = chance;\\r\\n        _luckyShot.minimumSpendAmount = minimumSpendAmount;\\r\\n        _luckyShot.minimumPoolThreshold = minimumTokensAccumulated;\\r\\n    }\\r\\n\\r\\n    function pancakePairAddress(address newPair) external onlyOwner {\\r\\n        _pancakePair = newPair;\\r\\n    }\\r\\n\\r\\n    function pancakeRouterAddress(address newRouter) external onlyOwner {\\r\\n        /// If using a new version it may not be compatible\\r\\n        /// we will force it to use the V2 interface since that is what this contract is using.\\r\\n        _pancakeRouter = IPancakeRouter02(newRouter);\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (_isExcluded[account].fromReward) return _tokenBalance[account];\\r\\n        return _reflectionBalance[account] / __getReflectionRate();\\r\\n    }\\r\\n\\r\\n    function isExcludedFromReward(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _isExcluded[account].fromReward;\\r\\n    }\\r\\n\\r\\n    function getFeeStatus(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        string memory feesExcludedFrom;\\r\\n\\r\\n        if (_isExcluded[account].fromFee) {\\r\\n            feesExcludedFrom = \\\"Excluded from All Fees\\\";\\r\\n        } else if (_isExcluded[account].forVendor) {\\r\\n            feesExcludedFrom = \\\"Has Vendor Fee\\\";\\r\\n        }\\r\\n\\r\\n        return feesExcludedFrom;\\r\\n    }\\r\\n\\r\\n    function burnAddress() external view returns (address) {\\r\\n        return _burnAddress;\\r\\n    }\\r\\n\\r\\n    function circulatingSupply() external view returns (uint256) {\\r\\n        return _tokenSupply - _tokenBalance[_burnAddress];\\r\\n    }\\r\\n\\r\\n    function getContractRates() external view returns (ContractRates memory) {\\r\\n        return\\r\\n            ContractRates(\\r\\n                _contractRates.combinedBuyRate,\\r\\n                _contractRates.reflectionBuyRate,\\r\\n                _contractRates.luckyShotBuyRate,\\r\\n                _contractRates.combinedSellRate,\\r\\n                _contractRates.reflectionSellRate,\\r\\n                _contractRates.luckyShotSellRate,\\r\\n                _contractRates.combinedSendRate,\\r\\n                _contractRates.antiWhaleRate\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getLuckyShot() external view returns (LuckyShot memory) {\\r\\n        return\\r\\n            LuckyShot(\\r\\n                _luckyShot.enabled,\\r\\n                _luckyShot.chanceToWin,\\r\\n                _luckyShot.minimumSpendAmount,\\r\\n                _luckyShot.minimumPoolThreshold,\\r\\n                _luckyShot.previousWinner,\\r\\n                _luckyShot.previousWinAmount,\\r\\n                _luckyShot.previousWinTime,\\r\\n                _luckyShot.pool,\\r\\n                _luckyShot.lastRoll,\\r\\n                _luckyShot.rolls\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getLayer2Address() external view returns (address) {\\r\\n        return _projectLayer2;\\r\\n    }\\r\\n\\r\\n    function getPancakePair() external view returns (address) {\\r\\n        return _pancakePair;\\r\\n    }\\r\\n\\r\\n    function getPancakeRouter() external view returns (address) {\\r\\n        return address(_pancakeRouter);\\r\\n    }\\r\\n\\r\\n    function getTokenAmountFromReflection(uint256 amount)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return amount / __getReflectionRate();\\r\\n    }\\r\\n\\r\\n    function getReflectionAmountFromToken(uint256 amount)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 reflectedAmount)\\r\\n    {\\r\\n        reflectedAmount = amount * __getReflectionRate();\\r\\n    }\\r\\n\\r\\n    function initialSupportFunds() external view returns (uint256) {\\r\\n        return _tokensForInitialSupport;\\r\\n    }\\r\\n\\r\\n    // Conveniently displays actual token pool minus its decimal places\\r\\n    function luckyShotTokens() external view returns (uint256) {\\r\\n        return _luckyShot.pool / 10**9;\\r\\n    }\\r\\n\\r\\n    function projectFundsAvailable() external view returns (uint256) {\\r\\n        return _tokenBalance[address(this)] - _tokensForInitialSupport;\\r\\n    }\\r\\n\\r\\n    function totalReflectionsEarned() external view returns (uint256) {\\r\\n        return _reflections.reflectionFeesEarned;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _tokenSupply;\\r\\n    }\\r\\n\\r\\n    function name() external pure returns (string memory) {\\r\\n        return \\\"Hunger Token\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure returns (string memory) {\\r\\n        return \\\"HUNGER\\\";\\r\\n    }\\r\\n\\r\\n    function decimals() external pure returns (uint256) {\\r\\n        return 9;\\r\\n    }\\r\\n\\r\\n    function __approveAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        __verify(owner, spender);\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function __transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        uint256 reflectionRate = __getReflectionRate();\\r\\n        require(\\r\\n            _reflectionBalance[from] / reflectionRate \\u003e= amount ||\\r\\n                _tokenBalance[from] \\u003e= amount,\\r\\n            \\\"Balance must be greater than amount\\\"\\r\\n        );\\r\\n\\r\\n        bool luckyShotEnabled;\\r\\n        address tokenWallet = _projectLayer2;\\r\\n        uint256 reflectionFee;\\r\\n        uint256 luckyShotFee;\\r\\n        uint256 tokensForSelling;\\r\\n        IsExcluded memory isExcludedFrom = _isExcluded[from];\\r\\n        IsExcluded memory isExcludedTo = _isExcluded[to];\\r\\n        LuckyShot memory luckyShot = _luckyShot;\\r\\n\\r\\n        luckyShotEnabled =\\r\\n            luckyShot.enabled \\u0026\\u0026\\r\\n            luckyShot.pool \\u003e= luckyShot.minimumPoolThreshold \\u0026\\u0026\\r\\n            amount \\u003e= luckyShot.minimumSpendAmount;\\r\\n\\r\\n        if (!_lockSwap \\u0026\\u0026 !(isExcludedFrom.fromFee || isExcludedTo.fromFee)) {\\r\\n            (\\r\\n                tokensForSelling,\\r\\n                reflectionFee,\\r\\n                luckyShotFee\\r\\n            ) = __splitAndDetermineFees(\\r\\n                from,\\r\\n                to,\\r\\n                amount,\\r\\n                [isExcludedFrom, isExcludedTo]\\r\\n            );\\r\\n\\r\\n            if (luckyShotFee \\u003e 0) _luckyShot.pool += luckyShotFee;\\r\\n        }\\r\\n\\r\\n        __transferAndReflect(\\r\\n            from,\\r\\n            to,\\r\\n            amount,\\r\\n            tokensForSelling + luckyShotFee,\\r\\n            reflectionFee,\\r\\n            reflectionRate,\\r\\n            [isExcludedFrom, isExcludedTo]\\r\\n        );\\r\\n\\r\\n        if (luckyShotEnabled \\u0026\\u0026 from == _pancakePair) {\\r\\n            _luckyShot.lastRoll = __roll();\\r\\n            _luckyShot.rolls++;\\r\\n            __handleLuckyShot(isExcludedTo.fromReward, to);\\r\\n        }\\r\\n\\r\\n        /// Take Fees\\r\\n        if (tokensForSelling \\u003e 0) {\\r\\n            _tokenBalance[tokenWallet] += tokensForSelling;\\r\\n            emit Transfer(from, tokenWallet, tokensForSelling);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function __transferAndReflect(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 tokenFees,\\r\\n        uint256 reflectionFee,\\r\\n        uint256 reflectionRate,\\r\\n        IsExcluded[2] memory isExcluded\\r\\n    ) private {\\r\\n        uint256 antiWhaleRate = _contractRates.antiWhaleRate;\\r\\n        bool antiWhaleCheck = antiWhaleRate \\u003e 0 \\u0026\\u0026 // Anti-whale Rate\\r\\n            to != _pancakePair \\u0026\\u0026\\r\\n            to != _burnAddress \\u0026\\u0026\\r\\n            to != address(this);\\r\\n        uint256 amountMinusFees = amount - tokenFees - reflectionFee;\\r\\n        Reflections storage reflections = _reflections;\\r\\n\\r\\n        /// Take total amount from sender\\r\\n        if (!isExcluded[0].fromReward) {\\r\\n            _reflectionBalance[from] -= (amount * reflectionRate);\\r\\n\\r\\n            if (isExcluded[1].fromReward) {\\r\\n                unchecked {\\r\\n                    reflections.inCirculation -= ((amount - reflectionFee) *\\r\\n                        reflectionRate);\\r\\n                    reflections.totalSupply -= (amount - reflectionFee);\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            _tokenBalance[from] -= amount;\\r\\n\\r\\n            if (!isExcluded[1].fromReward) {\\r\\n                reflections.inCirculation += ((amount - tokenFees) *\\r\\n                    reflectionRate);\\r\\n                reflections.totalSupply += (amount - tokenFees);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        /// Give amount minus fees to receiver\\r\\n        if (!isExcluded[1].fromReward) {\\r\\n            _reflectionBalance[to] += (amountMinusFees * reflectionRate);\\r\\n\\r\\n            if (antiWhaleCheck) {\\r\\n                require(\\r\\n                    _reflectionBalance[to] / reflectionRate \\u003c=\\r\\n                        ((_tokenSupply - _tokenBalance[_burnAddress]) *\\r\\n                            antiWhaleRate) /\\r\\n                            100000,\\r\\n                    \\\"Receiver Reflection balance exceeds holder limit\\\"\\r\\n                );\\r\\n            }\\r\\n        } else {\\r\\n            _tokenBalance[to] += amountMinusFees;\\r\\n\\r\\n            if (antiWhaleCheck) {\\r\\n                require(\\r\\n                    _tokenBalance[to] \\u003c=\\r\\n                        ((_tokenSupply - _tokenBalance[_burnAddress]) *\\r\\n                            antiWhaleRate) /\\r\\n                            100000,\\r\\n                    \\\"Receiver Token balance exceeds holder limit\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amountMinusFees);\\r\\n\\r\\n        if (reflectionFee \\u003e 0) {\\r\\n            uint256 reflectionFeeWithRate = reflectionFee *\\r\\n                __getReflectionRate();\\r\\n            if (reflections.inCirculation \\u003e= reflectionFeeWithRate)\\r\\n                reflections.inCirculation -= reflectionFeeWithRate;\\r\\n\\r\\n            reflections.reflectionFeesEarned += reflectionFee;\\r\\n            emit TokensReflected(reflectionFee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function __handleLuckyShot(bool isExcludedFromRewardCheck, address to)\\r\\n        private\\r\\n    {\\r\\n        uint256 timestamp = block.timestamp;\\r\\n        uint256 luckyShotRewardsCollected;\\r\\n        LuckyShot storage luckyShot = _luckyShot;\\r\\n\\r\\n        luckyShotRewardsCollected = luckyShot.pool;\\r\\n\\r\\n        if (luckyShot.lastRoll \\u003c= luckyShot.chanceToWin) {\\r\\n            if (!isExcludedFromRewardCheck) {\\r\\n                _reflectionBalance[to] += (luckyShotRewardsCollected *\\r\\n                    __getReflectionRate());\\r\\n\\r\\n                _reflections.inCirculation += (luckyShotRewardsCollected *\\r\\n                    __getReflectionRate());\\r\\n                _reflections.totalSupply += luckyShotRewardsCollected;\\r\\n            } else {\\r\\n                _tokenBalance[to] += luckyShotRewardsCollected;\\r\\n            }\\r\\n\\r\\n            emit Transfer(address(this), to, luckyShotRewardsCollected);\\r\\n            emit LuckyShotWon(to, timestamp, luckyShotRewardsCollected);\\r\\n\\r\\n            luckyShot.pool = 0;\\r\\n            luckyShot.previousWinner = to;\\r\\n            luckyShot.previousWinAmount = luckyShotRewardsCollected;\\r\\n            luckyShot.previousWinTime = timestamp;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// Generates a random number between 1 and 1000\\r\\n    function __roll() private view returns (uint256 randomNumber) {\\r\\n        randomNumber = uint256(\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        block.difficulty,\\r\\n                        block.timestamp,\\r\\n                        _luckyShot.lastRoll\\r\\n                    )\\r\\n                )\\r\\n            ) % 1000\\r\\n        );\\r\\n\\r\\n        randomNumber += 1;\\r\\n    }\\r\\n\\r\\n    function __swapTokens(uint256 amount) private LockSwap {\\r\\n        uint256 initialBnb = address(this).balance;\\r\\n\\r\\n        // generate the Pancake pair path of token -\\u003e weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _pancakeRouter.WETH();\\r\\n\\r\\n        // make the swap\\r\\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        if (address(this).balance \\u003e initialBnb) {\\r\\n            emit SwapTokensForBNB(\\r\\n                uint128(amount),\\r\\n                uint128(address(this).balance - initialBnb)\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function __buybackAndBurn(uint128 buybackRate, uint256 amount)\\r\\n        private\\r\\n        LockSwap\\r\\n    {\\r\\n        uint256 buybackBNB = (amount * (buybackRate * 1000)) / 100000;\\r\\n\\r\\n        if (address(this).balance \\u003e= buybackBNB) {\\r\\n            // generate the Pancake pair path of token -\\u003e weth\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = _pancakeRouter.WETH();\\r\\n            path[1] = address(this);\\r\\n\\r\\n            // make the swap\\r\\n            _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\\r\\n                value: buybackBNB\\r\\n            }(\\r\\n                0, // accept any amount of Tokens\\r\\n                path,\\r\\n                _burnAddress,\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function __addLiquidity(uint256 tokensAvailable, uint256 bnbAmount)\\r\\n        private\\r\\n        LockSwap\\r\\n    {\\r\\n        (uint128 tokenA, uint128 tokenB) = __getReserves();\\r\\n        uint256 tokenQuote = uint256(\\r\\n            _pancakeRouter.quote(bnbAmount, tokenB, tokenA)\\r\\n        );\\r\\n\\r\\n        if (tokensAvailable \\u003c tokenQuote) {\\r\\n            uint256 bnbQuote = uint256(\\r\\n                _pancakeRouter.quote(tokensAvailable, tokenA, tokenB)\\r\\n            );\\r\\n\\r\\n            if (address(this).balance \\u003e= bnbQuote) {\\r\\n                bnbAmount = bnbQuote;\\r\\n                tokenQuote = tokensAvailable;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (tokensAvailable \\u003e= tokenQuote) {\\r\\n            _pancakeRouter.addLiquidityETH{value: bnbAmount}(\\r\\n                address(this),\\r\\n                tokenQuote,\\r\\n                0,\\r\\n                0,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n\\r\\n            emit AddLiquidity(tokenQuote, bnbAmount, _pancakePair);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function __burn(uint64 amount) private {\\r\\n        if (_tokenBalance[address(this)] \\u003e= amount) {\\r\\n            _tokenBalance[address(this)] -= amount;\\r\\n            _tokenBalance[_burnAddress] += amount;\\r\\n\\r\\n            emit Transfer(address(this), _burnAddress, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function __getReserves()\\r\\n        private\\r\\n        view\\r\\n        returns (uint128 reserveA, uint128 reserveB)\\r\\n    {\\r\\n        address tokenA = address(this);\\r\\n        (address token0, ) = sortTokens(tokenA, _pancakeRouter.WETH());\\r\\n        (uint128 reserve0, uint128 reserve1, ) = IPancakePair(_pancakePair)\\r\\n            .getReserves();\\r\\n        (reserveA, reserveB) = tokenA == token0\\r\\n            ? (reserve0, reserve1)\\r\\n            : (reserve1, reserve0);\\r\\n    }\\r\\n\\r\\n    function __getReflectionRate() private view returns (uint256) {\\r\\n        if (\\r\\n            _reflections.inCirculation \\u003e 0 \\u0026\\u0026\\r\\n            _reflections.inCirculation \\u003e= _reflections.totalSupply\\r\\n        ) {\\r\\n            return _reflections.inCirculation / _reflections.totalSupply;\\r\\n        } else {\\r\\n            return (_MAX - (_MAX % _tokenSupply)) / _tokenSupply;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function __splitAndDetermineFees(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        IsExcluded[2] memory isExcluded\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            uint256 tokensForSellFee,\\r\\n            uint256 reflectionFee,\\r\\n            uint256 luckyShotFee\\r\\n        )\\r\\n    {\\r\\n        uint32 denominator = 100000;\\r\\n        (\\r\\n            uint256 tokensForSellRate,\\r\\n            uint256 reflectionRate,\\r\\n            uint256 luckyShotRate\\r\\n        ) = __getRates(from, to, isExcluded);\\r\\n\\r\\n        if (tokensForSellRate \\u003e 0)\\r\\n            tokensForSellFee = (amount * tokensForSellRate) / denominator;\\r\\n\\r\\n        if (reflectionRate \\u003e 0)\\r\\n            reflectionFee = (amount * reflectionRate) / denominator;\\r\\n\\r\\n        if (luckyShotRate \\u003e 0)\\r\\n            luckyShotFee = (amount * luckyShotRate) / denominator;\\r\\n    }\\r\\n\\r\\n    function __getRates(\\r\\n        address from,\\r\\n        address to,\\r\\n        IsExcluded[2] memory isExcluded\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            uint16 tokensForSellRate,\\r\\n            uint16 reflectionRate,\\r\\n            uint16 luckyShotRate\\r\\n        )\\r\\n    {\\r\\n        ContractRates memory contractRates = _contractRates;\\r\\n\\r\\n        if (isExcluded[0].forVendor || isExcluded[1].forVendor) {\\r\\n            tokensForSellRate = 3000;\\r\\n        } else {\\r\\n            /// Buy\\r\\n            if (from == _pancakePair) {\\r\\n                tokensForSellRate = contractRates.combinedBuyRate;\\r\\n                reflectionRate = contractRates.reflectionBuyRate;\\r\\n                luckyShotRate = contractRates.luckyShotBuyRate;\\r\\n\\r\\n                /// Sell\\r\\n            } else if (to == _pancakePair) {\\r\\n                tokensForSellRate = contractRates.combinedSellRate;\\r\\n                reflectionRate = contractRates.reflectionSellRate;\\r\\n                luckyShotRate = contractRates.luckyShotSellRate;\\r\\n            } else {\\r\\n                tokensForSellRate = contractRates.combinedSendRate;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function sortTokens(address tokenA, address tokenB)\\r\\n        private\\r\\n        pure\\r\\n        returns (address token0, address token1)\\r\\n    {\\r\\n        (token0, token1) = tokenA \\u003c tokenB\\r\\n            ? (tokenA, tokenB)\\r\\n            : (tokenB, tokenA);\\r\\n    }\\r\\n\\r\\n    function __verify(address from, address to) private pure {\\r\\n        require(from != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n\"},\"ThirdParty.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n\\n            if (returndata.length \\u003e 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n    address private _previousOwner;\\n    uint256 private _lockTime;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership(bool renounceGuard) external virtual onlyOwner {\\n        require(renounceGuard == true, \\\"Please set to true to renounce\\\");\\n\\n        _owner = address(0);\\n        emit OwnershipTransferred(_owner, address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _owner = newOwner;\\n        emit OwnershipTransferred(_owner, newOwner);\\n    }\\n\\n    function getUnlockTime() external view returns (uint256) {\\n        return _lockTime;\\n    }\\n\\n    function getTime() external view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /// @param time Value in seconds\\n    function lock(uint256 time) external virtual onlyOwner {\\n        _previousOwner = _owner;\\n        _owner = address(0);\\n        _lockTime = block.timestamp + time;\\n        emit OwnershipTransferred(_owner, address(0));\\n    }\\n\\n    function unlock() external virtual {\\n        require(_previousOwner == msg.sender, \\\"You don\\u0027t have permission to unlock\\\");\\n        require(block.timestamp \\u003e _lockTime , \\\"Contract is locked until 7 days\\\");\\n        _owner = _previousOwner;\\n        emit OwnershipTransferred(_owner, _previousOwner);\\n    }\\n}\\n\\n\\n/// Pancake Factory\\ninterface IPancakeFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\n\\ninterface IPancakeERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\\n\\ninterface IPancakeCallee {\\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\\n\\ninterface IPancakePair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\n/// Pancake Router\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"path\",\"type\":\"address\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LuckyShotWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"wallet\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbForLP\",\"type\":\"uint256\"}],\"name\":\"SendToWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"combinedBuyRate\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"reflectionBuyRate\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"luckyShotBuyRate\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"combinedSellRate\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"reflectionSellRate\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"luckyShotSellRate\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"combinedSendRate\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"antiWhaleRate\",\"type\":\"uint16\"}],\"name\":\"SetRates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"antiWhalerate\",\"type\":\"uint16\"}],\"name\":\"SetRates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amountIn\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amountOut\",\"type\":\"uint128\"}],\"name\":\"SwapTokensForBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReflected\",\"type\":\"uint256\"}],\"name\":\"TokensReflected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"listIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_addToFeeList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_addToRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_removeFromFeeLists\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_removeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"_setCharityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"combinedBuyRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reflectionBuyRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"luckyShotBuyRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"combinedSellRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reflectionSellRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"luckyShotSellRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"combinedSendRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"antiWhaleRate\",\"type\":\"uint16\"}],\"name\":\"_setContractRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"_setMarketingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"layer2Address\",\"type\":\"address\"}],\"name\":\"_setProjectLayer2Address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_setsDefaultRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_spendAvailableFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_turnOffAntiWhale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"charityRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"marketingRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"buybackRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"liquidityRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_useContractBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"}],\"name\":\"burnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractRates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"combinedBuyRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reflectionBuyRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"luckyShotBuyRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"combinedSellRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reflectionSellRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"luckyShotSellRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"combinedSendRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"antiWhaleRate\",\"type\":\"uint16\"}],\"internalType\":\"struct HungerToken.ContractRates\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getFeeStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLayer2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLuckyShot\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"chanceToWin\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"minimumSpendAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"minimumPoolThreshold\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"previousWinner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"previousWinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousWinTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRoll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rolls\",\"type\":\"uint256\"}],\"internalType\":\"struct HungerToken.LuckyShot\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPancakePair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPancakeRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getReflectionAmountFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reflectedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialSupportFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"chance\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"minimumSpendAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"minimumTokensAccumulated\",\"type\":\"uint128\"}],\"name\":\"luckyShotConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"luckyShotTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPair\",\"type\":\"address\"}],\"name\":\"pancakePairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"pancakeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectFundsAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"renounceGuard\",\"type\":\"bool\"}],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReflectionsEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HungerToken", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://92e57311cddec1a42f6e31006eab4e49c1a28c8807fc898d4effd9dd56731575"}