{"SourceCode": "{\"DumperShield.sol\":{\"content\":\"// Copyright (c) [2023], [Qwantum Finance Labs]\\r\\n// All rights reserved.\\r\\n// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./DumperShieldToken.sol\\\";\\r\\nimport \\\"./Voting.sol\\\";\\r\\n//import \\\"./Splitter.sol\\\";\\r\\n\\r\\ninterface IRouter {\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function factory() external pure returns (address);\\r\\n}\\r\\n\\r\\ninterface IFactory {\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IPair {\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n}\\r\\n\\r\\ninterface IGateway {\\r\\n    function tokenReceived(address token, uint256 amount, uint256 payValue) external;\\r\\n}\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\"); //APPROVE_FAILED\\r\\n    }\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\"); //TRANSFER_FAILED\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\"); //TRANSFER_FROM_FAILED\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint value) internal {\\r\\n        (bool success,) = to.call{value:value}(new bytes(0));\\r\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\"); //ETH_TRANSFER_FAILED\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Ownable {\\r\\n    address internal _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    error CallerIsNotOwner();\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n/*  we use proxy, so owner will be set in initialize() function\\r\\n    constructor () {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n*/\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        if(owner() != msg.sender) revert CallerIsNotOwner(); //Ownable: caller is not the owner\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0)); //\\\"Ownable: new owner is the zero address\\\"\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract DumperShieldFactory is Ownable, Voting {\\r\\n    using TransferHelper for address;\\r\\n    //using Splitter for Splitter.SplitterSet;\\r\\n\\r\\n    enum OrderStatus {Completed, Created, Canceled, Restricted, BuyOrderCreated}\\r\\n    address constant public NATIVE_COIN = address(1);\\r\\n    address public WETH;\\r\\n    address public DumperShieldTokenImplementation; // implementation contract for DumperShieldToken\\r\\n\\r\\n    struct Order {\\r\\n        address seller;\\r\\n        address buyer;\\r\\n        address tokenSell;  // token to sell\\r\\n        uint256 sellAmount;  // how many token sell\\r\\n        address wantToken;  // which token want to receive (address(0) for base coin (ETH, BNB))\\r\\n        address router; // router where \\\"wantToken\\\" can be swapped to native coin (ETH, BNB)\\r\\n        uint256 value;  // the value in native cion (ETH, BNB) want to receive\\r\\n        OrderStatus status;     // 0 - completed, 1 - created, 2 - canceled; 3 -restricted\\r\\n        uint16   position;  // position of token (buy or sell depends on order type)\\r\\n    }\\r\\n\\r\\n    Order[] public orders;\\r\\n\\r\\n    struct Limit {\\r\\n        uint256 period; // period of time while calculate tokens demand\\r\\n        uint256 limit;  // current limit amount. If limit == 0 than no limits\\r\\n        uint256 spent;  // amount of token that was spent;\\r\\n        uint256 endTime;  // timestamp when current period ends\\r\\n        uint256 nextLimit; // limit for next period\\r\\n        // if limit was spent by less than period * 50% (ie. 1 day * 50%) the limit *= 2\\r\\n        // if during period was spend less than `percentage` (ie. spent \\u003c limit * 50%) the limit /= 2\\r\\n    }\\r\\n\\r\\n    struct Fees {   // Fees with 2 decimals (100 = 1%)\\r\\n        uint16 maker;   // OTC maker\\r\\n        uint16 taker;   // OTC taker\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e Limit) public limits;    // token =\\u003e limit for sale\\r\\n    mapping(address =\\u003e DumperShieldToken) public dumperShieldTokens;   // token address =\\u003e DumperShieldToken contract address\\r\\n    mapping(bytes32 =\\u003e address) private _dumperShieldUsers;   // user with position =\\u003e DumperShieldUser contract address\\r\\n    mapping(address =\\u003e address) public Unused_dsRouters;     // token =\\u003e router // Unused now\\r\\n    mapping(address =\\u003e uint256) public dsUnlockDate;  // token =\\u003e unlock date (unix timestamp in seconds)\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public restrictedBalance;   // token =\\u003e user =\\u003e restricted balance\\r\\n    mapping(address =\\u003e uint /* Splitter.SplitterSet */) public Unused_tokensSale; // token =\\u003e sale library // Unused now\\r\\n\\r\\n    uint256 private _status;\\r\\n    uint256 constant public totalPositions = 3; // 0 - main; 1,2 - sub positions, excluded from voting\\r\\n    Fees public fees;\\r\\n    address public feeReceiver;\\r\\n\\r\\n    address public PDO;\\r\\n    address public gateway; // gateway can buy arbitrary orders from OTC with optimistic tokens receive and then send payment\\r\\n    uint256 private awaitPayment;  // amount of coin (BNB, ETH) await payment from gateway\\r\\n\\r\\n    event CreateDumperShield(address indexed token, address router, address dumperShieldToken);\\r\\n    event PaymentFromGateway(uint256 indexed channelId, address indexed token, uint256 value, uint256 soldValue);\\r\\n    event CreateOrder(\\r\\n        uint256 orderId, \\r\\n        address indexed seller, \\r\\n        address indexed buyer, \\r\\n        address indexed tokenSell,\\r\\n        uint256 sellAmount,\\r\\n        address wantToken,\\r\\n        address router,\\r\\n        uint256 value, \\r\\n        OrderStatus status,\\r\\n        uint256 position\\r\\n    );\\r\\n    event CompleteOrder(uint256 indexed orderId);\\r\\n    event ConfirmOrder(uint256 indexed orderId);\\r\\n    event CancelOrder(uint256 indexed orderId);\\r\\n    event PutOnSale(\\r\\n        address indexed token,  // taken address that put on sale\\r\\n        address indexed from,   // user address\\r\\n        uint256 value,          // value of tokens that user put on sale\\r\\n        uint256 valueA,         // total value of tokens that user has on sale\\r\\n        uint256 valueB          // value of coin (BNB, ETH) transferred to user for sold tokens\\r\\n    );\\r\\n    event RemoveFromSale(address indexed token, address indexed from, uint256 valueA, uint256 valueB);\\r\\n    event BuyOrder(uint256 indexed orderId, address indexed buyer, uint256 paymentAmount, uint256 receiveAmount);\\r\\n    event DumperShieldUnlock(address indexed token, uint256 unlockDate);\\r\\n    event DumperShieldTransfer(address indexed token, uint256 position, address indexed from, address indexed to, uint256 value);\\r\\n    event Reimburse(address user, uint256 gasFee, uint256 fee);\\r\\n    event CreateDumperShieldUserPosition(address user, address dsUserContract, uint256 position);\\r\\n\\r\\n    // Errors\\r\\n    error Reentrant();\\r\\n    error OnlyDSToken();\\r\\n    error TokenIsNotShielded();\\r\\n    error TokenAlreadyShielded();\\r\\n    error WrongLength();\\r\\n    error WrongStatus();\\r\\n    error WrongSender();\\r\\n    error UserIsNotInDumperShield();\\r\\n    error WrongValue();\\r\\n    error LowBalance();\\r\\n    error LowAmount();\\r\\n    error TokenIsLocked();\\r\\n    error TokenIsLockedInVoting();\\r\\n    error WrongDate();\\r\\n    error WrongRouter();\\r\\n    error OutOfLimit(uint256 limit);\\r\\n    error ERC1167CreateFailed();\\r\\n    error WantToken(address token);\\r\\n    error AwaitPayment(uint256 awaitAmount);\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        if(_status == 1) revert Reentrant(); //reentrant\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = 1;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = 2;\\r\\n    }\\r\\n\\r\\n    modifier reimburse() {\\r\\n        uint256 txGas = gasleft();\\r\\n        \\r\\n        _;\\r\\n\\r\\n        emit Reimburse(msg.sender, (txGas - gasleft()) * tx.gasprice, 0);        \\r\\n    }\\r\\n\\r\\n    // run only once from proxy\\r\\n    function initialize(address newOwner, address newDumperShieldTokenImplementation, address _weth) external {\\r\\n        require(newOwner != address(0) \\u0026\\u0026 _owner == address(0)); // run only once\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n        //WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // Ethereum WETH\\r\\n        //WETH = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270); // Poygon WMATIC (SushiSwap)\\r\\n        //WETH = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c); // Main BSC net WBNB\\r\\n        //WETH = address(0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd); // test BSC net WBNB\\r\\n        WETH = _weth;\\r\\n        DumperShieldTokenImplementation = newDumperShieldTokenImplementation;\\r\\n        orders.push();  // order ID starts from 1. Zero order ID means - no order\\r\\n        super.initialize();\\r\\n    }\\r\\n\\r\\n    function setWETH(address _WETH) external onlyOwner {\\r\\n        require(_WETH != address(0));\\r\\n        WETH = _WETH;\\r\\n    }\\r\\n\\r\\n    function setFeeReceiver(address _feeReceiver) external onlyOwner {\\r\\n        require(_feeReceiver != address(0));\\r\\n        feeReceiver = _feeReceiver;\\r\\n    }\\r\\n\\r\\n    function setFees(uint16 maker, uint16 taker) external onlyOwner {\\r\\n        require(maker \\u003c 10000 \\u0026\\u0026 taker \\u003c 10000); // fees must be less than 100%\\r\\n        fees.maker = maker;\\r\\n        fees.taker = taker;\\r\\n    }\\r\\n\\r\\n    // View functions\\r\\n    // get user balances of token on the dumper shield for each position\\r\\n    function balanceOf(address token, address user) public view returns (uint256[] memory balances) {\\r\\n        balances = new uint256[](totalPositions);\\r\\n        for (uint i = 0; i \\u003c totalPositions; i++) {\\r\\n            address dsUser = getDSUser(user, i);\\r\\n            if(dsUser != address(0))  //User is in dumper shield\\r\\n                balances[i] = IERC20(token).balanceOf(dsUser);   \\r\\n        }\\r\\n    }\\r\\n\\r\\n    // get user balance of token on position in the dumper shield\\r\\n    function balanceOf(address token, address user, uint256 position) public view returns (uint256 amount) {\\r\\n        address dsUser = getDSUser(user, position);\\r\\n        if(dsUser == address(0)) return 0; //User is not in dumper shield\\r\\n        amount = IERC20(token).balanceOf(dsUser);\\r\\n    }\\r\\n\\r\\n    // return DS user contract address\\r\\n    function getDSUser(address user, uint256 position) public view returns (address dsUser) {\\r\\n        bytes32 userPosition = bytes32((position \\u003c\\u003c 248) + uint256(uint160(user)));  // calculate position index\\r\\n        dsUser = _dumperShieldUsers[userPosition];\\r\\n    }\\r\\n\\r\\n    // create new DS user contract or return already existed\\r\\n    function createDSUser(address user, uint256 position) internal returns (address dsUser) {\\r\\n        bytes32 userPosition = bytes32((position \\u003c\\u003c 248) + uint256(uint160(user)));  // calculate position index\\r\\n        dsUser = _dumperShieldUsers[userPosition];\\r\\n        if (dsUser == address(0)) {\\r\\n            dsUser = address(new DumperShieldUser(user, address(this)));\\r\\n            _dumperShieldUsers[userPosition] = dsUser;\\r\\n        }\\r\\n        emit CreateDumperShieldUserPosition(user, dsUser, position);\\r\\n    }\\r\\n\\r\\n// debug functions\\r\\n/*\\r\\n    function getSplitter_tokenARatesShares(address token, uint256 index) external view returns(uint tokenARatesShares) {\\r\\n        tokenARatesShares = tokensSale[token].tokenARatesShares[index];\\r\\n    }\\r\\n\\r\\n    function getSplitter_sharesOrRateB(address token, uint256 rateA) external view returns(uint sharesOrRateB) {\\r\\n        sharesOrRateB = tokensSale[token].sharesOrRateB[rateA];\\r\\n    }\\r\\n\\r\\n    function getSplitter_deposits(address token, address user) external view \\r\\n    returns\\r\\n    (\\r\\n        uint256 tokenARate,\\r\\n        uint256 tokenBRate,\\r\\n        uint256 shares    \\r\\n    ) {\\r\\n        tokenARate = tokensSale[token].deposits[user].tokenARate;\\r\\n        tokenBRate = tokensSale[token].deposits[user].tokenBRate;\\r\\n        shares = tokensSale[token].deposits[user].shares;\\r\\n    }\\r\\n\\r\\n    function updateVars() external onlyOwner {\\r\\n\\r\\n    }\\r\\n    */\\r\\n// end debug\\r\\n\\r\\n    // return estimate value of tokens A in tokens B\\r\\n    function getQuote(address router, address tokenA, address tokenB, uint256 amountA) public view returns(uint256 amountB) {\\r\\n        address factory = IRouter(router).factory();\\r\\n        address pair = IFactory(factory).getPair(tokenA, tokenB);\\r\\n        (uint reserve0, uint reserve1,) = IPair(pair).getReserves();\\r\\n        (uint reserveA, uint reserveB) = tokenA \\u003c tokenB ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n        amountB = amountA * reserveB / reserveA;\\r\\n    }\\r\\n\\r\\n    // get total number of orders\\r\\n    function getOrdersNumber() external view returns(uint256 number) {\\r\\n        return orders.length;\\r\\n    }\\r\\n\\r\\n    // get order ID of last active sell order of seller\\r\\n    // if seller address = address(0), then returns last Buy Tokens orders.\\r\\n    function getLastSellOrder(address seller) external view returns(uint256[] memory)\\r\\n    {\\r\\n        uint256[] memory orderIDs = new uint256[](20);\\r\\n        uint len = orders.length;\\r\\n        uint min;\\r\\n        uint index;\\r\\n        if (len \\u003e 200) min = len - 200; // check last 200 orders\\r\\n        while(len \\u003e min) {\\r\\n            len--;\\r\\n            Order storage o = orders[len];\\r\\n            if ((o.status == OrderStatus.Restricted || o.status == OrderStatus.Created || o.status == OrderStatus.BuyOrderCreated) \\u0026\\u0026 o.seller == seller) {\\r\\n                orderIDs[index] = len;\\r\\n                index++;\\r\\n                if (index == 20) break;\\r\\n            }\\r\\n        }\\r\\n        return orderIDs; // No orders available\\r\\n    }\\r\\n\\r\\n    // get order ID of last active buy order of buyer\\r\\n    function getLastBuyOrder(address buyer) external view returns(uint256[] memory)\\r\\n    {\\r\\n        uint256[] memory orderIDs = new uint256[](20);\\r\\n        uint len = orders.length;\\r\\n        uint min;\\r\\n        uint index;\\r\\n        if (len \\u003e 200) min = len - 200; // check last 200 orders\\r\\n        while(len \\u003e min) {\\r\\n            len--;\\r\\n            Order storage o = orders[len];\\r\\n            if ((o.status == OrderStatus.Restricted || o.status == OrderStatus.Created || o.status == OrderStatus.BuyOrderCreated) \\u0026\\u0026 o.buyer == buyer) {\\r\\n                orderIDs[index] = len;\\r\\n                index++;\\r\\n                if (index == 20) break;\\r\\n            }\\r\\n        }\\r\\n        return orderIDs; // No orders available\\r\\n    }\\r\\n\\r\\n    function setLock(address token, address user, uint256 time) external returns(bool) {\\r\\n        if(msg.sender != address(dumperShieldTokens[token])) revert OnlyDSToken(); //onlyDSToken\\r\\n        if (locked[token][user] \\u003c time) {\\r\\n            locked[token][user] = time;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function getLock(address token, address user) external view returns(uint256) {\\r\\n        return locked[token][user];\\r\\n    }\\r\\n\\r\\n    // exported functions\\r\\n    // Deposit tokens to user\\u0027s address into Dumper Shield. Should be called approve() before deposit.\\r\\n    function deposit(\\r\\n        address token,  // token contract address\\r\\n        uint256 amount, // amount of tokens to deposit\\r\\n        address user    // user address who receives token\\r\\n    ) external returns (bool)\\r\\n    {\\r\\n        return depositPosition(token, amount, user, 0);\\r\\n    }\\r\\n\\r\\n    // exported functions\\r\\n    // Deposit tokens to user\\u0027s address into Dumper Shield in specific position. Should be called approve() before deposit.\\r\\n    function depositPosition(\\r\\n        address token,  // token contract address\\r\\n        uint256 amount, // amount of tokens to deposit\\r\\n        address user,   // user address who receives token\\r\\n        uint256 position // position in queue (0, 1, 2)\\r\\n    ) public returns (bool)\\r\\n    {\\r\\n        require(position \\u003c totalPositions); // limit of positions\\r\\n        DumperShieldToken dsToken = dumperShieldTokens[token];\\r\\n        if(address(dsToken) == address(0)) revert TokenIsNotShielded();   //Token is not shielded\\r\\n        address dsUser = createDSUser(user, position); // dsUser != 0\\r\\n        if (position == 0) dsToken.createDumperShieldUser(user, dsUser); // add user to dsToken (to apply in voting)\\r\\n        token.safeTransferFrom(msg.sender, dsUser, amount);\\r\\n        _updateBalanceAndTotal(token, user, position); // update data for voting\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev transfer token for a specified address into Escrow contract\\r\\n     * @param token The address of token to transfer to.\\r\\n     * @param to The address to transfer to.\\r\\n     * @param value The amount to be transferred.\\r\\n     */\\r\\n    function transfer(address token, uint256 position, address to, uint256 value) external reimburse returns (bool ret) {\\r\\n        //restrictedBalance[token][to] += value;     // transfer to restricted account\\r\\n        _transfer(token, position, msg.sender, to, value);\\r\\n        ret = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev transfer token for a Batch of specified addresses into Escrow contract\\r\\n     * @param token The address of token to transfer to.\\r\\n     * @param to The addresses to transfer to.\\r\\n     * @param value The amounts to be transferred.\\r\\n     */\\r\\n    function transferBatch(address token, uint256 position, address[] calldata to, uint256[] calldata value) external reimburse returns (bool ret) {\\r\\n        if(to.length != value.length) revert WrongLength(); // wrong length\\r\\n\\r\\n        for (uint i = 0; i \\u003c to.length; i++) {\\r\\n            //restrictedBalance[token][to] += value;     // transfer to restricted account\\r\\n            _transfer(token, position, msg.sender, to[i], value[i]);\\r\\n        }\\r\\n        ret = true;\\r\\n    }\\r\\n\\r\\n    // Sell tokens to other user (inside Escrow contract).\\r\\n    function sellToken(\\r\\n        address buyer,  // buyer address, can be address(0) if anybody can buy it (no specific buyer)\\r\\n        address tokenSell,  // token to sell\\r\\n        uint256 sellAmount,  // how many token sell\\r\\n        address wantToken,  // which token want to receive (address(0) for base coin (ETH, BNB))\\r\\n        address router, // router where \\\"wantToken\\\" can be swapped to native coin (ETH, BNB)\\r\\n        uint256 value,  // the value in native cion (ETH, BNB) want to receive\\r\\n        uint16 sellPosition // sell token position\\r\\n    ) external reimburse {\\r\\n        _createOrder(msg.sender, buyer, tokenSell, sellAmount, wantToken, router, value, sellPosition);\\r\\n    }\\r\\n\\r\\n    // Create buy tokens order from other users (inside Escrow contract).\\r\\n    function buyToken(\\r\\n        address wantToken,  // token to buy (under DS)\\r\\n        uint256 wantTokenAmount,  // how many tokens to buy\\r\\n        uint256 position    // position of wantToken\\r\\n    ) external payable reimburse {\\r\\n        _createOrder(address(0), msg.sender, address(0), msg.value, wantToken, address(0), wantTokenAmount, position);\\r\\n    }\\r\\n\\r\\n\\r\\n    // cancel sell order\\r\\n    function cancelOrder(uint256 orderId) external reimburse {\\r\\n        Order storage o = orders[orderId];\\r\\n        if (msg.sender != o.seller \\u0026\\u0026 msg.sender != o.buyer) revert WrongSender(); //can\\u0027t cancel\\r\\n        if (o.status == OrderStatus.BuyOrderCreated) {\\r\\n            o.status = OrderStatus.Canceled;    // cancel buy token order\\r\\n            o.buyer.safeTransferETH(o.sellAmount);\\r\\n        } else {\\r\\n            if (o.status != OrderStatus.Created \\u0026\\u0026 o.status != OrderStatus.Restricted) revert WrongStatus(); // user can cancel restricted order too.\\r\\n            if (o.status == OrderStatus.Restricted) restrictedBalance[o.tokenSell][o.seller] += o.sellAmount;    // transfer to restricted account\\r\\n            o.status = OrderStatus.Canceled;   // cancel\\r\\n            _transfer(o.tokenSell, uint256(o.position), address(this), o.seller, o.sellAmount);\\r\\n        }\\r\\n        emit CancelOrder(orderId);\\r\\n    }\\r\\n\\r\\n    // buy selected order (ID). If is used ERC20 token to buy, the amount should be approved for Escrow contract.\\r\\n    function buyOrder(\\r\\n        uint256 orderId, \\r\\n        uint256 paymentAmount\\r\\n    ) external payable nonReentrant \\r\\n    {\\r\\n        uint256 txGas = gasleft();\\r\\n        uint256 fee = _buyOrder(orderId, paymentAmount, msg.sender);\\r\\n        emit Reimburse(msg.sender, (txGas - gasleft()) * tx.gasprice, fee);  \\r\\n    }\\r\\n\\r\\n    // buy selected order (ID) behalf buyer (msg.sender pays). If is used ERC20 token to buy, the amount should be approved for Escrow contract.\\r\\n    function buyOrderBehalf(\\r\\n        uint256 orderId, \\r\\n        uint256 paymentAmount,\\r\\n        address buyer        \\r\\n    ) external payable nonReentrant \\r\\n    {\\r\\n        uint256 txGas = gasleft();\\r\\n        uint256 fee = _buyOrder(orderId, paymentAmount, buyer);\\r\\n        emit Reimburse(buyer, (txGas - gasleft()) * tx.gasprice, fee);    \\r\\n      }\\r\\n\\r\\n    function _buyOrder(\\r\\n        uint256 orderId, \\r\\n        uint256 paymentAmount,\\r\\n        address buyer        \\r\\n    ) internal returns (uint256 takerFee)\\r\\n    {\\r\\n        Order storage o = orders[orderId];\\r\\n        uint256 value = o.value; // want tokens amount\\r\\n        uint256 sellAmount = o.sellAmount;\\r\\n        uint256 makerFee;\\r\\n        if (o.status == OrderStatus.BuyOrderCreated) {  // process buy token order\\r\\n            if (msg.value != 0) revert WrongValue();    // don\\u0027t accept native coin\\r\\n            if (paymentAmount \\u003e= value) {\\r\\n                paymentAmount = value; // amount of token that buyer wants to buy\\r\\n                makerFee = sellAmount * fees.maker / 10000;\\r\\n                sellAmount -= makerFee;\\r\\n                o.sellAmount = 0;\\r\\n                o.value = 0;\\r\\n                o.status = OrderStatus.Completed;\\r\\n                emit CompleteOrder(orderId);\\r\\n            } else {\\r\\n                sellAmount = (sellAmount * 10000) / (10000 + fees.maker);\\r\\n                sellAmount = sellAmount * paymentAmount / value;\\r\\n                makerFee = sellAmount * fees.maker / 10000;\\r\\n                o.value = value - paymentAmount;\\r\\n                o.sellAmount = o.sellAmount - (sellAmount + makerFee);\\r\\n            }\\r\\n            takerFee = sellAmount * fees.taker / 10000;\\r\\n            feeReceiver.safeTransferETH(takerFee + makerFee);   // transfer fee\\r\\n            _transfer(o.wantToken, o.position, msg.sender, o.buyer, paymentAmount);\\r\\n            emit Reimburse(o.buyer, 0, makerFee); \\r\\n            buyer.safeTransferETH(sellAmount - takerFee);\\r\\n            emit BuyOrder(orderId, buyer, paymentAmount, sellAmount);\\r\\n        } else {    // process sell order\\r\\n            if (o.status != OrderStatus.Created) revert WrongStatus(); //Wrong status\\r\\n            if (o.buyer != address(0) \\u0026\\u0026 o.buyer != msg.sender) revert WrongSender(); //Wrong buyer (only buyer himself)\\r\\n\\r\\n            address token = o.wantToken;\\r\\n            if (value \\u003e 0) {\\r\\n                if (token == address(0)) { //pay with native coin\\r\\n                    paymentAmount = (msg.value * 10000) / (10000 + fees.taker);\\r\\n                    if (paymentAmount \\u003e value) {\\r\\n                        paymentAmount = value; \\r\\n                        takerFee = paymentAmount * fees.taker / 10000;\\r\\n                        buyer.safeTransferETH(msg.value - (paymentAmount + takerFee));  // return rest\\r\\n                    } else {\\r\\n                        takerFee = msg.value - paymentAmount;\\r\\n                    }\\r\\n                    makerFee = paymentAmount * fees.maker / 10000;\\r\\n                    feeReceiver.safeTransferETH(takerFee + makerFee);   // transfer fee\\r\\n                    (o.seller).safeTransferETH(paymentAmount - makerFee); // transfer money to seller\\r\\n                    emit Reimburse(o.seller, 0, makerFee); \\r\\n                    uint256 sellPart = sellAmount * paymentAmount / value;\\r\\n                    if (sellPart \\u003c sellAmount) {\\r\\n                        value = value - paymentAmount; // left order value\\r\\n                        if (value \\u003c 1 gwei) { // if left too small value\\r\\n                            value = 0;  // remove dust\\r\\n                        } else {\\r\\n                            o.value = value;\\r\\n                            o.sellAmount = sellAmount - sellPart;\\r\\n                            sellAmount = sellPart;\\r\\n                        }\\r\\n                    }                     \\r\\n                } else {    // pay with token\\r\\n                    //value = getQuote(o.router, WETH, token, value);   // value in token\\r\\n                    //if (value == 0) revert WrongValue(); // tokenAmount 0\\r\\n\\r\\n                    if (address(dumperShieldTokens[token]) == address(0)) { // pay with token from wallet (out of DS)\\r\\n                        makerFee = paymentAmount; // temporary store payment amount\\r\\n                        paymentAmount = (paymentAmount * 10000) / (10000 + fees.taker);\\r\\n                        if (paymentAmount \\u003e value) {\\r\\n                            paymentAmount = value; \\r\\n                            takerFee = paymentAmount * fees.taker / 10000;\\r\\n                        } else {\\r\\n                            takerFee = makerFee - paymentAmount;    // makerFee is initial paymentAmount\\r\\n                        }                        \\r\\n                        makerFee = paymentAmount * fees.maker / 10000;\\r\\n                        (token).safeTransferFrom(msg.sender, feeReceiver, takerFee + makerFee);\\r\\n                        (token).safeTransferFrom(msg.sender, o.seller, paymentAmount - makerFee);\\r\\n                        takerFee = 0; // dont reimburse fee in tokens (need to convert to BNB)\\r\\n                        //emit Reimburse(o.seller, 0, makerFee); \\r\\n                    } else {\\r\\n                        _transfer(token, 0, msg.sender, o.seller, paymentAmount);   // use 0 position token for buy\\r\\n                    }\\r\\n                    uint256 sellPart = sellAmount * paymentAmount / value;\\r\\n                    if (sellPart \\u003c sellAmount) {\\r\\n                        value = value - paymentAmount; // left order value\\r\\n                        //value = o.value;\\r\\n                        //value = value - (value * sellPart / sellAmount);  // left order value\\r\\n                        if (value \\u003c 1000) { // if left too small value. Be careful with tokens with small decimals\\r\\n                            value = 0;  // remove dust\\r\\n                        } else {\\r\\n                            o.value = value;\\r\\n                            o.sellAmount = sellAmount - sellPart;\\r\\n                            sellAmount = sellPart;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                if (value == 0) {\\r\\n                    o.sellAmount = 0;\\r\\n                    o.value = 0;\\r\\n                    o.status = OrderStatus.Completed;\\r\\n                    emit CompleteOrder(orderId);\\r\\n                }\\r\\n                emit BuyOrder(orderId, buyer, paymentAmount, sellAmount);\\r\\n            } else {\\r\\n                if (msg.value \\u003e 0) buyer.safeTransferETH(msg.value);  // return money if value == 0\\r\\n                o.status = OrderStatus.Completed;\\r\\n                emit CompleteOrder(orderId);\\r\\n                return 0;\\r\\n            }\\r\\n            //restrictedBalance[o.tokenSell][o.buyer] += o.sellAmount;    // transfer to restricted account\\r\\n            if(msg.sender == PDO) {\\r\\n                o.tokenSell.safeTransfer(PDO, sellAmount);\\r\\n            } else {\\r\\n                _transfer(o.tokenSell, o.position, address(this), buyer, sellAmount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // gateway can buy arbitrary orders from OTC with optimistic tokens receive and then send payment\\r\\n    function gatewayBuy(\\r\\n        uint256 orderId, \\r\\n        uint256 paymentAmount\\r\\n    ) external nonReentrant \\r\\n    {\\r\\n        require(msg.sender == gateway, \\\"Only gateway\\\");\\r\\n        if(awaitPayment != 0) revert AwaitPayment(awaitPayment); // should not be in await state\\r\\n        Order storage o = orders[orderId];\\r\\n        uint256 value = o.value; // want tokens amount\\r\\n        uint256 sellAmount = o.sellAmount;\\r\\n        if (o.status != OrderStatus.Created) revert WrongStatus(); //Wrong status\\r\\n        if (o.buyer != address(0) \\u0026\\u0026 o.buyer != msg.sender) revert WrongSender(); //Wrong buyer\\r\\n        uint256 takerFee;\\r\\n        uint256 makerFee;\\r\\n        address token = o.wantToken;\\r\\n        if (value \\u003e 0) {\\r\\n            if (token == address(0)) {\\r\\n                makerFee = paymentAmount;   // temporary store payment amount\\r\\n                paymentAmount = (paymentAmount * 10000) / (10000 + fees.taker);\\r\\n                if (paymentAmount \\u003e value) {\\r\\n                    paymentAmount = value; \\r\\n                    takerFee = paymentAmount * fees.taker / 10000;\\r\\n                } else {\\r\\n                    takerFee = makerFee - paymentAmount;\\r\\n                }\\r\\n                makerFee = paymentAmount * fees.maker / 10000;\\r\\n            } else {\\r\\n                revert WantToken(token);\\r\\n            }\\r\\n            uint256 sellPart = sellAmount * paymentAmount / value;\\r\\n          \\r\\n            if (sellPart \\u003c sellAmount) {\\r\\n                value = value - paymentAmount; // left order value\\r\\n                if (value \\u003c 1 gwei) { // if left too small value\\r\\n                    value = 0;  // remove dust\\r\\n                } else {\\r\\n                    o.value = value;\\r\\n                    o.sellAmount = sellAmount - sellPart;\\r\\n                    sellAmount = sellPart;\\r\\n                }\\r\\n            } \\r\\n            if (value == 0){\\r\\n                o.sellAmount = 0;\\r\\n                o.value = 0;\\r\\n                o.status = OrderStatus.Completed;\\r\\n                emit CompleteOrder(orderId);\\r\\n            }\\r\\n            emit BuyOrder(orderId, msg.sender, paymentAmount, sellAmount);\\r\\n        } else {\\r\\n            o.status = OrderStatus.Completed;\\r\\n            emit CompleteOrder(orderId);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        o.tokenSell.safeTransfer(gateway, sellAmount);  // optimistic transfer\\r\\n        uint256 balance = address(this).balance;\\r\\n        IGateway(gateway).tokenReceived(o.tokenSell, sellAmount, paymentAmount + takerFee);\\r\\n        if((balance + paymentAmount + takerFee) != address(this).balance) revert WrongValue(); // check payment\\r\\n        feeReceiver.safeTransferETH(takerFee + makerFee);   // transfer fee\\r\\n        (o.seller).safeTransferETH(paymentAmount - makerFee); // transfer money to seller\\r\\n        emit Reimburse(o.seller, 0, makerFee); \\r\\n    }\\r\\n/*\\r\\n    // buy token from Dumper Shield by pool price, without slippage\\r\\n    function gatewayBuyToken(\\r\\n        address token,      // token that should be bought\\r\\n        uint256 buyAmountMin,  // minimum amount to buy\\r\\n        address sendToken,  // token that used to buy, should be address(0) = native coin (BNB, ETH)\\r\\n        uint256 sendAmount  // amount of native coin == msg.value\\r\\n    ) external payable returns (uint256 tokenAmountOut)\\r\\n    {\\r\\n        if (sendToken != address(0)) revert WrongToken(); //onlyCoin\\r\\n        if (sendAmount != msg.value) revert WrongValue(); //wrong value\\r\\n        if (address(dumperShieldTokens[token]) == address(0)) revert TokenIsNotShielded();  // Token is not in dumper shield\\r\\n        tokenAmountOut = getQuote(dsRouters[token], WETH, token, sendAmount);\\r\\n        _updateLimits(token, tokenAmountOut);    // check and update limits\\r\\n        Splitter.SplitterSet storage set = tokensSale[token];\\r\\n        if (set.totalTokenA \\u003c tokenAmountOut) revert LowBalance(); //Not enough available tokens\\r\\n        if (tokenAmountOut \\u003c buyAmountMin) revert LowAmount(); //Amount is less then minimum\\r\\n        set.swap(tokenAmountOut, sendAmount);\\r\\n        token.safeTransfer(msg.sender, tokenAmountOut);\\r\\n    }\\r\\n\\r\\n    // get available token for sell\\r\\n    function getAvailableTokens(address token) public view returns (uint256 amount) {\\r\\n        amount = tokensSale[token].totalTokenA;\\r\\n        uint256 limit = limits[token].limit;\\r\\n        if (limit != 0) {\\r\\n            uint256 endTime = limits[token].endTime;\\r\\n            if(block.timestamp \\u003c endTime) {\\r\\n                limit = limit - limits[token].spent;\\r\\n            } else {\\r\\n                // if spent less than 50% of limit during last period\\r\\n                if(limits[token].spent \\u003c limit/2 \\u0026\\u0026 endTime != 0) {\\r\\n                    // decrease limit\\r\\n                    limit = limit/2;\\r\\n                }                 \\r\\n            }\\r\\n            amount = amount \\u003c limit ? amount : limit;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // get output amount of token that can be bought from Dumper Shield\\r\\n    function getOutputTokens(address sendToken, uint256 sendAmount, address token) external view returns (uint256 amount)\\r\\n    {\\r\\n        if (sendToken != address(0)) revert WrongToken(); //only coin\\r\\n        amount = getQuote(dsRouters[token], WETH, token, sendAmount);\\r\\n    }\\r\\n    // end exported functions\\r\\n*/ \\r\\n    // withdraw token from user\\u0027s DumperShield address (only for 0 position)\\r\\n    function withdrawToken(address token, uint256 amount) external {\\r\\n        if (dsUnlockDate[token] \\u003e= block.timestamp) revert TokenIsLocked(); //tokens is locked\\r\\n        if (locked[token][msg.sender] \\u003e= block.timestamp) revert TokenIsLockedInVoting(); // tokens is locked in voting\\r\\n\\r\\n        address dsUser = getDSUser(msg.sender, 0);\\r\\n        if (dsUser == address(0)) revert UserIsNotInDumperShield();\\r\\n\\r\\n        DumperShieldUser(dsUser).safeTransfer(token, msg.sender, amount);\\r\\n        _updateBalanceAndTotal(token, msg.sender, 0);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Create Dumper Shield for new token\\r\\n    function createDumperShield(\\r\\n        address token,  // token contract address\\r\\n        //address router, // Uniswap compatible AMM router address where exist Token \\u003c\\u003e WETH pair\\r\\n        uint256 unlockDate, // Epoch time (in second) when tokens will be unlocked\\r\\n        address dao         // Address of token\\u0027s voting contract if exist. Otherwise = address(0).\\r\\n    ) \\r\\n        external \\r\\n    {\\r\\n        if (address(dumperShieldTokens[token]) != address(0)) revert TokenAlreadyShielded(); //Token already shielded\\r\\n        if (unlockDate \\u003c= block.timestamp) revert WrongDate();  //unlockDate in past\\r\\n        /*\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = WETH;\\r\\n        path[1] = token;\\r\\n        uint[] memory amounts = IRouter(router).getAmountsOut(1 ether, path);\\r\\n        if (amounts[1] == 0) revert WrongRouter(); //wrong router\\r\\n        dsRouters[token] = router;\\r\\n        */\\r\\n        DumperShieldToken dsToken = DumperShieldToken(clone(DumperShieldTokenImplementation));// = new DumperShieldToken(token);\\r\\n        dsToken.initialize(token, dao);\\r\\n        dumperShieldTokens[token] = dsToken;\\r\\n        dsUnlockDate[token] = unlockDate;\\r\\n        votingTime[token] = 1 days;\\r\\n        minimalLevel[token] = 1;\\r\\n        emit CreateDumperShield(token, address(0), address(dsToken)); //router\\r\\n        emit DumperShieldUnlock(token, unlockDate);\\r\\n    }\\r\\n\\r\\n    // Set address of token\\u0027s voting contract if exist. Otherwise = address(0).\\r\\n    function setDAO(address token, address newDAO) external onlyVoting {\\r\\n        dumperShieldTokens[token].setDAO(newDAO);\\r\\n    }\\r\\n/*\\r\\n    function setRouter(address token, address newRouter) external onlyVoting {\\r\\n        if (dsRouters[token] == address(0)) revert TokenIsNotShielded();    //No dumperShieldToken\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = WETH;\\r\\n        path[1] = token;\\r\\n        uint[] memory amounts = IRouter(newRouter).getAmountsOut(1 ether, path);\\r\\n        if (amounts[1] == 0) revert WrongRouter(); //wrong router\\r\\n        dsRouters[token] = newRouter;\\r\\n    }\\r\\n*/\\r\\n    function setGateway(address newGateway) external onlyOwner {\\r\\n        gateway = newGateway;\\r\\n    }\\r\\n\\r\\n    function setPDO(address newPDO) external onlyOwner {\\r\\n        PDO = newPDO;\\r\\n    }\\r\\n\\r\\n    function setUnlockDate(address token, uint256 newUnlockDate) external onlyVoting {\\r\\n        if (dsUnlockDate[token] == 0) revert TokenIsNotShielded();  //No dumperShieldToken\\r\\n        if (newUnlockDate \\u003c= block.timestamp) revert WrongDate(); //unlockDate in past\\r\\n        dsUnlockDate[token] = newUnlockDate;\\r\\n        emit DumperShieldUnlock(token, newUnlockDate);\\r\\n    }\\r\\n\\r\\n    // set period (in seconds) and initial limit for token sale. If limit == 0, then no limits\\r\\n    function setLimits(address token, uint256 period, uint256 limit) external onlyVoting {\\r\\n        require(dsUnlockDate[token] != 0);  //No dumperShieldToken\\r\\n        limits[token].period = period;\\r\\n        limits[token].limit = limit;\\r\\n        limits[token].nextLimit = limit;\\r\\n    }\\r\\n\\r\\n    // user - wallet address related to dumper shield contract\\r\\n    function _updateBalanceAndTotal(address token, address user, uint256 position) internal override returns (uint256 realBalance) {\\r\\n        if (position != 0) return 0;    // only 0 position can vote\\r\\n        address dsUser = getDSUser(user, position);\\r\\n        if (dsUser == address(0)) revert UserIsNotInDumperShield();  // User is not in dumper shield\\r\\n        uint256 dsBalance = dsBalanceOf[token][dsUser];\\r\\n        realBalance = IERC20(token).balanceOf(dsUser);\\r\\n        if (dsBalance != realBalance) {\\r\\n            dsBalanceOf[token][dsUser] = realBalance;\\r\\n            uint256 ts = totalSupply[token] + realBalance ;\\r\\n            if (ts \\u003e dsBalance) {\\r\\n                totalSupply[token] = ts - dsBalance;\\r\\n            } else {\\r\\n                totalSupply[token] = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev transfer token for a specified address into Escrow contract\\r\\n     * @param to The address to transfer to.\\r\\n     * @param value The amount to be transferred.\\r\\n     */\\r\\n    function _transfer(address token, uint256 position, address from, address to, uint256 value) internal returns (bool) {\\r\\n        if (to == address(0)) revert ZeroAddress();\\r\\n        DumperShieldToken dsToken = dumperShieldTokens[token];\\r\\n        if (address(dsToken) == address(0)) revert TokenIsNotShielded();    //Token is not shielded\\r\\n        if (locked[token][from] \\u003e= block.timestamp) revert TokenIsLockedInVoting(); //tokens is locked in voting\\r\\n        address dsUser = createDSUser(to, position); // dsUser != 0\\r\\n        if (position == 0) dsToken.createDumperShieldUser(to, dsUser); // add user to dsToken (to apply in voting)\\r\\n\\r\\n        if (from == address(this)) {\\r\\n            token.safeTransfer(dsUser, value);\\r\\n        } else {\\r\\n            address dsFrom = getDSUser(from, position);\\r\\n            if (dsFrom == address(0)) revert UserIsNotInDumperShield();\\r\\n            uint256 balance = IERC20(token).balanceOf(dsFrom);\\r\\n            // disable restricted !!!\\r\\n            //require(available \\u003e= value, \\\"balance\\\");  // Not enough balance\\r\\n            if (balance \\u003c value) revert LowBalance();  // Not enough balance\\r\\n            // end disable restricted\\r\\n            DumperShieldUser(dsFrom).safeTransfer(token, dsUser, value);\\r\\n            _updateBalanceAndTotal(token, from, position); // update data for voting\\r\\n        }\\r\\n        _updateBalanceAndTotal(token, to, position); // update data for voting\\r\\n        emit DumperShieldTransfer(token, position, from, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Create OTC order\\r\\n    function _createOrder(\\r\\n        address seller,\\r\\n        address buyer,      // if address(0) - anyone can buy this order\\r\\n        address tokenSell,  // token to sell\\r\\n        uint256 sellAmount,  // how many token sell\\r\\n        address wantToken,  // which token want to receive (address(0) for base coin (ETH, BNB))\\r\\n        address router, // router where \\\"wantToken\\\" (or \\\"tokenSell\\\" for BuyOrder) can be swapped to native coin (ETH, BNB)\\r\\n        uint256 value,  // the value in native cion (ETH, BNB) want to receive\\r\\n        uint256 position   // token position (depends on buy or sel order). \\r\\n    ) \\r\\n        internal \\r\\n    {\\r\\n        if (sellAmount == 0) revert LowAmount(); //amount 0\\r\\n        OrderStatus status;\\r\\n        if (seller == address(0)) { // buy token order\\r\\n            if (address(dumperShieldTokens[wantToken]) == address(0)) revert TokenIsNotShielded(); //Token is not shielded\\r\\n            status = OrderStatus.BuyOrderCreated;\\r\\n        } else { // sell order\\r\\n            if (address(dumperShieldTokens[tokenSell]) == address(0)) revert TokenIsNotShielded(); //Token is not shielded\\r\\n            if (locked[tokenSell][seller] \\u003e= block.timestamp) revert TokenIsLockedInVoting();   //tokens is locked in voting\\r\\n            status = OrderStatus.Created;\\r\\n            address dsUser = getDSUser(seller, position);\\r\\n            uint256 balance = IERC20(tokenSell).balanceOf(dsUser);\\r\\n            if (balance \\u003c sellAmount) revert LowBalance();    // Not enough tokens\\r\\n            DumperShieldUser(dsUser).safeTransfer(tokenSell, address(this), sellAmount);\\r\\n            _updateBalanceAndTotal(tokenSell, seller, position);\\r\\n        }\\r\\n        uint256 orderId = orders.length;\\r\\n        orders.push(Order(seller, buyer, tokenSell, sellAmount, wantToken, router, value, status, uint16(position)));  //add restricted order\\r\\n        emit CreateOrder(orderId, seller, buyer, tokenSell, sellAmount, wantToken, router, value, status, position);\\r\\n    }    \\r\\n\\r\\n    function _updateLimits(address token, uint256 buyAmount) internal {\\r\\n        uint256 limit = limits[token].limit;\\r\\n        if (limit != 0) {\\r\\n            uint256 endTime = limits[token].endTime;\\r\\n            if(block.timestamp \\u003c endTime) {\\r\\n                // period is not ended\\r\\n                uint256 timeLeft = endTime - block.timestamp;\\r\\n                buyAmount = limits[token].spent + buyAmount; // bought amount\\r\\n                // if was spent more than 95% of limits during half of time period\\r\\n                if(buyAmount \\u003e limit*95/100 \\u0026\\u0026 timeLeft \\u003e= limits[token].period/2) {\\r\\n                    // increase limit\\r\\n                    limits[token].nextLimit = limit*2;\\r\\n                }\\r\\n            } else {\\r\\n                // new period\\r\\n                // if spent less than 50% of limit during last period\\r\\n                if(limits[token].spent \\u003c limit/2 \\u0026\\u0026 endTime != 0) {\\r\\n                    // decrease limit\\r\\n                    limit = limit/2;\\r\\n                    limits[token].limit = limit;\\r\\n                }\\r\\n                if(endTime == 0) {\\r\\n                    //start first period\\r\\n                    limits[token].endTime = block.timestamp + limits[token].period;\\r\\n                } else {\\r\\n                    uint256 sinceStart = (block.timestamp - endTime) % limits[token].period;\\r\\n                    limits[token].endTime = block.timestamp + limits[token].period - sinceStart;\\r\\n                }\\r\\n            }\\r\\n            if (limit \\u003c buyAmount) revert OutOfLimit(limit); //OutOfLimit\\r\\n            limits[token].spent = buyAmount;\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\\r\\n     *\\r\\n     * This function uses the create opcode, which should never revert.\\r\\n     */\\r\\n    function clone(address implementation) internal returns (address instance) {\\r\\n        assembly {\\r\\n            let ptr := mload(0x40)\\r\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\r\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\r\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\r\\n            instance := create(0, ptr, 0x37)\\r\\n        }\\r\\n        if (instance == address(0)) revert ERC1167CreateFailed(); //ERC1167: create failed\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        require(msg.sender == gateway);\\r\\n    }\\r\\n}\\r\\n\"},\"DumperShieldToken.sol\":{\"content\":\"// Copyright (c) [2023], [Qwantum Finance Labs]\\r\\n// All rights reserved.\\r\\n// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IDSFactory {\\r\\n    function totalSupply(address token) external view returns (uint256);\\r\\n    function getLock(address token, address user) external view returns(uint256);\\r\\n    function setLock(address token, address user, uint256 time) external returns(bool);\\r\\n}\\r\\n\\r\\ncontract DumperShieldUser {\\r\\n\\r\\n    address public factory; // dumper shield factory\\r\\n    address public user;\\r\\n    error OnlyFactory();\\r\\n/*\\r\\n    address public dumperShield;\\r\\n    modifier onlyDumperShield() {\\r\\n        require(dumperShield == msg.sender, \\\"Only dumperShield allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n*/\\r\\n    modifier onlyFactory() {\\r\\n        if (factory != msg.sender) revert OnlyFactory();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor (address _user, address _factory) {\\r\\n        require(_user != address(0) \\u0026\\u0026 _factory != address(0));\\r\\n        user = _user;\\r\\n        factory = _factory;\\r\\n    }\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) external onlyFactory {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027DSU1\\u0027); //DumperShieldUser: TRANSFER_FAILED\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DumperShieldToken {\\r\\n    IERC20 public shieldedToken;   // address of shielded token\\r\\n    address public factory; // dumper shield factory\\r\\n    //address public router;\\r\\n    mapping(address =\\u003e address) public dumperShieldUsers;   // user address =\\u003e DumperShieldUser contract\\r\\n    address public DAO; // address of global voting contract\\r\\n\\r\\n    event CreateDumperShieldUser(address user, address dsUserContract);\\r\\n\\r\\n    modifier onlyFactory() {\\r\\n        require(factory == msg.sender, \\\"onlyFactory\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function initialize(address _token, address _dao) external {\\r\\n        require(address(shieldedToken) == address(0) \\u0026\\u0026 _token != address(0));\\r\\n        shieldedToken = IERC20(_token);\\r\\n        DAO = _dao;\\r\\n        //router = _router;\\r\\n        factory = msg.sender;\\r\\n    }\\r\\n    /**\\r\\n     * @dev Gets the balance of the specified address.\\r\\n     * @param user The address to query the the balance of.\\r\\n     * @return balance an uint256 representing the amount owned by the passed address.\\r\\n     */\\r\\n    function balanceOf(address user) external view returns (uint256 balance) {\\r\\n        return shieldedToken.balanceOf(dumperShieldUsers[user]);\\r\\n    }\\r\\n\\r\\n    // returns DumperShieldUser contract address. If user has not contract - create it.\\r\\n    function createDumperShieldUser(address user, address dsUser) external onlyFactory returns(address) {\\r\\n\\r\\n        if (dsUser == address(0)) {\\r\\n            dsUser = address(new DumperShieldUser(user, factory));\\r\\n            emit CreateDumperShieldUser(user, dsUser);\\r\\n        } else if (dumperShieldUsers[user] == dsUser) {\\r\\n            return dsUser;\\r\\n        }\\r\\n        dumperShieldUsers[user] = dsUser;\\r\\n        return dsUser;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return IDSFactory(factory).totalSupply(address(shieldedToken));\\r\\n    }\\r\\n\\r\\n    function setLock(address user, uint256 time) external returns(bool) {\\r\\n        require(msg.sender == DAO, \\\"Only DAO\\\");\\r\\n        return IDSFactory(factory).setLock(address(shieldedToken), user, time);\\r\\n    }\\r\\n\\r\\n    function getLock(address user) external view returns(uint256) {\\r\\n        return IDSFactory(factory).getLock(address(shieldedToken),user);\\r\\n    }\\r\\n\\r\\n    function setDAO(address _dao) external returns (bool) {\\r\\n        require(msg.sender == factory, \\\"Only factory\\\");\\r\\n        DAO = _dao;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // allow to rescue tokens that were transferet to this contract by mistake\\r\\n    function safeTransfer(address token, address to, uint value) external onlyFactory {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TRANSFER_FAILED\\u0027);\\r\\n    }\\r\\n}\"},\"Voting.sol\":{\"content\":\"// Copyright (c) [2023], [Qwantum Finance Labs]\\r\\n// All rights reserved.\\r\\n// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ncontract Voting {\\r\\n    \\r\\n    uint256 public ballotIds;\\r\\n    uint256 public rulesIds;\\r\\n    \\r\\n    enum Vote {None, Yea, Nay}\\r\\n    enum Status {New , Executed}\\r\\n\\r\\n    struct Rule {\\r\\n        //address contr;      // contract address which have to be triggered\\r\\n        uint32 majority;  // require more than this percentage of participants voting power (in according tokens).\\r\\n        string funcAbi;     // function ABI (ex. \\\"transfer(address,uint256)\\\")\\r\\n    }\\r\\n\\r\\n    struct Ballot {\\r\\n        uint256 closeVote; // timestamp when vote will close\\r\\n        uint256 ruleId; // rule which edit\\r\\n        address token;  // shielded token to vote\\r\\n        bytes args; // ABI encoded arguments for proposal which is required to call appropriate function\\r\\n        Status status;\\r\\n        address creator;    // wallet address of ballot creator.\\r\\n        uint256 yea;  // YEA votes according communities (tokens)\\r\\n        uint256 totalVotes;  // The total voting power od all participant according communities (tokens)\\r\\n    }\\r\\n    \\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bool)) public voted;      // user =\\u003e ballotID =\\u003e isVoted\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public locked;  // token =\\u003e user =\\u003e locked until (time)\\r\\n    mapping(address =\\u003e uint256) public votingTime;   // duration of voting\\r\\n    mapping(address =\\u003e uint256) public minimalLevel; // user who has this percentage of token can suggest change\\r\\n    mapping(uint256 =\\u003e Ballot) public ballots;\\r\\n    mapping(uint256 =\\u003e Rule) public rules;\\r\\n    mapping(address =\\u003e uint256) public totalSupply;   // token address =\\u003e total supply of locked tokens\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public dsBalanceOf;   // token =\\u003e dumper shield user contract =\\u003e balance (real balance may be different)\\r\\n    //event AddRule(address indexed contractAddress, string funcAbi, uint32 majorMain);\\r\\n    event ApplyBallot(address indexed token, uint256 indexed ruleId, uint256 indexed ballotId);\\r\\n    event BallotCreated(address indexed token, uint256 indexed ruleId, uint256 indexed ballotId);\\r\\n\\r\\n    // Errors\\r\\n    error OnlyVoting();\\r\\n    error ZeroAddress();\\r\\n    error WrongBallot();\\r\\n    error AlreadyVoted();\\r\\n    error VotingClosed();\\r\\n    error WrongRule();\\r\\n    error WrongToken();\\r\\n    error WrongLevel();\\r\\n    error ExecuteError(uint256 errorCode);\\r\\n    \\r\\n    modifier onlyVoting() {\\r\\n        if (address(this) != msg.sender) revert OnlyVoting();\\r\\n        _;        \\r\\n    }\\r\\n\\r\\n    function initialize() internal {\\r\\n        rules[0] = Rule(75,\\\"setVotingDuration(address,uint256)\\\");\\r\\n        rules[1] = Rule(75,\\\"setMinimalLevel(address,uint256)\\\");\\r\\n        rules[2] = Rule(75,\\\"setRouter(address,address)\\\");\\r\\n        rules[3] = Rule(75,\\\"setUnlockDate(address,uint256)\\\");\\r\\n        rules[4] = Rule(75,\\\"setLimits(address,uint256,uint256)\\\");\\r\\n        rules[5] = Rule(75,\\\"setDAO(address,address)\\\");\\r\\n        rules[6] = Rule(75,\\\"setGateway(address)\\\");\\r\\n        rules[7] = Rule(75,\\\"setPDO(address)\\\");\\r\\n        rulesIds = 7;\\r\\n        //super.initialize();\\r\\n    }\\r\\n    \\r\\n    // placeholder\\r\\n    function _updateBalanceAndTotal(address token, address dumperShieldUser, uint256 position) internal virtual returns (uint256 realBalance) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Add new rule - function that call target contract to change setting.\\r\\n        * @param contr The contract address which have to be triggered\\r\\n        * @param majority The majority level (%) for the tokens \\r\\n        * @param funcAbi The function ABI (ex. \\\"transfer(address,uint256)\\\")\\r\\n     */\\r\\n     /*\\r\\n    function addRule(\\r\\n        address contr,\\r\\n        uint32  majority,\\r\\n        string memory funcAbi\\r\\n    ) external onlyOwner {\\r\\n        require(contr != address(0), \\\"Zero address\\\");\\r\\n        rulesIds +=1;\\r\\n        rules[rulesIds] = Rule(contr, majority, funcAbi);\\r\\n        emit AddRule(contr, funcAbi, majority);\\r\\n    }\\r\\n    */\\r\\n\\r\\n    /**\\r\\n     * @dev Set voting duration\\r\\n     * @param time duration in seconds\\r\\n    */\\r\\n    function setVotingDuration(address token, uint256 time) external onlyVoting {\\r\\n        require(time \\u003e 600);\\r\\n        votingTime[token] = time;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Set minimal level to create proposal\\r\\n     * @param level in percentage. I.e. 10 = 10%\\r\\n    */\\r\\n    function setMinimalLevel(address token, uint256 level) external onlyVoting {\\r\\n        require(level \\u003e= 1 \\u0026\\u0026 level \\u003c= 51);    // not less then 1% and not more then 51%\\r\\n        minimalLevel[token] = level;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Get rules details.\\r\\n     * @param ruleId The rules index\\r\\n     * @return majority The level of majority in according tokens\\r\\n     * @return funcAbi The function Abi (ex. \\\"transfer(address,uint256)\\\")\\r\\n    */\\r\\n    function getRule(uint256 ruleId) external view returns(uint32 majority, string memory funcAbi) {\\r\\n        Rule storage r = rules[ruleId];\\r\\n        return (r.majority, r.funcAbi);\\r\\n    }\\r\\n    \\r\\n    function _checkMajority(uint32 majority, uint256 _ballotId) internal view returns(bool){\\r\\n        Ballot storage b = ballots[_ballotId];\\r\\n        if (b.yea * 2 \\u003e totalSupply[b.token]) {\\r\\n            return true;\\r\\n        }\\r\\n        if((b.totalVotes - b.yea) * 2 \\u003e totalSupply[b.token]){\\r\\n            return false;\\r\\n        }\\r\\n        if (block.timestamp \\u003e= b.closeVote \\u0026\\u0026 b.yea \\u003e b.totalVotes * majority / 100) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function vote(uint256 _ballotId, bool yea) external returns (bool){\\r\\n        if (_ballotId \\u003e ballotIds) revert WrongBallot();\\r\\n        if (voted[msg.sender][_ballotId]) revert AlreadyVoted();\\r\\n        \\r\\n        Ballot storage b = ballots[_ballotId];\\r\\n        uint256 closeVote = b.closeVote;\\r\\n        if (closeVote \\u003c= block.timestamp) revert VotingClosed();\\r\\n        uint256 power = _updateBalanceAndTotal(b.token, msg.sender, 0);\\r\\n        \\r\\n        if(yea){\\r\\n            b.yea += power;    \\r\\n        }\\r\\n        b.totalVotes += power;\\r\\n        voted[msg.sender][_ballotId] = true;\\r\\n        if(_checkMajority(rules[b.ruleId].majority, _ballotId)) {\\r\\n            _executeBallot(_ballotId);\\r\\n        } else if (locked[b.token][msg.sender] \\u003c closeVote) {\\r\\n            locked[b.token][msg.sender] = closeVote;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function createBallot(address token, uint256 ruleId, bytes calldata args) external {\\r\\n        if (ruleId \\u003e rulesIds) revert WrongRule();\\r\\n        Rule storage r = rules[ruleId];\\r\\n        address argToken = abi.decode(args,(address));\\r\\n        if (argToken != token) revert WrongToken();\\r\\n        uint256 power = _updateBalanceAndTotal(token, msg.sender, 0);\\r\\n        if (power \\u003c totalSupply[token] * minimalLevel[token] / 100) revert WrongLevel();\\r\\n        uint256 closeVote = block.timestamp + votingTime[token];\\r\\n        ballotIds += 1;\\r\\n        Ballot storage b = ballots[ballotIds];\\r\\n        b.ruleId = ruleId;\\r\\n        b.token = token;\\r\\n        b.args = args;\\r\\n        b.creator = msg.sender;\\r\\n        b.yea = power;\\r\\n        b.totalVotes = power;\\r\\n        b.closeVote = closeVote;\\r\\n        b.status = Status.New;\\r\\n        voted[msg.sender][ballotIds] = true;\\r\\n        emit BallotCreated(token, ruleId, ballotIds);\\r\\n        \\r\\n        if (_checkMajority(r.majority, ballotIds)) {\\r\\n            _executeBallot(ballotIds);\\r\\n        } else if (locked[token][msg.sender] \\u003c closeVote) {\\r\\n            locked[token][msg.sender] = closeVote;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function executeBallot(uint256 _ballotId) external {\\r\\n        Ballot storage b = ballots[_ballotId];\\r\\n        if(_checkMajority(rules[b.ruleId].majority, _ballotId)){\\r\\n            _executeBallot(_ballotId);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    \\r\\n    /**\\r\\n     * @dev Apply changes from ballot.\\r\\n     * @param ballotId The ballot index\\r\\n     */\\r\\n    function _executeBallot(uint256 ballotId) internal {\\r\\n        Ballot storage b = ballots[ballotId];\\r\\n        if (b.status == Status.Executed) revert ExecuteError(1); // already executed\\r\\n        Rule storage r = rules[b.ruleId];\\r\\n        bytes memory command = abi.encodePacked(bytes4(keccak256(bytes(r.funcAbi))), b.args);\\r\\n        trigger(address(this), command);\\r\\n        b.closeVote = block.timestamp;\\r\\n        b.status = Status.Executed;\\r\\n        emit ApplyBallot(b.token, b.ruleId, ballotId);\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @dev Apply changes from Governance System. Call destination contract.\\r\\n     * @param contr The contract address to call\\r\\n     * @param params encoded params\\r\\n     */\\r\\n    function trigger(address contr, bytes memory params) internal  {\\r\\n        (bool success,) = contr.call(params);\\r\\n        if (!success) revert ExecuteError(2); //Trigger error\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyVoted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"awaitAmount\",\"type\":\"uint256\"}],\"name\":\"AwaitPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1167CreateFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"ExecuteError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LowAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LowBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDSToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyVoting\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"OutOfLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyShielded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIsLockedInVoting\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIsNotShielded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UserIsNotInDumperShield\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VotingClosed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"WantToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongBallot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongLevel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongRule\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ruleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ballotId\",\"type\":\"uint256\"}],\"name\":\"ApplyBallot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ruleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ballotId\",\"type\":\"uint256\"}],\"name\":\"BallotCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveAmount\",\"type\":\"uint256\"}],\"name\":\"BuyOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"CancelOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"CompleteOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ConfirmOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dumperShieldToken\",\"type\":\"address\"}],\"name\":\"CreateDumperShield\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dsUserContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"CreateDumperShieldUserPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenSell\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum DumperShieldFactory.OrderStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"CreateOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DumperShieldTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"}],\"name\":\"DumperShieldUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldValue\",\"type\":\"uint256\"}],\"name\":\"PaymentFromGateway\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueB\",\"type\":\"uint256\"}],\"name\":\"PutOnSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Reimburse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueB\",\"type\":\"uint256\"}],\"name\":\"RemoveFromSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DumperShieldTokenImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE_COIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PDO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Unused_dsRouters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Unused_tokensSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ballotIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ballots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"closeVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ruleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"},{\"internalType\":\"enum Voting.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"yea\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVotes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"}],\"name\":\"buyOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"buyOrderBehalf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ruleId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"}],\"name\":\"createBallot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"createDumperShield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"depositPosition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dsBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dsUnlockDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dumperShieldTokens\",\"outputs\":[{\"internalType\":\"contract DumperShieldToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ballotId\",\"type\":\"uint256\"}],\"name\":\"executeBallot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"maker\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"taker\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"}],\"name\":\"gatewayBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"getDSUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"dsUser\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"getLastBuyOrder\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"getLastSellOrder\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrdersNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"}],\"name\":\"getQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ruleId\",\"type\":\"uint256\"}],\"name\":\"getRule\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"majority\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"funcAbi\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newDumperShieldTokenImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"limits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minimalLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenSell\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"enum DumperShieldFactory.OrderStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"position\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"restrictedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rules\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"majority\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"funcAbi\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rulesIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenSell\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"sellPosition\",\"type\":\"uint16\"}],\"name\":\"sellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"setDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"maker\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"taker\",\"type\":\"uint16\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGateway\",\"type\":\"address\"}],\"name\":\"setGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setMinimalLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPDO\",\"type\":\"address\"}],\"name\":\"setPDO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newUnlockDate\",\"type\":\"uint256\"}],\"name\":\"setUnlockDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setVotingDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"name\":\"setWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ret\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"}],\"name\":\"transferBatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ret\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ballotId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"yea\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DumperShieldFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8515a1bcb474b71955d72c1516fa19b85f5b60c26a9070e73ccbe1fd24f621f2"}