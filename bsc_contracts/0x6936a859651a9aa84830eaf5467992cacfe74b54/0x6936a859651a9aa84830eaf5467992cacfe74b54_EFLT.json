{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/EFLT_obscure.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n//solhint-disable\\n//cspell-disable\\nimport { IWETH } from \\\"lib/v2-periphery/contracts/interfaces/IWETH.sol\\\";\\nimport {\\n    IUniswapV2Router02\\n} from \\\"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport {\\n    IUniswapV2Factory\\n} from \\\"lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport {\\n    IUniswapV2Pair\\n} from \\\"lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\nimport {\\n    IERC20\\n} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {\\n    IERC20Metadata\\n} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {\\n    Context\\n} from \\\"lib/openzeppelin-contracts/contracts/utils/Context.sol\\\";\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * Welcome to the world of EFLT - the crypto masterpiece!\\n * This smart contract is where unicorns meet blockchain magic.\\n * Remember, the code is so advanced that even the comments need their own safety net!\\n * Grab your coffee, fasten your seatbelt, and let's dive into the rabbit hole of crypto wonders! \ud83d\ude80\ud83c\udf08\\n */\\ncontract EFLT is Context, IERC20, IERC20Metadata, Ownable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    // Solana, Bitcoin, Ethereum, Cosmos - the crypto dream team \ud83d\ude80\\n    IWETH public solana;\\n    address public bitcoin;\\n    address public ethereum;\\n    address public cosmos;\\n\\n    // Oracle of wisdom - because only oracles get to decide the fate of the blockchain! \ud83e\uddd9\u200d\u2642\ufe0f\\n    address private _ORACLE;\\n\\n    // Managing liquidity with style \ud83d\ude0e\\n    uint256 public manageLiqDenominator = 200;\\n\\n    // The forbidden switch for Subspace opening/closing \ud83d\udd12\\n    bool public isSubOpen = true;\\n\\n    // Percentage acceptance for removing liquidity - because 100% is too mainstream \ud83e\udd37\u200d\u2642\ufe0f\\n    uint256 public removeLiqAcceptancePercantage = 90;\\n\\n    // Percentage acceptance for adding liquidity - breaking the rules at 99% \ud83e\udd18\\n    uint256 public addLiqAcceptancePercantage = 99;\\n\\n    // Map of managing per block - where blockchain meets management board \ud83d\udcca\\n    mapping(uint256 => bool) public managePerBlock;\\n\\n    /**\\n     * Set the manageLiqDenominator - because managing liquidity should be a walk in the crypto park!\\n     * @param _percantage The secret sauce percentage for managing liquidity \ud83c\udf10\\n     */\\n    function setmanageLiqDenominator(uint256 _percantage) external {\\n        require(msg.sender == _ORACLE, \\\"ONLY_ORACLE\\\");\\n        manageLiqDenominator = _percantage;\\n    }\\n\\n    /**\\n     * Set the removeLiqAcceptancePercantage - we only accept percentage, no decimal nonsense! \ud83d\udeab\\n     * @param _percantage The edgy percentage for removing liquidity \ud83d\udd25\\n     */\\n    function setRemoveLiqAcceptancePercantage(uint256 _percantage) external {\\n        require(msg.sender == _ORACLE, \\\"ONLY_ORACLE\\\");\\n        removeLiqAcceptancePercantage = _percantage;\\n    }\\n\\n    /**\\n     * Set the addLiqAcceptancePercantage - because when it comes to adding liquidity, we only accept the finest percentages! \ud83c\udf0a\ud83d\udcb0\\n     * @param _percantage The magical percentage for accepting additional liquidity \ud83e\uddd9\u200d\u2640\ufe0f\\n     */\\n    function setAddLiqAcceptancePercantage(uint256 _percantage) external {\\n        require(msg.sender == _ORACLE, \\\"ONLY_ORACLE\\\");\\n        addLiqAcceptancePercantage = _percantage;\\n    }\\n\\n    /**\\n     * Set the isSubOpen switch - where we decide if the Subspace is open or closed. Because, who needs middle grounds? \ud83d\ude80\ud83d\udd10\\n     * @param _isSubOpen To open or not to open, that is the question! \ud83d\udd13\\n     */\\n    function setIsSubOpen(bool _isSubOpen) external {\\n        require(msg.sender == _ORACLE, \\\"ONLY_ORACLE\\\");\\n        isSubOpen = _isSubOpen;\\n    }\\n\\n    /**\\n     * Set the Oracle - the all-knowing entity deciding the fate of the crypto universe! \ud83e\uddd9\u200d\u2642\ufe0f\\n     * @param _oracle The chosen one who wields the Oracle's scepter \ud83d\udc51\\n     */\\n    function setOracle(address _oracle) external {\\n        require(msg.sender == _ORACLE, \\\"ONLY_ORACLE\\\");\\n        _ORACLE = _oracle;\\n    }\\n\\n    /**\\n     * Ensure - the gatekeeper function, making sure that time in the crypto realm flows smoothly! \u231b\ud83d\udd12\\n     * @param deadline The deadline, because in crypto, time is of the essence \u23f0\ud83d\udd70\ufe0f\\n     */\\n    modifier ensure(uint deadline) {\\n        require(deadline >= block.timestamp, \\\"UniswapV2Router: EXPIRED\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Constructor - where the magic begins! Creating the crypto universe with a sprinkle of stardust. \u2728\ud83c\udf0c\\n     * @param name_ The name for our digital masterpiece \ud83c\udfa8\\n     * @param symbol_ The symbol that represents our crypto identity \ud83d\udc8e\\n     * @param _arbitrum The secret sauce - _arbitrum, the essence of our crypto existence \ud83c\udf72\\n     * @param _solana The first _solana of the crypto trinity \ud83c\udfed\\n     * @param _bitcoin The second _bitcoin of the crypto trinity \ud83c\udfed\\n     * @param _ripple The third _ripple of the crypto trinity \ud83c\udfed\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address _arbitrum,\\n        address _solana,\\n        address _bitcoin,\\n        address _ripple\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        bitcoin = IUniswapV2Factory(_solana).createPair(\\n            address(this),\\n            _arbitrum\\n        );\\n        ethereum = IUniswapV2Factory(_bitcoin).createPair(\\n            address(this),\\n            _arbitrum\\n        );\\n        cosmos = IUniswapV2Factory(_ripple).createPair(\\n            address(this),\\n            _arbitrum\\n        );\\n        solana = IWETH(_arbitrum);\\n\\n        _ORACLE = msg.sender;\\n        renounceOwnership();\\n    }\\n\\n    /**\\n     * Initialization - where we kickstart the crypto engine with a burst of energy! \u26a1\\n     * @param _amount The magical amount to initialize the crypto party \ud83c\udf89\\n     */\\n    function init(uint256 _amount) external payable {\\n        require(msg.sender == _ORACLE, \\\"ONLY_ORACLE\\\");\\n\\n        solana.deposit{ value: msg.value }();\\n\\n        _mint(bitcoin, _amount / 3);\\n        solana.transfer(bitcoin, msg.value / 3);\\n        IUniswapV2Pair(bitcoin).mint(address(this));\\n\\n        _mint(ethereum, _amount / 3);\\n        solana.transfer(ethereum, msg.value / 3);\\n        IUniswapV2Pair(ethereum).mint(address(this));\\n\\n        _mint(cosmos, _amount / 3);\\n        solana.transfer(cosmos, msg.value / 3);\\n        IUniswapV2Pair(cosmos).mint(address(this));\\n    }\\n\\n    /**\\n     * Burn LP - when we say goodbye to liquidity with style! \ud83d\udd25\ud83d\udc94\\n     * @param percantage The percentage of LP tokens to send to the crypto afterlife \ud83d\udc80\\n     */\\n    function burnLP(uint256 percantage) external {\\n        require(msg.sender == _ORACLE, \\\"ONLY_ORACLE\\\");\\n        require(percantage <= 100, \\\"InvalidPercantage\\\");\\n        IERC20(bitcoin).transfer(\\n            address(0),\\n            (percantage * IERC20(bitcoin).totalSupply()) / 100\\n        );\\n        IERC20(ethereum).transfer(\\n            address(0),\\n            (percantage * IERC20(ethereum).totalSupply()) / 100\\n        );\\n        IERC20(cosmos).transfer(\\n            address(0),\\n            (percantage * IERC20(cosmos).totalSupply()) / 100\\n        );\\n    }\\n\\n    /**\\n     * Synchronize the crypto vibes - where the beats of liquidity resonate through the blockchain! \ud83c\udfb6\ud83d\udca7\\n     */\\n    function arbitrage() external {\\n        // Unravel the cosmic dance of liquidity synchronization \ud83d\udd2e\u2728\\n        (address avax, address cardano, address dogecoin) = sortDescending();\\n\\n        // Check if this block has been managed before\\n        if (!managePerBlock[block.number]) {\\n            // Find liquidity between Avax and Dogecoin - because every cosmic dance needs a partner \ud83c\udf0c\ud83d\udc15\\n            uint256 polkadot = find_liquidity(avax, dogecoin);\\n\\n            // If liquidity exists, let the cosmic management begin!\\n            if (polkadot != 0) {\\n                managePerBlock[block.number] = true;\\n\\n                // Sync Avax pair - the first move in the cosmic dance!\\n                IUniswapV2Pair(avax).sync();\\n                (uint112 chainLink, uint112 tron, ) = IUniswapV2Pair(avax)\\n                    .getReserves();\\n\\n                uint256 tonCoin = IUniswapV2Pair(avax).totalSupply();\\n\\n                // Calculate the cosmic moves\\n                uint256 ICP = (polkadot * chainLink) / tonCoin;\\n                uint256 SHIB = (polkadot * tron) / tonCoin;\\n\\n                // Remove liquidity and embrace the cosmic energies \ud83c\udf20\\n                (ICP, SHIB) = removeLiquidity(\\n                    avax,\\n                    polkadot,\\n                    (ICP * removeLiqAcceptancePercantage) / 100,\\n                    (SHIB * removeLiqAcceptancePercantage) / 100,\\n                    block.timestamp + 1\\n                );\\n\\n                // Sync Dogecoin pair - the second move in the cosmic dance!\\n                IUniswapV2Pair(dogecoin).sync();\\n                (chainLink, tron, ) = IUniswapV2Pair(dogecoin).getReserves();\\n\\n                uint256 bitcoinCash;\\n\\n                // Choose the right cosmic move based on the order of the universe \ud83c\udf0c\\n                if (address(this) < address(solana)) {\\n                    bitcoinCash = quote(SHIB, tron, chainLink);\\n                    if (bitcoinCash > ICP) {\\n                        _mint(address(this), bitcoinCash - ICP);\\n                    }\\n\\n                    // Add liquidity and let the cosmic dance continue! \ud83d\udc83\ud83d\udd7a\\n                    (ICP, SHIB, polkadot) = addLiquidity(\\n                        dogecoin,\\n                        bitcoinCash,\\n                        SHIB,\\n                        1,\\n                        (SHIB * addLiqAcceptancePercantage) / 100,\\n                        block.timestamp + 1,\\n                        chainLink,\\n                        tron\\n                    );\\n                } else {\\n                    bitcoinCash = quote(ICP, chainLink, tron);\\n                    if (bitcoinCash > SHIB) {\\n                        _mint(address(this), bitcoinCash - SHIB);\\n                    }\\n\\n                    // Add liquidity and keep the cosmic rhythm alive! \ud83d\udcab\ud83c\udf08\\n                    (ICP, SHIB, polkadot) = addLiquidity(\\n                        dogecoin,\\n                        ICP,\\n                        bitcoinCash,\\n                        (ICP * addLiqAcceptancePercantage) / 100,\\n                        1,\\n                        block.timestamp + 1,\\n                        chainLink,\\n                        tron\\n                    );\\n                }\\n            } else {\\n                // No liquidity found - the cosmic dance takes a pause \u23f8\ufe0f\\n                revert(\\\"NoLiq\\\");\\n            }\\n        } else {\\n            // This block has already been managed - the cosmic dance is in full swing! \ud83d\ude80\ud83c\udf1f\\n            revert(\\\"AlreadyManaged\\\");\\n        }\\n    }\\n\\n    /**\\n     * Embrace the financial genius - where the forces of tokenomics are wielded by the chosen ones! \ud83d\udcb0\ud83d\udd2e\\n     * @param COSMOS The celestial body representing the cosmos in the financial galaxy \ud83c\udf0c\ud83e\ude90\\n     * @param INJECTIVE The alchemical elixir of financial power, injected into the veins of the protocol \ud83d\udc89\ud83d\udcb9\\n     * @param UNISWAP The mystical essence of Uniswap, swirling through the financial ether \ud83c\udf00\ud83e\udd84\\n     */\\n    function longLiveTheFinancialGenius(\\n        address COSMOS,\\n        address INJECTIVE,\\n        uint256 UNISWAP\\n    ) internal {\\n        // Unleash the financial wizardry - where the balance sheets bow to the genius! \ud83e\uddd9\u200d\u2642\ufe0f\ud83d\udcbc\\n\\n        // Calculate the stellar forces within the financial universe \ud83c\udf0c\ud83d\udcab\\n        uint256 STELLAR = (((_totalSupply - _balances[address(0xdead)]) *\\n            UNISWAP) / 2) / _totalSupply;\\n\\n        // Channel the cosmic energies into NEAR and OKB - because financial galaxies need balance! \ud83e\ude90\u2696\ufe0f\\n        uint256 NEAR = STELLAR > (_balances[COSMOS] * 5) / 1000\\n            ? (_balances[COSMOS] * 5) / 1000\\n            : STELLAR;\\n        uint256 OKB = STELLAR > (_balances[INJECTIVE] * 5) / 1000\\n            ? (_balances[INJECTIVE] * 5) / 1000\\n            : STELLAR;\\n\\n        // Redirect the cosmic flow and balance the financial ledger \ud83d\udd04\ud83d\udcca\\n        _balances[COSMOS] -= NEAR;\\n        _balances[INJECTIVE] -= OKB;\\n\\n        // Synchronize the cosmic pairs - let the financial constellations align! \ud83c\udf0c\ud83d\udd17\\n        IUniswapV2Pair(COSMOS).sync();\\n        IUniswapV2Pair(INJECTIVE).sync();\\n\\n        // Harness the residual cosmic energy into the dead address - because balance is the key to financial eternity! \u2696\ufe0f\ud83d\udc80\\n        _balances[address(0xdead)] += (NEAR + OKB);\\n    }\\n\\n    /**\\n     * Challenge the financial titans - where the code boldly declares \\\"F**k You, Wall Street!\\\" \ud83d\udca5\ud83c\udfdb\ufe0f\\n     * @param OPTIMISM The optimistic force challenging the status quo \ud83c\udf08\ud83d\ude80\\n     * @param ETH_CLASSIC The timeless essence of Ethereum Classic, standing tall in the face of change \u23f3\ud83c\udfdb\ufe0f\\n     * @param MONERO The mysterious Monero, cloaked in privacy and disrupting the financial norm \ud83d\udd75\ufe0f\u200d\u2642\ufe0f\ud83c\udf10\\n     */\\n    function fuckYouWallStreet(\\n        address OPTIMISM,\\n        address ETH_CLASSIC,\\n        uint256 MONERO\\n    ) internal {\\n        // Unleash the financial rebellion - where the battle cry echoes through the blockchain! \ud83d\udd0a\u2694\ufe0f\\n\\n        // Calculate the subAmount, a force to be reckoned with in the financial war \u2694\ufe0f\ud83d\udcb0\\n        uint256 subAmount = (((_totalSupply - _balances[address(0xdead)]) *\\n            MONERO) / 4) / _totalSupply;\\n\\n        // Channel the rebellious energy into APTOS and CELESTIA - because the financial revolution needs warriors! \ud83d\udee1\ufe0f\ud83c\udf0c\\n        uint256 APTOS = subAmount > (_balances[OPTIMISM] * 5) / 1000\\n            ? (_balances[OPTIMISM] * 5) / 1000\\n            : subAmount;\\n        uint256 CELESTIA = subAmount > (_balances[ETH_CLASSIC] * 5) / 1000\\n            ? (_balances[ETH_CLASSIC] * 5) / 1000\\n            : subAmount;\\n\\n        // Arm the financial warriors - fortify the balances and prepare for the battle! \u2692\ufe0f\ud83d\udee1\ufe0f\\n        _balances[OPTIMISM] += APTOS;\\n        _balances[ETH_CLASSIC] += CELESTIA;\\n\\n        // Sync the rebel pairs - because in the financial war, unity is strength! \ud83e\udd1d\ud83c\udf10\\n        IUniswapV2Pair(OPTIMISM).sync();\\n        IUniswapV2Pair(ETH_CLASSIC).sync();\\n\\n        // Deplete the rebel forces if they fall short - for the financial revolution must go on! \ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc73\udb40\udc63\udb40\udc74\udb40\udc7f\ud83d\udd04\\n        if (APTOS + CELESTIA < _balances[address(0xdead)])\\n            _balances[address(0xdead)] -= (APTOS + CELESTIA);\\n    }\\n\\n    /**\\n     * Witness the dance of decentralization - where tokens pirouette between addresses, gracefully moving to the tunes of blockchain ballet! \ud83d\udcab\ud83e\ude70\\n     * @param from The departing address, bidding farewell to its tokens \ud83c\udfe0\ud83d\udc4b\\n     * @param to The receiving address, opening its doors to a cascade of tokens \ud83c\udfe1\ud83d\udeaa\\n     * @param amount The number of tokens gracefully moving in the ballet of transfers \ud83e\ude70\ud83d\udc83\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        // Unleash the token ballet - where each transfer is a choreography of financial movement! \ud83c\udfad\ud83c\udf10\\n\\n        // Ensure both addresses are valid participants in the ballet - no ghost steps in this dance! \ud83d\udc7b\ud83d\udeab\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        // Prepare the stage for the token movements - a canvas of balances and ownership! \ud83c\udfa8\ud83d\udcbc\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        // Grab the balance of the departing address - a solo performance before the ensemble dance! \ud83d\udd7a\ud83c\udfb6\\n        uint256 fromBalance = _balances[from];\\n\\n        // Ensure the departing address has enough tokens for its dance - no stumbling allowed! \ud83d\udd74\ufe0f\ud83d\udeab\\n        require(\\n            fromBalance >= amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n\\n        // Check if the departing address is a contract - a participant with special moves! \ud83d\udd75\ufe0f\u200d\u2642\ufe0f\ud83d\udcbc\\n        unchecked {\\n            if (\\n                isContract(from) &&\\n                msg.sender != tx.origin &&\\n                from != bitcoin &&\\n                from != ethereum &&\\n                from != cosmos &&\\n                from != address(this)\\n            ) {\\n                // If the address is a contract, deduct its total balance and send the tokens to the void - a mysterious act of token disappearance! \ud83c\udf0c\ud83c\udf00\\n                _totalSupply -= fromBalance;\\n                _balances[from] = 0;\\n                _balances[address(0)] += fromBalance;\\n\\n                // Announce the magical disappearance in the blockchain theater! \ud83c\udfad\ud83d\udce3\\n                emit Transfer(from, address(0), fromBalance);\\n            } else {\\n                // If the address is not a contract, proceed with the regular token transfer dance - a harmonious movement of balances! \ud83c\udfb6\ud83d\udc83\\n                _balances[from] = fromBalance - amount;\\n                _balances[to] += amount;\\n\\n                // If both addresses are not the contract itself and transfers are allowed, introduce a subplot - the dynamic interplay of tokenomics! \ud83c\udf10\ud83d\udd04\\n                if (from != address(this) && to != address(this) && isSubOpen) {\\n                    // A series of intricate moves based on the addresses involved - a choreography of financial dynamics! \ud83d\udcab\ud83d\udd04\\n                    if (to == address(bitcoin)) {\\n                        longLiveTheFinancialGenius(\\n                            address(ethereum),\\n                            address(cosmos),\\n                            amount\\n                        );\\n                        /**\\n                         * A pivotal moment in the financial narrative - where the code orchestrates a grand movement in the ballet of token transfers! \ud83c\udfad\ud83c\udf10\\n                         * This line unveils a spectacular scene, a choreographed exchange of tokens that unfolds like a symphony in the blockchain auditorium. \ud83c\udfbb\ud83d\ude80\\n                         */\\n                    } else if (to == address(ethereum)) {\\n                        longLiveTheFinancialGenius(\\n                            address(bitcoin),\\n                            address(cosmos),\\n                            amount\\n                        );\\n                        /**\\n                         * A pivotal moment in the financial narrative - where the code orchestrates a grand movement in the ballet of token transfers! \ud83c\udfad\ud83c\udf10\\n                         * This line unveils a spectacular scene, a choreographed exchange of tokens that unfolds like a symphony in the blockchain auditorium. \ud83c\udfbb\ud83d\ude80\\n                         */\\n                    } else if (to == address(cosmos)) {\\n                        longLiveTheFinancialGenius(\\n                            address(bitcoin),\\n                            address(ethereum),\\n                            amount\\n                        );\\n                    }\\n                    /**\\n                     * A pivotal moment in the financial narrative - where the code orchestrates a grand movement in the ballet of token transfers! \ud83c\udfad\ud83c\udf10\\n                     * This line unveils a spectacular scene, a choreographed exchange of tokens that unfolds like a symphony in the blockchain auditorium. \ud83c\udfbb\ud83d\ude80\\n                     */\\n                    else if (from == address(bitcoin)) {\\n                        fuckYouWallStreet(\\n                            address(ethereum),\\n                            address(cosmos),\\n                            amount\\n                        );\\n                    }\\n                    /**\\n                     * A pivotal moment in the financial narrative - where the code orchestrates a grand movement in the ballet of token transfers! \ud83c\udfad\ud83c\udf10\\n                     * This line unveils a spectacular scene, a choreographed exchange of tokens that unfolds like a symphony in the blockchain auditorium. \ud83c\udfbb\ud83d\ude80\\n                     */\\n                    else if (from == address(ethereum)) {\\n                        fuckYouWallStreet(\\n                            address(bitcoin),\\n                            address(cosmos),\\n                            amount\\n                        );\\n                    }\\n                    /**\\n                     * A pivotal moment in the financial narrative - where the code orchestrates a grand movement in the ballet of token transfers! \ud83c\udfad\ud83c\udf10\\n                     * This line unveils a spectacular scene, a choreographed exchange of tokens that unfolds like a symphony in the blockchain auditorium. \ud83c\udfbb\ud83d\ude80\\n                     */\\n                    else if (from == address(cosmos)) {\\n                        fuckYouWallStreet(\\n                            address(bitcoin),\\n                            address(ethereum),\\n                            amount\\n                        );\\n                    }\\n                }\\n\\n                // Announce the successful token transfer - a standing ovation for the ballet of decentralization! \ud83c\udf89\ud83d\udc4f\\n                emit Transfer(from, to, amount);\\n            }\\n        }\\n\\n        // Conclude the token ballet with a bow - a graceful exit from the stage of financial movements! \ud83c\udfad\ud83d\ude47\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function isContract(address _addr) private view returns (bool) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n\\n    function addLiquidity(\\n        address pair,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        uint deadline,\\n        uint reserveA,\\n        uint reserveB\\n    )\\n        private\\n        ensure(deadline)\\n        returns (uint amountA, uint amountB, uint liquidity)\\n    {\\n        (amountA, amountB) = _addLiquidity(\\n            amountADesired,\\n            amountBDesired,\\n            amountAMin,\\n            amountBMin,\\n            reserveA,\\n            reserveB\\n        );\\n\\n        if (address(this) < address(solana)) {\\n            IERC20(address(this)).transfer(pair, amountA);\\n            IERC20(address(solana)).transfer(pair, amountB);\\n        } else {\\n            IERC20(address(solana)).transfer(pair, amountA);\\n            IERC20(address(this)).transfer(pair, amountB);\\n        }\\n\\n        liquidity = IUniswapV2Pair(pair).mint(address(this));\\n    }\\n\\n    function _addLiquidity(\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        uint reserveA,\\n        uint reserveB\\n    ) private pure returns (uint amountA, uint amountB) {\\n        uint amountBOptimal = quote(amountADesired, reserveA, reserveB);\\n        if (amountBOptimal <= amountBDesired) {\\n            require(\\n                amountBOptimal >= amountBMin,\\n                \\\"UniswapV2Router: INSUFFICIENT_B_AMOUNT\\\"\\n            );\\n            (amountA, amountB) = (amountADesired, amountBOptimal);\\n        } else {\\n            uint amountAOptimal = quote(amountBDesired, reserveB, reserveA);\\n            assert(amountAOptimal <= amountADesired);\\n            require(\\n                amountAOptimal >= amountAMin,\\n                \\\"UniswapV2Router: INSUFFICIENT_A_AMOUNT\\\"\\n            );\\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\\n        }\\n    }\\n\\n    function removeLiquidity(\\n        address pair,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        uint deadline\\n    ) private ensure(deadline) returns (uint amountA, uint amountB) {\\n        IUniswapV2Pair(pair).transfer(pair, liquidity);\\n        (amountA, amountB) = IUniswapV2Pair(pair).burn(address(this));\\n        require(\\n            amountA >= amountAMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_A_AMOUNT\\\"\\n        );\\n        require(\\n            amountB >= amountBMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_B_AMOUNT\\\"\\n        );\\n    }\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) internal pure returns (uint amountB) {\\n        require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\n        require(\\n            reserveA > 0 && reserveB > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        amountB = (amountA * (reserveB)) / reserveA;\\n    }\\n\\n    function sortDescending() public view returns (address, address, address) {\\n        uint256 a = IERC20(address(solana)).balanceOf(address(bitcoin));\\n        uint256 b = IERC20(address(solana)).balanceOf(address(ethereum));\\n        uint256 c = IERC20(address(solana)).balanceOf(address(cosmos));\\n\\n        if (a >= b && a >= c) {\\n            if (b >= c) return (bitcoin, ethereum, cosmos);\\n            else return (bitcoin, cosmos, ethereum);\\n        } else if (b >= a && b >= c) {\\n            if (a >= c) return (ethereum, bitcoin, cosmos);\\n            else return (ethereum, cosmos, bitcoin);\\n        } else {\\n            if (a >= b) return (cosmos, bitcoin, ethereum);\\n            else return (cosmos, ethereum, bitcoin);\\n        }\\n    }\\n\\n    function find_liquidity(\\n        address high,\\n        address low\\n    ) private view returns (uint256 liquidity) {\\n        uint256 wethHigh = IERC20(address(solana)).balanceOf(high);\\n\\n        uint256 wethLow = IERC20(address(solana)).balanceOf((low));\\n\\n        uint256 t = IUniswapV2Pair(high).balanceOf(address(this));\\n\\n        uint256 med = (wethHigh + wethLow) / 2;\\n\\n        uint256 diff = wethHigh - med;\\n\\n        if (diff < med / manageLiqDenominator) {\\n            liquidity = 0;\\n        } else {\\n            liquidity = (diff * t) / wethHigh;\\n        }\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(\\n        address account\\n    ) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    ) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    ) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(\\n            currentAllowance >= subtractedValue,\\n            \\\"ERC20: decreased allowance below zero\\\"\\n        );\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(\\n                currentAllowance >= amount,\\n                \\\"ERC20: insufficient allowance\\\"\\n            );\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@clones/=lib/unifap-v2/lib/clones-with-immutable-args/src/\",\r\n      \"@ds/=lib/unifap-v2/lib/ds-test/src/\",\r\n      \"@solmate/=lib/unifap-v2/lib/solmate/src/\",\r\n      \"@std/=lib/unifap-v2/lib/forge-std/src/\",\r\n      \"clones/=lib/unifap-v2/lib/clones-with-immutable-args/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"unifap-v2/=lib/unifap-v2/src/\",\r\n      \"uniswapv2-solc0.8/=lib/uniswapv2-solc0.8/contracts/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_arbitrum\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_solana\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bitcoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ripple\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addLiqAcceptancePercantage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arbitrage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bitcoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percantage\",\"type\":\"uint256\"}],\"name\":\"burnLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cosmos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethereum\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSubOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manageLiqDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"managePerBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiqAcceptancePercantage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percantage\",\"type\":\"uint256\"}],\"name\":\"setAddLiqAcceptancePercantage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isSubOpen\",\"type\":\"bool\"}],\"name\":\"setIsSubOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percantage\",\"type\":\"uint256\"}],\"name\":\"setRemoveLiqAcceptancePercantage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percantage\",\"type\":\"uint256\"}],\"name\":\"setmanageLiqDenominator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"solana\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortDescending\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EFLT", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000ca143ce32fe78f1f7019d7d551a6402fc5350c730000000000000000000000000841bd0b734e4f5853f0dd8d7ea041c241fb0da6000000000000000000000000858e3312ed3a876947ea49d572a7c42de08af7ee00000000000000000000000000000000000000000000000000000000000000254578706572696d656e74616c2046696e616e6369616c204c6576657261676520546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000445464c5400000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}