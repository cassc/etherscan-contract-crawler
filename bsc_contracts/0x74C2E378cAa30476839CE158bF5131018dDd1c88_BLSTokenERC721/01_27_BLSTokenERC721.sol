// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

// Token
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";

// Assets
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";

// Utils
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol";

// Proxy
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

// Interfaces
import "@thirdweb-dev/contracts/extension/interface/IOwnable.sol";


contract BLSTokenERC721 is
    Initializable,
    IOwnable,
    ContextUpgradeable,
    AccessControlEnumerableUpgradeable,
    ERC721RoyaltyUpgradeable,
    ERC721URIStorageUpgradeable,
    ERC721EnumerableUpgradeable,
    ERC721BurnableUpgradeable,
    ERC721PausableUpgradeable
{
    using CountersUpgradeable for CountersUpgradeable.Counter;
    using StringsUpgradeable for uint256;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    uint private constant MAX_POWER_SIMPLE = 5;
    uint private constant MAX_POWER_EXCLUSIVE = 8;

    CountersUpgradeable.Counter private _tokenIdTracker;

    string private _baseTokenURI;

    /// @dev The recipient of who gets the royalty.
    address private royaltyRecipient;

    /// @dev Owner of the contract (purpose: OpenSea compatibility, etc.)
    address private _owner;

    /// @dev The percentage of royalty how much royalty in basis points.
    uint96 private defaultRoyaltyBps;

    /// @dev The preceding random number for the randomizer salt
    uint256 private seed;

    // Optional mapping for token URIs
    mapping(uint256 => string) private _tokenURIs;

    /// @dev Mapping from tokenId => boolean 0 - simple, 1 - exclusive
    mapping(uint256 => bool) public tokenIsExclusive;

    /// @dev Mapping from tokenId => token power
    mapping(uint256 => uint256) public tokenPower;

    function initialize(
        string memory name,
        string memory symbol,
        string memory baseTokenURI,
        address defaultAdmin,
        uint96 _defaultRoyaltyBps,
        address defaultRoyaltyRecipient
    ) public virtual initializer {
        __ERC721_init_unchained(name, symbol);
        __Pausable_init_unchained();

        _baseTokenURI = baseTokenURI;
        defaultRoyaltyBps = _defaultRoyaltyBps;

        _setDefaultRoyalty(defaultRoyaltyRecipient, _defaultRoyaltyBps);

        _setupRole(DEFAULT_ADMIN_ROLE, defaultAdmin);
        _setupRole(MINTER_ROLE, defaultAdmin);
        _setupRole(PAUSER_ROLE, defaultAdmin);
    }

    ///     =====   Public functions  =====

    /// @dev Returns the address of the current owner.
    function owner() public view returns (address) {
        return hasRole(DEFAULT_ADMIN_ROLE, _owner) ? _owner : address(0);
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address _to, string memory _tokenURI) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "BLSTokenERC721: must have minter role to mint");

        uint256 tokenId = _tokenIdTracker.current();

        _safeMint(_to, tokenId);
        _setTokenURI(tokenId, _tokenURI);
        _setTokenPower(tokenId);
        _setTokenRoyalty(tokenId, _to, defaultRoyaltyBps);

        _tokenIdTracker.increment();
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "BLSTokenERC721: must have pauser role to pause");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "BLSTokenERC721: must have pauser role to unpause");
        _unpause();
    }

    ///     =====   External functions  =====

    /// @dev Creates a new token with double parameters if token exclusive call function mint(address _to, string memory _tokenURI)
    function mint(address _to, string memory _tokenURI, bool _isExclusive) external virtual {
        tokenIsExclusive[_tokenIdTracker.current()] = _isExclusive;

        mint(_to, _tokenURI);
    }

    function mintBatch(
        uint256[] memory _ids,
        address[] memory _to,
        string[] calldata URIs,
        uint256[] memory _powers,
        bool[] memory _isExclusives
    ) external virtual {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BLSTokenERC721: must have admin role for migration");

        uint tokenId;
        for (uint256 i = 0; i < _ids.length; i++) {
            tokenId = _ids[i];
            _safeMint(_to[i], tokenId);
            _setTokenURI(tokenId, URIs[i]);
            tokenIsExclusive[tokenId] = _isExclusives[i];
            tokenPower[tokenId] = _powers[i];
            _setTokenRoyalty(tokenId, _to[i], defaultRoyaltyBps);
        }
    }

    //      =====   Setter functions  =====

    /**
     * @dev Change base token URI
     */
    function setBaseTokenURI(string memory baseTokenURI) external virtual {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BLSTokenERC721: must have admin role to set");

        _baseTokenURI = baseTokenURI;
    }

    /**
     * @dev Change base token URI
     */
    function setDefaultRoyaltyBps(uint96 _defaultRoyaltyBps) external virtual {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BLSTokenERC721: must have admin role to set");

        defaultRoyaltyBps = _defaultRoyaltyBps;
    }

    function setDefaultRoyalty(address _defaultRoyaltyRecipient, uint96 _defaultRoyaltyBps)
    external
    onlyRole(DEFAULT_ADMIN_ROLE)
    {
        defaultRoyaltyBps = _defaultRoyaltyBps;
        _setDefaultRoyalty(_defaultRoyaltyRecipient, _defaultRoyaltyBps);
    }

    /// @dev Lets a module admin set a new owner for the contract. The new owner must be a module admin.
    function setOwner(address _newOwner) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(hasRole(DEFAULT_ADMIN_ROLE, _newOwner), "new owner not module admin.");
        address _prevOwner = _owner;
        _owner = _newOwner;

        emit OwnerUpdated(_prevOwner, _newOwner);
    }

    ///     =====   Internal functions  =====

    /**
     * @dev Generate random number for nft power
     */
    function random(uint256 tokenId) internal view returns (uint power) {
        uint256 randomNum = uint(keccak256(abi.encodePacked(block.timestamp, _msgSender(), tokenId)));

        if (tokenIsExclusive[tokenId]) {
            power = randomNum % 3 + 6; // exclusive from 6 to 8
        } else {
            power = randomNum % 5 + 1; // simple from 1 to 5
        }
    }

    /**
     * @dev Set token power
     */
    function _setTokenPower(uint256 tokenId) internal virtual {
        tokenPower[tokenId] = random(tokenId);
    }

    ///     =====   Low-level overrides  =====

    /**
     * @dev See {ERC721-_burn}. This override additionally checks to see if a
     * token-specific URI was set for the token, and if so, it deletes the token URI from
     * the storage mapping.
     */
    function _burn(uint256 tokenId) internal virtual
    override(ERC721RoyaltyUpgradeable, ERC721URIStorageUpgradeable, ERC721Upgradeable)
    {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId) public view virtual
    override(ERC721Upgradeable, ERC721URIStorageUpgradeable)
    returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721PausableUpgradeable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev Set token power
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(AccessControlEnumerableUpgradeable, ERC721RoyaltyUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable)
    returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[50] private __gap;

}