{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/AARUES.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./proxy/Initializable.sol\\\";\\r\\nimport \\\"./TokenStorageAarue.sol\\\";\\r\\n\\r\\n\\r\\ncontract Aarue is Initializable, TokenStorage{\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMath32 for uint32;\\r\\n\\r\\n\\r\\n\\r\\n    function init(address _aidrAddress, address _usdtAddress, uint256 _fxRate, address _scheduler) public initializer {\\r\\n        aidr = IERC20(_aidrAddress);\\r\\n        supportedTokens[_usdtAddress] = true;\\r\\n        fxRateToToken[_usdtAddress] = _fxRate.sub((_fxRate.mul(fxRatePercentage).div(1000)));\\r\\n        treasury = msg.sender;\\r\\n        fxRateFromToken[_usdtAddress] = _fxRate.add((_fxRate.mul(fxRatePercentage).div(1000)));\\r\\n        fxScheduler = _scheduler;\\r\\n        timestampFx = block.timestamp;\\r\\n        _owner = msg.sender;\\r\\n        _status = _NOT_ENTERED;\\r\\n        minThreshold = 500;\\r\\n        fxRatePercentage = 20;\\r\\n        platformRate = 10;\\r\\n    }\\r\\n\\r\\n    function changeInsuranceRate(uint256 _newRate) public onlyOwner {\\r\\n        insuranceRate = _newRate;\\r\\n    }\\r\\n\\r\\n    function changefxRatePercentage(uint256 _newPercentage) public onlyOwner {\\r\\n        fxRatePercentage = _newPercentage;\\r\\n    }\\r\\n\\r\\n    function changePlatformFee(uint256 _newFee) public onlyOwner{\\r\\n        platformRate = _newFee;\\r\\n    }\\r\\n\\r\\n    function changeThreshold(uint256 _minThreshold) public onlyOwner{\\r\\n        minThreshold = _minThreshold;\\r\\n    }\\r\\n\\r\\n    function updateToFX(address _tokenAddress, uint256 _fxRate) public {\\r\\n        require(msg.sender == _owner || msg.sender == fxScheduler, \\\"Not authorized to modify fx\\\");\\r\\n        if(msg.sender == fxScheduler){\\r\\n            require(block.timestamp >=  timestampFx.add(86400),\\\"scheduler cant update the fx again before 24hours\\\");\\r\\n            require(_fxRate <= fxRateToToken[_tokenAddress].mul(11).div(10) && _fxRate >=  fxRateToToken[_tokenAddress].mul(9).div(10), \\\"cannot change fx more than 10%\\\");\\r\\n            timestampFx = block.timestamp;\\r\\n\\r\\n        }\\r\\n        \\r\\n        fxRateToToken[_tokenAddress] = _fxRate.sub((_fxRate.mul(fxRatePercentage).div(1000)));\\r\\n        fxRateFromToken[_tokenAddress] = _fxRate.add((_fxRate.mul(fxRatePercentage).div(1000)));\\r\\n    }\\r\\n\\r\\n    function changeScheduler(address _scheduler) public onlyOwner{\\r\\n        fxScheduler = _scheduler;\\r\\n    }\\r\\n\\r\\n    function viewDebtOwed(uint256 _borrowId) public view returns(uint256){\\r\\n        BorrowInfo memory borrowInfo = borrowInfos[_borrowId];  \\r\\n        BorrowerInfo storage borrowerInfo = borrowerInfos[borrowInfo.walletAddress];\\r\\n        uint256 endTime = borrowInfo.startTimestamp.add(borrowInfo.tenure);\\r\\n        uint256 repaymentAmount = borrowInfo.repaymentAmount.mul(fxRateFromToken[borrowInfo.tokenRequested]).div(1000000);\\r\\n        uint256 repaymentShare = repaymentAmount.div(borrowInfo.tenure);\\r\\n        uint256 units = 0;\\r\\n        if(block.timestamp >= endTime){\\r\\n            repaymentAmount = repaymentAmount.sub(borrowerInfo.repaidAmount[_borrowId]);\\r\\n        }else{\\r\\n            units = block.timestamp.sub(borrowerInfo.repaymentTimeStamp[_borrowId]);\\r\\n            repaymentAmount = repaymentShare.mul(units);       \\r\\n        }\\r\\n        return repaymentAmount;\\r\\n\\r\\n    }\\r\\n\\r\\n    function viewWithdrawableBalance(uint256 _borrowId, address _lender) public view returns(uint256) {\\r\\n        BorrowInfo memory borrowInfo = borrowInfos[_borrowId];\\r\\n        uint256 borrowId = _borrowId;\\r\\n        LenderInfo storage lenderInfo = lenderInfos[_lender];\\r\\n        BorrowerInfo storage borrowerInfo = borrowerInfos[borrowInfo.walletAddress];\\r\\n        uint256 repaymentAmount = borrowInfo.repaymentAmount;\\r\\n        uint256 platformFeeShare = borrowInfo.borrowAmount.div(100);\\r\\n        repaymentAmount = repaymentAmount.sub(platformFeeShare);\\r\\n        uint256 individualShares = repaymentAmount.mul(lenderInfo.liquidity[borrowId]).div((borrowInfo.borrowAmount.mul(borrowInfo.tenure))); //repayment/tenure * liquidity/borrowAmount\\r\\n        uint256 originalShares = lenderInfo.liquidity[borrowId].div(borrowInfo.tenure);\\r\\n        uint256 interestGainedShares = individualShares.sub(originalShares);\\r\\n        uint256 insuranceShare = interestGainedShares.mul(insuranceRate).div(1000);\\r\\n        individualShares = individualShares.sub(insuranceShare); //after insurance deduction\\r\\n        individualShares = individualShares.mul(fxRateToToken[borrowInfo.tokenRequested]).div(1000000);\\r\\n        uint256 unitsToClaim = 0;\\r\\n        uint256 repaymentTimestamp = borrowerInfo.repaymentTimeStamp[borrowId];\\r\\n        uint256 claimTimestamp = lenderInfo.claimTimeStamp[borrowId];\\r\\n\\r\\n        if(lenderInfo.claimTimeStamp[borrowId] == 0 && lenderInfo.liquidity[borrowId] > 0){\\r\\n            claimTimestamp = borrowInfo.startTimestamp;\\r\\n            \\r\\n        }\\r\\n        unitsToClaim = repaymentTimestamp.sub(claimTimestamp);\\r\\n        return individualShares.mul(unitsToClaim);\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    function viewBorrowListStatus(uint256 _status) public view returns(uint256[] memory) {\\r\\n        uint256[] memory borrowInfoFilterStatus = new uint256[](borrowInfoLists.length);\\r\\n        uint256 count = 0;\\r\\n        for(uint i = 0 ; i < borrowInfoLists.length; i++){\\r\\n            \\r\\n            if(borrowInfos[i].status == _status){\\r\\n                borrowInfoFilterStatus[count] = i;\\r\\n                count = count.add(1);\\r\\n            }\\r\\n\\r\\n        }\\r\\n        return borrowInfoFilterStatus;\\r\\n    }\\r\\n\\r\\n    function viewBorrowerBorrowList(address _user) public view returns(uint256[] memory) {\\r\\n        return borrowerInfos[_user].borrowIds;\\r\\n    }\\r\\n\\r\\n    function defaultBorrower(uint256 _borrowId) public {\\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        BorrowerInfo storage borrowerInfo = borrowerInfos[borrowInfo.walletAddress];\\r\\n        require(borrowInfo.status == 2, \\\"cant default in this status\\\");\\r\\n        uint256 lastRepaymentTimestamp = borrowerInfo.repaymentTimeStamp[_borrowId];\\r\\n        uint256 timestampDif = block.timestamp.sub(lastRepaymentTimestamp);\\r\\n        bool defaulted = false;\\r\\n        if(block.timestamp > borrowInfo.startTimestamp.add(borrowInfo.tenure)){\\r\\n            timestampDif = borrowInfo.startTimestamp.add(borrowInfo.tenure).sub(lastRepaymentTimestamp);\\r\\n        }\\r\\n        if((borrowInfo.paymentFeq == 0 && timestampDif > 86400) ||(borrowInfo.paymentFeq == 1 && timestampDif > 604800) || (borrowInfo.paymentFeq == 2 && timestampDif > 2635200) || (borrowInfo.paymentFeq == 3 && timestampDif > 7862400) || (borrowInfo.paymentFeq == 4 && timestampDif > 15724800) || (borrowInfo.paymentFeq == 5 && timestampDif > 31536000)) {\\r\\n            defaulted = true;\\r\\n        }\\r\\n        require(defaulted, \\\"does not meet condition for default\\\");\\r\\n        borrowInfo.status = 7;\\r\\n    }\\r\\n\\r\\n    function viewBorrowInfo(uint256 _borrowId) public view returns (BorrowInfo memory)  {\\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        return borrowInfo;\\r\\n    }\\r\\n\\r\\n    function viewBorrowerInfo(address _borrower, uint256 _borrowId) public view returns (uint256 repaymentTimeStamp, uint256 repaidAmount)  {\\r\\n        BorrowerInfo storage borrowerInfo = borrowerInfos[_borrower];\\r\\n        return (borrowerInfo.repaymentTimeStamp[_borrowId],borrowerInfo.repaidAmount[_borrowId]);\\r\\n    }\\r\\n\\r\\n    function viewLenderInfos(address _lender, uint256 _borrowId) public view returns (uint256 claimTimeStamp, uint256 liquidity )  {\\r\\n        LenderInfo storage lenderInfo = lenderInfos[_lender];\\r\\n        return (lenderInfo.claimTimeStamp[_borrowId],lenderInfo.liquidity[_borrowId]);\\r\\n    }\\r\\n\\r\\n    function viewLenderBorrowList(address _lender) public view returns (uint256[] memory) {\\r\\n        LenderInfo storage lenderInfo = lenderInfos[_lender];\\r\\n        return lenderInfo.borrowIds;\\r\\n    }\\r\\n\\r\\n    function viewBorrowInfoList() public view returns (BorrowInfo[] memory) {\\r\\n        uint256[] memory borrowIds = borrowInfoLists;\\r\\n        BorrowInfo[] memory borrowInfoList = new BorrowInfo[](borrowIds.length);\\r\\n        for(uint i = 0 ; i < borrowIds.length ; i ++){\\r\\n            borrowInfoList[i] = borrowInfos[i];\\r\\n        }\\r\\n\\r\\n        return borrowInfoList;\\r\\n    }\\r\\n\\r\\n    // Lender Supply before Acceptance into Request\\r\\n    function supply(uint256 _amount, uint256 _borrowId) public nonReentrant{\\r\\n        _validateBorrowId(_borrowId);\\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        LenderInfo storage lenderInfo = lenderInfos[msg.sender];\\r\\n        require(borrowInfo.status == 1, \\\"Cannot supply at this juncture\\\");\\r\\n        require(borrowInfo.liquidity.add(_amount) <= borrowInfo.borrowAmount, \\\"Cannot supply more than total loan request\\\");\\r\\n        IERC20(borrowInfo.tokenRequested).transferFrom(msg.sender, address(this), _amount);\\r\\n        _registerBorrow(lenderInfo.borrowIds,_borrowId);\\r\\n        borrowInfo.liquidity = borrowInfo.liquidity.add(_amount);\\r\\n        lenderInfo.liquidity[_borrowId] = lenderInfo.liquidity[_borrowId].add(_amount);\\r\\n    }\\r\\n\\r\\n    // Lender withdrawal before Acceptance\\r\\n    function withdraw(uint256 _amount, uint256 _borrowId) public nonReentrant{ \\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        LenderInfo storage lenderInfo = lenderInfos[msg.sender];\\r\\n        require(borrowInfo.status == 1 || borrowInfo.status == 5 , \\\"Cannot withdraw at this juncture\\\");\\r\\n        require(lenderInfo.liquidity[_borrowId] >= _amount, \\\"insufficient funds to withdraw\\\");\\r\\n        lenderInfo.liquidity[_borrowId] = lenderInfo.liquidity[_borrowId].sub(_amount);\\r\\n        borrowInfo.liquidity = borrowInfo.liquidity.sub(_amount);\\r\\n        IERC20(borrowInfo.tokenRequested).transfer(msg.sender, _amount);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function convert(uint256 _amount, address _tokenRequested, uint256 _option) public {\\r\\n        require(supportedTokens[_tokenRequested], \\\"not supported token\\\");\\r\\n        require(_option == 1 || _option == 2, \\\"not a proper option\\\");\\r\\n        if(_option == 1){\\r\\n            IERC20(_tokenRequested).transferFrom(msg.sender, address(this), _amount);\\r\\n            uint256 amountToMint = _amount.mul(fxRateToToken[_tokenRequested]).div(1000000);\\r\\n            aidr.mint(msg.sender, amountToMint);\\r\\n        }\\r\\n\\r\\n        if(_option == 2){\\r\\n            aidr.burn(msg.sender, _amount);\\r\\n            uint256 amountToTransfer = _amount.mul(1000000).div(fxRateFromToken[_tokenRequested]);\\r\\n            IERC20(_tokenRequested).transfer(msg.sender, amountToTransfer);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // lender withdrawal after acceptance\\r\\n    function awithdraw(uint256 _borrowId) public nonReentrant{ \\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        LenderInfo storage lenderInfo = lenderInfos[msg.sender];\\r\\n        BorrowerInfo storage borrowerInfo = borrowerInfos[borrowInfo.walletAddress];\\r\\n        uint256 repaymentAmount = borrowInfo.repaymentAmount;\\r\\n        uint256 platformFee = (borrowInfo.borrowAmount.div(100));\\r\\n        uint256 platformFeeShares = (borrowInfo.borrowAmount.div(100)).div(borrowInfo.tenure);\\r\\n        repaymentAmount = repaymentAmount.sub(platformFee);\\r\\n        require(borrowInfo.status == 2 || borrowInfo.status == 6 || borrowInfo.status == 7, \\\"Cannot withdraw at this juncture\\\");\\r\\n        require(lenderInfo.liquidity[_borrowId] > 0, \\\"user is not a participant of loan\\\");\\r\\n        if(lenderInfo.claimTimeStamp[_borrowId] == 0){\\r\\n            lenderInfo.claimTimeStamp[_borrowId] = borrowInfo.startTimestamp;\\r\\n        }\\r\\n        uint256 individualShares = repaymentAmount.mul(lenderInfo.liquidity[_borrowId]).div((borrowInfo.borrowAmount.mul(borrowInfo.tenure))); //repayment/tenure * liquidity/borrowAmount\\r\\n        uint256 originalShares = lenderInfo.liquidity[_borrowId].div(borrowInfo.tenure);\\r\\n        uint256 interestGainedShares = individualShares.sub(originalShares);\\r\\n        uint256 insuranceShare = interestGainedShares.mul(insuranceRate).div(1000);\\r\\n        interestGainedShares = interestGainedShares.sub(insuranceShare);\\r\\n        individualShares = individualShares.sub(insuranceShare); //after insurance deduction\\r\\n        uint256 unitsToClaim = 0;\\r\\n        individualShares = individualShares.mul(fxRateToToken[borrowInfo.tokenRequested]).div(1000000);\\r\\n        \\r\\n        unitsToClaim = borrowerInfo.repaymentTimeStamp[_borrowId].sub(lenderInfo.claimTimeStamp[_borrowId]);\\r\\n        lenderInfo.claimTimeStamp[_borrowId] = borrowerInfo.repaymentTimeStamp[_borrowId];\\r\\n        \\r\\n        insuranceGenerated = insuranceShare.mul(unitsToClaim);\\r\\n        \\r\\n        lenderInfo.interestGained = lenderInfo.interestGained.add((interestGainedShares.mul(unitsToClaim)));\\r\\n        interestGenerated = interestGenerated.add((interestGainedShares.mul(unitsToClaim)));\\r\\n        IERC20(aidr).transfer(msg.sender, individualShares.mul(unitsToClaim));\\r\\n        IERC20(borrowInfo.tokenRequested).transfer(treasury, platformFeeShares.mul(unitsToClaim));\\r\\n        \\r\\n    }\\r\\n    //Once Accepted, Borrowers receives funds.\\r\\n    function accept(uint256 _borrowId) public nonReentrant{\\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        BorrowerInfo storage borrowerInfo = borrowerInfos[msg.sender];\\r\\n        require(borrowInfo.walletAddress == msg.sender, \\\"only request owner can accept\\\");\\r\\n        require(borrowInfo.status == 1, \\\"cannot accept at thie juncture\\\");\\r\\n        require(borrowInfo.liquidity >= borrowInfo.borrowAmount.mul(minThreshold).div(1000), \\\"cant accept below threshold\\\");\\r\\n        require(activatedBorrowers[borrowInfo.walletAddress], \\\"borrower is no longer active. Please contact support\\\");\\r\\n        borrowInfo.borrowAmount = borrowInfo.liquidity;\\r\\n        borrowInfo.liquidity = 0;\\r\\n        borrowInfo.startTimestamp = block.timestamp;\\r\\n        borrowInfo.status = 2;\\r\\n        borrowerInfo.repaymentTimeStamp[_borrowId] = borrowInfo.startTimestamp;\\r\\n        aidr.mint(borrowInfo.walletAddress,fxRateToToken[borrowInfo.tokenRequested].mul(borrowInfo.borrowAmount).div(1000000));\\r\\n    }\\r\\n\\r\\n    // Once Accepted, Borrowers must make regular repayments\\r\\n    function repay(uint256 _borrowId) public nonReentrant{\\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        BorrowerInfo storage borrowerInfo = borrowerInfos[msg.sender];\\r\\n        require(borrowInfo.walletAddress == msg.sender, \\\"only borrower can pay loan\\\");\\r\\n        require(borrowInfo.status == 2, \\\"cannot repay when borrowRequest over\\\");\\r\\n        require(borrowInfo.status != 7, \\\"loan is in default, please contact support\\\");\\r\\n        uint256 repaymentAmount = borrowInfo.repaymentAmount.mul(fxRateFromToken[borrowInfo.tokenRequested]).div(1000000);\\r\\n        uint256 repaymentShare = repaymentAmount.div(borrowInfo.tenure);\\r\\n        uint256 units = 0;\\r\\n        uint256 endTime = borrowInfo.startTimestamp.add(borrowInfo.tenure);\\r\\n        if(block.timestamp >= endTime){\\r\\n            repaymentAmount = repaymentAmount.sub(borrowerInfo.repaidAmount[_borrowId]);\\r\\n            borrowerInfo.repaymentTimeStamp[_borrowId] = endTime;\\r\\n            borrowInfo.status = 6;\\r\\n        }else{\\r\\n            units = block.timestamp.sub(borrowerInfo.repaymentTimeStamp[_borrowId]);\\r\\n            repaymentAmount = repaymentShare.mul(units);\\r\\n            borrowerInfo.repaymentTimeStamp[_borrowId] = block.timestamp;\\r\\n            \\r\\n        }\\r\\n\\r\\n        borrowerInfo.repaidAmount[_borrowId] = borrowerInfo.repaidAmount[_borrowId].add(repaymentAmount);\\r\\n        \\r\\n        aidr.transferFrom(msg.sender,address(this),repaymentAmount);\\r\\n\\r\\n        \\r\\n    }\\r\\n\\r\\n        // Once Accepted, Borrowers must make regular repayments\\r\\n    function repayDefault(uint256 _borrowId, uint256 reimburseTimeStamp) public onlyOwner nonReentrant{\\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        BorrowerInfo storage borrowerInfo = borrowerInfos[borrowInfo.walletAddress];\\r\\n        require(borrowInfo.status == 7, \\\"loan must be in default\\\");\\r\\n        uint256 repaymentAmount = borrowInfo.repaymentAmount.mul(fxRateFromToken[borrowInfo.tokenRequested]).div(1000000);\\r\\n        uint256 repaymentShare = repaymentAmount.div(borrowInfo.tenure);\\r\\n        uint256 units = 0;\\r\\n\\r\\n        units = reimburseTimeStamp.sub(borrowerInfo.repaymentTimeStamp[_borrowId]);\\r\\n        repaymentAmount = repaymentShare.mul(units);\\r\\n        borrowerInfo.repaymentTimeStamp[_borrowId] = reimburseTimeStamp;\\r\\n        borrowInfo.status = 8;\\r\\n\\r\\n        borrowerInfo.repaidAmount[_borrowId] = borrowerInfo.repaidAmount[_borrowId].add(repaymentAmount);\\r\\n        \\r\\n    }\\r\\n\\r\\n    //\\r\\n    function cancel(uint256 _borrowId) public nonReentrant {\\r\\n        BorrowInfo storage borrowInfo = borrowInfos[_borrowId];\\r\\n        require(borrowInfo.walletAddress == msg.sender, \\\"only borrower can cancel\\\");\\r\\n        require(borrowInfo.status == 1, \\\"cannot cancel\\\");\\r\\n        borrowInfo.status = 5;\\r\\n    }\\r\\n\\r\\n    function request(address _tokenRequested, uint256 _borrowAmount, uint256 _repaymentAmount, uint256 _tenure,uint8 _paymentFeq) public nonReentrant{\\r\\n        require(activatedBorrowers[msg.sender], \\\"Borrower cannot request loan\\\");\\r\\n        require(supportedTokens[_tokenRequested], \\\"token not supported\\\");\\r\\n        require(fxRateToToken[_tokenRequested] > 0, \\\"exchange rate not set\\\");\\r\\n        require(_repaymentAmount > _borrowAmount, \\\"repayment amount must be more than borrow amount\\\");\\r\\n        require( _paymentFeq > 0, \\\"not a proper payment frequency\\\");\\r\\n        require(_borrowAmount > 0, \\\"borrow amount cannot be 0\\\");\\r\\n        uint256 feeAmount = _borrowAmount.div(100);\\r\\n        BorrowInfo memory borrowRequest = \\r\\n            BorrowInfo(\\r\\n                msg.sender,\\r\\n                _tokenRequested,\\r\\n                _borrowAmount,\\r\\n                _repaymentAmount.add(feeAmount),\\r\\n                0,\\r\\n                1,\\r\\n                _tenure,\\r\\n                0,\\r\\n                _paymentFeq\\r\\n            );\\r\\n\\r\\n        _registerBorrow(borrowerInfos[msg.sender].borrowIds,currentBorrowId); //register new loan request to the borrowers\\r\\n        _registerBorrow(borrowInfoLists,currentBorrowId);// add the loan request to the list of existing borrow\\r\\n        borrowInfos[currentBorrowId] = borrowRequest; //\\r\\n        currentBorrowId = currentBorrowId.add(1);\\r\\n    }\\r\\n\\r\\n    function activateBorrower(address _borrower) public onlyOwner{\\r\\n        activatedBorrowers[_borrower] = true;\\r\\n    }\\r\\n\\r\\n    function deactivateBorrower(address _borrower) public onlyOwner{\\r\\n        activatedBorrowers[_borrower] = false;\\r\\n    }\\r\\n\\r\\n    function _validateBorrowId(uint256 _id) internal view {\\r\\n        require(currentBorrowId > _id, \\\"invalid borrowInfo id\\\");\\r\\n    }\\r\\n\\r\\n    function _registerBorrow(\\r\\n        uint256[] storage _borrowIds,\\r\\n        uint256 borrowId\\r\\n    ) internal {\\r\\n        _borrowIds.push(borrowId);\\r\\n    }\\r\\n\\r\\n    function _deregisterBorrow(\\r\\n        uint256[] storage _borrowIds,\\r\\n        uint256 borrowId\\r\\n    ) internal {\\r\\n        _removeArrayElement(_borrowIds, borrowId);\\r\\n    }\\r\\n\\r\\n    function supportToken(address _tokenAddress) public onlyOwner{\\r\\n        supportedTokens[_tokenAddress] = true;\\r\\n    }\\r\\n\\r\\n    function removeToken(address _tokenAddress) public onlyOwner{\\r\\n        supportedTokens[_tokenAddress] = false;\\r\\n    }\\r\\n    function _isSupported(address _tokenAddress) internal view {\\r\\n        require(supportedTokens[_tokenAddress], \\\"token not supported\\\");\\r\\n    }\\r\\n\\r\\n    // Assuming the given array does contain the given element\\r\\n    function _removeArrayElement(uint256[] storage arr, uint256 el) internal {\\r\\n        uint256 lastIndex = arr.length - 1;\\r\\n        if (lastIndex != 0) {\\r\\n            uint256 replaced = arr[lastIndex];\\r\\n            if (replaced != el) {\\r\\n                // Shift elements until the one being removed is replaced\\r\\n                do {\\r\\n                    uint256 replacing = replaced;\\r\\n                    replaced = arr[lastIndex - 1];\\r\\n                    lastIndex--;\\r\\n                    arr[lastIndex] = replacing;\\r\\n                } while (replaced != el && lastIndex != 0);\\r\\n            }\\r\\n        }\\r\\n        // Remove the last (and quite probably the only) element\\r\\n        arr.pop();\\r\\n    }\\r\\n\\r\\n    function _revertZeroAddress(address _address) private pure {\\r\\n        require(_address != address(0), \\\"KDecks:ZERO_ADDRESS\\\");\\r\\n    }\\r\\n\\r\\n    function _nonZeroAddr(address _address) private pure returns (address) {\\r\\n        _revertZeroAddress(_address);\\r\\n        return _address;\\r\\n    }\\r\\n\\r\\n    function safe32(uint256 n) private pure returns (uint32) {\\r\\n        require(n < 2**32, \\\"KDecks:UNSAFE_UINT32\\\");\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function transferAIDROwnership(address _newOwner) public onlyOwner{\\r\\n        aidr.transferOwnership(_newOwner);\\r\\n    }\\r\\n\\r\\n    function updateMinimunThreshold(uint256 _amount) public onlyOwner{\\r\\n\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"/contracts/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// solhint-disable-next-line compiler-version\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n */\\r\\ncontract Initializable {\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates that the contract has been initialized.\\r\\n     */\\r\\n    bool private _initialized;\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates that the contract is in the process of being initialized.\\r\\n     */\\r\\n    bool private _initializing;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\r\\n     */\\r\\n    modifier initializer() {\\r\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\r\\n\\r\\n        bool isTopLevelCall = !_initializing;\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = true;\\r\\n            _initialized = true;\\r\\n        }\\r\\n\\r\\n        _;\\r\\n\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = false;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/TokenStorageAarue.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token decimals.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address _owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function mint(address account, uint256 amount) external;\\r\\n\\r\\n    function burn(address _from, uint256 _amount) external;\\r\\n\\r\\n    function transferOwnership(address _newOwner) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ncontract Context {\\r\\n    function _msgSender() internal view  returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\\"s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\\"s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\\"s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n\\r\\n    uint256 internal constant _NOT_ENTERED = 1;\\r\\n    uint256 internal constant _ENTERED = 2;\\r\\n\\r\\n    uint256 internal _status;\\r\\n\\r\\n\\r\\n    constructor () public {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by manature the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    \\r\\n    address internal _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() public {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath32 {\\r\\n\\r\\n    function add(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\r\\n        uint32 c = a + b;\\r\\n        require(c >= a, errorMessage);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        return add(a, b, \\\"SafeMath32: addition overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(b <= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        return sub(a, b, \\\"SafeMath32: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function fromUint(uint n, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(n < 2**32, errorMessage);\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function fromUint(uint n) internal pure returns (uint32) {\\r\\n        return fromUint(n, \\\"SafeMath32: exceeds 32 bits\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract TokenStorage is Ownable, ReentrancyGuard {\\r\\n\\r\\n\\r\\n    uint256 public interestGenerated = 0;\\r\\n    uint256 public insuranceRate = 0;\\r\\n    uint256 public insuranceGenerated = 0;\\r\\n    uint256 public availableFundsForLending = 0;\\r\\n    uint256 public minThreshold = 500;\\r\\n    uint256 public fxRatePercentage = 20;\\r\\n    uint256 public platformRate = 10;\\r\\n\\r\\n    uint256 public currentBorrowId = 0;\\r\\n\\r\\n    address public fxScheduler;\\r\\n\\r\\n    uint256 public timestampFx;\\r\\n\\r\\n    mapping(address => bool) public supportedTokens;\\r\\n\\r\\n    mapping(uint256 => BorrowInfo) internal borrowInfos;\\r\\n    mapping(address => LenderInfo) internal lenderInfos;\\r\\n    mapping(address => BorrowerInfo) internal borrowerInfos;\\r\\n\\r\\n    mapping(uint256 => uint256) borrowIdToAmountSupplied;\\r\\n\\r\\n    mapping(address => bool) public activatedBorrowers;\\r\\n\\r\\n    mapping(address => uint256) public fxRateToToken;\\r\\n\\r\\n    mapping(address => uint256) public fxRateFromToken;\\r\\n\\r\\n    address public treasury;\\r\\n\\r\\n    uint256[] public borrowInfoLists; // keep all the borrowInfo Ids in a List\\r\\n\\r\\n    IERC20 public aidr;\\r\\n\\r\\n    struct BorrowInfo {\\r\\n        address walletAddress;\\r\\n        address tokenRequested; // USDT\\r\\n        uint256 borrowAmount; // Loan Amount\\r\\n        uint256 repaymentAmount; // repayment Amount\\r\\n        uint256 liquidity; // Liquidity to track how much until it reaches min threshold for acceptance\\r\\n        uint8 status; // status 1 - Request Submitted , 2 - Accepted, Repayment enabled, Lender's Amount locked, 3\\r\\n        uint256 tenure; // in seconds\\r\\n        uint256 startTimestamp; //start of the loan\\r\\n        uint256 paymentFeq; //payment frequency before able to call for default.\\r\\n    }\\r\\n\\r\\n    struct BorrowerInfo{\\r\\n        uint256[] borrowIds; // list of all borrowIds that assigned to borrowers\\r\\n        mapping(uint256 => uint256) repaymentTimeStamp; // map borrowIds to repayment amount\\r\\n        mapping(uint256 => uint256) repaidAmount;\\r\\n    }\\r\\n\\r\\n    struct LenderInfo {\\r\\n        uint256[] borrowIds; // list of all borrowIds that assigned to lenders\\r\\n        mapping(uint256 => uint256) claimTimeStamp; //borrowIds to claim timestamps.\\r\\n        mapping(uint256 => uint256) liquidity; //before acceptance if users want to remove liqudiity\\r\\n        uint256 interestGained;\\r\\n    }\\r\\n\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"accept\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"activateBorrower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activatedBorrowers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aidr\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableFundsForLending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"awithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"borrowInfoLists\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"changeInsuranceRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"changePlatformFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_scheduler\",\"type\":\"address\"}],\"name\":\"changeScheduler\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minThreshold\",\"type\":\"uint256\"}],\"name\":\"changeThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPercentage\",\"type\":\"uint256\"}],\"name\":\"changefxRatePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenRequested\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_option\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBorrowId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"deactivateBorrower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"defaultBorrower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fxRateFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fxRatePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fxRateToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fxScheduler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aidrAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fxRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_scheduler\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"insuranceGenerated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"insuranceRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestGenerated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reimburseTimeStamp\",\"type\":\"uint256\"}],\"name\":\"repayDefault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenRequested\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_repaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tenure\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_paymentFeq\",\"type\":\"uint8\"}],\"name\":\"request\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"supportToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timestampFx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferAIDROwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateMinimunThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fxRate\",\"type\":\"uint256\"}],\"name\":\"updateToFX\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"viewBorrowInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenRequested\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tenure\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentFeq\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenStorage.BorrowInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewBorrowInfoList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenRequested\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tenure\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentFeq\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenStorage.BorrowInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_status\",\"type\":\"uint256\"}],\"name\":\"viewBorrowListStatus\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewBorrowerBorrowList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"viewBorrowerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"repaymentTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repaidAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"viewDebtOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"}],\"name\":\"viewLenderBorrowList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"viewLenderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"}],\"name\":\"viewWithdrawableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrowId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Aarue", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}