{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/root/bscDarsContracts/contracts/BonusContract.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n/*\\nhttps://dars.one/\\n*/\\npragma solidity 0.7.6;\\nimport \\\"./lib/IBEP20.sol\\\";\\nimport \\\"./lib/SafeMath.sol\\\";\\nimport \\\"./lib/ECDSA.sol\\\";\\nimport \\\"./lib/TransferHelper.sol\\\";\\n\\npragma experimental ABIEncoderV2;\\n\\ncontract BonusContract{\\n\\n    using SafeMath for uint256;\\n    using ECDSA for bytes32;\\n    using TransferHelper for IBEP20;\\n\\n    struct User {\\n        uint128 id;\\n        uint128 bonusNonce;\\n        uint256 totalBuy;\\n        uint256 totalBuyOutside;\\n        uint256 totalBuySpecial;\\n        uint256 affectedBuySpecial;\\n        uint256 totalUpgrade;\\n        uint256 totalBonus;  \\n    }\\n\\n    struct Packet{\\n        uint256 id;\\n        uint256 packetType;\\n        uint256 qty;\\n        uint256 packetPrice;\\n        address target;\\n        bool upgradable;\\n        bool affecting;\\n        bool cartDependent;\\n    }\\n    mapping(bytes32=>Packet) private packets;\\n    mapping(address=>bool) public migrated;\\n    bytes32[] private allPackets;\\n    \\n    IBEP20 immutable public bonusToken;\\n    address immutable public darsBasis;\\n    uint256 immutable public chainId;\\n    uint256 immutable public darsPercent;\\n    address immutable public companyOwner;\\n    address immutable public darsSigner;\\n    address public companySigner;\\n    address public migrationsAdmin;\\n    uint256 public bonusPercent;\\n    address public companyContract;\\n    string  public darsName;\\n    string  public Url;  \\n    uint128 public lastUserId = 0;\\n    uint128 public lastPacketId = 0;\\n    bool public lowBalance = false;\\n    bool public salesStopped = false;\\n    uint256 public totalWithdrawBonus;\\n    uint256 public totalBuy;\\n    uint256 public totalBuyOutside;\\n    uint256 public totalBuySpecial;\\n    uint256 public totalUpgrade;\\n    uint256 public lastWithdrawalTimestamp;\\n    uint256 constant public maxTermWithoutCompanySignature = 15552000;//180 days\\n\\n    \\n\\n    mapping(address => User) public users;\\n    mapping(uint128 => address) private usersID;\\n    \\n    modifier onlyCompanyOwner() {\\n        require(companyOwner == msg.sender, \\\"caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyDarsSigner() {\\n        require(darsSigner == msg.sender, \\\"caller is not darsSigner\\\");\\n        _;\\n    }\\n\\n\\n    event PacketAdded(uint256 id,\\n                uint256 packetType,\\n                uint256 qty,\\n                uint256 packetPrice,\\n                address targetContract,\\n                bytes32 singlePacketUID,\\n                bool upgradeable,\\n                bool affecting,\\n                bool cartDependent);\\n\\n    event PacketUpdated(uint256 id,\\n                uint256 qty,\\n                uint256 packetPrice,\\n                address targetContract,\\n                bytes32 singlePacketUID,\\n                bool upgradeable,\\n                bool affecting,\\n                bool cartDependent);\\n\\n    event Migrations(address user, \\n                    uint256 totalBuy,\\n                    uint256 totalBuyOutside,\\n                    uint256 totalBuySpecial,\\n                    uint256 affectedBuySpecial,\\n                    uint256 totalUpgrade);\\n\\n    event Withdraw(address user, uint256 amount,uint128 nextnonce);\\n    event Registration(address user, uint128 userId);\\n    event Buy(address user,uint256 price,bytes32 orderUID);\\n    event BuyOutside(address user,uint256 price,uint256 marketing);\\n    event BuySpecial(address user,uint256 price,bytes32 singlePacketUID);\\n    event UpgradeSpecial(address user,uint256 price,bytes32 singlePacketUID);\\n\\n    constructor(address _companyOwner,\\n                address _companySigner,\\n                address _darsSigner,\\n                address _companyContract,\\n                address _bonusToken,\\n                uint256 _darsPercent,\\n                uint256 _bonusPercent,\\n                string memory _darsName, \\n                string memory _Url) {\\n\\n        darsBasis = msg.sender;//parent, Dars platform base contract\\n        companyOwner = _companyOwner;\\n        darsSigner = _darsSigner;\\n        companySigner = _companySigner;\\n        companyContract = _companyContract;\\n        darsName = _darsName;\\n        Url = _Url;\\n        bonusPercent = _bonusPercent;\\n        darsPercent = _darsPercent;\\n        bonusToken=IBEP20(_bonusToken);\\n        uint256 _chainId;\\n        assembly {\\n            _chainId := chainid()\\n        }\\n        chainId=_chainId;\\n        lastWithdrawalTimestamp=block.timestamp;\\n    }\\n\\n    function antiSabotage(bool _lowBalance) external onlyDarsSigner {\\n       lowBalance=_lowBalance; \\n    }\\n\\n    function withdrawBonus(uint256 amount, bytes calldata signatureDars,bytes calldata signatureCompany) external {\\n        uint128 id=users[msg.sender].id;\\n        require(id>0,\\\"The user doesn't exist!\\\");\\n        require(amount>0,\\\"bonus must be greater than 0\\\");\\n        bytes32 hash=createHash(id,amount,users[msg.sender].bonusNonce);\\n        hash=hash.toEthSignedMessageHash();\\n        require(hash.recover(signatureDars)==darsSigner,\\\"dars signature is wrong\\\");\\n        bool isSolvent=bonusToken.balanceOf(address(this))>=amount;\\n        \\n        if((block.timestamp-lastWithdrawalTimestamp)<maxTermWithoutCompanySignature){\\n            require(hash.recover(signatureCompany)==companySigner,\\\"company signature is wrong\\\");\\n            lastWithdrawalTimestamp=block.timestamp;\\n        }else{\\n            salesStopped=true;\\n        }\\n        \\n        if(isSolvent){\\n            users[msg.sender].bonusNonce++;\\n            users[msg.sender].totalBonus=users[msg.sender].totalBonus.add(amount);\\n            totalWithdrawBonus=totalWithdrawBonus.add(amount);\\n            lowBalance=false;                     \\n            bonusToken.safeTransfer(address(msg.sender), amount);\\n            emit Withdraw(msg.sender,amount,users[msg.sender].bonusNonce);\\n        }else{\\n            require(lowBalance==false,\\\"low contract balance..Please contact to support of company.\\\");\\n            lowBalance=true;\\n        }\\n\\n    }\\n\\n\\n    function dbMigrations(address _user,\\n                        uint256 _totalBuy,\\n                        uint256 _totalBuyOutside,\\n                        uint256 _totalBuySpecial,\\n                        uint256 _affectedBuySpecial,\\n                        uint256 _totalUpgrade) external {\\n        \\n        require(migrationsAdmin==msg.sender,\\\"this caller is not a migration admin\\\");\\n        require(migrated[_user]==false,\\\"this user already migrated\\\");                    \\n        if(users[_user].id==0){\\n            _registration(_user);\\n        }\\n        migrated[_user]=true;\\n        User storage user = users[_user];\\n        user.totalBuy=user.totalBuy.add(_totalBuy);\\n        user.totalBuyOutside=user.totalBuyOutside.add(_totalBuyOutside);\\n        user.totalBuySpecial=user.totalBuySpecial.add(_totalBuySpecial);\\n        user.affectedBuySpecial=user.affectedBuySpecial.add(_affectedBuySpecial);\\n        user.totalUpgrade=user.totalUpgrade.add(_totalUpgrade);\\n        \\n        emit Migrations(_user, \\n                    user.totalBuy,\\n                    user.totalBuyOutside,\\n                    user.totalBuySpecial,\\n                    user.affectedBuySpecial,\\n                    user.totalUpgrade);\\n\\n    }\\n\\n    function _registration(address newUser) internal {\\n\\n        User memory user = User({\\n            id: ++lastUserId,\\n            bonusNonce: uint128(0),\\n            totalBuy: 0,\\n            totalBuyOutside:0,\\n            totalBuySpecial: 0,\\n            affectedBuySpecial:0,\\n            totalUpgrade:0,\\n            totalBonus: 0\\n        });\\n        users[newUser] = user;\\n        usersID[lastUserId]=newUser;\\n        emit Registration(newUser, lastUserId);\\n\\n    } \\n\\n    function _buy(address payer,uint256 price) internal {\\n        \\n        require(price > 0, \\\"price must be greater than 0\\\");\\n        require(!lowBalance, \\\"operations suspended, low balance for bonuses\\\");\\n        require(!salesStopped, \\\"this company under liquidation, the sale is stopped\\\");\\n        require(\\n            bonusToken.allowance(payer, address(this)) >=\\n                price,\\n            \\\"Increase the allowance first,call the approve method\\\"\\n        );\\n        \\n        bonusToken.safeTransferFrom(\\n            payer,\\n            address(this),\\n            price\\n        );\\n        uint256 toDarsAmount=price.mul(darsPercent).div(100);\\n        uint256 toBonusAmount=price.mul(bonusPercent).div(100);\\n        uint256 toCompanyAmount=price.sub(toDarsAmount.add(toBonusAmount));\\n        \\n        if(toDarsAmount>0){\\n            bonusToken.safeTransfer(darsBasis, toDarsAmount);\\n        }\\n\\n        if(toCompanyAmount>0){\\n            bonusToken.safeTransfer(companyContract, toCompanyAmount);\\n        }\\n\\n    }\\n\\n    //marketing 0-DEFAULT\\n    function buyOutside(address user,uint256 price,uint256 marketing) external {\\n        require(users[user].id>0,\\\"user not exist\\\");\\n        _buy(msg.sender,price);\\n        totalBuyOutside=totalBuyOutside.add(price);       \\n        users[user].totalBuyOutside=users[user].totalBuyOutside.add(price);\\n        emit BuyOutside(user,price,marketing);\\n    }\\n\\n    function buy(uint256 price,bytes32 orderUID) external {\\n        _buy(msg.sender,price);\\n        if(users[msg.sender].id==0){\\n            _registration(msg.sender);\\n        }\\n        totalBuy=totalBuy.add(price);       \\n        users[msg.sender].totalBuy=users[msg.sender].totalBuy.add(price);\\n        emit Buy(msg.sender,price,orderUID);\\n    }\\n\\n    function buySpecial(uint256 price,bytes32 singlePacketUID) external {\\n\\n        require(price > 0 && packets[singlePacketUID].packetPrice==price,\\\"bad packet price or packet not avaible\\\");\\n        _buy(msg.sender,price); \\n        if(users[msg.sender].id==0){\\n            _registration(msg.sender);\\n        }\\n        totalBuySpecial=totalBuySpecial.add(price);\\n        users[msg.sender].totalBuySpecial=users[msg.sender].totalBuySpecial.add(price);\\n\\n        if(packets[singlePacketUID].affecting){\\n            users[msg.sender].affectedBuySpecial=users[msg.sender].affectedBuySpecial.add(price);\\n        }\\n\\n        if(packets[singlePacketUID].target!=address(0)){\\n            (bool success,) = packets[singlePacketUID].target\\n            .call(abi.encodeWithSignature(\\\"delivery(address,uint256,uint256,uint256,uint256)\\\",\\n            msg.sender,packets[singlePacketUID].packetType,packets[singlePacketUID].qty,packets[singlePacketUID].id,price));\\n            require(success,\\\"delivery call FAIL\\\");\\n        }\\n        \\n        emit BuySpecial(msg.sender,price,singlePacketUID);\\n    }\\n\\n    function upgradeSpecial(uint256 maxPrice,bytes32 singlePacketUID) external {\\n        require(users[msg.sender].id>0,\\\"user not exist\\\");\\n\\n        (bool success,uint256 price) = getUpgradePriceIfAvailable(msg.sender,singlePacketUID);\\n        require(success,\\\"This upgrade is not available\\\");\\n        require(price <= maxPrice,\\\"bad upgrade price, maybe the packet price was changed\\\");\\n        _buy(msg.sender,price);\\n        totalUpgrade=totalUpgrade.add(price);\\n        users[msg.sender].totalUpgrade=users[msg.sender].totalUpgrade.add(price);\\n        \\n        if(packets[singlePacketUID].affecting){\\n            users[msg.sender].affectedBuySpecial=users[msg.sender].affectedBuySpecial.add(price);\\n        }      \\n\\n        if(packets[singlePacketUID].target!=address(0)){\\n            (success,) = packets[singlePacketUID].target\\n            .call(abi.encodeWithSignature(\\\"upgradeDelivery(address,uint256,uint256,uint256,uint256)\\\",\\n            msg.sender,packets[singlePacketUID].packetType,packets[singlePacketUID].qty,packets[singlePacketUID].id,price));\\n            require(success,\\\"upgradeDelivery call FAIL\\\");\\n        }\\n        \\n        emit UpgradeSpecial(msg.sender,price,singlePacketUID);\\n\\n    }\\n\\n    function getUpgradePriceIfAvailable(address user,bytes32 singlePacketUID) public view returns (bool,uint256) {\\n\\n        if(users[user].id > 0 && packets[singlePacketUID].packetPrice>0 && packets[singlePacketUID].upgradable){\\n            uint256 affected=users[user].affectedBuySpecial;\\n            if(packets[singlePacketUID].cartDependent){\\n                affected = affected.add(users[user].totalBuy).add(users[user].totalBuyOutside);\\n            }\\n            if(packets[singlePacketUID].packetPrice>affected){\\n                return (true,packets[singlePacketUID].packetPrice.sub(affected)); \\n            }\\n        }\\n        return (false,0);\\n    }\\n\\n    function getPacketsList() public view returns (bytes32[] memory) {\\n        return allPackets;\\n    }\\n\\n    function uidToId(bytes32 singlePacketUID) external view returns (uint256){\\n        return packets[singlePacketUID].id;\\n    }\\n\\n    function getPacketByUID(bytes32 singlePacketUID) external view returns (Packet memory){\\n        \\n        return packets[singlePacketUID];\\n    }\\n\\n    function getPacketByID(uint256 packetId) external view returns (Packet memory){\\n        require(packetId > 0 && packetId <= lastPacketId, \\\"wrong Id\\\");\\n        bytes32 id = allPackets[packetId-1];\\n        return packets[id];\\n    }\\n\\n    function isPacketActive(bytes32 singlePacketUID) external view returns(bool){\\n        return (packets[singlePacketUID].target != address(0));\\n    } \\n\\n    function createHash(uint128 to, uint256 amount, uint128 nonce) internal view returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(chainId, this, to, amount, nonce));\\n    }\\n    \\n    function isUserExists(address user) external view returns (bool) {\\n        return (users[user].id > 0);\\n    }\\n\\n    function getUserNonce(address user) external view returns (uint128) {\\n        return users[user].bonusNonce;\\n    }\\n\\n    function addressToId(address user) external view returns (uint128) {\\n        require(users[user].id>0,\\\"The user doesn't exist!\\\");\\n        return users[user].id;\\n    }\\n\\n    function idToAddress(uint128 id) external view returns (address) {\\n        require(id>0 && id<=lastUserId,\\\"The user doesn't exist!\\\");\\n        return usersID[id];\\n    }\\n    /*\\n        TYPE_PACKAGE = 1;\\n        TYPE_ACTIVITY = 2;\\n        TYPE_ONE_TIME_FEE = 3;\\n    */\\n    function addPacket(uint256 _qty,\\n                    uint256 _packetType,\\n                    uint256 _packetPrice, \\n                    address _target,\\n                    bytes32 singlePacketUID,\\n                    bool _upgradable,\\n                    bool _affecting,\\n                    bool _cartDependent) external onlyCompanyOwner {\\n        \\n        if(_target!=address(0)){\\n            uint32 size;\\n            assembly {\\n                size := extcodesize(_target)\\n            }\\n            require(size != 0, \\\"The target must be a contract or zero address\\\");\\n        }\\n        \\n\\n        if(packets[singlePacketUID].id>0){\\n            require(packets[singlePacketUID].packetType==_packetType,\\\"type change not available\\\");\\n            packets[singlePacketUID].qty=_qty;\\n            packets[singlePacketUID].packetPrice=_packetPrice;\\n            packets[singlePacketUID].target=_target;\\n            packets[singlePacketUID].upgradable=_upgradable;\\n            packets[singlePacketUID].affecting=_affecting;\\n            packets[singlePacketUID].cartDependent=_cartDependent;\\n            emit PacketUpdated(packets[singlePacketUID].id,_qty,_packetPrice, _target, singlePacketUID,_upgradable,_affecting,_cartDependent);\\n        }else{\\n            packets[singlePacketUID]=Packet(\\n            {id:++lastPacketId,\\n            packetType:_packetType,\\n            qty:_qty,\\n            packetPrice:_packetPrice,\\n            target:_target,\\n            upgradable:_upgradable,\\n            affecting:_affecting,\\n            cartDependent:_cartDependent\\n            });\\n            allPackets.push(singlePacketUID);\\n            emit PacketAdded(lastPacketId,_packetType,_qty,_packetPrice, _target, singlePacketUID,_upgradable,_affecting,_cartDependent);\\n        }\\n        \\n    }\\n\\n    function setMigrationsAdmin(address _migrationsAdmin) external onlyCompanyOwner {\\n        migrationsAdmin = _migrationsAdmin;\\n    }\\n\\n    function setBonusPercent(uint256 newPercent) external onlyCompanyOwner {\\n        require(newPercent>0 && newPercent <= uint256(100).sub(darsPercent),\\\"bad percent\\\");\\n        bonusPercent = newPercent;\\n    }\\n    \\n    function setCompanyUrl(string calldata _Url) external onlyCompanyOwner {\\n        Url = _Url;\\n    }\\n    function setCompanyContract(address _companyContract) external onlyCompanyOwner {\\n        companyContract = _companyContract;\\n    }\\n\\n    function setCompanySigner(address _companySigner) external onlyCompanyOwner {\\n        companySigner = _companySigner;\\n    }\\n}\"\r\n    },\r\n    \"/root/bscDarsContracts/contracts/DarsBasis.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\nhttps://dars.one/\\n*/\\npragma solidity 0.7.6;\\nimport \\\"./lib/IBEP20.sol\\\";\\nimport \\\"./lib/SafeMath.sol\\\";\\nimport \\\"./lib/Ownable.sol\\\";\\nimport \\\"./BonusContract.sol\\\";\\nimport \\\"./lib/IPancakeRouter02.sol\\\";\\nimport \\\"./lib/TransferHelper.sol\\\";\\n\\npragma experimental ABIEncoderV2;\\n\\ncontract DarsBasis is Ownable {\\n    \\n    using SafeMath for uint256;\\n    using TransferHelper for IBEP20;\\n    struct CompanyInfo{\\n        string darsAccount;\\n        address contractAddress;\\n        address companyOwner;\\n        address darsGuardian;\\n    }   \\n\\n    address immutable public PancakeRouter;//0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n    address immutable public bonusToken;//0x55d398326f99059ff775485246999027b3197955  usdt\\n    address immutable public darsPool;\\n    address immutable public darsToken;\\n    address immutable public darsShareholders;\\n    address immutable public darsReserveAddress;\\n    uint256 immutable public minDistrBalance;\\n    uint256 immutable public darsReserveAmount;\\n\\n    mapping (address => address)  public companies;\\n    CompanyInfo[] public allCompanies;\\n    uint256 public darsPercent;\\n    uint256 public burnPercent;\\n    uint256 public poolPercent;\\n    address public constant dev1=0x6C8F69523858b9A4124b59876E9ffE9f6B84e2Ce;\\n    address public constant dev2=0xF4293330eF51997D0FA8dfc6DFE493Dd5048A96b;\\n\\n    modifier onlyDev() {\\n        require(dev1 == msg.sender \\n                || dev2 == msg.sender \\n                || owner() == msg.sender,\\n                 \\\"caller is not a developer\\\");\\n        _;\\n    }\\n\\n    event CompanyCreated(string darsName, string Url, address companyOwner, address contractAddress);\\n\\n    constructor (address _pancakeRouter,\\n                address _bonusToken,\\n                address _darsPool,\\n                address _darsToken,\\n                address _darsShareholders,\\n                address _darsReserveAddress,\\n                uint256 _darsReserveAmount) {\\n        PancakeRouter=_pancakeRouter;\\n        bonusToken = _bonusToken;\\n        darsPool = _darsPool;\\n        darsToken = _darsToken;\\n        darsShareholders = _darsShareholders;\\n        darsReserveAddress=_darsReserveAddress;\\n        darsReserveAmount=_darsReserveAmount; \\n        darsPercent=50;\\n        burnPercent=25;\\n        poolPercent=25;\\n        minDistrBalance=10*10**IBEP20(_bonusToken).decimals();\\n    }\\n    \\n    //percentages without floating part is enough\\n    function setDistributionPercents(uint256 _darsPercent,uint256 _burnPercent,uint256 _poolPercent) external onlyOwner {\\n        require(_darsPercent.add(_burnPercent.add(_poolPercent))==100,\\\"bad percent\\\");\\n        darsPercent =_darsPercent;\\n        burnPercent =_burnPercent;\\n        poolPercent =_poolPercent;\\n    }\\n    function createCompany(address _companyOwner,\\n                            address _companySigner,\\n                            address _darsGuardian,\\n                            address _companyContract,\\n                            uint256 _darsPercent,\\n                            uint256 _bonusPercent,\\n                            string memory _darsName,\\n                            string memory _Url) external onlyDev {\\n\\n        require(!isCompanyExists(_companyOwner), \\\"companyOwner is already exists\\\");\\n\\n        bytes memory bytecode = type(BonusContract).creationCode;\\n        bytecode = abi.encodePacked(bytecode, abi.encode(_companyOwner, _companySigner, _darsGuardian, _companyContract,bonusToken,_darsPercent, _bonusPercent,_darsName, _Url));\\n        bytes32 salt = keccak256(abi.encodePacked( _darsName, _companyOwner, _darsGuardian));\\n\\n        address contractAddress;\\n        assembly {\\n            contractAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        require(contractAddress != address(0), \\\"Create2: Failed on deploy\\\");\\n        \\n        companies[_companyOwner] = contractAddress;\\n        allCompanies.push(CompanyInfo({\\n                                    darsAccount:_darsName,\\n                                    contractAddress:contractAddress,\\n                                    companyOwner:_companyOwner,\\n                                    darsGuardian:_darsGuardian}));\\n        \\n        emit CompanyCreated(_darsName, _Url, _companyOwner, contractAddress);\\n        \\n    }\\n\\n    function distribute() external{\\n        \\n        uint256 cBalance=IBEP20(bonusToken).balanceOf(address(this));\\n        require(cBalance>=minDistrBalance,\\\"balance should be greater\\\");\\n\\n        uint256 toDarsAmount=cBalance.mul(darsPercent).div(100);\\n        uint256 toPoolAmount=cBalance.mul(poolPercent).div(100);\\n        uint256 toBurnAmount=cBalance.mul(burnPercent).div(100);\\n\\n        uint256 reserveBalance=IBEP20(bonusToken).balanceOf(darsReserveAddress);\\n\\n        if(toDarsAmount>0){\\n            if(reserveBalance<darsReserveAmount){\\n                IBEP20(bonusToken).safeTransfer(darsReserveAddress, toDarsAmount);\\n            }else{\\n                IBEP20(bonusToken).safeTransfer(darsShareholders, toDarsAmount);\\n            }\\n        }\\n        \\n        if(toPoolAmount>0){\\n            IBEP20(bonusToken).safeIncreaseAllowance(darsPool, toPoolAmount);\\n            (bool success,) = darsPool.call(abi.encodeWithSignature(\\\"chargePool(uint256)\\\",toPoolAmount));\\n            require(success,\\\"chargePool FAIL\\\");\\n        }\\n\\n        if(toBurnAmount>0){\\n            IBEP20(bonusToken).safeIncreaseAllowance(PancakeRouter, toBurnAmount);\\n            address[] memory tokenPath = new address[](2);\\n            tokenPath[0] = bonusToken;\\n            tokenPath[1] = darsToken;\\n\\n            IPancakeRouter02(PancakeRouter)\\n                .swapExactTokensForTokens(\\n                toBurnAmount,\\n                0,\\n                tokenPath,\\n                address(this),\\n                block.timestamp + 60\\n            );\\n            uint256 burned = IBEP20(darsToken).balanceOf(address(this));\\n            if(burned>0){\\n                (bool success,) = darsToken.call(abi.encodeWithSignature(\\\"burn(uint256)\\\",burned));\\n                require(success,\\\"burn FAIL\\\");\\n            }\\n        }\\n\\n    }\\n\\n    function isCompanyExists(address companyOwn) public view returns (bool) {\\n        return (companies[companyOwn]!=address(0));\\n    }\\n    function companiesNumber() public view returns (uint256) {\\n        return allCompanies.length;\\n    }\\n    function companiesList() public view returns (CompanyInfo[] memory) {\\n        return allCompanies;\\n    }\\n\\n}\"\r\n    },\r\n    \"/root/bscDarsContracts/contracts/lib/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/bscDarsContracts/contracts/lib/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.4 <0.8.0;\\n\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"/root/bscDarsContracts/contracts/lib/IPancakeRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"/root/bscDarsContracts/contracts/lib/Ownable.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.4 <0.8.0;\\n// \\\"SPDX-License-Identifier: Apache License 2.0\\\"\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/bscDarsContracts/contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.4 <0.8.0;\\n\\n/**\\n * Copyright (c) 2016-2019 zOS Global Limited\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/bscDarsContracts/contracts/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.4 <0.8.0;\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TransferHelper {\\n    using SafeMath for uint256;\\n\\n    function safeTransfer(\\n        IBEP20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            address(token).call(\\n                abi.encodeWithSelector(token.transfer.selector, to, value)\\n            );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IBEP20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            address(token).call(\\n                abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n            );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IBEP20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance =\\n            token.allowance(address(this), spender).add(value);\\n\\n        (bool success, bytes memory data) =\\n            address(token).call(\\n                abi.encodeWithSelector(token.approve.selector,spender,newAllowance)\\n            );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"INCREASE_ALLOWANCE_FAILED\\\"\\n        );     \\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pancakeRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonusToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_darsPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_darsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_darsShareholders\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_darsReserveAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_darsReserveAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"darsName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"Url\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"companyOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"CompanyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PancakeRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allCompanies\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"darsAccount\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"companyOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"darsGuardian\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"companies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companiesList\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"darsAccount\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"companyOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"darsGuardian\",\"type\":\"address\"}],\"internalType\":\"struct DarsBasis.CompanyInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companiesNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_companyOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_companySigner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_darsGuardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_companyContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_darsPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusPercent\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_darsName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Url\",\"type\":\"string\"}],\"name\":\"createCompany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsReserveAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsReserveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsShareholders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darsToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"companyOwn\",\"type\":\"address\"}],\"name\":\"isCompanyExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDistrBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_darsPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolPercent\",\"type\":\"uint256\"}],\"name\":\"setDistributionPercents\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DarsBasis", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000c893df56e01d9282f469bb985d0b3e6377b9d1d20000000000000000000000000928f73b694b440291b4f852c9b8ffbad85ec20f0000000000000000000000007d0be96649a31081329eb4d465065a9de86db1150000000000000000000000007c13a5b74779e97e1a0c3c1652fa6941b7a44d5f000000000000000000000000000000000000000000000a968163f0a57b400000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}