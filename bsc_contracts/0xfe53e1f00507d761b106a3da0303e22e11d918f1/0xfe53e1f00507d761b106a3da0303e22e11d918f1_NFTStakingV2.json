{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers. \\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721Holder is IERC721Receiver {\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NFTStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\\\";\\n\\nimport \\\"./interfaces/ICurrencyManager.sol\\\";\\nimport \\\"./interfaces/INFTStaking.sol\\\";\\nimport \\\"./interfaces/IElpisEquipment.sol\\\";\\n\\ncontract NFTStakingV2 is\\n    INFTStaking,\\n    ERC721Holder,\\n    Context,\\n    Ownable,\\n    ReentrancyGuard\\n{\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n        uint256 rewardToHarvest; //When stake or unstake, add pending reward to rewardToHarvest.\\n        EnumerableSet.UintSet holderTokens; // Mapping from holder address to their (enumerable) set of owned tokens\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        bytes32 merkleRoot; //  The merkle root is built from hero tree.\\n        uint256 rewardPerNFTAndBlock; // Rewards created per NFT and block\\n        uint256 lastRewardBlock; // Last block number that rewards distribution occurs.\\n        uint256 accRewardPerNFT; // Accumulated rewards per NFT.\\n        uint256 totalStaked; // Total number of heroes staked in pool\\n    }\\n\\n    // The NFT addresss\\n    IERC721 public immutable EMH;\\n    //The reward NFT address\\n    IElpisEquipment public immutable EMQ;\\n    //The currency manager address\\n    ICurrencyManager public immutable currencyManager;\\n\\n    bool public isEmergency = false;\\n    bool public isBuyable = false;\\n    uint256 public maxEquipmentSupply;\\n    uint256 public totalEquipmentSales;\\n    uint256 public maxEquipmentPerTx = 10;\\n    //The symbol of reward currency\\n    bytes32 public immutable rewardCurrency;\\n    // The block number when NFT staking starts\\n    uint256 public immutable startBlock;\\n\\n    //A list of the current prices of equipments on sale\\n    uint256[] public equipmentPriceList;\\n    //Info of each pool\\n    PoolInfo[] public poolInfo;\\n\\n    // Info of each user that stakes hero.\\n    mapping(uint256 => mapping(address => UserInfo)) private _userInfo;\\n    //a map to check a pool(merkle root) is unique\\n    mapping(bytes32 => bool) private _poolIndexes;\\n\\n    modifier poolNotExists(bytes32 merkleRoot) {\\n        require(!_poolIndexes[merkleRoot], \\\"Pool already exists\\\");\\n        _;\\n    }\\n\\n    modifier buyable() {\\n        require(isBuyable, \\\"Not buyable\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        IERC721 _EMH,\\n        IElpisEquipment _EMQ,\\n        ICurrencyManager _currencyManager,\\n        bytes32 _rewardCurrency,\\n        uint256 _startBlock\\n    ) {\\n        EMH = _EMH;\\n        EMQ = _EMQ;\\n        currencyManager = _currencyManager;\\n        rewardCurrency = _rewardCurrency;\\n        startBlock = _startBlock;\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    function priceListEquipmentsLength() external view returns (uint256) {\\n        return equipmentPriceList.length;\\n    }\\n\\n    function updateEmergencyState(bool _isEmergency) external onlyOwner {\\n        isEmergency = _isEmergency;\\n\\n        emit EmergencyStateChanged(_msgSender(), isEmergency);\\n    }\\n\\n    function updateBuyableState(bool _isBuyable) external onlyOwner {\\n        isBuyable = _isBuyable;\\n\\n        emit BuyableStateChanged(_msgSender(), isBuyable);\\n    }\\n\\n    function updateMaxEquipmentSupply(uint256 _maxEquipmentSupply)\\n        external\\n        onlyOwner\\n    {\\n        emit MaxEquipmentSupplyChanged(\\n            _msgSender(),\\n            maxEquipmentSupply,\\n            _maxEquipmentSupply\\n        );\\n\\n        maxEquipmentSupply = _maxEquipmentSupply;\\n    }\\n\\n    function updateMaxEquipmentPerTx(uint256 _maxEquipmentPerTx)\\n        external\\n        onlyOwner\\n    {\\n        emit MaxEquipmentPerTxChanged(\\n            _msgSender(),\\n            maxEquipmentPerTx,\\n            _maxEquipmentPerTx\\n        );\\n\\n        maxEquipmentPerTx = _maxEquipmentPerTx;\\n    }\\n\\n    // Return reward multiplier over the given from `_from` to `_to` block.\\n    function getMultiplier(uint256 _from, uint256 _to)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return _to.sub(_from);\\n    }\\n\\n    //View function to see user info\\n    function getUserInfo(uint256 _pid, address _account)\\n        external\\n        view\\n        returns (\\n            uint256 amount,\\n            uint256 rewardToHarvest,\\n            uint256 rewardDebt\\n        )\\n    {\\n        UserInfo storage user = _userInfo[_pid][_account];\\n        amount = user.holderTokens.length();\\n        rewardToHarvest = user.rewardToHarvest;\\n        rewardDebt = user.rewardDebt;\\n    }\\n\\n    /// @dev Returns a token ID owned by `owner` at a given `index` of their token list.\\n    /// Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n    function tokenOfOwnerByIndex(\\n        uint256 _pid,\\n        address _owner,\\n        uint256 _index\\n    ) external view returns (uint256) {\\n        UserInfo storage user = _userInfo[_pid][_owner];\\n        return user.holderTokens.at(_index);\\n    }\\n\\n    function pendingReward(uint256 _pid, address _user)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = _userInfo[_pid][_user];\\n        uint256 accRewardPerNFT = pool.accRewardPerNFT;\\n        uint256 totalStaked = pool.totalStaked;\\n\\n        if (block.number > pool.lastRewardBlock && totalStaked != 0) {\\n            uint256 multiplier = getMultiplier(\\n                pool.lastRewardBlock,\\n                block.number\\n            );\\n            uint256 reward = multiplier.mul(pool.rewardPerNFTAndBlock);\\n            accRewardPerNFT = accRewardPerNFT.add(reward);\\n        }\\n\\n        return\\n            user.holderTokens.length().mul(accRewardPerNFT).sub(\\n                user.rewardDebt\\n            );\\n    }\\n\\n    function add(bytes32 _merkleRoot, uint256 _rewardPerNFTAndBlock)\\n        external\\n        override\\n        onlyOwner\\n        poolNotExists(_merkleRoot)\\n    {\\n        _poolIndexes[_merkleRoot] = true;\\n        uint256 lastRewardBlock = block.number > startBlock\\n            ? block.number\\n            : startBlock;\\n        poolInfo.push(\\n            PoolInfo({\\n                merkleRoot: _merkleRoot,\\n                rewardPerNFTAndBlock: _rewardPerNFTAndBlock,\\n                lastRewardBlock: lastRewardBlock,\\n                accRewardPerNFT: 0,\\n                totalStaked: 0\\n            })\\n        );\\n    }\\n\\n    function updateMerkleRoot(uint256 _pid, bytes32 _merkleRoot)\\n        external\\n        override\\n        onlyOwner\\n        poolNotExists(_merkleRoot)\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        bytes32 oldMekleRoot = pool.merkleRoot;\\n        require(\\n            oldMekleRoot != _merkleRoot,\\n            \\\"The new merkle root match old value\\\"\\n        );\\n\\n        _poolIndexes[oldMekleRoot] = false;\\n        _poolIndexes[_merkleRoot] = true;\\n        pool.merkleRoot = _merkleRoot;\\n\\n        emit MerkleRootChanged(_msgSender(), _pid, oldMekleRoot, _merkleRoot);\\n    }\\n\\n    function updateRewardPerNFTAndBlock(\\n        uint256 _pid,\\n        uint256 _rewardPerNFTAndBlock\\n    ) public override onlyOwner {\\n        PoolInfo storage pool = poolInfo[_pid];\\n\\n        uint256 oldRewardPerNFTAndBlock = pool.rewardPerNFTAndBlock;\\n        if (oldRewardPerNFTAndBlock != _rewardPerNFTAndBlock) {\\n            _updateStakingPool(_pid);\\n            pool.rewardPerNFTAndBlock = _rewardPerNFTAndBlock;\\n\\n            emit RewardPerNFTAndBlockChanged(\\n                _pid,\\n                oldRewardPerNFTAndBlock,\\n                _rewardPerNFTAndBlock\\n            );\\n        }\\n    }\\n\\n    function addEquipmentPrice(uint256 _price) external override onlyOwner {\\n        require(_price > 0, \\\"The price is the zero value\\\");\\n        equipmentPriceList.push(_price);\\n\\n        emit EquipmentPriceAdded(\\n            _msgSender(),\\n            equipmentPriceList.length - 1,\\n            _price\\n        );\\n    }\\n\\n    function updateEquipmentPrice(uint256 _idx, uint256 _price)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        require(_price > 0, \\\"The new price is the zero value\\\");\\n        emit EquipmentPriceChanged(\\n            _msgSender(),\\n            _idx,\\n            equipmentPriceList[_idx],\\n            _price\\n        );\\n        equipmentPriceList[_idx] = _price;\\n    }\\n\\n    /// Update pool reward variables\\n    function _updateStakingPool(uint256 _pid) internal {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        uint256 totalStaked = pool.totalStaked;\\n        if (totalStaked == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 reward = multiplier.mul(pool.rewardPerNFTAndBlock);\\n        pool.accRewardPerNFT = pool.accRewardPerNFT.add(reward);\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    function stake(\\n        uint256 _pid,\\n        uint256 _index,\\n        uint256 _tokenId,\\n        bytes32[] calldata _merkleProof\\n    ) external override nonReentrant {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = _userInfo[_pid][_msgSender()];\\n        require(\\n            _tokenIsValid(_index, _tokenId, _merkleProof, pool.merkleRoot),\\n            \\\"Verify tokenId failed\\\"\\n        );\\n\\n        _updateStakingPool(_pid);\\n        uint256 currentBalance = user.holderTokens.length();\\n        if (currentBalance > 0) {\\n            uint256 pending = currentBalance.mul(pool.accRewardPerNFT).sub(\\n                user.rewardDebt\\n            );\\n            if (pending > 0) {\\n                user.rewardToHarvest = user.rewardToHarvest.add(pending);\\n            }\\n        }\\n\\n        EMH.safeTransferFrom(_msgSender(), address(this), _tokenId);\\n        user.holderTokens.add(_tokenId);\\n        user.rewardDebt = user.holderTokens.length().mul(pool.accRewardPerNFT);\\n        pool.totalStaked++;\\n\\n        emit Staked(_msgSender(), _pid, _tokenId);\\n    }\\n\\n    function batchStake(\\n        uint256 _pid,\\n        uint256[] calldata _indexes,\\n        uint256[] calldata _tokenIds,\\n        bytes32[][] calldata _merkleProofs\\n    ) external override nonReentrant {\\n        require(\\n            _indexes.length == _tokenIds.length &&\\n                _indexes.length == _merkleProofs.length,\\n            \\\"indexess, tokenIds and merkleProofs length mismatch\\\"\\n        );\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = _userInfo[_pid][_msgSender()];\\n\\n        _updateStakingPool(_pid);\\n        uint256 currentBalance = user.holderTokens.length();\\n        if (currentBalance > 0) {\\n            uint256 pending = currentBalance.mul(pool.accRewardPerNFT).sub(\\n                user.rewardDebt\\n            );\\n\\n            if (pending > 0) {\\n                user.rewardToHarvest = user.rewardToHarvest.add(pending);\\n            }\\n        }\\n\\n        uint256 amount = _tokenIds.length;\\n        for (uint256 i = 0; i < amount; ++i) {\\n            require(\\n                _tokenIsValid(\\n                    _indexes[i],\\n                    _tokenIds[i],\\n                    _merkleProofs[i],\\n                    pool.merkleRoot\\n                ),\\n                \\\"Verify tokenId failed\\\"\\n            );\\n\\n            EMH.safeTransferFrom(_msgSender(), address(this), _tokenIds[i]);\\n            user.holderTokens.add(_tokenIds[i]);\\n        }\\n        user.rewardDebt = user.holderTokens.length().mul(pool.accRewardPerNFT);\\n        pool.totalStaked += amount;\\n\\n        emit BatchStaked(_msgSender(), _pid, _tokenIds);\\n    }\\n\\n    function unstake(uint256 _pid, uint256 _tokenId)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = _userInfo[_pid][_msgSender()];\\n        require(\\n            user.holderTokens.contains(_tokenId),\\n            \\\"The tokenId has not been staked by the caller\\\"\\n        );\\n\\n        _updateStakingPool(_pid);\\n        uint256 pending = user\\n            .holderTokens\\n            .length()\\n            .mul(pool.accRewardPerNFT)\\n            .sub(user.rewardDebt);\\n        if (pending > 0) {\\n            user.rewardToHarvest = user.rewardToHarvest.add(pending);\\n        }\\n\\n        EMH.safeTransferFrom(address(this), _msgSender(), _tokenId);\\n        user.holderTokens.remove(_tokenId);\\n        user.rewardDebt = user.holderTokens.length().mul(pool.accRewardPerNFT);\\n        pool.totalStaked--;\\n\\n        emit UnStaked(_msgSender(), _pid, _tokenId);\\n    }\\n\\n    function batchUnstake(uint256 _pid, uint256[] calldata _tokenIds)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = _userInfo[_pid][_msgSender()];\\n        uint256 currentBalance = user.holderTokens.length();\\n        uint256 amount = _tokenIds.length;\\n        require(currentBalance >= amount, \\\"Unstake exceeds balance\\\");\\n\\n        _updateStakingPool(_pid);\\n        if (currentBalance > 0) {\\n            uint256 pending = currentBalance.mul(pool.accRewardPerNFT).sub(\\n                user.rewardDebt\\n            );\\n            if (pending > 0) {\\n                user.rewardToHarvest = user.rewardToHarvest.add(pending);\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < amount; ++i) {\\n            require(\\n                user.holderTokens.contains(_tokenIds[i]),\\n                \\\"The tokenId has not been staked by caller\\\"\\n            );\\n            EMH.safeTransferFrom(address(this), _msgSender(), _tokenIds[i]);\\n            user.holderTokens.remove(_tokenIds[i]);\\n        }\\n        user.rewardDebt = user.holderTokens.length().mul(pool.accRewardPerNFT);\\n        pool.totalStaked -= amount;\\n\\n        emit BatchUnStaked(_msgSender(), _pid, _tokenIds);\\n    }\\n\\n    // Be careful of gas spending!\\n    function stopReward() external onlyOwner {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updateRewardPerNFTAndBlock(pid, 0);\\n        }\\n    }\\n\\n    function emergencyUnstake(uint256 _pid, uint256[] calldata _tokenIds)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        require(isEmergency, \\\"Not allow\\\");\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = _userInfo[_pid][_msgSender()];\\n        require(\\n            user.holderTokens.length() >= _tokenIds.length,\\n            \\\"Unstake exceeds balance\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            EMH.safeTransferFrom(address(this), _msgSender(), _tokenIds[i]);\\n            user.holderTokens.remove(_tokenIds[i]);\\n        }\\n        if (user.holderTokens.length() == 0) {\\n            user.rewardDebt = 0;\\n        }\\n        pool.totalStaked -= _tokenIds.length;\\n\\n        emit EmergencyUnstake(_msgSender(), _pid, _tokenIds);\\n    }\\n\\n    function harvest() external override nonReentrant {\\n        uint256 length = poolInfo.length;\\n        uint256 totalEarned = 0;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            PoolInfo storage pool = poolInfo[pid];\\n            UserInfo storage user = _userInfo[pid][_msgSender()];\\n\\n            //we will only calculate the pending rewards of the pools that the user has stake\\n            uint256 currentBalance = user.holderTokens.length();\\n            if (currentBalance > 0) {\\n                _updateStakingPool(pid);\\n                uint256 pending = currentBalance.mul(pool.accRewardPerNFT).sub(\\n                    user.rewardDebt\\n                );\\n\\n                if (pending > 0) {\\n                    user.rewardToHarvest = user.rewardToHarvest.add(pending);\\n                }\\n                user.rewardDebt = currentBalance.mul(pool.accRewardPerNFT);\\n            }\\n            if (user.rewardToHarvest > 0) {\\n                totalEarned = totalEarned.add(user.rewardToHarvest);\\n                user.rewardToHarvest = 0;\\n            }\\n        }\\n        if (totalEarned > 0) {\\n            currencyManager.increase(rewardCurrency, _msgSender(), totalEarned);\\n        }\\n        emit Harvested(_msgSender(), totalEarned);\\n    }\\n\\n    function buyEquipments(uint256 _idx, uint256 _amount)\\n        external\\n        override\\n        buyable\\n    {\\n        require(\\n            _amount <= maxEquipmentPerTx,\\n            \\\"Exceeds the maximum equipment per tx\\\"\\n        );\\n        if (maxEquipmentSupply > 0) {\\n            require(\\n                totalEquipmentSales.add(_amount) <= maxEquipmentSupply,\\n                \\\"Exceeds the maximum equipment supply\\\"\\n            );\\n        }\\n        uint256 cost = equipmentPriceList[_idx].mul(_amount);\\n        currencyManager.decrease(rewardCurrency, _msgSender(), cost);\\n        totalEquipmentSales = totalEquipmentSales.add(_amount);\\n        for (uint256 i = 0; i < _amount; ++i) {\\n            EMQ.mint(_msgSender());\\n        }\\n\\n        emit EquipmentBought(_msgSender(), _idx, _amount);\\n    }\\n\\n    function _tokenIsValid(\\n        uint256 _index,\\n        uint256 _tokenId,\\n        bytes32[] calldata _merkleProof,\\n        bytes32 _merkleRoot\\n    ) internal pure returns (bool) {\\n        // Verify the merkle proof.\\n        bytes32 node = keccak256(abi.encodePacked(_index, _tokenId));\\n        return MerkleProof.verify(_merkleProof, _merkleRoot, node);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurrencyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface ICurrencyManager {\\n    function balanceOf(address account, bytes32 currency) external view returns (uint256);\\n\\n    function increase(\\n        bytes32 currency,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function decrease(\\n        bytes32 currency,\\n        address account,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IElpisEquipment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IElpisEquipment is IERC721 {\\n    function mint(address to) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/INFTStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface INFTStaking {\\n    /// @notice Emitted when someone stake in the pool.\\n    event Staked(address indexed staker, uint256 indexed pid, uint256 tokenId);\\n\\n    /// @notice Emitted when someone batch stake in the pool.\\n    event BatchStaked(\\n        address indexed staker,\\n        uint256 indexed pid,\\n        uint256[] tokenIds\\n    );\\n\\n    /// @notice Emitted when someone unstake from the pool.\\n    event UnStaked(\\n        address indexed staker,\\n        uint256 indexed pid,\\n        uint256 tokenId\\n    );\\n\\n    /// @notice Emitted when someone batch unstake from the pool.\\n    event BatchUnStaked(\\n        address indexed staker,\\n        uint256 indexed pid,\\n        uint256[] tokenIds\\n    );\\n\\n    /// @notice Emitted when someone harvest reward from the pool.\\n    event Harvested(address indexed staker, uint256 amount);\\n\\n    /// @notice Emitted when someone emergency unstake from the pool.\\n    event EmergencyUnstake(\\n        address indexed staker,\\n        uint256 indexed pid,\\n        uint256[] tokenIds\\n    );\\n\\n    /// @notice Emitted when the amount of rewards created per NFT and block is changed.\\n    event RewardPerNFTAndBlockChanged(\\n        uint256 pid,\\n        uint256 oldRewardPerNFTAndBlock,\\n        uint256 newRewardPerNFTAndBlock\\n    );\\n\\n    event MerkleRootChanged(\\n        address account,\\n        uint256 pid,\\n        bytes32 oldMerkleRoot,\\n        bytes32 newMerkleRoot\\n    );\\n\\n    /// @notice Emitted when someone buy equipment.\\n    event EquipmentBought(\\n        address indexed account,\\n        uint256 indexed idx,\\n        uint256 amount\\n    );\\n\\n    /// @notice Emitted when someone add the price list equipment.\\n    event EquipmentPriceAdded(address account, uint256 idx, uint256 price);\\n\\n    /// @notice Emitted when someone change the price list equipment.\\n    event EquipmentPriceChanged(\\n        address account,\\n        uint256 idx,\\n        uint256 oldPrice,\\n        uint256 newPrice\\n    );\\n\\n    /// @notice Emitted when someone change the emergency state.\\n    event EmergencyStateChanged(address account, bool emergencyState);\\n\\n    /// @notice Emitted when someone change the buyable state.\\n    event BuyableStateChanged(address account, bool buyableState);\\n\\n    /// @notice Emitted when someone change the max equipment supply.\\n    event MaxEquipmentSupplyChanged(\\n        address account,\\n        uint256 oldMaxEquipmentSupply,\\n        uint256 newMaxEquipmentSupply\\n    );\\n\\n    /// @notice Emitted when someone change the max equipment per tx.\\n    event MaxEquipmentPerTxChanged(\\n        address account,\\n        uint256 oldMaxEquipmentPerTx,\\n        uint256 newMaxEquipmentPerTx\\n    );\\n\\n    /// @notice View function to see user's pending rewards per pool.\\n    /// @param pid The index of pool in the pools.\\n    /// @param user The address of user.\\n    /// @return the pending reward of user.\\n    function pendingReward(uint256 pid, address user)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Add the price equipment to equipment price list.\\n    /// @param price The price equipment.\\n    function addEquipmentPrice(uint256 price) external;\\n\\n    /// @notice Update the price equipment.\\n    /// @param idx The idx of the price equipment in the equipment price list.\\n    /// @param newPrice The new price list equipment.\\n    function updateEquipmentPrice(uint256 idx, uint256 newPrice) external;\\n\\n    /// @notice Add new staking pool.\\n    /// @param merkleRoot The merkle root is built from hero tree.\\n    /// @param rewardPerNFTAndBlock The amount of rewards created per NFT and block.\\n    function add(bytes32 merkleRoot, uint256 rewardPerNFTAndBlock) external;\\n\\n    /// @notice Update pool's merkle root.\\n    /// @param pid The index of pool in the pools.\\n    /// @param newMerkleRoot The new merkle root is built from hero tree.\\n    function updateMerkleRoot(uint256 pid, bytes32 newMerkleRoot) external;\\n\\n    /// @notice Update pool's merkle root.\\n    /// @param pid The index of pool in the pools.\\n    /// @param newRewardPerNFTAndBlock The new amount of rewards created per NFT and block.\\n    function updateRewardPerNFTAndBlock(\\n        uint256 pid,\\n        uint256 newRewardPerNFTAndBlock\\n    ) external;\\n\\n    /// @notice Stake NFT token to pool for EBA allocation.\\n    /// @param pid The index of pool in the pools.\\n    /// @param index The index of tokenId in the merkle tree.\\n    /// @param tokenId The token id of NFT asset.\\n    /// @param merkleProof A proof containing: sibling hashes on the branch from the leaf to the root of the merkle tree.\\n    function stake(\\n        uint256 pid,\\n        uint256 index,\\n        uint256 tokenId,\\n        bytes32[] calldata merkleProof\\n    ) external;\\n\\n    /// @notice batch stake implementation\\n    function batchStake(\\n        uint256 pid,\\n        uint256[] calldata indexs,\\n        uint256[] calldata tokenIds,\\n        bytes32[][] calldata merkleProofs\\n    ) external;\\n\\n    /// @notice UnStake NFT token from pool.\\n    /// @param pid The index of pool in the pools.\\n    /// @param tokenId The token id of NFT asset.\\n    function unstake(uint256 pid, uint256 tokenId) external;\\n\\n    /// @notice batch unstake implementation\\n    function batchUnstake(uint256 pid, uint256[] calldata tokenIds) external;\\n\\n    /// @notice harvest user rewards.\\n    function harvest() external;\\n\\n    /// @notice Buy `amount` equipment.\\n    /// @param idx The index of equipment price in the equipment price list.\\n    /// @param amount The amount of equipments to buy.\\n    function buyEquipments(uint256 idx, uint256 amount) external;\\n\\n    /// @notice Unstake all without caring about rewards. EMERGENCY ONLY.\\n    /// @param pid The index of pool in the pools.\\n    /// @param tokenIds The list of `tokenId` tokens to unstake from the `pid` pool.\\n    function emergencyUnstake(uint256 pid, uint256[] calldata tokenIds)\\n        external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_EMH\",\"type\":\"address\"},{\"internalType\":\"contract IElpisEquipment\",\"name\":\"_EMQ\",\"type\":\"address\"},{\"internalType\":\"contract ICurrencyManager\",\"name\":\"_currencyManager\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_rewardCurrency\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"BatchStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"BatchUnStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"buyableState\",\"type\":\"bool\"}],\"name\":\"BuyableStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"emergencyState\",\"type\":\"bool\"}],\"name\":\"EmergencyStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"EmergencyUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EquipmentBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"EquipmentPriceAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"EquipmentPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxEquipmentPerTx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxEquipmentPerTx\",\"type\":\"uint256\"}],\"name\":\"MaxEquipmentPerTxChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxEquipmentSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxEquipmentSupply\",\"type\":\"uint256\"}],\"name\":\"MaxEquipmentSupplyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldMerkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRewardPerNFTAndBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRewardPerNFTAndBlock\",\"type\":\"uint256\"}],\"name\":\"RewardPerNFTAndBlockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"UnStaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EMH\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMQ\",\"outputs\":[{\"internalType\":\"contract IElpisEquipment\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerNFTAndBlock\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"addEquipmentPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_indexes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_merkleProofs\",\"type\":\"bytes32[][]\"}],\"name\":\"batchStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyEquipments\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyManager\",\"outputs\":[{\"internalType\":\"contract ICurrencyManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"emergencyUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"equipmentPriceList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardToHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBuyable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEmergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxEquipmentPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxEquipmentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerNFTAndBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerNFT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceListEquipmentsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardCurrency\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEquipmentSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isBuyable\",\"type\":\"bool\"}],\"name\":\"updateBuyableState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEmergency\",\"type\":\"bool\"}],\"name\":\"updateEmergencyState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateEquipmentPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxEquipmentPerTx\",\"type\":\"uint256\"}],\"name\":\"updateMaxEquipmentPerTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxEquipmentSupply\",\"type\":\"uint256\"}],\"name\":\"updateMaxEquipmentSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerNFTAndBlock\",\"type\":\"uint256\"}],\"name\":\"updateRewardPerNFTAndBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NFTStakingV2", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9156432bc661300722ab1ede425eb2a607dd26c0000000000000000000000006647bd0cc251ea11c77e655e9020c10c2270417000000000000000000000000080c03808dd0d5ef81a3db68937dc7d53c962e6a249524f4e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0bd98", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}