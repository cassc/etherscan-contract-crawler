{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/policy/Policy.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../../dependencies/BokkyPooBahsDateTimeLibrary.sol\\\";\\nimport \\\"../../interfaces/IStore.sol\\\";\\nimport \\\"../../interfaces/ICxTokenFactory.sol\\\";\\nimport \\\"../../interfaces/ICxToken.sol\\\";\\nimport \\\"../../interfaces/IPolicy.sol\\\";\\nimport \\\"../../libraries/PolicyHelperV1.sol\\\";\\nimport \\\"../Recoverable.sol\\\";\\n\\n/**\\n * @title Policy Contract\\n * @dev The policy contract enables you to a purchase cover\\n */\\ncontract Policy is IPolicy, Recoverable {\\n  using PolicyHelperV1 for IStore;\\n  using ProtoUtilV1 for IStore;\\n  using CoverUtilV1 for IStore;\\n  using ValidationLibV1 for IStore;\\n  using StrategyLibV1 for IStore;\\n\\n  /**\\n   * @dev Constructs this contract\\n   *\\n   * @param store Provide an implementation of IStore\\n   */\\n  constructor(IStore store) Recoverable(store) {} // solhint-disable-line\\n\\n  /**\\n   * @dev Purchase cover for the specified amount. <br /> <br />\\n   * When you purchase covers, you receive equal amount of cxTokens back.\\n   * You need the cxTokens to claim the cover when resolution occurs.\\n   * Each unit of cxTokens are fully redeemable at 1:1 ratio to the given\\n   * stablecoins (like wxDai, DAI, USDC, or BUSD) based on the chain.\\n   *\\n   * https://docs.neptunemutual.com/covers/purchasing-covers\\n   *\\n   * ## Payouts and Incident Date\\n   *\\n   * @custom:note Please take note of the following key differences:\\n   *\\n   * **Event Date or Observed Date**\\n   *\\n   * The date and time the event took place in the real world.\\n   * It is also referred to as the **event date**.\\n   *\\n   * **Incident Date**\\n   *\\n   * The incident date is the timestamp at which an event report is submitted.\\n   * Only if the incident date falls within your coverage period\\n   * and resolution is in your favor, will you receive a claims payout.\\n   *\\n   * **Claim Period**\\n   *\\n   * In contrast to most DeFi cover protocols, Neptune Mutual has no waiting period\\n   * between submitting a claim and receiving payout. You can access the claims feature\\n   * to immediately receive a payout if a cover is successfully resolved as Incident Happened.\\n   *\\n   * Please note that after an incident is resolved, there is usually a 7-day claim period.\\n   * Any claim submitted after the claim period expiry is automatically denied.\\n   *\\n   * @custom:warning Warning:\\n   *\\n   * Please thoroughly review the cover rules, cover exclusions,\\n   * and standard exclusions before purchasing a cover.\\n   *\\n   * If the resolution does not go in your favour, you will not be able to\\n   * submit a claim or receive a payout.\\n   *\\n   * By using the this function on our UI, directly via a smart contract call,\\n   * through an explorer service such as Etherscan,\\n   * through an SDK and/or API, or in any other way,\\n   * you are fully aware, fully understand, and accept the risk\\n   * of getting your claim(s) denied.\\n   *\\n   * @custom:suppress-acl This is a publicly accessible feature\\n   *\\n   */\\n  function purchaseCover(PurchaseCoverArgs calldata args) public override nonReentrant returns (address, uint256) {\\n    // @todo: When the POT system is replaced with NPM tokens in the future, upgrade this contract\\n    // and uncomment the following line\\n    // require(IERC20(s.getNpmTokenAddressInternal()).balanceOf(msg.sender) >= 1 ether, \\\"No NPM balance\\\");\\n    require(args.coverKey > 0, \\\"Invalid cover key\\\");\\n    require(args.onBehalfOf != address(0), \\\"Invalid `onBehalfOf`\\\");\\n    require(args.amountToCover > 0, \\\"Enter an amount\\\");\\n    require(args.coverDuration > 0 && args.coverDuration <= ProtoUtilV1.MAX_POLICY_DURATION, \\\"Invalid cover duration\\\");\\n\\n    s.mustNotBePaused();\\n    s.mustMaintainProposalThreshold(args.amountToCover);\\n    s.mustBeSupportedProductOrEmpty(args.coverKey, args.productKey);\\n    s.mustHaveNormalProductStatus(args.coverKey, args.productKey);\\n    s.mustNotHavePolicyDisabled(args.coverKey, args.productKey);\\n    s.senderMustBeWhitelistedIfRequired(args.coverKey, args.productKey, args.onBehalfOf);\\n\\n    uint256 lastPolicyId = s.incrementPolicyIdInternal();\\n\\n    (ICxToken cxToken, uint256 fee, uint256 platformFee) = s.purchaseCoverInternal(lastPolicyId, args);\\n\\n    emit CoverPurchased(args, address(cxToken), fee, platformFee, cxToken.expiresOn(), lastPolicyId);\\n    return (address(cxToken), lastPolicyId);\\n  }\\n\\n  function purchaseCovers(PurchaseCoverArgs[] calldata args) external {\\n    for (uint256 i = 0; i < args.length; i++) {\\n      purchaseCover(args[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets cxToken and its expiry address by the supplied arguments.\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param coverKey Enter the cover key\\n   * @param productKey Enter the cover key\\n   * @param coverDuration Enter the cover's policy duration. Valid values: 1-3.\\n   *\\n   */\\n  function getCxToken(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 coverDuration\\n  ) external view override returns (address cxToken, uint256 expiryDate) {\\n    require(coverDuration > 0 && coverDuration <= ProtoUtilV1.MAX_POLICY_DURATION, \\\"Invalid cover duration\\\");\\n\\n    return s.getCxTokenInternal(coverKey, productKey, coverDuration);\\n  }\\n\\n  /**\\n   * @dev Returns cxToken address by the cover key, product key, and expiry date.\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param coverKey Enter the cover key\\n   * @param productKey Enter the cover key\\n   * @param expiryDate Enter the cxToken's expiry date\\n   *\\n   */\\n  function getCxTokenByExpiryDate(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 expiryDate\\n  ) external view override returns (address cxToken) {\\n    return s.getCxTokenByExpiryDateInternal(coverKey, productKey, expiryDate);\\n  }\\n\\n  /**\\n   * @dev Gets the expiry date based on cover duration\\n   * @param today Enter the current timestamp\\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\\n   *\\n   */\\n  function getExpiryDate(uint256 today, uint256 coverDuration) external pure override returns (uint256) {\\n    return CoverUtilV1.getExpiryDateInternal(today, coverDuration);\\n  }\\n\\n  /**\\n   * @dev Gets the sum total of cover commitment that has not expired yet.\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   */\\n  function getCommitment(bytes32 coverKey, bytes32 productKey) external view override returns (uint256) {\\n    uint256 precision = s.getStablecoinPrecisionInternal();\\n    return s.getActiveLiquidityUnderProtectionInternal(coverKey, productKey, precision);\\n  }\\n\\n  /**\\n   * @dev Gets the available liquidity in the pool.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   */\\n  function getAvailableLiquidity(bytes32 coverKey) external view override returns (uint256) {\\n    return s.getStablecoinOwnedByVaultInternal(coverKey);\\n  }\\n\\n  /**\\n   * @dev Gets the cover fee info for the given cover key, duration, and amount\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter the cover key\\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\\n   * @param amountToCover Enter the amount of the stablecoin to cover.\\n   *\\n   */\\n  function getCoverFeeInfo(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 coverDuration,\\n    uint256 amountToCover\\n  ) external view override returns (CoverFeeInfoType memory) {\\n    PolicyHelperV1.CalculatePolicyFeeArgs memory args = PolicyHelperV1.CalculatePolicyFeeArgs({coverKey: coverKey, productKey: productKey, coverDuration: coverDuration, amountToCover: amountToCover});\\n    return s.calculatePolicyFeeInternal(args);\\n  }\\n\\n  /**\\n   * @dev Returns the pool summary of the given cover key\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   */\\n  function getCoverPoolSummary(bytes32 coverKey, bytes32 productKey) external view override returns (IPolicy.CoverPoolSummaryType memory summary) {\\n    return s.getCoverPoolSummaryInternal(coverKey, productKey);\\n  }\\n\\n  /**\\n   * @dev Version number of this contract\\n   */\\n  function version() external pure override returns (bytes32) {\\n    return \\\"v0.1\\\";\\n  }\\n\\n  /**\\n   * @dev Name of this contract\\n   */\\n  function getName() external pure override returns (bytes32) {\\n    return ProtoUtilV1.CNAME_POLICY;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Recoverable.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"../interfaces/IRecoverable.sol\\\";\\nimport \\\"../libraries/BaseLibV1.sol\\\";\\nimport \\\"../libraries/ValidationLibV1.sol\\\";\\n\\n/**\\n *\\n * @title Recoverable Contract\\n * @dev The recoverable contract enables \\\"Recovery Agents\\\" to recover\\n * Ether and ERC-20 tokens sent to this address.\\n *\\n * To learn more about our recovery policy, please refer to the following doc:\\n * https://docs.neptunemutual.com/usage/recovering-cryptocurrencies\\n *\\n */\\nabstract contract Recoverable is ReentrancyGuard, IRecoverable {\\n  using ValidationLibV1 for IStore;\\n  IStore public override s;\\n\\n  constructor(IStore store) {\\n    require(address(store) != address(0), \\\"Invalid Store\\\");\\n    s = store;\\n  }\\n\\n  /**\\n   * @dev Recover all Ether held by the contract.\\n   * On success, no event is emitted because the recovery feature does\\n   * not have any significance in the SDK or the UI.\\n   */\\n  function recoverEther(address sendTo) external override nonReentrant {\\n    s.mustNotBePaused();\\n    AccessControlLibV1.mustBeRecoveryAgent(s);\\n    BaseLibV1.recoverEtherInternal(sendTo);\\n  }\\n\\n  /**\\n   * @dev Recover all ERC-20 compatible tokens sent to this address.\\n   * On success, no event is emitted because the recovery feature does\\n   * not have any significance in the SDK or the UI.\\n   *\\n   * @custom:suppress-malicious-erc The malicious ERC-20 `token` should only be invoked via `NTransferUtil`.\\n   * @custom:suppress-address-trust-issue Although the token can't be trusted, the recovery agent has to check the token code manually.\\n   *\\n   * @param token ERC-20 The address of the token contract\\n   */\\n  function recoverToken(address token, address sendTo) external override nonReentrant {\\n    s.mustNotBePaused();\\n    AccessControlLibV1.mustBeRecoveryAgent(s);\\n    BaseLibV1.recoverTokenInternal(token, sendTo);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/BokkyPooBahsDateTimeLibrary.sol\": {\r\n      \"content\": \"/* solhint-disable var-name-mixedcase, private-vars-leading-underscore, reason-string */\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.01\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary BokkyPooBahsDateTimeLibrary {\\n  uint256 internal constant SECONDS_PER_DAY = 24 * 60 * 60;\\n  uint256 internal constant SECONDS_PER_HOUR = 60 * 60;\\n  uint256 internal constant SECONDS_PER_MINUTE = 60;\\n  int256 internal constant OFFSET19700101 = 2440588;\\n\\n  uint256 internal constant DOW_MON = 1;\\n  uint256 internal constant DOW_TUE = 2;\\n  uint256 internal constant DOW_WED = 3;\\n  uint256 internal constant DOW_THU = 4;\\n  uint256 internal constant DOW_FRI = 5;\\n  uint256 internal constant DOW_SAT = 6;\\n  uint256 internal constant DOW_SUN = 7;\\n\\n  // ------------------------------------------------------------------------\\n  // Calculate the number of days from 1970/01/01 to year/month/day using\\n  // the date conversion algorithm from\\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n  // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n  //\\n  // days = day\\n  //      - 32075\\n  //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n  //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n  //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n  //      - offset\\n  // ------------------------------------------------------------------------\\n  function _daysFromDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (uint256 _days) {\\n    require(year >= 1970);\\n    int256 _year = int256(year);\\n    int256 _month = int256(month);\\n    int256 _day = int256(day);\\n\\n    int256 __days = _day -\\n      32075 +\\n      (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n      4 +\\n      (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n      12 -\\n      (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n      4 -\\n      OFFSET19700101;\\n\\n    _days = uint256(__days);\\n  }\\n\\n  // ------------------------------------------------------------------------\\n  // Calculate year/month/day from the number of days since 1970/01/01 using\\n  // the date conversion algorithm from\\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n  // and adding the offset 2440588 so that 1970/01/01 is day 0\\n  //\\n  // int L = days + 68569 + offset\\n  // int N = 4 * L / 146097\\n  // L = L - (146097 * N + 3) / 4\\n  // year = 4000 * (L + 1) / 1461001\\n  // L = L - 1461 * year / 4 + 31\\n  // month = 80 * L / 2447\\n  // dd = L - 2447 * month / 80\\n  // L = month / 11\\n  // month = month + 2 - 12 * L\\n  // year = 100 * (N - 49) + year + L\\n  // ------------------------------------------------------------------------\\n  function _daysToDate(uint256 _days)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day\\n    )\\n  {\\n    int256 __days = int256(_days);\\n\\n    int256 L = __days + 68569 + OFFSET19700101;\\n    int256 N = (4 * L) / 146097;\\n    L = L - (146097 * N + 3) / 4;\\n    int256 _year = (4000 * (L + 1)) / 1461001;\\n    L = L - (1461 * _year) / 4 + 31;\\n    int256 _month = (80 * L) / 2447;\\n    int256 _day = L - (2447 * _month) / 80;\\n    L = _month / 11;\\n    _month = _month + 2 - 12 * L;\\n    _year = 100 * (N - 49) + _year + L;\\n\\n    year = uint256(_year);\\n    month = uint256(_month);\\n    day = uint256(_day);\\n  }\\n\\n  function timestampFromDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (uint256 timestamp) {\\n    timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n  }\\n\\n  function timestampFromDateTime(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day,\\n    uint256 hour,\\n    uint256 minute,\\n    uint256 second\\n  ) internal pure returns (uint256 timestamp) {\\n    timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\\n  }\\n\\n  function timestampToDate(uint256 timestamp)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day\\n    )\\n  {\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function timestampToDateTime(uint256 timestamp)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day,\\n      uint256 hour,\\n      uint256 minute,\\n      uint256 second\\n    )\\n  {\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    uint256 secs = timestamp % SECONDS_PER_DAY;\\n    hour = secs / SECONDS_PER_HOUR;\\n    secs = secs % SECONDS_PER_HOUR;\\n    minute = secs / SECONDS_PER_MINUTE;\\n    second = secs % SECONDS_PER_MINUTE;\\n  }\\n\\n  function isValidDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (bool valid) {\\n    if (year >= 1970 && month > 0 && month <= 12) {\\n      uint256 daysInMonth = _getDaysInMonth(year, month);\\n      if (day > 0 && day <= daysInMonth) {\\n        valid = true;\\n      }\\n    }\\n  }\\n\\n  function isValidDateTime(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day,\\n    uint256 hour,\\n    uint256 minute,\\n    uint256 second\\n  ) internal pure returns (bool valid) {\\n    if (isValidDate(year, month, day)) {\\n      if (hour < 24 && minute < 60 && second < 60) {\\n        valid = true;\\n      }\\n    }\\n  }\\n\\n  function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {\\n    (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    leapYear = _isLeapYear(year);\\n  }\\n\\n  function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\\n    leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n  }\\n\\n  function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\\n    weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\\n  }\\n\\n  function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\\n    weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\\n  }\\n\\n  function getDaysInMonth(uint256 timestamp) internal pure returns (uint256 daysInMonth) {\\n    (uint256 year, uint256 month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    daysInMonth = _getDaysInMonth(year, month);\\n  }\\n\\n  function _getDaysInMonth(uint256 year, uint256 month) internal pure returns (uint256 daysInMonth) {\\n    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n      daysInMonth = 31;\\n    } else if (month != 2) {\\n      daysInMonth = 30;\\n    } else {\\n      daysInMonth = _isLeapYear(year) ? 29 : 28;\\n    }\\n  }\\n\\n  // 1 = Monday, 7 = Sunday\\n  function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {\\n    uint256 _days = timestamp / SECONDS_PER_DAY;\\n    dayOfWeek = ((_days + 3) % 7) + 1;\\n  }\\n\\n  function getYear(uint256 timestamp) internal pure returns (uint256 year) {\\n    (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\\n    (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getDay(uint256 timestamp) internal pure returns (uint256 day) {\\n    (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\\n    uint256 secs = timestamp % SECONDS_PER_DAY;\\n    hour = secs / SECONDS_PER_HOUR;\\n  }\\n\\n  function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {\\n    uint256 secs = timestamp % SECONDS_PER_HOUR;\\n    minute = secs / SECONDS_PER_MINUTE;\\n  }\\n\\n  function getSecond(uint256 timestamp) internal pure returns (uint256 second) {\\n    second = timestamp % SECONDS_PER_MINUTE;\\n  }\\n\\n  function addYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    year += _years;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    month += _months;\\n    year += (month - 1) / 12;\\n    month = ((month - 1) % 12) + 1;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addDays(uint256 timestamp, uint256 _days) internal pure returns (uint256 newTimestamp) {\\n    newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addHours(uint256 timestamp, uint256 _hours) internal pure returns (uint256 newTimestamp) {\\n    newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addMinutes(uint256 timestamp, uint256 _minutes) internal pure returns (uint256 newTimestamp) {\\n    newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\\n    newTimestamp = timestamp + _seconds;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function subYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    year -= _years;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    uint256 yearMonth = year * 12 + (month - 1) - _months;\\n    year = yearMonth / 12;\\n    month = (yearMonth % 12) + 1;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subDays(uint256 timestamp, uint256 _days) internal pure returns (uint256 newTimestamp) {\\n    newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subHours(uint256 timestamp, uint256 _hours) internal pure returns (uint256 newTimestamp) {\\n    newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subMinutes(uint256 timestamp, uint256 _minutes) internal pure returns (uint256 newTimestamp) {\\n    newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\\n    newTimestamp = timestamp - _seconds;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function diffYears(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _years) {\\n    require(fromTimestamp <= toTimestamp);\\n    (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n    (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n    _years = toYear - fromYear;\\n  }\\n\\n  function diffMonths(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _months) {\\n    require(fromTimestamp <= toTimestamp);\\n    (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n    (uint256 toYear, uint256 toMonth, ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n    _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n  }\\n\\n  function diffDays(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _days) {\\n    require(fromTimestamp <= toTimestamp);\\n    _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n  }\\n\\n  function diffHours(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _hours) {\\n    require(fromTimestamp <= toTimestamp);\\n    _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n  }\\n\\n  function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _minutes) {\\n    require(fromTimestamp <= toTimestamp);\\n    _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n  }\\n\\n  function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _seconds) {\\n    require(fromTimestamp <= toTimestamp);\\n    _seconds = toTimestamp - fromTimestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/uniswap-v2/IUniswapV2FactoryLike.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2FactoryLike {\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/uniswap-v2/IUniswapV2PairLike.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2PairLike {\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/uniswap-v2/IUniswapV2RouterLike.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2RouterLike {\\n  function factory() external view returns (address);\\n\\n  function getAmountOut(\\n    uint256 amountIn,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) external pure returns (uint256 amountOut);\\n\\n  function getAmountIn(\\n    uint256 amountOut,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) external pure returns (uint256 amountIn);\\n\\n  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n  function quote(\\n    uint256 amountA,\\n    uint256 reserveA,\\n    uint256 reserveB\\n  ) external pure returns (uint256 amountB);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint256 amountADesired,\\n    uint256 amountBDesired,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    returns (\\n      uint256 amountA,\\n      uint256 amountB,\\n      uint256 liquidity\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondPool.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IMember.sol\\\";\\n\\ninterface IBondPool is IMember {\\n  struct BondPoolInfoType {\\n    address lpToken;\\n    uint256 marketPrice;\\n    uint256 discountRate;\\n    uint256 vestingTerm;\\n    uint256 maxBond;\\n    uint256 totalNpmAllocated;\\n    uint256 totalNpmDistributed;\\n    uint256 npmAvailable;\\n    uint256 bondContribution;\\n    uint256 claimable;\\n    uint256 unlockDate;\\n  }\\n\\n  struct SetupBondPoolArgs {\\n    address lpToken;\\n    address treasury;\\n    uint256 bondDiscountRate;\\n    uint256 maxBondAmount;\\n    uint256 vestingTerm;\\n    uint256 npmToTopUpNow;\\n  }\\n\\n  event BondPoolSetup(SetupBondPoolArgs args);\\n  event BondCreated(address indexed account, uint256 lpTokens, uint256 npmToVest, uint256 unlockDate);\\n  event BondClaimed(address indexed account, uint256 amount);\\n\\n  function setup(SetupBondPoolArgs calldata args) external;\\n\\n  function createBond(uint256 lpTokens, uint256 minNpmDesired) external;\\n\\n  function claimBond() external;\\n\\n  function getNpmMarketPrice() external view returns (uint256);\\n\\n  function calculateTokensForLp(uint256 lpTokens) external view returns (uint256);\\n\\n  function getInfo(address forAccount) external view returns (BondPoolInfoType memory info);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICover.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IMember.sol\\\";\\n\\ninterface ICover is IMember {\\n  struct AddCoverArgs {\\n    bytes32 coverKey;\\n    string info;\\n    string tokenName;\\n    string tokenSymbol;\\n    bool supportsProducts;\\n    bool requiresWhitelist;\\n    uint256 stakeWithFee;\\n    uint256 initialReassuranceAmount;\\n    uint256 minStakeToReport;\\n    uint256 reportingPeriod;\\n    uint256 cooldownPeriod;\\n    uint256 claimPeriod;\\n    uint256 floor;\\n    uint256 ceiling;\\n    uint256 reassuranceRate;\\n    uint256 leverageFactor;\\n  }\\n\\n  struct AddProductArgs {\\n    bytes32 coverKey;\\n    bytes32 productKey;\\n    string info;\\n    bool requiresWhitelist;\\n    uint256 productStatus;\\n    uint256 efficiency;\\n  }\\n\\n  struct UpdateProductArgs {\\n    bytes32 coverKey;\\n    bytes32 productKey;\\n    string info;\\n    uint256 productStatus;\\n    uint256 efficiency;\\n  }\\n\\n  event CoverCreated(bytes32 indexed coverKey, string info, string tokenName, string tokenSymbol, bool indexed supportsProducts, bool indexed requiresWhitelist);\\n  event ProductCreated(bytes32 indexed coverKey, bytes32 productKey, string info);\\n  event CoverUpdated(bytes32 indexed coverKey, string info);\\n  event ProductUpdated(bytes32 indexed coverKey, bytes32 productKey, string info);\\n  event ProductStateUpdated(bytes32 indexed coverKey, bytes32 indexed productKey, address indexed updatedBy, bool status, string reason);\\n\\n  event CoverCreatorWhitelistUpdated(address account, bool status);\\n  event CoverUserWhitelistUpdated(bytes32 indexed coverKey, bytes32 indexed productKey, address indexed account, bool status);\\n  event CoverCreationFeeSet(uint256 previous, uint256 current);\\n  event MinCoverCreationStakeSet(uint256 previous, uint256 current);\\n  event MinStakeToAddLiquiditySet(uint256 previous, uint256 current);\\n  event CoverInitialized(address indexed stablecoin, bytes32 withName);\\n\\n  /**\\n   * @dev Initializes this contract\\n   * @param stablecoin Provide the address of the token this cover will be quoted against.\\n   * @param friendlyName Enter a description or ENS name of your liquidity token.\\n   *\\n   */\\n  function initialize(address stablecoin, bytes32 friendlyName) external;\\n\\n  /**\\n   * @dev Adds a new coverage pool or cover contract.\\n   * To add a new cover, you need to pay cover creation fee\\n   * and stake minimum amount of NPM in the Vault. <br /> <br />\\n   *\\n   * Through the governance portal, projects will be able redeem\\n   * the full cover fee at a later date. <br /> <br />\\n   *\\n   * **Apply for Fee Redemption** <br />\\n   * https://docs.neptunemutual.com/covers/cover-fee-redemption <br /><br />\\n   *\\n   * As the cover creator, you will earn a portion of all cover fees\\n   * generated in this pool. <br /> <br />\\n   *\\n   * Read the documentation to learn more about the fees: <br />\\n   * https://docs.neptunemutual.com/covers/contract-creators\\n   *\\n   */\\n  function addCover(AddCoverArgs calldata args) external returns (address);\\n\\n  function addCovers(AddCoverArgs[] calldata args) external returns (address[] memory vaults);\\n\\n  function addProduct(AddProductArgs calldata args) external;\\n\\n  function addProducts(AddProductArgs[] calldata args) external;\\n\\n  function updateProduct(UpdateProductArgs calldata args) external;\\n\\n  /**\\n   * @dev Updates the cover contract.\\n   * This feature is accessible only to the cover owner or protocol owner (governance).\\n   *\\n   * @param coverKey Enter the cover key\\n   * @param info Enter a new IPFS hash to update\\n   */\\n  function updateCover(bytes32 coverKey, string calldata info) external;\\n\\n  function updateCoverCreatorWhitelist(address[] calldata account, bool[] calldata whitelisted) external;\\n\\n  function updateCoverUsersWhitelist(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address[] calldata accounts,\\n    bool[] calldata statuses\\n  ) external;\\n\\n  function disablePolicy(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    bool status,\\n    string calldata reason\\n  ) external;\\n\\n  function checkIfWhitelistedCoverCreator(address account) external view returns (bool);\\n\\n  function checkIfWhitelistedUser(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address account\\n  ) external view returns (bool);\\n\\n  function setCoverCreationFee(uint256 value) external;\\n\\n  function setMinCoverCreationStake(uint256 value) external;\\n\\n  function setMinStakeToAddLiquidity(uint256 value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICoverReassurance.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IMember.sol\\\";\\n\\ninterface ICoverReassurance is IMember {\\n  event ReassuranceAdded(bytes32 indexed coverKey, address indexed onBehalfOf, uint256 amount);\\n  event WeightSet(bytes32 indexed coverKey, uint256 weight);\\n  event PoolCapitalized(bytes32 indexed coverKey, bytes32 indexed productKey, uint256 indexed incidentDate, uint256 amount);\\n\\n  /**\\n   * @dev Adds reassurance to the specified cover contract\\n   * @param coverKey Enter the cover key\\n   * @param onBehalfOf Enter the account on behalf of which you are adding reassurance.\\n   * @param amount Enter the amount you would like to supply\\n   */\\n  function addReassurance(\\n    bytes32 coverKey,\\n    address onBehalfOf,\\n    uint256 amount\\n  ) external;\\n\\n  function setWeight(bytes32 coverKey, uint256 weight) external;\\n\\n  function capitalizePool(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external;\\n\\n  /**\\n   * @dev Gets the reassurance amount of the specified cover contract\\n   * @param coverKey Enter the cover key\\n   */\\n  function getReassurance(bytes32 coverKey) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICoverStake.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IMember.sol\\\";\\n\\ninterface ICoverStake is IMember {\\n  event StakeAdded(bytes32 indexed coverKey, address indexed account, uint256 amount);\\n  event StakeRemoved(bytes32 indexed coverKey, address indexed account, uint256 amount);\\n  event FeeBurned(bytes32 indexed coverKey, uint256 amount);\\n\\n  /**\\n   * @dev Increase the stake of the given cover pool\\n   * @param coverKey Enter the cover key\\n   * @param account Enter the account from where the NPM tokens will be transferred\\n   * @param amount Enter the amount of stake\\n   * @param fee Enter the fee amount. Note: do not enter the fee if you are directly calling this function.\\n   */\\n  function increaseStake(\\n    bytes32 coverKey,\\n    address account,\\n    uint256 amount,\\n    uint256 fee\\n  ) external;\\n\\n  /**\\n   * @dev Decreases the stake from the given cover pool\\n   * @param coverKey Enter the cover key\\n   * @param amount Enter the amount of stake to decrease\\n   */\\n  function decreaseStake(bytes32 coverKey, uint256 amount) external;\\n\\n  /**\\n   * @dev Gets the stake of an account for the given cover key\\n   * @param coverKey Enter the cover key\\n   * @param account Specify the account to obtain the stake of\\n   * @return Returns the total stake of the specified account on the given cover key\\n   */\\n  function stakeOf(bytes32 coverKey, address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICxToken.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\ninterface ICxToken is IERC20 {\\n  event CoverageStartSet(uint256 policyId, bytes32 coverKey, bytes32 productKey, address account, uint256 effectiveFrom, uint256 amount);\\n\\n  function mint(\\n    uint256 policyId,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address to,\\n    uint256 amount\\n  ) external;\\n\\n  function burn(uint256 amount) external;\\n\\n  function createdOn() external view returns (uint256);\\n\\n  function expiresOn() external view returns (uint256);\\n\\n  // slither-disable-next-line naming-convention\\n  function COVER_KEY() external view returns (bytes32); // solhint-disable\\n\\n  // slither-disable-next-line naming-convention\\n  function PRODUCT_KEY() external view returns (bytes32); // solhint-disable\\n\\n  function getCoverageStartsFrom(address account, uint256 date) external view returns (uint256);\\n\\n  function getClaimablePolicyOf(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICxTokenFactory.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IStore.sol\\\";\\nimport \\\"./IMember.sol\\\";\\n\\ninterface ICxTokenFactory is IMember {\\n  event CxTokenDeployed(address cxToken, IStore store, bytes32 indexed coverKey, bytes32 indexed productKey, string tokenName, uint256 indexed expiryDate);\\n\\n  function deploy(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    string calldata tokenName,\\n    uint256 expiryDate\\n  ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Detailed.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20Detailed is IERC20 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function mint(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernance.sol\": {\r\n      \"content\": \"/* solhint-disable function-max-lines */\\n// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IReporter.sol\\\";\\nimport \\\"./IWitness.sol\\\";\\nimport \\\"./IMember.sol\\\";\\n\\n// solhint-disable-next-line\\ninterface IGovernance is IMember, IReporter, IWitness {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingStrategy.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IMember.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\ninterface ILendingStrategy is IMember {\\n  struct LendingStrategyInfoType {\\n    uint256 deposits;\\n    uint256 withdrawals;\\n  }\\n\\n  event LogDeposit(bytes32 indexed name, uint256 counter, uint256 amount, uint256 certificateReceived, uint256 depositTotal, uint256 withdrawalTotal);\\n  event Deposited(bytes32 indexed key, address indexed onBehalfOf, uint256 stablecoinDeposited, uint256 certificateTokenIssued);\\n  event LogWithdrawal(bytes32 indexed name, uint256 counter, uint256 stablecoinWithdrawn, uint256 certificateRedeemed, uint256 depositTotal, uint256 withdrawalTotal);\\n  event Withdrawn(bytes32 indexed key, address indexed sendTo, uint256 stablecoinWithdrawn, uint256 certificateTokenRedeemed);\\n  event Drained(IERC20 indexed asset, uint256 amount);\\n\\n  function getKey() external pure returns (bytes32);\\n\\n  function getWeight() external pure returns (uint256);\\n\\n  function getDepositAsset() external view returns (IERC20);\\n\\n  function getDepositCertificate() external view returns (IERC20);\\n\\n  /**\\n   * @dev Gets info of this strategy by cover key\\n   * @param coverKey Enter the cover key\\n   */\\n  function getInfo(bytes32 coverKey) external view returns (LendingStrategyInfoType memory info);\\n\\n  function deposit(bytes32 coverKey, uint256 amount) external returns (uint256 certificateReceived);\\n\\n  function withdraw(bytes32 coverKey) external returns (uint256 stablecoinWithdrawn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMember.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IMember {\\n  /**\\n   * @dev Version number of this contract\\n   */\\n  function version() external pure returns (bytes32);\\n\\n  /**\\n   * @dev Name of this contract\\n   */\\n  function getName() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPausable.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IPausable {\\n  function paused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPolicy.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IMember.sol\\\";\\n\\ninterface IPolicy is IMember {\\n  struct PurchaseCoverArgs {\\n    address onBehalfOf;\\n    bytes32 coverKey;\\n    bytes32 productKey;\\n    uint256 coverDuration;\\n    uint256 amountToCover;\\n    bytes32 referralCode;\\n  }\\n\\n  struct CoverFeeInfoType {\\n    uint256 fee;\\n    uint256 utilizationRatio;\\n    uint256 totalAvailableLiquidity;\\n    uint256 floor;\\n    uint256 ceiling;\\n    uint256 rate;\\n  }\\n\\n  struct CoverPoolSummaryType {\\n    uint256 totalAmountInPool;\\n    uint256 totalCommitment;\\n    uint256 reassuranceAmount;\\n    uint256 reassurancePoolWeight;\\n    uint256 productCount;\\n    uint256 leverage;\\n    uint256 productCapitalEfficiency;\\n  }\\n\\n  event CoverPurchased(PurchaseCoverArgs args, address indexed cxToken, uint256 fee, uint256 platformFee, uint256 expiresOn, uint256 policyId);\\n\\n  /**\\n   * @dev Purchase cover for the specified amount. <br /> <br />\\n   * When you purchase covers, you receive equal amount of cxTokens back.\\n   * You need the cxTokens to claim the cover when resolution occurs.\\n   * Each unit of cxTokens are fully redeemable at 1:1 ratio to the given\\n   * stablecoins (like wxDai, DAI, USDC, or BUSD) based on the chain.\\n   */\\n\\n  function purchaseCover(PurchaseCoverArgs calldata args) external returns (address, uint256);\\n\\n  /**\\n   * @dev Gets the cover fee info for the given cover key, duration, and amount\\n   * @param coverKey Enter the cover key\\n   * @param productKey Enter the product key\\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\\n   * @param amountToCover Enter the amount of the stablecoin to cover.\\n   */\\n  function getCoverFeeInfo(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 coverDuration,\\n    uint256 amountToCover\\n  ) external view returns (CoverFeeInfoType memory);\\n\\n  /**\\n   * @dev Returns pool summary of the given cover key\\n   */\\n  function getCoverPoolSummary(bytes32 coverKey, bytes32 productKey) external view returns (CoverPoolSummaryType memory summary);\\n\\n  function getCxToken(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 coverDuration\\n  ) external view returns (address cxToken, uint256 expiryDate);\\n\\n  function getCxTokenByExpiryDate(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 expiryDate\\n  ) external view returns (address cxToken);\\n\\n  /**\\n   * Gets the sum total of cover commitment that haven't expired yet.\\n   */\\n  function getCommitment(bytes32 coverKey, bytes32 productKey) external view returns (uint256);\\n\\n  /**\\n   * Gets the available liquidity in the pool.\\n   */\\n  function getAvailableLiquidity(bytes32 coverKey) external view returns (uint256);\\n\\n  /**\\n   * @dev Gets the expiry date based on cover duration\\n   * @param today Enter the current timestamp\\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\\n   */\\n  function getExpiryDate(uint256 today, uint256 coverDuration) external pure returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IPriceOracle {\\n  function update() external;\\n\\n  function consult(address token, uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function consultPair(uint256 amountIn) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProtocol.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/access/IAccessControl.sol\\\";\\nimport \\\"./IMember.sol\\\";\\n\\ninterface IProtocol is IMember, IAccessControl {\\n  struct AccountWithRoles {\\n    address account;\\n    bytes32[] roles;\\n  }\\n\\n  struct InitializeArgs {\\n    address burner;\\n    address uniswapV2RouterLike;\\n    address uniswapV2FactoryLike;\\n    address npm;\\n    address treasury;\\n    address priceOracle;\\n    uint256 coverCreationFee;\\n    uint256 minCoverCreationStake;\\n    uint256 minStakeToAddLiquidity;\\n    uint256 firstReportingStake;\\n    uint256 claimPeriod;\\n    uint256 reportingBurnRate;\\n    uint256 governanceReporterCommission;\\n    uint256 claimPlatformFee;\\n    uint256 claimReporterCommission;\\n    uint256 flashLoanFee;\\n    uint256 flashLoanFeeProtocol;\\n    uint256 resolutionCoolDownPeriod;\\n    uint256 stateUpdateInterval;\\n    uint256 maxLendingRatio;\\n    uint256 lendingPeriod;\\n    uint256 withdrawalWindow;\\n    uint256 policyFloor;\\n    uint256 policyCeiling;\\n  }\\n\\n  event Initialized(InitializeArgs args);\\n  event ContractAdded(bytes32 indexed namespace, bytes32 indexed key, address indexed contractAddress);\\n  event ContractUpgraded(bytes32 indexed namespace, bytes32 indexed key, address previous, address indexed current);\\n  event MemberAdded(address member);\\n  event MemberRemoved(address member);\\n\\n  function addContract(bytes32 namespace, address contractAddress) external;\\n\\n  function addContracts(\\n    bytes32[] calldata namespaces,\\n    bytes32[] calldata keys,\\n    address[] calldata contractAddresses\\n  ) external;\\n\\n  function addContractWithKey(\\n    bytes32 namespace,\\n    bytes32 coverKey,\\n    address contractAddress\\n  ) external;\\n\\n  function initialize(InitializeArgs calldata args) external;\\n\\n  function upgradeContract(\\n    bytes32 namespace,\\n    address previous,\\n    address current\\n  ) external;\\n\\n  function upgradeContractWithKey(\\n    bytes32 namespace,\\n    bytes32 coverKey,\\n    address previous,\\n    address current\\n  ) external;\\n\\n  function addMember(address member) external;\\n\\n  function removeMember(address member) external;\\n\\n  function grantRoles(AccountWithRoles[] calldata detail) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRecoverable.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IStore.sol\\\";\\n\\ninterface IRecoverable {\\n  function s() external view returns (IStore);\\n\\n  function recoverEther(address sendTo) external;\\n\\n  function recoverToken(address token, address sendTo) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReporter.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IReporter {\\n  event Reported(bytes32 indexed coverKey, bytes32 indexed productKey, address reporter, uint256 indexed incidentDate, string info, uint256 initialStake, uint256 resolutionTimestamp);\\n  event Disputed(bytes32 indexed coverKey, bytes32 indexed productKey, address reporter, uint256 indexed incidentDate, string info, uint256 initialStake);\\n\\n  event ReportingBurnRateSet(uint256 previous, uint256 current);\\n  event FirstReportingStakeSet(bytes32 coverKey, uint256 previous, uint256 current);\\n  event ReporterCommissionSet(uint256 previous, uint256 current);\\n\\n  function report(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    string calldata info,\\n    uint256 stake\\n  ) external;\\n\\n  function dispute(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    string calldata info,\\n    uint256 stake\\n  ) external;\\n\\n  function getActiveIncidentDate(bytes32 coverKey, bytes32 productKey) external view returns (uint256);\\n\\n  function getAttestation(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address who,\\n    uint256 incidentDate\\n  ) external view returns (uint256 myStake, uint256 totalStake);\\n\\n  function getRefutation(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address who,\\n    uint256 incidentDate\\n  ) external view returns (uint256 myStake, uint256 totalStake);\\n\\n  function getReporter(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external view returns (address);\\n\\n  function getResolutionTimestamp(bytes32 coverKey, bytes32 productKey) external view returns (uint256);\\n\\n  function setFirstReportingStake(bytes32 coverKey, uint256 value) external;\\n\\n  function getFirstReportingStake(bytes32 coverKey) external view returns (uint256);\\n\\n  function setReportingBurnRate(uint256 value) external;\\n\\n  function setReporterCommission(uint256 value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStore.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IStore {\\n  event PausersSet(address indexed addedBy, address[] accounts, bool[] statuses);\\n\\n  function setPausers(address[] calldata accounts, bool[] calldata statuses) external;\\n\\n  function setAddress(bytes32 k, address v) external;\\n\\n  function setAddressBoolean(\\n    bytes32 k,\\n    address a,\\n    bool v\\n  ) external;\\n\\n  function setUint(bytes32 k, uint256 v) external;\\n\\n  function addUint(bytes32 k, uint256 v) external;\\n\\n  function subtractUint(bytes32 k, uint256 v) external;\\n\\n  function setUints(bytes32 k, uint256[] calldata v) external;\\n\\n  function setString(bytes32 k, string calldata v) external;\\n\\n  function setBytes(bytes32 k, bytes calldata v) external;\\n\\n  function setBool(bytes32 k, bool v) external;\\n\\n  function setInt(bytes32 k, int256 v) external;\\n\\n  function setBytes32(bytes32 k, bytes32 v) external;\\n\\n  function setAddressArrayItem(bytes32 k, address v) external;\\n\\n  function setBytes32ArrayItem(bytes32 k, bytes32 v) external;\\n\\n  function deleteAddress(bytes32 k) external;\\n\\n  function deleteUint(bytes32 k) external;\\n\\n  function deleteUints(bytes32 k) external;\\n\\n  function deleteString(bytes32 k) external;\\n\\n  function deleteBytes(bytes32 k) external;\\n\\n  function deleteBool(bytes32 k) external;\\n\\n  function deleteInt(bytes32 k) external;\\n\\n  function deleteBytes32(bytes32 k) external;\\n\\n  function deleteAddressArrayItem(bytes32 k, address v) external;\\n\\n  function deleteBytes32ArrayItem(bytes32 k, bytes32 v) external;\\n\\n  function deleteAddressArrayItemByIndex(bytes32 k, uint256 i) external;\\n\\n  function deleteBytes32ArrayItemByIndex(bytes32 k, uint256 i) external;\\n\\n  function getAddressValues(bytes32[] calldata keys) external view returns (address[] memory values);\\n\\n  function getAddress(bytes32 k) external view returns (address);\\n\\n  function getAddressBoolean(bytes32 k, address a) external view returns (bool);\\n\\n  function getUintValues(bytes32[] calldata keys) external view returns (uint256[] memory values);\\n\\n  function getUint(bytes32 k) external view returns (uint256);\\n\\n  function getUints(bytes32 k) external view returns (uint256[] memory);\\n\\n  function getString(bytes32 k) external view returns (string memory);\\n\\n  function getBytes(bytes32 k) external view returns (bytes memory);\\n\\n  function getBool(bytes32 k) external view returns (bool);\\n\\n  function getInt(bytes32 k) external view returns (int256);\\n\\n  function getBytes32(bytes32 k) external view returns (bytes32);\\n\\n  function countAddressArrayItems(bytes32 k) external view returns (uint256);\\n\\n  function countBytes32ArrayItems(bytes32 k) external view returns (uint256);\\n\\n  function getAddressArray(bytes32 k) external view returns (address[] memory);\\n\\n  function getBytes32Array(bytes32 k) external view returns (bytes32[] memory);\\n\\n  function getAddressArrayItemPosition(bytes32 k, address toFind) external view returns (uint256);\\n\\n  function getBytes32ArrayItemPosition(bytes32 k, bytes32 toFind) external view returns (uint256);\\n\\n  function getAddressArrayItemByIndex(bytes32 k, uint256 i) external view returns (address);\\n\\n  function getBytes32ArrayItemByIndex(bytes32 k, uint256 i) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUnstakable.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IStore.sol\\\";\\n\\ninterface IUnstakable {\\n  struct UnstakeInfoType {\\n    uint256 totalStakeInWinningCamp;\\n    uint256 totalStakeInLosingCamp;\\n    uint256 myStakeInWinningCamp;\\n    uint256 toBurn;\\n    uint256 toReporter;\\n    uint256 myReward;\\n    uint256 unstaken;\\n  }\\n\\n  event Unstaken(bytes32 indexed coverKey, bytes32 indexed productKey, address indexed caller, uint256 originalStake, uint256 reward);\\n  event ReporterRewardDistributed(bytes32 indexed coverKey, bytes32 indexed productKey, address caller, address indexed reporter, uint256 originalReward, uint256 reporterReward);\\n  event GovernanceBurned(bytes32 indexed coverKey, bytes32 indexed productKey, address caller, address indexed burner, uint256 originalReward, uint256 burnedAmount);\\n\\n  function unstake(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external;\\n\\n  function unstakeWithClaim(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external;\\n\\n  function getUnstakeInfoFor(\\n    address account,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external view returns (UnstakeInfoType memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVault.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IMember.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IVault is IMember, IERC20 {\\n  struct VaultInfoType {\\n    uint256 totalPods;\\n    uint256 balance;\\n    uint256 extendedBalance;\\n    uint256 totalReassurance;\\n    uint256 myPodBalance;\\n    uint256 myShare;\\n    uint256 withdrawalOpen;\\n    uint256 withdrawalClose;\\n  }\\n\\n  struct AddLiquidityArgs {\\n    /// @dev Enter the cover key\\n    bytes32 coverKey;\\n    /// @dev Enter the amount of liquidity token to supply.\\n    uint256 amount;\\n    /// @dev Enter the amount of NPM token to stake. Will be locked for a minimum window of one withdrawal period.\\n    uint256 npmStakeToAdd;\\n    /// @dev Enter referral code\\n    bytes32 referralCode;\\n  }\\n\\n  event GovernanceTransfer(address indexed to, uint256 amount);\\n  event StrategyTransfer(address indexed token, address indexed strategy, bytes32 indexed name, uint256 amount);\\n  event StrategyReceipt(address indexed token, address indexed strategy, bytes32 indexed name, uint256 amount, uint256 income, uint256 loss);\\n  event PodsIssued(address indexed account, uint256 issued, uint256 liquidityAdded, bytes32 indexed referralCode);\\n  event PodsRedeemed(address indexed account, uint256 redeemed, uint256 liquidityReleased);\\n  event FlashLoanBorrowed(address indexed lender, address indexed borrower, address indexed stablecoin, uint256 amount, uint256 fee);\\n  event NpmStaken(address indexed account, uint256 amount);\\n  event NpmUnstaken(address indexed account, uint256 amount);\\n  event InterestAccrued(bytes32 indexed coverKey);\\n  event Entered(bytes32 indexed coverKey, address indexed account);\\n  event Exited(bytes32 indexed coverKey, address indexed account);\\n\\n  function key() external view returns (bytes32);\\n\\n  function sc() external view returns (address);\\n\\n  /**\\n   * @dev Adds liquidity to the specified cover contract\\n   */\\n  function addLiquidity(AddLiquidityArgs calldata args) external;\\n\\n  function accrueInterest() external;\\n\\n  /**\\n   * @dev Removes liquidity from the specified cover contract\\n   * @param coverKey Enter the cover key\\n   * @param amount Enter the amount of liquidity token to remove.\\n   * @param npmStake Enter the amount of NPM stake to remove.\\n   * @param exit Indicates NPM stake exit.\\n   */\\n  function removeLiquidity(\\n    bytes32 coverKey,\\n    uint256 amount,\\n    uint256 npmStake,\\n    bool exit\\n  ) external;\\n\\n  /**\\n   * @dev Transfers liquidity to governance contract.\\n   * @param coverKey Enter the cover key\\n   * @param to Enter the destination account\\n   * @param amount Enter the amount of liquidity token to transfer.\\n   */\\n  function transferGovernance(\\n    bytes32 coverKey,\\n    address to,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @dev Transfers liquidity to strategy contract.\\n   * @param coverKey Enter the cover key\\n   * @param strategyName Enter the strategy's name\\n   * @param amount Enter the amount of liquidity token to transfer.\\n   */\\n  function transferToStrategy(\\n    IERC20 token,\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @dev Receives from strategy contract.\\n   * @param coverKey Enter the cover key\\n   * @param strategyName Enter the strategy's name\\n   * @param amount Enter the amount of liquidity token to transfer.\\n   */\\n  function receiveFromStrategy(\\n    IERC20 token,\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    uint256 amount\\n  ) external;\\n\\n  function calculatePods(uint256 forStablecoinUnits) external view returns (uint256);\\n\\n  function calculateLiquidity(uint256 podsToBurn) external view returns (uint256);\\n\\n  function getInfo(address forAccount) external view returns (VaultInfoType memory info);\\n\\n  /**\\n   * @dev Returns the stablecoin balance of this vault\\n   * This also includes amounts lent out in lending strategies\\n   */\\n  function getStablecoinBalanceOf() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultFactory.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"./IStore.sol\\\";\\nimport \\\"./IMember.sol\\\";\\n\\ninterface IVaultFactory is IMember {\\n  event VaultDeployed(address vault, bytes32 indexed coverKey, string name, string symbol);\\n\\n  function deploy(\\n    bytes32 coverKey,\\n    string calldata name,\\n    string calldata symbol\\n  ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWitness.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IWitness {\\n  event Attested(bytes32 indexed coverKey, bytes32 indexed productKey, address witness, uint256 indexed incidentDate, uint256 stake);\\n  event Refuted(bytes32 indexed coverKey, bytes32 indexed productKey, address witness, uint256 indexed incidentDate, uint256 stake);\\n\\n  function attest(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    uint256 stake\\n  ) external;\\n\\n  function refute(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    uint256 stake\\n  ) external;\\n\\n  function getStatus(bytes32 coverKey, bytes32 productKey) external view returns (uint256);\\n\\n  function isCoverNormal(bytes32 coverKey) external view returns (bool);\\n\\n  function getStakes(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external view returns (uint256, uint256);\\n\\n  function getStakesOf(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    address account\\n  ) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AccessControlLibV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\n/* solhint-disable ordering  */\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/access/IAccessControl.sol\\\";\\nimport \\\"./ProtoUtilV1.sol\\\";\\n\\nlibrary AccessControlLibV1 {\\n  using ProtoUtilV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n\\n  bytes32 public constant NS_ROLES_ADMIN = 0x00; // SAME AS \\\"DEFAULT_ADMIN_ROLE\\\"\\n  bytes32 public constant NS_ROLES_COVER_MANAGER = \\\"role:cover:manager\\\";\\n  bytes32 public constant NS_ROLES_LIQUIDITY_MANAGER = \\\"role:liquidity:manager\\\";\\n  bytes32 public constant NS_ROLES_GOVERNANCE_AGENT = \\\"role:governance:agent\\\";\\n  bytes32 public constant NS_ROLES_GOVERNANCE_ADMIN = \\\"role:governance:admin\\\";\\n  bytes32 public constant NS_ROLES_UPGRADE_AGENT = \\\"role:upgrade:agent\\\";\\n  bytes32 public constant NS_ROLES_RECOVERY_AGENT = \\\"role:recovery:agent\\\";\\n  bytes32 public constant NS_ROLES_PAUSE_AGENT = \\\"role:pause:agent\\\";\\n  bytes32 public constant NS_ROLES_UNPAUSE_AGENT = \\\"role:unpause:agent\\\";\\n\\n  /**\\n   * @dev Reverts if the sender is not the protocol admin.\\n   */\\n  function mustBeAdmin(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_ADMIN, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the cover manager.\\n   */\\n  function mustBeCoverManager(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_COVER_MANAGER, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the liquidity manager.\\n   */\\n  function mustBeLiquidityManager(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_LIQUIDITY_MANAGER, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not a governance agent.\\n   */\\n  function mustBeGovernanceAgent(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_GOVERNANCE_AGENT, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not a governance admin.\\n   */\\n  function mustBeGovernanceAdmin(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_GOVERNANCE_ADMIN, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not an upgrade agent.\\n   */\\n  function mustBeUpgradeAgent(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_UPGRADE_AGENT, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not a recovery agent.\\n   */\\n  function mustBeRecoveryAgent(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_RECOVERY_AGENT, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the pause agent.\\n   */\\n  function mustBePauseAgent(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_PAUSE_AGENT, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the unpause agent.\\n   */\\n  function mustBeUnpauseAgent(IStore s) external view {\\n    _mustHaveAccess(s, NS_ROLES_UNPAUSE_AGENT, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not the protocol admin.\\n   */\\n  function callerMustBeAdmin(IStore s, address caller) external view {\\n    _mustHaveAccess(s, NS_ROLES_ADMIN, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not the cover manager.\\n   */\\n  function callerMustBeCoverManager(IStore s, address caller) external view {\\n    _mustHaveAccess(s, NS_ROLES_COVER_MANAGER, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not the liquidity manager.\\n   */\\n  function callerMustBeLiquidityManager(IStore s, address caller) external view {\\n    _mustHaveAccess(s, NS_ROLES_LIQUIDITY_MANAGER, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not a governance agent.\\n   */\\n  function callerMustBeGovernanceAgent(IStore s, address caller) external view {\\n    _mustHaveAccess(s, NS_ROLES_GOVERNANCE_AGENT, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not a governance admin.\\n   */\\n  function callerMustBeGovernanceAdmin(IStore s, address caller) external view {\\n    _mustHaveAccess(s, NS_ROLES_GOVERNANCE_ADMIN, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not an upgrade agent.\\n   */\\n  function callerMustBeUpgradeAgent(IStore s, address caller) public view {\\n    _mustHaveAccess(s, NS_ROLES_UPGRADE_AGENT, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not a recovery agent.\\n   */\\n  function callerMustBeRecoveryAgent(IStore s, address caller) external view {\\n    _mustHaveAccess(s, NS_ROLES_RECOVERY_AGENT, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not the pause agent.\\n   */\\n  function callerMustBePauseAgent(IStore s, address caller) external view {\\n    _mustHaveAccess(s, NS_ROLES_PAUSE_AGENT, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is not the unpause agent.\\n   */\\n  function callerMustBeUnpauseAgent(IStore s, address caller) external view {\\n    _mustHaveAccess(s, NS_ROLES_UNPAUSE_AGENT, caller);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller does not have access to the given role.\\n   */\\n  function _mustHaveAccess(\\n    IStore s,\\n    bytes32 role,\\n    address caller\\n  ) private view {\\n    require(hasAccessInternal(s, role, caller), \\\"Forbidden\\\");\\n  }\\n\\n  /**\\n   * @dev Checks if a given user has access to the given role\\n   * @param role Specify the role name\\n   * @param user Enter the user account\\n   * @return Returns true if the user is a member of the specified role\\n   */\\n  function hasAccessInternal(\\n    IStore s,\\n    bytes32 role,\\n    address user\\n  ) public view returns (bool) {\\n    address protocol = s.getProtocolAddressInternal();\\n\\n    // The protocol is not deployed yet. Therefore, no role to check\\n    if (protocol == address(0)) {\\n      return false;\\n    }\\n\\n    // You must have the same role in the protocol contract if you're don't have this role here\\n    return IAccessControl(protocol).hasRole(role, user);\\n  }\\n\\n  /**\\n   * @dev Adds a protocol member contract\\n   *\\n   * @custom:suppress-address-trust-issue This feature can only be accessed internally within the protocol.\\n   *\\n   * @param s Enter the store instance\\n   * @param namespace Enter the contract namespace\\n   * @param key Enter the contract key\\n   * @param contractAddress Enter the contract address\\n   */\\n  function addContractInternal(\\n    IStore s,\\n    bytes32 namespace,\\n    bytes32 key,\\n    address contractAddress\\n  ) external {\\n    // Not only the msg.sender needs to be an upgrade agent\\n    // but the contract using this library (and this function)\\n    // must also be an upgrade agent\\n    callerMustBeUpgradeAgent(s, address(this));\\n    _addContract(s, namespace, key, contractAddress);\\n  }\\n\\n  function _addContract(\\n    IStore s,\\n    bytes32 namespace,\\n    bytes32 key,\\n    address contractAddress\\n  ) private {\\n    if (key > 0) {\\n      s.setAddressByKeys(ProtoUtilV1.NS_CONTRACTS, namespace, key, contractAddress);\\n    } else {\\n      s.setAddressByKeys(ProtoUtilV1.NS_CONTRACTS, namespace, contractAddress);\\n    }\\n    _addMember(s, contractAddress);\\n  }\\n\\n  function _deleteContract(\\n    IStore s,\\n    bytes32 namespace,\\n    bytes32 key,\\n    address contractAddress\\n  ) private {\\n    if (key > 0) {\\n      s.deleteAddressByKeys(ProtoUtilV1.NS_CONTRACTS, namespace, key);\\n    } else {\\n      s.deleteAddressByKeys(ProtoUtilV1.NS_CONTRACTS, namespace);\\n    }\\n    _removeMember(s, contractAddress);\\n  }\\n\\n  /**\\n   * @dev Upgrades a contract at the given namespace and key.\\n   *\\n   * The previous contract's protocol membership is revoked and\\n   * the current immediately starts assuming responsibility of\\n   * whatever the contract needs to do at the supplied namespace and key.\\n   *\\n   * @custom:warning Warning:\\n   *\\n   * This feature is only accessible to an upgrade agent.\\n   * Since adding member to the protocol is a highly risky activity,\\n   * the role `Upgrade Agent` is considered to be one of the most `Critical` roles.\\n   *\\n   * @custom:suppress-address-trust-issue This feature can only be accessed internally within the protocol.\\n   *\\n   * @param s Provide store instance\\n   * @param namespace Enter a unique namespace for this contract\\n   * @param key Enter a key if this contract has siblings\\n   * @param previous Enter the existing contract address at this namespace and key.\\n   * @param current Enter the contract address which will replace the previous contract.\\n   */\\n  function upgradeContractInternal(\\n    IStore s,\\n    bytes32 namespace,\\n    bytes32 key,\\n    address previous,\\n    address current\\n  ) external {\\n    // Not only the msg.sender needs to be an upgrade agent\\n    // but the contract using this library (and this function)\\n    // must also be an upgrade agent\\n    callerMustBeUpgradeAgent(s, address(this));\\n\\n    bool isMember = s.isProtocolMemberInternal(previous);\\n    require(isMember, \\\"Not a protocol member\\\");\\n\\n    _deleteContract(s, namespace, key, previous);\\n    _addContract(s, namespace, key, current);\\n  }\\n\\n  /**\\n   * @dev Adds member to the protocol\\n   *\\n   * A member is a trusted EOA or a contract that was added to the protocol using `addContract`\\n   * function. When a contract is removed using `upgradeContract` function, the membership of previous\\n   * contract is also removed.\\n   *\\n   * @custom:warning Warning:\\n   *\\n   * This feature is only accessible to an upgrade agent.\\n   * Since adding member to the protocol is a highly risky activity,\\n   * the role `Upgrade Agent` is considered to be one of the most `Critical` roles.\\n   *\\n   * @custom:suppress-address-trust-issue This feature can only be accessed internally within the protocol.\\n   *\\n   * @param member Enter an address to add as a protocol member\\n   */\\n  function addMemberInternal(IStore s, address member) external {\\n    // Not only the msg.sender needs to be an upgrade agent\\n    // but the contract using this library (and this function)\\n    // must also be an upgrade agent\\n    callerMustBeUpgradeAgent(s, address(this));\\n\\n    _addMember(s, member);\\n  }\\n\\n  /**\\n   * @dev Removes a member from the protocol. This function is only accessible\\n   * to an upgrade agent.\\n   *\\n   * @custom:suppress-address-trust-issue This feature can only be accessed internally within the protocol.\\n   *\\n   * @param member Enter an address to remove as a protocol member\\n   */\\n  function removeMemberInternal(IStore s, address member) external {\\n    // Not only the msg.sender needs to be an upgrade agent\\n    // but the contract using this library (and this function)\\n    // must also be an upgrade agent\\n    callerMustBeUpgradeAgent(s, address(this));\\n\\n    _removeMember(s, member);\\n  }\\n\\n  function _addMember(IStore s, address member) private {\\n    require(s.getBoolByKeys(ProtoUtilV1.NS_MEMBERS, member) == false, \\\"Already exists\\\");\\n    s.setBoolByKeys(ProtoUtilV1.NS_MEMBERS, member, true);\\n  }\\n\\n  function _removeMember(IStore s, address member) private {\\n    s.deleteBoolByKeys(ProtoUtilV1.NS_MEMBERS, member);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BaseLibV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\n/* solhint-disable ordering  */\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../interfaces/IProtocol.sol\\\";\\nimport \\\"../interfaces/IPausable.sol\\\";\\n\\nlibrary BaseLibV1 {\\n  using SafeERC20 for IERC20;\\n\\n  /**\\n   * @dev Recover all Ether held by the contract.\\n   * On success, no event is emitted because the recovery feature does\\n   * not have any significance in the SDK or the UI.\\n   */\\n  function recoverEtherInternal(address sendTo) external {\\n    // slither-disable-next-line low-level-calls\\n    (bool success, ) = payable(sendTo).call{value: address(this).balance}(\\\"\\\"); // solhint-disable-line avoid-low-level-calls\\n    require(success, \\\"Recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Recover all IERC-20 compatible tokens sent to this address.\\n   * On success, no event is emitted because the recovery feature does\\n   * not have any significance in the SDK or the UI.\\n   *\\n   * @custom:suppress-malicious-erc Risk tolerable. Although the token can't be trusted, the recovery agent has to check the token code manually.\\n   * @custom:suppress-address-trust-issue Risk tolerable. Although the token can't be trusted, the recovery agent has to check the token code manually.\\n   *\\n   * @param token IERC-20 The address of the token contract\\n   */\\n  function recoverTokenInternal(address token, address sendTo) external {\\n    IERC20 erc20 = IERC20(token);\\n\\n    uint256 balance = erc20.balanceOf(address(this));\\n\\n    if (balance > 0) {\\n      // slither-disable-next-line unchecked-transfer\\n      erc20.safeTransfer(sendTo, balance);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/CoverUtilV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../dependencies/BokkyPooBahsDateTimeLibrary.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"../interfaces/ICxToken.sol\\\";\\nimport \\\"../interfaces/IERC20Detailed.sol\\\";\\nimport \\\"./StrategyLibV1.sol\\\";\\n\\nlibrary CoverUtilV1 {\\n  using ProtoUtilV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n  using StrategyLibV1 for IStore;\\n\\n  uint256 public constant REASSURANCE_WEIGHT_FALLBACK_VALUE = 8000;\\n  uint256 public constant COVER_LAG_FALLBACK_VALUE = 1 days;\\n\\n  enum ProductStatus {\\n    Normal,\\n    Stopped,\\n    IncidentHappened,\\n    FalseReporting,\\n    Claimable\\n  }\\n\\n  /**\\n   * @dev Returns the given cover's owner.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getCoverOwnerInternal(IStore s, bytes32 coverKey) external view returns (address) {\\n    return s.getAddressByKeys(ProtoUtilV1.NS_COVER_OWNER, coverKey);\\n  }\\n\\n  /**\\n   * @dev Returns cover creation fee information.\\n   * @param s Specify store instance\\n   *\\n   * @return fee Returns the amount of NPM tokens you need to pay to create a new cover\\n   * @return minCoverCreationStake Returns the amount of NPM tokens you need to stake to create a new cover\\n   * @return minStakeToAddLiquidity Returns the amount of NPM tokens you need to stake to add liquidity\\n   *\\n   */\\n  function getCoverCreationFeeInfoInternal(IStore s)\\n    external\\n    view\\n    returns (\\n      uint256 fee,\\n      uint256 minCoverCreationStake,\\n      uint256 minStakeToAddLiquidity\\n    )\\n  {\\n    fee = s.getUintByKey(ProtoUtilV1.NS_COVER_CREATION_FEE);\\n    minCoverCreationStake = getMinCoverCreationStakeInternal(s);\\n    minStakeToAddLiquidity = getMinStakeToAddLiquidityInternal(s);\\n  }\\n\\n  /**\\n   * @dev Returns minimum NPM stake to create a new cover.\\n   * @param s Specify store instance\\n   */\\n  function getMinCoverCreationStakeInternal(IStore s) public view returns (uint256) {\\n    return s.getUintByKey(ProtoUtilV1.NS_COVER_CREATION_MIN_STAKE);\\n  }\\n\\n  /**\\n   * @dev Returns a cover's creation date\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getCoverCreationDateInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\\n    return s.getUintByKeys(ProtoUtilV1.NS_COVER_CREATION_DATE, coverKey);\\n  }\\n\\n  /**\\n   * @dev Returns minimum NPM stake to add liquidity.\\n   * @param s Specify store instance\\n   */\\n  function getMinStakeToAddLiquidityInternal(IStore s) public view returns (uint256) {\\n    return s.getUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_MIN_STAKE);\\n  }\\n\\n  /**\\n   * @dev Gets claim period/duration of the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getClaimPeriodInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\\n    uint256 fromKey = s.getUintByKeys(ProtoUtilV1.NS_CLAIM_PERIOD, coverKey);\\n    uint256 fallbackValue = s.getUintByKey(ProtoUtilV1.NS_CLAIM_PERIOD);\\n\\n    return fromKey > 0 ? fromKey : fallbackValue;\\n  }\\n\\n  /**\\n   * @dev Returns a summary of the given cover pool.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   */\\n  function getCoverPoolSummaryInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view returns (IPolicy.CoverPoolSummaryType memory summary) {\\n    uint256 precision = s.getStablecoinPrecisionInternal();\\n\\n    summary.totalAmountInPool = s.getStablecoinOwnedByVaultInternal(coverKey); // precision: stablecoin\\n    summary.totalCommitment = getActiveLiquidityUnderProtectionInternal(s, coverKey, productKey, precision); // <-- adjusted precision\\n    summary.reassuranceAmount = getReassuranceAmountInternal(s, coverKey); // precision: stablecoin\\n    summary.reassurancePoolWeight = getReassuranceWeightInternal(s, coverKey);\\n    summary.productCount = s.countBytes32ArrayByKeys(ProtoUtilV1.NS_COVER_PRODUCT, coverKey);\\n    summary.leverage = s.getUintByKeys(ProtoUtilV1.NS_COVER_LEVERAGE_FACTOR, coverKey);\\n    summary.productCapitalEfficiency = s.getUintByKeys(ProtoUtilV1.NS_COVER_PRODUCT_EFFICIENCY, coverKey, productKey);\\n  }\\n\\n  /**\\n   * @dev Gets the reassurance weight of a given cover key.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param s Provide store instance\\n   * @param coverKey Enter the cover for which you want to obtain the reassurance weight for.\\n   *\\n   * @return If reassurance weight value wasn't set for the specified cover pool,\\n   * the global value will be returned.\\n   *\\n   * If global value, too, isn't available, a fallback value of `REASSURANCE_WEIGHT_FALLBACK_VALUE`\\n   * is returned.\\n   *\\n   */\\n  function getReassuranceWeightInternal(IStore s, bytes32 coverKey) public view returns (uint256) {\\n    uint256 setForTheCoverPool = s.getUintByKey(getReassuranceWeightKeyInternal(coverKey));\\n\\n    if (setForTheCoverPool > 0) {\\n      return setForTheCoverPool;\\n    }\\n\\n    // Globally set value: not set for any specific cover\\n    uint256 setGlobally = s.getUintByKey(getReassuranceWeightKeyInternal(0));\\n\\n    if (setGlobally > 0) {\\n      return setGlobally;\\n    }\\n\\n    return REASSURANCE_WEIGHT_FALLBACK_VALUE;\\n  }\\n\\n  /**\\n   * @dev Gets the reassurance amount of the specified cover contract\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter the cover key\\n   *\\n   */\\n  function getReassuranceAmountInternal(IStore s, bytes32 coverKey) public view returns (uint256) {\\n    return s.getUintByKey(getReassuranceKeyInternal(coverKey));\\n  }\\n\\n  /**\\n   * @dev Returns reassurance rate of the specified cover key.\\n   * When a cover is finalized after claims payout, a portion\\n   * of the reassurance fund (if available) is transferred to the cover liquidity pool.\\n   *\\n   * If the reassurance rate is 25%, either 25% of the reassurance pool\\n   * or 25% of the suffered loss is transferred prior to finalization, whichever is less.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param s Specify store\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getReassuranceRateInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\\n    uint256 rate = s.getUintByKey(getReassuranceRateKeyInternal(coverKey));\\n\\n    if (rate > 0) {\\n      return rate;\\n    }\\n\\n    // Default: 25%\\n    return 2500;\\n  }\\n\\n  /**\\n   * @dev Hash key of the reassurance for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getReassuranceKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_REASSURANCE, coverKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the reassurance rate for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getReassuranceRateKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_REASSURANCE_RATE, coverKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the reassurance weight for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getReassuranceWeightKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_REASSURANCE_WEIGHT, coverKey));\\n  }\\n\\n  /**\\n   * @dev Indicates whether the specified cover and all associated products are \\\"normal\\\".\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @return Returns false if any associated product isn't normal.\\n   *\\n   */\\n  function isCoverNormalInternal(IStore s, bytes32 coverKey) external view returns (bool) {\\n    uint256 incidentDate;\\n\\n    bool supportsProducts = supportsProductsInternal(s, coverKey);\\n\\n    if (supportsProducts == false) {\\n      incidentDate = getActiveIncidentDateInternal(s, coverKey, ProtoUtilV1.PRODUCT_KEY_INTENTIONALLY_EMPTY);\\n      return getProductStatusOfInternal(s, coverKey, ProtoUtilV1.PRODUCT_KEY_INTENTIONALLY_EMPTY, incidentDate) == ProductStatus.Normal;\\n    }\\n\\n    bytes32[] memory products = _getProducts(s, coverKey);\\n\\n    for (uint256 i = 0; i < products.length; i++) {\\n      incidentDate = getActiveIncidentDateInternal(s, coverKey, products[i]);\\n      bool isNormal = getProductStatusOfInternal(s, coverKey, products[i], incidentDate) == ProductStatus.Normal;\\n\\n      if (!isNormal) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Gets product status of the given cover product.\\n   *\\n   *\\n   * 0 - normal\\n   * 1 - stopped, can not purchase covers or add liquidity\\n   * 2 - reporting, incident happened\\n   * 3 - reporting, false reporting\\n   * 4 - claimable, claims accepted for payout\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function getProductStatusInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view returns (ProductStatus) {\\n    uint256 incidentDate = getActiveIncidentDateInternal(s, coverKey, productKey);\\n    return getProductStatusOfInternal(s, coverKey, productKey, incidentDate);\\n  }\\n\\n  /**\\n   * @dev Returns current status a given cover product as `ProductStatus`.\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function getProductStatusOfInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view returns (ProductStatus) {\\n    uint256 value = s.getUintByKey(getProductStatusOfKeyInternal(coverKey, productKey, incidentDate));\\n    return ProductStatus(value);\\n  }\\n\\n  /**\\n   * @dev Hash key of the product status of (the given cover, product, and incident date)\\n   * for historical significance. This must not be reset during finalization.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getProductStatusOfKeyInternal(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_STATUS, coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Hash key of the stakes (collectively added by liquidity providers) of the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getCoverLiquidityStakeKeyInternal(bytes32 coverKey) external pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_LIQUIDITY_STAKE, coverKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the last stablecoin deposit of the given cover.\\n   * There must be a couple of block heights as an offset\\n   * before withdrawal can be performed (even during a withdrawal window).\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getLastDepositHeightKeyInternal(bytes32 coverKey) external pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_VAULT_DEPOSIT_HEIGHTS, coverKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the individual stake (added by an LP) for the given cover and account.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param account Enter the account to obtain the hash key\\n   *\\n   */\\n  function getCoverLiquidityStakeIndividualKeyInternal(bytes32 coverKey, address account) external pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_LIQUIDITY_STAKE, coverKey, account));\\n  }\\n\\n  /**\\n   * @dev Hash key of the blacklisted accounts for the given cover.\\n   * Blacklisted accounts are forbidden to receive claims payout.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter the trigger incident date\\n   *\\n   */\\n  function getBlacklistKeyInternal(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_CLAIM_BLACKLIST, coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Returns the total liquidity committed/under active protection.\\n   * If the cover is a diversified pool, returns sum total of all products' commitments.\\n   *\\n   * Simply put, commitments are the \\\"totalSupply\\\" of cxTokens that haven't yet expired.\\n   * Note that cxTokens can be precise to 18 decimal places.\\n   * If the protocol's stablecoin has a different precision,\\n   * you must tell this function explicitly when you call it.\\n   *\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param precision Specify the protocol stablecoin precision.\\n   *\\n   */\\n  function getTotalLiquidityUnderProtectionInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    uint256 precision\\n  ) external view returns (uint256 total) {\\n    bool supportsProducts = supportsProductsInternal(s, coverKey);\\n\\n    if (supportsProducts == false) {\\n      return getActiveLiquidityUnderProtectionInternal(s, coverKey, ProtoUtilV1.PRODUCT_KEY_INTENTIONALLY_EMPTY, precision);\\n    }\\n\\n    bytes32[] memory products = _getProducts(s, coverKey);\\n\\n    for (uint256 i = 0; i < products.length; i++) {\\n      total += getActiveLiquidityUnderProtectionInternal(s, coverKey, products[i], precision);\\n    }\\n  }\\n\\n  function _getProducts(IStore s, bytes32 coverKey) private view returns (bytes32[] memory products) {\\n    return s.getBytes32ArrayByKeys(ProtoUtilV1.NS_COVER_PRODUCT, coverKey);\\n  }\\n\\n  /**\\n   * @dev Returns the total liquidity committed/under active protection.\\n   * If the cover is a diversified pool, you must a provide product key.\\n   *\\n   * Simply put, commitments are the \\\"totalSupply\\\" of cxTokens that haven't yet expired.\\n   * Note that cxTokens are precise to 18 decimal places.\\n   * If the protocol's stablecoin has a different precision,\\n   * you must tell this function explicitly when you call it.\\n   *\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param adjustPrecision Specify the protocol stablecoin precision.\\n   *\\n   */\\n  function getActiveLiquidityUnderProtectionInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 adjustPrecision\\n  ) public view returns (uint256 total) {\\n    (uint256 current, uint256 expiryDate) = _getCurrentCommitment(s, coverKey, productKey);\\n    uint256 future = _getFutureCommitments(s, coverKey, productKey, expiryDate);\\n\\n    total = current + future;\\n\\n    // @caution:\\n    // Adjusting precision results in truncation and data loss.\\n    //\\n    // Can also open a can of worms if the protocol stablecoin\\n    // address needs to be updated in the future.\\n    total = (total * adjustPrecision) / ProtoUtilV1.CXTOKEN_PRECISION;\\n  }\\n\\n  /**\\n   * @dev Gets current commitment of a given cover product.\\n   *\\n   * <br /> <br />\\n   *\\n   * If there is no incident, should return zero.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   * @return amount The current commitment amount.\\n   * @return expiryDate The time at which the commitment `amount` expires.\\n   *\\n   */\\n  function _getCurrentCommitment(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) private view returns (uint256 amount, uint256 expiryDate) {\\n    uint256 incidentDateIfAny = getActiveIncidentDateInternal(s, coverKey, productKey);\\n\\n    // There isn't any incident for this cover\\n    // and therefore no need to pay\\n    if (incidentDateIfAny == 0) {\\n      return (0, 0);\\n    }\\n\\n    expiryDate = _getMonthEndDate(incidentDateIfAny);\\n    ICxToken cxToken = ICxToken(getCxTokenByExpiryDateInternal(s, coverKey, productKey, expiryDate));\\n\\n    if (address(cxToken) != address(0)) {\\n      amount = cxToken.totalSupply();\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets future commitment of a given cover product.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param excludedExpiryDate Enter expiry date (from current commitment) to exclude\\n   *\\n   * @return sum The total commitment amount.\\n   *\\n   */\\n  function _getFutureCommitments(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 excludedExpiryDate\\n  ) private view returns (uint256 sum) {\\n    for (uint256 i = 0; i <= ProtoUtilV1.MAX_POLICY_DURATION; i++) {\\n      uint256 expiryDate = _getNextMonthEndDate(block.timestamp, i); // solhint-disable-line\\n\\n      if (expiryDate == excludedExpiryDate || expiryDate <= block.timestamp) {\\n        // solhint-disable-previous-line\\n        continue;\\n      }\\n\\n      ICxToken cxToken = ICxToken(getCxTokenByExpiryDateInternal(s, coverKey, productKey, expiryDate));\\n\\n      if (address(cxToken) != address(0)) {\\n        sum += cxToken.totalSupply();\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Sets the current status of a given cover\\n   *\\n   * 0 - normal\\n   * 1 - stopped, can not purchase covers or add liquidity\\n   * 2 - reporting, incident happened\\n   * 3 - reporting, false reporting\\n   * 4 - claimable, claims accepted for payout\\n   *\\n   */\\n  function setStatusInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    ProductStatus status\\n  ) external {\\n    s.setUintByKey(getProductStatusOfKeyInternal(coverKey, productKey, incidentDate), uint256(status));\\n  }\\n\\n  /**\\n   * @dev Gets the expiry date based on cover duration\\n   * @param today Enter the current timestamp\\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\\n   */\\n  function getExpiryDateInternal(uint256 today, uint256 coverDuration) external pure returns (uint256) {\\n    // Get the day of the month\\n    (, , uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(today);\\n\\n    // Cover duration of 1 month means current month\\n    // unless today is the 25th calendar day or later\\n    uint256 monthToAdd = coverDuration - 1;\\n\\n    if (day >= 25) {\\n      // Add one month\\n      monthToAdd += 1;\\n    }\\n\\n    return _getNextMonthEndDate(today, monthToAdd);\\n  }\\n\\n  // function _getPreviousMonthEndDate(uint256 date, uint256 monthsToSubtract) private pure returns (uint256) {\\n  //   uint256 pastDate = BokkyPooBahsDateTimeLibrary.subMonths(date, monthsToSubtract);\\n  //   return _getMonthEndDate(pastDate);\\n  // }\\n\\n  function _getNextMonthEndDate(uint256 date, uint256 monthsToAdd) private pure returns (uint256) {\\n    uint256 futureDate = BokkyPooBahsDateTimeLibrary.addMonths(date, monthsToAdd);\\n    return _getMonthEndDate(futureDate);\\n  }\\n\\n  function _getMonthEndDate(uint256 date) private pure returns (uint256) {\\n    // Get the year and month from the date\\n    (uint256 year, uint256 month, ) = BokkyPooBahsDateTimeLibrary.timestampToDate(date);\\n\\n    // Count the total number of days of that month and year\\n    uint256 daysInMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);\\n\\n    // Get the month end date\\n    return BokkyPooBahsDateTimeLibrary.timestampFromDateTime(year, month, daysInMonth, 23, 59, 59);\\n  }\\n\\n  /**\\n   * @dev Returns the given cover product's cxToken by its expiry date (if available).\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param expiryDate Enter cxToken's expiry date\\n   *\\n   */\\n  function getCxTokenByExpiryDateInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 expiryDate\\n  ) public view returns (address cxToken) {\\n    bytes32 k = keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_CXTOKEN, coverKey, productKey, expiryDate));\\n    cxToken = s.getAddress(k);\\n  }\\n\\n  function checkIfProductRequiresWhitelistInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view returns (bool) {\\n    return s.getBoolByKeys(ProtoUtilV1.NS_COVER_REQUIRES_WHITELIST, coverKey, productKey);\\n  }\\n\\n  function checkIfRequiresWhitelistInternal(IStore s, bytes32 coverKey) external view returns (bool) {\\n    return s.getBoolByKeys(ProtoUtilV1.NS_COVER_REQUIRES_WHITELIST, coverKey);\\n  }\\n\\n  function supportsProductsInternal(IStore s, bytes32 coverKey) public view returns (bool) {\\n    return s.getBoolByKeys(ProtoUtilV1.NS_COVER_SUPPORTS_PRODUCTS, coverKey);\\n  }\\n\\n  function isValidProductInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view returns (bool) {\\n    return s.getBoolByKeys(ProtoUtilV1.NS_COVER_PRODUCT, coverKey, productKey);\\n  }\\n\\n  function isActiveProductInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view returns (bool) {\\n    return s.getUintByKeys(ProtoUtilV1.NS_COVER_PRODUCT, coverKey, productKey) == 1;\\n  }\\n\\n  function disablePolicyInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    bool status\\n  ) external {\\n    bytes32 key = getPolicyDisabledKeyInternal(coverKey, productKey);\\n    s.setBoolByKey(key, status);\\n  }\\n\\n  function isPolicyDisabledInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view returns (bool) {\\n    bytes32 key = getPolicyDisabledKeyInternal(coverKey, productKey);\\n    return s.getBoolByKey(key);\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"disabled policy flag\\\" for the given cover product.\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function getPolicyDisabledKeyInternal(bytes32 coverKey, bytes32 productKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_POLICY_DISABLED, coverKey, productKey));\\n  }\\n\\n  /**\\n   * @dev Gets the latest and \\\"active\\\" incident date of a cover product.\\n   * Note that after \\\"resolve\\\" is invoked, incident date is reset.\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   */\\n  function getActiveIncidentDateInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view returns (uint256) {\\n    return s.getUintByKeys(ProtoUtilV1.NS_GOVERNANCE_REPORTING_INCIDENT_DATE, coverKey, productKey);\\n  }\\n\\n  function getCoverageLagInternal(IStore s, bytes32 coverKey) internal view returns (uint256) {\\n    uint256 custom = s.getUintByKeys(ProtoUtilV1.NS_COVERAGE_LAG, coverKey);\\n\\n    // Custom means set for this exact cover\\n    if (custom > 0) {\\n      return custom;\\n    }\\n\\n    // Global means set for all covers (without specifying a cover key)\\n    uint256 global = s.getUintByKey(ProtoUtilV1.NS_COVERAGE_LAG);\\n\\n    if (global > 0) {\\n      return global;\\n    }\\n\\n    // Fallback means the default option\\n    return COVER_LAG_FALLBACK_VALUE;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/GovernanceUtilV1.sol\": {\r\n      \"content\": \"/* solhint-disable function-max-lines */\\n// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"../interfaces/IPolicy.sol\\\";\\nimport \\\"../interfaces/ICoverStake.sol\\\";\\nimport \\\"../interfaces/IUnstakable.sol\\\";\\nimport \\\"../interfaces/ICoverReassurance.sol\\\";\\nimport \\\"../interfaces/IVault.sol\\\";\\nimport \\\"../interfaces/IVaultFactory.sol\\\";\\nimport \\\"./RoutineInvokerLibV1.sol\\\";\\n\\nlibrary GovernanceUtilV1 {\\n  using CoverUtilV1 for IStore;\\n  using RoutineInvokerLibV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n\\n  /**\\n   * @dev Gets the reporting period for the given cover.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   *\\n   */\\n  function getReportingPeriodInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\\n    return s.getUintByKeys(ProtoUtilV1.NS_GOVERNANCE_REPORTING_PERIOD, coverKey);\\n  }\\n\\n  /**\\n   * @dev Gets the NPM stake burn rate (upon resolution) for the given cover.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   *\\n   */\\n  function getReportingBurnRateInternal(IStore s) public view returns (uint256) {\\n    return s.getUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_BURN_RATE);\\n  }\\n\\n  /**\\n   * @dev Gets the \\\"valid\\\" reporter's NPM commission rate\\n   * (upon each unstake claim invoked by individual \\\"valid\\\" stakers)\\n   * for the given cover.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   *\\n   */\\n  function getGovernanceReporterCommissionInternal(IStore s) public view returns (uint256) {\\n    return s.getUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTER_COMMISSION);\\n  }\\n\\n  /**\\n   * @dev Gets the protocol's NPM commission rate\\n   * (upon each unstake claim invoked by individual \\\"valid\\\" stakers)\\n   * for the given cover.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   *\\n   */\\n  function getPlatformCoverFeeRateInternal(IStore s) external view returns (uint256) {\\n    return s.getUintByKey(ProtoUtilV1.NS_COVER_PLATFORM_FEE);\\n  }\\n\\n  /**\\n   * @dev Gets the \\\"valid\\\" reporter's stablecoin commission rate\\n   * on protocol's earnings (upon each claim payout received by claimants)\\n   * for the given cover.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   *\\n   */\\n  function getClaimReporterCommissionInternal(IStore s) external view returns (uint256) {\\n    return s.getUintByKey(ProtoUtilV1.NS_CLAIM_REPORTER_COMMISSION);\\n  }\\n\\n  /**\\n   * @dev Gets the minimum units of NPM tokens required to report the supplied cover.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getMinReportingStakeInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\\n    uint256 fb = s.getUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_MIN_FIRST_STAKE);\\n    uint256 custom = s.getUintByKeys(ProtoUtilV1.NS_GOVERNANCE_REPORTING_MIN_FIRST_STAKE, coverKey);\\n\\n    return custom > 0 ? custom : fb;\\n  }\\n\\n  /**\\n   * @dev Gets a cover's resolution timestamp.\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function getResolutionTimestampInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view returns (uint256) {\\n    return s.getUintByKeys(ProtoUtilV1.NS_GOVERNANCE_RESOLUTION_TS, coverKey, productKey);\\n  }\\n\\n  /**\\n   * @dev Gets the given cover incident's reporter.\\n   * Note that this keeps changing between \\\"first reporter\\\"\\n   * and \\\"candidate reporter\\\" until resolution is achieved.\\n   *\\n   * <br /> <br />\\n   *\\n   * [Read More](https://docs.neptunemutual.com/covers/cover-reporting)\\n   *\\n   * <br /> <br />\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function getReporterInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external view returns (address) {\\n    CoverUtilV1.ProductStatus status = s.getProductStatusOfInternal(coverKey, productKey, incidentDate);\\n    bool incidentHappened = status == CoverUtilV1.ProductStatus.IncidentHappened || status == CoverUtilV1.ProductStatus.Claimable;\\n    bytes32 prefix = incidentHappened ? ProtoUtilV1.NS_GOVERNANCE_REPORTING_WITNESS_YES : ProtoUtilV1.NS_GOVERNANCE_REPORTING_WITNESS_NO;\\n\\n    return s.getAddressByKeys(prefix, coverKey, productKey);\\n  }\\n\\n  /**\\n   * @dev Returns stakes of the given cover product's incident.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getStakesInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view returns (uint256 yes, uint256 no) {\\n    yes = s.getUintByKey(_getIncidentOccurredStakesKey(coverKey, productKey, incidentDate));\\n    no = s.getUintByKey(_getFalseReportingStakesKey(coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Hash key of the reporter for the given cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function _getReporterKey(bytes32 coverKey, bytes32 productKey) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_REPORTING_WITNESS_YES, coverKey, productKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the stakes added under `Incident Happened` camp for the given cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function _getIncidentOccurredStakesKey(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_REPORTING_WITNESS_YES, coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Hash key of the claims payout given for the supplied cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function _getClaimPayoutsKey(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_CLAIM_PAYOUTS, coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Hash key of the reassurance payout granted for the supplied cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function _getReassurancePayoutKey(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_REASSURANCE_PAYOUT, coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Hash key of an individual's stakes added under `Incident Happened` camp for the given cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function _getIndividualIncidentOccurredStakeKey(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    address account\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_REPORTING_STAKE_OWNED_YES, coverKey, productKey, incidentDate, account));\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"candidate reporter\\\" for the supplied cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function _getDisputerKey(bytes32 coverKey, bytes32 productKey) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_REPORTING_WITNESS_NO, coverKey, productKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the stakes added under `False Reporting` camp for the given cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function _getFalseReportingStakesKey(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_REPORTING_WITNESS_NO, coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Hash key of an individual's stakes added under `False Reporting` camp for the given cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function _getIndividualFalseReportingStakeKey(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    address account\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_REPORTING_STAKE_OWNED_NO, coverKey, productKey, incidentDate, account));\\n  }\\n\\n  /**\\n   * @dev Returns stakes of the given account for a cover product's incident.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param account Specify the account to get stakes\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getStakesOfInternal(\\n    IStore s,\\n    address account,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view returns (uint256 yes, uint256 no) {\\n    yes = s.getUintByKey(_getIndividualIncidentOccurredStakeKey(coverKey, productKey, incidentDate, account));\\n    no = s.getUintByKey(_getIndividualFalseReportingStakeKey(coverKey, productKey, incidentDate, account));\\n  }\\n\\n  /**\\n   * @dev Returns resolution info of the given account\\n   * for a cover product's incident.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param account Specify the account to get stakes\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   * @param totalStakeInWinningCamp Total NPM tokens in currently \\\"winning\\\" camp.\\n   * @param totalStakeInLosingCamp Total NPM tokens in currently \\\"losing\\\" camp.\\n   * @param myStakeInWinningCamp Your NPM tokens in the \\\"winning\\\" camp.\\n   *\\n   */\\n  function getResolutionInfoForInternal(\\n    IStore s,\\n    address account,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  )\\n    public\\n    view\\n    returns (\\n      uint256 totalStakeInWinningCamp,\\n      uint256 totalStakeInLosingCamp,\\n      uint256 myStakeInWinningCamp\\n    )\\n  {\\n    (uint256 yes, uint256 no) = getStakesInternal(s, coverKey, productKey, incidentDate);\\n    (uint256 myYes, uint256 myNo) = getStakesOfInternal(s, account, coverKey, productKey, incidentDate);\\n\\n    CoverUtilV1.ProductStatus decision = s.getProductStatusOfInternal(coverKey, productKey, incidentDate);\\n    bool incidentHappened = decision == CoverUtilV1.ProductStatus.IncidentHappened || decision == CoverUtilV1.ProductStatus.Claimable;\\n\\n    totalStakeInWinningCamp = incidentHappened ? yes : no;\\n    totalStakeInLosingCamp = incidentHappened ? no : yes;\\n    myStakeInWinningCamp = incidentHappened ? myYes : myNo;\\n  }\\n\\n  /**\\n   * @dev Returns unstake info of the given account\\n   * for a cover product's incident.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param account Specify the account to get stakes\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getUnstakeInfoForInternal(\\n    IStore s,\\n    address account,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external view returns (IUnstakable.UnstakeInfoType memory info) {\\n    (info.totalStakeInWinningCamp, info.totalStakeInLosingCamp, info.myStakeInWinningCamp) = getResolutionInfoForInternal(s, account, coverKey, productKey, incidentDate);\\n\\n    info.unstaken = getReportingUnstakenAmountInternal(s, account, coverKey, productKey, incidentDate);\\n    require(info.myStakeInWinningCamp > 0, \\\"Nothing to unstake\\\");\\n\\n    uint256 rewardRatio = (info.myStakeInWinningCamp * ProtoUtilV1.MULTIPLIER) / info.totalStakeInWinningCamp;\\n\\n    uint256 reward = 0;\\n\\n    // Incident dates are reset when a reporting is finalized.\\n    // This check ensures only the people who come to unstake\\n    // before the finalization will receive rewards\\n    if (s.getActiveIncidentDateInternal(coverKey, productKey) == incidentDate) {\\n      // slither-disable-next-line divide-before-multiply\\n      reward = (info.totalStakeInLosingCamp * rewardRatio) / ProtoUtilV1.MULTIPLIER;\\n    }\\n\\n    require(getReportingBurnRateInternal(s) + getGovernanceReporterCommissionInternal(s) <= ProtoUtilV1.MULTIPLIER, \\\"Invalid configuration\\\");\\n\\n    info.toBurn = (reward * getReportingBurnRateInternal(s)) / ProtoUtilV1.MULTIPLIER;\\n    info.toReporter = (reward * getGovernanceReporterCommissionInternal(s)) / ProtoUtilV1.MULTIPLIER;\\n    info.myReward = reward - info.toBurn - info.toReporter;\\n  }\\n\\n  /**\\n   * @dev Returns NPM already unstaken by the specified account for a cover incident.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param account Specify the account to get stakes\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getReportingUnstakenAmountInternal(\\n    IStore s,\\n    address account,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view returns (uint256) {\\n    bytes32 k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKEN, coverKey, productKey, incidentDate, account));\\n    return s.getUintByKey(k);\\n  }\\n\\n  function updateUnstakeDetailsInternal(\\n    IStore s,\\n    address account,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    uint256 originalStake,\\n    uint256 reward,\\n    uint256 burned,\\n    uint256 reporterFee\\n  ) external {\\n    // Unstake timestamp of the account\\n    bytes32 k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKE_TS, coverKey, productKey, incidentDate, account));\\n    s.setUintByKey(k, block.timestamp); // solhint-disable-line\\n\\n    // Last unstake timestamp\\n    k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKE_TS, coverKey, productKey, incidentDate));\\n    s.setUintByKey(k, block.timestamp); // solhint-disable-line\\n\\n    // ---------------------------------------------------------------------\\n\\n    // Amount unstaken by the account\\n    k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKEN, coverKey, productKey, incidentDate, account));\\n    s.setUintByKey(k, originalStake);\\n\\n    // Amount unstaken by everyone\\n    k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKEN, coverKey, productKey, incidentDate));\\n    s.addUintByKey(k, originalStake);\\n\\n    // ---------------------------------------------------------------------\\n\\n    if (reward > 0) {\\n      // Reward received by the account\\n      k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKE_REWARD, coverKey, productKey, incidentDate, account));\\n      s.setUintByKey(k, reward);\\n\\n      // Total reward received\\n      k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKE_REWARD, coverKey, productKey, incidentDate));\\n      s.addUintByKey(k, reward);\\n    }\\n\\n    // ---------------------------------------------------------------------\\n\\n    if (burned > 0) {\\n      // Total burned\\n      k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKE_BURNED, coverKey, productKey, incidentDate));\\n      s.addUintByKey(k, burned);\\n    }\\n\\n    if (reporterFee > 0) {\\n      // Total fee paid to the final reporter\\n      k = keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_UNSTAKE_REPORTER_FEE, coverKey, productKey, incidentDate));\\n      s.addUintByKey(k, reporterFee);\\n    }\\n  }\\n\\n  function _updateProductStatusBeforeResolutionInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) private {\\n    require(incidentDate > 0, \\\"Invalid incident date\\\");\\n\\n    uint256 yes = s.getUintByKey(_getIncidentOccurredStakesKey(coverKey, productKey, incidentDate));\\n    uint256 no = s.getUintByKey(_getFalseReportingStakesKey(coverKey, productKey, incidentDate));\\n\\n    if (no > yes) {\\n      s.setStatusInternal(coverKey, productKey, incidentDate, CoverUtilV1.ProductStatus.FalseReporting);\\n      return;\\n    }\\n\\n    s.setStatusInternal(coverKey, productKey, incidentDate, CoverUtilV1.ProductStatus.IncidentHappened);\\n  }\\n\\n  /**\\n   * @dev Adds attestation to an incident report\\n   *\\n   * @custom:suppress-address-trust-issue The address `who` can be trusted here because we are not treating it like a contract.\\n   *\\n   */\\n  function addAttestationInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address who,\\n    uint256 incidentDate,\\n    uint256 stake\\n  ) external {\\n    mustNotExceedNpmThreshold(stake);\\n\\n    // Add individual stake of the reporter\\n    s.addUintByKey(_getIndividualIncidentOccurredStakeKey(coverKey, productKey, incidentDate, who), stake);\\n\\n    // All \\\"incident happened\\\" camp witnesses combined\\n    uint256 currentStake = s.getUintByKey(_getIncidentOccurredStakesKey(coverKey, productKey, incidentDate));\\n\\n    // No has reported yet, this is the first report\\n    if (currentStake == 0) {\\n      s.setAddressByKey(_getReporterKey(coverKey, productKey), who);\\n    }\\n\\n    s.addUintByKey(_getIncidentOccurredStakesKey(coverKey, productKey, incidentDate), stake);\\n    _updateProductStatusBeforeResolutionInternal(s, coverKey, productKey, incidentDate);\\n\\n    s.updateStateAndLiquidityInternal(coverKey);\\n  }\\n\\n  /**\\n   * @dev Returns sum total of NPM staken under `Incident Happened` camp.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param who Specify the account to get attestation info\\n   * @param incidentDate Enter incident date\\n   *\\n   * @param myStake The total NPM amount (under incident happened or yes) you have staken for this trigger incident.\\n   * @param totalStake The total NPM amount (under incident happened or yes) staken by all tokenholders.\\n   *\\n   */\\n  function getAttestationInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address who,\\n    uint256 incidentDate\\n  ) external view returns (uint256 myStake, uint256 totalStake) {\\n    myStake = s.getUintByKey(_getIndividualIncidentOccurredStakeKey(coverKey, productKey, incidentDate, who));\\n    totalStake = s.getUintByKey(_getIncidentOccurredStakesKey(coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Adds refutation to an incident report\\n   *\\n   * @custom:suppress-address-trust-issue The address `who` can be trusted here because we are not treating it like a contract.\\n   *\\n   */\\n  function addRefutationInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address who,\\n    uint256 incidentDate,\\n    uint256 stake\\n  ) external {\\n    mustNotExceedNpmThreshold(stake);\\n\\n    s.addUintByKey(_getIndividualFalseReportingStakeKey(coverKey, productKey, incidentDate, who), stake);\\n\\n    uint256 currentStake = s.getUintByKey(_getFalseReportingStakesKey(coverKey, productKey, incidentDate));\\n\\n    if (currentStake == 0) {\\n      // The first reporter who disputed\\n      s.setAddressByKey(_getDisputerKey(coverKey, productKey), who);\\n      s.setBoolByKey(getHasDisputeKeyInternal(coverKey, productKey), true);\\n    }\\n\\n    s.addUintByKey(_getFalseReportingStakesKey(coverKey, productKey, incidentDate), stake);\\n    _updateProductStatusBeforeResolutionInternal(s, coverKey, productKey, incidentDate);\\n\\n    s.updateStateAndLiquidityInternal(coverKey);\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"has dispute flag\\\" for the specified cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function getHasDisputeKeyInternal(bytes32 coverKey, bytes32 productKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_REPORTING_HAS_A_DISPUTE, coverKey, productKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"has finalized flag\\\" for the specified cover product.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getHasFinalizedKeyInternal(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_GOVERNANCE_REPORTING_FINALIZATION, coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Returns sum total of NPM staken under `False Reporting` camp.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param who Specify the account to get attestation info\\n   * @param incidentDate Enter incident date\\n   *\\n   * @param myStake The total NPM amount (under false reporting or no) you have staken for this trigger incident.\\n   * @param totalStake The total NPM amount (under false reporting or no) staken by all tokenholders.\\n   *\\n   */\\n  function getRefutationInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address who,\\n    uint256 incidentDate\\n  ) external view returns (uint256 myStake, uint256 totalStake) {\\n    myStake = s.getUintByKey(_getIndividualFalseReportingStakeKey(coverKey, productKey, incidentDate, who));\\n    totalStake = s.getUintByKey(_getFalseReportingStakesKey(coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Returns cooldown period. Cooldown period is a defense\\n   * against [collusion and last-block attacks](https://docs.neptunemutual.com/covers/cover-reporting#collusion-and-last-block-attacks).\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getCoolDownPeriodInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\\n    uint256 fromKey = s.getUintByKeys(ProtoUtilV1.NS_RESOLUTION_COOL_DOWN_PERIOD, coverKey);\\n    uint256 fallbackValue = s.getUintByKey(ProtoUtilV1.NS_RESOLUTION_COOL_DOWN_PERIOD);\\n\\n    return fromKey > 0 ? fromKey : fallbackValue;\\n  }\\n\\n  /**\\n   * @dev The date and time prior to which a governance administrator\\n   * may still initiate a \\\"emergency resolution.\\\"\\n   *\\n   * Warning: this function does not validate the cover and product key supplied.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   *\\n   */\\n  function getResolutionDeadlineInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view returns (uint256) {\\n    return s.getUintByKeys(ProtoUtilV1.NS_RESOLUTION_DEADLINE, coverKey, productKey);\\n  }\\n\\n  function addClaimPayoutsInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    uint256 claimed\\n  ) external {\\n    s.addUintByKey(_getClaimPayoutsKey(coverKey, productKey, incidentDate), claimed);\\n  }\\n\\n  /**\\n   * @dev Returns the total amount of payouts awarded to claimants for this incident.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getClaimPayoutsInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view returns (uint256) {\\n    return s.getUintByKey(_getClaimPayoutsKey(coverKey, productKey, incidentDate));\\n  }\\n\\n  /**\\n   * @dev Returns the total amount of reassurance granted to vault for this incident.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getReassurancePayoutInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view returns (uint256) {\\n    return s.getUintByKey(_getReassurancePayoutKey(coverKey, productKey, incidentDate));\\n  }\\n\\n  function addReassurancePayoutInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate,\\n    uint256 capitalized\\n  ) external {\\n    s.addUintByKey(_getReassurancePayoutKey(coverKey, productKey, incidentDate), capitalized);\\n  }\\n\\n  /**\\n   * @dev Returns the remaining reassurance amount that can be transferred\\n   * to the vault following the claim period but prior to finalisation.\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param s Specify store instance\\n   * @param coverKey Enter cover key\\n   * @param productKey Enter product key\\n   * @param incidentDate Enter incident date\\n   *\\n   */\\n  function getReassuranceTransferrableInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external view returns (uint256) {\\n    uint256 reassuranceRate = s.getReassuranceRateInternal(coverKey);\\n    uint256 available = s.getReassuranceAmountInternal(coverKey);\\n    uint256 reassurancePaid = getReassurancePayoutInternal(s, coverKey, productKey, incidentDate);\\n\\n    uint256 totalReassurance = available + reassurancePaid;\\n\\n    uint256 claimsPaid = getClaimPayoutsInternal(s, coverKey, productKey, incidentDate);\\n\\n    uint256 principal = claimsPaid <= totalReassurance ? claimsPaid : totalReassurance;\\n    uint256 transferAmount = (principal * reassuranceRate) / ProtoUtilV1.MULTIPLIER;\\n\\n    return transferAmount - reassurancePaid;\\n  }\\n\\n  function mustNotExceedNpmThreshold(uint256 amount) public pure {\\n    require(amount <= ProtoUtilV1.MAX_NPM_STAKE * 1 ether, \\\"NPM stake is above threshold\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NTransferUtilV2.sol\": {\r\n      \"content\": \"/* solhint-disable */\\n\\n// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary NTransferUtilV2 {\\n  using SafeERC20 for IERC20;\\n\\n  /**\\n   *\\n   * @dev Ensures approval of ERC20-like token\\n   * @custom:suppress-malicious-erc The address `malicious` can't be trusted and therefore we are ensuring that it does not act funny.\\n   * @custom:suppress-address-trust-issue The address `malicious` can't be trusted and therefore we are ensuring that it does not act funny.\\n   *\\n   */\\n  function ensureApproval(\\n    IERC20 malicious,\\n    address spender,\\n    uint256 amount\\n  ) external {\\n    require(address(malicious) != address(0), \\\"Invalid token address\\\");\\n    require(spender != address(0), \\\"Invalid spender\\\");\\n    require(amount > 0, \\\"Invalid transfer amount\\\");\\n\\n    malicious.safeIncreaseAllowance(spender, amount);\\n  }\\n\\n  /**\\n   * @dev Ensures transfer of ERC20-like token\\n   *\\n   * @custom:suppress-malicious-erc The address `malicious` can't be trusted and therefore we are ensuring that it does not act funny.\\n   * @custom:suppress-address-trust-issue The address `malicious` can't be trusted and therefore we are ensuring that it does not act funny.\\n   * The address `recipient` can be trusted as we're not treating (or calling) it as a contract.\\n   *\\n   */\\n  function ensureTransfer(\\n    IERC20 malicious,\\n    address recipient,\\n    uint256 amount\\n  ) external {\\n    require(address(malicious) != address(0), \\\"Invalid token address\\\");\\n    require(recipient != address(0), \\\"Spender can't be zero\\\");\\n    require(amount > 0, \\\"Invalid transfer amount\\\");\\n\\n    uint256 balanceBeforeTransfer = malicious.balanceOf(recipient);\\n    malicious.safeTransfer(recipient, amount);\\n    uint256 balanceAfterTransfer = malicious.balanceOf(recipient);\\n\\n    // @suppress-subtraction\\n    uint256 actualTransferAmount = balanceAfterTransfer - balanceBeforeTransfer;\\n\\n    require(actualTransferAmount == amount, \\\"Invalid transfer\\\");\\n  }\\n\\n  /**\\n   * @dev Ensures transferFrom of ERC20-like token\\n   *\\n   * @custom:suppress-malicious-erc The address `malicious` can't be trusted and therefore we are ensuring that it does not act funny.\\n   * @custom:suppress-address-trust-issue The address `malicious` can't be trusted and therefore we are ensuring that it does not act funny.\\n   * The address `recipient` can be trusted as we're not treating (or calling) it as a contract.\\n   *\\n   */\\n  function ensureTransferFrom(\\n    IERC20 malicious,\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external {\\n    require(address(malicious) != address(0), \\\"Invalid token address\\\");\\n    require(sender != address(0), \\\"Invalid sender\\\");\\n    require(recipient != address(0), \\\"Invalid recipient\\\");\\n    require(amount > 0, \\\"Invalid transfer amount\\\");\\n\\n    uint256 balanceBeforeTransfer = malicious.balanceOf(recipient);\\n    malicious.safeTransferFrom(sender, recipient, amount);\\n    uint256 balanceAfterTransfer = malicious.balanceOf(recipient);\\n\\n    // @suppress-subtraction\\n    uint256 actualTransferAmount = balanceAfterTransfer - balanceBeforeTransfer;\\n\\n    require(actualTransferAmount == amount, \\\"Invalid transfer\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PolicyHelperV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/ICxToken.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"../interfaces/IERC20Detailed.sol\\\";\\nimport \\\"./NTransferUtilV2.sol\\\";\\nimport \\\"./RoutineInvokerLibV1.sol\\\";\\n\\nlibrary PolicyHelperV1 {\\n  using CoverUtilV1 for IStore;\\n  using NTransferUtilV2 for IERC20;\\n  using ProtoUtilV1 for IStore;\\n  using RegistryLibV1 for IStore;\\n  using RoutineInvokerLibV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n\\n  struct CalculatePolicyFeeArgs {\\n    bytes32 coverKey;\\n    bytes32 productKey;\\n    uint256 coverDuration;\\n    uint256 amountToCover;\\n  }\\n\\n  function calculatePolicyFeeInternal(IStore s, CalculatePolicyFeeArgs memory args) public view returns (IPolicy.CoverFeeInfoType memory policyFee) {\\n    (policyFee.floor, policyFee.ceiling) = getPolicyRatesInternal(s, args.coverKey);\\n    (uint256 availableLiquidity, uint256 commitment, uint256 reassuranceFund) = _getCoverPoolAmounts(s, args.coverKey, args.productKey);\\n\\n    require(args.amountToCover > 0, \\\"Please enter an amount\\\");\\n    require(args.coverDuration > 0 && args.coverDuration <= ProtoUtilV1.MAX_POLICY_DURATION, \\\"Invalid duration\\\");\\n    require(policyFee.floor > 0 && policyFee.ceiling > policyFee.floor, \\\"Policy rate config error\\\");\\n\\n    require(availableLiquidity - commitment > args.amountToCover, \\\"Insufficient fund\\\");\\n\\n    policyFee.totalAvailableLiquidity = availableLiquidity + reassuranceFund;\\n    policyFee.utilizationRatio = (ProtoUtilV1.MULTIPLIER * (commitment + args.amountToCover)) / policyFee.totalAvailableLiquidity;\\n\\n    // console.log(\\\"[sc] s: %s, p: %s, u: %s\\\", availableLiquidity, reassuranceFund, policyFee.utilizationRatio);\\n    // console.log(\\\"[sc] c: %s, a: %s, t: %s\\\", commitment, args.amountToCover, policyFee.totalAvailableLiquidity);\\n\\n    policyFee.rate = policyFee.utilizationRatio > policyFee.floor ? policyFee.utilizationRatio : policyFee.floor;\\n\\n    policyFee.rate = policyFee.rate + (args.coverDuration * 100);\\n\\n    if (policyFee.rate > policyFee.ceiling) {\\n      policyFee.rate = policyFee.ceiling;\\n    }\\n\\n    uint256 expiryDate = CoverUtilV1.getExpiryDateInternal(block.timestamp, args.coverDuration); // solhint-disable-line\\n    uint256 effectiveFrom = getEODInternal(block.timestamp + s.getCoverageLagInternal(args.coverKey)); // solhint-disable-line\\n    uint256 daysCovered = BokkyPooBahsDateTimeLibrary.diffDays(effectiveFrom, expiryDate);\\n\\n    policyFee.fee = (args.amountToCover * policyFee.rate * daysCovered) / (365 * ProtoUtilV1.MULTIPLIER);\\n  }\\n\\n  function getPolicyFeeInternal(IStore s, CalculatePolicyFeeArgs memory args) public view returns (uint256 fee, uint256 platformFee) {\\n    IPolicy.CoverFeeInfoType memory coverFeeInfo = calculatePolicyFeeInternal(s, args);\\n    fee = coverFeeInfo.fee;\\n\\n    uint256 rate = s.getUintByKey(ProtoUtilV1.NS_COVER_PLATFORM_FEE);\\n    platformFee = (fee * rate) / ProtoUtilV1.MULTIPLIER;\\n  }\\n\\n  function _getCoverPoolAmounts(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  )\\n    private\\n    view\\n    returns (\\n      uint256 availableLiquidity,\\n      uint256 commitment,\\n      uint256 reassuranceFund\\n    )\\n  {\\n    IPolicy.CoverPoolSummaryType memory summary = s.getCoverPoolSummaryInternal(coverKey, productKey);\\n\\n    availableLiquidity = summary.totalAmountInPool;\\n    commitment = summary.totalCommitment;\\n\\n    reassuranceFund = (summary.reassuranceAmount * summary.reassurancePoolWeight) / ProtoUtilV1.MULTIPLIER;\\n\\n    if (s.supportsProductsInternal(coverKey)) {\\n      require(summary.productCount > 0, \\\"Misconfigured or retired product\\\");\\n      availableLiquidity = (summary.totalAmountInPool * summary.leverage * summary.productCapitalEfficiency) / (summary.productCount * ProtoUtilV1.MULTIPLIER);\\n    }\\n  }\\n\\n  function getPolicyRatesInternal(IStore s, bytes32 coverKey) public view returns (uint256 floor, uint256 ceiling) {\\n    if (coverKey > 0) {\\n      floor = s.getUintByKeys(ProtoUtilV1.NS_COVER_POLICY_RATE_FLOOR, coverKey);\\n      ceiling = s.getUintByKeys(ProtoUtilV1.NS_COVER_POLICY_RATE_CEILING, coverKey);\\n    }\\n\\n    if (floor == 0) {\\n      // Fallback to default values\\n      floor = s.getUintByKey(ProtoUtilV1.NS_COVER_POLICY_RATE_FLOOR);\\n      ceiling = s.getUintByKey(ProtoUtilV1.NS_COVER_POLICY_RATE_CEILING);\\n    }\\n  }\\n\\n  function getCxTokenInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 coverDuration\\n  ) public view returns (address cxToken, uint256 expiryDate) {\\n    expiryDate = CoverUtilV1.getExpiryDateInternal(block.timestamp, coverDuration); // solhint-disable-line\\n    bytes32 k = keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_CXTOKEN, coverKey, productKey, expiryDate));\\n\\n    cxToken = s.getAddress(k);\\n  }\\n\\n  /**\\n   * @dev Gets the instance of cxToken or deploys a new one based on the cover expiry timestamp\\n   * @param coverKey Enter the cover key\\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\\n   */\\n  function getCxTokenOrDeployInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 coverDuration\\n  ) public returns (ICxToken) {\\n    (address cxToken, uint256 expiryDate) = getCxTokenInternal(s, coverKey, productKey, coverDuration);\\n\\n    if (cxToken != address(0)) {\\n      return ICxToken(cxToken);\\n    }\\n\\n    ICxTokenFactory factory = s.getCxTokenFactory();\\n    string memory tokenName = _getCxTokenName(coverKey, productKey, expiryDate);\\n\\n    cxToken = factory.deploy(coverKey, productKey, tokenName, expiryDate);\\n\\n    return ICxToken(cxToken);\\n  }\\n\\n  /**\\n   * @dev Returns month name of a given date\\n   */\\n  function _getMonthName(uint256 date) private pure returns (bytes3) {\\n    bytes3[13] memory m = [bytes3(0), \\\"jan\\\", \\\"feb\\\", \\\"mar\\\", \\\"apr\\\", \\\"may\\\", \\\"jun\\\", \\\"jul\\\", \\\"aug\\\", \\\"sep\\\", \\\"oct\\\", \\\"nov\\\", \\\"dec\\\"];\\n    uint256 month = BokkyPooBahsDateTimeLibrary.getMonth(date);\\n\\n    return m[month];\\n  }\\n\\n  /**\\n   * @dev Returns cxToken name from the supplied inputs.\\n   *\\n   * Format:\\n   *\\n   * For basket cover pool product\\n   * --> dex:uni:nov (cxUSD)\\n   *\\n   * For standalone cover pool\\n   * --> bal:nov (cxUSD)\\n   */\\n  function _getCxTokenName(\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 expiry\\n  ) private pure returns (string memory) {\\n    bytes3 month = _getMonthName(expiry);\\n\\n    if (productKey > 0) {\\n      return string(abi.encodePacked(string(abi.encodePacked(coverKey)), \\\":\\\", string(abi.encodePacked(productKey)), \\\":\\\", string(abi.encodePacked(month))));\\n    }\\n\\n    return string(abi.encodePacked(string(abi.encodePacked(coverKey)), \\\":\\\", string(abi.encodePacked(month))));\\n  }\\n\\n  /**\\n   *\\n   * @dev Purchase cover for the specified amount. <br /> <br />\\n   * When you purchase covers, you receive equal amount of cxTokens back.\\n   * You need the cxTokens to claim the cover when resolution occurs.\\n   * Each unit of cxTokens are fully redeemable at 1:1 ratio to the given\\n   * stablecoins (like wxDai, DAI, USDC, or BUSD) based on the chain.\\n   *\\n   * @custom:suppress-malicious-erc The ERC-20 `stablecoin` can't be manipulated via user input.\\n   *\\n   */\\n  function purchaseCoverInternal(\\n    IStore s,\\n    uint256 policyId,\\n    IPolicy.PurchaseCoverArgs calldata args\\n  )\\n    external\\n    returns (\\n      ICxToken cxToken,\\n      uint256 fee,\\n      uint256 platformFee\\n    )\\n  {\\n    CalculatePolicyFeeArgs memory policyFeeArgs = CalculatePolicyFeeArgs({coverKey: args.coverKey, productKey: args.productKey, coverDuration: args.coverDuration, amountToCover: args.amountToCover});\\n\\n    (fee, platformFee) = getPolicyFeeInternal(s, policyFeeArgs);\\n    require(fee > 0, \\\"Insufficient fee\\\");\\n    require(platformFee > 0, \\\"Insufficient platform fee\\\");\\n\\n    address stablecoin = s.getStablecoinAddressInternal();\\n    require(stablecoin != address(0), \\\"Cover liquidity uninitialized\\\");\\n\\n    IERC20(stablecoin).ensureTransferFrom(msg.sender, address(this), fee);\\n    IERC20(stablecoin).ensureTransfer(s.getVaultAddress(args.coverKey), fee - platformFee);\\n    IERC20(stablecoin).ensureTransfer(s.getTreasuryAddressInternal(), platformFee);\\n\\n    uint256 stablecoinPrecision = s.getStablecoinPrecisionInternal();\\n    uint256 toMint = (args.amountToCover * ProtoUtilV1.CXTOKEN_PRECISION) / stablecoinPrecision;\\n\\n    cxToken = getCxTokenOrDeployInternal(s, args.coverKey, args.productKey, args.coverDuration);\\n    cxToken.mint(policyId, args.coverKey, args.productKey, args.onBehalfOf, toMint);\\n\\n    s.updateStateAndLiquidityInternal(args.coverKey);\\n  }\\n\\n  /**\\n   * @dev Gets the EOD (End of Day) time\\n   */\\n  function getEODInternal(uint256 date) public pure returns (uint256) {\\n    (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(date);\\n    return BokkyPooBahsDateTimeLibrary.timestampFromDateTime(year, month, day, 23, 59, 59);\\n  }\\n\\n  /**\\n   * @dev Increases the \\\"last policy id\\\" and returns new id\\n   *\\n   */\\n  function incrementPolicyIdInternal(IStore s) external returns (uint256) {\\n    s.addUintByKey(ProtoUtilV1.NS_POLICY_LAST_PURCHASE_ID, 1);\\n\\n    return s.getUintByKey(ProtoUtilV1.NS_POLICY_LAST_PURCHASE_ID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PriceLibV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\n/* solhint-disable ordering  */\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"../interfaces/IPriceOracle.sol\\\";\\nimport \\\"../dependencies/uniswap-v2/IUniswapV2RouterLike.sol\\\";\\nimport \\\"../dependencies/uniswap-v2/IUniswapV2PairLike.sol\\\";\\nimport \\\"../dependencies/uniswap-v2/IUniswapV2FactoryLike.sol\\\";\\nimport \\\"./ProtoUtilV1.sol\\\";\\n\\nlibrary PriceLibV1 {\\n  using ProtoUtilV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n\\n  function getPriceOracleInternal(IStore s) public view returns (IPriceOracle) {\\n    return IPriceOracle(s.getNpmPriceOracleInternal());\\n  }\\n\\n  function setNpmPrice(IStore s) internal {\\n    IPriceOracle oracle = getPriceOracleInternal(s);\\n\\n    if (address(oracle) == address(0)) {\\n      return;\\n    }\\n\\n    oracle.update();\\n  }\\n\\n  function convertNpmLpUnitsToStabelcoinInternal(IStore s, uint256 amountIn) external view returns (uint256) {\\n    return getPriceOracleInternal(s).consultPair(amountIn);\\n  }\\n\\n  function getLastUpdatedOnInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\\n    bytes32 key = getLastUpdateKeyInternal(coverKey);\\n    return s.getUintByKey(key);\\n  }\\n\\n  function setLastUpdatedOnInternal(IStore s, bytes32 coverKey) external {\\n    bytes32 key = getLastUpdateKeyInternal(coverKey);\\n    s.setUintByKey(key, block.timestamp); // solhint-disable-line\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"last state update\\\" for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getLastUpdateKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LAST_LIQUIDITY_STATE_UPDATE, coverKey));\\n  }\\n\\n  function getNpmPriceInternal(IStore s, uint256 amountIn) external view returns (uint256) {\\n    return getPriceOracleInternal(s).consult(s.getNpmTokenAddressInternal(), amountIn);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ProtoUtilV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./StoreKeyUtil.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"../interfaces/IProtocol.sol\\\";\\nimport \\\"../interfaces/IERC20Detailed.sol\\\";\\n\\nlibrary ProtoUtilV1 {\\n  using StoreKeyUtil for IStore;\\n\\n  // Magic numbers\\n  uint256 public constant MAX_POLICY_DURATION = 3;\\n  bytes32 public constant KEY_INTENTIONALLY_EMPTY = 0;\\n  bytes32 public constant PRODUCT_KEY_INTENTIONALLY_EMPTY = 0;\\n  uint256 public constant MULTIPLIER = 10_000;\\n  uint256 public constant MIN_LIQUIDITY = 10;\\n  uint256 public constant MAX_LIQUIDITY = 10_000_000;\\n  uint256 public constant MIN_PROPOSAL_AMOUNT = 10;\\n  uint256 public constant MAX_PROPOSAL_AMOUNT = 10_000_000;\\n  uint256 public constant MAX_NPM_STAKE = 10_000_000;\\n  uint256 public constant NPM_PRECISION = 1 ether;\\n  uint256 public constant CXTOKEN_PRECISION = 1 ether;\\n  uint256 public constant POD_PRECISION = 1 ether;\\n\\n  /// @dev Protocol contract namespace\\n  bytes32 public constant CNS_CORE = \\\"cns:core\\\";\\n\\n  /// @dev The address of NPM token available in this blockchain\\n  bytes32 public constant CNS_NPM = \\\"cns:core:npm:instance\\\";\\n\\n  /// @dev Key prefix for creating a new cover product on chain\\n  bytes32 public constant CNS_COVER = \\\"cns:cover\\\";\\n\\n  bytes32 public constant CNS_UNISWAP_V2_ROUTER = \\\"cns:core:uni:v2:router\\\";\\n  bytes32 public constant CNS_UNISWAP_V2_FACTORY = \\\"cns:core:uni:v2:factory\\\";\\n  bytes32 public constant CNS_PRICE_DISCOVERY = \\\"cns:core:price:discovery\\\";\\n  bytes32 public constant CNS_TREASURY = \\\"cns:core:treasury\\\";\\n  bytes32 public constant CNS_NPM_PRICE_ORACLE = \\\"cns:core:npm:price:oracle\\\";\\n  bytes32 public constant CNS_COVER_REASSURANCE = \\\"cns:cover:reassurance\\\";\\n  bytes32 public constant CNS_POOL_BOND = \\\"cns:pool:bond\\\";\\n  bytes32 public constant CNS_COVER_POLICY = \\\"cns:cover:policy\\\";\\n  bytes32 public constant CNS_COVER_POLICY_MANAGER = \\\"cns:cover:policy:manager\\\";\\n  bytes32 public constant CNS_COVER_POLICY_ADMIN = \\\"cns:cover:policy:admin\\\";\\n  bytes32 public constant CNS_COVER_STAKE = \\\"cns:cover:stake\\\";\\n  bytes32 public constant CNS_COVER_VAULT = \\\"cns:cover:vault\\\";\\n  bytes32 public constant CNS_COVER_VAULT_DELEGATE = \\\"cns:cover:vault:delegate\\\";\\n  bytes32 public constant CNS_COVER_STABLECOIN = \\\"cns:cover:sc\\\";\\n  bytes32 public constant CNS_COVER_CXTOKEN_FACTORY = \\\"cns:cover:cxtoken:factory\\\";\\n  bytes32 public constant CNS_COVER_VAULT_FACTORY = \\\"cns:cover:vault:factory\\\";\\n  bytes32 public constant CNS_BOND_POOL = \\\"cns:pools:bond\\\";\\n  bytes32 public constant CNS_STAKING_POOL = \\\"cns:pools:staking\\\";\\n  bytes32 public constant CNS_LIQUIDITY_ENGINE = \\\"cns:liquidity:engine\\\";\\n  bytes32 public constant CNS_STRATEGY_AAVE = \\\"cns:strategy:aave\\\";\\n  bytes32 public constant CNS_STRATEGY_COMPOUND = \\\"cns:strategy:compound\\\";\\n\\n  /// @dev Governance contract address\\n  bytes32 public constant CNS_GOVERNANCE = \\\"cns:gov\\\";\\n\\n  /// @dev Governance:Resolution contract address\\n  bytes32 public constant CNS_GOVERNANCE_RESOLUTION = \\\"cns:gov:resolution\\\";\\n\\n  /// @dev Claims processor contract address\\n  bytes32 public constant CNS_CLAIM_PROCESSOR = \\\"cns:claim:processor\\\";\\n\\n  /// @dev The address where `burn tokens` are sent or collected.\\n  /// The collection behavior (collection) is required if the protocol\\n  /// is deployed on a sidechain or a layer-2 blockchain.\\n  /// &nbsp;\\\\n\\n  /// The collected NPM tokens are will be periodically bridged back to Ethereum\\n  /// and then burned.\\n  bytes32 public constant CNS_BURNER = \\\"cns:core:burner\\\";\\n\\n  /// @dev Namespace for all protocol members.\\n  bytes32 public constant NS_MEMBERS = \\\"ns:members\\\";\\n\\n  /// @dev Namespace for protocol contract members.\\n  bytes32 public constant NS_CONTRACTS = \\\"ns:contracts\\\";\\n\\n  /// @dev Key prefix for creating a new cover product on chain\\n  bytes32 public constant NS_COVER = \\\"ns:cover\\\";\\n  bytes32 public constant NS_COVER_PRODUCT = \\\"ns:cover:product\\\";\\n  bytes32 public constant NS_COVER_PRODUCT_EFFICIENCY = \\\"ns:cover:product:efficiency\\\";\\n\\n  bytes32 public constant NS_COVER_CREATION_DATE = \\\"ns:cover:creation:date\\\";\\n  bytes32 public constant NS_COVER_CREATION_FEE = \\\"ns:cover:creation:fee\\\";\\n  bytes32 public constant NS_COVER_CREATION_MIN_STAKE = \\\"ns:cover:creation:min:stake\\\";\\n  bytes32 public constant NS_COVER_REASSURANCE = \\\"ns:cover:reassurance\\\";\\n  bytes32 public constant NS_COVER_REASSURANCE_PAYOUT = \\\"ns:cover:reassurance:payout\\\";\\n  bytes32 public constant NS_COVER_REASSURANCE_WEIGHT = \\\"ns:cover:reassurance:weight\\\";\\n  bytes32 public constant NS_COVER_REASSURANCE_RATE = \\\"ns:cover:reassurance:rate\\\";\\n  bytes32 public constant NS_COVER_LEVERAGE_FACTOR = \\\"ns:cover:leverage:factor\\\";\\n  bytes32 public constant NS_COVER_CREATION_FEE_EARNING = \\\"ns:cover:creation:fee:earning\\\";\\n  bytes32 public constant NS_COVER_INFO = \\\"ns:cover:info\\\";\\n  bytes32 public constant NS_COVER_OWNER = \\\"ns:cover:owner\\\";\\n  bytes32 public constant NS_COVER_SUPPORTS_PRODUCTS = \\\"ns:cover:supports:products\\\";\\n\\n  bytes32 public constant NS_VAULT_STRATEGY_OUT = \\\"ns:vault:strategy:out\\\";\\n  bytes32 public constant NS_VAULT_LENDING_INCOMES = \\\"ns:vault:lending:incomes\\\";\\n  bytes32 public constant NS_VAULT_LENDING_LOSSES = \\\"ns:vault:lending:losses\\\";\\n  bytes32 public constant NS_VAULT_DEPOSIT_HEIGHTS = \\\"ns:vault:deposit:heights\\\";\\n  bytes32 public constant NS_COVER_LIQUIDITY_LENDING_PERIOD = \\\"ns:cover:liquidity:len:p\\\";\\n  bytes32 public constant NS_COVER_LIQUIDITY_MAX_LENDING_RATIO = \\\"ns:cover:liquidity:max:lr\\\";\\n  bytes32 public constant NS_COVER_LIQUIDITY_WITHDRAWAL_WINDOW = \\\"ns:cover:liquidity:ww\\\";\\n  bytes32 public constant NS_COVER_LIQUIDITY_MIN_STAKE = \\\"ns:cover:liquidity:min:stake\\\";\\n  bytes32 public constant NS_COVER_LIQUIDITY_STAKE = \\\"ns:cover:liquidity:stake\\\";\\n  bytes32 public constant NS_COVER_LIQUIDITY_COMMITTED = \\\"ns:cover:liquidity:committed\\\";\\n  bytes32 public constant NS_COVER_STABLECOIN_NAME = \\\"ns:cover:stablecoin:name\\\";\\n  bytes32 public constant NS_COVER_REQUIRES_WHITELIST = \\\"ns:cover:requires:whitelist\\\";\\n\\n  bytes32 public constant NS_COVER_HAS_FLASH_LOAN = \\\"ns:cover:has:fl\\\";\\n  bytes32 public constant NS_COVER_LIQUIDITY_FLASH_LOAN_FEE = \\\"ns:cover:liquidity:fl:fee\\\";\\n  bytes32 public constant NS_COVER_LIQUIDITY_FLASH_LOAN_FEE_PROTOCOL = \\\"ns:proto:cover:liquidity:fl:fee\\\";\\n\\n  bytes32 public constant NS_COVERAGE_LAG = \\\"ns:coverage:lag\\\";\\n  bytes32 public constant NS_COVER_POLICY_RATE_FLOOR = \\\"ns:cover:policy:rate:floor\\\";\\n  bytes32 public constant NS_COVER_POLICY_RATE_CEILING = \\\"ns:cover:policy:rate:ceiling\\\";\\n  bytes32 public constant NS_POLICY_DISABLED = \\\"ns:policy:disabled\\\";\\n  bytes32 public constant NS_POLICY_LAST_PURCHASE_ID = \\\"ns:policy:last:purchase:id\\\";\\n\\n  bytes32 public constant NS_COVER_STAKE = \\\"ns:cover:stake\\\";\\n  bytes32 public constant NS_COVER_STAKE_OWNED = \\\"ns:cover:stake:owned\\\";\\n  bytes32 public constant NS_COVER_STATUS = \\\"ns:cover:status\\\";\\n  bytes32 public constant NS_COVER_CXTOKEN = \\\"ns:cover:cxtoken\\\";\\n  bytes32 public constant NS_VAULT_TOKEN_NAME = \\\"ns:vault:token:name\\\";\\n  bytes32 public constant NS_VAULT_TOKEN_SYMBOL = \\\"ns:vault:token:symbol\\\";\\n  bytes32 public constant NS_COVER_CREATOR_WHITELIST = \\\"ns:cover:creator:whitelist\\\";\\n  bytes32 public constant NS_COVER_USER_WHITELIST = \\\"ns:cover:user:whitelist\\\";\\n  bytes32 public constant NS_COVER_CLAIM_BLACKLIST = \\\"ns:cover:claim:blacklist\\\";\\n\\n  /// @dev Resolution timestamp = timestamp of first reporting + reporting period\\n  bytes32 public constant NS_GOVERNANCE_RESOLUTION_TS = \\\"ns:gov:resolution:ts\\\";\\n\\n  /// @dev The timestamp when a tokenholder withdraws their reporting stake\\n  bytes32 public constant NS_GOVERNANCE_UNSTAKEN = \\\"ns:gov:unstaken\\\";\\n\\n  /// @dev The timestamp when a tokenholder withdraws their reporting stake\\n  bytes32 public constant NS_GOVERNANCE_UNSTAKE_TS = \\\"ns:gov:unstake:ts\\\";\\n\\n  /// @dev The reward received by the winning camp\\n  bytes32 public constant NS_GOVERNANCE_UNSTAKE_REWARD = \\\"ns:gov:unstake:reward\\\";\\n\\n  /// @dev The stakes burned during incident resolution\\n  bytes32 public constant NS_GOVERNANCE_UNSTAKE_BURNED = \\\"ns:gov:unstake:burned\\\";\\n\\n  /// @dev The stakes burned during incident resolution\\n  bytes32 public constant NS_GOVERNANCE_UNSTAKE_REPORTER_FEE = \\\"ns:gov:unstake:rep:fee\\\";\\n\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_MIN_FIRST_STAKE = \\\"ns:gov:rep:min:first:stake\\\";\\n\\n  /// @dev An approximate date and time when trigger event or cover incident occurred\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_INCIDENT_DATE = \\\"ns:gov:rep:incident:date\\\";\\n\\n  /// @dev A period (in solidity timestamp) configurable by cover creators during\\n  /// when NPM tokenholders can vote on incident reporting proposals\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_PERIOD = \\\"ns:gov:rep:period\\\";\\n\\n  /// @dev Used as key element in a couple of places:\\n  /// 1. For uint256 --> Sum total of NPM witnesses who saw incident to have happened\\n  /// 2. For address --> The address of the first reporter\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_WITNESS_YES = \\\"ns:gov:rep:witness:yes\\\";\\n\\n  /// @dev Used as key to flag if a cover was disputed. Cleared when a cover is finalized.\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_HAS_A_DISPUTE = \\\"ns:gov:rep:has:dispute\\\";\\n\\n  /// @dev Used as key to flag if a incident was finalized.\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_FINALIZATION = \\\"ns:gov:rep:has:finalized\\\";\\n\\n  /// @dev Used as key element in a couple of places:\\n  /// 1. For uint256 --> Sum total of NPM witnesses who disagreed with and disputed an incident reporting\\n  /// 2. For address --> The address of the first disputing reporter (disputer / candidate reporter)\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_WITNESS_NO = \\\"ns:gov:rep:witness:no\\\";\\n\\n  /// @dev Stakes guaranteed by an individual witness supporting the \\\"incident happened\\\" camp\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_STAKE_OWNED_YES = \\\"ns:gov:rep:stake:owned:yes\\\";\\n\\n  /// @dev Stakes guaranteed by an individual witness supporting the \\\"false reporting\\\" camp\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_STAKE_OWNED_NO = \\\"ns:gov:rep:stake:owned:no\\\";\\n\\n  /// @dev The percentage rate (x MULTIPLIER) of amount of reporting/unstake reward to burn.\\n  /// @custom:note that the reward comes from the losing camp after resolution is achieved.\\n  bytes32 public constant NS_GOVERNANCE_REPORTING_BURN_RATE = \\\"ns:gov:rep:burn:rate\\\";\\n\\n  /// @dev The percentage rate (x MULTIPLIER) of amount of reporting/unstake\\n  /// reward to provide to the final reporter.\\n  bytes32 public constant NS_GOVERNANCE_REPORTER_COMMISSION = \\\"ns:gov:reporter:commission\\\";\\n\\n  bytes32 public constant NS_CLAIM_PERIOD = \\\"ns:claim:period\\\";\\n\\n  bytes32 public constant NS_CLAIM_PAYOUTS = \\\"ns:claim:payouts\\\";\\n\\n  /// @dev A 24-hour delay after a governance agent \\\"resolves\\\" an actively reported cover.\\n  bytes32 public constant NS_CLAIM_BEGIN_TS = \\\"ns:claim:begin:ts\\\";\\n\\n  /// @dev Claim expiry date = Claim begin date + claim duration\\n  bytes32 public constant NS_CLAIM_EXPIRY_TS = \\\"ns:claim:expiry:ts\\\";\\n\\n  bytes32 public constant NS_RESOLUTION_DEADLINE = \\\"ns:resolution:deadline\\\";\\n\\n  /// @dev Claim expiry date = Claim begin date + claim duration\\n  bytes32 public constant NS_RESOLUTION_COOL_DOWN_PERIOD = \\\"ns:resolution:cdp\\\";\\n\\n  /// @dev The percentage rate (x MULTIPLIER) of amount deducted by the platform\\n  /// for each successful claims payout\\n  bytes32 public constant NS_COVER_PLATFORM_FEE = \\\"ns:cover:platform:fee\\\";\\n\\n  /// @dev The percentage rate (x MULTIPLIER) of amount provided to the first reporter\\n  /// upon favorable incident resolution. This amount is a commission of the\\n  /// 'ns:claim:platform:fee'\\n  bytes32 public constant NS_CLAIM_REPORTER_COMMISSION = \\\"ns:claim:reporter:commission\\\";\\n\\n  bytes32 public constant NS_LAST_LIQUIDITY_STATE_UPDATE = \\\"ns:last:snl:update\\\";\\n  bytes32 public constant NS_LIQUIDITY_STATE_UPDATE_INTERVAL = \\\"ns:snl:update:interval\\\";\\n  bytes32 public constant NS_LENDING_STRATEGY_ACTIVE = \\\"ns:lending:strategy:active\\\";\\n  bytes32 public constant NS_LENDING_STRATEGY_DISABLED = \\\"ns:lending:strategy:disabled\\\";\\n  bytes32 public constant NS_LENDING_STRATEGY_WITHDRAWAL_START = \\\"ns:lending:strategy:w:start\\\";\\n  bytes32 public constant NS_ACCRUAL_INVOCATION = \\\"ns:accrual:invocation\\\";\\n  bytes32 public constant NS_LENDING_STRATEGY_WITHDRAWAL_END = \\\"ns:lending:strategy:w:end\\\";\\n\\n  bytes32 public constant CNAME_PROTOCOL = \\\"Neptune Mutual Protocol\\\";\\n  bytes32 public constant CNAME_TREASURY = \\\"Treasury\\\";\\n  bytes32 public constant CNAME_POLICY = \\\"Policy\\\";\\n  bytes32 public constant CNAME_POLICY_ADMIN = \\\"Policy Admin\\\";\\n  bytes32 public constant CNAME_BOND_POOL = \\\"BondPool\\\";\\n  bytes32 public constant CNAME_STAKING_POOL = \\\"Staking Pool\\\";\\n  bytes32 public constant CNAME_CLAIMS_PROCESSOR = \\\"Claims Processor\\\";\\n  bytes32 public constant CNAME_COVER = \\\"Cover\\\";\\n  bytes32 public constant CNAME_GOVERNANCE = \\\"Governance\\\";\\n  bytes32 public constant CNAME_RESOLUTION = \\\"Resolution\\\";\\n  bytes32 public constant CNAME_VAULT_FACTORY = \\\"Vault Factory\\\";\\n  bytes32 public constant CNAME_CXTOKEN_FACTORY = \\\"cxToken Factory\\\";\\n  bytes32 public constant CNAME_COVER_STAKE = \\\"Cover Stake\\\";\\n  bytes32 public constant CNAME_COVER_REASSURANCE = \\\"Cover Reassurance\\\";\\n  bytes32 public constant CNAME_LIQUIDITY_VAULT = \\\"Vault\\\";\\n  bytes32 public constant CNAME_VAULT_DELEGATE = \\\"Vault Delegate\\\";\\n  bytes32 public constant CNAME_LIQUIDITY_ENGINE = \\\"Liquidity Engine\\\";\\n\\n  function getProtocolInternal(IStore s) external view returns (IProtocol) {\\n    return IProtocol(getProtocolAddressInternal(s));\\n  }\\n\\n  function getProtocolAddressInternal(IStore s) public view returns (address) {\\n    return s.getAddressByKey(CNS_CORE);\\n  }\\n\\n  function getContractInternal(\\n    IStore s,\\n    bytes32 name,\\n    bytes32 key\\n  ) public view returns (address) {\\n    if (key > 0) {\\n      return s.getAddressByKeys(NS_CONTRACTS, name, key);\\n    }\\n\\n    return s.getAddressByKeys(NS_CONTRACTS, name);\\n  }\\n\\n  function isProtocolMemberInternal(IStore s, address contractAddress) public view returns (bool) {\\n    return s.getBoolByKeys(ProtoUtilV1.NS_MEMBERS, contractAddress);\\n  }\\n\\n  /**\\n   * @dev Reverts if the caller is one of the protocol members.\\n   */\\n  function mustBeProtocolMember(IStore s, address contractAddress) external view {\\n    bool isMember = isProtocolMemberInternal(s, contractAddress);\\n    require(isMember, \\\"Not a protocol member\\\");\\n  }\\n\\n  /**\\n   * @dev Ensures that the sender matches with the exact contract having the specified name.\\n   * @param name Enter the name of the contract\\n   * @param sender Enter the `msg.sender` value\\n   */\\n  function mustBeExactContract(\\n    IStore s,\\n    bytes32 name,\\n    bytes32 key,\\n    address sender\\n  ) public view {\\n    address contractAddress = getContractInternal(s, name, key);\\n    require(sender == contractAddress, \\\"Access denied\\\");\\n  }\\n\\n  /**\\n   * @dev Ensures that the sender matches with the exact contract having the specified name.\\n   * @param name Enter the name of the contract\\n   */\\n  function senderMustBeExactContract(IStore s, bytes32 name) external view {\\n    return callerMustBeExactContract(s, name, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Ensures that the sender matches with the exact contract having the specified name.\\n   * @param name Enter the name of the contract\\n   */\\n  function callerMustBeExactContract(\\n    IStore s,\\n    bytes32 name,\\n    address caller\\n  ) public view {\\n    return mustBeExactContract(s, name, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY, caller);\\n  }\\n\\n  function getNpmTokenInstanceInternal(IStore s) external view returns (IERC20) {\\n    return IERC20(getNpmTokenAddressInternal(s));\\n  }\\n\\n  function getNpmTokenAddressInternal(IStore s) public view returns (address) {\\n    address npm = s.getAddressByKey(CNS_NPM);\\n    return npm;\\n  }\\n\\n  function getUniswapV2RouterInternal(IStore s) external view returns (address) {\\n    return s.getAddressByKey(CNS_UNISWAP_V2_ROUTER);\\n  }\\n\\n  function getUniswapV2FactoryInternal(IStore s) external view returns (address) {\\n    return s.getAddressByKey(CNS_UNISWAP_V2_FACTORY);\\n  }\\n\\n  function getNpmPriceOracleInternal(IStore s) external view returns (address) {\\n    return s.getAddressByKey(CNS_NPM_PRICE_ORACLE);\\n  }\\n\\n  function getTreasuryAddressInternal(IStore s) external view returns (address) {\\n    return s.getAddressByKey(CNS_TREASURY);\\n  }\\n\\n  function getStablecoinAddressInternal(IStore s) public view returns (address) {\\n    return s.getAddressByKey(CNS_COVER_STABLECOIN);\\n  }\\n\\n  function getStablecoinPrecisionInternal(IStore s) external view returns (uint256) {\\n    return 10**IERC20Detailed(getStablecoinAddressInternal(s)).decimals();\\n  }\\n\\n  function getBurnAddressInternal(IStore s) external view returns (address) {\\n    return s.getAddressByKey(CNS_BURNER);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RegistryLibV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ProtoUtilV1.sol\\\";\\nimport \\\"./StoreKeyUtil.sol\\\";\\nimport \\\"../interfaces/ICover.sol\\\";\\nimport \\\"../interfaces/IPolicy.sol\\\";\\nimport \\\"../interfaces/IBondPool.sol\\\";\\nimport \\\"../interfaces/ICoverStake.sol\\\";\\nimport \\\"../interfaces/ICxTokenFactory.sol\\\";\\nimport \\\"../interfaces/ICoverReassurance.sol\\\";\\nimport \\\"../interfaces/IGovernance.sol\\\";\\nimport \\\"../interfaces/IVault.sol\\\";\\nimport \\\"../interfaces/IVaultFactory.sol\\\";\\n\\nlibrary RegistryLibV1 {\\n  using ProtoUtilV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n\\n  function getGovernanceContract(IStore s) external view returns (IGovernance) {\\n    return IGovernance(s.getContractInternal(ProtoUtilV1.CNS_GOVERNANCE, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY));\\n  }\\n\\n  function getResolutionContract(IStore s) external view returns (IGovernance) {\\n    return IGovernance(s.getContractInternal(ProtoUtilV1.CNS_GOVERNANCE_RESOLUTION, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY));\\n  }\\n\\n  function getStakingContract(IStore s) external view returns (ICoverStake) {\\n    return ICoverStake(s.getContractInternal(ProtoUtilV1.CNS_COVER_STAKE, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY));\\n  }\\n\\n  function getCxTokenFactory(IStore s) external view returns (ICxTokenFactory) {\\n    return ICxTokenFactory(s.getContractInternal(ProtoUtilV1.CNS_COVER_CXTOKEN_FACTORY, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY));\\n  }\\n\\n  function getPolicyContract(IStore s) external view returns (IPolicy) {\\n    return IPolicy(s.getContractInternal(ProtoUtilV1.CNS_COVER_POLICY, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY));\\n  }\\n\\n  function getReassuranceContract(IStore s) external view returns (ICoverReassurance) {\\n    return ICoverReassurance(s.getContractInternal(ProtoUtilV1.CNS_COVER_REASSURANCE, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY));\\n  }\\n\\n  function getBondPoolContract(IStore s) external view returns (IBondPool) {\\n    return IBondPool(getBondPoolAddress(s));\\n  }\\n\\n  function getProtocolContract(IStore s, bytes32 cns) public view returns (address) {\\n    return s.getAddressByKeys(ProtoUtilV1.NS_CONTRACTS, cns);\\n  }\\n\\n  function getProtocolContract(\\n    IStore s,\\n    bytes32 cns,\\n    bytes32 key\\n  ) public view returns (address) {\\n    return s.getAddressByKeys(ProtoUtilV1.NS_CONTRACTS, cns, key);\\n  }\\n\\n  function getCoverContract(IStore s) external view returns (ICover) {\\n    address vault = getProtocolContract(s, ProtoUtilV1.CNS_COVER);\\n    return ICover(vault);\\n  }\\n\\n  function getVault(IStore s, bytes32 coverKey) external view returns (IVault) {\\n    return IVault(getVaultAddress(s, coverKey));\\n  }\\n\\n  function getVaultAddress(IStore s, bytes32 coverKey) public view returns (address) {\\n    address vault = getProtocolContract(s, ProtoUtilV1.CNS_COVER_VAULT, coverKey);\\n    return vault;\\n  }\\n\\n  function getVaultDelegate(IStore s) external view returns (address) {\\n    address vaultImplementation = getProtocolContract(s, ProtoUtilV1.CNS_COVER_VAULT_DELEGATE);\\n    return vaultImplementation;\\n  }\\n\\n  function getStakingPoolAddress(IStore s) external view returns (address) {\\n    address pool = getProtocolContract(s, ProtoUtilV1.CNS_STAKING_POOL);\\n    return pool;\\n  }\\n\\n  function getBondPoolAddress(IStore s) public view returns (address) {\\n    address pool = getProtocolContract(s, ProtoUtilV1.CNS_BOND_POOL);\\n    return pool;\\n  }\\n\\n  function getVaultFactoryContract(IStore s) external view returns (IVaultFactory) {\\n    address factory = s.getContractInternal(ProtoUtilV1.CNS_COVER_VAULT_FACTORY, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY);\\n    return IVaultFactory(factory);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RoutineInvokerLibV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\n/* solhint-disable ordering  */\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"../interfaces/ILendingStrategy.sol\\\";\\nimport \\\"./PriceLibV1.sol\\\";\\nimport \\\"./CoverUtilV1.sol\\\";\\n\\nlibrary RoutineInvokerLibV1 {\\n  using CoverUtilV1 for IStore;\\n  using PriceLibV1 for IStore;\\n  using ProtoUtilV1 for IStore;\\n  using RegistryLibV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n  using StrategyLibV1 for IStore;\\n\\n  enum Action {\\n    Deposit,\\n    Withdraw\\n  }\\n\\n  function updateStateAndLiquidityInternal(IStore s, bytes32 coverKey) external {\\n    _invoke(s, coverKey);\\n  }\\n\\n  function _invoke(IStore s, bytes32 coverKey) private {\\n    // solhint-disable-next-line\\n    if (s.getLastUpdatedOnInternal(coverKey) + _getUpdateInterval(s) > block.timestamp) {\\n      return;\\n    }\\n\\n    PriceLibV1.setNpmPrice(s);\\n\\n    if (coverKey > 0) {\\n      _updateWithdrawalPeriod(s, coverKey);\\n      _invokeAssetManagement(s, coverKey);\\n      s.setLastUpdatedOnInternal(coverKey);\\n    }\\n  }\\n\\n  function _getUpdateInterval(IStore s) private view returns (uint256) {\\n    return s.getUintByKey(ProtoUtilV1.NS_LIQUIDITY_STATE_UPDATE_INTERVAL);\\n  }\\n\\n  function getWithdrawalInfoInternal(IStore s, bytes32 coverKey)\\n    public\\n    view\\n    returns (\\n      bool isWithdrawalPeriod,\\n      uint256 lendingPeriod,\\n      uint256 withdrawalWindow,\\n      uint256 start,\\n      uint256 end\\n    )\\n  {\\n    (lendingPeriod, withdrawalWindow) = s.getRiskPoolingPeriodsInternal(coverKey);\\n\\n    // Get the withdrawal period of this cover liquidity\\n    start = s.getUintByKey(getNextWithdrawalStartKeyInternal(coverKey));\\n    end = s.getUintByKey(getNextWithdrawalEndKeyInternal(coverKey));\\n\\n    // solhint-disable-next-line\\n    if (block.timestamp >= start && block.timestamp <= end) {\\n      isWithdrawalPeriod = true;\\n    }\\n  }\\n\\n  function _isWithdrawalPeriod(IStore s, bytes32 coverKey) private view returns (bool) {\\n    (bool isWithdrawalPeriod, , , , ) = getWithdrawalInfoInternal(s, coverKey);\\n    return isWithdrawalPeriod;\\n  }\\n\\n  function _updateWithdrawalPeriod(IStore s, bytes32 coverKey) private {\\n    (, uint256 lendingPeriod, uint256 withdrawalWindow, uint256 start, uint256 end) = getWithdrawalInfoInternal(s, coverKey);\\n\\n    // Without a lending period and withdrawal window, nothing can be updated\\n    if (lendingPeriod == 0 || withdrawalWindow == 0) {\\n      return;\\n    }\\n\\n    // The withdrawal period is now over.\\n    // Deposits can be performed again.\\n    // Set the next withdrawal cycle\\n    if (block.timestamp > end) {\\n      // solhint-disable-previous-line\\n\\n      // Next Withdrawal Cycle\\n\\n      // Withdrawals can start after the lending period\\n      start = block.timestamp + lendingPeriod; // solhint-disable\\n      // Withdrawals can be performed until the end of the next withdrawal cycle\\n      end = start + withdrawalWindow;\\n\\n      s.setUintByKey(getNextWithdrawalStartKeyInternal(coverKey), start);\\n      s.setUintByKey(getNextWithdrawalEndKeyInternal(coverKey), end);\\n      setAccrualCompleteInternal(s, coverKey, false);\\n    }\\n  }\\n\\n  function isAccrualCompleteInternal(IStore s, bytes32 coverKey) external view returns (bool) {\\n    return s.getBoolByKey(getAccrualInvocationKeyInternal(coverKey));\\n  }\\n\\n  function setAccrualCompleteInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bool flag\\n  ) public {\\n    s.setBoolByKey(getAccrualInvocationKeyInternal(coverKey), flag);\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"accrual invocation status\\\" for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getAccrualInvocationKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_ACCRUAL_INVOCATION, coverKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"next withdrawal start date\\\" for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getNextWithdrawalStartKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_WITHDRAWAL_START, coverKey));\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"next withdrawal end date\\\" for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getNextWithdrawalEndKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_WITHDRAWAL_END, coverKey));\\n  }\\n\\n  function mustBeDuringWithdrawalPeriod(IStore s, bytes32 coverKey) external view {\\n    // Get the withdrawal period of this cover liquidity\\n    uint256 start = s.getUintByKey(getNextWithdrawalStartKeyInternal(coverKey));\\n    uint256 end = s.getUintByKey(getNextWithdrawalEndKeyInternal(coverKey));\\n\\n    require(start > 0 && block.timestamp >= start, \\\"Withdrawal period has not started\\\");\\n    require(end > 0 && block.timestamp <= end, \\\"Withdrawal period has already ended\\\");\\n  }\\n\\n  function _executeAndGetAction(\\n    IStore s,\\n    ILendingStrategy,\\n    bytes32 coverKey\\n  ) private returns (Action) {\\n    // If the cover is undergoing reporting, withdraw everything\\n    bool isNormal = s.isCoverNormalInternal(coverKey);\\n\\n    if (isNormal != true) {\\n      // Reset the withdrawal window\\n      s.setUintByKey(getNextWithdrawalStartKeyInternal(coverKey), 0);\\n      s.setUintByKey(getNextWithdrawalEndKeyInternal(coverKey), 0);\\n\\n      return Action.Withdraw;\\n    }\\n\\n    if (_isWithdrawalPeriod(s, coverKey) == true) {\\n      return Action.Withdraw;\\n    }\\n\\n    return Action.Deposit;\\n  }\\n\\n  function _canDeposit(\\n    IStore s,\\n    ILendingStrategy strategy,\\n    uint256 totalStrategies,\\n    bytes32 coverKey\\n  ) private view returns (uint256) {\\n    IERC20 stablecoin = IERC20(s.getStablecoinAddressInternal());\\n\\n    uint256 totalBalance = s.getStablecoinOwnedByVaultInternal(coverKey);\\n    uint256 maximumAllowed = (totalBalance * s.getMaxLendingRatioInternal()) / ProtoUtilV1.MULTIPLIER;\\n    uint256 allocation = maximumAllowed / totalStrategies;\\n    uint256 weight = strategy.getWeight();\\n    uint256 canDeposit = (allocation * weight) / ProtoUtilV1.MULTIPLIER;\\n    uint256 alreadyDeposited = s.getAmountInStrategyInternal(coverKey, strategy.getName(), address(stablecoin));\\n\\n    if (alreadyDeposited >= canDeposit) {\\n      return 0;\\n    }\\n\\n    return canDeposit - alreadyDeposited;\\n  }\\n\\n  function _invokeAssetManagement(IStore s, bytes32 coverKey) private {\\n    address vault = s.getVaultAddress(coverKey);\\n    _withdrawFromDisabled(s, coverKey, vault);\\n\\n    address[] memory strategies = s.getActiveStrategiesInternal();\\n\\n    for (uint256 i = 0; i < strategies.length; i++) {\\n      ILendingStrategy strategy = ILendingStrategy(strategies[i]);\\n      _executeStrategy(s, strategy, strategies.length, vault, coverKey);\\n    }\\n  }\\n\\n  function _executeStrategy(\\n    IStore s,\\n    ILendingStrategy strategy,\\n    uint256 totalStrategies,\\n    address vault,\\n    bytes32 coverKey\\n  ) private {\\n    uint256 canDeposit = _canDeposit(s, strategy, totalStrategies, coverKey);\\n    uint256 balance = IERC20(s.getStablecoinAddressInternal()).balanceOf(vault);\\n\\n    if (canDeposit > balance) {\\n      canDeposit = balance;\\n    }\\n\\n    Action action = _executeAndGetAction(s, strategy, coverKey);\\n\\n    if (action == Action.Deposit && canDeposit == 0) {\\n      return;\\n    }\\n\\n    if (action == Action.Withdraw) {\\n      _withdrawAllFromStrategy(strategy, vault, coverKey);\\n      return;\\n    }\\n\\n    _depositToStrategy(strategy, coverKey, canDeposit);\\n  }\\n\\n  function _depositToStrategy(\\n    ILendingStrategy strategy,\\n    bytes32 coverKey,\\n    uint256 amount\\n  ) private {\\n    strategy.deposit(coverKey, amount);\\n  }\\n\\n  function _withdrawAllFromStrategy(\\n    ILendingStrategy strategy,\\n    address vault,\\n    bytes32 coverKey\\n  ) private returns (uint256 stablecoinWithdrawn) {\\n    uint256 balance = IERC20(strategy.getDepositCertificate()).balanceOf(vault);\\n\\n    if (balance > 0) {\\n      stablecoinWithdrawn = strategy.withdraw(coverKey);\\n    }\\n  }\\n\\n  function _withdrawFromDisabled(\\n    IStore s,\\n    bytes32 coverKey,\\n    address onBehalfOf\\n  ) private {\\n    address[] memory strategies = s.getDisabledStrategiesInternal();\\n\\n    for (uint256 i = 0; i < strategies.length; i++) {\\n      ILendingStrategy strategy = ILendingStrategy(strategies[i]);\\n      uint256 balance = IERC20(strategy.getDepositCertificate()).balanceOf(onBehalfOf);\\n\\n      if (balance > 0) {\\n        strategy.withdraw(coverKey);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StoreKeyUtil.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\n// solhint-disable func-order\\npragma solidity ^0.8.0;\\nimport \\\"../interfaces/IStore.sol\\\";\\n\\nlibrary StoreKeyUtil {\\n  function setUintByKey(\\n    IStore s,\\n    bytes32 key,\\n    uint256 value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.setUint(key, value);\\n  }\\n\\n  function setUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    uint256 value\\n  ) external {\\n    return s.setUint(_getKey(key1, key2), value);\\n  }\\n\\n  function setUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    uint256 value\\n  ) external {\\n    return s.setUint(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function setUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address account,\\n    uint256 value\\n  ) external {\\n    return s.setUint(_getKey(key1, key2, account), value);\\n  }\\n\\n  function addUintByKey(\\n    IStore s,\\n    bytes32 key,\\n    uint256 value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.addUint(key, value);\\n  }\\n\\n  function addUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    uint256 value\\n  ) external {\\n    return s.addUint(_getKey(key1, key2), value);\\n  }\\n\\n  function addUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address account,\\n    uint256 value\\n  ) external {\\n    return s.addUint(_getKey(key1, key2, account), value);\\n  }\\n\\n  function subtractUintByKey(\\n    IStore s,\\n    bytes32 key,\\n    uint256 value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.subtractUint(key, value);\\n  }\\n\\n  function subtractUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    uint256 value\\n  ) external {\\n    return s.subtractUint(_getKey(key1, key2), value);\\n  }\\n\\n  function subtractUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address account,\\n    uint256 value\\n  ) external {\\n    return s.subtractUint(_getKey(key1, key2, account), value);\\n  }\\n\\n  function setStringByKey(\\n    IStore s,\\n    bytes32 key,\\n    string calldata value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    s.setString(key, value);\\n  }\\n\\n  function setStringByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    string calldata value\\n  ) external {\\n    return s.setString(_getKey(key1, key2), value);\\n  }\\n\\n  function setStringByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    string calldata value\\n  ) external {\\n    return s.setString(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function setBytes32ByKey(\\n    IStore s,\\n    bytes32 key,\\n    bytes32 value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    s.setBytes32(key, value);\\n  }\\n\\n  function setBytes32ByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 value\\n  ) external {\\n    return s.setBytes32(_getKey(key1, key2), value);\\n  }\\n\\n  function setBytes32ByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    bytes32 value\\n  ) external {\\n    return s.setBytes32(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function setBoolByKey(\\n    IStore s,\\n    bytes32 key,\\n    bool value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.setBool(key, value);\\n  }\\n\\n  function setBoolByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bool value\\n  ) external {\\n    return s.setBool(_getKey(key1, key2), value);\\n  }\\n\\n  function setBoolByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    bool value\\n  ) external {\\n    return s.setBool(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function setBoolByKeys(\\n    IStore s,\\n    bytes32 key,\\n    address account,\\n    bool value\\n  ) external {\\n    return s.setBool(_getKey(key, account), value);\\n  }\\n\\n  function setAddressByKey(\\n    IStore s,\\n    bytes32 key,\\n    address value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.setAddress(key, value);\\n  }\\n\\n  function setAddressByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address value\\n  ) external {\\n    return s.setAddress(_getKey(key1, key2), value);\\n  }\\n\\n  function setAddressByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    address value\\n  ) external {\\n    return s.setAddress(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function setAddressArrayByKey(\\n    IStore s,\\n    bytes32 key,\\n    address value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.setAddressArrayItem(key, value);\\n  }\\n\\n  function setAddressArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address value\\n  ) external {\\n    return s.setAddressArrayItem(_getKey(key1, key2), value);\\n  }\\n\\n  function setAddressArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    address value\\n  ) external {\\n    return s.setAddressArrayItem(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function setAddressBooleanByKey(\\n    IStore s,\\n    bytes32 key,\\n    address account,\\n    bool value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.setAddressBoolean(key, account, value);\\n  }\\n\\n  function setAddressBooleanByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address account,\\n    bool value\\n  ) external {\\n    return s.setAddressBoolean(_getKey(key1, key2), account, value);\\n  }\\n\\n  function setAddressBooleanByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    address account,\\n    bool value\\n  ) external {\\n    return s.setAddressBoolean(_getKey(key1, key2, key3), account, value);\\n  }\\n\\n  function deleteUintByKey(IStore s, bytes32 key) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.deleteUint(key);\\n  }\\n\\n  function deleteUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external {\\n    return s.deleteUint(_getKey(key1, key2));\\n  }\\n\\n  function deleteUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external {\\n    return s.deleteUint(_getKey(key1, key2, key3));\\n  }\\n\\n  function deleteBytes32ByKey(IStore s, bytes32 key) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    s.deleteBytes32(key);\\n  }\\n\\n  function deleteBytes32ByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external {\\n    return s.deleteBytes32(_getKey(key1, key2));\\n  }\\n\\n  function deleteBoolByKey(IStore s, bytes32 key) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.deleteBool(key);\\n  }\\n\\n  function deleteBoolByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external {\\n    return s.deleteBool(_getKey(key1, key2));\\n  }\\n\\n  function deleteBoolByKeys(\\n    IStore s,\\n    bytes32 key,\\n    address account\\n  ) external {\\n    return s.deleteBool(_getKey(key, account));\\n  }\\n\\n  function deleteAddressByKey(IStore s, bytes32 key) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.deleteAddress(key);\\n  }\\n\\n  function deleteAddressByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external {\\n    return s.deleteAddress(_getKey(key1, key2));\\n  }\\n\\n  function deleteAddressByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external {\\n    return s.deleteAddress(_getKey(key1, key2, key3));\\n  }\\n\\n  function deleteAddressArrayByKey(\\n    IStore s,\\n    bytes32 key,\\n    address value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.deleteAddressArrayItem(key, value);\\n  }\\n\\n  function deleteAddressArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address value\\n  ) external {\\n    return s.deleteAddressArrayItem(_getKey(key1, key2), value);\\n  }\\n\\n  function deleteAddressArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    address value\\n  ) external {\\n    return s.deleteAddressArrayItem(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function deleteAddressArrayByIndexByKey(\\n    IStore s,\\n    bytes32 key,\\n    uint256 index\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.deleteAddressArrayItemByIndex(key, index);\\n  }\\n\\n  function deleteAddressArrayByIndexByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    uint256 index\\n  ) external {\\n    return s.deleteAddressArrayItemByIndex(_getKey(key1, key2), index);\\n  }\\n\\n  function deleteAddressArrayByIndexByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    uint256 index\\n  ) external {\\n    return s.deleteAddressArrayItemByIndex(_getKey(key1, key2, key3), index);\\n  }\\n\\n  function getUintByKey(IStore s, bytes32 key) external view returns (uint256) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getUint(key);\\n  }\\n\\n  function getUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (uint256) {\\n    return s.getUint(_getKey(key1, key2));\\n  }\\n\\n  function getUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external view returns (uint256) {\\n    return s.getUint(_getKey(key1, key2, key3));\\n  }\\n\\n  function getUintByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address account\\n  ) external view returns (uint256) {\\n    return s.getUint(_getKey(key1, key2, account));\\n  }\\n\\n  function getStringByKey(IStore s, bytes32 key) external view returns (string memory) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getString(key);\\n  }\\n\\n  function getStringByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (string memory) {\\n    return s.getString(_getKey(key1, key2));\\n  }\\n\\n  function getBytes32ByKey(IStore s, bytes32 key) external view returns (bytes32) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getBytes32(key);\\n  }\\n\\n  function getBytes32ByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (bytes32) {\\n    return s.getBytes32(_getKey(key1, key2));\\n  }\\n\\n  function getBoolByKey(IStore s, bytes32 key) external view returns (bool) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getBool(key);\\n  }\\n\\n  function getBoolByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external view returns (bool) {\\n    return s.getBool(_getKey(key1, key2, key3));\\n  }\\n\\n  function getBoolByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (bool) {\\n    return s.getBool(_getKey(key1, key2));\\n  }\\n\\n  function getBoolByKeys(\\n    IStore s,\\n    bytes32 key,\\n    address account\\n  ) external view returns (bool) {\\n    return s.getBool(_getKey(key, account));\\n  }\\n\\n  function getAddressByKey(IStore s, bytes32 key) external view returns (address) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getAddress(key);\\n  }\\n\\n  function getAddressByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (address) {\\n    return s.getAddress(_getKey(key1, key2));\\n  }\\n\\n  function getAddressByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external view returns (address) {\\n    return s.getAddress(_getKey(key1, key2, key3));\\n  }\\n\\n  function getAddressBooleanByKey(\\n    IStore s,\\n    bytes32 key,\\n    address account\\n  ) external view returns (bool) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getAddressBoolean(key, account);\\n  }\\n\\n  function getAddressBooleanByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address account\\n  ) external view returns (bool) {\\n    return s.getAddressBoolean(_getKey(key1, key2), account);\\n  }\\n\\n  function getAddressBooleanByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    address account\\n  ) external view returns (bool) {\\n    return s.getAddressBoolean(_getKey(key1, key2, key3), account);\\n  }\\n\\n  function countAddressArrayByKey(IStore s, bytes32 key) external view returns (uint256) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.countAddressArrayItems(key);\\n  }\\n\\n  function countAddressArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (uint256) {\\n    return s.countAddressArrayItems(_getKey(key1, key2));\\n  }\\n\\n  function countAddressArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external view returns (uint256) {\\n    return s.countAddressArrayItems(_getKey(key1, key2, key3));\\n  }\\n\\n  function getAddressArrayByKey(IStore s, bytes32 key) external view returns (address[] memory) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getAddressArray(key);\\n  }\\n\\n  function getAddressArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (address[] memory) {\\n    return s.getAddressArray(_getKey(key1, key2));\\n  }\\n\\n  function getAddressArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external view returns (address[] memory) {\\n    return s.getAddressArray(_getKey(key1, key2, key3));\\n  }\\n\\n  function getAddressArrayItemPositionByKey(\\n    IStore s,\\n    bytes32 key,\\n    address addressToFind\\n  ) external view returns (uint256) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getAddressArrayItemPosition(key, addressToFind);\\n  }\\n\\n  function getAddressArrayItemPositionByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    address addressToFind\\n  ) external view returns (uint256) {\\n    return s.getAddressArrayItemPosition(_getKey(key1, key2), addressToFind);\\n  }\\n\\n  function getAddressArrayItemPositionByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    address addressToFind\\n  ) external view returns (uint256) {\\n    return s.getAddressArrayItemPosition(_getKey(key1, key2, key3), addressToFind);\\n  }\\n\\n  function getAddressArrayItemByIndexByKey(\\n    IStore s,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (address) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getAddressArrayItemByIndex(key, index);\\n  }\\n\\n  function getAddressArrayItemByIndexByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    uint256 index\\n  ) external view returns (address) {\\n    return s.getAddressArrayItemByIndex(_getKey(key1, key2), index);\\n  }\\n\\n  function getAddressArrayItemByIndexByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    uint256 index\\n  ) external view returns (address) {\\n    return s.getAddressArrayItemByIndex(_getKey(key1, key2, key3), index);\\n  }\\n\\n  function _getKey(bytes32 key1, bytes32 key2) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(key1, key2));\\n  }\\n\\n  function _getKey(\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(key1, key2, key3));\\n  }\\n\\n  function _getKey(bytes32 key, address account) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(key, account));\\n  }\\n\\n  function _getKey(\\n    bytes32 key1,\\n    bytes32 key2,\\n    address account\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(key1, key2, account));\\n  }\\n\\n  function setBytes32ArrayByKey(\\n    IStore s,\\n    bytes32 key,\\n    bytes32 value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.setBytes32ArrayItem(key, value);\\n  }\\n\\n  function setBytes32ArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 value\\n  ) external {\\n    return s.setBytes32ArrayItem(_getKey(key1, key2), value);\\n  }\\n\\n  function setBytes32ArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    bytes32 value\\n  ) external {\\n    return s.setBytes32ArrayItem(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function deleteBytes32ArrayByKey(\\n    IStore s,\\n    bytes32 key,\\n    bytes32 value\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.deleteBytes32ArrayItem(key, value);\\n  }\\n\\n  function deleteBytes32ArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 value\\n  ) external {\\n    return s.deleteBytes32ArrayItem(_getKey(key1, key2), value);\\n  }\\n\\n  function deleteBytes32ArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    bytes32 value\\n  ) external {\\n    return s.deleteBytes32ArrayItem(_getKey(key1, key2, key3), value);\\n  }\\n\\n  function deleteBytes32ArrayByIndexByKey(\\n    IStore s,\\n    bytes32 key,\\n    uint256 index\\n  ) external {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.deleteBytes32ArrayItemByIndex(key, index);\\n  }\\n\\n  function deleteBytes32ArrayByIndexByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    uint256 index\\n  ) external {\\n    return s.deleteBytes32ArrayItemByIndex(_getKey(key1, key2), index);\\n  }\\n\\n  function deleteBytes32ArrayByIndexByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    uint256 index\\n  ) external {\\n    return s.deleteBytes32ArrayItemByIndex(_getKey(key1, key2, key3), index);\\n  }\\n\\n  function countBytes32ArrayByKey(IStore s, bytes32 key) external view returns (uint256) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.countBytes32ArrayItems(key);\\n  }\\n\\n  function countBytes32ArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (uint256) {\\n    return s.countBytes32ArrayItems(_getKey(key1, key2));\\n  }\\n\\n  function countBytes32ArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external view returns (uint256) {\\n    return s.countBytes32ArrayItems(_getKey(key1, key2, key3));\\n  }\\n\\n  function getBytes32ArrayByKey(IStore s, bytes32 key) external view returns (bytes32[] memory) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getBytes32Array(key);\\n  }\\n\\n  function getBytes32ArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2\\n  ) external view returns (bytes32[] memory) {\\n    return s.getBytes32Array(_getKey(key1, key2));\\n  }\\n\\n  function getBytes32ArrayByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3\\n  ) external view returns (bytes32[] memory) {\\n    return s.getBytes32Array(_getKey(key1, key2, key3));\\n  }\\n\\n  function getBytes32ArrayItemPositionByKey(\\n    IStore s,\\n    bytes32 key,\\n    bytes32 bytes32ToFind\\n  ) external view returns (uint256) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getBytes32ArrayItemPosition(key, bytes32ToFind);\\n  }\\n\\n  function getBytes32ArrayItemPositionByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 bytes32ToFind\\n  ) external view returns (uint256) {\\n    return s.getBytes32ArrayItemPosition(_getKey(key1, key2), bytes32ToFind);\\n  }\\n\\n  function getBytes32ArrayItemPositionByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    bytes32 bytes32ToFind\\n  ) external view returns (uint256) {\\n    return s.getBytes32ArrayItemPosition(_getKey(key1, key2, key3), bytes32ToFind);\\n  }\\n\\n  function getBytes32ArrayItemByIndexByKey(\\n    IStore s,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (bytes32) {\\n    require(key > 0, \\\"Invalid key\\\");\\n    return s.getBytes32ArrayItemByIndex(key, index);\\n  }\\n\\n  function getBytes32ArrayItemByIndexByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    uint256 index\\n  ) external view returns (bytes32) {\\n    return s.getBytes32ArrayItemByIndex(_getKey(key1, key2), index);\\n  }\\n\\n  function getBytes32ArrayItemByIndexByKeys(\\n    IStore s,\\n    bytes32 key1,\\n    bytes32 key2,\\n    bytes32 key3,\\n    uint256 index\\n  ) external view returns (bytes32) {\\n    return s.getBytes32ArrayItemByIndex(_getKey(key1, key2, key3), index);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StrategyLibV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\n/* solhint-disable ordering  */\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"../interfaces/ILendingStrategy.sol\\\";\\nimport \\\"./PriceLibV1.sol\\\";\\nimport \\\"./RegistryLibV1.sol\\\";\\n\\nlibrary StrategyLibV1 {\\n  using ProtoUtilV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n  using RegistryLibV1 for IStore;\\n\\n  uint256 public constant DEFAULT_LENDING_PERIOD = 180 days;\\n  uint256 public constant DEFAULT_WITHDRAWAL_WINDOW = 7 days;\\n\\n  event StrategyAdded(address indexed strategy);\\n  event RiskPoolingPeriodSet(bytes32 indexed key, uint256 lendingPeriod, uint256 withdrawalWindow);\\n  event MaxLendingRatioSet(uint256 ratio);\\n\\n  /**\\n   * @dev Hash key of the \\\"active strategy flag\\\".\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param strategyAddress Enter a strategy address\\n   *\\n   */\\n  function _getIsActiveStrategyKey(address strategyAddress) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_ACTIVE, strategyAddress));\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"disabled strategy flag\\\".\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param strategyAddress Enter a strategy address\\n   *\\n   */\\n  function _getIsDisabledStrategyKey(address strategyAddress) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_DISABLED, strategyAddress));\\n  }\\n\\n  /**\\n   * @dev Disables a strategy\\n   *\\n   * @custom:suppress-address-trust-issue The address `toFind` can be trusted since we are not treating it like a contract.\\n   *\\n   */\\n  function disableStrategyInternal(IStore s, address toFind) external {\\n    _disableStrategy(s, toFind);\\n\\n    s.setAddressArrayByKey(ProtoUtilV1.NS_LENDING_STRATEGY_DISABLED, toFind);\\n  }\\n\\n  /**\\n   * @dev Deletes a strategy\\n   *\\n   * @custom:suppress-address-trust-issue The address `toFind` can be trusted since we are not treating it like a contract.\\n   *\\n   */\\n  function deleteStrategyInternal(IStore s, address toFind) external {\\n    _deleteStrategy(s, toFind);\\n  }\\n\\n  function addStrategiesInternal(IStore s, address[] calldata strategies) external {\\n    for (uint256 i = 0; i < strategies.length; i++) {\\n      address strategy = strategies[i];\\n      _addStrategy(s, strategy);\\n    }\\n  }\\n\\n  function getRiskPoolingPeriodsInternal(IStore s, bytes32 coverKey) external view returns (uint256 lendingPeriod, uint256 withdrawalWindow) {\\n    lendingPeriod = s.getUintByKey(getLendingPeriodKeyInternal(coverKey));\\n    withdrawalWindow = s.getUintByKey(getWithdrawalWindowKeyInternal(coverKey));\\n\\n    if (lendingPeriod == 0) {\\n      lendingPeriod = s.getUintByKey(getLendingPeriodKeyInternal(0));\\n      withdrawalWindow = s.getUintByKey(getWithdrawalWindowKeyInternal(0));\\n    }\\n\\n    lendingPeriod = lendingPeriod == 0 ? DEFAULT_LENDING_PERIOD : lendingPeriod;\\n    withdrawalWindow = withdrawalWindow == 0 ? DEFAULT_WITHDRAWAL_WINDOW : withdrawalWindow;\\n  }\\n\\n  function setRiskPoolingPeriodsInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    uint256 lendingPeriod,\\n    uint256 withdrawalWindow\\n  ) external {\\n    s.setUintByKey(getLendingPeriodKeyInternal(coverKey), lendingPeriod);\\n    s.setUintByKey(getWithdrawalWindowKeyInternal(coverKey), withdrawalWindow);\\n\\n    emit RiskPoolingPeriodSet(coverKey, lendingPeriod, withdrawalWindow);\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"lending period\\\" for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getLendingPeriodKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    if (coverKey > 0) {\\n      return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_LIQUIDITY_LENDING_PERIOD, coverKey));\\n    }\\n\\n    return ProtoUtilV1.NS_COVER_LIQUIDITY_LENDING_PERIOD;\\n  }\\n\\n  function getMaxLendingRatioInternal(IStore s) external view returns (uint256) {\\n    return s.getUintByKey(getMaxLendingRatioKeyInternal());\\n  }\\n\\n  function setMaxLendingRatioInternal(IStore s, uint256 ratio) external {\\n    s.setUintByKey(getMaxLendingRatioKeyInternal(), ratio);\\n\\n    emit MaxLendingRatioSet(ratio);\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"maximum lending ratio\\\" for the given cover.\\n   */\\n  function getMaxLendingRatioKeyInternal() public pure returns (bytes32) {\\n    return ProtoUtilV1.NS_COVER_LIQUIDITY_MAX_LENDING_RATIO;\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"withdrawal window duration\\\" for the given cover.\\n   *\\n   * Warning: this function does not validate the cover key supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   *\\n   */\\n  function getWithdrawalWindowKeyInternal(bytes32 coverKey) public pure returns (bytes32) {\\n    if (coverKey > 0) {\\n      return keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_LIQUIDITY_WITHDRAWAL_WINDOW, coverKey));\\n    }\\n\\n    return ProtoUtilV1.NS_COVER_LIQUIDITY_WITHDRAWAL_WINDOW;\\n  }\\n\\n  function _addStrategy(IStore s, address deployedOn) private {\\n    ILendingStrategy strategy = ILendingStrategy(deployedOn);\\n    require(strategy.getWeight() <= ProtoUtilV1.MULTIPLIER, \\\"Weight too much\\\");\\n\\n    s.setBoolByKey(_getIsActiveStrategyKey(deployedOn), true);\\n    s.setAddressArrayByKey(ProtoUtilV1.NS_LENDING_STRATEGY_ACTIVE, deployedOn);\\n    emit StrategyAdded(deployedOn);\\n  }\\n\\n  function _disableStrategy(IStore s, address toFind) private {\\n    bytes32 key = ProtoUtilV1.NS_LENDING_STRATEGY_ACTIVE;\\n\\n    uint256 pos = s.getAddressArrayItemPosition(key, toFind);\\n    require(pos > 0, \\\"Invalid strategy\\\");\\n\\n    s.deleteAddressArrayItem(key, toFind);\\n    s.setBoolByKey(_getIsActiveStrategyKey(toFind), false);\\n    s.setBoolByKey(_getIsDisabledStrategyKey(toFind), true);\\n  }\\n\\n  function _deleteStrategy(IStore s, address toFind) private {\\n    bytes32 key = ProtoUtilV1.NS_LENDING_STRATEGY_DISABLED;\\n\\n    uint256 pos = s.getAddressArrayItemPosition(key, toFind);\\n    require(pos > 0, \\\"Invalid strategy\\\");\\n\\n    s.deleteAddressArrayItem(key, toFind);\\n    s.setBoolByKey(_getIsDisabledStrategyKey(toFind), false);\\n  }\\n\\n  function getDisabledStrategiesInternal(IStore s) external view returns (address[] memory strategies) {\\n    return s.getAddressArrayByKey(ProtoUtilV1.NS_LENDING_STRATEGY_DISABLED);\\n  }\\n\\n  function getActiveStrategiesInternal(IStore s) external view returns (address[] memory strategies) {\\n    return s.getAddressArrayByKey(ProtoUtilV1.NS_LENDING_STRATEGY_ACTIVE);\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"strategy outs\\\" for the given cover and token.\\n   *\\n   * Warning: this function does not validate the cover key and token supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param token Enter the token address\\n   *\\n   */\\n  function getStrategyOutKeyInternal(bytes32 coverKey, address token) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_VAULT_STRATEGY_OUT, coverKey, token));\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"outs\\\" to a specific strategy for the given cover and token.\\n   *\\n   * Warning: this function does not validate the cover key and token supplied.\\n   *\\n   * @param coverKey Enter cover key\\n   * @param token Enter the token address\\n   *\\n   */\\n  function getSpecificStrategyOutKeyInternal(\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    address token\\n  ) public pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_VAULT_STRATEGY_OUT, coverKey, strategyName, token));\\n  }\\n\\n  function getAmountInStrategiesInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    address token\\n  ) public view returns (uint256) {\\n    bytes32 k = getStrategyOutKeyInternal(coverKey, token);\\n    return s.getUintByKey(k);\\n  }\\n\\n  function getAmountInStrategyInternal(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    address token\\n  ) public view returns (uint256) {\\n    bytes32 k = getSpecificStrategyOutKeyInternal(coverKey, strategyName, token);\\n    return s.getUintByKey(k);\\n  }\\n\\n  function preTransferToStrategyInternal(\\n    IStore s,\\n    IERC20 token,\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    uint256 amount\\n  ) external {\\n    if (s.getStablecoinAddressInternal() != address(token)) {\\n      return;\\n    }\\n\\n    _addToStrategyOut(s, coverKey, address(token), amount);\\n    _addToSpecificStrategyOut(s, coverKey, strategyName, address(token), amount);\\n  }\\n\\n  function postReceiveFromStrategyInternal(\\n    IStore s,\\n    IERC20 token,\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    uint256 received\\n  ) external returns (uint256 income, uint256 loss) {\\n    if (s.getStablecoinAddressInternal() != address(token)) {\\n      return (income, loss);\\n    }\\n\\n    uint256 amountInThisStrategy = getAmountInStrategyInternal(s, coverKey, strategyName, address(token));\\n\\n    income = received > amountInThisStrategy ? received - amountInThisStrategy : 0;\\n    loss = received < amountInThisStrategy ? amountInThisStrategy - received : 0;\\n\\n    _reduceStrategyOut(s, coverKey, address(token), amountInThisStrategy);\\n    _clearSpecificStrategyOut(s, coverKey, strategyName, address(token));\\n\\n    _logIncomes(s, coverKey, strategyName, income, loss);\\n  }\\n\\n  function _addToStrategyOut(\\n    IStore s,\\n    bytes32 coverKey,\\n    address token,\\n    uint256 amountToAdd\\n  ) private {\\n    bytes32 k = getStrategyOutKeyInternal(coverKey, token);\\n    s.addUintByKey(k, amountToAdd);\\n  }\\n\\n  function _reduceStrategyOut(\\n    IStore s,\\n    bytes32 coverKey,\\n    address token,\\n    uint256 amount\\n  ) private {\\n    bytes32 k = getStrategyOutKeyInternal(coverKey, token);\\n    s.subtractUintByKey(k, amount);\\n  }\\n\\n  function _addToSpecificStrategyOut(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    address token,\\n    uint256 amountToAdd\\n  ) private {\\n    bytes32 k = getSpecificStrategyOutKeyInternal(coverKey, strategyName, token);\\n    s.addUintByKey(k, amountToAdd);\\n  }\\n\\n  function _clearSpecificStrategyOut(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    address token\\n  ) private {\\n    bytes32 k = getSpecificStrategyOutKeyInternal(coverKey, strategyName, token);\\n    s.deleteUintByKey(k);\\n  }\\n\\n  function _logIncomes(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 strategyName,\\n    uint256 income,\\n    uint256 loss\\n  ) private {\\n    // Overall Income\\n    s.addUintByKey(ProtoUtilV1.NS_VAULT_LENDING_INCOMES, income);\\n\\n    // By Cover\\n    s.addUintByKey(keccak256(abi.encodePacked(ProtoUtilV1.NS_VAULT_LENDING_INCOMES, coverKey)), income);\\n\\n    // By Cover on This Strategy\\n    s.addUintByKey(keccak256(abi.encodePacked(ProtoUtilV1.NS_VAULT_LENDING_INCOMES, coverKey, strategyName)), income);\\n\\n    // Overall Loss\\n    s.addUintByKey(ProtoUtilV1.NS_VAULT_LENDING_LOSSES, loss);\\n\\n    // By Cover\\n    s.addUintByKey(keccak256(abi.encodePacked(ProtoUtilV1.NS_VAULT_LENDING_LOSSES, coverKey)), loss);\\n\\n    // By Cover on This Strategy\\n    s.addUintByKey(keccak256(abi.encodePacked(ProtoUtilV1.NS_VAULT_LENDING_LOSSES, coverKey, strategyName)), loss);\\n  }\\n\\n  function getStablecoinOwnedByVaultInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\\n    address stablecoin = s.getStablecoinAddressInternal();\\n\\n    uint256 balance = IERC20(stablecoin).balanceOf(s.getVaultAddress(coverKey));\\n    uint256 inStrategies = getAmountInStrategiesInternal(s, coverKey, stablecoin);\\n\\n    return balance + inStrategies;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ValidationLibV1.sol\": {\r\n      \"content\": \"// Neptune Mutual Protocol (https://neptunemutual.com)\\n// SPDX-License-Identifier: BUSL-1.1\\n/* solhint-disable ordering  */\\npragma solidity ^0.8.0;\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/access/IAccessControl.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"../interfaces/IPausable.sol\\\";\\nimport \\\"../interfaces/ICxToken.sol\\\";\\nimport \\\"./GovernanceUtilV1.sol\\\";\\nimport \\\"./AccessControlLibV1.sol\\\";\\n\\nlibrary ValidationLibV1 {\\n  using CoverUtilV1 for IStore;\\n  using GovernanceUtilV1 for IStore;\\n  using ProtoUtilV1 for IStore;\\n  using RegistryLibV1 for IStore;\\n  using StoreKeyUtil for IStore;\\n\\n  /**\\n   * @dev Reverts if the protocol is paused\\n   */\\n  function mustNotBePaused(IStore s) public view {\\n    address protocol = s.getProtocolAddressInternal();\\n    require(IPausable(protocol).paused() == false, \\\"Protocol is paused\\\");\\n  }\\n\\n  /**\\n   * @dev Reverts if the cover or any of the cover's product is not normal.\\n   * @param coverKey Enter the cover key to check\\n   */\\n  function mustEnsureAllProductsAreNormal(IStore s, bytes32 coverKey) external view {\\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \\\"Cover does not exist\\\");\\n    require(s.isCoverNormalInternal(coverKey) == true, \\\"Status not normal\\\");\\n  }\\n\\n  /**\\n   * @dev Reverts if the key does not resolve in a valid cover contract\\n   * or if the cover is under governance.\\n   * @param coverKey Enter the cover key to check\\n   * @param productKey Enter the product key to check\\n   */\\n  function mustHaveNormalProductStatus(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \\\"Cover does not exist\\\");\\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.Normal, \\\"Status not normal\\\");\\n  }\\n\\n  /**\\n   * @dev Reverts if the key does not resolve in a valid cover contract.\\n   * @param coverKey Enter the cover key to check\\n   */\\n  function mustBeValidCoverKey(IStore s, bytes32 coverKey) external view {\\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \\\"Cover does not exist\\\");\\n  }\\n\\n  /**\\n   * @dev Reverts if the cover does not support creating products.\\n   * @param coverKey Enter the cover key to check\\n   */\\n  function mustSupportProducts(IStore s, bytes32 coverKey) external view {\\n    require(s.supportsProductsInternal(coverKey), \\\"Does not have products\\\");\\n  }\\n\\n  /**\\n   * @dev Reverts if the key does not resolve in a valid product of a cover contract.\\n   * @param coverKey Enter the cover key to check\\n   * @param productKey Enter the cover key to check\\n   */\\n  function mustBeValidProduct(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view {\\n    require(s.isValidProductInternal(coverKey, productKey), \\\"Product does not exist\\\");\\n  }\\n\\n  /**\\n   * @dev Reverts if the key resolves in an expired product.\\n   * @param coverKey Enter the cover key to check\\n   * @param productKey Enter the cover key to check\\n   */\\n  function mustBeActiveProduct(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view {\\n    require(s.isActiveProductInternal(coverKey, productKey), \\\"Product retired or deleted\\\");\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the cover owner\\n   * @param coverKey Enter the cover key to check\\n   * @param sender The `msg.sender` value\\n   */\\n  function mustBeCoverOwner(\\n    IStore s,\\n    bytes32 coverKey,\\n    address sender\\n  ) public view {\\n    bool isCoverOwner = s.getCoverOwnerInternal(coverKey) == sender;\\n    require(isCoverOwner, \\\"Forbidden\\\");\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the cover owner or the cover contract\\n   * @param coverKey Enter the cover key to check\\n   * @param sender The `msg.sender` value\\n   */\\n  function mustBeCoverOwnerOrCoverContract(\\n    IStore s,\\n    bytes32 coverKey,\\n    address sender\\n  ) external view {\\n    bool isCoverOwner = s.getCoverOwnerInternal(coverKey) == sender;\\n    bool isCoverContract = address(s.getCoverContract()) == sender;\\n\\n    require(isCoverOwner || isCoverContract, \\\"Forbidden\\\");\\n  }\\n\\n  function senderMustBeCoverOwnerOrAdmin(IStore s, bytes32 coverKey) external view {\\n    if (AccessControlLibV1.hasAccessInternal(s, AccessControlLibV1.NS_ROLES_ADMIN, msg.sender) == false) {\\n      mustBeCoverOwner(s, coverKey, msg.sender);\\n    }\\n  }\\n\\n  function senderMustBePolicyContract(IStore s) external view {\\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER_POLICY);\\n  }\\n\\n  function senderMustBePolicyManagerContract(IStore s) external view {\\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER_POLICY_MANAGER);\\n  }\\n\\n  function senderMustBeCoverContract(IStore s) external view {\\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER);\\n  }\\n\\n  function senderMustBeVaultContract(IStore s, bytes32 coverKey) external view {\\n    address vault = s.getVaultAddress(coverKey);\\n    require(msg.sender == vault, \\\"Forbidden\\\");\\n  }\\n\\n  function senderMustBeGovernanceContract(IStore s) external view {\\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_GOVERNANCE);\\n  }\\n\\n  function senderMustBeClaimsProcessorContract(IStore s) external view {\\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_CLAIM_PROCESSOR);\\n  }\\n\\n  function callerMustBeClaimsProcessorContract(IStore s, address caller) external view {\\n    s.callerMustBeExactContract(ProtoUtilV1.CNS_CLAIM_PROCESSOR, caller);\\n  }\\n\\n  function senderMustBeStrategyContract(IStore s) external view {\\n    bool senderIsStrategyContract = s.getBoolByKey(_getIsActiveStrategyKey(msg.sender));\\n    require(senderIsStrategyContract == true, \\\"Not a strategy contract\\\");\\n  }\\n\\n  function callerMustBeStrategyContract(IStore s, address caller) public view {\\n    bool isActive = s.getBoolByKey(_getIsActiveStrategyKey(caller));\\n    bool wasDisabled = s.getBoolByKey(_getIsDisabledStrategyKey(caller));\\n\\n    require(isActive == true || wasDisabled == true, \\\"Not a strategy contract\\\");\\n  }\\n\\n  function callerMustBeSpecificStrategyContract(\\n    IStore s,\\n    address caller,\\n    bytes32 strategyName\\n  ) external view {\\n    callerMustBeStrategyContract(s, caller);\\n    require(IMember(caller).getName() == strategyName, \\\"Access denied\\\");\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"active strategy flag\\\".\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param strategyAddress Enter a strategy address\\n   *\\n   */\\n  function _getIsActiveStrategyKey(address strategyAddress) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_ACTIVE, strategyAddress));\\n  }\\n\\n  /**\\n   * @dev Hash key of the \\\"disabled strategy flag\\\".\\n   *\\n   * Warning: this function does not validate the input arguments.\\n   *\\n   * @param strategyAddress Enter a strategy address\\n   *\\n   */\\n  function _getIsDisabledStrategyKey(address strategyAddress) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_DISABLED, strategyAddress));\\n  }\\n\\n  function senderMustBeProtocolMember(IStore s) external view {\\n    require(s.isProtocolMemberInternal(msg.sender), \\\"Forbidden\\\");\\n  }\\n\\n  function mustBeReporting(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.IncidentHappened, \\\"Not reporting\\\");\\n  }\\n\\n  function mustBeDisputed(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.FalseReporting, \\\"Not disputed\\\");\\n  }\\n\\n  function mustBeClaimable(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view {\\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.Claimable, \\\"Not claimable\\\");\\n  }\\n\\n  function mustBeClaimingOrDisputed(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    CoverUtilV1.ProductStatus status = s.getProductStatusInternal(coverKey, productKey);\\n\\n    bool claiming = status == CoverUtilV1.ProductStatus.Claimable;\\n    bool falseReporting = status == CoverUtilV1.ProductStatus.FalseReporting;\\n\\n    require(claiming || falseReporting, \\\"Not claimable nor disputed\\\");\\n  }\\n\\n  function mustBeReportingOrDisputed(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    CoverUtilV1.ProductStatus status = s.getProductStatusInternal(coverKey, productKey);\\n    bool incidentHappened = status == CoverUtilV1.ProductStatus.IncidentHappened;\\n    bool falseReporting = status == CoverUtilV1.ProductStatus.FalseReporting;\\n\\n    require(incidentHappened || falseReporting, \\\"Not reported nor disputed\\\");\\n  }\\n\\n  function mustBeBeforeResolutionDeadline(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\\n\\n    if (deadline > 0) {\\n      require(block.timestamp < deadline, \\\"Emergency resolution deadline over\\\"); // solhint-disable-line\\n    }\\n  }\\n\\n  function mustNotHaveResolutionDeadline(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\\n    require(deadline == 0, \\\"Resolution already has deadline\\\");\\n  }\\n\\n  function mustBeAfterResolutionDeadline(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view {\\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\\n    require(deadline > 0 && block.timestamp >= deadline, \\\"Still unresolved\\\"); // solhint-disable-line\\n  }\\n\\n  function mustBeAfterFinalization(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view {\\n    require(s.getBoolByKey(GovernanceUtilV1.getHasFinalizedKeyInternal(coverKey, productKey, incidentDate)), \\\"Incident not finalized\\\");\\n  }\\n\\n  function mustBeValidIncidentDate(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view {\\n    require(s.getActiveIncidentDateInternal(coverKey, productKey) == incidentDate, \\\"Invalid incident date\\\");\\n  }\\n\\n  function mustHaveDispute(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    bool hasDispute = s.getBoolByKey(GovernanceUtilV1.getHasDisputeKeyInternal(coverKey, productKey));\\n    require(hasDispute == true, \\\"Not disputed\\\");\\n  }\\n\\n  function mustNotHaveDispute(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    bool hasDispute = s.getBoolByKey(GovernanceUtilV1.getHasDisputeKeyInternal(coverKey, productKey));\\n    require(hasDispute == false, \\\"Already disputed\\\");\\n  }\\n\\n  function mustBeDuringReportingPeriod(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    require(s.getResolutionTimestampInternal(coverKey, productKey) >= block.timestamp, \\\"Reporting window closed\\\"); // solhint-disable-line\\n  }\\n\\n  function mustBeAfterReportingPeriod(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view {\\n    require(block.timestamp > s.getResolutionTimestampInternal(coverKey, productKey), \\\"Reporting still active\\\"); // solhint-disable-line\\n  }\\n\\n  function mustBeValidCxToken(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address cxToken,\\n    uint256 incidentDate\\n  ) public view {\\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER_CXTOKEN, cxToken) == true, \\\"Unknown cxToken\\\");\\n\\n    bytes32 COVER_KEY = ICxToken(cxToken).COVER_KEY(); // solhint-disable-line\\n    bytes32 PRODUCT_KEY = ICxToken(cxToken).PRODUCT_KEY(); // solhint-disable-line\\n\\n    require(coverKey == COVER_KEY && productKey == PRODUCT_KEY, \\\"Invalid cxToken\\\");\\n\\n    uint256 expires = ICxToken(cxToken).expiresOn();\\n    require(expires > incidentDate, \\\"Invalid or expired cxToken\\\");\\n  }\\n\\n  function mustBeValidClaim(\\n    IStore s,\\n    address account,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address cxToken,\\n    uint256 incidentDate,\\n    uint256 amount\\n  ) external view {\\n    mustBeSupportedProductOrEmpty(s, coverKey, productKey);\\n    mustBeValidCxToken(s, coverKey, productKey, cxToken, incidentDate);\\n    mustBeClaimable(s, coverKey, productKey);\\n    mustBeValidIncidentDate(s, coverKey, productKey, incidentDate);\\n    mustBeDuringClaimPeriod(s, coverKey, productKey);\\n    require(ICxToken(cxToken).getClaimablePolicyOf(account) >= amount, \\\"Claim exceeds your coverage\\\");\\n  }\\n\\n  function mustNotHaveUnstaken(\\n    IStore s,\\n    address account,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) public view {\\n    uint256 withdrawal = s.getReportingUnstakenAmountInternal(account, coverKey, productKey, incidentDate);\\n    require(withdrawal == 0, \\\"Already unstaken\\\");\\n  }\\n\\n  /**\\n   * @dev Validates your `unstakeWithoutClaim` arguments\\n   *\\n   * @custom:note This function is not intended be used and does not produce correct result\\n   * before an incident is finalized. Please use `validateUnstakeWithClaim` if you are accessing\\n   * this function after resolution and before finalization.\\n   */\\n  function validateUnstakeWithoutClaim(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external view {\\n    mustNotBePaused(s);\\n    mustBeSupportedProductOrEmpty(s, coverKey, productKey);\\n    mustNotHaveUnstaken(s, msg.sender, coverKey, productKey, incidentDate);\\n    mustBeAfterFinalization(s, coverKey, productKey, incidentDate);\\n  }\\n\\n  /**\\n   * @dev Validates your `unstakeWithClaim` arguments\\n   *\\n   * @custom:note This function is only intended be used after resolution and before finalization.\\n   * Please use `validateUnstakeWithoutClaim` if you are accessing\\n   * this function after finalization.\\n   */\\n  function validateUnstakeWithClaim(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    uint256 incidentDate\\n  ) external view {\\n    mustNotBePaused(s);\\n    mustBeSupportedProductOrEmpty(s, coverKey, productKey);\\n    mustNotHaveUnstaken(s, msg.sender, coverKey, productKey, incidentDate);\\n\\n    // If this reporting gets finalized, incident date will become invalid\\n    // meaning this execution will revert thereby restricting late comers\\n    // to access this feature. But they can still access `unstake` feature\\n    // to withdraw their stake.\\n    mustBeValidIncidentDate(s, coverKey, productKey, incidentDate);\\n\\n    // Before the deadline, emergency resolution can still happen\\n    // that may have an impact on the final decision. We, therefore, have to wait.\\n    mustBeAfterResolutionDeadline(s, coverKey, productKey);\\n  }\\n\\n  function mustBeDuringClaimPeriod(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view {\\n    uint256 beginsFrom = s.getUintByKeys(ProtoUtilV1.NS_CLAIM_BEGIN_TS, coverKey, productKey);\\n    uint256 expiresAt = s.getUintByKeys(ProtoUtilV1.NS_CLAIM_EXPIRY_TS, coverKey, productKey);\\n\\n    require(beginsFrom > 0, \\\"Invalid claim begin date\\\");\\n    require(expiresAt > beginsFrom, \\\"Invalid claim period\\\");\\n\\n    require(block.timestamp >= beginsFrom, \\\"Claim period hasn't begun\\\"); // solhint-disable-line\\n    require(block.timestamp <= expiresAt, \\\"Claim period has expired\\\"); // solhint-disable-line\\n  }\\n\\n  function mustBeAfterClaimExpiry(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    require(block.timestamp > s.getUintByKeys(ProtoUtilV1.NS_CLAIM_EXPIRY_TS, coverKey, productKey), \\\"Claim still active\\\"); // solhint-disable-line\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not whitelisted cover creator.\\n   */\\n  function senderMustBeWhitelistedCoverCreator(IStore s) external view {\\n    require(s.getAddressBooleanByKey(ProtoUtilV1.NS_COVER_CREATOR_WHITELIST, msg.sender), \\\"Not whitelisted\\\");\\n  }\\n\\n  function senderMustBeWhitelistedIfRequired(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey,\\n    address sender\\n  ) external view {\\n    bool supportsProducts = s.supportsProductsInternal(coverKey);\\n    bool required = supportsProducts ? s.checkIfProductRequiresWhitelistInternal(coverKey, productKey) : s.checkIfRequiresWhitelistInternal(coverKey);\\n\\n    if (required == false) {\\n      return;\\n    }\\n\\n    require(s.getAddressBooleanByKeys(ProtoUtilV1.NS_COVER_USER_WHITELIST, coverKey, productKey, sender), \\\"You are not whitelisted\\\");\\n  }\\n\\n  function mustBeSupportedProductOrEmpty(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) public view {\\n    bool hasProducts = s.supportsProductsInternal(coverKey);\\n\\n    hasProducts ? require(productKey > 0, \\\"Specify a product\\\") : require(productKey == 0, \\\"Invalid product\\\");\\n\\n    if (hasProducts) {\\n      mustBeValidProduct(s, coverKey, productKey);\\n      mustBeActiveProduct(s, coverKey, productKey);\\n    }\\n  }\\n\\n  function mustNotHavePolicyDisabled(\\n    IStore s,\\n    bytes32 coverKey,\\n    bytes32 productKey\\n  ) external view {\\n    require(!s.isPolicyDisabledInternal(coverKey, productKey), \\\"Policy purchase disabled\\\");\\n  }\\n\\n  function mustMaintainStablecoinThreshold(IStore s, uint256 amount) external view {\\n    uint256 stablecoinPrecision = s.getStablecoinPrecisionInternal();\\n\\n    require(amount >= ProtoUtilV1.MIN_LIQUIDITY * stablecoinPrecision, \\\"Liquidity is below threshold\\\");\\n    require(amount <= ProtoUtilV1.MAX_LIQUIDITY * stablecoinPrecision, \\\"Liquidity is above threshold\\\");\\n  }\\n\\n  function mustMaintainProposalThreshold(IStore s, uint256 amount) external view {\\n    uint256 stablecoinPrecision = s.getStablecoinPrecisionInternal();\\n\\n    require(amount >= ProtoUtilV1.MIN_PROPOSAL_AMOUNT * stablecoinPrecision, \\\"Proposal is below threshold\\\");\\n    require(amount <= ProtoUtilV1.MAX_PROPOSAL_AMOUNT * stablecoinPrecision, \\\"Proposal is above threshold\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/AccessControlLibV1.sol\": {\r\n        \"AccessControlLibV1\": \"0x405848de6da43460c73341bc27b1aee3abf428ee\"\r\n      },\r\n      \"contracts/libraries/BaseLibV1.sol\": {\r\n        \"BaseLibV1\": \"0x3def8f7843d024e9ef03d9db81626393d04f1c38\"\r\n      },\r\n      \"contracts/libraries/CoverUtilV1.sol\": {\r\n        \"CoverUtilV1\": \"0x91efe3e613d437752e169277e89c3c6aad7ac0f3\"\r\n      },\r\n      \"contracts/libraries/PolicyHelperV1.sol\": {\r\n        \"PolicyHelperV1\": \"0x64cff795cdf7527ece2b3a1fe06f3765310363f0\"\r\n      },\r\n      \"contracts/libraries/ProtoUtilV1.sol\": {\r\n        \"ProtoUtilV1\": \"0x1693cc00b92a8be4d2cfb8c87f5a134cd71c9de3\"\r\n      },\r\n      \"contracts/libraries/StrategyLibV1.sol\": {\r\n        \"StrategyLibV1\": \"0x7a429fea79cc5bb34a3e893c2ea7b0301be117fb\"\r\n      },\r\n      \"contracts/libraries/ValidationLibV1.sol\": {\r\n        \"ValidationLibV1\": \"0x2736f310069457abcb6f4173fc2eb48c4679caf0\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IStore\",\"name\":\"store\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"productKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coverDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToCover\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"referralCode\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IPolicy.PurchaseCoverArgs\",\"name\":\"args\",\"type\":\"tuple\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cxToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresOn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"policyId\",\"type\":\"uint256\"}],\"name\":\"CoverPurchased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"}],\"name\":\"getAvailableLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"productKey\",\"type\":\"bytes32\"}],\"name\":\"getCommitment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"productKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coverDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToCover\",\"type\":\"uint256\"}],\"name\":\"getCoverFeeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAvailableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"internalType\":\"struct IPolicy.CoverFeeInfoType\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"productKey\",\"type\":\"bytes32\"}],\"name\":\"getCoverPoolSummary\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountInPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCommitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reassuranceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reassurancePoolWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productCapitalEfficiency\",\"type\":\"uint256\"}],\"internalType\":\"struct IPolicy.CoverPoolSummaryType\",\"name\":\"summary\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"productKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coverDuration\",\"type\":\"uint256\"}],\"name\":\"getCxToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cxToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"productKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"}],\"name\":\"getCxTokenByExpiryDate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cxToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"today\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverDuration\",\"type\":\"uint256\"}],\"name\":\"getExpiryDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"productKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coverDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToCover\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"referralCode\",\"type\":\"bytes32\"}],\"internalType\":\"struct IPolicy.PurchaseCoverArgs\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"purchaseCover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"coverKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"productKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coverDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToCover\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"referralCode\",\"type\":\"bytes32\"}],\"internalType\":\"struct IPolicy.PurchaseCoverArgs[]\",\"name\":\"args\",\"type\":\"tuple[]\"}],\"name\":\"purchaseCovers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"recoverEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s\",\"outputs\":[{\"internalType\":\"contract IStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Policy", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000006579df8f986e4a982f200dafa0c1b955a438f620", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}