{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Reflecto.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libs/IBEP20.sol\\\";\\nimport \\\"./libs/Auth.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\nimport \\\"./libs/IDEX.sol\\\";\\nimport \\\"./DistributorFactory.sol\\\";\\nimport \\\"./DividendDistributor.sol\\\";\\n\\ncontract Reflecto is IBEP20, Auth {\\n    using SafeMath for uint256;\\n\\n    uint256 public constant MASK = type(uint128).max;\\n    address BUSD;\\n    address Crypter;\\n    address public WBNB;\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\n    address DEAD_NON_CHECKSUM = 0x000000000000000000000000000000000000dEaD;\\n\\n    string constant _name = \\\"REFLECTO\\\";\\n    string constant _symbol = \\\"REFLECTO\\\";\\n    uint8 constant _decimals = 9;\\n\\n    uint256 _totalSupply = 1_000_000_000_000_000 * (10**_decimals);\\n    uint256 public _maxTxAmount = _totalSupply.div(400); // 0.25%\\n\\n    mapping(address => uint256) _balances;\\n    mapping(address => uint256) public nonces;\\n    mapping(address => mapping(address => uint256)) _allowances;\\n\\n    mapping(address => bool) isFeeExempt;\\n    mapping(address => bool) isTxLimitExempt;\\n    mapping(address => bool) isDividendExempt;\\n\\n    uint256 liquidityFee = 400;\\n    uint256 buybackFee = 200;\\n    uint256 gasWalletFee = 100;\\n    uint256 reflectionFee = 1000;\\n    uint256 marketingFee = 300;\\n    uint256 totalFee = 2000;\\n    uint256 feeDenominator = 10000;\\n\\n    address public autoLiquidityReceiver;\\n    address public marketingFeeReceiver;\\n    address public gasWalletFeeReceiver;\\n\\n    uint256 targetLiquidity = 25;\\n    uint256 targetLiquidityDenominator = 100;\\n\\n    IDEXRouter public router;\\n    address public pair;\\n\\n    uint256 public launchedAt;\\n    uint256 public launchedAtTimestamp;\\n\\n    uint256 buybackMultiplierNumerator = 200;\\n    uint256 buybackMultiplierDenominator = 100;\\n    uint256 buybackMultiplierTriggeredAt;\\n    uint256 buybackMultiplierLength = 30 minutes;\\n\\n    bool public autoBuybackEnabled = false;\\n    mapping(address => bool) buyBacker;\\n    uint256 autoBuybackCap;\\n    uint256 autoBuybackAccumulator;\\n    uint256 autoBuybackAmount;\\n    uint256 autoBuybackBlockPeriod;\\n    uint256 autoBuybackBlockLast;\\n\\n    DistributorFactory distributor;\\n    // address public distributorAddress;\\n    uint256 distributorGas = 500000;\\n\\n    // --- EIP712 niceties ---\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\\n\\n    bool public swapEnabled = true;\\n    uint256 public swapThreshold = _totalSupply / 2000; // 0.005%\\n    bool inSwap;\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    constructor(address _dexRouter, address _WBNBinput) Auth(msg.sender) {\\n        WBNB = _WBNBinput;\\n\\n        router = IDEXRouter(_dexRouter);\\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\\n        _allowances[address(this)][address(router)] = _totalSupply;\\n        WBNB = router.WETH();\\n        distributor = new DistributorFactory();\\n\\n        isFeeExempt[msg.sender] = true;\\n        isTxLimitExempt[msg.sender] = true;\\n        isDividendExempt[pair] = true;\\n        isDividendExempt[address(this)] = true;\\n        isDividendExempt[DEAD] = true;\\n        buyBacker[msg.sender] = true;\\n\\n        autoLiquidityReceiver = msg.sender;\\n        marketingFeeReceiver = msg.sender;\\n        gasWalletFeeReceiver = msg.sender;\\n\\n        approve(_dexRouter, _totalSupply);\\n        approve(address(pair), _totalSupply);\\n        _balances[msg.sender] = _totalSupply;\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(_name)),\\n                keccak256(bytes(version())),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\n    }\\n\\n    function getDistributorFactory()\\n        external\\n        view\\n        returns (DistributorFactory)\\n    {\\n        return distributor;\\n    }\\n\\n    function addDistributor(\\n        address _dexRouter,\\n        address _BEP_TOKEN,\\n        address _WBNB\\n    ) external authorized {\\n        distributor.addDistributor(_dexRouter, _BEP_TOKEN, _WBNB);\\n    }\\n\\n    function deleteDistributor(address _BEP_TOKEN) external authorized {\\n        distributor.deleteDistributor(_BEP_TOKEN);\\n    }\\n\\n    function getDistributersBEP20Keys()\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        return distributor.getDistributorsAddresses();\\n    }\\n\\n    function getDistributer(address _BEP_TOKEN)\\n        external\\n        view\\n        returns (DividendDistributor)\\n    {\\n        return distributor.getDistributor(_BEP_TOKEN);\\n    }\\n\\n    function getTotalDividends(address _BEP_TOKEN)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        DividendDistributor singleDistributor = distributor.getDistributor(\\n            _BEP_TOKEN\\n        );\\n        return singleDistributor.totalDividends();\\n    }\\n\\n    /// @dev Setting the version as a function so that it can be overriden\\n    function version() public pure virtual returns (string memory) {\\n        return \\\"1\\\";\\n    }\\n\\n    function getChainID() external view returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    receive() external payable {}\\n\\n    function donate() external payable {}\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return owner;\\n    }\\n\\n    modifier onlyBuybacker() {\\n        require(buyBacker[msg.sender] == true, \\\"\\\");\\n        _;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address holder, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, _totalSupply);\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        return _transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (_allowances[sender][msg.sender] != _totalSupply) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\\n                .sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        checkTxLimit(sender, amount);\\n        //\\n        if (shouldSwapBack()) {\\n            swapBack();\\n        }\\n        if (shouldAutoBuyback()) {\\n            triggerAutoBuyback();\\n        }\\n\\n        //        if(!launched() && recipient == pair){ require(_balances[sender] > 0); launch(); }\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n\\n        uint256 amountReceived = shouldTakeFee(sender)\\n            ? takeFee(sender, recipient, amount)\\n            : amount;\\n\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\n\\n        if (!isDividendExempt[sender]) {\\n            try distributor.setShare(sender, _balances[sender]) {} catch {}\\n        }\\n        if (!isDividendExempt[recipient]) {\\n            try\\n                distributor.setShare(recipient, _balances[recipient])\\n            {} catch {}\\n        }\\n\\n        try distributor.process(distributorGas) {} catch {}\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        //        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function checkTxLimit(address sender, uint256 amount) internal view {\\n        require(\\n            amount <= _maxTxAmount || isTxLimitExempt[sender],\\n            \\\"TX Limit Exceeded\\\"\\n        );\\n    }\\n\\n    function shouldTakeFee(address sender) internal view returns (bool) {\\n        return !isFeeExempt[sender];\\n    }\\n\\n    function getTotalFee(bool selling) public view returns (uint256) {\\n        if (launchedAt + 1 >= block.number) {\\n            return feeDenominator.sub(1);\\n        }\\n        if (selling) {\\n            return getMultipliedFee();\\n        }\\n        return totalFee;\\n    }\\n\\n    function getMultipliedFee() public view returns (uint256) {\\n        if (launchedAtTimestamp + 1 days > block.timestamp) {\\n            return totalFee.mul(18000).div(feeDenominator);\\n        } else if (\\n            buybackMultiplierTriggeredAt.add(buybackMultiplierLength) >\\n            block.timestamp\\n        ) {\\n            uint256 remainingTime = buybackMultiplierTriggeredAt\\n                .add(buybackMultiplierLength)\\n                .sub(block.timestamp);\\n            uint256 feeIncrease = totalFee\\n                .mul(buybackMultiplierNumerator)\\n                .div(buybackMultiplierDenominator)\\n                .sub(totalFee);\\n            return\\n                totalFee.add(\\n                    feeIncrease.mul(remainingTime).div(buybackMultiplierLength)\\n                );\\n        }\\n        return totalFee;\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        address receiver,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        uint256 feeAmount = amount.mul(getTotalFee(receiver == pair)).div(\\n            feeDenominator\\n        );\\n\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount.sub(feeAmount);\\n    }\\n\\n    function shouldSwapBack() internal view returns (bool) {\\n        return\\n            msg.sender != pair &&\\n            !inSwap &&\\n            swapEnabled &&\\n            _balances[address(this)] >= swapThreshold;\\n    }\\n\\n    function swapBack() internal swapping {\\n        uint256 dynamicLiquidityFee = isOverLiquified(\\n            targetLiquidity,\\n            targetLiquidityDenominator\\n        )\\n            ? 0\\n            : liquidityFee;\\n        uint256 amountToLiquify = swapThreshold\\n            .mul(dynamicLiquidityFee)\\n            .div(totalFee)\\n            .div(2);\\n        uint256 amountToSwap = swapThreshold.sub(amountToLiquify);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WBNB;\\n        uint256 balanceBefore = address(this).balance;\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\\n\\n        uint256 totalBNBFee = totalFee.sub(dynamicLiquidityFee.div(2));\\n\\n        uint256 amountBNBLiquidity = amountBNB\\n            .mul(dynamicLiquidityFee)\\n            .div(totalBNBFee)\\n            .div(2);\\n        uint256 amountBNBReflection = amountBNB.mul(reflectionFee).div(\\n            totalBNBFee\\n        );\\n\\n        uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(\\n            totalBNBFee\\n        );\\n        uint256 amountBNBGasWallet = amountBNB.mul(gasWalletFee).div(\\n            totalBNBFee\\n        );\\n\\n        try distributor.deposit{value: amountBNBReflection}() {} catch {}\\n        payable(marketingFeeReceiver).transfer(amountBNBMarketing);\\n        payable(gasWalletFeeReceiver).transfer(amountBNBGasWallet);\\n\\n        if (amountToLiquify > 0) {\\n            router.addLiquidityETH{value: amountBNBLiquidity}(\\n                address(this),\\n                amountToLiquify,\\n                0,\\n                0,\\n                autoLiquidityReceiver,\\n                block.timestamp\\n            );\\n            emit AutoLiquify(amountBNBLiquidity, amountToLiquify);\\n        }\\n    }\\n\\n    function shouldAutoBuyback() internal view returns (bool) {\\n        return\\n            msg.sender != pair &&\\n            !inSwap &&\\n            autoBuybackEnabled &&\\n            autoBuybackBlockLast + autoBuybackBlockPeriod <= block.number && // After N blocks from last buyback\\n            address(this).balance >= autoBuybackAmount;\\n    }\\n\\n    function triggerZeusBuyback(uint256 amount, bool triggerBuybackMultiplier)\\n        external\\n        authorized\\n    {\\n        buyTokens(amount, DEAD);\\n        if (triggerBuybackMultiplier) {\\n            buybackMultiplierTriggeredAt = block.timestamp;\\n            emit BuybackMultiplierActive(buybackMultiplierLength);\\n        }\\n    }\\n\\n    function clearBuybackMultiplier() external authorized {\\n        buybackMultiplierTriggeredAt = 0;\\n    }\\n\\n    function triggerAutoBuyback() internal {\\n        buyTokens(autoBuybackAmount, DEAD);\\n        autoBuybackBlockLast = block.number;\\n        autoBuybackAccumulator = autoBuybackAccumulator.add(autoBuybackAmount);\\n        if (autoBuybackAccumulator > autoBuybackCap) {\\n            autoBuybackEnabled = false;\\n        }\\n    }\\n\\n    function buyTokens(uint256 amount, address to) internal swapping {\\n        address[] memory path = new address[](2);\\n        path[0] = WBNB;\\n        path[1] = address(this);\\n\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n            value: amount\\n        }(0, path, to, block.timestamp);\\n    }\\n\\n    function setAutoBuybackSettings(\\n        bool _enabled,\\n        uint256 _cap,\\n        uint256 _amount,\\n        uint256 _period\\n    ) external authorized {\\n        autoBuybackEnabled = _enabled;\\n        autoBuybackCap = _cap;\\n        autoBuybackAccumulator = 0;\\n        autoBuybackAmount = _amount;\\n        autoBuybackBlockPeriod = _period;\\n        autoBuybackBlockLast = block.number;\\n    }\\n\\n    function setBuybackMultiplierSettings(\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 length\\n    ) external authorized {\\n        require(numerator / denominator <= 2 && numerator > denominator);\\n        buybackMultiplierNumerator = numerator;\\n        buybackMultiplierDenominator = denominator;\\n        buybackMultiplierLength = length;\\n    }\\n\\n    function launched() internal view returns (bool) {\\n        return launchedAt != 0;\\n    }\\n\\n    function launch() public authorized {\\n        require(launchedAt == 0, \\\"Already launched boi\\\");\\n        launchedAt = block.number;\\n        launchedAtTimestamp = block.timestamp;\\n    }\\n\\n    function setTxLimit(uint256 amount) external authorized {\\n        require(amount >= _totalSupply / 1000);\\n        _maxTxAmount = amount;\\n    }\\n\\n    function setIsDividendExempt(address holder, bool exempt)\\n        external\\n        authorized\\n    {\\n        require(holder != address(this) && holder != pair);\\n        isDividendExempt[holder] = exempt;\\n        if (exempt) {\\n            distributor.setShare(holder, 0);\\n        } else {\\n            distributor.setShare(holder, _balances[holder]);\\n        }\\n    }\\n\\n    function setIsFeeExempt(address holder, bool exempt) external authorized {\\n        isFeeExempt[holder] = exempt;\\n    }\\n\\n    function setIsTxLimitExempt(address holder, bool exempt)\\n        external\\n        authorized\\n    {\\n        isTxLimitExempt[holder] = exempt;\\n    }\\n\\n    function setFees(\\n        uint256 _liquidityFee,\\n        uint256 _buybackFee,\\n        uint256 _gasWalletFee,\\n        uint256 _reflectionFee,\\n        uint256 _marketingFee,\\n        uint256 _feeDenominator\\n    ) external authorized {\\n        liquidityFee = _liquidityFee;\\n        buybackFee = _buybackFee;\\n        reflectionFee = _reflectionFee;\\n        marketingFee = _marketingFee;\\n        gasWalletFee = _gasWalletFee;\\n        totalFee = _liquidityFee\\n            .add(_buybackFee)\\n            .add(_reflectionFee)\\n            .add(_marketingFee)\\n            .add(gasWalletFee);\\n        feeDenominator = _feeDenominator;\\n        require(totalFee < feeDenominator / 4);\\n    }\\n\\n    function setFeeReceivers(\\n        address _autoLiquidityReceiver,\\n        address _marketingFeeReceiver,\\n        address _gasWalletReceiver\\n    ) external authorized {\\n        autoLiquidityReceiver = _autoLiquidityReceiver;\\n        marketingFeeReceiver = _marketingFeeReceiver;\\n        gasWalletFeeReceiver = _gasWalletReceiver;\\n    }\\n\\n    function setSwapBackSettings(bool _enabled, uint256 _amount)\\n        external\\n        authorized\\n    {\\n        swapEnabled = _enabled;\\n        swapThreshold = _amount;\\n    }\\n\\n    function setTargetLiquidity(uint256 _target, uint256 _denominator)\\n        external\\n        authorized\\n    {\\n        targetLiquidity = _target;\\n        targetLiquidityDenominator = _denominator;\\n    }\\n\\n    function setDistributionCriteria(\\n        address _BEP_TOKEN,\\n        uint256 _minPeriod,\\n        uint256 _minDistribution\\n    ) external authorized {\\n        distributor.setDistributionCriteria(\\n            _BEP_TOKEN,\\n            _minPeriod,\\n            _minDistribution\\n        );\\n    }\\n\\n    function setDistributorSettings(uint256 gas) external authorized {\\n        require(gas < 999999);\\n        distributorGas = gas;\\n    }\\n\\n    function getCirculatingSupply() public view returns (uint256) {\\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\\n    }\\n\\n    function getLiquidityBacking(uint256 accuracy)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\\n    }\\n\\n    function isOverLiquified(uint256 target, uint256 accuracy)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return getLiquidityBacking(accuracy) > target;\\n    }\\n\\n    /**\\n     * @dev Sets the allowance granted to `spender` by `owner`.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     */\\n    function _setAllowance(\\n        address owner,\\n        address spender,\\n        uint256 wad\\n    ) internal virtual returns (bool) {\\n        _allowances[owner][spender] = wad;\\n        emit Approval(owner, spender, wad);\\n\\n        return true;\\n    }\\n\\n    // --- Approve by signature ---\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        holder,\\n                        spender,\\n                        nonce,\\n                        expiry,\\n                        allowed\\n                    )\\n                )\\n            )\\n        );\\n\\n        require(holder != address(0), \\\"Reflecto/invalid-address-0\\\");\\n        require(\\n            holder == ecrecover(digest, v, r, s),\\n            \\\"Reflecto/invalid-permit\\\"\\n        );\\n        require(\\n            expiry == 0 || block.timestamp <= expiry,\\n            \\\"Reflecto/permit-expired\\\"\\n        );\\n        require(nonce == nonces[holder]++, \\\"Reflecto/invalid-nonce\\\");\\n        uint256 wad = allowed ? _totalSupply : 0;\\n        _setAllowance(holder, spender, wad);\\n    }\\n\\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\\n    event BuybackMultiplierActive(uint256 duration);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBEP20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function getOwner() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address _owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Auth {\\n    address internal owner;\\n    mapping(address => bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be contract owner\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"!OWNER\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be authorized\\n     */\\n    modifier authorized() {\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Authorize address. Owner only\\n     */\\n    function authorize(address adr) public onlyOwner {\\n        authorizations[adr] = true;\\n    }\\n\\n    /**\\n     * Remove address' authorization. Owner only\\n     */\\n    function unauthorize(address adr) public onlyOwner {\\n        authorizations[adr] = false;\\n    }\\n\\n    /**\\n     * Check if address is owner\\n     */\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    /**\\n     * Return address' authorization status\\n     */\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    /**\\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\\n     */\\n    function transferOwnership(address payable adr) public onlyOwner {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * SAFEMATH LIBRARY\\n */\\nlibrary SafeMath {\\n    function tryAdd(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function trySub(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function tryMul(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function tryDiv(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function tryMod(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/IDEX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IDEXFactory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/DistributorFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./DividendDistributor.sol\\\";\\nimport \\\"./libs/IBEP20.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\n\\ncontract DistributorFactory {\\n    using SafeMath for uint256;\\n    address _token;\\n\\n    struct structDistributors {\\n        DividendDistributor distributorAddress;\\n        uint256 index;\\n        string tokenName;\\n        bool exists;\\n    }\\n\\n    mapping(address => structDistributors) public distributorsMapping;\\n    address[] public distributorsArrayOfKeys;\\n\\n    modifier onlyToken() {\\n        require(msg.sender == _token);\\n        _;\\n    }\\n\\n    constructor() {\\n        _token = msg.sender;\\n    }\\n\\n    function addDistributor(\\n        address _router,\\n        address _BEP_TOKEN,\\n        address _wbnb\\n    ) external onlyToken returns (bool) {\\n        require(\\n            !distributorsMapping[_BEP_TOKEN].exists,\\n            \\\"Reflecto/Distributor already exists\\\"\\n        );\\n\\n        IBEP20 BEP_TOKEN = IBEP20(_BEP_TOKEN);\\n        DividendDistributor distributor = new DividendDistributor(\\n            _router,\\n            _BEP_TOKEN,\\n            _wbnb\\n        );\\n\\n        distributorsArrayOfKeys.push(_BEP_TOKEN);\\n        distributorsMapping[_BEP_TOKEN].distributorAddress = distributor;\\n        distributorsMapping[_BEP_TOKEN].index =\\n            distributorsArrayOfKeys.length -\\n            1;\\n        distributorsMapping[_BEP_TOKEN].tokenName = BEP_TOKEN.name();\\n        distributorsMapping[_BEP_TOKEN].exists = true;\\n\\n        // set shares\\n        if (distributorsArrayOfKeys.length > 0) {\\n            address firstDistributerKey = distributorsArrayOfKeys[0];\\n\\n            uint256 shareholdersCount = distributorsMapping[firstDistributerKey]\\n                .distributorAddress\\n                .getShareholders()\\n                .length;\\n\\n            for (uint256 i = 0; i < shareholdersCount; i++) {\\n                address shareholderAddress = distributorsMapping[\\n                    firstDistributerKey\\n                ].distributorAddress.getShareholders()[i];\\n\\n                uint256 shareholderAmount = distributorsMapping[\\n                    firstDistributerKey\\n                ].distributorAddress.getShareholderAmount(shareholderAddress);\\n\\n                distributor.setShare(shareholderAddress, shareholderAmount);\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function getShareholderAmount(address _BEP_TOKEN, address shareholder)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            distributorsMapping[_BEP_TOKEN]\\n                .distributorAddress\\n                .getShareholderAmount(shareholder);\\n    }\\n\\n    function deleteDistributor(address _BEP_TOKEN)\\n        external\\n        onlyToken\\n        returns (bool)\\n    {\\n        require(\\n            distributorsMapping[_BEP_TOKEN].exists,\\n            \\\"Reflecto/Distributor not found\\\"\\n        );\\n\\n        structDistributors memory deletedDistributer = distributorsMapping[\\n            _BEP_TOKEN\\n        ];\\n        // if index is not the last entry\\n        if (deletedDistributer.index != distributorsArrayOfKeys.length - 1) {\\n            // delete distributorsArrayOfKeys[deletedDistributer.index];\\n            // last strucDistributer\\n            address lastAddress = distributorsArrayOfKeys[\\n                distributorsArrayOfKeys.length - 1\\n            ];\\n            distributorsArrayOfKeys[deletedDistributer.index] = lastAddress;\\n            distributorsMapping[lastAddress].index = deletedDistributer.index;\\n        }\\n        delete distributorsMapping[_BEP_TOKEN];\\n        distributorsArrayOfKeys.pop();\\n        return true;\\n    }\\n\\n    function getDistributorsAddresses() public view returns (address[] memory) {\\n        return distributorsArrayOfKeys;\\n    }\\n\\n    function setShare(address shareholder, uint256 amount) external onlyToken {\\n        uint256 arrayLength = distributorsArrayOfKeys.length;\\n        for (uint256 i = 0; i < arrayLength; i++) {\\n            distributorsMapping[distributorsArrayOfKeys[i]]\\n                .distributorAddress\\n                .setShare(shareholder, amount);\\n        }\\n    }\\n\\n    function process(uint256 gas) external onlyToken {\\n        uint256 arrayLength = distributorsArrayOfKeys.length;\\n        for (uint256 i = 0; i < arrayLength; i++) {\\n            distributorsMapping[distributorsArrayOfKeys[i]]\\n                .distributorAddress\\n                .process(gas);\\n        }\\n    }\\n\\n    function deposit() external payable onlyToken {\\n        uint256 arrayLength = distributorsArrayOfKeys.length;\\n        uint256 valuePerToken = msg.value.div(arrayLength);\\n\\n        for (uint256 i = 0; i < arrayLength; i++) {\\n            distributorsMapping[distributorsArrayOfKeys[i]]\\n                .distributorAddress\\n                .deposit{value: valuePerToken}();\\n        }\\n    }\\n\\n    function getDistributor(address _BEP_TOKEN)\\n        public\\n        view\\n        returns (DividendDistributor)\\n    {\\n        return distributorsMapping[_BEP_TOKEN].distributorAddress;\\n    }\\n\\n    function getTotalDistributers() public view returns (uint256) {\\n        return distributorsArrayOfKeys.length;\\n    }\\n\\n    function setDistributionCriteria(\\n        address _BEP_TOKEN,\\n        uint256 _minPeriod,\\n        uint256 _minDistribution\\n    ) external onlyToken {\\n        distributorsMapping[_BEP_TOKEN]\\n            .distributorAddress\\n            .setDistributionCriteria(_minPeriod, _minDistribution);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DividendDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libs/IDividendDistributor.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\nimport \\\"./libs/IBEP20.sol\\\";\\nimport \\\"./libs/IDEX.sol\\\";\\n\\ncontract DividendDistributor is IDividendDistributor {\\n    using SafeMath for uint256;\\n\\n    address _token;\\n\\n    struct Share {\\n        uint256 amount;\\n        uint256 totalExcluded;\\n        uint256 totalRealised;\\n    }\\n\\n    IBEP20 BEP_TOKEN;\\n\\n    address WBNB;\\n    IDEXRouter router;\\n\\n    address[] shareholders;\\n    mapping(address => uint256) shareholderIndexes;\\n    mapping(address => uint256) shareholderClaims;\\n\\n    mapping(address => Share) public shares;\\n\\n    uint256 public totalShares;\\n    uint256 public totalDividends;\\n    uint256 public totalDistributed;\\n    uint256 public dividendsPerShare;\\n    uint256 public dividendsPerShareAccuracyFactor = 10**36;\\n\\n    uint256 public minPeriod = 1 hours;\\n    uint256 public minDistribution = 1 * (10**18);\\n\\n    uint256 currentIndex;\\n\\n    bool initialized;\\n    modifier initialization() {\\n        require(!initialized);\\n        _;\\n        initialized = true;\\n    }\\n\\n    modifier onlyFactory() {\\n        require(msg.sender == _token);\\n        _;\\n    }\\n\\n    constructor(\\n        address _router,\\n        address _BEP_TOKEN,\\n        address _wbnb\\n    ) {\\n        router = _router != address(0)\\n            ? IDEXRouter(_router)\\n            : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        _token = msg.sender;\\n        BEP_TOKEN = IBEP20(_BEP_TOKEN);\\n        WBNB = _wbnb;\\n    }\\n\\n    function setDistributionCriteria(\\n        uint256 _minPeriod,\\n        uint256 _minDistribution\\n    ) external override onlyFactory {\\n        minPeriod = _minPeriod;\\n        minDistribution = _minDistribution;\\n    }\\n\\n    function setShare(address shareholder, uint256 amount)\\n        external\\n        override\\n        onlyFactory\\n    {\\n        if (shares[shareholder].amount > 0) {\\n            distributeDividend(shareholder);\\n        }\\n\\n        if (amount > 0 && shares[shareholder].amount == 0) {\\n            addShareholder(shareholder);\\n        } else if (amount == 0 && shares[shareholder].amount > 0) {\\n            removeShareholder(shareholder);\\n        }\\n\\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\n        shares[shareholder].amount = amount;\\n\\n        shares[shareholder].totalExcluded = getCumulativeDividends(\\n            shares[shareholder].amount\\n        );\\n    }\\n\\n    function deposit() external payable override onlyFactory {\\n        uint256 balanceBefore = BEP_TOKEN.balanceOf(address(this));\\n\\n        address[] memory path = new address[](2);\\n        path[0] = WBNB;\\n        path[1] = address(BEP_TOKEN);\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n            value: msg.value\\n        }(0, path, address(this), block.timestamp);\\n\\n        uint256 amount = BEP_TOKEN.balanceOf(address(this)).sub(balanceBefore);\\n\\n        totalDividends = totalDividends.add(amount);\\n        dividendsPerShare = dividendsPerShare.add(\\n            dividendsPerShareAccuracyFactor.mul(amount).div(totalShares)\\n        );\\n    }\\n\\n    function process(uint256 gas) external override onlyFactory {\\n        uint256 shareholderCount = shareholders.length;\\n\\n        if (shareholderCount == 0) {\\n            return;\\n        }\\n\\n        uint256 gasUsed = 0;\\n        uint256 gasLeft = gasleft();\\n\\n        uint256 iterations = 0;\\n\\n        while (gasUsed < gas && iterations < shareholderCount) {\\n            if (currentIndex >= shareholderCount) {\\n                currentIndex = 0;\\n            }\\n\\n            if (shouldDistribute(shareholders[currentIndex])) {\\n                distributeDividend(shareholders[currentIndex]);\\n            }\\n\\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\\n            gasLeft = gasleft();\\n            currentIndex++;\\n            iterations++;\\n        }\\n    }\\n\\n    function shouldDistribute(address shareholder)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return\\n            shareholderClaims[shareholder] + minPeriod < block.timestamp &&\\n            getUnpaidEarnings(shareholder) > minDistribution;\\n    }\\n\\n    function distributeDividend(address shareholder) internal {\\n        if (shares[shareholder].amount == 0) {\\n            return;\\n        }\\n\\n        uint256 amount = getUnpaidEarnings(shareholder);\\n\\n        if (amount > 0) {\\n            totalDistributed = totalDistributed.add(amount);\\n            BEP_TOKEN.transfer(shareholder, amount);\\n            shareholderClaims[shareholder] = block.timestamp;\\n            shares[shareholder].totalRealised = shares[shareholder]\\n                .totalRealised\\n                .add(amount);\\n            shares[shareholder].totalExcluded = getCumulativeDividends(\\n                shares[shareholder].amount\\n            );\\n        }\\n    }\\n\\n    function claimDividend() external {\\n        distributeDividend(msg.sender);\\n    }\\n\\n    function getUnpaidEarnings(address shareholder)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (shares[shareholder].amount == 0) {\\n            return 0;\\n        }\\n\\n        uint256 shareholderTotalDividends = getCumulativeDividends(\\n            shares[shareholder].amount\\n        );\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\n\\n        if (shareholderTotalDividends <= shareholderTotalExcluded) {\\n            return 0;\\n        }\\n\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\\n    }\\n\\n    function getCumulativeDividends(uint256 share)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\n    }\\n\\n    function addShareholder(address shareholder) internal {\\n        shareholderIndexes[shareholder] = shareholders.length;\\n        shareholders.push(shareholder);\\n    }\\n\\n    function getShareholders()\\n        external\\n        view\\n        onlyFactory\\n        returns (address[] memory)\\n    {\\n        return shareholders;\\n    }\\n\\n    function getShareholderAmount(address shareholder)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return shares[shareholder].amount;\\n    }\\n\\n    function removeShareholder(address shareholder) internal {\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[\\n            shareholders.length - 1\\n        ];\\n        shareholderIndexes[\\n            shareholders[shareholders.length - 1]\\n        ] = shareholderIndexes[shareholder];\\n        shareholders.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/IDividendDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IDividendDistributor {\\n    function setDistributionCriteria(\\n        uint256 _minPeriod,\\n        uint256 _minDistribution\\n    ) external;\\n\\n    function setShare(address shareholder, uint256 amount) external;\\n\\n    function deposit() external payable;\\n\\n    function process(uint256 gas) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WBNBinput\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"BuybackMultiplierActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_BEP_TOKEN\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WBNB\",\"type\":\"address\"}],\"name\":\"addDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoBuybackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearBuybackMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BEP_TOKEN\",\"type\":\"address\"}],\"name\":\"deleteDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasWalletFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BEP_TOKEN\",\"type\":\"address\"}],\"name\":\"getDistributer\",\"outputs\":[{\"internalType\":\"contract DividendDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributersBEP20Keys\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributorFactory\",\"outputs\":[{\"internalType\":\"contract DistributorFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMultipliedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BEP_TOKEN\",\"type\":\"address\"}],\"name\":\"getTotalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"selling\",\"type\":\"bool\"}],\"name\":\"getTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAtTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setAutoBuybackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"setBuybackMultiplierSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BEP_TOKEN\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setDistributorSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasWalletReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buybackFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasWalletFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reflectionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDenominator\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"setTargetLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"triggerBuybackMultiplier\",\"type\":\"bool\"}],\"name\":\"triggerZeusBuyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Reflecto", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}