{"SourceCode": "{\"Libraries.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IBEP20 {\\n  function totalSupply() external view returns (uint256);\\n  function decimals() external view returns (uint8);\\n  function symbol() external view returns (string memory);\\n  function name() external view returns (string memory);\\n  function getOwner() external view returns (address);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IPancakeFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IPancakeRouter {\\n   \\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n}\\n\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = msg.sender;\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n\\n\\n\\n\"},\"shiba2K22.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\nimport \\\"./Libraries.sol\\\";\\ncontract SHIBA2K22 is IBEP20, Ownable\\n{\\n  \\n    mapping (address =\\u003e uint) private _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) private _allowances;\\n    mapping(address =\\u003e bool) public excludedFromFees;\\n    mapping(address =\\u003e bool) public excludedFromLimit;\\n    mapping(address=\\u003ebool) public isAMM;\\n    //Token Info\\n    string private constant _name = \\u0027SHIBA2K22\\u0027;\\n    string private constant _symbol = \\u0027SHIBA22\\u0027;\\n    uint8 private constant _decimals = 18;\\n    uint public constant InitialSupply= 1*10**15 * 10**_decimals;//equals 1.000.000.000.000.000 Token (Quadrillion)\\n\\n    uint private constant DefaultLiquidityLockTime=2 days;\\n    //0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3 testnet router\\n    //0x10ED43C718714eb63d5aA57B78B54704E256024E mainnet router\\n\\n    address private constant PancakeRouter=0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n\\n    //variables that track balanceLimit and sellLimit,\\n    //can be updated based on circulating supply and Sell- and BalanceLimitDividers\\n    uint private _circulatingSupply =InitialSupply;\\n    \\n    //Tracks the current Taxes, different Taxes can be applied for buy/sell/transfer\\n    uint public buyTax = 100;\\n    uint public sellTax = 200;\\n    uint public transferTax = 0;\\n    uint public burnTax=0;\\n    uint public liquidityTax=100;\\n    uint public marketingTax=900;\\n    uint constant TAX_DENOMINATOR=1000;\\n    uint constant MAXTAXDENOMINATOR=10;\\n    \\n\\n    address private _pancakePairAddress; \\n    IPancakeRouter private  _pancakeRouter;\\n    \\n    \\n    //TODO: marketingWallet\\n    address public marketingWallet;\\n    //Only marketingWallet can change marketingWallet\\n    function ChangeMarketingWallet(address newWallet) public{\\n        require(msg.sender==marketingWallet);\\n        marketingWallet=newWallet;\\n    }\\n    //modifier for functions only the team can call\\n    modifier onlyTeam() {\\n        require(_isTeam(msg.sender), \\\"Caller not Team or Owner\\\");\\n        _;\\n    }\\n    //Checks if address is in Team, is needed to give Team access even if contract is renounced\\n    //Team doesn\\u0027t have access to critical Functions that could turn this into a Rugpull(Exept liquidity unlocks)\\n    function _isTeam(address addr) private view returns (bool){\\n        return addr==owner()||addr==marketingWallet;\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Constructor///////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    constructor () {\\n        uint deployerBalance=_circulatingSupply;\\n        _balances[msg.sender] = deployerBalance;\\n        emit Transfer(address(0), msg.sender, deployerBalance);\\n\\n        // Pancake Router\\n        _pancakeRouter = IPancakeRouter(PancakeRouter);\\n        //Creates a Pancake Pair\\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\\n        isAMM[_pancakePairAddress]=true;\\n        \\n        //contract creator is by default marketing wallet\\n        marketingWallet=msg.sender;\\n        //owner pancake router and contract is excluded from Taxes\\n        excludedFromFees[msg.sender]=true;\\n        excludedFromFees[PancakeRouter]=true;\\n        excludedFromFees[address(this)]=true;\\n    }\\n    \\n\\n\\n\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Transfer functionality////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    //transfer function, every transfer runs through this function\\n    function _transfer(address sender, address recipient, uint amount) private{\\n        require(sender != address(0), \\\"Transfer from zero\\\");\\n        require(recipient != address(0), \\\"Transfer to zero\\\");\\n\\n\\n        //Pick transfer\\n        if(excludedFromFees[sender] || excludedFromFees[recipient])\\n            _feelessTransfer(sender, recipient, amount);\\n        else if(excludedFromLimit[recipient]){ \\n            //once trading is enabled, it can\\u0027t be turned off again\\n            require(LaunchTimestamp\\u003e0,\\\"trading not yet enabled\\\");\\n            _LimitlessFonctionTransfer(sender,recipient,amount);                  \\n        }\\n        else { \\n            //once trading is enabled, it can\\u0027t be turned off again\\n            require(LaunchTimestamp\\u003e0,\\\"trading not yet enabled\\\");\\n            _taxedTransfer(sender,recipient,amount);                  \\n        }\\n    }\\n    \\n    //applies taxes, checks for limits, locks generates autoLP and stakingBNB, and autostakes\\n    function _taxedTransfer(address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        uint recipientBalance = _balances[recipient];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n        require((recipientBalance + amount ) \\u003c= InitialSupply/200, \\\"Wallet contain more than 0.5% Total Supply\\\");\\n\\n        bool isBuy=isAMM[sender];\\n        bool isSell=isAMM[recipient];\\n\\n        uint tax;\\n        if(isSell){  \\n            uint SellTaxDuration=180 seconds;          \\n            if(block.timestamp\\u003cLaunchTimestamp+SellTaxDuration){\\n                tax=_getStartTax(SellTaxDuration,999);\\n                }else tax=sellTax;\\n            }\\n        else if(isBuy){\\n            uint BuyTaxDuration=20 seconds;\\n            if(block.timestamp\\u003cLaunchTimestamp+BuyTaxDuration){\\n                tax=_getStartTax(BuyTaxDuration,999);\\n            }else tax=buyTax;\\n        } else tax=transferTax;\\n\\n        if((sender!=_pancakePairAddress)\\u0026\\u0026(!manualSwap)\\u0026\\u0026(!_isSwappingContractModifier))\\n            _swapContractToken(false);\\n\\n        //Calculates the exact token amount for each tax\\n        uint tokensToBeBurnt=_calculateFee(amount, tax, burnTax);\\n        //staking and liquidity Tax get treated the same, only during conversion they get split\\n        uint contractToken=_calculateFee(amount, tax, marketingTax+liquidityTax);\\n        //Subtract the Taxed Tokens from the amount\\n        uint taxedAmount=amount-(tokensToBeBurnt + contractToken);\\n\\n        _balances[sender]-=amount;\\n        //Adds the taxed tokens to the contract wallet\\n        _balances[address(this)] += contractToken;\\n        //Burns tokens\\n        _circulatingSupply-=tokensToBeBurnt;\\n        _balances[recipient]+=taxedAmount;\\n        \\n        emit Transfer(sender,recipient,taxedAmount);\\n    }\\n    //Start tax drops depending on the time since launch, enables bot protection and Dump protection\\n    function _getStartTax(uint duration, uint maxTax) private view returns (uint){\\n        uint timeSinceLaunch=block.timestamp-LaunchTimestamp;\\n        return maxTax-((maxTax-50)*timeSinceLaunch/duration);\\n    }\\n    //Calculates the token that should be taxed\\n    function _calculateFee(uint amount, uint tax, uint taxPercent) private pure returns (uint) {\\n        return (amount*tax*taxPercent) / (TAX_DENOMINATOR*TAX_DENOMINATOR);\\n    }\\n\\n\\n    //Feeless transfer only transfers and autostakes\\n    function _feelessTransfer(address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n        _balances[sender]-=amount;\\n        _balances[recipient]+=amount;      \\n        emit Transfer(sender,recipient,amount);\\n    }\\n///////////////////////////////Yeaaaah//////////addd\\n    function _LimitlessFonctionTransfer (address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n\\n        bool isBuy=isAMM[sender];\\n        bool isSell=isAMM[recipient];\\n\\n        uint tax;\\n        if(isSell){  \\n            uint SellTaxDuration=180 seconds;          \\n            if(block.timestamp\\u003cLaunchTimestamp+SellTaxDuration){\\n                tax=_getStartTax(SellTaxDuration,999);\\n                }else tax=sellTax;\\n            }\\n        else if(isBuy){\\n            uint BuyTaxDuration=20 seconds;\\n            if(block.timestamp\\u003cLaunchTimestamp+BuyTaxDuration){\\n                tax=_getStartTax(BuyTaxDuration,999);\\n            }else tax=buyTax;\\n        } else tax=transferTax;\\n\\n        if((sender!=_pancakePairAddress)\\u0026\\u0026(!manualSwap)\\u0026\\u0026(!_isSwappingContractModifier))\\n            _swapContractToken(false);\\n\\n        //Calculates the exact token amount for each tax\\n        uint tokensToBeBurnt=_calculateFee(amount, tax, burnTax);\\n        //staking and liquidity Tax get treated the same, only during conversion they get split\\n        uint contractToken=_calculateFee(amount, tax, marketingTax+liquidityTax);\\n        //Subtract the Taxed Tokens from the amount\\n        uint taxedAmount=amount-(tokensToBeBurnt + contractToken);\\n\\n        _balances[sender]-=amount;\\n        //Adds the taxed tokens to the contract wallet\\n        _balances[address(this)] += contractToken;\\n        //Burns tokens\\n        _circulatingSupply-=tokensToBeBurnt;\\n        _balances[recipient]+=taxedAmount;\\n        \\n        emit Transfer(sender,recipient,taxedAmount);\\n    }\\n    \\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Swap Contract Tokens//////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    \\n    //Locks the swap if already swapping\\n    bool private _isSwappingContractModifier;\\n    modifier lockTheSwap {\\n        _isSwappingContractModifier = true;\\n        _;\\n        _isSwappingContractModifier = false;\\n    }\\n\\n    //Sets the permille of pancake pair to trigger liquifying taxed token\\n    uint public swapTreshold=2;\\n    function setSwapTreshold(uint newSwapTresholdPermille) public onlyTeam{\\n        require(newSwapTresholdPermille\\u003c=15);//MaxTreshold= 1.5%\\n        swapTreshold=newSwapTresholdPermille;\\n    }\\n    //Sets the max Liquidity where swaps for Liquidity still happen\\n    uint public overLiquifyTreshold=150;\\n    function SetOverLiquifiedTreshold(uint newOverLiquifyTresholdPermille) public onlyTeam{\\n        require(newOverLiquifyTresholdPermille\\u003c=1000);\\n        overLiquifyTreshold=newOverLiquifyTresholdPermille;\\n    }\\n    //Sets the taxes Burn+marketing+liquidity tax needs to equal the TAX_DENOMINATOR (1000)\\n    //buy, sell and transfer tax are limited by the MAXTAXDENOMINATOR\\n    event OnSetTaxes(uint buy, uint sell, uint transfer_, uint burn, uint marketing,uint liquidity);\\n    function SetTaxes(uint buy, uint sell, uint transfer_, uint burn, uint marketing,uint liquidity) public onlyTeam{\\n        uint maxTax=3*(TAX_DENOMINATOR/MAXTAXDENOMINATOR);\\n        require(buy\\u003c=maxTax\\u0026\\u0026sell\\u003c=maxTax\\u0026\\u0026transfer_\\u003c=maxTax,\\\"Tax exceeds maxTax\\\");\\n        require(burn+marketing+liquidity==TAX_DENOMINATOR,\\\"Taxes don\\u0027t add up to denominator\\\");\\n        \\n        buyTax=buy;\\n        sellTax=sell;\\n        transferTax=transfer_;\\n        marketingTax=marketing;\\n        liquidityTax=liquidity;\\n        burnTax=burn;\\n        emit OnSetTaxes(buy, sell, transfer_, burn, marketing,liquidity);\\n    }\\n    \\n    //If liquidity is over the treshold, convert 100% of Token to Marketing BNB to avoid overliquifying\\n    function isOverLiquified() public view returns(bool){\\n        return _balances[_pancakePairAddress]\\u003e_circulatingSupply*overLiquifyTreshold/1000;\\n    }\\n\\n\\n    //swaps the token on the contract for Marketing BNB and LP Token.\\n    //always swaps a percentage of the LP pair balance to avoid price impact\\n    function _swapContractToken(bool ignoreLimits) private lockTheSwap{\\n        uint contractBalance=_balances[address(this)];\\n        uint totalTax=liquidityTax+marketingTax;\\n        //swaps each time it reaches swapTreshold of pancake pair to avoid large prize impact\\n        uint tokenToSwap=_balances[_pancakePairAddress]*swapTreshold/1000;\\n\\n        //nothing to swap at no tax\\n        if(totalTax==0)return;\\n        //only swap if contractBalance is larger than tokenToSwap, and totalTax is unequal to 0\\n        //Ignore limits swaps 100% of the contractBalance\\n        if(ignoreLimits)\\n            tokenToSwap=_balances[address(this)];\\n        else if(contractBalance\\u003ctokenToSwap)\\n            return;\\n\\n        //splits the token in TokenForLiquidity and tokenForMarketing\\n        //if over liquified, 0 tokenForLiquidity\\n        uint tokenForLiquidity=\\n        isOverLiquified()?0\\n        :(tokenToSwap*liquidityTax)/totalTax;\\n\\n        uint tokenForMarketing= tokenToSwap-tokenForLiquidity;\\n\\n        uint LiqHalf=tokenForLiquidity/2;\\n        //swaps marktetingToken and the liquidity token half for BNB\\n        uint swapToken=LiqHalf+tokenForMarketing;\\n        //Gets the initial BNB balance, so swap won\\u0027t touch any contract BNB\\n        uint initialBNBBalance = address(this).balance;\\n        _swapTokenForBNB(swapToken);\\n        uint newBNB=(address(this).balance - initialBNBBalance);\\n\\n        //calculates the amount of BNB belonging to the LP-Pair and converts them to LP\\n        if(tokenForLiquidity\\u003e0){\\n            uint liqBNB = (newBNB*LiqHalf)/swapToken;\\n            _addLiquidity(LiqHalf, liqBNB);\\n        }\\n        //Sends all the marketing BNB to the marketingWallet\\n        (bool sent,)=marketingWallet.call{value:address(this).balance}(\\\"\\\");\\n        sent=true;\\n    }\\n    //swaps tokens on the contract for BNB\\n    function _swapTokenForBNB(uint amount) private {\\n        _approve(address(this), address(_pancakeRouter), amount);\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _pancakeRouter.WETH();\\n\\n        try _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        ){}\\n        catch{}\\n    }\\n    //Adds Liquidity directly to the contract where LP are locked\\n    function _addLiquidity(uint tokenamount, uint bnbamount) private {\\n        _approve(address(this), address(_pancakeRouter), tokenamount);\\n        _pancakeRouter.addLiquidityETH{value: bnbamount}(\\n            address(this),\\n            tokenamount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //public functions /////////////////////////////////////////////////////////////////////////////////////\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////// \\n    function getLiquidityReleaseTimeInSeconds() public view returns (uint){\\n        if(block.timestamp\\u003c_liquidityUnlockTime)\\n            return _liquidityUnlockTime-block.timestamp;\\n        return 0;\\n    }\\n    function getBurnedTokens() public view returns(uint){\\n        return (InitialSupply-_circulatingSupply)+_balances[address(0xdead)];\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Settings//////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //For AMM addresses buy and sell taxes apply\\n    function SetAMM(address AMM, bool Add) public onlyTeam{\\n        require(AMM!=_pancakePairAddress,\\\"can\\u0027t change pancake\\\");\\n        isAMM[AMM]=Add;\\n    }\\n    \\n    bool public manualSwap;\\n    //switches autoLiquidity and marketing BNB generation during transfers\\n    function SwitchManualSwap(bool manual) public onlyTeam{\\n        manualSwap=manual;\\n    }\\n    //manually converts contract token to LP and staking BNB\\n    function SwapContractToken() public onlyTeam{\\n    _swapContractToken(true);\\n    }\\n    event ExcludeAccount(address account, bool exclude);\\n    //Exclude/Include account from fees (eg. CEX)\\n    function ExcludeAccountFromFees(address account, bool exclude) public onlyTeam{\\n        require(account!=address(this),\\\"can\\u0027t Include the contract\\\");\\n        excludedFromFees[account]=exclude;\\n        emit ExcludeAccount(account,exclude);\\n    }\\n\\n    /////////////moussss///////////\\n     event ExcludeAccountLimit(address account, bool exclude);\\n    //Exclude/Include account from fees (eg. CEX)\\n    function ExcludedFromLimit(address account, bool exclude) public onlyTeam{\\n        require(account!=address(this),\\\"can\\u0027t Include the contract\\\");\\n        excludedFromLimit[account]=exclude;\\n        emit ExcludeAccountLimit(account,exclude);\\n    }\\n\\n\\n\\n    //Enables trading. Sets the launch timestamp to the given Value\\n    event OnEnableTrading();\\n    uint public LaunchTimestamp;\\n    function SetupEnableTrading() public onlyTeam{\\n        require(LaunchTimestamp==0,\\\"AlreadyLaunched\\\");\\n        LaunchTimestamp=block.timestamp;\\n        emit OnEnableTrading();\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Liquidity Lock////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //the timestamp when Liquidity unlocks\\n    uint _liquidityUnlockTime;\\n    bool public LPReleaseLimitedTo20Percent;\\n    //Sets Liquidity Release to 20% at a time and prolongs liquidity Lock for a Week after Release. \\n    //That way autoLiquidity can be slowly released \\n    function limitLiquidityReleaseTo20Percent() public onlyTeam{\\n        LPReleaseLimitedTo20Percent=true;\\n    }\\n    //Locks Liquidity for seconds. can only be prolonged\\n    function LockLiquidityForSeconds(uint secondsUntilUnlock) public onlyTeam{\\n        _prolongLiquidityLock(secondsUntilUnlock+block.timestamp);\\n    }\\n    event OnProlongLPLock(uint UnlockTimestamp);\\n    function _prolongLiquidityLock(uint newUnlockTime) private{\\n        // require new unlock time to be longer than old one\\n        require(newUnlockTime\\u003e_liquidityUnlockTime);\\n        _liquidityUnlockTime=newUnlockTime;\\n        emit OnProlongLPLock(_liquidityUnlockTime);\\n    }\\n    event OnReleaseLP();\\n    //Release Liquidity Tokens once unlock time is over\\n    function LiquidityRelease() public onlyTeam {\\n        //Only callable if liquidity Unlock time is over\\n        require(block.timestamp \\u003e= _liquidityUnlockTime, \\\"Not yet unlocked\\\");\\n\\n        IBEP20 liquidityToken = IBEP20(_pancakePairAddress);\\n        uint amount = liquidityToken.balanceOf(address(this));\\n        if(LPReleaseLimitedTo20Percent)\\n        {\\n            _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\\n            //regular liquidity release, only releases 50% at a time and locks liquidity for another week\\n            amount=amount*2/10;\\n        }\\n        liquidityToken.transfer(msg.sender, amount);\\n        emit OnReleaseLP();\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //external//////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    receive() external payable {}\\n\\n    function getOwner() external view override returns (address) {\\n        return owner();\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() external view override returns (uint) {\\n        return _circulatingSupply;\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address spender) external view override returns (uint) {\\n        return _allowances[_owner][spender];\\n    }\\n\\n    function approve(address spender, uint amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n    function _approve(address owner, address spender, uint amount) private {\\n        require(owner != address(0), \\\"Approve from zero\\\");\\n        require(spender != address(0), \\\"Approve to zero\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint currentAllowance = _allowances[sender][msg.sender];\\n        require(currentAllowance \\u003e= amount, \\\"Transfer \\u003e allowance\\\");\\n\\n        _approve(sender, msg.sender, currentAllowance - amount);\\n        return true;\\n    }\\n\\n    // IBEP20 - Helpers\\n\\n    function increaseAllowance(address spender, uint addedValue) external returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\\n        uint currentAllowance = _allowances[msg.sender][spender];\\n        require(currentAllowance \\u003e= subtractedValue, \\\"\\u003c0 allowance\\\");\\n\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\n        return true;\\n    }\\n\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccountLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnEnableTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UnlockTimestamp\",\"type\":\"uint256\"}],\"name\":\"OnProlongLPLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnReleaseLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transfer_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"OnSetTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"ChangeMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccountFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludedFromLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InitialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LPReleaseLimitedTo20Percent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LaunchTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsUntilUnlock\",\"type\":\"uint256\"}],\"name\":\"LockLiquidityForSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"Add\",\"type\":\"bool\"}],\"name\":\"SetAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newOverLiquifyTresholdPermille\",\"type\":\"uint256\"}],\"name\":\"SetOverLiquifiedTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transfer_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"SetTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SetupEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SwapContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"manual\",\"type\":\"bool\"}],\"name\":\"SwitchManualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBurnedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityReleaseTimeInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAMM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitLiquidityReleaseTo20Percent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overLiquifyTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSwapTresholdPermille\",\"type\":\"uint256\"}],\"name\":\"setSwapTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SHIBA2K22", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5549b586870826bd791efea6b486db6aa6a0fffd7f3f70fea9fec9e80f9658eb"}