{"SourceCode": "{\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\ncontract ERC20Detailed is IERC20 {\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor(string name, string symbol, uint8 decimals) public {\\n    _name = name;\\n    _symbol = symbol;\\n    _decimals = decimals;\\n  }\\n\\n  /**\\n   * @return the name of the token.\\n   */\\n  function name() public view returns(string) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @return the symbol of the token.\\n   */\\n  function symbol() public view returns(string) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @return the number of decimals of the token.\\n   */\\n  function decimals() public view returns(uint8) {\\n    return _decimals;\\n  }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external view returns (uint256);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n    external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"},\"Ranking.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nlibrary school {\\r\\n  struct schoolData{\\r\\n    mapping(address =\\u003e uint256)  scores;\\r\\n    mapping(address =\\u003e address)  _nextStudents;\\r\\n    uint256  listSize;\\r\\n    \\r\\n    address  lastAddress;\\r\\n    uint256  lastScore;\\r\\n\\r\\n    uint256  limitRank ;\\r\\n  }\\r\\n\\r\\n  struct rankDetail {\\r\\n    address _address;\\r\\n    uint _number;\\r\\n  }\\r\\n\\r\\n  address constant GUARD = address(1);\\r\\n\\r\\n  function init(schoolData storage data) internal{\\r\\n      data._nextStudents[GUARD] = GUARD;\\r\\n  }\\r\\n\\r\\n  function addStudent(schoolData storage data,address student, uint256 score) internal returns(bool){\\r\\n    if(data.listSize \\u003e= data.limitRank  \\u0026\\u0026 score \\u003c= data.lastScore ){\\r\\n      return false;\\r\\n    }\\r\\n    require(data._nextStudents[student] == address(0));\\r\\n    data.scores[student] = score;\\r\\n \\r\\n      address index = _findIndex(data,score);\\r\\n      data._nextStudents[student] = data._nextStudents[index];\\r\\n      data._nextStudents[index] = student;\\r\\n\\r\\n      data.listSize++;\\r\\n\\r\\n      if(data.listSize \\u003c= data.limitRank){\\r\\n       if( data.lastScore==0 ){\\r\\n          data.lastAddress=student;\\r\\n          data.lastScore = score;\\r\\n        }else if (score \\u003c= data.lastScore){\\r\\n          data.lastAddress=student;\\r\\n          data.lastScore = score;\\r\\n        }\\r\\n      }else{\\r\\n          (address lastIndex,address preIndex) = _findLastStudent(data);\\r\\n          removeStudent(data,lastIndex);\\r\\n          data.lastScore = data.scores[preIndex];\\r\\n          data.lastAddress= preIndex;\\r\\n      }\\r\\n      return true;\\r\\n  }\\r\\n\\r\\n  function increaseScore(schoolData storage data,address student, uint256 score) internal {\\r\\n    updateScore(data,student, data.scores[student] + score);\\r\\n  }\\r\\n\\r\\n  function updateScore(schoolData storage data,address student, uint256 newScore) internal {\\r\\n    require(data._nextStudents[student] != address(0));\\r\\n    if (newScore\\u003edata.lastScore){\\r\\n      address prevStudent = _findPrevStudent(data,student);\\r\\n      address nextStudent = data._nextStudents[student];\\r\\n      if(_verifyIndex(data,prevStudent, newScore, nextStudent)){\\r\\n        data.scores[student] = newScore;\\r\\n      } else {\\r\\n        removeStudent(data,student);\\r\\n        addStudent(data,student, newScore);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeStudent(schoolData storage data,address student) internal {\\r\\n    require(data._nextStudents[student] != address(0));\\r\\n    address prevStudent = _findPrevStudent(data,student);\\r\\n    data._nextStudents[prevStudent] = data._nextStudents[student];\\r\\n    data._nextStudents[student] = address(0);\\r\\n    data.scores[student] = 0;\\r\\n    data.listSize--;\\r\\n    //\u5220\u9664\u7684\u662f\u6700\u540e\u4e00\u4e2a\u8282\u70b9\\r\\n    if (student == data.lastAddress){  \\r\\n        data.lastAddress = prevStudent;\\r\\n        data.lastScore = data.scores[prevStudent];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function getTop(schoolData storage data,uint256 k) internal view returns(address[] memory) {\\r\\n    require(k \\u003c= data.listSize);\\r\\n    address[] memory studentLists = new address[](k);\\r\\n    address currentAddress = data._nextStudents[GUARD];\\r\\n    for(uint256 i = 0; i \\u003c k; ++i) {\\r\\n      studentLists[i] = currentAddress;\\r\\n      currentAddress = data._nextStudents[currentAddress];\\r\\n    }\\r\\n    return studentLists;\\r\\n  }\\r\\n\\r\\n   function getTopValue(schoolData storage data,uint256 k) internal view returns(uint256[] memory) {\\r\\n    require(k \\u003c= data.listSize);\\r\\n    uint256[] memory studentLists = new uint256[](k);\\r\\n    address currentAddress = data._nextStudents[GUARD];\\r\\n    for(uint256 i = 0; i \\u003c k; ++i) {\\r\\n      studentLists[i] =  data.scores[currentAddress];\\r\\n      currentAddress = data._nextStudents[currentAddress];\\r\\n    }\\r\\n    return studentLists;\\r\\n  }\\r\\n\\r\\n\\r\\n  function getTopDetail(schoolData storage data,uint256 k) internal view returns(rankDetail[] memory) {\\r\\n    require(k \\u003c= data.listSize);\\r\\n    rankDetail[] memory studentLists = new rankDetail[](k);\\r\\n    address currentAddress = data._nextStudents[GUARD];\\r\\n    for(uint256 i = 0; i \\u003c k; ++i) {\\r\\n      studentLists[i]._address = currentAddress;\\r\\n      studentLists[i]._number = data.scores[currentAddress];\\r\\n      currentAddress = data._nextStudents[currentAddress];\\r\\n    }\\r\\n    return studentLists;\\r\\n  }\\r\\n  function getRankBefore(schoolData storage data,uint256 k) internal view returns(address) {\\r\\n    require(k \\u003c= data.listSize);\\r\\n    address restudent;\\r\\n    address currentAddress = data._nextStudents[GUARD];\\r\\n    require(currentAddress != address(0));\\r\\n    for(uint256 i = 0; i \\u003c k; ++i) {\\r\\n      if (i==k-1){\\r\\n        restudent = currentAddress;\\r\\n        break;\\r\\n      }\\r\\n      currentAddress = data._nextStudents[currentAddress];\\r\\n      if (currentAddress == address(0)){\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n    return restudent;\\r\\n  }\\r\\n\\r\\n  function getRankByAddress(schoolData storage data,address _user) internal view returns(uint256) {\\r\\n    address currentAddress = data._nextStudents[GUARD];\\r\\n    for(uint256 i = 0; i \\u003c data.listSize; ++i) {\\r\\n        if (_user==currentAddress){\\r\\n            return i+1;\\r\\n        } \\r\\n      currentAddress = data._nextStudents[currentAddress];\\r\\n    }\\r\\n    return 0;\\r\\n  }\\r\\n\\r\\n  function _verifyIndex(schoolData storage data,address prevStudent, uint256 newValue, address nextStudent)\\r\\n    internal\\r\\n    view\\r\\n    returns(bool)\\r\\n  {\\r\\n    return (prevStudent == GUARD || data.scores[prevStudent] \\u003e= newValue) \\u0026\\u0026\\r\\n           (nextStudent == GUARD || newValue \\u003e data.scores[nextStudent]);\\r\\n  }\\r\\n\\r\\n  function _findIndex(schoolData storage data,uint256 newValue) internal view returns(address) {\\r\\n    address candidateAddress = GUARD;\\r\\n    while(true) {\\r\\n      if(_verifyIndex(data,candidateAddress, newValue, data._nextStudents[candidateAddress]))\\r\\n        return candidateAddress;\\r\\n      candidateAddress = data._nextStudents[candidateAddress];\\r\\n    }\\r\\n    return address(0);\\r\\n  }\\r\\n\\r\\n  function _isPrevStudent(schoolData storage data,address student, address prevStudent) internal view returns(bool) {\\r\\n    return data._nextStudents[prevStudent] == student;\\r\\n  }\\r\\n\\r\\n  function _findPrevStudent(schoolData storage data,address student) internal view returns(address) {\\r\\n    address currentAddress = GUARD;\\r\\n    while(data._nextStudents[currentAddress] != GUARD) {\\r\\n      if(_isPrevStudent(data,student, currentAddress))\\r\\n        return currentAddress;\\r\\n      currentAddress = data._nextStudents[currentAddress];\\r\\n    }\\r\\n    return address(0);\\r\\n  }\\r\\n\\r\\n  function _findLastStudent(schoolData storage data) internal view returns(address,address) {\\r\\n      address currentAddress = GUARD;\\r\\n      address preAddress;\\r\\n      while(data._nextStudents[currentAddress] != GUARD) {\\r\\n        preAddress=currentAddress;\\r\\n        currentAddress = data._nextStudents[currentAddress];\\r\\n      }\\r\\n      return (currentAddress ,preAddress);\\r\\n  }\\r\\n}\"},\"Roster.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nlibrary Roster {\\n    using SafeMath for uint256;\\n\\n    event Set(address,uint);\\n    event Remove(address,uint);\\n    struct roster {\\n        mapping(address=\\u003ebool) data;\\n        mapping(address=\\u003eaddress) next;\\n        uint length;\\n        address firstAddress;\\n    }\\n\\n    //List details\\n    function details(roster storage obj) internal view returns(address[] memory){\\n        address[] memory res = new address[](obj.length);\\n        if (obj.firstAddress == address(0)){\\n            return res;\\n        }\\n        address curraddress = obj.firstAddress;\\n        res[0] = curraddress;\\n        uint index = 1;\\n        while ( obj.next[curraddress] != address(0)){\\n            res[index] = obj.next[curraddress];\\n            curraddress = obj.next[curraddress];\\n            index = index.add(1);\\n        }\\n        return res;\\n    }\\n    //set  Roster\\n    function set(roster storage obj,address _address,uint _extend ) internal {\\n        require(_address != address(0),\\\"Empty address\\\");\\n        require(!obj.data[_address],\\\"Has been set\\\");\\n        obj.data[_address] =true;\\n        obj.length = obj.length.add(1);\\n        if (obj.firstAddress == address(0)){\\n            obj.firstAddress = _address;\\n        }else{\\n            address curraddress = obj.firstAddress;\\n            while ( obj.next[curraddress] != address(0)){\\n                curraddress = obj.next[curraddress];\\n            }\\n            obj.next[curraddress] = _address;\\n        }\\n        emit Set(_address,_extend);\\n    }\\n\\n    //remove Roster\\n    function remove(roster storage obj,address _address,uint _extend) internal{\\n        require(_address != address(0),\\\"Empty address\\\");\\n        require(obj.data[_address],\\\"Is not set\\\");\\n        obj.data[_address] = false;\\n        obj.length = obj.length.sub(1);\\n        if (obj.firstAddress == _address){\\n            obj.firstAddress = obj.next[_address];\\n            obj.next[_address] = address(0);\\n        }else{\\n            address curraddress = obj.firstAddress;\\n            while ( obj.next[curraddress] != _address ){\\n                curraddress = obj.next[curraddress];\\n            }\\n            obj.next[curraddress] = obj.next[_address];\\n            obj.next[_address] = address(0);\\n        }\\n        emit Remove(_address,_extend);\\n    }\\n    \\n    function isexists(roster storage obj,address _address) internal view returns(bool){\\n        return obj.data[_address];\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b,\\\"SafeMath:Calculation error\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003e 0,\\\"SafeMath: B cannot be 0\\\"); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a,\\\"SafeMath:B cannot be greater than A\\\");\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a,\\\"SafeMath:Calculation error\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0,\\\"SafeMath: B cannot be 0\\\");\\n    return a % b;\\n  }\\n}\\n\"},\"TK_poly.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"./ERC20Detailed.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Roster.sol\\\";\\r\\nimport \\\"./Ranking.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Standard ERC20 token\\r\\n *\\r\\n * @dev Implementation of the basic standard token.\\r\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\r\\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\r\\n */\\r\\n  contract ERC20 is ERC20Detailed {\\r\\n    using SafeMath for uint256;\\r\\n    using Roster for Roster.roster;\\r\\n    using school for school.schoolData;\\r\\n    \\r\\n    modifier checkAddress(address _address) {\\r\\n        require(_address != address(0),\\\"zero address \\\");\\r\\n        _;\\r\\n    }\\r\\n \\r\\n    event  SetAllotAddress(address,uint8);\\r\\n\\r\\n    event OwnershipTransferred(address, address);\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    address _owner;\\r\\n\\r\\n    address  constant GUARD = address(1);\\r\\n\\r\\n    school.schoolData  rankLp;\\r\\n\\r\\n    mapping(address =\\u003eaddress) public inviter;\\r\\n\\r\\n    address public addressLp;\\r\\n\\r\\n    address public  addressMarket;\\r\\n\\r\\n    uint public ratio_max = 1000;\\r\\n\\r\\n    uint public ratio_buy_lp = 15;\\r\\n\\r\\n    uint public ratio_buy_fixeds = 5;\\r\\n\\r\\n    uint public ratio_buy_invite = 20;\\r\\n \\r\\n    uint public ratio_buy_market= 30;\\r\\n \\r\\n     uint public ratio_sell_burn = 20;\\r\\n\\r\\n    uint8 public ratio_sell_lp = 15;\\r\\n\\r\\n    uint public ratio_sell_fixeds = 5;\\r\\n\\r\\n    uint public ratio_sell_invite = 10;\\r\\n  \\r\\n    uint public ratio_sell_market= 20;\\r\\n\\r\\n    Roster.roster private listWhite; \\r\\n\\r\\n    Roster.roster private listEarningsAddress;\\r\\n    \\r\\n    uint constant digit = 1E18;\\r\\n    constructor (string name, string symbol, uint256 total, uint256 limitRank) public ERC20Detailed(name, symbol,18)  {\\r\\n        _owner = msg.sender;\\r\\n        _totalSupply =total.mul(digit);\\r\\n        _balances[msg.sender] = _totalSupply;\\r\\n\\r\\n        rankLp.limitRank = limitRank;\\r\\n        rankLp.init();\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n   function setAddressLp(address _address) public onlyOwner{\\r\\n        addressLp = _address;\\r\\n    }\\r\\n    function setAddressMarket(address _address) public onlyOwner{\\r\\n        addressMarket = _address;\\r\\n    }\\r\\n\\r\\n    function setRatioMax(uint8 _ratioMax) public onlyOwner{\\r\\n        ratio_max = _ratioMax;\\r\\n    }\\r\\n\\r\\n    function setRatioBuyLp(uint8 _ratio) public onlyOwner{\\r\\n        ratio_buy_lp = _ratio;\\r\\n    }\\r\\n\\r\\n    function setRatioBuyFixeds(uint8 _ratio) public onlyOwner{\\r\\n        ratio_buy_fixeds = _ratio;\\r\\n    }\\r\\n\\r\\n    function setRatioBuyInvite(uint8 _ratio) public onlyOwner{\\r\\n        ratio_buy_invite = _ratio;\\r\\n    }\\r\\n\\r\\n    function setRatioBuyMarket(uint8 _ratio) public onlyOwner{\\r\\n        ratio_buy_market = _ratio;\\r\\n    }\\r\\n    function setRatioSellBurn(uint8 _ratio) public onlyOwner{\\r\\n        ratio_sell_burn = _ratio;\\r\\n    }\\r\\n\\r\\n    function setRatioSellLp(uint8 _ratio) public onlyOwner{\\r\\n        ratio_sell_lp = _ratio;\\r\\n    }\\r\\n    function setRatioSellFixeds(uint8 _ratio) public onlyOwner{\\r\\n        ratio_sell_fixeds = _ratio;\\r\\n    }\\r\\n\\r\\n    function setRatioSellInvite(uint8 _ratio) public onlyOwner{\\r\\n        ratio_sell_invite = _ratio;\\r\\n    }\\r\\n\\r\\n    function setRatioSellMarket(uint8 _ratio) public onlyOwner{\\r\\n        require(_ratio \\u003c= ratio_max \\u0026\\u0026 _ratio \\u003e= 0,\\\"value\\\");\\r\\n        ratio_sell_market = _ratio;\\r\\n    }\\r\\n\\r\\n    function SetListWhite(address _address) public onlyOwner{\\r\\n        listWhite.set(_address,1);\\r\\n    }\\r\\n\\r\\n    function RemoveListWhite(address _address) public onlyOwner{ \\r\\n        listWhite.remove(_address,1);\\r\\n    }\\r\\n    function  ListWhite() public view returns(address[] memory){\\r\\n      return(listWhite.details());\\r\\n    }\\r\\n\\r\\n    function SetListEarningsAddress(address _address) public onlyOwner{\\r\\n        listEarningsAddress.set(_address,1);\\r\\n    }\\r\\n\\r\\n    function RemoveListEarningsAddress(address _address) public onlyOwner{ \\r\\n        listEarningsAddress.remove(_address,1);\\r\\n    }\\r\\n    function  ListEarningsAddress() public view returns(address[] memory){\\r\\n      return(listEarningsAddress.details());\\r\\n    }\\r\\n \\r\\n    function  LpRankAddress(uint top) public view returns(address[] memory){\\r\\n      return(rankLp.getTop(top));\\r\\n    }\\r\\n \\r\\n    function  LpRankValue(uint top) public view returns(uint256[] memory){\\r\\n      return(rankLp.getTopValue(top));\\r\\n    }\\r\\n \\r\\n    function transferOwnership(address _newOwner) public   onlyOwner {\\r\\n        require(_newOwner != address(0), \\\"  new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, _newOwner);\\r\\n        _owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Total number of tokens in existence\\r\\n    */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n  \\r\\n  /**\\r\\n  * @dev Gets the balance of the specified address.\\r\\n  * @param owner The address to query the balance of.\\r\\n  * @return An uint256 representing the amount owned by the passed address.\\r\\n  */\\r\\n  function balanceOf(address owner) public view returns (uint256) {\\r\\n    return _balances[owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\r\\n   * @param owner address The address which owns the funds.\\r\\n   * @param spender address The address which will spend the funds.\\r\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\r\\n   */\\r\\n  function allowance(\\r\\n    address owner,\\r\\n    address spender\\r\\n   )\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return _allowed[owner][spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Transfer token for a specified address\\r\\n  * @param to The address to transfer to.\\r\\n  * @param value The amount to be transferred.\\r\\n  */\\r\\n  function transfer(address to, uint256 value) public returns (bool) {\\r\\n    _transfer(msg.sender, to, value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\r\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\r\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\r\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   * @param spender The address which will spend the funds.\\r\\n   * @param value The amount of tokens to be spent.\\r\\n   */\\r\\n  function approve(address spender, uint256 value) public returns (bool) {\\r\\n    require(spender != address(0));\\r\\n\\r\\n    _allowed[msg.sender][spender] = value;\\r\\n    emit Approval(msg.sender, spender, value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfer tokens from one address to another\\r\\n   * @param from address The address which you want to send tokens from\\r\\n   * @param to address The address which you want to transfer to\\r\\n   * @param value uint256 the amount of tokens to be transferred\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  )\\r\\n    public\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(value \\u003c= _allowed[from][msg.sender]);\\r\\n\\r\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\r\\n    _transfer(from, to, value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\\r\\n   * approve should be called when allowed_[_spender] == 0. To increment\\r\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n   * the first transaction is mined)\\r\\n   * From MonolithDAO Token.sol\\r\\n   * @param spender The address which will spend the funds.\\r\\n   * @param addedValue The amount of tokens to increase the allowance by.\\r\\n   */\\r\\n  function increaseAllowance(\\r\\n    address spender,\\r\\n    uint256 addedValue\\r\\n  )\\r\\n    public\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(spender != address(0));\\r\\n\\r\\n    _allowed[msg.sender][spender] = (\\r\\n    _allowed[msg.sender][spender].add(addedValue));\\r\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\\r\\n   * approve should be called when allowed_[_spender] == 0. To decrement\\r\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n   * the first transaction is mined)\\r\\n   * From MonolithDAO Token.sol\\r\\n   * @param spender The address which will spend the funds.\\r\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\r\\n   */\\r\\n  function decreaseAllowance(\\r\\n    address spender,\\r\\n    uint256 subtractedValue\\r\\n  )\\r\\n    public\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(spender != address(0));\\r\\n\\r\\n    _allowed[msg.sender][spender] = (\\r\\n    _allowed[msg.sender][spender].sub(subtractedValue));\\r\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Transfer token for a specified addresses\\r\\n  * @param from The address to transfer from.\\r\\n  * @param to The address to transfer to.\\r\\n  * @param value The amount to be transferred.\\r\\n  */\\r\\n  function _transfer(address from, address to, uint256 value) internal {\\r\\n    require(value \\u003c= _balances[from]);\\r\\n    require(to != address(0));\\r\\n\\r\\n    if (from != addressLp \\u0026\\u0026 to != addressLp){ \\r\\n        _createInviter(from,to);\\r\\n    }else{\\r\\n        address _address = from;\\r\\n        if (from == addressLp){\\r\\n            _address = to;\\r\\n        }\\r\\n        _UpdateLpRank(_address);\\r\\n    }\\r\\n    uint256 valueM = value; \\r\\n    if (!listWhite.isexists(from)){\\r\\n        uint256 valueInviter = 0;\\r\\n        bool isTransfer = false;\\r\\n        uint256 valueMarket = 0;\\r\\n        uint256 valueFixed = 0;\\r\\n        uint256 valueLp = 0;\\r\\n         if (from == addressLp){\\r\\n            ( valueInviter, isTransfer)= _rebate_buy_inviter(from,to,value);\\r\\n             valueMarket = _rebate_buy_market(from,value,isTransfer);\\r\\n             valueFixed =  _rebate_all_fixed(from ,value,ratio_buy_fixeds);\\r\\n             valueLp  = _rebate_all_Lp(from,value,ratio_buy_lp);\\r\\n         }else{  \\r\\n            ( valueInviter, isTransfer)= _rebate_sell_inviter(from,value);\\r\\n            valueMarket = _rebate_sell_market(from,value,isTransfer);\\r\\n            uint256 valueBurn =  _rebateValue(value,ratio_sell_burn);\\r\\n             _transferRebate(from,address(0),valueBurn);\\r\\n            valueFixed =  _rebate_all_fixed(from ,value,ratio_sell_fixeds);\\r\\n             valueLp  = _rebate_all_Lp(from,value,ratio_sell_lp);\\r\\n            valueM = valueM.sub(valueBurn);\\r\\n         }\\r\\n         valueM = valueM.sub(valueInviter).sub(valueMarket).sub(valueFixed).sub(valueLp);\\r\\n    }\\r\\n    _transferRebate(from,to,valueM); \\r\\n  }\\r\\n\\r\\n    function _createInviter(address from, address to) internal {\\r\\n        if (inviter[to] == address(0)){\\r\\n            inviter[to] = from;\\r\\n        }\\r\\n    }\\r\\n    function _rebate_buy_inviter(address from, address to, uint256 value) internal returns(uint256,bool) {\\r\\n        if (inviter[to] != address(0)){\\r\\n            uint256 valueRebate = _rebateValue(value,ratio_buy_invite);\\r\\n             _transferRebate(from,inviter[to],valueRebate);\\r\\n            return (valueRebate,true);\\r\\n        }\\r\\n        return (0,false);\\r\\n    }\\r\\n\\r\\n    function _rebate_sell_inviter(address from,  uint256 value) internal returns(uint256,bool) {\\r\\n        if (inviter[from] != address(0)){\\r\\n            uint256 valueRebate = _rebateValue(value,ratio_sell_invite);// value.mul(ratio_sell_invite).div(ratio_max);\\r\\n             _transferRebate(from,inviter[from],valueRebate);\\r\\n            return (valueRebate,true);\\r\\n        }\\r\\n        return (0,false);\\r\\n    }\\r\\n    function _rebate_sell_market(address from,  uint256 value,bool inviterTransfer) internal checkAddress(addressMarket)   returns(uint256)  {\\r\\n        uint ratio = ratio_sell_market;\\r\\n        if (!inviterTransfer){\\r\\n            ratio = ratio.add(ratio_sell_invite);\\r\\n        }\\r\\n        uint256 valueRebate = _rebateValue(value,ratio);\\r\\n        _transferRebate(from,addressMarket,valueRebate);\\r\\n        return (valueRebate);\\r\\n    }\\r\\n\\r\\n\\r\\n    function _rebate_buy_market(address from,  uint256 value,bool inviterTransfer) internal checkAddress(addressMarket)   returns(uint256)  {\\r\\n        uint ratio = ratio_buy_market;\\r\\n        if (!inviterTransfer){\\r\\n            ratio = ratio.add(ratio_buy_invite);\\r\\n        }\\r\\n        uint256 valueRebate = _rebateValue(value,ratio);\\r\\n        _transferRebate(from,addressMarket,valueRebate);\\r\\n        return (valueRebate);\\r\\n    }\\r\\n\\r\\n    function _rebate_all_Lp(address from,  uint256 value,uint ratio) internal  returns(uint256)  {\\r\\n        if (rankLp.listSize \\u003c1 ){\\r\\n            return 0;\\r\\n        }\\r\\n        address currentAddress = rankLp._nextStudents[GUARD];\\r\\n        uint256 balanceSum = 0;\\r\\n        uint256 balance = 0;\\r\\n        uint256 transferValueSum = 0;\\r\\n        for(uint256 i = 0; i \\u003c rankLp.listSize; ++i) {\\r\\n            balance = IERC20(addressLp).balanceOf(currentAddress);\\r\\n            balanceSum = balanceSum.add(balance);\\r\\n            currentAddress = rankLp._nextStudents[currentAddress];\\r\\n        }\\r\\n        if (balanceSum \\u003c 1 ){\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 valueLp = _rebateValue(value,ratio);\\r\\n        currentAddress = rankLp._nextStudents[GUARD];\\r\\n        for(i = 0; i \\u003c rankLp.listSize; ++i) {\\r\\n            balance = IERC20(addressLp).balanceOf(currentAddress);\\r\\n            if (balance \\u003e 0){\\r\\n                uint256 transferValue = valueLp.mul(balance).div(balanceSum);\\r\\n                _transferRebate(from,currentAddress,transferValue);\\r\\n                transferValueSum = transferValueSum.add(transferValue);\\r\\n            }\\r\\n            currentAddress = rankLp._nextStudents[currentAddress];\\r\\n        }\\r\\n        return (transferValueSum);\\r\\n    }\\r\\n\\r\\n    function _rebate_all_fixed(address from,  uint256 value,uint ratio) internal  returns(uint256)  {\\r\\n        if (listEarningsAddress.length \\u003c 1){\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 valueFixed = _rebateValue(value,ratio);//ratio_sell_fixeds);\\r\\n        uint valueSingle = valueFixed.div(listEarningsAddress.length);\\r\\n        address curraddress = listEarningsAddress.firstAddress;\\r\\n        _transferRebate(from,curraddress,valueSingle);\\r\\n        while ( listEarningsAddress.next[curraddress] != address(0)){\\r\\n            curraddress = listEarningsAddress.next[curraddress];\\r\\n            _transferRebate(from,curraddress,valueSingle);\\r\\n        }\\r\\n        return  (valueSingle.mul(listEarningsAddress.length));\\r\\n    }\\r\\n    \\r\\n    function  _rebateValue(uint256 value,uint256 ratio)internal  view  returns(uint256){\\r\\n        return value.mul(ratio).div(ratio_max);\\r\\n    }\\r\\n\\r\\n    function _transferRebate(address from,address to,  uint256 valueRatio) internal   {\\r\\n        _balances[from] = _balances[from].sub(valueRatio);\\r\\n        _balances[to] = _balances[to].add(valueRatio);\\r\\n        emit Transfer(from, to, valueRatio); \\r\\n    }\\r\\n\\r\\n    function _UpdateLpRank(address _address) internal{\\r\\n        uint256 balance = IERC20(addressLp).balanceOf(_address);\\r\\n        address nextAddress =  rankLp._nextStudents[_address];\\r\\n        if ( nextAddress==address(0)){\\r\\n            rankLp.addStudent(_address,balance);\\r\\n        }else{\\r\\n            rankLp.updateScore(_address,balance);\\r\\n        }  \\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"ratio_sell_market\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_sell_invite\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioBuyFixeds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"SetListEarningsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioSellInvite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_buy_market\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressLp\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"top\",\"type\":\"uint256\"}],\"name\":\"LpRankAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ListWhite\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioBuyLp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_buy_fixeds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioSellMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"top\",\"type\":\"uint256\"}],\"name\":\"LpRankValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_buy_lp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddressLp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_buy_invite\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"SetListWhite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratioMax\",\"type\":\"uint8\"}],\"name\":\"setRatioMax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioBuyMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioSellBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_sell_lp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_sell_fixeds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioSellFixeds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioSellLp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_sell_burn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ListEarningsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemoveListWhite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddressMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint8\"}],\"name\":\"setRatioBuyInvite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemoveListEarningsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"limitRank\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"SetAllotAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "ERC20", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000004c4b4000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000005652d5354440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005652d535444000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://6bc6c9b9019de637db6e7932ee5acaba11599706aacee5ecde05ecbc29d47f50"}