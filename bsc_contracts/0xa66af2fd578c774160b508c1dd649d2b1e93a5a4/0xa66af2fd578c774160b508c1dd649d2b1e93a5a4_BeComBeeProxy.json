{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-08-23\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n * \r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n * \r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     * \r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\r\n     * and {_fallback} should delegate.\r\n     */\r\n    function _implementation() internal virtual view returns (address);\r\n\r\n    /**\r\n     * @dev Delegates the current call to the address returned by `_implementation()`.\r\n     * \r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _fallback() internal {\r\n        _beforeFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback () payable external {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n     * is empty.\r\n     */\r\n    receive () payable external {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n     * call, or as part of the Solidity `fallback` or `receive` functions.\r\n     * \r\n     * If overriden should call `super._beforeFallback()`.\r\n     */\r\n    function _beforeFallback() internal virtual {\r\n    }\r\n}\r\n\r\ncontract BeComBeeProxy is Proxy {\r\n    \r\n    address public impl;\r\n    address public owner;\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n\r\n    uint public lastuid = 1;\r\n    uint8 public constant LAST_LEVEL = 9;\r\n    \r\n    mapping(uint8 => uint) public levelCost;\r\n\r\n    bool public initialized;\r\n    mapping(string => uint256) public uIntStorage;\r\n    mapping(string => uint256[]) public uIntArrayStorage;\r\n    mapping(string => string) public stringStorage;\r\n    mapping(string => string[]) public stringArrayStorage;\r\n    mapping(string => address) public addressStorage;\r\n    mapping(string => address[]) public addressArrayStorage;\r\n    mapping(string => bytes) public bytesStorage;\r\n    mapping(string => bytes[]) public bytesArrayStorage;\r\n\r\n    modifier onlyContractOwner() { \r\n        require(msg.sender == owner, \"onlyOwner\"); \r\n        _; \r\n    }\r\n\r\n    struct B3 {\r\n        address currentReferrer;\r\n        address[] referrals;\r\n        uint referralsDirect;\r\n        uint reinvestCount;\r\n        bool blocked;\r\n        uint8 typemat;\r\n    }\r\n    \r\n    struct B6 {\r\n        address currentReferrer;\r\n        address[] firstLevelReferrals;\r\n        address[] secondLevelReferrals;\r\n        //uint referralsDirect;\r\n        uint reinvestCount;\r\n        bool blocked;\r\n        uint8 typemat;\r\n        address closedPart;\r\n    }\r\n\r\n    struct User {\r\n        uint id;\r\n        address referrer;\r\n        uint partnersAllCount;\r\n        uint partnersActiveCount;\r\n        uint activeLevels;\r\n        uint valB3;\r\n        uint valB4;\r\n        \r\n        mapping(uint8 => bool) activeB3Levels;\r\n        mapping(uint8 => bool) activeB6Levels;\r\n        \r\n        mapping(uint8 => B3) b3Matrix;\r\n        mapping(uint8 => B6) b6Matrix;\r\n    }\r\n\r\n    struct Pay {\r\n        address tokenAddress;\r\n        uint256 tokenAmount;\r\n        bool atf;\r\n    }\r\n\r\n    constructor(address _impl) public {\r\n        impl = _impl;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function update(address newImpl) public onlyContractOwner {\r\n        impl = newImpl;\r\n    }\r\n    \r\n    function withdrawBNB(uint256 amount) public onlyContractOwner {\r\n        payable(owner).transfer(amount);\r\n    }\r\n\r\n    function withdrawToken(address addr, uint256 amount) public onlyContractOwner {\r\n        IERC20 tokenWithdraw = IERC20(addr);\r\n        tokenWithdraw.transfer(owner, amount);\r\n    }\r\n    \r\n    function _implementation() internal override view returns (address) {\r\n        return impl;\r\n    }\r\n}\r\n\r\n\r\ncontract BeComBeeBase {\r\n\r\n    address public impl;\r\n    address public owner;\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n\r\n    uint public lastuid = 1;\r\n    uint8 public constant LAST_LEVEL = 9;\r\n    \r\n    mapping(uint8 => uint) public levelCost;\r\n    \r\n    bool public initialized;\r\n    mapping(string => uint256) public uIntStorage;\r\n    mapping(string => uint256[]) public uIntArrayStorage;\r\n    mapping(string => string) public stringStorage;\r\n    mapping(string => string[]) public stringArrayStorage;\r\n    mapping(string => address) public addressStorage;\r\n    mapping(string => address[]) public addressArrayStorage;\r\n    mapping(string => bytes) public bytesStorage;\r\n    mapping(string => bytes[]) public bytesArrayStorage;\r\n\r\n    modifier onlyContractOwner() { \r\n        require(msg.sender == owner, \"onlyOwner\"); \r\n        _; \r\n    }\r\n\r\n    struct B3 {\r\n        address currentReferrer;\r\n        address[] referrals;\r\n        uint referralsDirect;\r\n        uint reinvestCount;\r\n        bool blocked;\r\n        uint8 typemat;\r\n    }\r\n    \r\n    struct B6 {\r\n        address currentReferrer;\r\n        address[] firstLevelReferrals;\r\n        address[] secondLevelReferrals;\r\n        //uint referralsDirect;\r\n        uint reinvestCount;\r\n        bool blocked;\r\n        uint8 typemat;\r\n        address closedPart;\r\n    }\r\n\r\n    struct User {\r\n        uint id;\r\n        address referrer;\r\n        uint partnersAllCount;\r\n        uint partnersActiveCount;\r\n        uint activeLevels;\r\n        uint valB3;\r\n        uint valB4;\r\n        \r\n        mapping(uint8 => bool) activeB3Levels;\r\n        mapping(uint8 => bool) activeB6Levels;\r\n        \r\n        mapping(uint8 => B3) b3Matrix;\r\n        mapping(uint8 => B6) b6Matrix;\r\n    }\r\n\r\n    struct Pay {\r\n        address tokenAddress;\r\n        uint256 tokenAmount;\r\n        bool atf;\r\n    }\r\n\r\n    address public nullAddress = 0x0000000000000000000000000000000000000000;\r\n    \r\n    event MissedFundsHost(address indexed receiver, address indexed from, uint8 matrix, uint8 level);\r\n    event GiftsFundsHost(address indexed from, address indexed receiver, uint8 matrix, uint8 level);\r\n    event MissedFundsUpgrade(address indexed receiver, address indexed from, uint8 matrix, uint8 level);\r\n    event GiftsFundsUpgrade(address indexed from, address indexed receiver, uint8 matrix, uint8 level);\r\n\r\n    event NewUserPlace(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint8 place, uint reinvest, uint8 usertype);\r\n    event Upgrade(address indexed user, address indexed referrer, uint8 matrix, uint8 level);\r\n    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);\r\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\r\n    event Blocked(address indexed user, uint8 matrix, uint8 level);\r\n}\r\n\r\ncontract BeComBee is BeComBeeBase {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function init(address ownerAddress) external payable onlyContractOwner{\r\n\r\n        require(!initialized, \"Contract instance has already been initialized\");\r\n        initialized = true;\r\n\r\n        levelCost[1] = 30;\r\n        levelCost[2] = 70;\r\n        levelCost[3] = 150;\r\n        levelCost[4] = 300;\r\n        levelCost[5] = 600;\r\n        levelCost[6] = 1500;\r\n        levelCost[7] = 3000;\r\n        levelCost[8] = 6000;\r\n        levelCost[9] = 12000;\r\n        \r\n        User memory user = User({\r\n            id: 1,\r\n            partnersAllCount: uint(0),\r\n            partnersActiveCount: uint(0),\r\n            referrer: address(0),\r\n            activeLevels: 0,\r\n            valB3: 0,\r\n            valB4: 0\r\n        });\r\n        \r\n        users[ownerAddress] = user;\r\n\r\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\r\n            users[ownerAddress].activeB3Levels[i] = true;\r\n            users[ownerAddress].activeB6Levels[i] = true;\r\n        }\r\n        \r\n        idToAddress[1] = ownerAddress;\r\n\r\n        lastuid++;\r\n    }\r\n\r\n    function registrationBNB(address referrerAddress, uint256 tknAmount, bool _atf, uint256 decimals) external payable {\r\n        registrationbase(msg.sender, referrerAddress, nullAddress, tknAmount, _atf, decimals);\r\n    }\r\n\r\n    function registrationToken(address referrerAddress, address tknAddress, uint256 tknAmount, bool _atf, uint256 decimals) external payable {\r\n        registrationbase(msg.sender, referrerAddress, tknAddress, tknAmount, _atf, decimals);\r\n    }\r\n    \r\n    function registrationbase(address userAddress, address referrerAddress, address tokenAddress, uint256 tokenAmount, bool atf, uint256 decimals) private {\r\n\r\n        tokenAmount = tokenAmount * 10**decimals;\r\n\r\n        if (tokenAddress != nullAddress){\r\n           IERC20 _token = IERC20(tokenAddress);\r\n            \r\n            if (atf){          \r\n                uint256 allowance = _token.allowance(msg.sender, address(this));\r\n                require(allowance >= tokenAmount, \"Check the token allowance\");\r\n\r\n                _token.safeTransferFrom(msg.sender, address(this), tokenAmount);\r\n            }\r\n        }\r\n\r\n        require(!isUserExists(userAddress), \"user exists\");\r\n        require(isUserExists(referrerAddress), \"referrer not exists\");\r\n        \r\n        //verify is contract\r\n        uint32 size;\r\n        assembly { size := extcodesize(userAddress) }\r\n        require(size == 0, \"cannot be a contract\");\r\n        \r\n        User memory user = User({\r\n            id: lastuid,\r\n            referrer: referrerAddress,\r\n            partnersAllCount: 0,\r\n            partnersActiveCount: 0,\r\n            activeLevels: 0,\r\n            valB3: 0,\r\n            valB4: 0\r\n        });\r\n        \r\n        users[userAddress] = user;\r\n        idToAddress[lastuid] = userAddress;        \r\n\r\n        users[userAddress].referrer = referrerAddress;   \r\n        users[referrerAddress].partnersAllCount++;\r\n        lastuid++;\r\n        \r\n        emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id);\r\n    }\r\n\r\n    //usertype: 1-direct, 2-blueb4(line2-line1), 3-direct/green(reinvest++), 4-yellow(line1-line2), 6-yellowclose(line1-line2), 5-directclose(line2-line1), 7-direct/greenclose(reinvest++)(line2-line1)\r\n    //typemat: 1-, 2-, 3- ,4-    events missed,gifts\r\n    function buyLevel(uint8 matrix, uint8 level, address tokenAddress, uint256 tokenAmount, bool atf, uint256 decimals) external payable {\r\n\r\n        require(isUserExists(msg.sender), \"user is not exists. Register first.\");\r\n        require(matrix == 1 || matrix == 2, \"invalid matrix\");\r\n        //require(msg.value == levelCost[level], \"invalid price\");\r\n        require(level >= 1 && level <= LAST_LEVEL, \"invalid level\");\r\n\r\n        tokenAmount = tokenAmount * 10**decimals;\r\n\r\n        Pay memory pay = Pay({\r\n            tokenAddress: tokenAddress,\r\n            tokenAmount: tokenAmount,\r\n            atf: atf\r\n        });\r\n\r\n        if (level == 1){ \r\n            users[users[msg.sender].referrer].partnersActiveCount++;\r\n        }\r\n\r\n        if (matrix == 1) {\r\n            //b3\r\n            require(level == 1 || users[msg.sender].activeB3Levels[level-1], \"buy previous level first\");\r\n            require(!users[msg.sender].activeB3Levels[level], \"level already activated\");\r\n\r\n            if (users[msg.sender].b3Matrix[level-1].blocked) {\r\n                users[msg.sender].b3Matrix[level-1].blocked = false;\r\n            }\r\n    \r\n            address freeB3Refer = findB3Ref(msg.sender, level);\r\n            users[msg.sender].b3Matrix[level].currentReferrer = freeB3Refer;\r\n            users[msg.sender].activeB3Levels[level] = true;\r\n            users[msg.sender].activeLevels = level;\r\n            updB3Ref(msg.sender, freeB3Refer, level, pay);\r\n            \r\n            emit Upgrade(msg.sender, freeB3Refer, 1, level);\r\n\r\n\r\n            if (users[msg.sender].b6Matrix[level-1].blocked) {\r\n                users[msg.sender].b6Matrix[level-1].blocked = false;\r\n            }\r\n\r\n            address freeB6Referrer = findB6Ref(msg.sender, level);            \r\n            users[msg.sender].activeB6Levels[level] = true;\r\n            updB6Ref(msg.sender, freeB6Referrer, level, pay);\r\n            \r\n            emit Upgrade(msg.sender, freeB6Referrer, 2, level);\r\n        }\r\n    }      \r\n    \r\n    function updB3Ref(address userAddress, address referrerAddress, uint8 level, Pay memory pay) private {\r\n        require(users[referrerAddress].activeB3Levels[level], \"Referrer level is inactive\");\r\n\r\n        uint8 usertype = (users[userAddress].b3Matrix[level].reinvestCount > 0)?3:1;\r\n        users[referrerAddress].b3Matrix[level].referrals.push(userAddress);\r\n\r\n        if (usertype == 1 && users[userAddress].b3Matrix[level].reinvestCount == 0 &&\r\n        referrerAddress == users[userAddress].referrer)\r\n        users[referrerAddress].b3Matrix[level].referralsDirect++;\r\n\r\n        if (users[referrerAddress].b3Matrix[level].referrals.length < 3) {\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, uint8(users[referrerAddress].b3Matrix[level].referrals.length), users[referrerAddress].b3Matrix[level].reinvestCount, usertype);\r\n            return sendDivid(referrerAddress, userAddress, 1, level, pay);\r\n        }\r\n\r\n        uint8 usertype_ = usertype;\r\n        if (users[referrerAddress].b3Matrix[level].referrals.length == 3){\r\n            if (users[userAddress].b3Matrix[level].reinvestCount > 0)\r\n                usertype_ = 7;\r\n            else\r\n                usertype_ = 5;        \r\n        }\r\n        \r\n        emit NewUserPlace(userAddress, referrerAddress, 1, level, 3, users[referrerAddress].b3Matrix[level].reinvestCount, usertype_);\r\n\r\n        //block matrix B3\r\n        users[referrerAddress].b3Matrix[level].referrals = new address[](0);\r\n        if (!users[referrerAddress].activeB3Levels[level+1] && level != LAST_LEVEL && users[referrerAddress].b3Matrix[level].reinvestCount == 2) {\r\n            users[referrerAddress].b3Matrix[level].blocked = true;\r\n            emit Blocked(referrerAddress, 1, level);\r\n        }\r\n\r\n        //new cycle\r\n        if (referrerAddress != owner) {\r\n            \r\n            //check referrer active level\r\n            address freeReferrerAddress = findB3Ref(referrerAddress, level);\r\n            if (users[referrerAddress].b3Matrix[level].currentReferrer != freeReferrerAddress) {\r\n                users[referrerAddress].b3Matrix[level].currentReferrer = freeReferrerAddress;\r\n            }\r\n            \r\n            users[referrerAddress].b3Matrix[level].reinvestCount++;\r\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 1, level);\r\n            updB3Ref(referrerAddress, freeReferrerAddress, level, pay);\r\n        } else {\r\n            sendDivid(owner, userAddress, 1, level, pay);\r\n            users[owner].b3Matrix[level].reinvestCount++;\r\n            emit Reinvest(owner, address(0), userAddress, 1, level);\r\n        }\r\n    }   \r\n\r\n    function updB6Ref(address userAddress, address referrerAddress, uint8 level, Pay memory pay) private {\r\n        require(users[referrerAddress].activeB6Levels[level], \"Referrer level is inactive\");\r\n\r\n        uint8 usertype = (users[userAddress].b6Matrix[level].reinvestCount > 0)?3:1;\r\n\r\n        //if (usertype == 1 && users[userAddress].b6Matrix[level].reinvestCount == 0 &&\r\n        //referrerAddress == users[userAddress].referrer)\r\n        // users[referrerAddress].b6Matrix[level].referralsDirect++;\r\n        \r\n        //line1\r\n        if (users[referrerAddress].b6Matrix[level].firstLevelReferrals.length < 2) {\r\n            \r\n            //set user line1\r\n            users[referrerAddress].b6Matrix[level].firstLevelReferrals.push(userAddress);\r\n\r\n            uint8 place = uint8(users[referrerAddress].b6Matrix[level].firstLevelReferrals.length);\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, place, users[referrerAddress].b6Matrix[level].reinvestCount, usertype);\r\n\r\n            users[userAddress].b6Matrix[level].currentReferrer = referrerAddress;\r\n\r\n            if (referrerAddress == owner) {\r\n                return sendDivid(referrerAddress, userAddress, 2, level, pay);\r\n            }\r\n            \r\n            address ref = users[referrerAddress].b6Matrix[level].currentReferrer;            \r\n            users[ref].b6Matrix[level].secondLevelReferrals.push(userAddress); \r\n            \r\n            uint len = users[ref].b6Matrix[level].firstLevelReferrals.length;\r\n\r\n            uint8 usertype_ = 4;\r\n            if (users[userAddress].referrer != referrerAddress){\r\n                usertype_ = 41;\r\n                if (users[ref].b6Matrix[level].secondLevelReferrals.length == 4)\r\n                usertype_ = 61;\r\n            }\r\n            else{\r\n                if (users[ref].b6Matrix[level].secondLevelReferrals.length == 4)\r\n                usertype_ = 6;\r\n            }\r\n                \r\n            \r\n            //set user-sponsor line2\r\n            if ((len == 2) && \r\n                (users[ref].b6Matrix[level].firstLevelReferrals[0] == referrerAddress) &&\r\n                (users[ref].b6Matrix[level].firstLevelReferrals[1] == referrerAddress)) {\r\n                if (users[referrerAddress].b6Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 5, users[ref].b6Matrix[level].reinvestCount, usertype_);\r\n\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 6, users[ref].b6Matrix[level].reinvestCount, usertype_);\r\n                }\r\n            }  else if ((len == 1 || len == 2) &&\r\n                    users[ref].b6Matrix[level].firstLevelReferrals[0] == referrerAddress) {\r\n                if (users[referrerAddress].b6Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 3, users[ref].b6Matrix[level].reinvestCount, usertype_);\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 4, users[ref].b6Matrix[level].reinvestCount, usertype_);\r\n                }\r\n            } else if (len == 2 && users[ref].b6Matrix[level].firstLevelReferrals[1] == referrerAddress) {\r\n                if (users[referrerAddress].b6Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 5, users[ref].b6Matrix[level].reinvestCount, usertype_);\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 6, users[ref].b6Matrix[level].reinvestCount, usertype_);\r\n                }\r\n            }\r\n\r\n            return updB6RefLevelTwo(userAddress, ref, level, pay);\r\n        }\r\n        \r\n        //line2 ( first from line1 )\r\n        users[referrerAddress].b6Matrix[level].secondLevelReferrals.push(userAddress);\r\n        \r\n        if (users[referrerAddress].b6Matrix[level].closedPart != address(0)) {\r\n            if ((users[referrerAddress].b6Matrix[level].firstLevelReferrals[0] == \r\n                users[referrerAddress].b6Matrix[level].firstLevelReferrals[1]) &&\r\n                (users[referrerAddress].b6Matrix[level].firstLevelReferrals[0] ==\r\n                users[referrerAddress].b6Matrix[level].closedPart)) {\r\n\r\n                updB6(userAddress, referrerAddress, level, true);\r\n                return updB6RefLevelTwo(userAddress, referrerAddress, level, pay);\r\n            } else if (users[referrerAddress].b6Matrix[level].firstLevelReferrals[0] == \r\n                users[referrerAddress].b6Matrix[level].closedPart) {\r\n                updB6(userAddress, referrerAddress, level, true);\r\n                return updB6RefLevelTwo(userAddress, referrerAddress, level, pay);\r\n            } else {\r\n                updB6(userAddress, referrerAddress, level, false);\r\n                return updB6RefLevelTwo(userAddress, referrerAddress, level, pay);\r\n            }\r\n        }\r\n\r\n        if (users[referrerAddress].b6Matrix[level].firstLevelReferrals[1] == userAddress) {\r\n            updB6(userAddress, referrerAddress, level, false);\r\n            return updB6RefLevelTwo(userAddress, referrerAddress, level, pay);\r\n        } else if (users[referrerAddress].b6Matrix[level].firstLevelReferrals[0] == userAddress) {\r\n            updB6(userAddress, referrerAddress, level, true);\r\n            return updB6RefLevelTwo(userAddress, referrerAddress, level, pay);\r\n        }\r\n\r\n        if (users[referrerAddress].b6Matrix[level].firstLevelReferrals[0] == users[referrerAddress].b6Matrix[level].firstLevelReferrals[1]){\r\n                updB6(userAddress, referrerAddress, level, true);\r\n        }\r\n        else {\r\n            if (users[users[referrerAddress].b6Matrix[level].firstLevelReferrals[0]].b6Matrix[level].firstLevelReferrals.length <= \r\n                users[users[referrerAddress].b6Matrix[level].firstLevelReferrals[1]].b6Matrix[level].firstLevelReferrals.length) {\r\n                updB6(userAddress, referrerAddress, level, false);\r\n            } else {\r\n                updB6(userAddress, referrerAddress, level, true);\r\n            }\r\n        }\r\n        \r\n        updB6RefLevelTwo(userAddress, referrerAddress, level, pay);\r\n    } \r\n\r\n    //set line1 ( first from line2 )\r\n    function updB6(address userAddress, address referrerAddress, uint8 level, bool x2) private {\r\n\r\n        uint8 usertype_ = (users[userAddress].b6Matrix[level].reinvestCount > 0)?3:1;\r\n        if (users[referrerAddress].b6Matrix[level].secondLevelReferrals.length == 4){\r\n            if (users[userAddress].b6Matrix[level].reinvestCount > 0)\r\n                usertype_ = 7;\r\n            else\r\n                usertype_ = 5;        \r\n        }\r\n\r\n        if (!x2) {\r\n            users[users[referrerAddress].b6Matrix[level].firstLevelReferrals[0]].b6Matrix[level].firstLevelReferrals.push(userAddress);\r\n\r\n            uint8 place = uint8(users[users[referrerAddress].b6Matrix[level].firstLevelReferrals[0]].b6Matrix[level].firstLevelReferrals.length);\r\n            \r\n            emit NewUserPlace(userAddress, users[referrerAddress].b6Matrix[level].firstLevelReferrals[0], 2, level, place, users[users[referrerAddress].b6Matrix[level].firstLevelReferrals[0]].b6Matrix[level].reinvestCount, 2);\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 2 + place, users[referrerAddress].b6Matrix[level].reinvestCount, usertype_);\r\n\r\n            //set current level\r\n            users[userAddress].b6Matrix[level].currentReferrer = users[referrerAddress].b6Matrix[level].firstLevelReferrals[0];\r\n        } else {\r\n            users[users[referrerAddress].b6Matrix[level].firstLevelReferrals[1]].b6Matrix[level].firstLevelReferrals.push(userAddress);\r\n\r\n            uint8 place = uint8(users[users[referrerAddress].b6Matrix[level].firstLevelReferrals[1]].b6Matrix[level].firstLevelReferrals.length);\r\n\r\n            emit NewUserPlace(userAddress, users[referrerAddress].b6Matrix[level].firstLevelReferrals[1], 2, level, place, users[users[referrerAddress].b6Matrix[level].firstLevelReferrals[1]].b6Matrix[level].reinvestCount, 2);\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 4 + place, users[referrerAddress].b6Matrix[level].reinvestCount, usertype_);\r\n\r\n            //set current level\r\n            users[userAddress].b6Matrix[level].currentReferrer = users[referrerAddress].b6Matrix[level].firstLevelReferrals[1];\r\n        }\r\n    }\r\n    \r\n    function updB6RefLevelTwo(address userAddress, address referrerAddress, uint8 level, Pay memory pay) private {\r\n\r\n        //pay\r\n        if (users[referrerAddress].b6Matrix[level].secondLevelReferrals.length < 4) {\r\n            return sendDivid(referrerAddress, userAddress, 2, level, pay);\r\n        }\r\n\r\n        address[] memory x6 = users[users[referrerAddress].b6Matrix[level].currentReferrer].b6Matrix[level].firstLevelReferrals;\r\n        \r\n        if (x6.length == 2) {\r\n            if (x6[0] == referrerAddress ||\r\n                x6[1] == referrerAddress) {\r\n                users[users[referrerAddress].b6Matrix[level].currentReferrer].b6Matrix[level].closedPart = referrerAddress;\r\n            }\r\n        } else if (x6.length == 1) {\r\n            if (x6[0] == referrerAddress) {\r\n                users[users[referrerAddress].b6Matrix[level].currentReferrer].b6Matrix[level].closedPart = referrerAddress;\r\n            }\r\n        }\r\n        \r\n\r\n        //new cycle\r\n        users[referrerAddress].b6Matrix[level].firstLevelReferrals = new address[](0);\r\n        users[referrerAddress].b6Matrix[level].secondLevelReferrals = new address[](0);\r\n        users[referrerAddress].b6Matrix[level].closedPart = address(0);\r\n\r\n        //block matrix B6\r\n        if (!users[referrerAddress].activeB6Levels[level+1] && level != LAST_LEVEL && users[referrerAddress].b6Matrix[level].reinvestCount == 2) {\r\n            users[referrerAddress].b6Matrix[level].blocked = true;\r\n            emit Blocked(referrerAddress, 2, level);\r\n        }\r\n\r\n        users[referrerAddress].b6Matrix[level].reinvestCount++;\r\n        \r\n        if (referrerAddress != owner) {\r\n            address freeReferrerAddress = findB6Ref(referrerAddress, level);\r\n\r\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 2, level);\r\n            updB6Ref(referrerAddress, freeReferrerAddress, level, pay);\r\n        } else {\r\n            emit Reinvest(owner, address(0), userAddress, 2, level);\r\n            sendDivid(owner, userAddress, 2, level, pay);\r\n        }\r\n    }\r\n    \r\n    function findB3Ref(address userAddress, uint8 level) public returns(address) {\r\n        bool isExtraDividends;\r\n\r\n        while (true) {\r\n            if (users[users[userAddress].referrer].activeB3Levels[level]) {\r\n                if (isExtraDividends){\r\n                    emit GiftsFundsHost(userAddress, users[userAddress].referrer, 1, level);\r\n                    users[users[userAddress].referrer].b3Matrix[level].typemat = 2;\r\n                }\r\n                return users[userAddress].referrer;\r\n            }\r\n            \r\n            if (!isExtraDividends){\r\n                emit MissedFundsHost(users[userAddress].referrer, userAddress, 1, level);\r\n                users[users[userAddress].referrer].b3Matrix[level].typemat = 1;\r\n                isExtraDividends = true;\r\n            }\r\n\r\n            userAddress = users[userAddress].referrer;\r\n        }\r\n    }\r\n\r\n    function findB6Ref(address userAddress, uint8 level) public returns(address) {\r\n        bool isExtraDividends = false;\r\n\r\n        while (true) {\r\n            if (users[users[userAddress].referrer].activeB6Levels[level]) {\r\n                if (isExtraDividends){\r\n                    emit GiftsFundsHost(userAddress, users[userAddress].referrer, 2, level);\r\n                    users[users[userAddress].referrer].b6Matrix[level].typemat = 2;\r\n                }\r\n                return users[userAddress].referrer;\r\n            }\r\n            \r\n            if (!isExtraDividends){\r\n                emit MissedFundsHost(users[userAddress].referrer, userAddress, 2, level);\r\n                users[users[userAddress].referrer].b6Matrix[level].typemat = 1;\r\n                isExtraDividends = true;\r\n            }\r\n\r\n            userAddress = users[userAddress].referrer;\r\n        }\r\n    }\r\n        \r\n    function usersActiveB3Levels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeB3Levels[level];\r\n    }\r\n    function usersActiveB3Levels2(address userAddress, uint8 level) public view returns(bool, uint8) {\r\n        return (users[userAddress].activeB3Levels[level], \r\n                level);\r\n    }\r\n\r\n    function usersActiveB6Levels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeB6Levels[level];\r\n    }\r\n    function usersActiveB6Levels2(address userAddress, uint8 level) public view returns(bool, uint8) {\r\n        return (users[userAddress].activeB6Levels[level], \r\n                level);\r\n    }\r\n\r\n    function usersB3Matrix(address userAddress, uint8 level) public view returns(address, address[] memory, bool) {\r\n        return (users[userAddress].b3Matrix[level].currentReferrer,\r\n                users[userAddress].b3Matrix[level].referrals,\r\n                users[userAddress].b3Matrix[level].blocked);\r\n    }\r\n    function usersB3Matrix2(address userAddress, uint8 level) public view returns(uint, address[] memory, bool, uint, uint8, uint8) {\r\n        return (users[userAddress].b3Matrix[level].referralsDirect,\r\n                users[userAddress].b3Matrix[level].referrals,\r\n                users[userAddress].b3Matrix[level].blocked, \r\n                users[userAddress].b3Matrix[level].reinvestCount, \r\n                level,\r\n                users[userAddress].b3Matrix[level].typemat);\r\n    }\r\n    function usersB3MatrixReinvest2(address userAddress, uint8 level, uint reinvest) public view returns(address[] memory, uint, uint8) {\r\n        return (users[userAddress].b3Matrix[level].referrals,\r\n                reinvest, \r\n                level);\r\n    }\r\n\r\n    function usersB6Matrix(address userAddress, uint8 level) public view returns(address, address[] memory, address[] memory, bool, address) {\r\n        return (users[userAddress].b6Matrix[level].currentReferrer,\r\n                users[userAddress].b6Matrix[level].firstLevelReferrals,\r\n                users[userAddress].b6Matrix[level].secondLevelReferrals,\r\n                users[userAddress].b6Matrix[level].blocked,\r\n                users[userAddress].b6Matrix[level].closedPart);\r\n    }\r\n    function usersB6Matrix2(address userAddress, uint8 level) public view returns(uint, address[] memory, address[] memory, uint, uint8, uint8) {\r\n        return (users[userAddress].b3Matrix[level].referralsDirect,\r\n                users[userAddress].b6Matrix[level].firstLevelReferrals,\r\n                users[userAddress].b6Matrix[level].secondLevelReferrals,\r\n                users[userAddress].b6Matrix[level].reinvestCount,\r\n                level,\r\n                users[userAddress].b6Matrix[level].typemat);\r\n    }\r\n    function usersB6MatrixReinvest2(address userAddress, uint8 level, uint reinvest) public view returns(address[] memory, address[] memory, uint, uint8) {\r\n        return (users[userAddress].b6Matrix[level].firstLevelReferrals,\r\n                users[userAddress].b6Matrix[level].secondLevelReferrals,\r\n                reinvest,\r\n                level);\r\n    }\r\n    \r\n    function isUserExists(address user) public view returns (bool) {\r\n        return (users[user].id != 0);\r\n    }\r\n\r\n    function findReceiver(address userAddress, address _from, uint8 matrix, uint8 level) private returns(address, bool) {\r\n        address receiver = userAddress;\r\n        bool isExtraDividends;\r\n\r\n        if (matrix == 1) {\r\n            while (true) {\r\n                if (users[receiver].b3Matrix[level].blocked) {\r\n                    emit MissedFundsUpgrade(receiver, _from, 1, level);\r\n                    users[receiver].b3Matrix[level].typemat = 3;\r\n                    isExtraDividends = true;\r\n                    //receiver = users[receiver].b3Matrix[level].currentReferrer;\r\n                    receiver = users[receiver].referrer;\r\n                } else {\r\n                    return (receiver, isExtraDividends);\r\n                }\r\n            }\r\n        } else {\r\n            while (true) {\r\n                if (users[receiver].b6Matrix[level].blocked) {\r\n                    emit MissedFundsUpgrade(receiver, _from, 2, level);\r\n                    users[receiver].b6Matrix[level].typemat = 3;\r\n                    isExtraDividends = true;\r\n                    //receiver = users[receiver].b6Matrix[level].currentReferrer;\r\n                    receiver = users[receiver].referrer;\r\n                } else {\r\n                    return (receiver, isExtraDividends);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function sendDivid(address userAddress, address _from, uint8 matrix, uint8 level, Pay memory pay) private {\r\n        (address receiver, bool isExtraDividends) = findReceiver(userAddress, _from, matrix, level);\r\n\r\n        if (pay.tokenAddress != nullAddress){\r\n            IERC20 _token = IERC20(pay.tokenAddress);\r\n\r\n            if (pay.atf)\r\n                _token.safeTransferFrom(msg.sender, receiver, pay.tokenAmount);\r\n            else\r\n                _token.safeTransfer(receiver, pay.tokenAmount);\r\n        }\r\n        else{\r\n            if (!address(uint160(receiver)).send(pay.tokenAmount)) {\r\n                pay.tokenAmount = address(this).balance;\r\n                address(uint160(receiver)).transfer(address(this).balance);\r\n            }\r\n        }\r\n        \r\n        if (isExtraDividends) {\r\n            emit GiftsFundsUpgrade(_from, receiver, matrix, level);\r\n            if (matrix == 1)\r\n                users[receiver].b3Matrix[level].typemat = 4;\r\n            else\r\n                users[receiver].b6Matrix[level].typemat = 4;\r\n        }\r\n\r\n        if (matrix == 1)\r\n            users[userAddress].valB3 = users[userAddress].valB3 + levelCost[level];\r\n        else    \r\n            users[userAddress].valB4 = users[userAddress].valB4 + levelCost[level];\r\n    }\r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n    function allowtoken(address addr1, address addr2) public view returns (uint256) {\r\n        IERC20 _token = IERC20(addr2);          \r\n        return _token.allowance(addr1, address(this));\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"LAST_LEVEL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressArrayStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"addressStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bytesArrayStorage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"bytesStorage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"impl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastuid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stringArrayStorage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"stringStorage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uIntArrayStorage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"uIntStorage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImpl\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"partnersAllCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partnersActiveCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeLevels\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valB3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valB4\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BeComBeeProxy", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ef022255b09e648edd87e55c505280011baab6a4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d1da90048fe98f17ca10bcbab6b36c76222847fe587bdf1513b84e36effefb44"}