{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@mean-finance/dca-v2-periphery/contracts/DCAHubCompanion/DCAHubCompanion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport './DCAHubCompanionLibrariesHandler.sol';\\nimport './DCAHubCompanionHubProxyHandler.sol';\\nimport '../utils/BaseCompanion.sol';\\n\\ncontract DCAHubCompanion is DCAHubCompanionLibrariesHandler, DCAHubCompanionHubProxyHandler, BaseCompanion, IDCAHubCompanion {\\n  constructor(\\n    address _swapper,\\n    address _allowanceTarget,\\n    address _governor,\\n    IPermit2 _permit2\\n  ) BaseCompanion(_swapper, _allowanceTarget, _governor, _permit2) {}\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/DCAHubCompanion/DCAHubCompanionLibrariesHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '../libraries/InputBuilding.sol';\\nimport '../libraries/SecondsUntilNextSwap.sol';\\nimport '../interfaces/IDCAHubCompanion.sol';\\n\\nabstract contract DCAHubCompanionLibrariesHandler is IDCAHubCompanionLibrariesHandler {\\n  /// @inheritdoc IDCAHubCompanionLibrariesHandler\\n  function getNextSwapInfo(\\n    IDCAHub _hub,\\n    Pair[] calldata _pairs,\\n    bool _calculatePrivilegedAvailability,\\n    bytes calldata _oracleData\\n  ) external view returns (IDCAHub.SwapInfo memory) {\\n    (address[] memory _tokens, IDCAHub.PairIndexes[] memory _indexes) = InputBuilding.buildGetNextSwapInfoInput(_pairs);\\n    return _hub.getNextSwapInfo(_tokens, _indexes, _calculatePrivilegedAvailability, _oracleData);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionLibrariesHandler\\n  function legacyGetNextSwapInfo(ILegacyDCAHub _hub, Pair[] calldata _pairs) external view returns (ILegacyDCAHub.SwapInfo memory) {\\n    (address[] memory _tokens, IDCAHub.PairIndexes[] memory _indexes) = InputBuilding.buildGetNextSwapInfoInput(_pairs);\\n    return _hub.getNextSwapInfo(_tokens, _indexes);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionLibrariesHandler\\n  function secondsUntilNextSwap(\\n    IDCAHub _hub,\\n    Pair[] calldata _pairs,\\n    bool _calculatePrivilegedAvailability\\n  ) external view returns (uint256[] memory) {\\n    return SecondsUntilNextSwap.secondsUntilNextSwap(_hub, _pairs, _calculatePrivilegedAvailability);\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/DCAHubCompanion/DCAHubCompanionHubProxyHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '../interfaces/IDCAHubCompanion.sol';\\n\\n/// @dev All public functions are payable, so that they can be multicalled together with other payable functions when msg.value > 0\\nabstract contract DCAHubCompanionHubProxyHandler is IDCAHubCompanionHubProxyHandler {\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function permissionPermit(\\n    IDCAPermissionManager _permissionManager,\\n    IDCAPermissionManager.PermissionSet[] calldata _permissions,\\n    uint256 _tokenId,\\n    uint256 _deadline,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external payable {\\n    _permissionManager.permissionPermit(_permissions, _tokenId, _deadline, _v, _r, _s);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function multiPermissionPermit(\\n    IDCAPermissionManager _permissionManager,\\n    IDCAPermissionManager.PositionPermissions[] calldata _permissions,\\n    uint256 _deadline,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external payable {\\n    _permissionManager.multiPermissionPermit(_permissions, _deadline, _v, _r, _s);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function deposit(\\n    IDCAHub _hub,\\n    address _from,\\n    address _to,\\n    uint256 _amount,\\n    uint32 _amountOfSwaps,\\n    uint32 _swapInterval,\\n    address _owner,\\n    IDCAPermissionManager.PermissionSet[] calldata _permissions,\\n    bytes calldata _miscellaneous\\n  ) public payable virtual returns (uint256 _positionId) {\\n    _approveHub(address(_from), _hub, _amount);\\n    _positionId = _miscellaneous.length > 0\\n      ? _hub.deposit(_from, _to, _amount, _amountOfSwaps, _swapInterval, _owner, _permissions, _miscellaneous)\\n      : _hub.deposit(_from, _to, _amount, _amountOfSwaps, _swapInterval, _owner, _permissions);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function depositWithBalanceOnContract(\\n    IDCAHub _hub,\\n    address _from,\\n    address _to,\\n    uint32 _amountOfSwaps,\\n    uint32 _swapInterval,\\n    address _owner,\\n    IDCAPermissionManager.PermissionSet[] calldata _permissions,\\n    bytes calldata _miscellaneous\\n  ) external payable returns (uint256 _positionId) {\\n    uint256 _amount = IERC20(_from).balanceOf(address(this));\\n    return deposit(_hub, _from, _to, _amount, _amountOfSwaps, _swapInterval, _owner, _permissions, _miscellaneous);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function withdrawSwapped(\\n    IDCAHub _hub,\\n    uint256 _positionId,\\n    address _recipient\\n  ) external payable verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.WITHDRAW) returns (uint256 _swapped) {\\n    _swapped = _hub.withdrawSwapped(_positionId, _recipient);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function withdrawSwappedMany(\\n    IDCAHub _hub,\\n    IDCAHub.PositionSet[] calldata _positions,\\n    address _recipient\\n  ) external payable returns (uint256[] memory _withdrawn) {\\n    for (uint256 i = 0; i < _positions.length; ) {\\n      uint256[] memory _positionIds = _positions[i].positionIds;\\n      for (uint256 j = 0; j < _positionIds.length; ) {\\n        _checkPermissionOrFail(_hub, _positionIds[j], IDCAPermissionManager.Permission.WITHDRAW);\\n        unchecked {\\n          j++;\\n        }\\n      }\\n      unchecked {\\n        i++;\\n      }\\n    }\\n    _withdrawn = _hub.withdrawSwappedMany(_positions, _recipient);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function increasePosition(\\n    IDCAHub _hub,\\n    uint256 _positionId,\\n    uint256 _amount,\\n    uint32 _newSwaps\\n  ) external payable verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.INCREASE) {\\n    IERC20Metadata _from = _hub.userPosition(_positionId).from;\\n    _approveHub(address(_from), _hub, _amount);\\n    _hub.increasePosition(_positionId, _amount, _newSwaps);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function increasePositionWithBalanceOnContract(\\n    IDCAHub _hub,\\n    uint256 _positionId,\\n    uint32 _newSwaps\\n  ) external payable verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.INCREASE) {\\n    IERC20Metadata _from = _hub.userPosition(_positionId).from;\\n    uint256 _amount = _from.balanceOf(address(this));\\n    _approveHub(address(_from), _hub, _amount);\\n    _hub.increasePosition(_positionId, _amount, _newSwaps);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function reducePosition(\\n    IDCAHub _hub,\\n    uint256 _positionId,\\n    uint256 _amount,\\n    uint32 _newSwaps,\\n    address _recipient\\n  ) external payable verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.REDUCE) {\\n    _hub.reducePosition(_positionId, _amount, _newSwaps, _recipient);\\n  }\\n\\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\\n  function terminate(\\n    IDCAHub _hub,\\n    uint256 _positionId,\\n    address _recipientUnswapped,\\n    address _recipientSwapped\\n  )\\n    external\\n    payable\\n    verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.TERMINATE)\\n    returns (uint256 _unswapped, uint256 _swapped)\\n  {\\n    (_unswapped, _swapped) = _hub.terminate(_positionId, _recipientUnswapped, _recipientSwapped);\\n  }\\n\\n  function _approveHub(\\n    address _token,\\n    IDCAHub _hub,\\n    uint256 _amount\\n  ) internal {\\n    uint256 _allowance = IERC20(_token).allowance(address(this), address(_hub));\\n    if (_allowance < _amount) {\\n      if (_allowance > 0) {\\n        IERC20(_token).approve(address(_hub), 0); // We do this because some tokens (like USDT) fail if we don't\\n      }\\n      IERC20(_token).approve(address(_hub), type(uint256).max);\\n    }\\n  }\\n\\n  function _checkPermissionOrFail(\\n    IDCAHub _hub,\\n    uint256 _positionId,\\n    IDCAPermissionManager.Permission _permission\\n  ) internal view {\\n    if (!_hub.permissionManager().hasPermission(_positionId, msg.sender, _permission)) revert UnauthorizedCaller();\\n  }\\n\\n  modifier verifyPermission(\\n    IDCAHub _hub,\\n    uint256 _positionId,\\n    IDCAPermissionManager.Permission _permission\\n  ) {\\n    _checkPermissionOrFail(_hub, _positionId, _permission);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/utils/BaseCompanion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@mean-finance/swappers/solidity/contracts/extensions/RevokableWithGovernor.sol';\\nimport '@mean-finance/swappers/solidity/contracts/extensions/PayableMulticall.sol';\\nimport {SimulationAdapter} from '@mean-finance/call-simulation/contracts/SimulationAdapter.sol';\\nimport {IPermit2} from '../interfaces/external/IPermit2.sol';\\nimport {Permit2Transfers} from '../libraries/Permit2Transfers.sol';\\n\\n/**\\n * @notice This contract will work as base companion for all our contracts. It will extend the capabilities of our companion\\n *         contracts so that they can execute multicalls, swaps, revokes and more\\n * @dev All public functions are payable, so that they can be multicalled together with other payable functions when msg.value > 0\\n */\\nabstract contract BaseCompanion is SimulationAdapter, RevokableWithGovernor, PayableMulticall {\\n  using Permit2Transfers for IPermit2;\\n  using SafeERC20 for IERC20;\\n\\n  /**\\n   * @notice Thrown when the swap produced less token out than expected\\n   * @param received The amount of token out received\\n   * @param expected The amount of token out expected\\n   */\\n  error ReceivedTooLittleTokenOut(uint256 received, uint256 expected);\\n\\n  /**\\n   * @notice Returns the address of the Permit2 contract\\n   * @dev This value is constant and cannot change\\n   * @return The address of the Permit2 contract\\n   */\\n  // solhint-disable-next-line var-name-mixedcase\\n  IPermit2 public immutable PERMIT2;\\n\\n  /// @notice The address of the swapper\\n  address public swapper;\\n\\n  /// @notice The address of the allowance target\\n  address public allowanceTarget;\\n\\n  constructor(\\n    address _swapper,\\n    address _allowanceTarget,\\n    address _governor,\\n    IPermit2 _permit2\\n  ) SwapAdapter(address(1)) Governable(_governor) {\\n    swapper = _swapper;\\n    allowanceTarget = _allowanceTarget;\\n    PERMIT2 = _permit2;\\n  }\\n\\n  /**\\n   * @notice Sends the specified amount of the given token to the recipient\\n   * @param _token The token to transfer\\n   * @param _amount The amount to transfer\\n   * @param _recipient The recipient of the token balance\\n   */\\n  function sendToRecipient(\\n    address _token,\\n    uint256 _amount,\\n    address _recipient\\n  ) external payable {\\n    _sendToRecipient(_token, _amount, _recipient);\\n  }\\n\\n  /**\\n   * @notice Takes the given amount of tokens from the caller and transfers it to this contract\\n   * @param _token The token to take\\n   * @param _amount The amount to take\\n   */\\n  function takeFromCaller(\\n    IERC20 _token,\\n    uint256 _amount,\\n    address _recipient\\n  ) external payable {\\n    _token.safeTransferFrom(msg.sender, _recipient, _amount);\\n  }\\n\\n  /**\\n   * @notice Executes a swap against the swapper\\n   * @param _allowanceToken The token to set allowance for (can be set to zero address to ignore)\\n   * @param _value The value to send to the swapper as part of the swap\\n   * @param _swapData The swap data\\n   * @param _tokenOut The token that will be bought as part of the swap\\n   * @param _minTokenOut The min amount of token out that we expect\\n   */\\n  function runSwap(\\n    address _allowanceToken,\\n    uint256 _value,\\n    bytes calldata _swapData,\\n    address _tokenOut,\\n    uint256 _minTokenOut\\n  ) external payable returns (uint256 _amountOut) {\\n    if (_allowanceToken != address(0)) {\\n      IERC20(_allowanceToken).approve(allowanceTarget, type(uint256).max);\\n    }\\n\\n    _executeSwap(swapper, _swapData, _value);\\n\\n    _amountOut = _tokenOut == PROTOCOL_TOKEN ? address(this).balance : IERC20(_tokenOut).balanceOf(address(this));\\n    if (_amountOut < _minTokenOut) revert ReceivedTooLittleTokenOut(_amountOut, _minTokenOut);\\n  }\\n\\n  /**\\n   * @notice Takes the given amount of tokens from the caller with Permit2 and transfers it to this contract\\n   * @param _token The token to take\\n   * @param _amount The amount to take\\n   * @param _nonce The signed nonce\\n   * @param _deadline The signature's deadline\\n   * @param _signature The owner's signature\\n   * @param _recipient The address that will receive the funds\\n   */\\n  function permitTakeFromCaller(\\n    address _token,\\n    uint256 _amount,\\n    uint256 _nonce,\\n    uint256 _deadline,\\n    bytes calldata _signature,\\n    address _recipient\\n  ) external payable {\\n    PERMIT2.takeFromCaller(_token, _amount, _nonce, _deadline, _signature, _recipient);\\n  }\\n\\n  /**\\n   * @notice Takes the a batch of tokens from the caller with Permit2 and transfers it to this contract\\n   * @param _tokens The tokens to take\\n   * @param _nonce The signed nonce\\n   * @param _deadline The signature's deadline\\n   * @param _signature The owner's signature\\n   * @param _recipient The address that will receive the funds\\n   */\\n  function batchPermitTakeFromCaller(\\n    IPermit2.TokenPermissions[] calldata _tokens,\\n    uint256 _nonce,\\n    uint256 _deadline,\\n    bytes calldata _signature,\\n    address _recipient\\n  ) external payable {\\n    PERMIT2.batchTakeFromCaller(_tokens, _nonce, _deadline, _signature, _recipient);\\n  }\\n\\n  /**\\n   * @notice Checks if the contract has any balance of the given token, and if it does,\\n   *         it sends it to the given recipient\\n   * @param _token The token to check\\n   * @param _recipient The recipient of the token balance\\n   */\\n  function sendBalanceOnContractToRecipient(address _token, address _recipient) external payable {\\n    _sendBalanceOnContractToRecipient(_token, _recipient);\\n  }\\n\\n  /**\\n   * @notice Sets a new swapper and allowance target\\n   * @param _newSwapper The address of the new swapper\\n   * @param _newAllowanceTarget The address of the new allowance target\\n   */\\n  function setSwapper(address _newSwapper, address _newAllowanceTarget) external onlyGovernor {\\n    swapper = _newSwapper;\\n    allowanceTarget = _newAllowanceTarget;\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/libraries/InputBuilding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\\nimport '../interfaces/ISharedTypes.sol';\\n\\n/// @title Input Building Library\\n/// @notice Provides functions to build input for swap related actions\\n/// @dev Please note that these functions are very expensive. Ideally, these would be used for off-chain purposes\\nlibrary InputBuilding {\\n  /// @notice Takes a list of pairs and returns the input necessary to check the next swap\\n  /// @dev Even though this function allows it, the DCAHub will fail if duplicated pairs are used\\n  /// @return _tokens A sorted list of all the tokens involved in the swap\\n  /// @return _pairsToSwap A sorted list of indexes that represent the pairs involved in the swap\\n  function buildGetNextSwapInfoInput(Pair[] calldata _pairs)\\n    internal\\n    pure\\n    returns (address[] memory _tokens, IDCAHub.PairIndexes[] memory _pairsToSwap)\\n  {\\n    (_tokens, _pairsToSwap, ) = buildSwapInput(_pairs, new IDCAHub.AmountOfToken[](0));\\n  }\\n\\n  /// @notice Takes a list of pairs and a list of tokens to borrow and returns the input necessary to execute a swap\\n  /// @dev Even though this function allows it, the DCAHub will fail if duplicated pairs are used\\n  /// @return _tokens A sorted list of all the tokens involved in the swap\\n  /// @return _pairsToSwap A sorted list of indexes that represent the pairs involved in the swap\\n  /// @return _borrow A list of amounts to borrow, based on the sorted token list\\n  function buildSwapInput(Pair[] calldata _pairs, IDCAHub.AmountOfToken[] memory _toBorrow)\\n    internal\\n    pure\\n    returns (\\n      address[] memory _tokens,\\n      IDCAHub.PairIndexes[] memory _pairsToSwap,\\n      uint256[] memory _borrow\\n    )\\n  {\\n    _tokens = _calculateUniqueTokens(_pairs, _toBorrow);\\n    _pairsToSwap = _calculatePairIndexes(_pairs, _tokens);\\n    _borrow = _calculateTokensToBorrow(_toBorrow, _tokens);\\n  }\\n\\n  /// @dev Given a list of token pairs and tokens to borrow, returns a list of all the tokens involved, sorted\\n  function _calculateUniqueTokens(Pair[] memory _pairs, IDCAHub.AmountOfToken[] memory _toBorrow)\\n    private\\n    pure\\n    returns (address[] memory _tokens)\\n  {\\n    uint256 _uniqueTokens;\\n    address[] memory _tokensPlaceholder = new address[](_pairs.length * 2 + _toBorrow.length);\\n\\n    // Load tokens in pairs onto placeholder\\n    for (uint256 i; i < _pairs.length; i++) {\\n      bool _foundA = false;\\n      bool _foundB = false;\\n      for (uint256 j; j < _uniqueTokens && !(_foundA && _foundB); j++) {\\n        if (!_foundA && _tokensPlaceholder[j] == _pairs[i].tokenA) _foundA = true;\\n        if (!_foundB && _tokensPlaceholder[j] == _pairs[i].tokenB) _foundB = true;\\n      }\\n\\n      if (!_foundA) _tokensPlaceholder[_uniqueTokens++] = _pairs[i].tokenA;\\n      if (!_foundB) _tokensPlaceholder[_uniqueTokens++] = _pairs[i].tokenB;\\n    }\\n\\n    // Load tokens to borrow onto placeholder\\n    for (uint256 i; i < _toBorrow.length; i++) {\\n      bool _found = false;\\n      for (uint256 j; j < _uniqueTokens && !_found; j++) {\\n        if (_tokensPlaceholder[j] == _toBorrow[i].token) _found = true;\\n      }\\n      if (!_found) _tokensPlaceholder[_uniqueTokens++] = _toBorrow[i].token;\\n    }\\n\\n    // Load sorted into new array\\n    _tokens = new address[](_uniqueTokens);\\n    for (uint256 i; i < _uniqueTokens; i++) {\\n      address _token = _tokensPlaceholder[i];\\n\\n      // Find index where the token should be\\n      uint256 _tokenIndex;\\n      while (_tokens[_tokenIndex] < _token && _tokens[_tokenIndex] != address(0)) _tokenIndex++;\\n\\n      // Move everything one place back\\n      for (uint256 j = i; j > _tokenIndex; j--) {\\n        _tokens[j] = _tokens[j - 1];\\n      }\\n\\n      // Set token on the correct index\\n      _tokens[_tokenIndex] = _token;\\n    }\\n  }\\n\\n  /// @dev Given a list of pairs, and a list of sorted tokens, it translates the first list into indexes of the second list. This list of indexes will\\n  /// be sorted. For example, if pairs are [{ tokenA, tokenB }, { tokenC, tokenB }] and tokens are: [ tokenA, tokenB, tokenC ], the following is returned\\n  /// [ { 0, 1 }, { 1, 1 }, { 1, 2 } ]\\n  function _calculatePairIndexes(Pair[] calldata _pairs, address[] memory _tokens)\\n    private\\n    pure\\n    returns (IDCAHub.PairIndexes[] memory _pairIndexes)\\n  {\\n    _pairIndexes = new IDCAHub.PairIndexes[](_pairs.length);\\n    uint256 _count;\\n\\n    for (uint8 i; i < _tokens.length; i++) {\\n      for (uint8 j = i + 1; j < _tokens.length; j++) {\\n        for (uint256 k; k < _pairs.length; k++) {\\n          if (\\n            (_tokens[i] == _pairs[k].tokenA && _tokens[j] == _pairs[k].tokenB) ||\\n            (_tokens[i] == _pairs[k].tokenB && _tokens[j] == _pairs[k].tokenA)\\n          ) {\\n            _pairIndexes[_count++] = IDCAHubSwapHandler.PairIndexes({indexTokenA: i, indexTokenB: j});\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @dev Given a list of tokens to borrow and a list of sorted tokens, it translated the first list into a list of amounts, sorted by the indexed of\\n  /// the seconds list. For example, if `toBorrow` are [{ tokenA, 100 }, { tokenC, 200 }, { tokenB, 500 }] and tokens are [ tokenA, tokenB, tokenC], the\\n  /// following is returned [100, 500, 200]\\n  function _calculateTokensToBorrow(IDCAHub.AmountOfToken[] memory _toBorrow, address[] memory _tokens)\\n    private\\n    pure\\n    returns (uint256[] memory _borrow)\\n  {\\n    _borrow = new uint256[](_tokens.length);\\n\\n    for (uint256 i; i < _toBorrow.length; i++) {\\n      uint256 j;\\n      while (_tokens[j] != _toBorrow[i].token) j++;\\n      _borrow[j] = _toBorrow[i].amount;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/interfaces/IDCAHubCompanion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAPermissionManager.sol';\\nimport './ILegacyDCAHub.sol';\\nimport './ISharedTypes.sol';\\n\\n/**\\n * @notice This contract exposes many utils that are also available through libraries. The idea is to make\\n *         these functions available here, so others don't need to deploy new contracts\\n */\\ninterface IDCAHubCompanionLibrariesHandler {\\n  /**\\n   * @notice Takes a list of pairs and returns how it would look like to execute a swap for all of them\\n   * @dev Please note that this function is very expensive. Ideally, it would be used for off-chain purposes\\n   * @param hub The address of the DCAHub\\n   * @param pairs The pairs to be involved in the swap\\n   * @param calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\\n   *        the possibility to calculate the next swap information for privileged and non-privileged accounts\\n   * @param oracleData Bytes to send to the oracle when executing a quote\\n   * @return How executing a swap for all the given pairs would look like\\n   */\\n  function getNextSwapInfo(\\n    IDCAHub hub,\\n    Pair[] calldata pairs,\\n    bool calculatePrivilegedAvailability,\\n    bytes calldata oracleData\\n  ) external view returns (IDCAHub.SwapInfo memory);\\n\\n  /**\\n   * @notice Takes a list of pairs and returns how it would look like to execute a swap for all of them\\n   * @dev Please note that this function is very expensive. Ideally, it would be used for off-chain purposes\\n   * @param hub The address of the DCAHub\\n   * @param pairs The pairs to be involved in the swap\\n   * @return How executing a swap for all the given pairs would look like\\n   */\\n  function legacyGetNextSwapInfo(ILegacyDCAHub hub, Pair[] calldata pairs) external view returns (ILegacyDCAHub.SwapInfo memory);\\n\\n  /**\\n   * @notice Returns how many seconds left until the next swap is available for a list of pairs\\n   * @dev Tokens in pairs may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param hub The address of the DCAHub\\n   * @param pairs Pairs to check\\n   * @param calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\\n   *        the possibility to calculate the seconds until next swap for privileged and non-privileged accounts\\n   * @return The amount of seconds until next swap for each of the pairs\\n   */\\n  function secondsUntilNextSwap(\\n    IDCAHub hub,\\n    Pair[] calldata pairs,\\n    bool calculatePrivilegedAvailability\\n  ) external view returns (uint256[] memory);\\n}\\n\\ninterface IDCAHubCompanionHubProxyHandler {\\n  /// @notice Thrown when a user tries operate on a position that they don't have access to\\n  error UnauthorizedCaller();\\n\\n  /**\\n   * @notice Creates a new position\\n   * @dev Meant to be used as part of a multicall\\n   * @param hub The address of the DCAHub\\n   * @param from The address of the \\\"from\\\" token\\n   * @param to The address of the \\\"to\\\" token\\n   * @param amount How many \\\"from\\\" tokens will be swapped in total\\n   * @param amountOfSwaps How many swaps to execute for this position\\n   * @param swapInterval How frequently the position's swaps should be executed\\n   * @param owner The address of the owner of the position being created\\n   * @param miscellaneous Bytes that will be emitted, and associated with the position. If empty, no event will be emitted\\n   * @return positionId The id of the created position\\n   */\\n  function deposit(\\n    IDCAHub hub,\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint32 amountOfSwaps,\\n    uint32 swapInterval,\\n    address owner,\\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\\n    bytes calldata miscellaneous\\n  ) external payable returns (uint256 positionId);\\n\\n  /**\\n   * @notice Creates a new position using the entire balance available on the contract\\n   * @dev Meant to be used as part of a multicall\\n   * @param hub The address of the DCAHub\\n   * @param from The address of the \\\"from\\\" token\\n   * @param to The address of the \\\"to\\\" token\\n   * @param amountOfSwaps How many swaps to execute for this position\\n   * @param swapInterval How frequently the position's swaps should be executed\\n   * @param owner The address of the owner of the position being created\\n   * @param miscellaneous Bytes that will be emitted, and associated with the position. If empty, no event will be emitted\\n   * @return positionId The id of the created position\\n   */\\n  function depositWithBalanceOnContract(\\n    IDCAHub hub,\\n    address from,\\n    address to,\\n    uint32 amountOfSwaps,\\n    uint32 swapInterval,\\n    address owner,\\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\\n    bytes calldata miscellaneous\\n  ) external payable returns (uint256 positionId);\\n\\n  /**\\n   * @notice Call the hub and withdraws all swapped tokens from a position to a recipient\\n   * @dev Meant to be used as part of a multicall\\n   * @param hub The address of the DCAHub\\n   * @param positionId The position's id\\n   * @param recipient The address to withdraw swapped tokens to\\n   * @return swapped How much was withdrawn\\n   */\\n  function withdrawSwapped(\\n    IDCAHub hub,\\n    uint256 positionId,\\n    address recipient\\n  ) external payable returns (uint256 swapped);\\n\\n  /**\\n   * @notice Call the hub and withdraws all swapped tokens from multiple positions\\n   * @dev Meant to be used as part of a multicall\\n   * @param hub The address of the DCAHub\\n   * @param positions A list positions, grouped by `to` token\\n   * @param recipient The address to withdraw swapped tokens to\\n   * @return withdrawn How much was withdrawn for each token\\n   */\\n  function withdrawSwappedMany(\\n    IDCAHub hub,\\n    IDCAHub.PositionSet[] calldata positions,\\n    address recipient\\n  ) external payable returns (uint256[] memory withdrawn);\\n\\n  /**\\n   * @notice Call the hub and takes the unswapped balance, adds the new deposited funds and modifies the position so that\\n   * it is executed in `newSwaps` swaps\\n   * @dev Meant to be used as part of a multicall\\n   * @param hub The address of the DCAHub\\n   * @param positionId The position's id\\n   * @param amount Amount of funds to add to the position\\n   * @param newSwaps The new amount of swaps\\n   */\\n  function increasePosition(\\n    IDCAHub hub,\\n    uint256 positionId,\\n    uint256 amount,\\n    uint32 newSwaps\\n  ) external payable;\\n\\n  /**\\n   * @notice Call the hub and takes the unswapped balance, adds the Companion's current balance and modifies the position so that\\n   * it is executed in `newSwaps` swaps\\n   * @dev Meant to be used as part of a multicall\\n   * @param hub The address of the DCAHub\\n   * @param positionId The position's id\\n   * @param newSwaps The new amount of swaps\\n   */\\n  function increasePositionWithBalanceOnContract(\\n    IDCAHub hub,\\n    uint256 positionId,\\n    uint32 newSwaps\\n  ) external payable;\\n\\n  /**\\n   * @notice Call the hub and withdraws the specified amount from the unswapped balance and modifies the position so that\\n   * it is executed in newSwaps swaps\\n   * @dev Meant to be used as part of a multicall\\n   * @param hub The address of the DCAHub\\n   * @param positionId The position's id\\n   * @param amount Amount of funds to withdraw from the position\\n   * @param newSwaps The new amount of swaps\\n   * @param recipient The address to send tokens to\\n   */\\n  function reducePosition(\\n    IDCAHub hub,\\n    uint256 positionId,\\n    uint256 amount,\\n    uint32 newSwaps,\\n    address recipient\\n  ) external payable;\\n\\n  /**\\n   * @notice Calls the hub and terminates the position and sends all unswapped and swapped balance to the specified recipients\\n   * @dev Meant to be used as part of a multicall\\n   * @param hub The address of the DCAHub\\n   * @param positionId The position's id\\n   * @param recipientUnswapped The address to withdraw unswapped tokens to\\n   * @param recipientSwapped The address to withdraw swapped tokens to\\n   * @return unswapped The unswapped balance sent to `recipientUnswapped`\\n   * @return swapped The swapped balance sent to `recipientSwapped`\\n   */\\n  function terminate(\\n    IDCAHub hub,\\n    uint256 positionId,\\n    address recipientUnswapped,\\n    address recipientSwapped\\n  ) external payable returns (uint256 unswapped, uint256 swapped);\\n\\n  /**\\n   * @notice Calls the permission manager and sets multiple permissions via signature\\n   * @param permissionManager The address of the permission manager\\n   * @param permissions The permissions to set\\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n   */\\n  function multiPermissionPermit(\\n    IDCAPermissionManager permissionManager,\\n    IDCAPermissionManager.PositionPermissions[] calldata permissions,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external payable;\\n\\n  /**\\n   * @notice Calls the permission manager and sets permissions via signature\\n   * @param permissionManager The address of the permission manager\\n   * @param permissions The permissions to set\\n   * @param tokenId The token's id\\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n   */\\n  function permissionPermit(\\n    IDCAPermissionManager permissionManager,\\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\\n    uint256 tokenId,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external payable;\\n}\\n\\ninterface IDCAHubCompanion is IDCAHubCompanionLibrariesHandler, IDCAHubCompanionHubProxyHandler {}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/libraries/SecondsUntilNextSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\\nimport '@mean-finance/dca-v2-core/contracts/libraries/TokenSorting.sol';\\nimport '@mean-finance/dca-v2-core/contracts/libraries/Intervals.sol';\\nimport '../interfaces/ISharedTypes.sol';\\n\\n/**\\n * @title Seconds Until Next Swap Library\\n * @notice Provides functions to calculate how long users have to wait until a pair's next swap is available\\n */\\nlibrary SecondsUntilNextSwap {\\n  /**\\n   * @notice Returns how many seconds left until the next swap is available for a specific pair\\n   * @dev _tokenA and _tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param _hub The address of the DCA Hub\\n   * @param _tokenA One of the pair's tokens\\n   * @param _tokenB The other of the pair's tokens\\n   * @param _calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\\n   *        the possibility to calculate the seconds until next swap for privileged and non-privileged accounts\\n   * @return The amount of seconds until next swap. Returns 0 if a swap can already be executed and max(uint256) if there is nothing to swap\\n   */\\n  function secondsUntilNextSwap(\\n    IDCAHub _hub,\\n    address _tokenA,\\n    address _tokenB,\\n    bool _calculatePrivilegedAvailability\\n  ) internal view returns (uint256) {\\n    (address __tokenA, address __tokenB) = TokenSorting.sortTokens(_tokenA, _tokenB);\\n    bytes1 _activeIntervals = _hub.activeSwapIntervals(__tokenA, __tokenB);\\n    bytes1 _mask = 0x01;\\n    uint256 _smallerIntervalBlocking;\\n    while (_activeIntervals >= _mask && _mask > 0) {\\n      if (_activeIntervals & _mask == _mask) {\\n        (, uint224 _nextAmountToSwapAToB, uint32 _lastSwappedAt, uint224 _nextAmountToSwapBToA) = _hub.swapData(_tokenA, _tokenB, _mask);\\n        uint32 _swapInterval = Intervals.maskToInterval(_mask);\\n        uint256 _nextAvailable = ((_lastSwappedAt / _swapInterval) + 1) * _swapInterval;\\n        if (!_calculatePrivilegedAvailability) {\\n          // If the caller does not have privileges, then they will have to wait a little more to execute swaps\\n          _nextAvailable += _swapInterval / 3;\\n        }\\n        if (_nextAmountToSwapAToB > 0 || _nextAmountToSwapBToA > 0) {\\n          if (_nextAvailable <= block.timestamp) {\\n            return _smallerIntervalBlocking;\\n          } else {\\n            return _nextAvailable - block.timestamp;\\n          }\\n        } else if (_nextAvailable > block.timestamp) {\\n          _smallerIntervalBlocking = _smallerIntervalBlocking == 0 ? _nextAvailable - block.timestamp : _smallerIntervalBlocking;\\n        }\\n      }\\n      _mask <<= 1;\\n    }\\n    return type(uint256).max;\\n  }\\n\\n  /**\\n   * @notice Returns how many seconds left until the next swap is available for a list of pairs\\n   * @dev Tokens in pairs may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param _hub The address of the DCA Hub\\n   * @param _pairs Pairs to check\\n   * @return _seconds The amount of seconds until next swap for each of the pairs\\n   * @param _calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\\n   *        the possibility to calculate the seconds until next swap for privileged and non-privileged accounts\\n   */\\n  function secondsUntilNextSwap(\\n    IDCAHub _hub,\\n    Pair[] calldata _pairs,\\n    bool _calculatePrivilegedAvailability\\n  ) internal view returns (uint256[] memory _seconds) {\\n    _seconds = new uint256[](_pairs.length);\\n    for (uint256 i; i < _pairs.length; i++) {\\n      _seconds[i] = secondsUntilNextSwap(_hub, _pairs[i].tokenA, _pairs[i].tokenB, _calculatePrivilegedAvailability);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport '@mean-finance/oracles/solidity/interfaces/ITokenPriceOracle.sol';\\nimport './IDCAPermissionManager.sol';\\n\\n/**\\n * @title The interface for all state related queries\\n * @notice These methods allow users to read the hubs's current values\\n */\\ninterface IDCAHubParameters {\\n  /**\\n   * @notice Returns how much will the amount to swap differ from the previous swap. f.e. if the returned value is -100, then the amount to swap will be 100 less than the swap just before it\\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\\n   * @param tokenA One of the pair's token\\n   * @param tokenB The other of the pair's token\\n   * @param swapIntervalMask The byte representation of the swap interval to check\\n   * @param swapNumber The swap number to check\\n   * @return swapDeltaAToB How much less of token A will the following swap require\\n   * @return swapDeltaBToA How much less of token B will the following swap require\\n   */\\n  function swapAmountDelta(\\n    address tokenA,\\n    address tokenB,\\n    bytes1 swapIntervalMask,\\n    uint32 swapNumber\\n  ) external view returns (uint128 swapDeltaAToB, uint128 swapDeltaBToA);\\n\\n  /**\\n   * @notice Returns the sum of the ratios reported in all swaps executed until the given swap number\\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\\n   * @param tokenA One of the pair's token\\n   * @param tokenB The other of the pair's token\\n   * @param swapIntervalMask The byte representation of the swap interval to check\\n   * @param swapNumber The swap number to check\\n   * @return accumRatioAToB The sum of all ratios from A to B\\n   * @return accumRatioBToA The sum of all ratios from B to A\\n   */\\n  function accumRatio(\\n    address tokenA,\\n    address tokenB,\\n    bytes1 swapIntervalMask,\\n    uint32 swapNumber\\n  ) external view returns (uint256 accumRatioAToB, uint256 accumRatioBToA);\\n\\n  /**\\n   * @notice Returns swapping information about a specific pair\\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\\n   * @param tokenA One of the pair's token\\n   * @param tokenB The other of the pair's token\\n   * @param swapIntervalMask The byte representation of the swap interval to check\\n   * @return performedSwaps How many swaps have been executed\\n   * @return nextAmountToSwapAToB How much of token A will be swapped on the next swap\\n   * @return lastSwappedAt Timestamp of the last swap\\n   * @return nextAmountToSwapBToA How much of token B will be swapped on the next swap\\n   */\\n  function swapData(\\n    address tokenA,\\n    address tokenB,\\n    bytes1 swapIntervalMask\\n  )\\n    external\\n    view\\n    returns (\\n      uint32 performedSwaps,\\n      uint224 nextAmountToSwapAToB,\\n      uint32 lastSwappedAt,\\n      uint224 nextAmountToSwapBToA\\n    );\\n\\n  /**\\n   * @notice Returns the byte representation of the set of actice swap intervals for the given pair\\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\\n   * @param tokenA The smaller of the pair's token\\n   * @param tokenB The other of the pair's token\\n   * @return The byte representation of the set of actice swap intervals\\n   */\\n  function activeSwapIntervals(address tokenA, address tokenB) external view returns (bytes1);\\n\\n  /**\\n   * @notice Returns how much of the hub's token balance belongs to the platform\\n   * @param token The token to check\\n   * @return The amount that belongs to the platform\\n   */\\n  function platformBalance(address token) external view returns (uint256);\\n}\\n\\n/**\\n * @title The interface for all position related matters\\n * @notice These methods allow users to create, modify and terminate their positions\\n */\\ninterface IDCAHubPositionHandler {\\n  /// @notice The position of a certain user\\n  struct UserPosition {\\n    // The token that the user deposited and will be swapped in exchange for \\\"to\\\"\\n    IERC20Metadata from;\\n    // The token that the user will get in exchange for their \\\"from\\\" tokens in each swap\\n    IERC20Metadata to;\\n    // How frequently the position's swaps should be executed\\n    uint32 swapInterval;\\n    // How many swaps were executed since deposit, last modification, or last withdraw\\n    uint32 swapsExecuted;\\n    // How many \\\"to\\\" tokens can currently be withdrawn\\n    uint256 swapped;\\n    // How many swaps left the position has to execute\\n    uint32 swapsLeft;\\n    // How many \\\"from\\\" tokens there are left to swap\\n    uint256 remaining;\\n    // How many \\\"from\\\" tokens need to be traded in each swap\\n    uint120 rate;\\n  }\\n\\n  /// @notice A list of positions that all have the same `to` token\\n  struct PositionSet {\\n    // The `to` token\\n    address token;\\n    // The position ids\\n    uint256[] positionIds;\\n  }\\n\\n  /**\\n   * @notice Emitted when a position is terminated\\n   * @param user The address of the user that terminated the position\\n   * @param recipientUnswapped The address of the user that will receive the unswapped tokens\\n   * @param recipientSwapped The address of the user that will receive the swapped tokens\\n   * @param positionId The id of the position that was terminated\\n   * @param returnedUnswapped How many \\\"from\\\" tokens were returned to the caller\\n   * @param returnedSwapped How many \\\"to\\\" tokens were returned to the caller\\n   */\\n  event Terminated(\\n    address indexed user,\\n    address indexed recipientUnswapped,\\n    address indexed recipientSwapped,\\n    uint256 positionId,\\n    uint256 returnedUnswapped,\\n    uint256 returnedSwapped\\n  );\\n\\n  /**\\n   * @notice Emitted when a position is created\\n   * @param depositor The address of the user that creates the position\\n   * @param owner The address of the user that will own the position\\n   * @param positionId The id of the position that was created\\n   * @param fromToken The address of the \\\"from\\\" token\\n   * @param toToken The address of the \\\"to\\\" token\\n   * @param swapInterval How frequently the position's swaps should be executed\\n   * @param rate How many \\\"from\\\" tokens need to be traded in each swap\\n   * @param startingSwap The number of the swap when the position will be executed for the first time\\n   * @param lastSwap The number of the swap when the position will be executed for the last time\\n   * @param permissions The permissions defined for the position\\n   */\\n  event Deposited(\\n    address indexed depositor,\\n    address indexed owner,\\n    uint256 positionId,\\n    address fromToken,\\n    address toToken,\\n    uint32 swapInterval,\\n    uint120 rate,\\n    uint32 startingSwap,\\n    uint32 lastSwap,\\n    IDCAPermissionManager.PermissionSet[] permissions\\n  );\\n\\n  /**\\n   * @notice Emitted when a position is created and extra data is provided\\n   * @param positionId The id of the position that was created\\n   * @param data The extra data that was provided\\n   */\\n  event Miscellaneous(uint256 positionId, bytes data);\\n\\n  /**\\n   * @notice Emitted when a user withdraws all swapped tokens from a position\\n   * @param withdrawer The address of the user that executed the withdraw\\n   * @param recipient The address of the user that will receive the withdrawn tokens\\n   * @param positionId The id of the position that was affected\\n   * @param token The address of the withdrawn tokens. It's the same as the position's \\\"to\\\" token\\n   * @param amount The amount that was withdrawn\\n   */\\n  event Withdrew(address indexed withdrawer, address indexed recipient, uint256 positionId, address token, uint256 amount);\\n\\n  /**\\n   * @notice Emitted when a user withdraws all swapped tokens from many positions\\n   * @param withdrawer The address of the user that executed the withdraws\\n   * @param recipient The address of the user that will receive the withdrawn tokens\\n   * @param positions The positions to withdraw from\\n   * @param withdrew The total amount that was withdrawn from each token\\n   */\\n  event WithdrewMany(address indexed withdrawer, address indexed recipient, PositionSet[] positions, uint256[] withdrew);\\n\\n  /**\\n   * @notice Emitted when a position is modified\\n   * @param user The address of the user that modified the position\\n   * @param positionId The id of the position that was modified\\n   * @param rate How many \\\"from\\\" tokens need to be traded in each swap\\n   * @param startingSwap The number of the swap when the position will be executed for the first time\\n   * @param lastSwap The number of the swap when the position will be executed for the last time\\n   */\\n  event Modified(address indexed user, uint256 positionId, uint120 rate, uint32 startingSwap, uint32 lastSwap);\\n\\n  /// @notice Thrown when a user tries to create a position with the same `from` & `to`\\n  error InvalidToken();\\n\\n  /// @notice Thrown when a user tries to create a position with a swap interval that is not allowed\\n  error IntervalNotAllowed();\\n\\n  /// @notice Thrown when a user tries operate on a position that doesn't exist (it might have been already terminated)\\n  error InvalidPosition();\\n\\n  /// @notice Thrown when a user tries operate on a position that they don't have access to\\n  error UnauthorizedCaller();\\n\\n  /// @notice Thrown when a user tries to create a position with zero swaps\\n  error ZeroSwaps();\\n\\n  /// @notice Thrown when a user tries to create a position with zero funds\\n  error ZeroAmount();\\n\\n  /// @notice Thrown when a user tries to withdraw a position whose `to` token doesn't match the specified one\\n  error PositionDoesNotMatchToken();\\n\\n  /// @notice Thrown when a user tries create or modify a position with an amount too big\\n  error AmountTooBig();\\n\\n  /**\\n   * @notice Returns the permission manager contract\\n   * @return The contract itself\\n   */\\n  function permissionManager() external view returns (IDCAPermissionManager);\\n\\n  /**\\n   * @notice Returns total created positions\\n   * @return The total created positions\\n   */\\n  function totalCreatedPositions() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a user position\\n   * @param positionId The id of the position\\n   * @return position The position itself\\n   */\\n  function userPosition(uint256 positionId) external view returns (UserPosition memory position);\\n\\n  /**\\n   * @notice Creates a new position\\n   * @dev Will revert:\\n   *      - With ZeroAddress if from, to or owner are zero\\n   *      - With InvalidToken if from == to\\n   *      - With ZeroAmount if amount is zero\\n   *      - With AmountTooBig if amount is too big\\n   *      - With ZeroSwaps if amountOfSwaps is zero\\n   *      - With IntervalNotAllowed if swapInterval is not allowed\\n   * @param from The address of the \\\"from\\\" token\\n   * @param to The address of the \\\"to\\\" token\\n   * @param amount How many \\\"from\\\" tokens will be swapped in total\\n   * @param amountOfSwaps How many swaps to execute for this position\\n   * @param swapInterval How frequently the position's swaps should be executed\\n   * @param owner The address of the owner of the position being created\\n   * @param permissions Extra permissions to add to the position. Can be empty\\n   * @return positionId The id of the created position\\n   */\\n  function deposit(\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint32 amountOfSwaps,\\n    uint32 swapInterval,\\n    address owner,\\n    IDCAPermissionManager.PermissionSet[] calldata permissions\\n  ) external returns (uint256 positionId);\\n\\n  /**\\n   * @notice Creates a new position\\n   * @dev Will revert:\\n   *      - With ZeroAddress if from, to or owner are zero\\n   *      - With InvalidToken if from == to\\n   *      - With ZeroAmount if amount is zero\\n   *      - With AmountTooBig if amount is too big\\n   *      - With ZeroSwaps if amountOfSwaps is zero\\n   *      - With IntervalNotAllowed if swapInterval is not allowed\\n   * @param from The address of the \\\"from\\\" token\\n   * @param to The address of the \\\"to\\\" token\\n   * @param amount How many \\\"from\\\" tokens will be swapped in total\\n   * @param amountOfSwaps How many swaps to execute for this position\\n   * @param swapInterval How frequently the position's swaps should be executed\\n   * @param owner The address of the owner of the position being created\\n   * @param permissions Extra permissions to add to the position. Can be empty\\n   * @param miscellaneous Bytes that will be emitted, and associated with the position\\n   * @return positionId The id of the created position\\n   */\\n  function deposit(\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint32 amountOfSwaps,\\n    uint32 swapInterval,\\n    address owner,\\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\\n    bytes calldata miscellaneous\\n  ) external returns (uint256 positionId);\\n\\n  /**\\n   * @notice Withdraws all swapped tokens from a position to a recipient\\n   * @dev Will revert:\\n   *      - With InvalidPosition if positionId is invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\\n   *      - With ZeroAddress if recipient is zero\\n   * @param positionId The position's id\\n   * @param recipient The address to withdraw swapped tokens to\\n   * @return swapped How much was withdrawn\\n   */\\n  function withdrawSwapped(uint256 positionId, address recipient) external returns (uint256 swapped);\\n\\n  /**\\n   * @notice Withdraws all swapped tokens from multiple positions\\n   * @dev Will revert:\\n   *      - With InvalidPosition if any of the position ids are invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position to any of the given positions\\n   *      - With ZeroAddress if recipient is zero\\n   *      - With PositionDoesNotMatchToken if any of the positions do not match the token in their position set\\n   * @param positions A list positions, grouped by `to` token\\n   * @param recipient The address to withdraw swapped tokens to\\n   * @return withdrawn How much was withdrawn for each token\\n   */\\n  function withdrawSwappedMany(PositionSet[] calldata positions, address recipient) external returns (uint256[] memory withdrawn);\\n\\n  /**\\n   * @notice Takes the unswapped balance, adds the new deposited funds and modifies the position so that\\n   * it is executed in newSwaps swaps\\n   * @dev Will revert:\\n   *      - With InvalidPosition if positionId is invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\\n   *      - With AmountTooBig if amount is too big\\n   * @param positionId The position's id\\n   * @param amount Amount of funds to add to the position\\n   * @param newSwaps The new amount of swaps\\n   */\\n  function increasePosition(\\n    uint256 positionId,\\n    uint256 amount,\\n    uint32 newSwaps\\n  ) external;\\n\\n  /**\\n   * @notice Withdraws the specified amount from the unswapped balance and modifies the position so that\\n   * it is executed in newSwaps swaps\\n   * @dev Will revert:\\n   *      - With InvalidPosition if positionId is invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\\n   *      - With ZeroSwaps if newSwaps is zero and amount is not the total unswapped balance\\n   * @param positionId The position's id\\n   * @param amount Amount of funds to withdraw from the position\\n   * @param newSwaps The new amount of swaps\\n   * @param recipient The address to send tokens to\\n   */\\n  function reducePosition(\\n    uint256 positionId,\\n    uint256 amount,\\n    uint32 newSwaps,\\n    address recipient\\n  ) external;\\n\\n  /**\\n   * @notice Terminates the position and sends all unswapped and swapped balance to the specified recipients\\n   * @dev Will revert:\\n   *      - With InvalidPosition if positionId is invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\\n   *      - With ZeroAddress if recipientUnswapped or recipientSwapped is zero\\n   * @param positionId The position's id\\n   * @param recipientUnswapped The address to withdraw unswapped tokens to\\n   * @param recipientSwapped The address to withdraw swapped tokens to\\n   * @return unswapped The unswapped balance sent to `recipientUnswapped`\\n   * @return swapped The swapped balance sent to `recipientSwapped`\\n   */\\n  function terminate(\\n    uint256 positionId,\\n    address recipientUnswapped,\\n    address recipientSwapped\\n  ) external returns (uint256 unswapped, uint256 swapped);\\n}\\n\\n/**\\n * @title The interface for all swap related matters\\n * @notice These methods allow users to get information about the next swap, and how to execute it\\n */\\ninterface IDCAHubSwapHandler {\\n  /// @notice Information about a swap\\n  struct SwapInfo {\\n    // The tokens involved in the swap\\n    TokenInSwap[] tokens;\\n    // The pairs involved in the swap\\n    PairInSwap[] pairs;\\n  }\\n\\n  /// @notice Information about a token's role in a swap\\n  struct TokenInSwap {\\n    // The token's address\\n    address token;\\n    // How much will be given of this token as a reward\\n    uint256 reward;\\n    // How much of this token needs to be provided by swapper\\n    uint256 toProvide;\\n    // How much of this token will be paid to the platform\\n    uint256 platformFee;\\n  }\\n\\n  /// @notice Information about a pair in a swap\\n  struct PairInSwap {\\n    // The address of one of the tokens\\n    address tokenA;\\n    // The address of the other token\\n    address tokenB;\\n    // The total amount of token A swapped in this pair\\n    uint256 totalAmountToSwapTokenA;\\n    // The total amount of token B swapped in this pair\\n    uint256 totalAmountToSwapTokenB;\\n    // How much is 1 unit of token A when converted to B\\n    uint256 ratioAToB;\\n    // How much is 1 unit of token B when converted to A\\n    uint256 ratioBToA;\\n    // The swap intervals involved in the swap, represented as a byte\\n    bytes1 intervalsInSwap;\\n  }\\n\\n  /// @notice A pair of tokens, represented by their indexes in an array\\n  struct PairIndexes {\\n    // The index of the token A\\n    uint8 indexTokenA;\\n    // The index of the token B\\n    uint8 indexTokenB;\\n  }\\n\\n  /**\\n   * @notice Emitted when a swap is executed\\n   * @param sender The address of the user that initiated the swap\\n   * @param rewardRecipient The address that received the reward\\n   * @param callbackHandler The address that executed the callback\\n   * @param swapInformation All information related to the swap\\n   * @param borrowed How much was borrowed\\n   * @param fee The swap fee at the moment of the swap\\n   */\\n  event Swapped(\\n    address indexed sender,\\n    address indexed rewardRecipient,\\n    address indexed callbackHandler,\\n    SwapInfo swapInformation,\\n    uint256[] borrowed,\\n    uint32 fee\\n  );\\n\\n  /// @notice Thrown when pairs indexes are not sorted correctly\\n  error InvalidPairs();\\n\\n  /// @notice Thrown when trying to execute a swap, but there is nothing to swap\\n  error NoSwapsToExecute();\\n\\n  /**\\n   * @notice Returns all information related to the next swap\\n   * @dev Will revert with:\\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\\n   * @param tokens The tokens involved in the next swap\\n   * @param pairs The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\\n   * @param calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\\n   *        the possibility to calculate the next swap information for privileged and non-privileged accounts\\n   * @param oracleData Bytes to send to the oracle when executing a quote\\n   * @return swapInformation The information about the next swap\\n   */\\n  function getNextSwapInfo(\\n    address[] calldata tokens,\\n    PairIndexes[] calldata pairs,\\n    bool calculatePrivilegedAvailability,\\n    bytes calldata oracleData\\n  ) external view returns (SwapInfo memory swapInformation);\\n\\n  /**\\n   * @notice Executes a flash swap\\n   * @dev Will revert with:\\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\\n   *      - With Paused if swaps are paused by protocol\\n   *      - With NoSwapsToExecute if there are no swaps to execute for the given pairs\\n   *      - With LiquidityNotReturned if the required tokens were not back during the callback\\n   * @param tokens The tokens involved in the next swap\\n   * @param pairsToSwap The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\\n   * @param rewardRecipient The address to send the reward to\\n   * @param callbackHandler Address to call for callback (and send the borrowed tokens to)\\n   * @param borrow How much to borrow of each of the tokens in tokens. The amount must match the position of the token in the tokens array\\n   * @param callbackData Bytes to send to the caller during the callback\\n   * @param oracleData Bytes to send to the oracle when executing a quote\\n   * @return Information about the executed swap\\n   */\\n  function swap(\\n    address[] calldata tokens,\\n    PairIndexes[] calldata pairsToSwap,\\n    address rewardRecipient,\\n    address callbackHandler,\\n    uint256[] calldata borrow,\\n    bytes calldata callbackData,\\n    bytes calldata oracleData\\n  ) external returns (SwapInfo memory);\\n}\\n\\n/**\\n * @title The interface for handling all configuration\\n * @notice This contract will manage configuration that affects all pairs, swappers, etc\\n */\\ninterface IDCAHubConfigHandler {\\n  /**\\n   * @notice Emitted when a new oracle is set\\n   * @param oracle The new oracle contract\\n   */\\n  event OracleSet(ITokenPriceOracle oracle);\\n\\n  /**\\n   * @notice Emitted when a new swap fee is set\\n   * @param feeSet The new swap fee\\n   */\\n  event SwapFeeSet(uint32 feeSet);\\n\\n  /**\\n   * @notice Emitted when new swap intervals are allowed\\n   * @param swapIntervals The new swap intervals\\n   */\\n  event SwapIntervalsAllowed(uint32[] swapIntervals);\\n\\n  /**\\n   * @notice Emitted when some swap intervals are no longer allowed\\n   * @param swapIntervals The swap intervals that are no longer allowed\\n   */\\n  event SwapIntervalsForbidden(uint32[] swapIntervals);\\n\\n  /**\\n   * @notice Emitted when a new platform fee ratio is set\\n   * @param platformFeeRatio The new platform fee ratio\\n   */\\n  event PlatformFeeRatioSet(uint16 platformFeeRatio);\\n\\n  /**\\n   * @notice Emitted when allowed states of tokens are updated\\n   * @param tokens Array of updated tokens\\n   * @param allowed Array of new allow state per token were allowed[i] is the updated state of tokens[i]\\n   */\\n  event TokensAllowedUpdated(address[] tokens, bool[] allowed);\\n\\n  /// @notice Thrown when trying to interact with an unallowed token\\n  error UnallowedToken();\\n\\n  /// @notice Thrown when set allowed tokens input is not valid\\n  error InvalidAllowedTokensInput();\\n\\n  /// @notice Thrown when trying to set a fee higher than the maximum allowed\\n  error HighFee();\\n\\n  /// @notice Thrown when trying to set a fee that is not multiple of 100\\n  error InvalidFee();\\n\\n  /// @notice Thrown when trying to set a fee ratio that is higher that the maximum allowed\\n  error HighPlatformFeeRatio();\\n\\n  /**\\n   * @notice Returns the max fee ratio that can be set\\n   * @dev Cannot be modified\\n   * @return The maximum possible value\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MAX_PLATFORM_FEE_RATIO() external view returns (uint16);\\n\\n  /**\\n   * @notice Returns the fee charged on swaps\\n   * @return swapFee The fee itself\\n   */\\n  function swapFee() external view returns (uint32 swapFee);\\n\\n  /**\\n   * @notice Returns the price oracle contract\\n   * @return oracle The contract itself\\n   */\\n  function oracle() external view returns (ITokenPriceOracle oracle);\\n\\n  /**\\n   * @notice Returns how much will the platform take from the fees collected in swaps\\n   * @return The current ratio\\n   */\\n  function platformFeeRatio() external view returns (uint16);\\n\\n  /**\\n   * @notice Returns the max fee that can be set for swaps\\n   * @dev Cannot be modified\\n   * @return maxFee The maximum possible fee\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MAX_FEE() external view returns (uint32 maxFee);\\n\\n  /**\\n   * @notice Returns a byte that represents allowed swap intervals\\n   * @return allowedSwapIntervals The allowed swap intervals\\n   */\\n  function allowedSwapIntervals() external view returns (bytes1 allowedSwapIntervals);\\n\\n  /**\\n   * @notice Returns if a token is currently allowed or not\\n   * @return Allowed state of token\\n   */\\n  function allowedTokens(address token) external view returns (bool);\\n\\n  /**\\n   * @notice Returns token's magnitude (10**decimals)\\n   * @return Stored magnitude for token\\n   */\\n  function tokenMagnitude(address token) external view returns (uint120);\\n\\n  /**\\n   * @notice Returns whether swaps and deposits are currently paused\\n   * @return isPaused Whether swaps and deposits are currently paused\\n   */\\n  function paused() external view returns (bool isPaused);\\n\\n  /**\\n   * @notice Sets a new swap fee\\n   * @dev Will revert with HighFee if the fee is higher than the maximum\\n   * @dev Will revert with InvalidFee if the fee is not multiple of 100\\n   * @param fee The new swap fee\\n   */\\n  function setSwapFee(uint32 fee) external;\\n\\n  /**\\n   * @notice Sets a new price oracle\\n   * @dev Will revert with ZeroAddress if the zero address is passed\\n   * @param oracle The new oracle contract\\n   */\\n  function setOracle(ITokenPriceOracle oracle) external;\\n\\n  /**\\n   * @notice Sets a new platform fee ratio\\n   * @dev Will revert with HighPlatformFeeRatio if given ratio is too high\\n   * @param platformFeeRatio The new ratio\\n   */\\n  function setPlatformFeeRatio(uint16 platformFeeRatio) external;\\n\\n  /**\\n   * @notice Adds new swap intervals to the allowed list\\n   * @param swapIntervals The new swap intervals\\n   */\\n  function addSwapIntervalsToAllowedList(uint32[] calldata swapIntervals) external;\\n\\n  /**\\n   * @notice Removes some swap intervals from the allowed list\\n   * @param swapIntervals The swap intervals to remove\\n   */\\n  function removeSwapIntervalsFromAllowedList(uint32[] calldata swapIntervals) external;\\n\\n  /// @notice Pauses all swaps and deposits\\n  function pause() external;\\n\\n  /// @notice Unpauses all swaps and deposits\\n  function unpause() external;\\n}\\n\\n/**\\n * @title The interface for handling platform related actions\\n * @notice This contract will handle all actions that affect the platform in some way\\n */\\ninterface IDCAHubPlatformHandler {\\n  /**\\n   * @notice Emitted when someone withdraws from the paltform balance\\n   * @param sender The address of the user that initiated the withdraw\\n   * @param recipient The address that received the withdraw\\n   * @param amounts The tokens (and the amount) that were withdrawn\\n   */\\n  event WithdrewFromPlatform(address indexed sender, address indexed recipient, IDCAHub.AmountOfToken[] amounts);\\n\\n  /**\\n   * @notice Withdraws tokens from the platform balance\\n   * @param amounts The amounts to withdraw\\n   * @param recipient The address that will receive the tokens\\n   */\\n  function withdrawFromPlatformBalance(IDCAHub.AmountOfToken[] calldata amounts, address recipient) external;\\n}\\n\\ninterface IDCAHub is IDCAHubParameters, IDCAHubConfigHandler, IDCAHubSwapHandler, IDCAHubPositionHandler, IDCAHubPlatformHandler {\\n  /// @notice Specifies an amount of a token. For example to determine how much to borrow from certain tokens\\n  struct AmountOfToken {\\n    // The tokens' address\\n    address token;\\n    // How much to borrow or withdraw of the specified token\\n    uint256 amount;\\n  }\\n\\n  /// @notice Thrown when one of the parameters is a zero address\\n  error ZeroAddress();\\n\\n  /// @notice Thrown when the expected liquidity is not returned in flash swaps\\n  error LiquidityNotReturned();\\n\\n  /// @notice Thrown when a list of token pairs is not sorted, or if there are duplicates\\n  error InvalidTokens();\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/interfaces/ISharedTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\n/// @notice A pair of tokens\\nstruct Pair {\\n  address tokenA;\\n  address tokenB;\\n}\\n\"\r\n    },\r\n    \"@mean-finance/oracles/solidity/interfaces/ITokenPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title The interface for an oracle that provides price quotes\\n * @notice These methods allow users to add support for pairs, and then ask for quotes\\n */\\ninterface ITokenPriceOracle {\\n  /// @notice Thrown when trying to add support for a pair that cannot be supported\\n  error PairCannotBeSupported(address tokenA, address tokenB);\\n\\n  /// @notice Thrown when trying to execute a quote with a pair that isn't supported yet\\n  error PairNotSupportedYet(address tokenA, address tokenB);\\n\\n  /**\\n   * @notice Returns whether this oracle can support the given pair of tokens\\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @return Whether the given pair of tokens can be supported by the oracle\\n   */\\n  function canSupportPair(address tokenA, address tokenB) external view returns (bool);\\n\\n  /**\\n   * @notice Returns whether this oracle is already supporting the given pair of tokens\\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @return Whether the given pair of tokens is already being supported by the oracle\\n   */\\n  function isPairAlreadySupported(address tokenA, address tokenB) external view returns (bool);\\n\\n  /**\\n   * @notice Returns a quote, based on the given tokens and amount\\n   * @dev Will revert if pair isn't supported\\n   * @param tokenIn The token that will be provided\\n   * @param amountIn The amount that will be provided\\n   * @param tokenOut The token we would like to quote\\n   * @param data Custom data that the oracle might need to operate\\n   * @return amountOut How much `tokenOut` will be returned in exchange for `amountIn` amount of `tokenIn`\\n   */\\n  function quote(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut,\\n    bytes calldata data\\n  ) external view returns (uint256 amountOut);\\n\\n  /**\\n   * @notice Add or reconfigures the support for a given pair. This function will let the oracle take some actions\\n   *         to configure the pair, in preparation for future quotes. Can be called many times in order to let the oracle\\n   *         re-configure for a new context\\n   * @dev Will revert if pair cannot be supported. tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @param data Custom data that the oracle might need to operate\\n   */\\n  function addOrModifySupportForPair(\\n    address tokenA,\\n    address tokenB,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @notice Adds support for a given pair if the oracle didn't support it already. If called for a pair that is already supported,\\n   *         then nothing will happen. This function will let the oracle take some actions to configure the pair, in preparation\\n   *         for future quotes\\n   * @dev Will revert if pair cannot be supported. tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @param data Custom data that the oracle might need to operate\\n   */\\n  function addSupportForPairIfNeeded(\\n    address tokenA,\\n    address tokenB,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-core/contracts/interfaces/IDCAPermissionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport '@mean-finance/nft-descriptors/solidity/interfaces/IDCAHubPositionDescriptor.sol';\\n\\ninterface IERC721BasicEnumerable {\\n  /**\\n   * @notice Count NFTs tracked by this contract\\n   * @return A count of valid NFTs tracked by this contract, where each one of\\n   *         them has an assigned and queryable owner not equal to the zero address\\n   */\\n  function totalSupply() external view returns (uint256);\\n}\\n\\n/**\\n * @title The interface for all permission related matters\\n * @notice These methods allow users to set and remove permissions to their positions\\n */\\ninterface IDCAPermissionManager is IERC721, IERC721BasicEnumerable {\\n  /// @notice Set of possible permissions\\n  enum Permission {\\n    INCREASE,\\n    REDUCE,\\n    WITHDRAW,\\n    TERMINATE\\n  }\\n\\n  /// @notice A set of permissions for a specific operator\\n  struct PermissionSet {\\n    // The address of the operator\\n    address operator;\\n    // The permissions given to the overator\\n    Permission[] permissions;\\n  }\\n\\n  /// @notice A collection of permissions sets for a specific position\\n  struct PositionPermissions {\\n    // The id of the token\\n    uint256 tokenId;\\n    // The permissions to assign to the position\\n    PermissionSet[] permissionSets;\\n  }\\n\\n  /**\\n   * @notice Emitted when permissions for a token are modified\\n   * @param tokenId The id of the token\\n   * @param permissions The set of permissions that were updated\\n   */\\n  event Modified(uint256 tokenId, PermissionSet[] permissions);\\n\\n  /**\\n   * @notice Emitted when the address for a new descritor is set\\n   * @param descriptor The new descriptor contract\\n   */\\n  event NFTDescriptorSet(IDCAHubPositionDescriptor descriptor);\\n\\n  /// @notice Thrown when a user tries to set the hub, once it was already set\\n  error HubAlreadySet();\\n\\n  /// @notice Thrown when a user provides a zero address when they shouldn't\\n  error ZeroAddress();\\n\\n  /// @notice Thrown when a user calls a method that can only be executed by the hub\\n  error OnlyHubCanExecute();\\n\\n  /// @notice Thrown when a user tries to modify permissions for a token they do not own\\n  error NotOwner();\\n\\n  /// @notice Thrown when a user tries to execute a permit with an expired deadline\\n  error ExpiredDeadline();\\n\\n  /// @notice Thrown when a user tries to execute a permit with an invalid signature\\n  error InvalidSignature();\\n\\n  /**\\n   * @notice The permit typehash used in the permit signature\\n   * @return The typehash for the permit\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The permit typehash used in the permission permit signature\\n   * @return The typehash for the permission permit\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function PERMISSION_PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The permit typehash used in the multi permission permit signature\\n   * @return The typehash for the multi permission permit\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MULTI_PERMISSION_PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The permit typehash used in the permission permit signature\\n   * @return The typehash for the permission set\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function PERMISSION_SET_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The permit typehash used in the multi permission permit signature\\n   * @return The typehash for the position permissions\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function POSITION_PERMISSIONS_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The domain separator used in the permit signature\\n   * @return The domain seperator used in encoding of permit signature\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  /**\\n   * @notice Returns the NFT descriptor contract\\n   * @return The contract for the NFT descriptor\\n   */\\n  function nftDescriptor() external returns (IDCAHubPositionDescriptor);\\n\\n  /**\\n   * @notice Returns the address of the DCA Hub\\n   * @return The address of the DCA Hub\\n   */\\n  function hub() external returns (address);\\n\\n  /**\\n   * @notice Returns the next nonce to use for a given user\\n   * @param user The address of the user\\n   * @return nonce The next nonce to use\\n   */\\n  function nonces(address user) external returns (uint256 nonce);\\n\\n  /**\\n   * @notice Returns whether the given address has the permission for the given token\\n   * @param id The id of the token to check\\n   * @param account The address of the user to check\\n   * @param permission The permission to check\\n   * @return Whether the user has the permission or not\\n   */\\n  function hasPermission(\\n    uint256 id,\\n    address account,\\n    Permission permission\\n  ) external view returns (bool);\\n\\n  /**\\n   * @notice Returns whether the given address has the permissions for the given token\\n   * @param id The id of the token to check\\n   * @param account The address of the user to check\\n   * @param permissions The permissions to check\\n   * @return hasPermissions Whether the user has each permission or not\\n   */\\n  function hasPermissions(\\n    uint256 id,\\n    address account,\\n    Permission[] calldata permissions\\n  ) external view returns (bool[] memory hasPermissions);\\n\\n  /**\\n   * @notice Sets the address for the hub\\n   * @dev Can only be successfully executed once. Once it's set, it can be modified again\\n   *      Will revert:\\n   *      - With ZeroAddress if address is zero\\n   *      - With HubAlreadySet if the hub has already been set\\n   * @param hub The address to set for the hub\\n   */\\n  function setHub(address hub) external;\\n\\n  /**\\n   * @notice Mints a new NFT with the given id, and sets the permissions for it\\n   * @dev Will revert with OnlyHubCanExecute if the caller is not the hub\\n   * @param id The id of the new NFT\\n   * @param owner The owner of the new NFT\\n   * @param permissions Permissions to set for the new NFT\\n   */\\n  function mint(\\n    uint256 id,\\n    address owner,\\n    PermissionSet[] calldata permissions\\n  ) external;\\n\\n  /**\\n   * @notice Burns the NFT with the given id, and clears all permissions\\n   * @dev Will revert with OnlyHubCanExecute if the caller is not the hub\\n   * @param id The token's id\\n   */\\n  function burn(uint256 id) external;\\n\\n  /**\\n   * @notice Sets new permissions for the given position\\n   * @dev Will revert with NotOwner if the caller is not the token's owner.\\n   *      Operators that are not part of the given permission sets do not see their permissions modified.\\n   *      In order to remove permissions to an operator, provide an empty list of permissions for them\\n   * @param id The token's id\\n   * @param permissions A list of permission sets\\n   */\\n  function modify(uint256 id, PermissionSet[] calldata permissions) external;\\n\\n  /**\\n   * @notice Sets new permissions for the given positions\\n   * @dev This is basically the same as executing multiple `modify`\\n   * @param permissions A list of position permissions to set\\n   */\\n  function modifyMany(PositionPermissions[] calldata permissions) external;\\n\\n  /**\\n   * @notice Approves spending of a specific token ID by spender via signature\\n   * @param spender The account that is being approved\\n   * @param tokenId The ID of the token that is being approved for spending\\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n   */\\n  function permit(\\n    address spender,\\n    uint256 tokenId,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @notice Sets permissions via signature\\n   * @dev This method works similarly to `modifyMany`, but instead of being executed by the owner, it can be set by signature\\n   * @param permissions The permissions to set for the different positions\\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n   */\\n  function multiPermissionPermit(\\n    PositionPermissions[] calldata permissions,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @notice Sets permissions via signature\\n   * @dev This method works similarly to `modify`, but instead of being executed by the owner, it can be set my signature\\n   * @param permissions The permissions to set\\n   * @param tokenId The token's id\\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n   */\\n  function permissionPermit(\\n    PermissionSet[] calldata permissions,\\n    uint256 tokenId,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @notice Sets a new NFT descriptor\\n   * @dev Will revert with ZeroAddress if address is zero\\n   * @param descriptor The new NFT descriptor contract\\n   */\\n  function setNFTDescriptor(IDCAHubPositionDescriptor descriptor) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@mean-finance/nft-descriptors/solidity/interfaces/IDCAHubPositionDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\n/**\\n * @title The interface for generating a description for a position in a DCA Hub\\n * @notice Contracts that implement this interface must return a base64 JSON with the entire description\\n */\\ninterface IDCAHubPositionDescriptor {\\n  /**\\n   * @notice Generates a positions's description, both the JSON and the image inside\\n   * @param hub The address of the DCA Hub\\n   * @param positionId The token/position id\\n   * @return description The position's description\\n   */\\n  function tokenURI(address hub, uint256 positionId) external view returns (string memory description);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/interfaces/ILegacyDCAHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\\n\\ninterface ILegacyDCAHub {\\n  /// @notice Information about a swap\\n  struct SwapInfo {\\n    // The tokens involved in the swap\\n    TokenInSwap[] tokens;\\n    // The pairs involved in the swap\\n    PairInSwap[] pairs;\\n  }\\n\\n  /// @notice Information about a token's role in a swap\\n  struct TokenInSwap {\\n    // The token's address\\n    address token;\\n    // How much will be given of this token as a reward\\n    uint256 reward;\\n    // How much of this token needs to be provided by swapper\\n    uint256 toProvide;\\n    // How much of this token will be paid to the platform\\n    uint256 platformFee;\\n  }\\n\\n  /// @notice Information about a pair in a swap\\n  struct PairInSwap {\\n    // The address of one of the tokens\\n    address tokenA;\\n    // The address of the other token\\n    address tokenB;\\n    // How much is 1 unit of token A when converted to B\\n    uint256 ratioAToB;\\n    // How much is 1 unit of token B when converted to A\\n    uint256 ratioBToA;\\n    // The swap intervals involved in the swap, represented as a byte\\n    bytes1 intervalsInSwap;\\n  }\\n\\n  /**\\n   * @notice Returns all information related to the next swap\\n   * @dev Will revert with:\\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\\n   * @param tokens The tokens involved in the next swap\\n   * @param pairs The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\\n   * @return swapInformation The information about the next swap\\n   */\\n  function getNextSwapInfo(address[] calldata tokens, IDCAHub.PairIndexes[] calldata pairs)\\n    external\\n    view\\n    returns (SwapInfo memory swapInformation);\\n\\n  /**\\n   * @notice Executes a flash swap\\n   * @dev Will revert with:\\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\\n   *      - With Paused if swaps are paused by protocol\\n   *      - With NoSwapsToExecute if there are no swaps to execute for the given pairs\\n   *      - With LiquidityNotReturned if the required tokens were not back during the callback\\n   * @param tokens The tokens involved in the next swap\\n   * @param pairsToSwap The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\\n   * @param rewardRecipient The address to send the reward to\\n   * @param callbackHandler Address to call for callback (and send the borrowed tokens to)\\n   * @param borrow How much to borrow of each of the tokens in tokens. The amount must match the position of the token in the tokens array\\n   * @param callbackData Bytes to send to the caller during the callback\\n   * @return Information about the executed swap\\n   */\\n  function swap(\\n    address[] calldata tokens,\\n    IDCAHub.PairIndexes[] calldata pairsToSwap,\\n    address rewardRecipient,\\n    address callbackHandler,\\n    uint256[] calldata borrow,\\n    bytes calldata callbackData\\n  ) external returns (SwapInfo memory);\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-core/contracts/libraries/TokenSorting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >0.6;\\n\\n/// @title TokenSorting library\\n/// @notice Provides functions to sort tokens easily\\nlibrary TokenSorting {\\n  /// @notice Takes two tokens, and returns them sorted\\n  /// @param _tokenA One of the tokens\\n  /// @param _tokenB The other token\\n  /// @return __tokenA The first of the tokens\\n  /// @return __tokenB The second of the tokens\\n  function sortTokens(address _tokenA, address _tokenB) internal pure returns (address __tokenA, address __tokenB) {\\n    (__tokenA, __tokenB) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-core/contracts/libraries/Intervals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\n/// @title Intervals library\\n/// @notice Provides functions to easily convert from swap intervals to their byte representation and viceversa\\nlibrary Intervals {\\n  /// @notice Thrown when a user tries convert and invalid interval to a byte representation\\n  error InvalidInterval();\\n\\n  /// @notice Thrown when a user tries convert and invalid byte representation to an interval\\n  error InvalidMask();\\n\\n  /// @notice Takes a swap interval and returns its byte representation\\n  /// @dev Will revert with InvalidInterval if the swap interval is not valid\\n  /// @param _swapInterval The swap interval\\n  /// @return The interval's byte representation\\n  function intervalToMask(uint32 _swapInterval) internal pure returns (bytes1) {\\n    if (_swapInterval == 1 minutes) return 0x01;\\n    if (_swapInterval == 5 minutes) return 0x02;\\n    if (_swapInterval == 15 minutes) return 0x04;\\n    if (_swapInterval == 30 minutes) return 0x08;\\n    if (_swapInterval == 1 hours) return 0x10;\\n    if (_swapInterval == 4 hours) return 0x20;\\n    if (_swapInterval == 1 days) return 0x40;\\n    if (_swapInterval == 1 weeks) return 0x80;\\n    revert InvalidInterval();\\n  }\\n\\n  /// @notice Takes a byte representation of a swap interval and returns the swap interval\\n  /// @dev Will revert with InvalidMask if the byte representation is not valid\\n  /// @param _mask The byte representation\\n  /// @return The swap interval\\n  function maskToInterval(bytes1 _mask) internal pure returns (uint32) {\\n    if (_mask == 0x01) return 1 minutes;\\n    if (_mask == 0x02) return 5 minutes;\\n    if (_mask == 0x04) return 15 minutes;\\n    if (_mask == 0x08) return 30 minutes;\\n    if (_mask == 0x10) return 1 hours;\\n    if (_mask == 0x20) return 4 hours;\\n    if (_mask == 0x40) return 1 days;\\n    if (_mask == 0x80) return 1 weeks;\\n    revert InvalidMask();\\n  }\\n\\n  /// @notice Takes a byte representation of a set of swap intervals and returns which ones are in the set\\n  /// @dev Will always return an array of length 8, with zeros at the end if there are less than 8 intervals\\n  /// @param _byte The byte representation\\n  /// @return _intervals The swap intervals in the set\\n  function intervalsInByte(bytes1 _byte) internal pure returns (uint32[] memory _intervals) {\\n    _intervals = new uint32[](8);\\n    uint8 _index;\\n    bytes1 _mask = 0x01;\\n    while (_byte >= _mask && _mask > 0) {\\n      if (_byte & _mask != 0) {\\n        _intervals[_index++] = maskToInterval(_mask);\\n      }\\n      _mask <<= 1;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/call-simulation/contracts/SimulationAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { IERC165 } from \\\"./interfaces/external/IERC165.sol\\\";\\nimport { ISimulationAdapter } from \\\"./interfaces/ISimulationAdapter.sol\\\";\\n\\n/**\\n * @title Simulation Adapter\\n * @author Sam Bugs\\n * @notice This contracts adds off-chain simulation capabilities to existing contracts. It works similarly to a\\n *         multicall, but the state is not modified in each subcall.\\n */\\nabstract contract SimulationAdapter is IERC165, ISimulationAdapter {\\n  /// @notice An error that contains a simulation's result\\n  error SimulatedCall(SimulationResult result);\\n\\n  /// @inheritdoc IERC165\\n  function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\n    return _interfaceId == type(ISimulationAdapter).interfaceId || _interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @inheritdoc ISimulationAdapter\\n  function simulate(bytes[] calldata _calls) external payable returns (SimulationResult[] memory _results) {\\n    _results = new SimulationResult[](_calls.length);\\n    for (uint256 i = 0; i < _calls.length; i++) {\\n      _results[i] = _simulate(_calls[i]);\\n    }\\n    return _results;\\n  }\\n\\n  /**\\n   * @notice Executes a simulation and returns the result\\n   * @param _call The call to simulate\\n   * @return _simulationResult The simulation's result\\n   */\\n  function _simulate(bytes calldata _call) internal returns (SimulationResult memory _simulationResult) {\\n    (bool _success, bytes memory _result) =\\n    // solhint-disable-next-line avoid-low-level-calls\\n     address(this).delegatecall(abi.encodeWithSelector(this.simulateAndRevert.selector, _call));\\n    require(!_success, \\\"WTF? Should have failed!\\\");\\n    // Move pointer to ignore selector\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      _result := add(_result, 0x04)\\n    }\\n    (_simulationResult) = abi.decode(_result, (SimulationResult));\\n  }\\n\\n  /**\\n   * @notice Executes a call agains this contract and reverts with the result\\n   * @dev This is meant to be used internally, do not call!\\n   * @param _call The call to simulate\\n   */\\n  function simulateAndRevert(bytes calldata _call) external payable {\\n    uint256 _gasAtStart = gasleft();\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool _success, bytes memory _result) = address(this).delegatecall(_call);\\n    uint256 _gasSpent = _gasAtStart - gasleft();\\n    revert SimulatedCall(SimulationResult({ success: _success, result: _result, gasSpent: _gasSpent }));\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/swappers/solidity/contracts/extensions/RevokableWithGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '../utils/Governable.sol';\\nimport '../SwapAdapter.sol';\\n\\nabstract contract RevokableWithGovernor is SwapAdapter, Governable {\\n  /**\\n   * @notice Revokes ERC20 allowances for the given spenders\\n   * @dev Can only be called by the governor\\n   * @param _revokeActions The spenders and tokens to revoke\\n   */\\n  function revokeAllowances(RevokeAction[] calldata _revokeActions) external onlyGovernor {\\n    _revokeAllowances(_revokeActions);\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/swappers/solidity/contracts/extensions/PayableMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\n/**\\n * @dev Adding this contract will enable batching calls. This is basically the same as Open Zeppelin's\\n *      Multicall contract, but we have made it payable. It supports both payable and non payable\\n *      functions. However, if `msg.value` is not zero, then non payable functions cannot be called.\\n *      Any contract that uses this Multicall version should be very careful when using msg.value.\\n *      For more context, read: https://github.com/Uniswap/v3-periphery/issues/52\\n */\\nabstract contract PayableMulticall {\\n  /**\\n   * @notice Receives and executes a batch of function calls on this contract.\\n   * @param _data A list of different function calls to execute\\n   * @return _results The result of executing each of those calls\\n   */\\n  function multicall(bytes[] calldata _data) external payable returns (bytes[] memory _results) {\\n    _results = new bytes[](_data.length);\\n    for (uint256 i = 0; i < _data.length; ) {\\n      _results[i] = Address.functionDelegateCall(address(this), _data[i]);\\n      unchecked {\\n        i++;\\n      }\\n    }\\n    return _results;\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/libraries/Permit2Transfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport {IPermit2} from '../interfaces/external/IPermit2.sol';\\n\\n/**\\n * @title Permit2 Transfers Library\\n * @author Sam Bugs\\n * @notice A small library to call Permit2's transfer from methods\\n */\\nlibrary Permit2Transfers {\\n  /**\\n   * @notice Executes a transfer from using Permit2\\n   * @param _permit2 The Permit2 contract\\n   * @param _token The token to transfer\\n   * @param _amount The amount to transfer\\n   * @param _nonce The owner's nonce\\n   * @param _deadline The signature's expiration deadline\\n   * @param _signature The signature that allows the transfer\\n   * @param _recipient The address that will receive the funds\\n   */\\n  function takeFromCaller(\\n    IPermit2 _permit2,\\n    address _token,\\n    uint256 _amount,\\n    uint256 _nonce,\\n    uint256 _deadline,\\n    bytes calldata _signature,\\n    address _recipient\\n  ) internal {\\n    _permit2.permitTransferFrom(\\n      // The permit message.\\n      IPermit2.PermitTransferFrom({permitted: IPermit2.TokenPermissions({token: _token, amount: _amount}), nonce: _nonce, deadline: _deadline}),\\n      // The transfer recipient and amount.\\n      IPermit2.SignatureTransferDetails({to: _recipient, requestedAmount: _amount}),\\n      // The owner of the tokens, which must also be\\n      // the signer of the message, otherwise this call\\n      // will fail.\\n      msg.sender,\\n      // The packed signature that was the result of signing\\n      // the EIP712 hash of `permit`.\\n      _signature\\n    );\\n  }\\n\\n  /**\\n   * @notice Executes a batch transfer from using Permit2\\n   * @param _permit2 The Permit2 contract\\n   * @param _tokens The amount of tokens to transfer\\n   * @param _nonce The owner's nonce\\n   * @param _deadline The signature's expiration deadline\\n   * @param _signature The signature that allows the transfer\\n   * @param _recipient The address that will receive the funds\\n   */\\n  function batchTakeFromCaller(\\n    IPermit2 _permit2,\\n    IPermit2.TokenPermissions[] calldata _tokens,\\n    uint256 _nonce,\\n    uint256 _deadline,\\n    bytes calldata _signature,\\n    address _recipient\\n  ) internal {\\n    if (_tokens.length > 0) {\\n      _permit2.permitTransferFrom(\\n        // The permit message.\\n        IPermit2.PermitBatchTransferFrom({permitted: _tokens, nonce: _nonce, deadline: _deadline}),\\n        // The transfer recipients and amounts.\\n        _buildTransferDetails(_tokens, _recipient),\\n        // The owner of the tokens, which must also be\\n        // the signer of the message, otherwise this call\\n        // will fail.\\n        msg.sender,\\n        // The packed signature that was the result of signing\\n        // the EIP712 hash of `permit`.\\n        _signature\\n      );\\n    }\\n  }\\n\\n  function _buildTransferDetails(IPermit2.TokenPermissions[] calldata _tokens, address _recipient)\\n    private\\n    pure\\n    returns (IPermit2.SignatureTransferDetails[] memory _details)\\n  {\\n    _details = new IPermit2.SignatureTransferDetails[](_tokens.length);\\n    for (uint256 i; i < _details.length; ) {\\n      _details[i] = IPermit2.SignatureTransferDetails({to: _recipient, requestedAmount: _tokens[i].amount});\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/dca-v2-periphery/contracts/interfaces/external/IPermit2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n// Minimal Permit2 interface, derived from\\n// https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol\\ninterface IPermit2 {\\n  struct TokenPermissions {\\n    address token;\\n    uint256 amount;\\n  }\\n\\n  struct PermitTransferFrom {\\n    TokenPermissions permitted;\\n    uint256 nonce;\\n    uint256 deadline;\\n  }\\n\\n  struct PermitBatchTransferFrom {\\n    TokenPermissions[] permitted;\\n    uint256 nonce;\\n    uint256 deadline;\\n  }\\n\\n  struct SignatureTransferDetails {\\n    address to;\\n    uint256 requestedAmount;\\n  }\\n\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function permitTransferFrom(\\n    PermitTransferFrom calldata permit,\\n    SignatureTransferDetails calldata transferDetails,\\n    address owner,\\n    bytes calldata signature\\n  ) external;\\n\\n  function permitTransferFrom(\\n    PermitBatchTransferFrom memory permit,\\n    SignatureTransferDetails[] calldata transferDetails,\\n    address owner,\\n    bytes calldata signature\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@mean-finance/call-simulation/contracts/interfaces/ISimulationAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface ISimulationAdapter {\\n  /// @notice A simulation's result\\n  struct SimulationResult {\\n    bool success;\\n    bytes result;\\n    uint256 gasSpent;\\n  }\\n\\n  /**\\n   * @notice Executes individual simulations against this contract but doesn't modify the state when doing so\\n   * @dev This function is meant to be used for off-chain simulation and should not be called on-chain\\n   * @param calls The calls to simulate\\n   * @return results Each simulation result\\n   */\\n  function simulate(bytes[] calldata calls) external payable returns (SimulationResult[] memory results);\\n}\\n\"\r\n    },\r\n    \"@mean-finance/call-simulation/contracts/interfaces/external/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@mean-finance/swappers/solidity/contracts/utils/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '../../interfaces/utils/IGovernable.sol';\\n\\n/**\\n * @notice This contract is meant to be used in other contracts. By using this contract,\\n *         a specific address will be given a \\\"governor\\\" role, which basically will be able to\\n *         control certains aspects of the contract. There are other contracts that do the same,\\n *         but this contract forces a new governor to accept the role before it's transferred.\\n *         This is a basically a safety measure to prevent losing access to the contract.\\n */\\nabstract contract Governable is IGovernable {\\n  /// @inheritdoc IGovernable\\n  address public governor;\\n\\n  /// @inheritdoc IGovernable\\n  address public pendingGovernor;\\n\\n  constructor(address _governor) {\\n    if (_governor == address(0)) revert GovernorIsZeroAddress();\\n    governor = _governor;\\n  }\\n\\n  /// @inheritdoc IGovernable\\n  function isGovernor(address _account) public view returns (bool) {\\n    return _account == governor;\\n  }\\n\\n  /// @inheritdoc IGovernable\\n  function isPendingGovernor(address _account) public view returns (bool) {\\n    return _account == pendingGovernor;\\n  }\\n\\n  /// @inheritdoc IGovernable\\n  function setPendingGovernor(address _pendingGovernor) external onlyGovernor {\\n    pendingGovernor = _pendingGovernor;\\n    emit PendingGovernorSet(_pendingGovernor);\\n  }\\n\\n  /// @inheritdoc IGovernable\\n  function acceptPendingGovernor() external onlyPendingGovernor {\\n    governor = pendingGovernor;\\n    pendingGovernor = address(0);\\n    emit PendingGovernorAccepted();\\n  }\\n\\n  modifier onlyGovernor() {\\n    if (!isGovernor(msg.sender)) revert OnlyGovernor();\\n    _;\\n  }\\n\\n  modifier onlyPendingGovernor() {\\n    if (!isPendingGovernor(msg.sender)) revert OnlyPendingGovernor();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/swappers/solidity/contracts/SwapAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '../interfaces/ISwapAdapter.sol';\\n\\nabstract contract SwapAdapter is ISwapAdapter {\\n  using SafeERC20 for IERC20;\\n  using Address for address;\\n  using Address for address payable;\\n\\n  /// @inheritdoc ISwapAdapter\\n  address public constant PROTOCOL_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  /// @inheritdoc ISwapAdapter\\n  ISwapperRegistry public immutable SWAPPER_REGISTRY;\\n\\n  constructor(address _swapperRegistry) {\\n    if (_swapperRegistry == address(0)) revert ZeroAddress();\\n    SWAPPER_REGISTRY = ISwapperRegistry(_swapperRegistry);\\n  }\\n\\n  receive() external payable {}\\n\\n  /**\\n   * @notice Takes the given amount of tokens from the caller\\n   * @param _token The token to check\\n   * @param _amount The amount to take\\n   */\\n  function _takeFromMsgSender(IERC20 _token, uint256 _amount) internal virtual {\\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\\n  }\\n\\n  /**\\n   * @notice Checks if the given spender has enough allowance, and approves the max amount\\n   *         if it doesn't\\n   * @param _token The token to check\\n   * @param _spender The spender to check\\n   * @param _minAllowance The min allowance. If the spender has over this amount, then no extra approve is needed\\n   */\\n  function _maxApproveSpenderIfNeeded(\\n    IERC20 _token,\\n    address _spender,\\n    bool _alreadyValidatedSpender,\\n    uint256 _minAllowance\\n  ) internal virtual {\\n    if (_spender != address(0)) {\\n      uint256 _allowance = _token.allowance(address(this), _spender);\\n      if (_allowance < _minAllowance) {\\n        if (!_alreadyValidatedSpender && !SWAPPER_REGISTRY.isValidAllowanceTarget(_spender)) {\\n          revert InvalidAllowanceTarget(_spender);\\n        }\\n        if (_allowance > 0) {\\n          _token.approve(_spender, 0); // We do this because some tokens (like USDT) fail if we don't\\n        }\\n        _token.approve(_spender, type(uint256).max);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Executes a swap for the given swapper\\n   * @param _swapper The actual swapper\\n   * @param _swapData The swap execution data\\n   */\\n  function _executeSwap(\\n    address _swapper,\\n    bytes calldata _swapData,\\n    uint256 _value\\n  ) internal virtual {\\n    _swapper.functionCallWithValue(_swapData, _value);\\n  }\\n\\n  /**\\n   * @notice Checks if the contract has any balance of the given token, and if it does,\\n   *         it sends it to the given recipient\\n   * @param _token The token to check\\n   * @param _recipient The recipient of the token balance\\n   */\\n  function _sendBalanceOnContractToRecipient(address _token, address _recipient) internal virtual {\\n    uint256 _balance = _token == PROTOCOL_TOKEN ? address(this).balance : IERC20(_token).balanceOf(address(this));\\n    if (_balance > 0) {\\n      _sendToRecipient(_token, _balance, _recipient);\\n    }\\n  }\\n\\n  /**\\n   * @notice Transfers the given amount of tokens from the contract to the recipient\\n   * @param _token The token to check\\n   * @param _amount The amount to send\\n   * @param _recipient The recipient\\n   */\\n  function _sendToRecipient(\\n    address _token,\\n    uint256 _amount,\\n    address _recipient\\n  ) internal virtual {\\n    if (_recipient == address(0)) _recipient = msg.sender;\\n    if (_token == PROTOCOL_TOKEN) {\\n      payable(_recipient).sendValue(_amount);\\n    } else {\\n      IERC20(_token).safeTransfer(_recipient, _amount);\\n    }\\n  }\\n\\n  /**\\n   * @notice Checks if given swapper is allowlisted, and fails if it isn't\\n   * @param _swapper The swapper to check\\n   */\\n  function _assertSwapperIsAllowlisted(address _swapper) internal view {\\n    if (!SWAPPER_REGISTRY.isSwapperAllowlisted(_swapper)) revert SwapperNotAllowlisted(_swapper);\\n  }\\n\\n  /**\\n   * @notice Revokes ERC20 allowances for the given spenders\\n   * @dev If exposed, then it should be permissioned\\n   * @param _revokeActions The spenders and tokens to revoke\\n   */\\n  function _revokeAllowances(RevokeAction[] calldata _revokeActions) internal virtual {\\n    for (uint256 i = 0; i < _revokeActions.length; ) {\\n      RevokeAction memory _action = _revokeActions[i];\\n      for (uint256 j = 0; j < _action.tokens.length; ) {\\n        _action.tokens[j].approve(_action.spender, 0);\\n        unchecked {\\n          j++;\\n        }\\n      }\\n      unchecked {\\n        i++;\\n      }\\n    }\\n  }\\n\\n  modifier onlyAllowlisted(address _swapper) {\\n    _assertSwapperIsAllowlisted(_swapper);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/swappers/solidity/interfaces/utils/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\n/**\\n * @title A contract that manages a \\\"governor\\\" role\\n */\\ninterface IGovernable {\\n  /// @notice Thrown when trying to set the zero address as governor\\n  error GovernorIsZeroAddress();\\n\\n  /// @notice Thrown when trying to execute an action that only the governor an execute\\n  error OnlyGovernor();\\n\\n  /// @notice Thrown when trying to execute an action that only the pending governor an execute\\n  error OnlyPendingGovernor();\\n\\n  /**\\n   * @notice Emitted when a new pending governor is set\\n   * @param newPendingGovernor The new pending governor\\n   */\\n  event PendingGovernorSet(address newPendingGovernor);\\n\\n  /**\\n   * @notice Emitted when the pending governor accepts the role and becomes the governor\\n   */\\n  event PendingGovernorAccepted();\\n\\n  /**\\n   * @notice Returns the address of the governor\\n   * @return The address of the governor\\n   */\\n  function governor() external view returns (address);\\n\\n  /**\\n   * @notice Returns the address of the pending governor\\n   * @return The address of the pending governor\\n   */\\n  function pendingGovernor() external view returns (address);\\n\\n  /**\\n   * @notice Returns whether the given account is the current governor\\n   * @param account The account to check\\n   * @return Whether it is the current governor or not\\n   */\\n  function isGovernor(address account) external view returns (bool);\\n\\n  /**\\n   * @notice Returns whether the given account is the pending governor\\n   * @param account The account to check\\n   * @return Whether it is the pending governor or not\\n   */\\n  function isPendingGovernor(address account) external view returns (bool);\\n\\n  /**\\n   * @notice Sets a new pending governor\\n   * @dev Only the current governor can execute this action\\n   * @param pendingGovernor The new pending governor\\n   */\\n  function setPendingGovernor(address pendingGovernor) external;\\n\\n  /**\\n   * @notice Sets the pending governor as the governor\\n   * @dev Only the pending governor can execute this action\\n   */\\n  function acceptPendingGovernor() external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/swappers/solidity/interfaces/ISwapAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\\nimport './ISwapperRegistry.sol';\\n\\n/**\\n * @notice This abstract contract will give contracts that implement it swapping capabilities. It will\\n *         take a swapper and a swap's data, and if the swapper is valid, it will execute the swap\\n */\\ninterface ISwapAdapter {\\n  /// @notice Describes how the allowance should be revoked for the given spender\\n  struct RevokeAction {\\n    address spender;\\n    IERC20[] tokens;\\n  }\\n\\n  /// @notice Thrown when one of the parameters is a zero address\\n  error ZeroAddress();\\n\\n  /**\\n   * @notice Thrown when trying to execute a swap with a swapper that is not allowlisted\\n   * @param swapper The swapper that was not allowlisted\\n   */\\n  error SwapperNotAllowlisted(address swapper);\\n\\n  /// @notice Thrown when the allowance target is not allowed by the swapper registry\\n  error InvalidAllowanceTarget(address spender);\\n\\n  /**\\n   * @notice Returns the address of the swapper registry\\n   * @dev Cannot be modified\\n   * @return The address of the swapper registry\\n   */\\n  function SWAPPER_REGISTRY() external view returns (ISwapperRegistry);\\n\\n  /**\\n   * @notice Returns the address of the protocol token\\n   * @dev Cannot be modified\\n   * @return The address of the protocol token;\\n   */\\n  function PROTOCOL_TOKEN() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@mean-finance/swappers/solidity/interfaces/ISwapperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\n/**\\n * @notice This contract will act as a registry to allowlist swappers. Different contracts from the Mean\\n *         ecosystem will ask this contract if an address is a valid swapper or not\\n *         In some cases, swappers have supplementary allowance targets that need ERC20 approvals. We\\n *         will also track those here\\n */\\ninterface ISwapperRegistry {\\n  /// @notice Thrown when one of the parameters is a zero address\\n  error ZeroAddress();\\n\\n  /// @notice Thrown when trying to remove an account from the swappers list, when it wasn't there before\\n  error AccountIsNotSwapper(address account);\\n\\n  /**\\n   * @notice Thrown when trying to remove an account from the supplementary allowance target list,\\n   *         when it wasn't there before\\n   */\\n  error AccountIsNotSupplementaryAllowanceTarget(address account);\\n\\n  /// @notice Thrown when trying to mark an account as swapper or allowance target, but it already has a role assigned\\n  error AccountAlreadyHasRole(address account);\\n\\n  /**\\n   * @notice Emitted when swappers are removed from the allowlist\\n   * @param swappers The swappers that were removed\\n   */\\n  event RemoveSwappersFromAllowlist(address[] swappers);\\n\\n  /**\\n   * @notice Emitted when new swappers are added to the allowlist\\n   * @param swappers The swappers that were added\\n   */\\n  event AllowedSwappers(address[] swappers);\\n\\n  /**\\n   * @notice Emitted when new supplementary allowance targets are are added to the allowlist\\n   * @param allowanceTargets The allowance targets that were added\\n   */\\n  event AllowedSupplementaryAllowanceTargets(address[] allowanceTargets);\\n\\n  /**\\n   * @notice Emitted when supplementary allowance targets are removed from the allowlist\\n   * @param allowanceTargets The allowance targets that were removed\\n   */\\n  event RemovedAllowanceTargetsFromAllowlist(address[] allowanceTargets);\\n\\n  /**\\n   * @notice Returns whether a given account is allowlisted for swaps\\n   * @param account The address to check\\n   * @return Whether it is allowlisted for swaps\\n   */\\n  function isSwapperAllowlisted(address account) external view returns (bool);\\n\\n  /**\\n   * @notice Returns whether a given account is a valid allowance target. This would be true\\n   *         if the account is either a swapper, or a supplementary allowance target\\n   * @param account The address to check\\n   * @return Whether it is a valid allowance target\\n   */\\n  function isValidAllowanceTarget(address account) external view returns (bool);\\n\\n  /**\\n   * @notice Adds a list of swappers to the allowlist\\n   * @dev Can only be called by users with the admin role\\n   * @param swappers The list of swappers to add\\n   */\\n  function allowSwappers(address[] calldata swappers) external;\\n\\n  /**\\n   * @notice Removes the given swappers from the allowlist\\n   * @dev Can only be called by users with the admin role\\n   * @param swappers The list of swappers to remove\\n   */\\n  function removeSwappersFromAllowlist(address[] calldata swappers) external;\\n\\n  /**\\n   * @notice Adds a list of supplementary allowance targets to the allowlist\\n   * @dev Can only be called by users with the admin role\\n   * @param allowanceTargets The list of allowance targets to add\\n   */\\n  function allowSupplementaryAllowanceTargets(address[] calldata allowanceTargets) external;\\n\\n  /**\\n   * @notice Removes the given allowance targets from the allowlist\\n   * @dev Can only be called by users with the admin role\\n   * @param allowanceTargets The list of allowance targets to remove\\n   */\\n  function removeSupplementaryAllowanceTargetsFromAllowlist(address[] calldata allowanceTargets) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"contract IPermit2\",\"name\":\"_permit2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"GovernorIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"InvalidAllowanceTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMask\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGovernor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingGovernor\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"ReceivedTooLittleTokenOut\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasSpent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISimulationAdapter.SimulationResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"name\":\"SimulatedCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"SwapperNotAllowlisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PendingGovernorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingGovernor\",\"type\":\"address\"}],\"name\":\"PendingGovernorSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"contract IPermit2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROTOCOL_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAPPER_REGISTRY\",\"outputs\":[{\"internalType\":\"contract ISwapperRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptPendingGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowanceTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IPermit2.TokenPermissions[]\",\"name\":\"_tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"batchPermitTakeFromCaller\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_amountOfSwaps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_swapInterval\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"enum IDCAPermissionManager.Permission[]\",\"name\":\"permissions\",\"type\":\"uint8[]\"}],\"internalType\":\"struct IDCAPermissionManager.PermissionSet[]\",\"name\":\"_permissions\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"_miscellaneous\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_amountOfSwaps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_swapInterval\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"enum IDCAPermissionManager.Permission[]\",\"name\":\"permissions\",\"type\":\"uint8[]\"}],\"internalType\":\"struct IDCAPermissionManager.PermissionSet[]\",\"name\":\"_permissions\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"_miscellaneous\",\"type\":\"bytes\"}],\"name\":\"depositWithBalanceOnContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"internalType\":\"struct Pair[]\",\"name\":\"_pairs\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"_calculatePrivilegedAvailability\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_oracleData\",\"type\":\"bytes\"}],\"name\":\"getNextSwapInfo\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toProvide\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"platformFee\",\"type\":\"uint256\"}],\"internalType\":\"struct IDCAHubSwapHandler.TokenInSwap[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountToSwapTokenA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountToSwapTokenB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratioAToB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratioBToA\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"intervalsInSwap\",\"type\":\"bytes1\"}],\"internalType\":\"struct IDCAHubSwapHandler.PairInSwap[]\",\"name\":\"pairs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IDCAHubSwapHandler.SwapInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newSwaps\",\"type\":\"uint32\"}],\"name\":\"increasePosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newSwaps\",\"type\":\"uint32\"}],\"name\":\"increasePositionWithBalanceOnContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isPendingGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILegacyDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"internalType\":\"struct Pair[]\",\"name\":\"_pairs\",\"type\":\"tuple[]\"}],\"name\":\"legacyGetNextSwapInfo\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toProvide\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"platformFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ILegacyDCAHub.TokenInSwap[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratioAToB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratioBToA\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"intervalsInSwap\",\"type\":\"bytes1\"}],\"internalType\":\"struct ILegacyDCAHub.PairInSwap[]\",\"name\":\"pairs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ILegacyDCAHub.SwapInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAPermissionManager\",\"name\":\"_permissionManager\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"enum IDCAPermissionManager.Permission[]\",\"name\":\"permissions\",\"type\":\"uint8[]\"}],\"internalType\":\"struct IDCAPermissionManager.PermissionSet[]\",\"name\":\"permissionSets\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IDCAPermissionManager.PositionPermissions[]\",\"name\":\"_permissions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"multiPermissionPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAPermissionManager\",\"name\":\"_permissionManager\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"enum IDCAPermissionManager.Permission[]\",\"name\":\"permissions\",\"type\":\"uint8[]\"}],\"internalType\":\"struct IDCAPermissionManager.PermissionSet[]\",\"name\":\"_permissions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"permissionPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"permitTakeFromCaller\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newSwaps\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"reducePosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"internalType\":\"struct ISwapAdapter.RevokeAction[]\",\"name\":\"_revokeActions\",\"type\":\"tuple[]\"}],\"name\":\"revokeAllowances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allowanceToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_swapData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minTokenOut\",\"type\":\"uint256\"}],\"name\":\"runSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"internalType\":\"struct Pair[]\",\"name\":\"_pairs\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"_calculatePrivilegedAvailability\",\"type\":\"bool\"}],\"name\":\"secondsUntilNextSwap\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"sendBalanceOnContractToRecipient\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"sendToRecipient\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pendingGovernor\",\"type\":\"address\"}],\"name\":\"setPendingGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSwapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAllowanceTarget\",\"type\":\"address\"}],\"name\":\"setSwapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_calls\",\"type\":\"bytes[]\"}],\"name\":\"simulate\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasSpent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISimulationAdapter.SimulationResult[]\",\"name\":\"_results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_call\",\"type\":\"bytes\"}],\"name\":\"simulateAndRevert\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"takeFromCaller\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipientUnswapped\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipientSwapped\",\"type\":\"address\"}],\"name\":\"terminate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_unswapped\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapped\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawSwapped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapped\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"_hub\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"positionIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IDCAHubPositionHandler.PositionSet[]\",\"name\":\"_positions\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawSwappedMany\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_withdrawn\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DCAHubCompanion", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "000000000000000000000000227f070ed2afd8744ef059959b8a8b8e8edc6c0f000000000000000000000000227f070ed2afd8744ef059959b8a8b8e8edc6c0f00000000000000000000000010a5d3b1c0f3639cfb0e554f29c3effd912d0c64000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}