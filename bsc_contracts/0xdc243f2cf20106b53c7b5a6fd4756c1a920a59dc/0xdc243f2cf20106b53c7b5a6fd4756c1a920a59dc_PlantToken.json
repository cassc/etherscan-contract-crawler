{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// https://github.com/binance-chain/bsc-genesis-contract/blob/master/contracts/bep20_template/BEP20Token.template\\r\\n// https://docs.binance.org/smart-chain/developer/BEP20.html\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\n\\r\\ninterface IBEP20 {\\r\\n\\r\\n    // Functions\\r\\n    \\r\\n    function totalSupply() external view returns (uint256);     // Returns the amount of tokens in existence.\\r\\n\\r\\n    function decimals() external view returns (uint8);  // Returns the token decimals.\\r\\n\\r\\n    function symbol() external view returns (string memory); // Returns the token symbol.\\r\\n\\r\\n    function name() external view returns (string memory); // Returns the token name.\\r\\n\\r\\n    function getOwner() external view returns (address); // Returns the bep token owner.\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);   // Returns the amount of tokens owned by `account`\\r\\n    \\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);  // transfer tokens to addr, Emits a {Transfer} event.\\r\\n\\r\\n    function allowance(address _owner, address spender) external view returns (uint256); // Returns remaining tokens that spender is allowed during {approve} or {transferFrom} \\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool); // sets amount of allowance, emits approval event\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); // move amount, then reduce allowance, emits a transfer event\\r\\n\\r\\n\\r\\n    // Events\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);    // emitted when value tokens moved, value can be zero\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);  // emits when allowance of spender for owner is set by a call to approve. value is new allowance\\r\\n\\r\\n}\"},\"IPancakeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// https://github.com/pancakeswap/pancake-swap-core/blob/master/contracts/interfaces/IPancakeFactory.sol\\r\\n// https://github.com/pancakeswap/pancake-swap-core\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\ninterface IPancakeFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);      // creates pair of BNB and token\\r\\n\\r\\n    function feeTo() external view returns (address);       // gives a fee to the LP provider?\\r\\n    function feeToSetter() external view returns (address);     // gives a fee to the LP setter?\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);  // gets the address of the LP token pair\\r\\n    function allPairs(uint) external view returns (address pair);       // gets address of all the pairs? not sure\\r\\n    function allPairsLength() external view returns (uint);     // gets the length?\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);    // creates the pair\\r\\n\\r\\n    function setFeeTo(address) external;        // sets a fee to an address\\r\\n    function setFeeToSetter(address) external;  // sets fee to the setter address\\r\\n\\r\\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\\r\\n}\"},\"IPancakeRouter01.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// https://github.com/pancakeswap/pancake-swap-periphery/blob/master/contracts/interfaces/IPancakeRouter01.sol\\r\\n// https://github.com/pancakeswap/pancake-swap-periphery\\r\\n\\r\\n\\r\\n// TODO - might want to change the ETH name to BNB, but that might not work because it\\u0027s that way in pancake swap I think\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ninterface IPancakeRouter01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) \\r\\n        external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) \\r\\n        external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) \\r\\n        external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) \\r\\n        external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit( address tokenA, address tokenB,uint liquidity,uint amountAMin,uint amountBMin,address to,uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) \\r\\n        external returns (uint amountA, uint amountB);\\r\\n        \\r\\n    function removeLiquidityETHWithPermit(address token, uint liquidity,uint amountTokenMin,uint amountETHMin,address to,uint deadline,bool approveMax, uint8 v, bytes32 r, bytes32 s) \\r\\n        external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(uint amountOut,uint amountInMax,address[] calldata path,address to,uint deadline) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\r\\n}\"},\"IPancakeRouter02.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// https://github.com/pancakeswap/pancake-swap-periphery/blob/master/contracts/interfaces/IPancakeRouter02.sol\\r\\n// https://github.com/pancakeswap/pancake-swap-periphery\\r\\n\\r\\n// TODO - might want to change the ETH name to BNB, but that might not work because it\\u0027s that way in pancake swap I think\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport \\u0027./IPancakeRouter01.sol\\u0027;\\r\\n\\r\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\r\\n\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"},\"LinkTokenInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ninterface LinkTokenInterface {\\r\\n\\r\\n  function allowance(\\r\\n    address owner,\\r\\n    address spender\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256 remaining\\r\\n    );\\r\\n\\r\\n  function approve(\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  )\\r\\n    external\\r\\n    returns (\\r\\n      bool success\\r\\n    );\\r\\n\\r\\n  function balanceOf(\\r\\n    address owner\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256 balance\\r\\n    );\\r\\n\\r\\n  function decimals()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint8 decimalPlaces\\r\\n    );\\r\\n\\r\\n  function decreaseApproval(\\r\\n    address spender,\\r\\n    uint256 addedValue\\r\\n  )\\r\\n    external\\r\\n    returns (\\r\\n      bool success\\r\\n    );\\r\\n\\r\\n  function increaseApproval(\\r\\n    address spender,\\r\\n    uint256 subtractedValue\\r\\n  ) external;\\r\\n\\r\\n  function name()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      string memory tokenName\\r\\n    );\\r\\n\\r\\n  function symbol()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      string memory tokenSymbol\\r\\n    );\\r\\n\\r\\n  function totalSupply()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256 totalTokensIssued\\r\\n    );\\r\\n\\r\\n  function transfer(\\r\\n    address to,\\r\\n    uint256 value\\r\\n  )\\r\\n    external\\r\\n    returns (\\r\\n      bool success\\r\\n    );\\r\\n\\r\\n  function transferAndCall(\\r\\n    address to,\\r\\n    uint256 value,\\r\\n    bytes calldata data\\r\\n  )\\r\\n    external\\r\\n    returns (\\r\\n      bool success\\r\\n    );\\r\\n\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  )\\r\\n    external\\r\\n    returns (\\r\\n      bool success\\r\\n    );\\r\\n\\r\\n}\"},\"Plant.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n/*\\r\\n$PLANT Token! Our mission is to help renew the envyronment through crypto. We are a charity focused deflationary token that gives back to the environment, and its holders.\\r\\n\\r\\nWebsite- https://www.PlantToken.co/\\r\\nTelegram - https://t.me/PlantTokenCrypto\\r\\nTwitter - https://twitter.com/PlantToken\\r\\n\\r\\n\\r\\n                                                                                                    \\r\\n                                      `..--::://///////::--..`                                      \\r\\n                                `.-:/++++++++++++++++++++++++++/:-.`                                \\r\\n                            .-:/++++++++++++++++++++++++++++++++++++/:-.`                           \\r\\n                        `-:/++++++++++++++++++++++++++++++++++++++++++++/:-`                        \\r\\n                     `-//++++++++++++++++++++++++++++++++++++++++++++++++++//-`                     \\r\\n                   .:/++++++++++++++++++++++++++++++++++++++++++++++++++++++++/:.                   \\r\\n                 ./+++++++..--://++++++++++++++++++++++++++++++++++++++++++++++++/.                 \\r\\n               ./+++++++++.     ``.-::/++++++++++++++++++++++++++++++++++++++++++++/.               \\r\\n             .:+++++++++++:           ``-:/++++++++++++++++++++++++++++++++++++++++++/.             \\r\\n           `:/++++++++++++/               ``-:/++++++++++++++++++++++++++++++++++++++++:`           \\r\\n          ./+++++++++++++++.                  `-/+++++++++++++++++++++++++++++++++++++++/.          \\r\\n         -/++++++++++++++++:        `..`        `-/++++++++++++++++++++++++++++++++++++++/-         \\r\\n        -+++++++++++++++++++`         `-:.        `:+++++++++++++++++++++++++++++++++++++++:        \\r\\n       :++++++++++++++++++++:           `:/.        :+++++++++++++++++++++++++++++++++++++++:       \\r\\n      -++++++++++++++++++++++.            ./:`      `/++++++++++++/////::::::::/+++++++++++++:      \\r\\n     -+++++++++++++++++++++++/             `:/-      :+++++++//:-.``           -++++++++++++++-     \\r\\n    `/++++++++++++++++++++++++-              :+:     :+++++/-`                -++++++++++++++++`    \\r\\n    :++++++++++++++++++++++++++-              :+:`   /++++-       `.-.`      -+++++++++++++++++/    \\r\\n   .++++++++++++++++++++++++++++-              :+/  -++++.     .-:-`        -+++++++++++++++++++.   \\r\\n   /+++++++++++++++++++++++++++++-             `/+:-++++/   `-/:.         `:++++++++++++++++++++/   \\r\\n  `+++++++++++++++++++++++++++++++/.            `+++++++- `-/-`          `/++++++++++++++++++++++`  \\r\\n  -+++++++++++++++++++++++++++++++++/-`     `.-: -++++++:./-           `-++++++++++++++++++++++++-  \\r\\n  :+++++++++++++++++++++++++++++++++++++////++++- /+++++/.`-:`       `-/+++++++++++++++++++++++++:  \\r\\n  :+++++++++++++++++++++++++++++++++++++++++++++/ .+++/- ./+++/:---:/++++++++++++++++++++++++++++/  \\r\\n  /++++++++++++++++++++++++++++++++++++++++++++++` /+:` :++++++++++++++++++++++++++++++++++++++++/  \\r\\n  :++++++++++++++++++++++++++++++//::----::/+++++. .. ./+++++++++++++++++++++++++++++++++++++++++/  \\r\\n  :++++++++++++++++++++++++++/.`            ./+++-  `:+++++++++++++++++++++++++++++++++++++++++++:  \\r\\n  -+++++++++++++++++++++++++++/.    ``.---.`  :++:  :++++++++++++++++++++++++++++++++++++++++++++-  \\r\\n  `+++++++++++++++++++++++++++++:`       `.--.-++/  -++++++++++++++++++++++++++++++++++++++++++++`  \\r\\n   /+++++++++++++++++++++++++++++/:.        `-.://  `+++++++++++++++++++++++++++++++++++++++++++/   \\r\\n   .++++++++++++++++++++++++++++++++/-.````./+/-..   +++++++++++++++++++++++++++++++++++++++++++.   \\r\\n    /++++++++++++++++++++++++++++++++++////+++++/:   /+++++++++++++++++++++++++++++++++++++++++/    \\r\\n    `/++++++++++++++++++++++++++++++++++++++++++++   :+++++++++++++++++++++++++++++++++++++++++.    \\r\\n     -+++++++++++++++++++++++++++++++++++++++++++/   -++++++++++++++++++++++++++++++++++++++++-     \\r\\n      -++++++++++++++++++++++++++++++++++++++++++/   -+++++++++++++++++++++++++++++++++++++++:      \\r\\n       :+++++++++++++++++++++++++++++++++++++++++/.`.:++++++++++++++++++++++++++++++++++++++:       \\r\\n        :+++++++++++++++++++++++++++++++++++++//:://::----::/++++++++++++++++++++++++++++++:        \\r\\n         -/+++++++++++++++++++++++++++++++///-`   ``        `.:/++++++++++++++++++++++++++-         \\r\\n          ./+++++++++++++++++++++++/-...-.`                    `/+++++++++++++++++++++++/.          \\r\\n           `:/+++++++++++++++++++/-`                            `.-/+++++++++++++++++++:`           \\r\\n             ./+++++++++++++++++:`                                 `:++++++++++++++++/.             \\r\\n               ./++++++++++++++-                                     ./++++++++++++/-               \\r\\n                 ./+++++++++++/----------------------------------------++++++++++/-`                \\r\\n                   .:/++++++++++++++++++++++++++++++++++++++++++++++++++++++++/:.                   \\r\\n                     `-//++++++++++++++++++++++++++++++++++++++++++++++++++//-`                     \\r\\n                        `-:/++++++++++++++++++++++++++++++++++++++++++++//-`                        \\r\\n                           `.-//++++++++++++++++++++++++++++++++++++//-.`                           \\r\\n                                `.-:/++++++++++++++++++++++++++/::-.                                \\r\\n                                     ``.--::://////////:::--.``                                     \\r\\n                                                                \\r\\n\\r\\nPlantToken is a new cryptocurrency that rewards holders through a weekly lottery system we are calling Suprise Sprouts! \\r\\n\\r\\nHow does PlantToken reward its holders? If you are holding at least 80,000 PLANTs then you are added to a lottery pool.\\r\\n\\r\\nEach week a winner is chosen via Chainlink VRF.\\r\\n\\r\\nOnce a winner is selected, they are distributed tokens each day, until all their winnings are fully dispensed.\\r\\n\\r\\nThe winner is then removed from the lottery pool and will be unable to win again.\\r\\n\\r\\nThe cycle repeats itself and then crowns a new winner.\\r\\n\\r\\nThe following tokenomics taxes are on each transaction:\\r\\n\u2022    A 3% charity tax is given directly to a charity wallet, and dontated monthly.\\r\\n\u2022    A 2% liquidity tax is taken for direct liquidity boosting.\\r\\n\u2022    A 2% redistribution tax is taken and given to all holders.\\r\\n\u2022    A 2% burn tax deflates the token and increases the coin\u2019s value.\\r\\n\u2022    A 1% lottery tax is taken and given to the lottery wallet, and drawn weekly.\\r\\n\\r\\n\\r\\n*/\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n// Imports\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./IPancakeFactory.sol\\\";\\r\\nimport \\\"./IPancakeRouter01.sol\\\";\\r\\nimport \\\"./IPancakeRouter02.sol\\\";\\r\\nimport \\\"./SafeBEP20.sol\\\";\\r\\n\\r\\nimport \\\"./VRFConsumerBase.sol\\\"; // VRF for randomness\\r\\n\\r\\n\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ncontract PlantToken is Context, IBEP20, VRFConsumerBase  {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using SafeBEP20 for IBEP20;\\r\\n    using Address for address;\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n    address private ownerOfToken;\\r\\n    address private previousOwnerOfToken;\\r\\n\\r\\n    uint256 private totalSupplyOfToken;\\r\\n    uint8 private totalDecimalsOfToken;\\r\\n    string private tokenSymbol;\\r\\n    string private tokenName;\\r\\n\\r\\n    mapping(address =\\u003e bool) private isAccountExcludedFromReward;\\r\\n    address[] private excludedFromRewardAddresses;      // holds the address of the account that is excluded from reward\\r\\n\\r\\n    mapping(address =\\u003e bool) private isAccountExcludedFromFee;\\r\\n\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowanceAmount;\\r\\n\\r\\n    mapping(address =\\u003e uint256) private reflectTokensOwned;\\r\\n    mapping(address =\\u003e uint256) private totalTokensOwned;\\r\\n\\r\\n\\r\\n    // RFI Variables....\\r\\n    uint256 private MAXintNum;\\r\\n    uint256 private _rTotal;\\r\\n    uint256 private totalFeeAmount;\\r\\n\\r\\n\\r\\n    \\r\\n    uint256 public taxFeePercent;\\r\\n    uint256 private previousTaxFeePercent;\\r\\n\\r\\n    uint256 public charityFeePercent;\\r\\n    uint256 private previousCharityFeePercent;\\r\\n\\r\\n    uint256 public burnFeePercent;\\r\\n    uint256 private previousBurnFeePercent;\\r\\n\\r\\n    uint256 public lotteryFeePercent;\\r\\n    uint256 private previousLotteryFeePercent;\\r\\n\\r\\n    uint256 public liquidityFeePercent;\\r\\n    uint256 private previousLiquidityFeePercent;\\r\\n\\r\\n\\r\\n\\r\\n    IPancakeRouter02 public pancakeswapRouter;\\r\\n    address public pancakeswapPair;\\r\\n    address public routerAddressForDEX;\\r\\n\\r\\n    bool private inSwapAndLiquify;\\r\\n    bool public isSwapAndLiquifyEnabled;\\r\\n\\r\\n    // uint256 public maxTransferAmount;   \\r\\n\\r\\n    uint256 public numTokensSellToAddToLiquidity;\\r\\n\\r\\n\\r\\n\\r\\n    // Release Time Stamp\\r\\n    uint256 releaseUnixTimeStampV1;\\r\\n\\r\\n\\r\\n    // Addresses\\r\\n    address public deadAddress;\\r\\n    address public charityAddress;\\r\\n    address public lotteryAddress;\\r\\n    address public teamAddress;\\r\\n    address public plantContractControllerAddress;\\r\\n\\r\\n    address public drawingAddress;\\r\\n\\r\\n\\r\\n    address public deadAddressZero; \\r\\n    address public deadAddressOne; \\r\\n\\r\\n\\r\\n\\r\\n    // Lottery Tracking Vars\\r\\n    mapping(address =\\u003e bool) public isExcludedFromLottery;\\r\\n    \\r\\n    uint256 public maxDrawingChances;\\r\\n    uint256 public initialMaxDrawingChances;\\r\\n    uint256 public amountNeededForDrawingChance;\\r\\n\\r\\n\\r\\n    // Single Entry Lottery\\r\\n    mapping(address =\\u003e bool) public hasEnoughTokensForLotterySingle;\\r\\n    mapping(uint256 =\\u003e address) public lotteryPoolNumberToAddressSingle;      // position to address\\r\\n    mapping(address =\\u003e uint256) public lotteryPoolAddressToNumberSingle;      // starting position of entries \\r\\n    uint256 public lotteryPoolCounterSingle;\\r\\n\\r\\n\\r\\n   \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    uint256 public lotteryTime;\\r\\n    address public currentLotteryWinner;\\r\\n\\r\\n\\r\\n    uint256 public amountToDisperseInDrawingTotal;\\r\\n    uint256 public amountToDisperseInDrawingPerPeriod;\\r\\n    uint256 public amountToDisperseInDrawingLeft;\\r\\n\\r\\n    uint256 public periodsToDisperse;\\r\\n    uint256 public hoursInPeriodToDisperse;\\r\\n    uint256 public dispersalTime;\\r\\n\\r\\n    bool public isLotterySystemEnabled;\\r\\n    bool public isAddSingleEntrySystemEnabled;\\r\\n    bool public isRewardSingleEntrySystemEnabled;\\r\\n    \\r\\n\\r\\n    bool public isRandomnessFulfilled;\\r\\n    bool public isCallLotteryReady;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    uint256 public numberToUseForRandomLoopFindWinner;\\r\\n\\r\\n    \\r\\n\\r\\n    // Chainlink VRF\\r\\n    bytes32 private keyHashForLINK;\\r\\n    uint256 private feeForLINK;\\r\\n    uint256 public randomResultFromLINKVRF;\\r\\n\\r\\n    \\r\\n\\r\\n    // CHANGEIT - For LIVE\\r\\n    address public linkTokenAddress = 0x404460C6A5EdE2D891e8297795264fDe62ADBB75;\\r\\n    address public vrfCoordinatorAddress = 0x747973a5A2a4Ae1D3a8fDF5479f1514F65Db9C31;\\r\\n\\r\\n    // this is for BSC Test NETWORK\\r\\n    // address public linkTokenAddress = 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06;\\r\\n    // address public vrfCoordinatorAddress = 0xa555fC018435bef5A13C6c6870a9d4C11DEC329C;\\r\\n   \\r\\n    // CHANGEIT - For LIVE\\r\\n    //address public linkTokenAddress = 0x404460C6A5EdE2D891e8297795264fDe62ADBB75;\\r\\n    //address public vrfCoordinatorAddress = 0x747973a5A2a4Ae1D3a8fDF5479f1514F65Db9C31;\\r\\n\\r\\n\\r\\n  \\r\\n\\r\\n\\r\\n\\r\\n    // Events\\r\\n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\\r\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\r\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\r\\n    event RandomNumberPickedSingle(uint256 randomNumber);\\r\\n    event LoopBrokenTooManyDrawingsSingle(uint256 randomExpansionCounter);\\r\\n\\r\\n   \\r\\n    event RandomNumberDeterminedSingle(uint randomNum);\\r\\n    \\r\\n\\r\\n    event WinnerPickedS(address winnerAddress);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    constructor () VRFConsumerBase(vrfCoordinatorAddress, linkTokenAddress){\\r\\n\\r\\n        // Fee Addresses\\r\\n        deadAddress = 0x000000000000000000000000000000000000dEaD;\\r\\n        charityAddress = 0xBD426AFC2cFF219Ee66FAD65d522445F5e20ce90;\\r\\n        lotteryAddress = 0xa2375E604C30Db47C5B897B46210c425823C360c;\\r\\n\\r\\n\\r\\n        teamAddress = 0x0687e994037e5d5165824B443CD6b2C3cBe31466;    \\r\\n        drawingAddress = 0x16B9F15D9aC12d26AF380A283cEa9621aAFe0b42;\\r\\n\\r\\n        plantContractControllerAddress = 0xbF9F8FC9e4548cD29f0CaB6217Ae916c8b4b8FF8;\\r\\n\\r\\n\\r\\n        deadAddressZero = 0x0000000000000000000000000000000000000000; \\r\\n        deadAddressOne = 0x0000000000000000000000000000000000000001; \\r\\n\\r\\n\\r\\n        amountToDisperseInDrawingTotal = 0;\\r\\n        amountToDisperseInDrawingPerPeriod = 0;\\r\\n        amountToDisperseInDrawingLeft = 0;\\r\\n\\r\\n\\r\\n        periodsToDisperse = 7; // CHANGEIT - must change to 7 here for days\\r\\n        // periodsToDisperse = 2;\\r\\n\\r\\n        hoursInPeriodToDisperse = 24 hours;  // CHANGEIT - must change to 24 hours here\\r\\n        // hoursInPeriodToDisperse = 1 minutes;\\r\\n        \\r\\n\\r\\n\\r\\n        maxDrawingChances = 25;\\r\\n        initialMaxDrawingChances = maxDrawingChances;\\r\\n        amountNeededForDrawingChance = 80000 * 10**9;\\r\\n        lotteryTime = block.timestamp.add(periodsToDisperse.mul(hoursInPeriodToDisperse));\\r\\n        dispersalTime = 0;\\r\\n        currentLotteryWinner = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n\\r\\n        ownerOfToken = plantContractControllerAddress;\\r\\n        emit OwnershipTransferred(address(0), _msgSender());\\r\\n\\r\\n        totalSupplyOfToken = 161211420 * 10**9;\\r\\n        totalDecimalsOfToken = 9;\\r\\n\\r\\n        MAXintNum = ~uint256(0);\\r\\n        _rTotal = (MAXintNum - (MAXintNum % totalSupplyOfToken));       \\r\\n        \\r\\n        tokenSymbol = \\\"PLANT\\\";  \\r\\n        tokenName = \\\"PlantToken\\\";   \\r\\n        \\r\\n        \\r\\n        // CHANGEIT YOU MUST CHANGE TO ZERO FOR DXSALE\\r\\n        \\r\\n         // charityFeePercent = 3; \\r\\n        charityFeePercent = 0; \\r\\n        previousCharityFeePercent = charityFeePercent;\\r\\n        // taxFeePercent = 2;\\r\\n        taxFeePercent = 0;\\r\\n        previousTaxFeePercent = taxFeePercent;\\r\\n        // burnFeePercent = 2; \\r\\n        burnFeePercent = 0; \\r\\n        previousBurnFeePercent = burnFeePercent;\\r\\n        // liquidityFeePercent = 2;\\r\\n        liquidityFeePercent = 0;\\r\\n        previousLiquidityFeePercent = liquidityFeePercent;\\r\\n        // lotteryFeePercent = 1; \\r\\n        lotteryFeePercent = 0; \\r\\n        previousLotteryFeePercent = lotteryFeePercent;\\r\\n        \\r\\n\\r\\n    \\r\\n        isSwapAndLiquifyEnabled = false;       // CHANGEIT set to false for launch  You must change it to true after dxsale\\r\\n\\r\\n        numTokensSellToAddToLiquidity = 10 * 10**11 * 10**9;  \\r\\n\\r\\n\\r\\n\\r\\n        reflectTokensOwned[owner()] = _rTotal; \\r\\n        emit Transfer(address(0), owner(), totalSupplyOfToken);    // emits event of the transfer of the supply from dead to owner   \\r\\n\\r\\n\\r\\n\\r\\n        // V2 Router - 0x10ED43C718714eb63d5aA57B78B54704E256024E   // CHANGEIT - this is the one you want for live\\r\\n\\r\\n        // 0x10ED43C718714eb63d5aA57B78B54704E256024E = LIVE PancakeSwap ROUTER V2\\r\\n        // 0x73feaa1eE314F8c655E354234017bE2193C9E24E = LIVE PancakeSwap Staking Contract\\r\\n        // 0xA527a61703D82139F8a06Bc30097cC9CAA2df5A6 = LIVE PancakeSwap CAKE\\r\\n        // 0x1B96B92314C44b159149f7E0303511fB2Fc4774f = LIVE PancakeSwap BUSD\\r\\n        // 0xfa249Caa1D16f75fa159F7DFBAc0cC5EaB48CeFf = LIVE PancakeSwap FACTORY (Bunny Factory?) \\r\\n\\r\\n        // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D = TESTNET/LIVE Uniswap Ropsten and Rinkeby ROUTER\\r\\n        // 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f = TESTNET/LIVE Uniswap FACTORY\\r\\n        // uniswap v3 factory 0x1F98431c8aD98523631AE4a59f267346ea31F984\\r\\n\\r\\n        // 0x6725F303b657a9451d8BA641348b6761A6CC7a17 = TESTNET PancakeSwap FACTORY\\r\\n        // 0xD99D1c33F9fC3444f8101754aBC46c52416550D1 = TESTNET PancakeSwap ROUTER\\r\\n\\r\\n\\r\\n        // Address for Testing with https://pancake.kiemtienonline360.com/#/swap\\r\\n        // 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\\r\\n        // You will need to update the pair address if you do this\\r\\n        \\r\\n\\r\\n        routerAddressForDEX = 0x10ED43C718714eb63d5aA57B78B54704E256024E;       // CHANGEIT - change this to real pancakeswap router\\r\\n        // routerAddressForDEX = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;       // For TestNET\\r\\n\\r\\n\\r\\n\\r\\n        IPancakeRouter02 pancakeswapRouterLocal = IPancakeRouter02(routerAddressForDEX);      // gets the router\\r\\n        pancakeswapPair = IPancakeFactory(pancakeswapRouterLocal.factory()).createPair(address(this), pancakeswapRouterLocal.WETH());     // Creates the pancakeswap pair   \\r\\n        pancakeswapRouter = pancakeswapRouterLocal;   // set the rest of the contract variables in the global router variable from the local one\\r\\n\\r\\n\\r\\n        // Exclude from fees\\r\\n        isAccountExcludedFromFee[owner()] = true; \\r\\n        isAccountExcludedFromFee[address(this)] = true; \\r\\n        isAccountExcludedFromFee[drawingAddress] = true;  \\r\\n        isAccountExcludedFromFee[teamAddress] = true;  \\r\\n        isAccountExcludedFromFee[lotteryAddress] = true;  \\r\\n        isAccountExcludedFromFee[charityAddress] = true;  \\r\\n\\r\\n        \\r\\n        \\r\\n\\r\\n\\r\\n        // Excluding basic addresses from lottery\\r\\n        isExcludedFromLottery[owner()] = true;\\r\\n        isExcludedFromLottery[deadAddress] = true;\\r\\n        isExcludedFromLottery[deadAddressZero] = true;\\r\\n        isExcludedFromLottery[deadAddressOne] = true;\\r\\n        isExcludedFromLottery[drawingAddress] = true;\\r\\n        isExcludedFromLottery[teamAddress] = true;\\r\\n        isExcludedFromLottery[lotteryAddress] = true;\\r\\n        isExcludedFromLottery[charityAddress] = true;\\r\\n        isExcludedFromLottery[routerAddressForDEX] = true;\\r\\n        isExcludedFromLottery[pancakeswapPair] = true;\\r\\n        isExcludedFromLottery[address(this)] = true;\\r\\n\\r\\n\\r\\n\\r\\n \\r\\n\\r\\n        \\r\\n        lotteryPoolCounterSingle = 0;\\r\\n        isLotterySystemEnabled = false;  // CHANGEIT set to false for launch  You must change it to true after dxsale\\r\\n\\r\\n        isAddSingleEntrySystemEnabled  = true;\\r\\n        isRewardSingleEntrySystemEnabled  = false;      // CHANGEIT - if something goes wrong in this system, turn this on, and set multi to false\\r\\n\\r\\n        \\r\\n\\r\\n        numberToUseForRandomLoopFindWinner = 25;\\r\\n\\r\\n        isRandomnessFulfilled = false;\\r\\n        isCallLotteryReady = true;  // should always be set to true\\r\\n\\r\\n        // chainlink vrf  \\r\\n        // CHANGEIT - live net here\\r\\n        keyHashForLINK = 0xc251acd21ec4fb7f31bb8868288bfdbaeb4fbfec2df3735ddbd4f7dc8d60103c;\\r\\n        feeForLINK = 0.2 * 10 ** 18; // 0.2 LINK (Varies by network)\\r\\n\\r\\n\\r\\n        // this is for BSC Test Network\\r\\n        // keyHashForLINK = 0xcaf3c3727e033261d383b315559476f48034c13b18f8cafed4d871abe5049186;\\r\\n        // feeForLINK = 0.1 * 10 ** 18; // 0.2 LINK (Varies by network)\\r\\n        \\r\\n        // CHANGEIT - live net here\\r\\n        //keyHashForLINK = 0xc251acd21ec4fb7f31bb8868288bfdbaeb4fbfec2df3735ddbd4f7dc8d60103c;\\r\\n        //feeForLINK = 0.2 * 10 ** 18; // 0.2 LINK (Varies by network)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        releaseUnixTimeStampV1 = block.timestamp;     // gets the block timestamp so we can know when it was deployed\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// ACCESS CONTROL FUNCTIONS //////////////////////////////\\r\\n    function owner() public view returns (address) {\\r\\n        return ownerOfToken;        // Returns the address of the current owner.\\r\\n    }\\r\\n\\r\\n    function getOwner() external view override returns (address){\\r\\n        return owner();     // gets current owner address\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(ownerOfToken == _msgSender(), \\\"Ownable: caller is not the owner\\\");  // Throws if called by any account other than the owner.\\r\\n        _;      // when using a modifier, the code from the function is inserted here. // if multiple modifiers then the previous one inherits the next one\\u0027s modifier code\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner() {     // changes ownership\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");   \\r\\n        emit OwnershipTransferred(ownerOfToken, newOwner);\\r\\n        previousOwnerOfToken = ownerOfToken;\\r\\n        ownerOfToken = newOwner;\\r\\n    }\\r\\n    ////////////////////////////// ACCESS CONTROL FUNCTIONS //////////////////////////////\\r\\n    \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// BASIC INFO FUNCTIONS //////////////////////////////\\r\\n    function decimals() public view override returns (uint8) {\\r\\n        return totalDecimalsOfToken;  \\r\\n    }\\r\\n\\r\\n    function symbol() public view override returns (string memory) {\\r\\n        return tokenSymbol;   \\r\\n    }\\r\\n\\r\\n    function name() public view override returns (string memory) {\\r\\n        return tokenName;   \\r\\n    }\\r\\n\\r\\n    function totalSupply() external view override returns (uint256){\\r\\n        return totalSupplyOfToken;   \\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        if (isAccountExcludedFromReward[account]) {   \\r\\n            return totalTokensOwned[account];\\r\\n        }\\r\\n        return tokenFromReflection(reflectTokensOwned[account]);\\r\\n    }\\r\\n    \\r\\n    function getNowBlockTime() public view returns (uint) {\\r\\n        return block.timestamp;     // gets the current time and date in Unix timestamp\\r\\n    }\\r\\n\\r\\n    function releaseUnixTimeDate() public view returns (uint256) {\\r\\n        return releaseUnixTimeStampV1;\\r\\n    }\\r\\n    ////////////////////////////// BASIC INFO FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// TRANSFER FUNCTIONS //////////////////////////////\\r\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\r\\n        transferInternal(_msgSender(), recipient, amount); // transfers with fees applied\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\r\\n        transferInternal(sender, recipient, amount); \\r\\n        approveInternal(sender, _msgSender(), allowanceAmount[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getTaxValues(uint256 transferAmount) private view returns (uint256[6] memory) {\\r\\n\\r\\n\\r\\n        uint256[6] memory taxLiqCharityBurnLotteryFeeArray;\\r\\n        taxLiqCharityBurnLotteryFeeArray[0] = transferAmount.mul(taxFeePercent).div(10**2);    // calculate Tax Fee\\r\\n        taxLiqCharityBurnLotteryFeeArray[1] = transferAmount.mul(liquidityFeePercent).div(10**2);   // calculate Liquidity Fee\\r\\n        taxLiqCharityBurnLotteryFeeArray[2] = transferAmount.mul(charityFeePercent).div(10**2);   // calculate Charity Fee\\r\\n        taxLiqCharityBurnLotteryFeeArray[3] = transferAmount.mul(burnFeePercent).div(10**2);   // calculate Burn Fee\\r\\n        taxLiqCharityBurnLotteryFeeArray[4] = transferAmount.mul(lotteryFeePercent).div(10**2);   // calculate Lottery Fee\\r\\n        taxLiqCharityBurnLotteryFeeArray[5] = transferAmount.sub(taxLiqCharityBurnLotteryFeeArray[0]).sub(taxLiqCharityBurnLotteryFeeArray[1])\\r\\n            .sub(taxLiqCharityBurnLotteryFeeArray[2]).sub(taxLiqCharityBurnLotteryFeeArray[3]).sub(taxLiqCharityBurnLotteryFeeArray[4]);\\r\\n\\r\\n        return (taxLiqCharityBurnLotteryFeeArray);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function getReflectionValues(uint256 transferAmount, uint256 taxFee, uint256 taxLiquidity, uint256 taxCharityFee, uint256 taxBurnFee, uint256 taxLotteryFee, uint256 currentRate) \\r\\n    private pure returns (uint256, uint256, uint256){\\r\\n        uint256 reflectionAmount = transferAmount.mul(currentRate);\\r\\n        uint256 reflectionFee = taxFee.mul(currentRate);\\r\\n        uint256 reflectionLiquidity = taxLiquidity.mul(currentRate);\\r\\n        uint256 reflectionFeeCharity = taxCharityFee.mul(currentRate);\\r\\n        uint256 reflectionFeeBurn = taxBurnFee.mul(currentRate);\\r\\n        uint256 reflectionFeeLottery = taxLotteryFee.mul(currentRate);\\r\\n        uint256 reflectionTransferAmount = reflectionAmount.sub(reflectionFee).sub(reflectionLiquidity);\\r\\n        reflectionTransferAmount = reflectionTransferAmount.sub(reflectionFeeCharity).sub(reflectionFeeBurn).sub(reflectionFeeLottery);\\r\\n        return (reflectionAmount, reflectionTransferAmount, reflectionFee);\\r\\n    }\\r\\n\\r\\n    function getTaxAndReflectionValues(uint256 tAmount) private view returns (uint256,uint256,uint256, uint256[6] memory) {\\r\\n\\r\\n        (uint256[6] memory taxLiqCharityBurnLotteryFeeArray) = getTaxValues(tAmount);\\r\\n        (uint256 reflectAmount, uint256 reflectTransferAmount, uint256 reflectFee) = \\r\\n            getReflectionValues(tAmount, taxLiqCharityBurnLotteryFeeArray[0], taxLiqCharityBurnLotteryFeeArray[1], \\r\\n                taxLiqCharityBurnLotteryFeeArray[2], taxLiqCharityBurnLotteryFeeArray[3], taxLiqCharityBurnLotteryFeeArray[4], getReflectRate());\\r\\n        return (reflectAmount, reflectTransferAmount, reflectFee, taxLiqCharityBurnLotteryFeeArray);\\r\\n\\r\\n    }\\r\\n\\r\\n    ////////////////////////////// TRANSFER FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// ALLOWANCE FUNCTIONS //////////////////////////////\\r\\n    function allowance(address ownerAddr, address spender) external view override returns (uint256) { \\r\\n        return allowanceAmount[ownerAddr][spender];    // Returns remaining tokens that spender is allowed during {approve} or {transferFrom} \\r\\n    }\\r\\n\\r\\n    function approveInternal(address ownerAddr, address spender, uint256 amount) private { \\r\\n        // This is internal function is equivalent to `approve`, and can be used to e.g. set automatic allowances for certain subsystems, etc.\\r\\n        require(ownerAddr != address(0), \\\"BEP20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\r\\n        allowanceAmount[ownerAddr][spender] = amount;       // approves the amount to spend by the ownerAddr\\r\\n        emit Approval(ownerAddr, spender, amount);\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns (bool){\\r\\n        approveInternal(_msgSender(), spender, amount);     \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool){\\r\\n        approveInternal(_msgSender(), spender, allowanceAmount[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool){\\r\\n        approveInternal(_msgSender(),spender,allowanceAmount[_msgSender()][spender].sub(subtractedValue,\\\"BEP20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    ////////////////////////////// ALLOWANCE FUNCTIONS //////////////////////////////\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// RFI FUNCTIONS //////////////////////////////\\r\\n    function totalFees() public view returns (uint256) {\\r\\n        return totalFeeAmount;\\r\\n    }\\r\\n\\r\\n    function deliverReflectTokens(uint256 tAmount) public {     // this is just a burn for Reflect Tokens\\r\\n        address sender = _msgSender();           \\r\\n        require(!isAccountExcludedFromReward[sender],\\\"Excluded addresses cannot call this function\\\");\\r\\n        (uint256 rAmount, , , ) = getTaxAndReflectionValues(tAmount);\\r\\n        reflectTokensOwned[sender] = reflectTokensOwned[sender].sub(rAmount);\\r\\n        _rTotal = _rTotal.sub(rAmount);\\r\\n        totalFeeAmount = totalFeeAmount.add(tAmount);     \\r\\n    }\\r\\n\\r\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns (uint256) {\\r\\n        require(tAmount \\u003c= totalSupplyOfToken, \\\"Amount must be less than supply\\\");         \\r\\n        (uint256 rAmount, uint256 rTransferAmount, , ) = getTaxAndReflectionValues(tAmount);\\r\\n        if(deductTransferFee){\\r\\n            return rTransferAmount;     // if we are deducting the transfer fee, then use this amount, otherwise return the regular Amount\\r\\n        }\\r\\n        else{\\r\\n            return rAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tokenFromReflection(uint256 rAmount) public view returns (uint256){  \\r\\n        require(rAmount \\u003c= _rTotal, \\\"Amount must be less than total reflections\\\");\\r\\n        uint256 currentRate = getReflectRate();\\r\\n        return rAmount.div(currentRate);        // gets the amount of the reflection\\r\\n    }\\r\\n\\r\\n    function isExcludedFromReward(address account) public view returns (bool) {\\r\\n        return isAccountExcludedFromReward[account];\\r\\n    }\\r\\n\\r\\n    function excludeFromReward(address account) public onlyOwner() {\\r\\n        // if there is ever cross change compatability, then in the future you will need to include Uniswap Addresses, but for now Pancake Swap works, just one router address works\\r\\n        require(account != routerAddressForDEX, \\\"Account must not be PancakeSwap Router\\\");    // don\\u0027t ever exclude the Uniswap or Pancake Swap router\\r\\n        require(!isAccountExcludedFromReward[account], \\\"Account is already excluded\\\");\\r\\n        if (reflectTokensOwned[account] \\u003e 0) {\\r\\n            totalTokensOwned[account] = tokenFromReflection(reflectTokensOwned[account]);   // gets the reflect tokens and gives them to the address before excluding it\\r\\n        }\\r\\n        isAccountExcludedFromReward[account] = true;\\r\\n        excludedFromRewardAddresses.push(account);\\r\\n    }\\r\\n\\r\\n    function includeInReward(address account) external onlyOwner() {\\r\\n        require(isAccountExcludedFromReward[account], \\\"Account is already included\\\");\\r\\n        for (uint256 i = 0; i \\u003c excludedFromRewardAddresses.length; i++) {\\r\\n            if (excludedFromRewardAddresses[i] == account) {\\r\\n                excludedFromRewardAddresses[i] = excludedFromRewardAddresses[excludedFromRewardAddresses.length - 1];   // finds and removes the address from the excluded addresses\\r\\n                totalTokensOwned[account] = 0;  // sets the reward tokens to 0\\r\\n                isAccountExcludedFromReward[account] = false;\\r\\n                excludedFromRewardAddresses.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function excludeFromFee(address account) public onlyOwner() {\\r\\n        isAccountExcludedFromFee[account] = true;\\r\\n    }\\r\\n\\r\\n    function includeInFee(address account) public onlyOwner() {\\r\\n        isAccountExcludedFromFee[account] = false;\\r\\n    }\\r\\n\\r\\n    function isExcludedFromFee(address account) public view returns (bool) {\\r\\n        return isAccountExcludedFromFee[account];\\r\\n    }\\r\\n\\r\\n    function takeReflectFee(uint256 reflectFee, uint256 taxFee) private {\\r\\n        _rTotal = _rTotal.sub(reflectFee);      // subtracts the fee from the reflect totals\\r\\n        totalFeeAmount = totalFeeAmount.add(taxFee);    // adds to the toal fee amount\\r\\n    }\\r\\n\\r\\n    function getReflectRate() private view returns (uint256) {\\r\\n        (uint256 reflectSupply, uint256 tokenSupply) = getCurrentSupplyTotals();       // gets the current reflect supply, and the total token supply.\\r\\n        return reflectSupply.div(tokenSupply);        // to get the rate, we will divide the reflect supply by the total token supply.\\r\\n    }\\r\\n\\r\\n    function getCurrentSupplyTotals() private view returns (uint256, uint256) { \\r\\n\\r\\n        uint256 rSupply = _rTotal;      // total reflections\\r\\n        uint256 tSupply = totalSupplyOfToken;       // total supply\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c excludedFromRewardAddresses.length; i++) {\\r\\n            if ((reflectTokensOwned[excludedFromRewardAddresses[i]] \\u003e rSupply) || (totalTokensOwned[excludedFromRewardAddresses[i]] \\u003e tSupply)){\\r\\n                return (_rTotal, totalSupplyOfToken);       // if any address that is excluded has a greater reflection supply or great than the total supply then we just return that\\r\\n            } \\r\\n            rSupply = rSupply.sub(reflectTokensOwned[excludedFromRewardAddresses[i]]);  // calculates the reflection supply by subtracting the reflect tokens owned from every address\\r\\n            tSupply = tSupply.sub(totalTokensOwned[excludedFromRewardAddresses[i]]);    // calculates the total token supply by subtracting the total tokens owned from every address\\r\\n            // I think this will eventually leave the supplies with what\\u0027s left in the PancakeSwap router\\r\\n        }\\r\\n\\r\\n        if (rSupply \\u003c _rTotal.div(totalSupplyOfToken)){     // checks to see if the reflection total rate is greater than the reflection supply after subtractions\\r\\n            return (_rTotal, totalSupplyOfToken);\\r\\n        } \\r\\n\\r\\n        return (rSupply, tSupply);\\r\\n    }\\r\\n    ////////////////////////////// RFI FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// TAX FUNCTIONS //////////////////////////////\\r\\n    function setTaxFeePercent(uint256 newTaxFeePercent) external onlyOwner() {\\r\\n        require(newTaxFeePercent \\u003c= 5, \\\"New percent must be 5 or less\\\");\\r\\n        taxFeePercent = newTaxFeePercent;\\r\\n    }\\r\\n\\r\\n    function setCharityFeePercent(uint256 newCharityFee) external onlyOwner() {\\r\\n        require(newCharityFee \\u003c= 5, \\\"New percent must be 5 or less\\\");\\r\\n        charityFeePercent = newCharityFee;\\r\\n    }\\r\\n\\r\\n    function setBurnFeePercent(uint256 newBurnFee) external onlyOwner() {\\r\\n        require(newBurnFee \\u003c= 5, \\\"New percent must be 5 or less\\\");\\r\\n        burnFeePercent = newBurnFee;\\r\\n    }\\r\\n\\r\\n    function setLotteryFeePercent(uint256 newLotteryFee) external onlyOwner() {\\r\\n        require(newLotteryFee \\u003c= 5, \\\"New percent must be 5 or less\\\");\\r\\n        lotteryFeePercent = newLotteryFee;\\r\\n    }\\r\\n\\r\\n    function setLiquidityFeePercent(uint256 newLiquidityFeePercent) external onlyOwner() {\\r\\n        require(newLiquidityFeePercent \\u003c= 5, \\\"New percent must be 5 or less\\\");\\r\\n        liquidityFeePercent = newLiquidityFeePercent;\\r\\n    }\\r\\n\\r\\n    function takeLiquidityFee(uint256 tLiquidity) private {\\r\\n        uint256 currentRate = getReflectRate();\\r\\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\\r\\n        reflectTokensOwned[address(this)] = reflectTokensOwned[address(this)].add(rLiquidity);  // if included gives the reward to their reflect tokens owned part\\r\\n        if (isAccountExcludedFromReward[address(this)]){\\r\\n            totalTokensOwned[address(this)] = totalTokensOwned[address(this)].add(tLiquidity);  // if excluded from reward gives it to their tokens, \\r\\n        }\\r\\n    }\\r\\n\\r\\n    function takeCharityFee(uint256 taxCharityFee) private {\\r\\n        uint256 currentRate = getReflectRate();\\r\\n        uint256 rCharityTaxFee = taxCharityFee.mul(currentRate);\\r\\n        reflectTokensOwned[charityAddress] = reflectTokensOwned[charityAddress].add(rCharityTaxFee); \\r\\n        if (isAccountExcludedFromReward[charityAddress]){\\r\\n            totalTokensOwned[charityAddress] = totalTokensOwned[charityAddress].add(taxCharityFee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function takeBurnFee(uint256 taxBurnFee) private {\\r\\n        uint256 currentRate = getReflectRate();\\r\\n        uint256 rBurnTaxFee = taxBurnFee.mul(currentRate);\\r\\n        reflectTokensOwned[deadAddress] = reflectTokensOwned[deadAddress].add(rBurnTaxFee); \\r\\n        if (isAccountExcludedFromReward[deadAddress]){\\r\\n            totalTokensOwned[deadAddress] = totalTokensOwned[deadAddress].add(taxBurnFee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function takeLotteryFee(uint256 taxLotteryFee) private {\\r\\n        uint256 currentRate = getReflectRate();\\r\\n        uint256 rLotteryTaxFee = taxLotteryFee.mul(currentRate);\\r\\n        reflectTokensOwned[lotteryAddress] = reflectTokensOwned[lotteryAddress].add(rLotteryTaxFee); \\r\\n        if (isAccountExcludedFromReward[lotteryAddress]){\\r\\n            totalTokensOwned[lotteryAddress] = totalTokensOwned[lotteryAddress].add(taxLotteryFee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeAllFee() private {\\r\\n        previousTaxFeePercent = taxFeePercent;\\r\\n        previousCharityFeePercent = charityFeePercent;\\r\\n        previousBurnFeePercent = burnFeePercent;\\r\\n        previousLotteryFeePercent = lotteryFeePercent;\\r\\n        previousLiquidityFeePercent = liquidityFeePercent;\\r\\n\\r\\n        taxFeePercent = 0;\\r\\n        charityFeePercent = 0;\\r\\n        burnFeePercent = 0;\\r\\n        lotteryFeePercent = 0;\\r\\n        liquidityFeePercent = 0;\\r\\n    }\\r\\n\\r\\n    function restoreAllFee() private {\\r\\n        taxFeePercent = previousTaxFeePercent;\\r\\n        charityFeePercent = previousCharityFeePercent;\\r\\n        burnFeePercent = previousBurnFeePercent;\\r\\n        lotteryFeePercent = previousLotteryFeePercent;\\r\\n        liquidityFeePercent = previousLiquidityFeePercent;\\r\\n    }\\r\\n    ////////////////////////////// TAX FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// LIQ FUNCTIONS //////////////////////////////\\r\\n\\r\\n    function swapAndLiquify(uint256 contractStoredFeeTokenBalance) private {        // this sells half the tokens when over a certain amount.\\r\\n        inSwapAndLiquify = true;\\r\\n        // gets two halves to be used in liquification\\r\\n        uint256 half1 = contractStoredFeeTokenBalance.div(2);\\r\\n        uint256 half2 = contractStoredFeeTokenBalance.sub(half1);\\r\\n        uint256 initialBalance = address(this).balance;     \\r\\n        // gets initial balance, get exact amount of BNB that swap creates, and make sure the liquidity event doesn\\u0027t include BNB manually sent to the contract.\\r\\n        swapTokensForEth(half1); // swaps tokens into BNB to add back into liquidity. Uses half 1\\r\\n        uint256 newBalance = address(this).balance.sub(initialBalance);     // new Balance calculated after that swap\\r\\n        addLiquidity(half2, newBalance);     // Adds liquidity to PancakeSwap using Half 2\\r\\n        emit SwapAndLiquify(half1, newBalance, half2);\\r\\n        inSwapAndLiquify = false;\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);       // Contract Token Address\\r\\n        path[1] = pancakeswapRouter.WETH();     // Router Address\\r\\n        approveInternal(address(this), address(pancakeswapRouter), tokenAmount);        // Why two approvals? Have to approve both halfs\\r\\n        pancakeswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp);     // make the swap\\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        approveInternal(address(this), address(pancakeswapRouter), tokenAmount);        // Why two approvals? Have to approve both halfs\\r\\n        pancakeswapRouter.addLiquidityETH{value: ethAmount}(address(this),tokenAmount, 0, 0, address(this), block.timestamp);     // adds the liquidity\\r\\n        // perhaps in the future I might want to change the minimum amounts that are swapped - the 0, 0, parameters\\r\\n    }\\r\\n\\r\\n    function setSwapAndLiquifyEnabled(bool enableSwapAndLiquify) external onlyOwner() {     \\r\\n        isSwapAndLiquifyEnabled = enableSwapAndLiquify;   // allows owner to turn off the liquification fee\\r\\n        emit SwapAndLiquifyEnabledUpdated(enableSwapAndLiquify);\\r\\n    }\\r\\n\\r\\n\\r\\n    function setNumberOfTokensToSwapAndLiquify(uint256 newTokenAmount) external onlyOwner() {      // addition, in version 1 of NIP, this will allow you to set the numTokensSellToAddToLiquidity later on if you need to.\\r\\n        numTokensSellToAddToLiquidity = newTokenAmount;\\r\\n    }\\r\\n\\r\\n    ////////////////////////////// LIQ FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// PANCAKESWAP FUNCTIONS //////////////////////////////\\r\\n    function setRouterAddress(address newRouter) external onlyOwner() {\\r\\n        routerAddressForDEX = newRouter;\\r\\n        IPancakeRouter02 pancakeswapRouterLocal = IPancakeRouter02(routerAddressForDEX);      // gets the router\\r\\n        pancakeswapPair = IPancakeFactory(pancakeswapRouterLocal.factory()).createPair(address(this), pancakeswapRouterLocal.WETH());     // Creates the pancakeswap pair   \\r\\n        pancakeswapRouter = pancakeswapRouterLocal;   // set the rest of the contract variables in the global router variable from the local one\\r\\n    }\\r\\n\\r\\n    function setPairAddress(address newPairAddress) public onlyOwner() {\\r\\n        pancakeswapPair = newPairAddress;\\r\\n    }\\r\\n    ////////////////////////////// PANCAKESWAP FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// CHAINLINK FUNCTIONS //////////////////////////////\\r\\n    // Setters for Chainlink VRF\\r\\n    function setKeyHashForLinkVRF(bytes32 newKeyHash) public onlyOwner() {\\r\\n        keyHashForLINK = newKeyHash;\\r\\n    }\\r\\n\\r\\n    function setFeeForLinkVRF(uint256 newFee) public onlyOwner() {\\r\\n        feeForLINK = newFee;\\r\\n    }\\r\\n    ////////////////////////////// CHAINLINK FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// CUSTOM TRANSFER FUNCTIONS //////////////////////////////\\r\\n    \\r\\n    function transferInternal(address senderAddr, address receiverAddr, uint256 amount) private {   \\r\\n        // internal function is equivalent to {transfer}, and can be used to e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n\\r\\n        require(senderAddr != address(0), \\\"BEP20: transfer from the zero address\\\");\\r\\n        require(receiverAddr != address(0), \\\"BEP20: transfer to the zero address\\\");\\r\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        \\r\\n        uint256 contractStoredFeeTokenBalance = balanceOf(address(this));\\r\\n\\r\\n        bool overMinContractStoredFeeTokenBalance = false; \\r\\n        if(contractStoredFeeTokenBalance \\u003e= numTokensSellToAddToLiquidity){  // check to see if there are enough tokens stored from fees in the Contract to justify the Swap\\r\\n            overMinContractStoredFeeTokenBalance = true;                        // if we did not have a minimum, the gas would eat into the profits generated from the fees.\\r\\n        }\\r\\n\\r\\n        if (overMinContractStoredFeeTokenBalance \\u0026\\u0026 !inSwapAndLiquify \\u0026\\u0026 senderAddr != pancakeswapPair \\u0026\\u0026 isSwapAndLiquifyEnabled) {\\r\\n            contractStoredFeeTokenBalance = numTokensSellToAddToLiquidity;     // the reason this is set to that, is to make sure we get the exact amount we are wanting to swap and liquify   \\r\\n            swapAndLiquify(contractStoredFeeTokenBalance);   //add liquidity\\r\\n        }\\r\\n\\r\\n        bool takeFee = true;    // should fee be taken?\\r\\n        if (isAccountExcludedFromFee[senderAddr] || isAccountExcludedFromFee[receiverAddr]) {   // if either address is excluded from fee, then set takeFee to false.\\r\\n            takeFee = false;    \\r\\n        }\\r\\n\\r\\n\\r\\n        transferTokens(senderAddr, receiverAddr, amount, takeFee); \\r\\n    }\\r\\n\\r\\n    function transferTokens(address sender, address recipient, uint256 transferAmount, bool takeFee) private {\\r\\n        if (!takeFee) {\\r\\n            removeAllFee();\\r\\n        }\\r\\n\\r\\n        (uint256 reflectAmount, uint256 reflectTransferAmount,uint256 reflectFee, uint256[6] memory taxLiqCharityBurnLotteryFeeArray) = getTaxAndReflectionValues(transferAmount);\\r\\n\\r\\n        if(isAccountExcludedFromReward[sender]){    // is the sender address excluded from Reward?\\r\\n            totalTokensOwned[sender] = totalTokensOwned[sender].sub(transferAmount);\\r\\n        }\\r\\n        reflectTokensOwned[sender] = reflectTokensOwned[sender].sub(reflectAmount);\\r\\n\\r\\n        if(isAccountExcludedFromReward[recipient]){    // is the sender address excluded from Reward?\\r\\n            totalTokensOwned[recipient] = totalTokensOwned[recipient].add(taxLiqCharityBurnLotteryFeeArray[5]);\\r\\n        }\\r\\n        reflectTokensOwned[recipient] = reflectTokensOwned[recipient].add(reflectTransferAmount);\\r\\n\\r\\n        takeLiquidityFee(taxLiqCharityBurnLotteryFeeArray[1]);   \\r\\n        takeCharityFee(taxLiqCharityBurnLotteryFeeArray[2]);      \\r\\n        takeBurnFee(taxLiqCharityBurnLotteryFeeArray[3]);      \\r\\n        takeLotteryFee(taxLiqCharityBurnLotteryFeeArray[4]);      \\r\\n        takeReflectFee(reflectFee, taxLiqCharityBurnLotteryFeeArray[0]);\\r\\n\\r\\n        emit Transfer(sender, recipient, taxLiqCharityBurnLotteryFeeArray[5]);\\r\\n\\r\\n        if (!takeFee){\\r\\n            restoreAllFee();\\r\\n        } \\r\\n\\r\\n        if(isLotterySystemEnabled){ // Lotto functions\\r\\n\\r\\n            if(isAddSingleEntrySystemEnabled){\\r\\n                checkForLotteryParticipationOrRemovalSingle(recipient);\\r\\n                checkForLotteryParticipationOrRemovalSingle(sender);\\r\\n            }\\r\\n\\r\\n            if(isRewardSingleEntrySystemEnabled){\\r\\n                weeklyLotterySingle();\\r\\n                weeklyLotteryFulfillSingle();\\r\\n            }\\r\\n\\r\\n    \\r\\n            lotteryDisperseFromDrawingWallet();\\r\\n        }\\r\\n    }\\r\\n    ////////////////////////////// CUSTOM TRANSFER FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// SINGLE LOTTERY FUNCTIONS //////////////////////////////\\r\\n\\r\\n    function checkForLotteryParticipationOrRemovalSingle(address addressToCheck) private {\\r\\n\\r\\n\\r\\n        if(!isExcludedFromLottery[addressToCheck]){  // if the recipient isn\\u0027t excluded from the lottery we must check balance and add \\r\\n\\r\\n            uint256 currentBalanceOfAddrToCheck = balanceOf(addressToCheck);    \\r\\n\\r\\n            if(currentBalanceOfAddrToCheck \\u003e= amountNeededForDrawingChance){       // make sure they have enough\\r\\n\\r\\n                if(!hasEnoughTokensForLotterySingle[addressToCheck]){     // if he is not in the pool then add him\\r\\n                    hasEnoughTokensForLotterySingle[addressToCheck] = true;\\r\\n\\r\\n                    lotteryPoolCounterSingle = lotteryPoolCounterSingle.add(1);     // increases the lottery pool counter\\r\\n\\r\\n                    lotteryPoolNumberToAddressSingle[lotteryPoolCounterSingle] = addressToCheck;       // adds him to the lottery pool\\r\\n                    lotteryPoolAddressToNumberSingle[addressToCheck] = lotteryPoolCounterSingle;        // adds his position to the other mapping\\r\\n                }\\r\\n\\r\\n                // don\\u0027t do anything if he is already in the pool.\\r\\n\\r\\n            }\\r\\n            else{\\r\\n                if(hasEnoughTokensForLotterySingle[addressToCheck]){      // checks to see if they at one point did have enough tokens, remove them out of lotto if they did\\r\\n                    hasEnoughTokensForLotterySingle[addressToCheck] = false;\\r\\n                    removeFromLotteryCompletelySingle(addressToCheck);\\r\\n                }\\r\\n                // don\\u0027t do anything if he is already out of the pool\\r\\n            }\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n    function checkForLotteryParticipationOrRemovalSingleManual(address addressToCheck) external onlyOwner() {\\r\\n        checkForLotteryParticipationOrRemovalSingle(addressToCheck);\\r\\n    }\\r\\n\\r\\n\\r\\n    function removeFromLotteryCompletelySingle(address addressToRemove) private {    \\r\\n\\r\\n        uint256 positionInLotto = lotteryPoolAddressToNumberSingle[addressToRemove];       // gets the position of the address to replace\\r\\n\\r\\n        address addressToMoveToReplace = lotteryPoolNumberToAddressSingle[lotteryPoolCounterSingle];   // gets the address to replace (the address at the end)\\r\\n\\r\\n        lotteryPoolNumberToAddressSingle[positionInLotto] = addressToMoveToReplace;  // sets the address into the original position \\r\\n\\r\\n        lotteryPoolAddressToNumberSingle[addressToMoveToReplace] = positionInLotto;  // sets the position to the address\\r\\n\\r\\n        lotteryPoolAddressToNumberSingle[addressToRemove] = 0;        // sets it back to zero upon removal\\r\\n\\r\\n        lotteryPoolNumberToAddressSingle[lotteryPoolCounterSingle] = deadAddressZero;       // sets the other address to the dead address, just in case\\r\\n\\r\\n        lotteryPoolCounterSingle = lotteryPoolCounterSingle.sub(1);     // decreases the lottery pool counter\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    function weeklyLotterySingle() private {     // gets called at the end of every transfer\\r\\n\\r\\n        // single entry version\\r\\n        if(block.timestamp \\u003e= lotteryTime \\u0026\\u0026 lotteryPoolCounterSingle \\u003e 0){     \\r\\n\\r\\n            if(amountToDisperseInDrawingLeft == 0 \\u0026\\u0026 LINK.balanceOf(address(this)) \\u003e= feeForLINK){ \\r\\n\\r\\n                uint256 currentLotteryWalletBalance = balanceOf(lotteryAddress);\\r\\n                if(currentLotteryWalletBalance \\u003e 0){\\r\\n\\r\\n                    if(isCallLotteryReady){\\r\\n                        isCallLotteryReady = false;\\r\\n                        bytes32 requestIdForRandomNum = getRandomNumber(block.timestamp);   // gets random number to determine lottery winner\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n            \\r\\n    }\\r\\n    function weeklyLotteryManualSingle() external onlyOwner() {\\r\\n        weeklyLotterySingle();\\r\\n    }\\r\\n\\r\\n\\r\\n    function weeklyLotteryFulfillSingle() private {\\r\\n\\r\\n\\r\\n        uint256 currentLotteryWalletBalance = balanceOf(lotteryAddress);\\r\\n\\r\\n        if(isRandomnessFulfilled){\\r\\n            isRandomnessFulfilled = false;\\r\\n\\r\\n            currentLotteryWinner = lotteryPoolNumberToAddressSingle[randomResultFromLINKVRF];      // set current lottery winner\\r\\n            emit RandomNumberPickedSingle(randomResultFromLINKVRF);\\r\\n\\r\\n            uint256 randomExpansionCounter = 0;\\r\\n            while (currentLotteryWinner == deadAddressZero) {   // if he picks a dead address, we need to loop to find the winner, max 10 times for gas concerns\\r\\n                \\r\\n                uint256 newRandNumber = (uint256(keccak256(abi.encode(randomResultFromLINKVRF, randomExpansionCounter))).mod(lotteryPoolCounterSingle)).add(1);\\r\\n                emit RandomNumberPickedSingle(newRandNumber);\\r\\n                currentLotteryWinner = lotteryPoolNumberToAddressSingle[newRandNumber];      // set current lottery winner\\r\\n                randomExpansionCounter = randomExpansionCounter.add(1);\\r\\n\\r\\n                if(randomExpansionCounter \\u003e numberToUseForRandomLoopFindWinner){        // 25 is risking it, but I think it can be done., we can set lower later\\r\\n                    emit LoopBrokenTooManyDrawingsSingle(randomExpansionCounter);\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n\\r\\n\\r\\n            if(currentLotteryWinner != deadAddress){    // failsafe\\r\\n\\r\\n                transferTokensForLotteryToDrawingOrWinner(lotteryAddress, drawingAddress, currentLotteryWalletBalance, false);    // transfers the tokens to the drawing address\\r\\n\\r\\n                uint256 currentDrawingWalletBalance = balanceOf(drawingAddress);\\r\\n                amountToDisperseInDrawingTotal = currentDrawingWalletBalance;\\r\\n                amountToDisperseInDrawingLeft = currentDrawingWalletBalance;\\r\\n                amountToDisperseInDrawingPerPeriod = currentDrawingWalletBalance.div(periodsToDisperse);\\r\\n                dispersalTime = block.timestamp;\\r\\n                lotteryTime = lotteryTime.add(periodsToDisperse.mul(hoursInPeriodToDisperse)); // reset the lotteryTime back to the block until it\\u0027s time for a new drawing \\r\\n\\r\\n                isExcludedFromLottery[currentLotteryWinner] = true;     // exclude him and remove chances from lotto pool\\r\\n                removeFromLotteryCompletelySingle(currentLotteryWinner);\\r\\n\\r\\n                emit WinnerPickedS(currentLotteryWinner);\\r\\n\\r\\n                isCallLotteryReady = true;\\r\\n\\r\\n            } \\r\\n        }\\r\\n    }\\r\\n\\r\\n    ////////////////////////////// SINGLE LOTTERY FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////// LOTTERY CORE FUNCTIONS //////////////////////////////\\r\\n    function lotteryDisperseFromDrawingWallet() private {      // gets called at the end of every transfer\\r\\n        \\r\\n        if(amountToDisperseInDrawingLeft \\u003e 0){  // make sure it has tokens to disperse\\r\\n            if(block.timestamp \\u003e= dispersalTime) {    // is it time to disperse again?\\r\\n\\r\\n                uint256 currentDrawingWalletBalance = balanceOf(drawingAddress);\\r\\n                if(currentDrawingWalletBalance \\u003e= amountToDisperseInDrawingPerPeriod){\\r\\n\\r\\n                    if(amountToDisperseInDrawingPerPeriod \\u003e currentDrawingWalletBalance.sub(amountToDisperseInDrawingPerPeriod) ){   \\r\\n                        // flag to send it all of the winnings out, as trace amounts will be left over.\\r\\n                        transferTokensForLotteryToDrawingOrWinner(drawingAddress, currentLotteryWinner, balanceOf(drawingAddress), false);\\r\\n                        amountToDisperseInDrawingLeft = 0;\\r\\n                    }\\r\\n                    else{   \\r\\n                        // send the corret partial drawing amount\\r\\n                        transferTokensForLotteryToDrawingOrWinner(drawingAddress, currentLotteryWinner, amountToDisperseInDrawingPerPeriod, false);\\r\\n                        amountToDisperseInDrawingLeft = amountToDisperseInDrawingLeft.sub(amountToDisperseInDrawingPerPeriod);\\r\\n                    }\\r\\n\\r\\n                }       \\r\\n                else if(currentDrawingWalletBalance \\u003e 0){       // failsafe, just incase there gets any left over.\\r\\n                    // this will just get rid of any remainder to the winner, there might be instances where there are left over tokens\\r\\n                    transferTokensForLotteryToDrawingOrWinner(drawingAddress, currentLotteryWinner, amountToDisperseInDrawingLeft, false);\\r\\n                    amountToDisperseInDrawingLeft = 0;\\r\\n                }\\r\\n                \\r\\n                dispersalTime = dispersalTime.add(hoursInPeriodToDisperse);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function lotteryDisperseFromDrawingWalletManual() external onlyOwner() {\\r\\n        lotteryDisperseFromDrawingWallet();\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n    function getRandomNumber(uint256 userProvidedSeed) private returns (bytes32 requestId) {     // Requests randomness from a user-provided seed\\r\\n        require(LINK.balanceOf(address(this)) \\u003e= feeForLINK, \\\"Not enough LINK - fill contract with faucet\\\");\\r\\n        return requestRandomness(keyHashForLINK, feeForLINK, userProvidedSeed);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {   // Callback function used by VRF Coordinator\\r\\n        if(isRewardSingleEntrySystemEnabled){\\r\\n            uint256 randomNum = (randomness.mod(lotteryPoolCounterSingle));\\r\\n            emit RandomNumberDeterminedSingle(randomNum);\\r\\n            randomNum = randomNum.add(1);\\r\\n            emit RandomNumberDeterminedSingle(randomNum);\\r\\n            randomResultFromLINKVRF = randomNum;       // gets a random element to use with the lotto mapping  // add 1 to go from 1 to lotto number, \\r\\n        }\\r\\n        \\r\\n        isRandomnessFulfilled = true;\\r\\n    }\\r\\n    \\r\\n\\r\\n\\r\\n    // TestFunctions Here\\r\\n\\r\\n    function expandExampleTestSingle(uint256 randomValue, uint256 n) public view returns (uint256[] memory expandedValues) {\\r\\n        expandedValues = new uint256[](n);\\r\\n        for (uint256 i = 0; i \\u003c n; i++) {\\r\\n            expandedValues[i] = (uint256(keccak256(abi.encode(randomValue, i))).mod(lotteryPoolCounterSingle)).add(1);\\r\\n        }\\r\\n        return expandedValues;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function getSecondsUntilNextLotto() public view returns (uint256 secondsUntilNextLotto){\\r\\n        if(block.timestamp \\u003e= lotteryTime){\\r\\n            return 0;\\r\\n        }\\r\\n        if(lotteryTime.sub(block.timestamp) \\u003e 0){\\r\\n            return lotteryTime.sub(block.timestamp);\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function setLotterytime(uint256 newLotteryTime) external onlyOwner() {\\r\\n        lotteryTime = newLotteryTime;\\r\\n    }\\r\\n\\r\\n    function setMaxDrawingChances(uint256 newMaxDrawingChances) public onlyOwner() {\\r\\n        require(newMaxDrawingChances \\u003c= initialMaxDrawingChances, \\\"New max drawing chances cannot be over the initial Max Drawin Changes\\\");\\r\\n        maxDrawingChances = newMaxDrawingChances;\\r\\n    }\\r\\n\\r\\n    function setAmountNeededForDrawingChance(uint256 newAmountNeededForDrawingChance) public onlyOwner() {\\r\\n        amountNeededForDrawingChance = newAmountNeededForDrawingChance;\\r\\n    }\\r\\n\\r\\n    function setPeriodsToDisperse(uint256 newPeriodsToDisperse) public onlyOwner() {\\r\\n        periodsToDisperse = newPeriodsToDisperse;\\r\\n    }\\r\\n\\r\\n    function setHoursInPeriodToDisperse(uint256 newHoursInPeriodToDisperse) public onlyOwner() {\\r\\n        hoursInPeriodToDisperse = newHoursInPeriodToDisperse;\\r\\n    }\\r\\n\\r\\n    function setLotterySystemEnabled(bool isLotterySystemEnabledNew) public onlyOwner() {\\r\\n        isLotterySystemEnabled = isLotterySystemEnabledNew;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setAddSingleEntrySystemEnabled(bool isEnabledNew) public onlyOwner() {\\r\\n        isAddSingleEntrySystemEnabled = isEnabledNew;\\r\\n    }\\r\\n\\r\\n    function setRewardSingleEntrySystemEnabled(bool isEnabledNew) public onlyOwner() {\\r\\n        isRewardSingleEntrySystemEnabled = isEnabledNew;\\r\\n    }\\r\\n\\r\\n    function setNumberToUseForRandomLoopFindWinner(uint256 newNumber) public onlyOwner() {\\r\\n        numberToUseForRandomLoopFindWinner = newNumber;\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n\\r\\n    function excludeOrIncludeFromLotterySingle(address addressToExcludeInclude, bool setIsExcludedFromLottery) public onlyOwner() {\\r\\n        isExcludedFromLottery[addressToExcludeInclude] = setIsExcludedFromLottery;\\r\\n        if(setIsExcludedFromLottery){\\r\\n            removeFromLotteryCompletelySingle(addressToExcludeInclude); \\r\\n        }\\r\\n    }\\r\\n\\r\\n    function excludeOrIncludeJustFromLottery(address addressToExcludeInclude, bool setIsExcludedFromLottery) public onlyOwner() {\\r\\n        isExcludedFromLottery[addressToExcludeInclude] = setIsExcludedFromLottery;\\r\\n    }\\r\\n\\r\\n    function transferTokensForLotteryToDrawingOrWinner(address sender, address recipient, uint256 transferAmount, bool takeFee) private {\\r\\n        if (!takeFee) {\\r\\n            removeAllFee();\\r\\n        }\\r\\n        (uint256 reflectAmount, uint256 reflectTransferAmount,uint256 reflectFee, uint256[6] memory taxLiqCharityBurnLotteryFeeArray) = getTaxAndReflectionValues(transferAmount);\\r\\n\\r\\n        if(isAccountExcludedFromReward[sender]){    // is the sender address excluded from Reward?\\r\\n            totalTokensOwned[sender] = totalTokensOwned[sender].sub(transferAmount);\\r\\n        }\\r\\n        reflectTokensOwned[sender] = reflectTokensOwned[sender].sub(reflectAmount);\\r\\n\\r\\n        if(isAccountExcludedFromReward[recipient]){    // is the sender address excluded from Reward?\\r\\n            totalTokensOwned[recipient] = totalTokensOwned[recipient].add(taxLiqCharityBurnLotteryFeeArray[5]);\\r\\n        }\\r\\n        reflectTokensOwned[recipient] = reflectTokensOwned[recipient].add(reflectTransferAmount);\\r\\n\\r\\n        takeLiquidityFee(taxLiqCharityBurnLotteryFeeArray[1]);   \\r\\n        takeCharityFee(taxLiqCharityBurnLotteryFeeArray[2]);      \\r\\n        takeBurnFee(taxLiqCharityBurnLotteryFeeArray[3]);      \\r\\n        takeLotteryFee(taxLiqCharityBurnLotteryFeeArray[4]);      \\r\\n        takeReflectFee(reflectFee, taxLiqCharityBurnLotteryFeeArray[0]);\\r\\n\\r\\n        emit Transfer(sender, recipient, taxLiqCharityBurnLotteryFeeArray[5]);\\r\\n\\r\\n        if (!takeFee){\\r\\n            restoreAllFee();\\r\\n        } \\r\\n    }\\r\\n    ////////////////////////////// LOTTERY CORE FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n    ////////////////////////////// RESCUE FUNCTIONS //////////////////////////////\\r\\n    function payableTeamWalletAddr() private view returns (address payable) {   // gets the sender of the payable address\\r\\n        address payable payableMsgSender = payable(address(teamAddress));      \\r\\n        return payableMsgSender;\\r\\n    }\\r\\n\\r\\n    function rescueBNBSentToContractAddress() external onlyOwner()  {   \\r\\n        payableTeamWalletAddr().transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function rescueBEP20SentToContractAddress(IBEP20 tokenToWithdraw) external onlyOwner() {\\r\\n        tokenToWithdraw.safeTransfer(payableTeamWalletAddr(), tokenToWithdraw.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function rescueAllContractToken() external onlyOwner() {\\r\\n        transferInternal(address(this), payableTeamWalletAddr(), balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function rescueAmountContractToken(uint256 amount) external onlyOwner() {\\r\\n        transferInternal(address(this), payableTeamWalletAddr(), amount);\\r\\n    }\\r\\n    ////////////////////////////// RESCUE FUNCTIONS //////////////////////////////\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    receive() external payable {}       // Oh it\\u0027s payable alright.\\r\\n\\r\\n\\r\\n}\"},\"SafeBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\\r\\n// this has been slightly modified to incorporate BEP20 naming conventions as well as inhereting contracts in different places\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeBEP20\\r\\n * @dev Wrappers around BEP20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeBEP20 for IBEP20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeBEP20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IBEP20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IBEP20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeBEP20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance \\u003e= value, \\\"SafeBEP20: decreased allowance below zero\\\");\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeBEP20: low-level call failed\\\");\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeBEP20: BEP20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler\\u0027s built in overflow checks.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\r\\n *\\r\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003c= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\"},\"VRFConsumerBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport \\\"./LinkTokenInterface.sol\\\";\\r\\n\\r\\nimport \\\"./VRFRequestIDBase.sol\\\";\\r\\n\\r\\n/** ****************************************************************************\\r\\n * @notice Interface for contracts using VRF randomness\\r\\n * *****************************************************************************\\r\\n * @dev PURPOSE\\r\\n *\\r\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\r\\n * @dev to Vera the verifier in such a way that Vera can be sure he\\u0027s not\\r\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\r\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\r\\n * @dev Reggie, he gives back a value which is computed completely\\r\\n * @dev deterministically from the seed and the secret key.\\r\\n *\\r\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\r\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\r\\n * @dev the output is indistinguishable to her from a uniform random sample\\r\\n * @dev from the output space.\\r\\n *\\r\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\r\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\r\\n * @dev simple access to a verifiable source of randomness.\\r\\n * *****************************************************************************\\r\\n * @dev USAGE\\r\\n *\\r\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\r\\n * @dev initialize VRFConsumerBase\\u0027s attributes in their constructor as\\r\\n * @dev shown:\\r\\n *\\r\\n * @dev   contract VRFConsumer {\\r\\n * @dev     constuctor(\\u003cother arguments\\u003e, address _vrfCoordinator, address _link)\\r\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\r\\n * @dev         \\u003cinitialization with other arguments goes here\\u003e\\r\\n * @dev       }\\r\\n * @dev   }\\r\\n *\\r\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\r\\n * @dev committed to (let\\u0027s call it keyHash), and have told you the minimum LINK\\r\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\r\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\r\\n * @dev want to generate randomness from.\\r\\n *\\r\\n * @dev Once the VRFCoordinator has received and validated the oracle\\u0027s response\\r\\n * @dev to your request, it will call your contract\\u0027s fulfillRandomness method.\\r\\n *\\r\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\r\\n * @dev generated from your seed.\\r\\n *\\r\\n * @dev The requestId argument is generated from the keyHash and the seed by\\r\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\r\\n * @dev requests open, you can use the requestId to track which seed is\\r\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\r\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\r\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\r\\n *\\r\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\r\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\r\\n * @dev next section.)\\r\\n *\\r\\n * *****************************************************************************\\r\\n * @dev SECURITY CONSIDERATIONS\\r\\n *\\r\\n * @dev A method with the ability to call your fulfillRandomness method directly\\r\\n * @dev could spoof a VRF response with any random value, so it\\u0027s critical that\\r\\n * @dev it cannot be directly called by anything other than this base contract\\r\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\r\\n *\\r\\n * @dev For your users to trust that your contract\\u0027s random behavior is free\\r\\n * @dev from malicious interference, it\\u0027s best if you can write it so that all\\r\\n * @dev behaviors implied by a VRF response are executed *during* your\\r\\n * @dev fulfillRandomness method. If your contract must store the response (or\\r\\n * @dev anything derived from it) and use it later, you must ensure that any\\r\\n * @dev user-significant behavior which depends on that stored value cannot be\\r\\n * @dev manipulated by a subsequent VRF request.\\r\\n *\\r\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\r\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\r\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\r\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\r\\n * @dev be used to manipulate your contract\\u0027s user-significant behavior.\\r\\n *\\r\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\r\\n * @dev block in which the request is made, user-provided seeds have no impact\\r\\n * @dev on its economic security properties. They are only included for API\\r\\n * @dev compatability with previous versions of this contract.\\r\\n *\\r\\n * @dev Since the block hash of the block which contains the requestRandomness\\r\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\r\\n * @dev miner could, in principle, fork the blockchain to evict the block\\r\\n * @dev containing the request, forcing the request to be included in a\\r\\n * @dev different block with a different hash, and therefore a different input\\r\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\r\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\r\\n * @dev until it calls responds to a request.\\r\\n */\\r\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\r\\n\\r\\n  /**\\r\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\r\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\r\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\r\\n   * @notice method.\\r\\n   *\\r\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\r\\n   * @dev signature, and will call it once it has verified the proof\\r\\n   * @dev associated with the randomness. (It is triggered via a call to\\r\\n   * @dev rawFulfillRandomness, below.)\\r\\n   *\\r\\n   * @param requestId The Id initially returned by requestRandomness\\r\\n   * @param randomness the VRF output\\r\\n   */\\r\\n  function fulfillRandomness(\\r\\n    bytes32 requestId,\\r\\n    uint256 randomness\\r\\n  )\\r\\n    internal\\r\\n    virtual;\\r\\n\\r\\n  /**\\r\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\r\\n   *\\r\\n   * @dev The fulfillRandomness method receives the output, once it\\u0027s provided\\r\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\r\\n   *\\r\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\r\\n   * @dev the _fee must exceed the fee specified during registration of the\\r\\n   * @dev _keyHash.\\r\\n   *\\r\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\r\\n   * @dev compatibility with older versions. It can\\u0027t *hurt* to mix in some of\\r\\n   * @dev your own randomness, here, but it\\u0027s not necessary because the VRF\\r\\n   * @dev oracle will mix the hash of the block containing your request into the\\r\\n   * @dev VRF seed it ultimately uses.\\r\\n   *\\r\\n   * @param _keyHash ID of public key against which randomness is generated\\r\\n   * @param _fee The amount of LINK to send with the request\\r\\n   * @param _seed seed mixed into the input of the VRF.\\r\\n   *\\r\\n   * @return requestId unique ID for this request\\r\\n   *\\r\\n   * @dev The returned requestId can be used to distinguish responses to\\r\\n   * @dev concurrent requests. It is passed as the first argument to\\r\\n   * @dev fulfillRandomness.\\r\\n   */\\r\\n  function requestRandomness(\\r\\n    bytes32 _keyHash,\\r\\n    uint256 _fee,\\r\\n    uint256 _seed\\r\\n  )\\r\\n    internal\\r\\n    returns (\\r\\n      bytes32 requestId\\r\\n    )\\r\\n  {\\r\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\\r\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\r\\n    // the hash of the block containing this request to obtain the seed/input\\r\\n    // which is finally passed to the VRF cryptographic machinery.\\r\\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\\r\\n    // nonces[_keyHash] must stay in sync with\\r\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\r\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\r\\n    // This provides protection against the user repeating their input seed,\\r\\n    // which would result in a predictable/duplicate output, if multiple such\\r\\n    // requests appeared in the same block.\\r\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\r\\n    return makeRequestId(_keyHash, vRFSeed);\\r\\n  }\\r\\n\\r\\n  LinkTokenInterface immutable internal LINK;\\r\\n  address immutable private vrfCoordinator;\\r\\n\\r\\n  // Nonces for each VRF key from which randomness has been requested.\\r\\n  //\\r\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\r\\n  mapping(bytes32 /* keyHash */ =\\u003e uint256 /* nonce */) private nonces;\\r\\n\\r\\n  /**\\r\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\r\\n   * @param _link address of LINK token contract\\r\\n   *\\r\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\r\\n   */\\r\\n  constructor(\\r\\n    address _vrfCoordinator,\\r\\n    address _link\\r\\n  ) {\\r\\n    vrfCoordinator = _vrfCoordinator;\\r\\n    LINK = LinkTokenInterface(_link);\\r\\n  }\\r\\n\\r\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\r\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\r\\n  // the origin of the call\\r\\n  function rawFulfillRandomness(\\r\\n    bytes32 requestId,\\r\\n    uint256 randomness\\r\\n  )\\r\\n    external\\r\\n  {\\r\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\r\\n    fulfillRandomness(requestId, randomness);\\r\\n  }\\r\\n}\"},\"VRFRequestIDBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ncontract VRFRequestIDBase {\\r\\n\\r\\n  /**\\r\\n   * @notice returns the seed which is actually input to the VRF coordinator\\r\\n   *\\r\\n   * @dev To prevent repetition of VRF output due to repetition of the\\r\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\r\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\r\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\r\\n   * @dev the final seed, but the nonce does protect against repetition in\\r\\n   * @dev requests which are included in a single block.\\r\\n   *\\r\\n   * @param _userSeed VRF seed input provided by user\\r\\n   * @param _requester Address of the requesting contract\\r\\n   * @param _nonce User-specific nonce at the time of the request\\r\\n   */\\r\\n  function makeVRFInputSeed(\\r\\n    bytes32 _keyHash,\\r\\n    uint256 _userSeed,\\r\\n    address _requester,\\r\\n    uint256 _nonce\\r\\n  )\\r\\n    internal\\r\\n    pure\\r\\n    returns (\\r\\n      uint256\\r\\n    )\\r\\n  {\\r\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the id for this request\\r\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\r\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\r\\n   * @return The id for this request\\r\\n   *\\r\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\r\\n   * @dev contract, but the one generated by makeVRFInputSeed\\r\\n   */\\r\\n  function makeRequestId(\\r\\n    bytes32 _keyHash,\\r\\n    uint256 _vRFInputSeed\\r\\n  )\\r\\n    internal\\r\\n    pure\\r\\n    returns (\\r\\n      bytes32\\r\\n    )\\r\\n  {\\r\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\r\\n  }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomExpansionCounter\",\"type\":\"uint256\"}],\"name\":\"LoopBrokenTooManyDrawingsSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minTokensBeforeSwap\",\"type\":\"uint256\"}],\"name\":\"MinTokensBeforeSwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNum\",\"type\":\"uint256\"}],\"name\":\"RandomNumberDeterminedSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"RandomNumberPickedSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winnerAddress\",\"type\":\"address\"}],\"name\":\"WinnerPickedS\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountNeededForDrawingChance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountToDisperseInDrawingLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountToDisperseInDrawingPerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountToDisperseInDrawingTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToCheck\",\"type\":\"address\"}],\"name\":\"checkForLotteryParticipationOrRemovalSingleManual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLotteryWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddressOne\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddressZero\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliverReflectTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dispersalTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drawingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToExcludeInclude\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"setIsExcludedFromLottery\",\"type\":\"bool\"}],\"name\":\"excludeOrIncludeFromLotterySingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToExcludeInclude\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"setIsExcludedFromLottery\",\"type\":\"bool\"}],\"name\":\"excludeOrIncludeJustFromLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"expandExampleTestSingle\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"expandedValues\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNowBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSecondsUntilNextLotto\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsUntilNextLotto\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasEnoughTokensForLotterySingle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hoursInPeriodToDisperse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialMaxDrawingChances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAddSingleEntrySystemEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCallLotteryReady\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromLottery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLotterySystemEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRandomnessFulfilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRewardSingleEntrySystemEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryDisperseFromDrawingWalletManual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lotteryPoolAddressToNumberSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryPoolCounterSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lotteryPoolNumberToAddressSingle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDrawingChances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellToAddToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberToUseForRandomLoopFindWinner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeswapRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodsToDisperse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plantContractControllerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomResultFromLINKVRF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseUnixTimeDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueAllContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueAmountContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"tokenToWithdraw\",\"type\":\"address\"}],\"name\":\"rescueBEP20SentToContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueBNBSentToContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddressForDEX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isEnabledNew\",\"type\":\"bool\"}],\"name\":\"setAddSingleEntrySystemEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmountNeededForDrawingChance\",\"type\":\"uint256\"}],\"name\":\"setAmountNeededForDrawingChance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBurnFee\",\"type\":\"uint256\"}],\"name\":\"setBurnFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCharityFee\",\"type\":\"uint256\"}],\"name\":\"setCharityFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFeeForLinkVRF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newHoursInPeriodToDisperse\",\"type\":\"uint256\"}],\"name\":\"setHoursInPeriodToDisperse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newKeyHash\",\"type\":\"bytes32\"}],\"name\":\"setKeyHashForLinkVRF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidityFeePercent\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLotteryFee\",\"type\":\"uint256\"}],\"name\":\"setLotteryFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isLotterySystemEnabledNew\",\"type\":\"bool\"}],\"name\":\"setLotterySystemEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLotteryTime\",\"type\":\"uint256\"}],\"name\":\"setLotterytime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxDrawingChances\",\"type\":\"uint256\"}],\"name\":\"setMaxDrawingChances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenAmount\",\"type\":\"uint256\"}],\"name\":\"setNumberOfTokensToSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNumber\",\"type\":\"uint256\"}],\"name\":\"setNumberToUseForRandomLoopFindWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPairAddress\",\"type\":\"address\"}],\"name\":\"setPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPeriodsToDisperse\",\"type\":\"uint256\"}],\"name\":\"setPeriodsToDisperse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isEnabledNew\",\"type\":\"bool\"}],\"name\":\"setRewardSingleEntrySystemEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enableSwapAndLiquify\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTaxFeePercent\",\"type\":\"uint256\"}],\"name\":\"setTaxFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vrfCoordinatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weeklyLotteryManualSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PlantToken", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c7497f0d4da78ceaa1d90de7b61b5c1f2daa20fa2b242f76f24fdfc9bf71d798"}