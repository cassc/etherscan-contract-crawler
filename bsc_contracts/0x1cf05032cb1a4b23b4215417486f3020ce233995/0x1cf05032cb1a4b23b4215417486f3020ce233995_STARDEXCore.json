{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": []\r\n  },\r\n  \"sources\": {\r\n    \"StardexCore_Prod.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function burn(uint256 amount) external;\\n    function mint(address recipient, uint256 amount) external;\\n    function lockCoins(address wallet, bool enabled, uint256 amount, uint256 expired, bool rewriteAmount) external;\\n}\\n\\ninterface IOracle {\\n    function decimals() external view returns (uint8);\\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\\ncontract STARDEXCore {\\n    enum QueueStatus {\\n        Close,\\n        Open\\n    }\\n\\n    enum BuyType {\\n        System,\\n        Referral,\\n        Leader,\\n        Queue,\\n        PreSale\\n    }\\n\\n    enum AmountType {\\n        Bnb,\\n        Usd,\\n        Coins\\n    }\\n\\n    struct Wallet {\\n        uint id;\\n        address referral;\\n        uint bought; //USD\\n        uint sold; //USD\\n        uint limit; //USD\\n    }\\n\\n    struct Order {\\n        uint id;\\n        address wallet;\\n        uint amount; //BNB\\n    }\\n\\n    struct Queue {\\n        uint id;\\n        address wallet;\\n        QueueStatus status;\\n        uint amountCoins;\\n        uint amountSoldCoins;\\n        uint amountBnb;\\n        uint amountUsd;\\n    }\\n\\n    struct Transaction {\\n        uint id;\\n        BuyType buyType;\\n        address buyer;\\n        address seller;\\n        uint orderId;\\n        uint queueId;\\n        uint price;\\n        uint amountCoins;\\n        uint amountBnb;\\n        uint amountUsd;\\n    }\\n\\n    struct Leader {\\n        uint id;\\n        address wallet;\\n        bool active;\\n    }\\n\\n    event UpdateCoinPrice(uint price, uint coins, uint sold, uint time);\\n    event AddUpdateQueue(uint indexed id, address indexed wallet, QueueStatus status, uint amount, uint time);\\n    event CloseQueue(uint indexed id,  address indexed wallet, uint activeQueueId, uint time);\\n    event AddOrder(uint indexed id, address indexed wallet, uint amount, uint time);\\n    event AddLeader(uint indexed id, address indexed wallet, uint time);\\n    event CloseLeader(uint indexed id, address indexed wallet, uint time);\\n    event AddWallet(uint indexed id, address indexed wallet, address indexed referral, uint time);\\n    event UpdateWallet(uint indexed id, address indexed wallet, uint bought, uint limit, uint time);\\n    event AddTransaction(uint indexed id, address indexed buyer, address indexed seller, BuyType buyType, uint orderId, uint queueId, uint priceAmount, uint coinAmount, uint bnbAmount, uint usdAmount, uint time);\\n    event TransferReferralReward(address indexed wallet, uint indexed orderId, address indexed referral, uint8 line, uint amount, uint time);\\n    event TransferFee(uint indexed orderId, uint feeAmount, uint liquidityAmount, uint time);\\n    event PreSale(address indexed wallet, uint orderId, uint transactionId, uint bnbAmount, uint coinsAmount, uint usdAmount, uint lockDays, uint time);\\n\\n    mapping (address => Wallet) public wallets;\\n    mapping (uint => address) public walletIdAddress;\\n    mapping (address => uint[]) public walletQueueIds;\\n    mapping (address => uint[]) public walletOrderIds;\\n    mapping (uint => uint[]) public queueTransactionIds;\\n    mapping (uint => uint[]) public orderTransactionIds;\\n\\n    mapping (uint8 => uint) public settingValues;\\n\\n    Queue[] public queues;\\n    Order[] public orders;\\n    Transaction[] public transactions;\\n    Leader[] public leaders;\\n    \\n    address public ownerAddress;\\n    address public dappAddress = address(0xD6d6535073bdCFb1c351df4d1dC70da3Cb2F9f6A);\\n    address public minterAddress = address(0x793CA04d7153e986eDB9937c54e1e811Dd684980);\\n    address public feeAddress = address(0xA9f0cFCC2818A20f6AE6e938A0f73B8A56D1486D);\\n    address public liquidityAddress = address(0x934360d1557Bdd4a87b795428C6f2Aa0159d1065);\\n    IERC20 public coinAddress = IERC20(address(0x5872b7B0305D745AdE10b13B5Ae5Fae99c10Dcae));\\n    IOracle public oracleAddress = IOracle(address(0xC5A35FC58EFDC4B88DDCA51AcACd2E8F593504bE));\\n\\n    uint public coinPrice;// = 10 * 1e18; //10 USD\\n    uint public coinPricePart;// = 1e16; //0.01 USD\\n    uint public coinReduction;// = 1e10; //0.00000001 Coin\\n    uint public usdReduction;// = 1e16; //0.01 USD\\n    uint public minBuyAmount;// = 25 * 1e18; //$25\\n    uint public minSellAmount;// = 1e15; //0.001 Coin\\n    uint public feePercent;// = 10; //10%\\n    uint public liquidityPercent;// = 10; //10%\\n    uint public chanceReferral;// = 50; //50%\\n    uint public chanceLeader;// = 25; //25%\\n    uint public boardPlacesLeader;// = 5; //5 last wallets\\n    uint public minBuyAmountLeader;// = 250 * 1e18; //$250\\n    uint public walletLimitFactor;// = 3; //300%\\n    uint public nextWalletId;// = 1;\\n    uint public nextQueueId;// = 1;\\n    uint public nextOrderId;// = 1;\\n    uint public nextTransactionId;// = 1;\\n    uint public nextPriceId;// = 1;\\n    uint public nextLeaderId;// = 1;\\n    uint public activeQueueId;// = 1;\\n    uint public oraclePrice;// = 0;\\n    uint public coinPriceUpper;// = 0;\\n    uint public coinPriceSold; // = 0;\\n    uint public activePreSaleAt; // = 0;\\n    uint public limitPreSale; // = 100 * 1e18; //100 USD\\n    uint public lockDaysPreSale;// = 45; //45 days\\n    uint public walletPreSaleLimitFactor; // = 1; //100%\\n    uint8 public oracleDecimals;// = 0;\\n    uint8 public activeReferralLines;// = 10; //10 lines\\n\\n    uint private saltRandom;// = 1;\\n\\n    modifier onlyDapp() { \\n        require(msg.sender == dappAddress || msg.sender == ownerAddress, \\\"33\\\"); \\n        _; \\n    }\\n\\n    modifier onlyOwner() { \\n        require(msg.sender == ownerAddress, \\\"33\\\"); \\n        _; \\n    }\\n\\n    constructor() {\\n        ownerAddress = msg.sender;\\n\\n        settingValues[1] = 120; //12%\\n        settingValues[2] = 60; //6%\\n        settingValues[3] = 40; //4%\\n        settingValues[4] = 30; //3%\\n        settingValues[5] = 20; //2%\\n        settingValues[6] = 10; //1%\\n        settingValues[7] = 5; //0.5%\\n        settingValues[8] = 5; //0.5%\\n        settingValues[9] = 5; //0.5%\\n        settingValues[10] = 5; //0.5%\\n        settingValues[11] = 0; //0%\\n        settingValues[12] = 1000; //0.01%\\n        settingValues[13] = 500; //0.005%\\n        settingValues[14] = 100; //0.001%\\n        settingValues[15] = 50; //0.0005%\\n        settingValues[16] = 10; //0.0001%\\n\\n        coinPrice = 10 * 1e18; //10 USD\\n        coinPricePart = 1e16; //0.01 USD\\n        coinReduction = 1e10; //0.00000001 Coin\\n        usdReduction = 1e16; //0.01 USD\\n        minBuyAmount = 25 * 1e18; //$25\\n        minSellAmount = 1e15; //0.001 Coin\\n        feePercent = 10; //10%\\n        liquidityPercent = 10; //10%\\n        chanceReferral = 50; //50%\\n        chanceLeader = 25; //25%\\n        boardPlacesLeader = 5; //5 last wallets\\n        minBuyAmountLeader = 250 * 1e18; //$250\\n        walletLimitFactor = 3; //300%\\n        nextWalletId = 1;\\n        nextQueueId = 1;\\n        nextOrderId = 1;\\n        nextTransactionId = 1;\\n        nextPriceId = 1;\\n        nextLeaderId = 1;\\n        activeQueueId = 1;\\n        oraclePrice = 0;\\n        coinPriceUpper = 0;\\n        coinPriceSold = 0;\\n        activePreSaleAt = 1705276800; //01/15/2024 UTC\\n        limitPreSale = 100 * 1e18; //100 USD\\n        lockDaysPreSale = 45; //45 days\\n        walletPreSaleLimitFactor = 1; //100%\\n        oracleDecimals = 0;\\n        activeReferralLines = 10; //10 line\\n\\n        //admin\\n        Wallet memory wallet = Wallet(nextWalletId, address(0), 0, 0, 0);\\n        wallets[ownerAddress] = wallet;\\n        walletIdAddress[nextWalletId] = ownerAddress;\\n\\n        emit AddWallet(wallet.id, ownerAddress, wallet.referral, block.timestamp);\\n        nextWalletId++;\\n\\n        //minter\\n        Wallet memory minterWallet = Wallet(nextWalletId, ownerAddress, 0, 0, 0);\\n        wallets[minterAddress] = minterWallet;\\n        walletIdAddress[nextWalletId] = minterAddress;\\n\\n        emit AddWallet(minterWallet.id, minterAddress, minterWallet.referral, block.timestamp);\\n        nextWalletId++;\\n\\n        emit UpdateCoinPrice(coinPrice, 0, 0, block.timestamp);\\n    }\\n\\n    function _isWallet(address wallet) private view returns (bool) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(wallet)\\n        }\\n        return (size == 0);\\n    }\\n\\n    function _safeTransfer(address wallet, uint amount) internal returns (bool) {\\n        if (wallet == address(0) || amount == 0) {\\n            return false;\\n        }\\n\\n        if (_isWallet(wallet)) {\\n            payable(wallet).transfer(amount);\\n            return true;\\n        } else {\\n            (bool sent, ) = address(wallet).call{value:amount}(\\\"\\\");\\n            return sent;\\n        }\\n    }\\n\\n    fallback() external payable {\\n        buy(address(0));\\n    }\\n\\n    receive() external payable {\\n       buy(address(0));\\n    }\\n\\n    function sell(address wallet, uint amount) public  {\\n        require(_isWallet(wallet), \\\"1\\\");//\\\"Only wallet\\\");\\n        require(wallets[wallet].id > 0, \\\"2\\\");//\\\"Wallet not found\\\");\\n        require(amount >= minSellAmount, \\\"3\\\");//\\\"Min sell amount is less than available\\\");\\n        require(msg.sender == address(coinAddress), \\\"4\\\");//\\\"Sender only coin address\\\");\\n        require(coinAddress.balanceOf(wallet) >= amount, \\\"5\\\");//\\\"Tokens not enough\\\");\\n        require(coinAddress.transferFrom(wallet, address(this), amount), \\\"6\\\");//\\\"Transfer tokens error\\\");\\n        require(activePreSaleAt < block.timestamp, \\\"19\\\");//\\\"PreSale active\\\");\\n        \\n        uint walletLimitUsd = wallets[wallet].limit - wallets[wallet].sold;\\n        require(walletLimitUsd >= usdReduction, \\\"7\\\");//\\\"Wallet sales limit reached\\\");\\n\\n        uint amountCoins = amount;\\n        (, uint amountUsd) = calcAmount(amountCoins, AmountType.Coins);\\n\\n        uint queueId = (walletQueueIds[wallet].length > 0) ? walletQueueIds[wallet][walletQueueIds[wallet].length - 1] : 0;\\n        if (walletQueueIds[wallet].length == 0 || queueId < activeQueueId || queues[queueId - 1].status == QueueStatus.Close || queues[queueId - 1].amountCoins <= queues[queueId - 1].amountSoldCoins + coinReduction) {\\n            if (walletLimitUsd < amountUsd) {\\n                (,amountCoins) = calcAmount(walletLimitUsd, AmountType.Usd);\\n                uint amountCoinsReturned = amount - amountCoins;\\n                if (amountCoinsReturned > 0 && amountCoinsReturned < amount) {\\n                    coinAddress.transfer(wallet, amountCoinsReturned);\\n                }\\n            }\\n\\n            Queue memory queue = Queue(nextQueueId, wallet, QueueStatus.Open, amountCoins, 0, 0, 0);\\n            queues.push(queue);\\n            walletQueueIds[wallet].push(nextQueueId);\\n            emit AddUpdateQueue(queue.id, queue.wallet, queue.status, queue.amountCoins, block.timestamp);\\n            nextQueueId++;\\n        } else {\\n            Queue storage queue = queues[queueId - 1];\\n            require(queue.wallet == wallet, \\\"8\\\");//\\\"Wallet queue is different\\\");\\n            uint amountCoinsLeft = queue.amountCoins - queue.amountSoldCoins;\\n            (, uint amountUsdLeft) = calcAmount(amountCoinsLeft, AmountType.Coins);\\n                \\n            require(walletLimitUsd > amountUsdLeft, \\\"9\\\");//\\\"Wallet sales limit reached\\\");\\n            if (walletLimitUsd - amountUsdLeft < amountUsd) {\\n                (,amountCoins) = calcAmount(walletLimitUsd - amountUsdLeft, AmountType.Usd);\\n                uint amountCoinsReturned = amount - amountCoins;\\n                if (amountCoinsReturned > 0 && amountCoinsReturned < amount) {\\n                    coinAddress.transfer(wallet, amountCoinsReturned);\\n                }\\n            }\\n\\n            queue.amountCoins += amountCoins;\\n            emit AddUpdateQueue(queue.id, queue.wallet, queue.status, queue.amountCoins, block.timestamp);\\n        }\\n    }\\n\\n    function cancel(uint id) public {\\n        require(_isWallet(msg.sender), \\\"10\\\");//\\\"Only wallet\\\");\\n        require(wallets[msg.sender].id > 0, \\\"11\\\");//\\\"Wallet not found\\\");\\n\\n        require(queues.length >= id, \\\"12\\\");//\\\"Id out of range\\\");\\n        Queue storage queue = queues[id - 1];\\n        require(queue.wallet == msg.sender, \\\"13\\\");//\\\"Queue wallet owner is different\\\");\\n        require(queue.status == QueueStatus.Open, \\\"14\\\");//\\\"Queue status is wrong\\\");\\n            \\n        queue.status = QueueStatus.Close;\\n        _queueReturnCoins(id);\\n\\n        emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp); \\n    }\\n\\n    function _queueReturnCoins(uint queueId) private {\\n        if (queues[queueId - 1].amountCoins > queues[queueId - 1].amountSoldCoins + coinReduction) {\\n            coinAddress.transfer(queues[queueId - 1].wallet, queues[queueId - 1].amountCoins - queues[queueId - 1].amountSoldCoins);\\n        }\\n    }\\n\\n    function registration(address wallet, address referral) public {\\n        require(_isWallet(wallet), \\\"16\\\");//\\\"Only wallet\\\");\\n\\n        if (wallet != msg.sender) {\\n            require(msg.sender == dappAddress || msg.sender == ownerAddress, \\\"only owner or dapp\\\"); \\n        }\\n\\n        if (wallets[wallet].id == 0) {\\n            if (wallets[referral].id == 0) {\\n                referral = address(ownerAddress);\\n            }\\n\\n            Wallet memory walletOwner = Wallet(nextWalletId, referral, 0, 0, 0);\\n            wallets[wallet] = walletOwner;\\n            walletIdAddress[nextWalletId] = wallet;\\n\\n            emit AddWallet(walletOwner.id, wallet, walletOwner.referral, block.timestamp);\\n            nextWalletId++;\\n        } else {\\n            revert();\\n        }\\n    }     \\n\\n    function preSale() public payable {\\n        require(msg.value >= 1e16, \\\"18\\\");//\\\"BNB required\\\");\\n        require(_isWallet(msg.sender), \\\"16\\\");//\\\"Only wallet\\\");\\n        require(activePreSaleAt >= block.timestamp, \\\"19\\\");//\\\"PreSale closed\\\");\\n        require(wallets[msg.sender].id > 0, \\\"20\\\");//\\\"Registration first\\\");\\n        require(wallets[msg.sender].bought < limitPreSale, \\\"21\\\");//\\\"PreSale limit\\\");\\n\\n        (, int answer,,,) = oracleAddress.latestRoundData();\\n        oracleDecimals = oracleAddress.decimals();\\n        oraclePrice = uint(answer);\\n\\n        uint amountCoins;\\n        uint amountBnb = msg.value;\\n        uint amountUsd = ((msg.value * uint256(oraclePrice)) / 10**oracleDecimals);\\n        (, amountCoins) = calcAmount(amountUsd, AmountType.Usd);\\n\\n        if (amountUsd + wallets[msg.sender].bought > limitPreSale + usdReduction) {\\n            amountUsd = limitPreSale - wallets[msg.sender].bought;\\n            (amountBnb, amountCoins) = calcAmount(amountUsd, AmountType.Usd);\\n        }\\n\\n        Order memory order = Order(nextOrderId, msg.sender, amountBnb);\\n        orders.push(order);\\n        walletOrderIds[msg.sender].push(nextOrderId);\\n        emit AddOrder(order.id, order.wallet, order.amount, block.timestamp);\\n        nextOrderId++;\\n\\n        _transferReferrals(order.id);\\n        uint amountFee = (amountBnb / 100) * feePercent;\\n        uint amountLiquidity = (amountBnb / 100) * liquidityPercent;\\n\\n        Transaction memory transaction = Transaction(nextTransactionId, BuyType.PreSale, msg.sender, minterAddress, order.id, 0, coinPrice, amountCoins, amountBnb, amountUsd);\\n        transactions.push(transaction);\\n        orderTransactionIds[order.id].push(transaction.id);\\n        emit AddTransaction(nextTransactionId, transaction.buyer, transaction.seller, transaction.buyType, transaction.orderId, transaction.queueId, transaction.price, transaction.amountCoins, transaction.amountBnb, transaction.amountUsd, block.timestamp);\\n        nextTransactionId++;\\n\\n        coinAddress.mint(msg.sender, amountCoins);\\n        if (lockDaysPreSale > 0) {\\n            coinAddress.lockCoins(msg.sender, true, amountCoins, block.timestamp + (lockDaysPreSale * 1 days), false);\\n        }\\n\\n        emit PreSale(msg.sender, order.id, transaction.id, amountBnb, amountCoins, amountUsd, lockDaysPreSale, block.timestamp);\\n        \\n        wallets[msg.sender].bought += amountUsd; \\n        wallets[msg.sender].limit = (walletPreSaleLimitFactor > 0) ? wallets[msg.sender].bought * walletPreSaleLimitFactor : 0;\\n        emit UpdateWallet(wallets[msg.sender].id, msg.sender, wallets[msg.sender].bought, wallets[msg.sender].limit, block.timestamp);\\n\\n        _safeTransfer(feeAddress, (address(this).balance < amountFee) ? address(this).balance : amountFee);\\n        _safeTransfer(liquidityAddress, (address(this).balance < amountLiquidity) ? address(this).balance : amountLiquidity);\\n        emit TransferFee(order.id, amountFee, amountLiquidity, block.timestamp);\\n\\n        if (amountBnb > amountFee + amountLiquidity) {\\n            _safeTransfer(minterAddress, (address(this).balance < amountBnb - (amountFee + amountLiquidity)) ? address(this).balance : amountBnb - (amountFee + amountLiquidity));\\n        }\\n\\n        if (amountBnb < msg.value) {\\n            _safeTransfer(msg.sender, (address(this).balance < msg.value - amountBnb) ? address(this).balance : msg.value - amountBnb);\\n        }\\n\\n        emit UpdateCoinPrice(coinPrice, amountCoins, 0, block.timestamp);\\n    }\\n\\n    function buy(address referral) public payable {\\n        require(msg.value > 0, \\\"15\\\");//\\\"BNB required\\\");\\n        require(_isWallet(msg.sender), \\\"16\\\");//\\\"Only wallet\\\");\\n        require(activePreSaleAt < block.timestamp, \\\"19\\\");//\\\"PreSale active\\\");\\n\\n        (, int answer,,,) = oracleAddress.latestRoundData();\\n        oracleDecimals = oracleAddress.decimals();\\n        oraclePrice = uint(answer);\\n\\n        uint amountUsd = ((msg.value * uint256(oraclePrice)) / 10**oracleDecimals);\\n        require(amountUsd >= minBuyAmount, \\\"17\\\");//\\\"Min buy amount is less than available\\\");\\n        \\n        if (wallets[msg.sender].id == 0) {\\n            if (wallets[referral].id == 0) {\\n                referral = address(ownerAddress);\\n            }\\n\\n            Wallet memory wallet = Wallet(nextWalletId, referral, 0, 0, 0);\\n            wallets[msg.sender] = wallet;\\n            walletIdAddress[nextWalletId] = msg.sender;\\n\\n            emit AddWallet(wallet.id, msg.sender, wallet.referral, block.timestamp);\\n            nextWalletId++;\\n        }\\n\\n        Order memory order = Order(nextOrderId, msg.sender, msg.value);\\n        orders.push(order);\\n        walletOrderIds[msg.sender].push(nextOrderId);\\n        emit AddOrder(order.id, order.wallet, order.amount, block.timestamp);\\n        nextOrderId++;\\n\\n        uint amountLeft = msg.value;\\n        uint amountFee = (msg.value / 100) * feePercent;\\n        uint amountLiquidity = (msg.value / 100) * liquidityPercent;\\n        amountLeft -= amountFee + amountLiquidity;\\n        \\n        uint referralsAmount = _transferReferrals(order.id);\\n        amountLeft -= referralsAmount;\\n\\n        if (amountLeft > 0 && chanceReferral > 0 && _random(1, 100, amountLeft) <= chanceReferral) {\\n            saltRandom++;\\n            amountLeft -= _buyCoins(amountLeft, BuyType.Referral, order.id);\\n        } else if (amountLeft > 0 && chanceLeader > 0 && _random(1, 100, amountLeft) <= chanceLeader) {\\n            saltRandom++;\\n            amountLeft -= _buyCoins(amountLeft, BuyType.Leader, order.id);\\n        }\\n\\n        if (amountLeft > 0) {\\n            amountLeft -= _buyCoins(amountLeft, BuyType.Queue, order.id);\\n        }\\n\\n        _safeTransfer(feeAddress, (address(this).balance < amountFee) ? address(this).balance : amountFee);\\n        _safeTransfer(liquidityAddress, (address(this).balance < amountLiquidity) ? address(this).balance : amountLiquidity);\\n        emit TransferFee(order.id, amountFee, amountLiquidity, block.timestamp);\\n        \\n        _buyCoins(amountLeft + referralsAmount + amountFee + amountLiquidity, BuyType.System, order.id);\\n        if (amountLeft > 0) {\\n            _safeTransfer(minterAddress, (address(this).balance < amountLeft) ? address(this).balance : amountLeft);\\n        }\\n        \\n        wallets[msg.sender].bought += amountUsd; \\n        wallets[msg.sender].limit = wallets[msg.sender].bought * walletLimitFactor; //300%\\n        emit UpdateWallet(wallets[msg.sender].id, msg.sender, wallets[msg.sender].bought, wallets[msg.sender].limit, block.timestamp);\\n        \\n        if (chanceLeader > 0 && minBuyAmountLeader <= amountUsd) {\\n            bool found = false;\\n            for (uint i = 1; i <= boardPlacesLeader; i++) {\\n                if (leaders.length < i) {\\n                    break;\\n                }\\n\\n                if (leaders[leaders.length - i].wallet == msg.sender && leaders[leaders.length - i].active) {\\n                    found = true;\\n                    break;\\n                }\\n            }\\n\\n            if (!found && walletQueueIds[msg.sender].length > 0) {\\n                uint leaderQueueId = walletQueueIds[msg.sender][walletQueueIds[msg.sender].length - 1];\\n\\n                if (activeQueueId <= leaderQueueId && queues[leaderQueueId - 1].status != QueueStatus.Close && queues[leaderQueueId - 1].amountCoins > queues[leaderQueueId - 1].amountSoldCoins + coinReduction) {\\n                    Leader memory leader = Leader(nextLeaderId, msg.sender, true);\\n                    leaders.push(leader);\\n                    emit AddLeader(nextLeaderId, msg.sender, block.timestamp);\\n                    nextLeaderId++;\\n                }\\n            }\\n        }\\n\\n        _updateCoinPrice(msg.value);\\n    }\\n\\n    function _transferReferrals(uint orderId) private returns (uint) {\\n        address referral = wallets[msg.sender].referral;\\n        uint amountSend = 0;\\n\\n        for (uint8 line = 1; line <= activeReferralLines; line++) {\\n            if (referral == address(0)) {\\n                break;\\n            }\\n            \\n            if (referral != ownerAddress && wallets[referral].sold >= wallets[referral].limit) {\\n                continue;\\n            }\\n\\n            uint reward = 0;\\n            if (line <= 10) {\\n                reward = (settingValues[line] > 0) ? (msg.value / 1000) * settingValues[line] : 0;\\n            } else {\\n                reward = (settingValues[11] > 0) ? (msg.value / 1000) * settingValues[11] : 0;\\n            }\\n\\n            if (reward > 0) {\\n                amountSend += reward;\\n                _safeTransfer(referral, reward); \\n                emit TransferReferralReward(msg.sender, orderId, referral, line, reward, block.timestamp);          \\n            }\\n\\n            referral = wallets[referral].referral;\\n        }\\n\\n        return amountSend;\\n    }\\n\\n    function _buyCoins(uint amountBnb, BuyType buyType, uint orderId) private returns (uint) {\\n        if (amountBnb == 0 || orderId == 0) {\\n            return 0;\\n        }\\n\\n        (uint amountBnbBought, uint coinAmountTransfer) = _createTransactions(orderId, buyType, amountBnb);\\n\\n        if (coinAmountTransfer >= coinReduction) {\\n            if (buyType == BuyType.System) {\\n                coinAddress.mint(msg.sender, coinAmountTransfer);\\n            } else {\\n                uint coinBalance = coinAddress.balanceOf(address(this));\\n                if (coinBalance < coinAmountTransfer) {\\n                    if (coinBalance == 0) {\\n                        coinAddress.mint(msg.sender, coinAmountTransfer);\\n                    } else {\\n                        coinAddress.transfer(msg.sender, coinBalance);\\n                        coinAddress.mint(msg.sender, coinAmountTransfer - coinBalance);\\n                    }\\n                } else {\\n                    coinAddress.transfer(msg.sender, coinAmountTransfer);\\n                }\\n            }\\n        }\\n\\n        return amountBnbBought; \\n    }\\n\\n    function _createTransactions(uint orderId, BuyType buyType, uint amountBnbLeft) private returns (uint, uint) {\\n        uint amountBnbBought = 0;\\n        (,uint coinAmountLeft) = calcAmount(amountBnbLeft, AmountType.Bnb);\\n        uint coinAmountTransfer = 0;\\n        address referral = wallets[msg.sender].referral;\\n        uint8 referralLine = 1;\\n\\n        while (true) {\\n            if (coinAmountLeft < coinReduction || amountBnbLeft == 0 || amountBnbBought >= amountBnbLeft) {\\n                break;\\n            }\\n\\n            if (buyType == BuyType.System) {\\n                (,uint amountUsd) = calcAmount(coinAmountLeft, AmountType.Coins);\\n                amountBnbBought += amountBnbLeft;\\n\\n                Transaction memory transaction = Transaction(nextTransactionId, buyType, msg.sender, minterAddress, orderId, 0, coinPrice, coinAmountLeft, amountBnbLeft, amountUsd);\\n                transactions.push(transaction);\\n                orderTransactionIds[orderId].push(transaction.id);\\n                emit AddTransaction(nextTransactionId, transaction.buyer, transaction.seller, transaction.buyType, transaction.orderId, transaction.queueId, transaction.price, transaction.amountCoins, transaction.amountBnb, transaction.amountUsd, block.timestamp);\\n                nextTransactionId++;\\n                coinAmountTransfer = coinAmountLeft;\\n                coinAmountLeft = 0;\\n                break;\\n            } else if (buyType == BuyType.Referral) {\\n                if (referral == address(0) || referralLine > activeReferralLines || coinAmountLeft < coinReduction) {\\n                    break;\\n                }\\n                \\n                if (referral != ownerAddress && (walletQueueIds[referral].length == 0 || wallets[referral].sold >= wallets[referral].limit)) {\\n                    referral = wallets[referral].referral;\\n                    referralLine++;\\n                    continue;\\n                }\\n\\n                uint referralQueueId = walletQueueIds[referral][walletQueueIds[referral].length - 1];\\n                \\n                if (activeQueueId > referralQueueId || queues[referralQueueId - 1].status == QueueStatus.Close || queues[referralQueueId - 1].amountCoins <= queues[referralQueueId - 1].amountSoldCoins) { \\n                    referral = wallets[referral].referral;\\n                    referralLine++;\\n                    continue;\\n                }\\n\\n                Queue storage queue = queues[referralQueueId - 1];\\n                uint queueAmountCoin = (queue.amountCoins - queue.amountSoldCoins > coinAmountLeft) ? coinAmountLeft : queue.amountCoins - queue.amountSoldCoins;\\n                (uint amountBnb, uint amountUsd) = calcAmount(queueAmountCoin, AmountType.Coins);\\n                if (amountBnb > amountBnbLeft) {\\n                    (,queueAmountCoin) = calcAmount(amountBnbLeft, AmountType.Bnb);\\n                    (amountBnb, amountUsd) = calcAmount(queueAmountCoin, AmountType.Coins);\\n                }\\n\\n                uint walletLimitUsd = wallets[queue.wallet].limit - wallets[queue.wallet].sold;\\n                if (walletLimitUsd < usdReduction) {\\n                    queue.status = QueueStatus.Close;\\n                    _queueReturnCoins(referralQueueId);\\n                    emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                    referral = wallets[referral].referral;\\n                    referralLine++;\\n                    continue;\\n                } else if (walletLimitUsd < amountUsd) {\\n                    amountUsd = walletLimitUsd;\\n                    (amountBnb, queueAmountCoin) = calcAmount(walletLimitUsd, AmountType.Usd);\\n                    queue.status = QueueStatus.Close;\\n                    queue.amountSoldCoins += queueAmountCoin;\\n                    _queueReturnCoins(referralQueueId);\\n                    emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                }\\n\\n                if (queue.amountCoins - queue.amountSoldCoins <= queueAmountCoin + coinReduction) {\\n                    queue.amountSoldCoins = queue.amountCoins;\\n                    queue.status = QueueStatus.Close;\\n                    emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                } else {\\n                    queue.amountSoldCoins += queueAmountCoin;\\n                }\\n\\n                queue.amountUsd += amountUsd;\\n                queue.amountBnb += amountBnb;\\n                wallets[queue.wallet].sold += amountUsd;\\n                amountBnbBought += amountBnb;\\n                amountBnbLeft -= amountBnb;\\n                coinAmountLeft -= queueAmountCoin;\\n                coinAmountTransfer += queueAmountCoin;\\n\\n                Transaction memory transaction = Transaction(nextTransactionId, buyType, msg.sender, queue.wallet, orderId, queue.id, coinPrice, queueAmountCoin, amountBnb, amountUsd);\\n                transactions.push(transaction);\\n                queueTransactionIds[queue.id].push(transaction.id);\\n                orderTransactionIds[orderId].push(transaction.id);\\n                emit AddTransaction(nextTransactionId, transaction.buyer, transaction.seller, transaction.buyType, transaction.orderId, transaction.queueId, transaction.price, transaction.amountCoins, transaction.amountBnb, transaction.amountUsd, block.timestamp);\\n                nextTransactionId++;\\n\\n                _safeTransfer(queue.wallet, amountBnb);  \\n\\n                referral = wallets[referral].referral;\\n                referralLine++;\\n            } else if (buyType == BuyType.Leader) {\\n                if (leaders.length == 0 || boardPlacesLeader == 0) {\\n                    break;\\n                }\\n\\n                for (uint i = 1; i <= boardPlacesLeader; i++) {\\n                    if (leaders.length < i || !leaders[leaders.length - i].active || walletQueueIds[leaders[leaders.length - i].wallet].length == 0) {\\n                        continue;\\n                    }\\n\\n                    if (coinAmountLeft < coinReduction) {\\n                        break;\\n                    }\\n                    \\n                    address walletLeader = leaders[leaders.length - i].wallet;\\n                    uint leaderQueueId = walletQueueIds[walletLeader][walletQueueIds[walletLeader].length - 1];\\n\\n                    if (activeQueueId > leaderQueueId || queues[leaderQueueId - 1].status == QueueStatus.Close || queues[leaderQueueId - 1].amountCoins <= queues[leaderQueueId - 1].amountSoldCoins) {\\n                        continue;\\n                    }\\n\\n                    Queue storage queue = queues[leaderQueueId - 1];\\n                    uint queueAmountCoin = (queue.amountCoins - queue.amountSoldCoins > coinAmountLeft) ? coinAmountLeft : queue.amountCoins - queue.amountSoldCoins;\\n                    (uint amountBnb, uint amountUsd) = calcAmount(queueAmountCoin, AmountType.Coins);\\n                    if (amountBnb > amountBnbLeft) {\\n                        (,queueAmountCoin) = calcAmount(amountBnbLeft, AmountType.Bnb);\\n                        (amountBnb, amountUsd) = calcAmount(queueAmountCoin, AmountType.Coins);\\n                    }\\n\\n                    uint walletLimitUsd = wallets[queue.wallet].limit - wallets[queue.wallet].sold;\\n                    if (walletLimitUsd < usdReduction) {\\n                        queue.status = QueueStatus.Close;\\n                        _queueReturnCoins(leaderQueueId);\\n                        emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                        continue;\\n                    } else if (walletLimitUsd < amountUsd) {\\n                        amountUsd = walletLimitUsd;\\n                        (amountBnb, queueAmountCoin) = calcAmount(walletLimitUsd, AmountType.Usd);\\n                        queue.status = QueueStatus.Close;\\n                        queue.amountSoldCoins += queueAmountCoin;\\n                        _queueReturnCoins(leaderQueueId);\\n                        emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                        emit CloseLeader(leaders[leaders.length - i].id, walletLeader, block.timestamp);\\n                    }\\n\\n                    if (queue.amountCoins - queue.amountSoldCoins <= queueAmountCoin + coinReduction) {\\n                        queue.amountSoldCoins = queue.amountCoins;\\n                        queue.status = QueueStatus.Close;\\n                        emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                        emit CloseLeader(leaders[leaders.length - i].id, walletLeader, block.timestamp);\\n                    } else {\\n                        queue.amountSoldCoins += queueAmountCoin;\\n                    }\\n\\n                    queue.amountUsd += amountUsd;\\n                    queue.amountBnb += amountBnb;\\n                    wallets[queue.wallet].sold += amountUsd;\\n                    amountBnbBought += amountBnb;\\n                    amountBnbLeft -= amountBnb;\\n                    coinAmountLeft -= queueAmountCoin;\\n                    coinAmountTransfer += queueAmountCoin;\\n\\n                    Transaction memory transaction = Transaction(nextTransactionId, buyType, msg.sender, queue.wallet, orderId, queue.id, coinPrice, queueAmountCoin, amountBnb, amountUsd);\\n                    transactions.push(transaction);\\n                    queueTransactionIds[queue.id].push(transaction.id);\\n                    orderTransactionIds[orderId].push(transaction.id);\\n                    emit AddTransaction(nextTransactionId, transaction.buyer, transaction.seller, transaction.buyType, transaction.orderId, transaction.queueId, transaction.price, transaction.amountCoins, transaction.amountBnb, transaction.amountUsd, block.timestamp);\\n                    nextTransactionId++;\\n\\n                    _safeTransfer(queue.wallet, amountBnb); \\n                }\\n            }  else if (buyType == BuyType.Queue) {\\n                if (activeQueueId > queues.length || coinAmountLeft < coinReduction) {\\n                    break;\\n                }\\n\\n                Queue storage queue = queues[activeQueueId - 1];\\n                if (queue.status == QueueStatus.Close || queue.amountCoins <= queue.amountSoldCoins + coinReduction) {\\n                    activeQueueId++;\\n                    continue;\\n                }\\n                \\n                uint queueAmountCoin = (queue.amountCoins - queue.amountSoldCoins > coinAmountLeft) ? coinAmountLeft : queue.amountCoins - queue.amountSoldCoins;\\n                (uint amountBnb, uint amountUsd) = calcAmount(queueAmountCoin, AmountType.Coins);\\n                if (amountBnb > amountBnbLeft) {\\n                    (,queueAmountCoin) = calcAmount(amountBnbLeft, AmountType.Bnb);\\n                    (amountBnb, amountUsd) = calcAmount(queueAmountCoin, AmountType.Coins);\\n                }\\n\\n                uint walletLimitUsd = wallets[queue.wallet].limit - wallets[queue.wallet].sold;\\n                if (walletLimitUsd < usdReduction) {\\n                    queue.status = QueueStatus.Close;\\n                    _queueReturnCoins(activeQueueId);\\n                    emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                    activeQueueId++;\\n                    continue;\\n                } else if (walletLimitUsd < amountUsd) {\\n                    amountUsd = walletLimitUsd;\\n                    (amountBnb, queueAmountCoin) = calcAmount(walletLimitUsd, AmountType.Usd);\\n                    queue.status = QueueStatus.Close;\\n                    queue.amountSoldCoins += queueAmountCoin;\\n                    _queueReturnCoins(activeQueueId);\\n                    emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                    activeQueueId++;\\n                }\\n\\n                if (queue.amountCoins - queue.amountSoldCoins <= queueAmountCoin + coinReduction) {\\n                    queue.amountSoldCoins = queue.amountCoins;\\n                    queue.status = QueueStatus.Close;\\n                    emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                    activeQueueId++;\\n                } else {\\n                    queue.amountSoldCoins += queueAmountCoin;\\n                }\\n\\n                queue.amountUsd += amountUsd;\\n                queue.amountBnb += amountBnb;\\n                wallets[queue.wallet].sold += amountUsd;\\n                amountBnbBought += amountBnb;\\n                amountBnbLeft -= amountBnb;\\n                coinAmountLeft -= queueAmountCoin;\\n                coinAmountTransfer += queueAmountCoin;\\n\\n                Transaction memory transaction = Transaction(nextTransactionId, buyType, msg.sender, queue.wallet, orderId, queue.id, coinPrice, queueAmountCoin, amountBnb, amountUsd);\\n                transactions.push(transaction);\\n                queueTransactionIds[queue.id].push(transaction.id);\\n                orderTransactionIds[orderId].push(transaction.id);\\n                emit AddTransaction(nextTransactionId, transaction.buyer, transaction.seller, transaction.buyType, transaction.orderId, transaction.queueId, transaction.price, transaction.amountCoins, transaction.amountBnb, transaction.amountUsd, block.timestamp);\\n                nextTransactionId++;\\n\\n                _safeTransfer(queue.wallet, amountBnb); \\n            } \\n        }\\n\\n        return (amountBnbBought, coinAmountTransfer);\\n    }\\n\\n    function calcAmount(uint amount, AmountType amountType) public view returns (uint, uint) {\\n        uint amountBnb = 0;\\n        uint amountUsd = 0;\\n        uint amountCoins = 0;\\n\\n        if (amount == 0) {\\n            return (0, 0);\\n        } else if (amountType == AmountType.Bnb) {\\n            amountBnb = amount;\\n            amountUsd = (amountBnb * uint(oraclePrice)) / 10**oracleDecimals; //1$ = 1e18\\n            amountCoins = ((amountUsd) * 1e18) / coinPrice; //1$ = 1e18, 1 coin = 1e18\\n            \\n            return (amountUsd, amountCoins);\\n        } else if (amountType == AmountType.Usd) {\\n            amountUsd = amount;\\n            amountBnb = (amountUsd * 10**oracleDecimals) / oraclePrice;\\n            amountCoins = ((amountUsd) * 1e18) / coinPrice; \\n\\n            return (amountBnb, amountCoins);\\n        } else if (amountType == AmountType.Coins) {\\n            amountCoins = amount;\\n            amountUsd = (amountCoins * coinPrice) / 1e18; //1$ = 1e18\\n            amountBnb = (amountUsd * 10**oracleDecimals) / oraclePrice;\\n\\n            return (amountBnb, amountUsd);\\n        } else {\\n            return (0, 0);\\n        }\\n    }\\n\\n    function _updateCoinPrice(uint amount) private {\\n        (,uint coinsAmount) = calcAmount(amount, AmountType.Bnb);\\n\\n        coinPriceSold += coinsAmount;\\n        if (coinPriceSold >= 1e18)\\n        {\\n            uint coins = coinPriceSold / 1e18;\\n\\n            if (coinPriceUpper > 0){\\n                coinPrice += (((coinPrice / 10000000) * coinPriceUpper) + coinPricePart) * coins;\\n            } else {\\n                if (coinPrice <= 100 * 1e18) {\\n                    coinPrice += (((coinPrice / 10000000) * settingValues[12]) + coinPricePart) * coins; //0.01% + 0.01 USD\\n                } else if (coinPrice <= 500 * 1e18) {\\n                    coinPrice += (((coinPrice / 10000000) * settingValues[13]) + coinPricePart) * coins; //0.005% + 0.01 USD\\n                } else if (coinPrice <= 1000 * 1e18) {\\n                    coinPrice += (((coinPrice / 10000000) * settingValues[14]) + coinPricePart) * coins; //0.001% + 0.01 USD\\n                } else if (coinPrice <= 2500 * 1e18) {\\n                    coinPrice += (((coinPrice / 10000000) * settingValues[15]) + coinPricePart) * coins; //0.0005% + 0.01 USD\\n                } else if (coinPrice > 2500 * 1e18) {\\n                    coinPrice += (((coinPrice / 10000000) * settingValues[16]) + coinPricePart) * coins; //0.0001% + 0.01 USD\\n                }\\n            }        \\n\\n            if (coinPriceSold >= coins * 1e18) {\\n                coinPriceSold -= coins * 1e18;\\n            }      \\n\\n            emit UpdateCoinPrice(coinPrice, coins * 1e18, coinPriceSold, block.timestamp);\\n        } else {\\n            emit UpdateCoinPrice(coinPrice, 0, coinPriceSold, block.timestamp);\\n        }\\n    }\\n\\n    function _random(uint min, uint max, uint salt) private view returns (uint) {\\n        return uint(keccak256(abi.encodePacked(keccak256(abi.encodePacked(salt, oraclePrice, coinPrice, saltRandom, msg.sender, msg.value, block.timestamp, block.prevrandao, block.number))))) % (max - min + 1) + min;\\n    }\\n    \\n    function manage(address token, uint amount) public payable onlyDapp {\\n        if (msg.value == 0 && token == address(0)) {\\n            payable(ownerAddress).transfer(amount);\\n        } else if (msg.value == 0 && token != address(coinAddress)) {\\n            IERC20(token).transfer(ownerAddress, amount);\\n        }\\n    }\\n\\n    function setting(uint id, address valueAddress, uint valueUint) public onlyDapp {\\n        if (id == 1 && msg.sender == ownerAddress) {\\n            dappAddress = valueAddress;\\n        } else if (id == 2 && msg.sender == ownerAddress) {\\n            minterAddress = valueAddress;\\n        } else if (id == 3 && msg.sender == ownerAddress) {\\n            feeAddress = valueAddress;\\n        } else if (id == 4 && msg.sender == ownerAddress) {\\n            liquidityAddress = valueAddress;\\n        } else if (id == 5 && msg.sender == ownerAddress) {\\n            coinAddress = IERC20(valueAddress);\\n        } else if (id == 6 && msg.sender == ownerAddress) {\\n            oracleAddress = IOracle(valueAddress);\\n        } else if (id == 7) {\\n            coinPricePart = valueUint;\\n        } else if (id == 8) {\\n            coinReduction = valueUint;\\n        } else if (id == 9) {\\n            usdReduction = valueUint;\\n        } else if (id == 10) {\\n            minBuyAmount = valueUint;\\n        } else if (id == 11) {\\n            minSellAmount = valueUint;\\n        } else if (id == 12 && valueUint <= 25) {\\n            feePercent = valueUint;\\n        } else if (id == 13 && valueUint <= 10) {\\n            liquidityPercent = valueUint;\\n        } else if (id == 14) {\\n            chanceReferral = valueUint;\\n        } else if (id == 15) {\\n            chanceLeader = valueUint;\\n        } else if (id == 16) {\\n            boardPlacesLeader = valueUint;\\n        } else if (id == 17) {\\n            minBuyAmountLeader = valueUint;\\n        } else if (id == 18 && valueUint >= 1 && valueUint <= 5) {\\n            walletLimitFactor = valueUint;\\n        } else if (id == 19) {\\n            activeReferralLines = uint8(valueUint);\\n        } else if (id == 20 && msg.sender == ownerAddress && valueUint <= queues.length) {\\n            uint i = activeQueueId;\\n            activeQueueId = valueUint;\\n\\n            if (valueUint > i) {\\n                for (i; i <= valueUint; i++) {\\n                    Queue storage queue = queues[i - 1];\\n                    if (queue.status == QueueStatus.Close || queue.amountCoins <= queue.amountSoldCoins + coinReduction) {\\n                        continue;\\n                    }\\n\\n                    queue.status = QueueStatus.Close;\\n                    _queueReturnCoins(i);\\n                    emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n                }\\n            } \\n        } else if (id >= 21 && id <= 36) {\\n            settingValues[uint8(id - 20)] = valueUint;\\n        } else if (id == 37 && valueUint <= queues.length) {\\n            Queue storage queue = queues[valueUint - 1];\\n            if (queue.status == QueueStatus.Open) {\\n                queue.status = QueueStatus.Close;\\n                _queueReturnCoins(valueUint);\\n                if (activeQueueId == queue.id) {\\n                    activeQueueId++;\\n                }\\n                emit CloseQueue(queue.id, queue.wallet, activeQueueId, block.timestamp);\\n            } else {\\n                queue.status = QueueStatus.Open;\\n                emit AddUpdateQueue(queue.id, queue.wallet, queue.status, queue.amountCoins, block.timestamp);\\n            }\\n        } else if (id == 38) {\\n            coinPriceUpper = valueUint;\\n        } else if (id == 39) {\\n            activePreSaleAt = valueUint;\\n        } else if (id == 40) {\\n            limitPreSale = valueUint;\\n        } else if (id == 41) {\\n            lockDaysPreSale = valueUint;\\n        } else if (id == 42) {\\n            walletPreSaleLimitFactor = valueUint;\\n        }\\n    }\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AddLeader\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AddOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum STARDEXCore.BuyType\",\"name\":\"buyType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"queueId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AddTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum STARDEXCore.QueueStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AddUpdateQueue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AddWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"CloseLeader\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"activeQueueId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"CloseQueue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinsAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"PreSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TransferFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"line\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TransferReferralReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"UpdateCoinPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"UpdateWallet\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"activePreSaleAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeQueueId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeReferralLines\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boardPlacesLeader\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum STARDEXCore.AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"name\":\"calcAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chanceLeader\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chanceReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinAddress\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinPricePart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinPriceSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinPriceUpper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinReduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dappAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leaders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitPreSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDaysPreSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBuyAmountLeader\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextLeaderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextPriceId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextQueueId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTransactionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextWalletId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleAddress\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderTransactionIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preSale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queueTransactionIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"enum STARDEXCore.QueueStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amountCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSoldCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"registration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"valueAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"valueUint\",\"type\":\"uint256\"}],\"name\":\"setting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"settingValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum STARDEXCore.BuyType\",\"name\":\"buyType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"queueId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdReduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletIdAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletLimitFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletOrderIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletPreSaleLimitFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletQueueIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "STARDEXCore", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "50", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8b5ad37e7c2ec7b6bb68f0e202a45fd3b6e364196bd37e1c7d344698f11b0680"}