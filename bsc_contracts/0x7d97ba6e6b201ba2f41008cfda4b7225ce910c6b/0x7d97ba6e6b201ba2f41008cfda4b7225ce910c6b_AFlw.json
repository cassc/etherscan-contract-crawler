{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-06-06\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\ninterface IPancakeRouter02 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,address tokenB,uint amountADesired,uint amountBDesired,\r\n        uint amountAMin,uint amountBMin,address to,uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n   \r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    // Multiplication calculation\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // If a is 0, the return product is 0.\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        // Multiplication calculation\r\n        c = a * b;\r\n        //Before returning, you need to check that the result does not overflow through division. Because after overflow, the division formula will not be equal.\r\n        //This also explains why a==0 should be determined separately, because in division, a cannot be used as a divisor if it is 0.\r\n        //If we don't judge b above, we can judge one more, which will increase the amount of calculation.\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    // Division calculation\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        // Now when the divisor is 0, solidity will automatically throw an exception\r\n        // There will be no integer overflow exception in division calculation\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    // Subtractive calculation\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Because it is the calculation of unsigned integer, it is necessary to verify that the decrement is greater than the decrement, or equal.\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    // Additive calculation\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        // C is the sum of a and b. If overflow occurs, c will become a small number. At this time, verify whether c is larger than a or equal (when b is 0).\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function getLp(address tokenA) external view returns (address lp);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface PB {\r\n    function changeBanlance(address token, address userAddress,uint amountIn) external;\r\n}\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * The default value of {decimals} is 18. To change this, you should override\r\n * this function so it returns a different value.\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\n\r\ncontract AIncome  {\r\n    using SafeMath for uint;\r\n    mapping(uint8 => address) public _owners;\r\n    mapping(address => bool) public whitelist;\r\n    /**\r\n     * \u53ea\u6709\u7ba1\u7406\u5458\u53ef\u4ee5\u64cd\u4f5c\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owners[0] , \"nodata\");\r\n        _;\r\n    }\r\n    modifier onlyWhitelisted() {\r\n        require(whitelist[msg.sender],\"no white\");\r\n        _;\r\n    }\r\n    constructor(address sender,address father) public {\r\n        _owners[0] = sender;\r\n        //\u9886\u53d6\u5408\u7ea6\u548c\u7ba1\u7406\u90fd\u662f\u6536\u76ca\u5408\u7ea6\u7684\u767d\u540d\u5355\r\n        whitelist[father] = true;\r\n    }\r\n    function toOwner(address to) public onlyOwner{\r\n        _owners[0] = to;\r\n    }\r\n\r\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\r\n        if (!whitelist[addr]) {\r\n            whitelist[addr] = true;\r\n            success = true;\r\n        }\r\n    }\r\n    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\r\n        if (whitelist[addr]) {\r\n            whitelist[addr] = false;\r\n            success = true;\r\n        }\r\n    }\r\n    function changeBanlance(address token, address userAddress,uint amountIn) onlyWhitelisted external virtual{\r\n        if (token == address(0)) {\r\n            payable(userAddress).transfer(amountIn);\r\n        }else {\r\n            IERC20(token).transfer(userAddress, amountIn);\r\n        }\r\n    }\r\n}\r\n\r\ncontract AFlw {\r\n    using SafeMath for uint;\r\n    address public _router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    address public usdtToken = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public bToken;\r\n    uint256 public smallUsdtPrice = 500e18;\r\n    uint256 public middleUsdtPrice = 1000e18;\r\n    uint256 public bigUsdtPrice = 3000e18;\r\n    address public _to;//\u8fd0\u8425\r\n    address public _to1;//\u63a7\u76d8\r\n    address public _dead;\r\n    address public k;//\u6536\u76ca\u5408\u7ea6\r\n    mapping(address => uint256) public lever;//\u5f53\u524d\u7b49\u7ea7\r\n    mapping(address => mapping(uint256 => uint256)) public father_lever;//\u4e0b\u9762\u6709\u591a\u5c11\u4e2a\u7b49\u7ea7\r\n    mapping(address => mapping(uint256 => MachinePledge)) public user_machines;\r\n    mapping(address=>address)public father1;//\u4e0a\u7ea7\u662f\u8c01\r\n    mapping(address=>address)public father2;//\u4e0a\u7ea7\u7684\u4e0a\u7ea7\u662f\u8c01\r\n    mapping(address=>uint)public father_people1;//\u56e2\u961f\u4eba\u65701\r\n    mapping(address=>uint)public father_people2;//\u56e2\u961f\u4eba\u65702\r\n    mapping(address => mapping(uint256 => address)) public father_users1;\r\n    mapping(address => mapping(uint256 => address)) public father_users2;\r\n    mapping(uint8 => address) public _owners;\r\n\r\n    mapping(address => uint256) public buyNumber;//\u8d2d\u4e70\u91d1\u989d\r\n\r\n    //500 126\r\n    struct MachinePledge {\r\n        uint256 amount; //\u8d28\u62bc\u6570\u91cf\r\n        uint256 allamount; //\u8d28\u62bc\u6570\u91cf\r\n        uint256 releasedAmount;//\u5df2\u9886\u7684\u6570\u91cf\r\n        uint256 useAmount;//\u8fd8\u6709\u591a\u5c11\u6ca1\u6709\u9886\u53d6\r\n        uint256 releasedTokenAmount;//\u5df2\u9886\u7684\u6570\u91cftoken\r\n        uint256 buytime;\r\n    }\r\n\r\n    constructor() {\r\n        _owners[0] = msg.sender;\r\n        _dead = 0x000000000000000000000000000000000000dEaD;\r\n        AIncome cincome = new AIncome(msg.sender,address(this));\r\n        k = address(cincome);\r\n\r\n        _to = 0xd2d100CD77B16c928f543c796B6c1130925b65f0;\r\n        _to1= 0xfd4Ce9eED33a965194BCE6e09e6D6DF4F9D77459;\r\n        bToken = 0x06e8e83D6F816333D77C4703eC27Bd7896a11748;\r\n        IERC20(bToken).approve(_router, 10000000000e18);\r\n        IERC20(usdtToken).approve(_router, 9 * 10000000000e18);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owners[0] , \"nodata\");\r\n        _;\r\n    }\r\n    function toOwner(address to) public onlyOwner{\r\n        _owners[0] = to;\r\n    }\r\n    function setToken(address token,address setusdtToken) public onlyOwner{\r\n        bToken = token;\r\n        usdtToken = setusdtToken;\r\n        IERC20(bToken).approve(_router, 10000000000e18);\r\n        IERC20(usdtToken).approve(_router, 9 * 10000000000e18);\r\n    }\r\n    function setTo(address to,address to1,address dead) public onlyOwner{\r\n        _to = to;\r\n        _to1 = to1;\r\n        _dead =dead;\r\n    }\r\n    function changeBanlance(address token, address userAddress,uint amountIn)  external onlyOwner virtual{\r\n        if (token == address(0)) {\r\n            payable(userAddress).transfer(amountIn);\r\n        }else {\r\n            IERC20(token).transfer(userAddress, amountIn);\r\n        }\r\n    }\r\n\r\n    function bind(address invite) external returns(bool){\r\n        require(father1[msg.sender] == address(0) && msg.sender != invite && invite != address(0),\"bind\");\r\n        father1[msg.sender] = invite;\r\n        father_people1[invite] = father_people1[invite]+=1;\r\n        father_users1[invite][father_people1[invite]] = msg.sender;\r\n        //\u5224\u65ad\u4e0a\u7ea7\u7684\u4e0a\u7ea7\r\n        if(father1[invite]!=address(0)){\r\n            father2[msg.sender] = father1[invite];\r\n            father_people2[father1[invite]] = father_people2[father1[invite]]+=1;\r\n            father_users2[father1[invite]][father_people2[father1[invite]]] = msg.sender;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    \r\n    //\u4e70\u77ff\u673a\r\n    function buy(uint256 typeid)external virtual{\r\n        uint balance = IERC20(usdtToken).balanceOf(msg.sender);\r\n        uint256 usdtPrice;\r\n        uint256 allusdtPirce;\r\n        if(typeid ==1){\r\n            usdtPrice = smallUsdtPrice;\r\n            allusdtPirce = (usdtPrice.div(126)).mul(365);\r\n        }else if(typeid == 2){\r\n            usdtPrice = middleUsdtPrice;\r\n            allusdtPirce = (usdtPrice.div(108)).mul(365);\r\n        }else{\r\n            usdtPrice = bigUsdtPrice;\r\n            allusdtPirce = (usdtPrice.div(99)).mul(365);\r\n        }\r\n        require(balance>=usdtPrice,\"balance error\");\r\n        require(IERC20(usdtToken).allowance(msg.sender,address(this))>balance,\"not approve\");\r\n        IERC20(usdtToken).transferFrom(msg.sender,address(this),usdtPrice);\r\n        //\u8fdb\u5e95\u6c60\r\n        (uint reserveIn, uint reserveOut,) =   IPancakeRouter02(IERC20(bToken).getLp(usdtToken)).getReserves();\r\n        uint lptokenprice = IPancakeRouter02(_router).quote(usdtPrice.mul(34).div(100),reserveOut,reserveIn); \r\n        IPancakeRouter02(_router).addLiquidity(usdtToken,bToken, usdtPrice.mul(34).div(100), lptokenprice,  usdtPrice.mul(34).div(100),lptokenprice, _dead, block.timestamp);\r\n        //\u8fdb\u62c9\u76d8\r\n        IERC20(usdtToken).transfer(_to1,usdtPrice.mul(20).div(100));\r\n\r\n        //\u8fdb\u52a8\u6001\u5956\u52b1\r\n        buyNumber[msg.sender] = buyNumber[msg.sender].add(usdtPrice);\r\n        //\u53d1\u653e\u77ff\u673a\r\n        user_machines[msg.sender][typeid].amount = usdtPrice;\r\n        user_machines[msg.sender][typeid].allamount = allusdtPirce;\r\n        user_machines[msg.sender][typeid].useAmount = allusdtPirce;\r\n        user_machines[msg.sender][typeid].buytime = block.timestamp;\r\n \r\n       _tim1(usdtPrice,reserveOut,reserveIn);\r\n    }\r\n\r\n\r\n    function _tim1(uint usdtPrice,uint usdtReserve,uint tokenReserve) private {\r\n        uint256 per =46;\r\n        //\u6211\u7684\u4e0a\u7ea7\r\n        address father1_address = father1[msg.sender];\r\n        //\u6211\u7684\u4e0a\u4e0a\u7ea7\r\n        address father2_address = father2[msg.sender];\r\n        //\u6211\u7684\u5f53\u524d\u4e34\u65f6\u7b49\u7ea7\r\n        uint temp_lever =lever[msg.sender];\r\n\r\n        //\u5982\u679c\u662f\u6211\u81ea\u5df1\u8d2d\u4e70\u7684\u8bdd \u5e76\u6211\u7684\u5f53\u524d\u7b49\u7ea7\u4e0d\u662f5\u7ea7\u7684\u8bdd\r\n        if(buyNumber[msg.sender]>=3000e18 && lever[msg.sender]!=5 ){\r\n            if(lever[msg.sender] ==0){\r\n                temp_lever = 1;\r\n                //\u5224\u65ad\u6211\u7684\u9080\u8bf7\u6709\u51e0\u4e2a\u7b49\u7ea7\r\n            }else if(lever[msg.sender] <=1 && father_lever[msg.sender][1] >=1){\r\n                temp_lever= 2;\r\n            }else if(lever[msg.sender] <=2 && father_lever[msg.sender][2] >=2){\r\n                temp_lever= 3;\r\n            }else if(lever[msg.sender] <=3 && father_lever[msg.sender][3] >=2){\r\n                temp_lever= 4;\r\n            }else if(lever[msg.sender] <=4 && father_lever[msg.sender][4] >=2){\r\n                temp_lever = 5;\r\n            }\r\n        }\r\n        //\u66f4\u65b0\u7b49\u7ea7\r\n        if(temp_lever!=lever[msg.sender]){\r\n            lever[msg.sender] =  temp_lever;\r\n            //\u7ed9\u4e0a\u7ea7\u7b49\u7ea7\u6dfb\u52a0\u6570\u91cf\r\n            if(father1_address!=address(0)){\r\n                father_lever[father1_address][temp_lever] = father_lever[father1_address][temp_lever].add(1);\r\n            }\r\n        }\r\n        uint256 perNumber1;\r\n        uint256 per1 =11;\r\n        //\u5224\u65ad\u662f\u5426\u6709\u4e0a\u7ea7\u76f4\u63a8\u5956\u52b1\r\n        if(father1_address!=address(0)){\r\n            trans(father1_address,usdtPrice,10,usdtReserve,tokenReserve);    \r\n            per = per.sub(10);\r\n            buyNumber[father1_address] =buyNumber[father1_address].add(usdtPrice);\r\n            //\u540c\u65f6\u5224\u65ad\u4e0a\u7ea7\u7b49\u7ea7\u9700\u4e0d\u9700\u8981\u5347\u7ea7\r\n            uint temp_lever1 =lever[father1_address];\r\n\r\n            if(buyNumber[father1_address]>=3000e18 && lever[father1_address]!=5 ){\r\n                if(lever[father1_address] ==0){\r\n                    temp_lever1 = 1;\r\n                }else if(lever[father1_address] <=1 && father_lever[father1_address][1] >=1){\r\n                    temp_lever1= 2;\r\n                }else if(lever[father1_address] <=2 && father_lever[father1_address][2] >=2){\r\n                    temp_lever1= 3;\r\n                }else if(lever[father1_address] <=3 && father_lever[father1_address][3] >=2){\r\n                    temp_lever1= 4;\r\n                }else if(lever[father1_address] <=4 && father_lever[father1_address][4] >=2){\r\n                    temp_lever1 = 5;\r\n                }  \r\n            }\r\n            if(temp_lever1!=lever[father1_address]){\r\n                lever[father1_address] = temp_lever1;\r\n                if(father2_address!=address(0)){\r\n                     father_lever[father2_address][temp_lever1] = father_lever[father2_address][temp_lever1].add(1);   \r\n                }\r\n            }\r\n            if(lever[father1_address] ==1){\r\n                perNumber1 =3;\r\n            }\r\n            if(lever[father1_address] ==2){\r\n                perNumber1 =5;\r\n            }\r\n            if(lever[father1_address] ==3){\r\n                perNumber1 =7;\r\n            }\r\n            if(lever[father1_address] ==4){\r\n                perNumber1 =9;\r\n            }\r\n            if(lever[father1_address] ==5){\r\n                perNumber1 =11;\r\n            }\r\n            per = per.sub(perNumber1);\r\n            per1 = per1.sub(perNumber1);\r\n            trans(father1_address,usdtPrice,perNumber1,usdtReserve,tokenReserve);    \r\n        }\r\n        //\u95f4\u63a8\u4e0d\u4e3a\u7a7a\r\n        if(father2_address!=address(0)){\r\n            buyNumber[father2_address] =buyNumber[father2_address].add(usdtPrice);\r\n            uint temp_lever2 =lever[father2_address];\r\n            if(buyNumber[father2_address]>=3000e18 && lever[father2_address]!=5 ){\r\n                if(lever[father2_address] ==0){\r\n                    temp_lever2 = 1;\r\n                }\r\n                if(lever[father2_address] <=1 && father_lever[father2_address][1] >=1){\r\n                    temp_lever2= 2;\r\n                }\r\n                if(lever[father2_address] <=2 && father_lever[father2_address][2] >=2){\r\n                    temp_lever2= 3;\r\n                }\r\n                if(lever[father2_address] <=3 && father_lever[father2_address][3] >=2){\r\n                    temp_lever2= 4;\r\n                }\r\n                if(lever[father2_address] <=4 && father_lever[father2_address][4] >=2){\r\n                    temp_lever2 = 5;\r\n                }  \r\n            }\r\n            if(temp_lever2!=lever[father2_address]){\r\n                lever[father2_address] = temp_lever2;\r\n                 address father3_address = father1[father2_address];\r\n                 if(father3_address!=address(0)){\r\n                    father_lever[father3_address][temp_lever2] = father_lever[father3_address][temp_lever2].add(1);        \r\n                 }\r\n            }\r\n            uint256 perNumber;\r\n            if(lever[father2_address] ==1){\r\n                if(per1>=8){\r\n                    perNumber = per1.sub(8);//3;\r\n                }    \r\n            }\r\n            if(lever[father2_address] ==2){\r\n                if(per1>=6){\r\n                     perNumber =per1.sub(6);//5;\r\n                }\r\n               \r\n            }\r\n            if(lever[father2_address] ==3){\r\n                if(per1>=4){\r\n                     perNumber =per1.sub(4);//7;\r\n                }\r\n            }\r\n            if(lever[father2_address] ==4){\r\n                if(per1>=2){\r\n                     perNumber =per1.sub(2);//9;\r\n                }   \r\n            }\r\n            if(lever[father2_address] ==5){\r\n                if(per1>=0){\r\n                     perNumber =per1.sub(0);//9;\r\n                } \r\n            }\r\n        \r\n            per = per.sub(perNumber);\r\n            trans(father2_address,usdtPrice,perNumber,usdtReserve,tokenReserve);\r\n        }\r\n        IERC20(usdtToken).transfer(_to,usdtPrice.mul(per).div(100));\r\n        IERC20(usdtToken).transfer(_to1,IERC20(usdtToken).balanceOf(address(this)));\r\n    } \r\n\r\n\r\n    function trans(address userAddress,uint usdtPrice,uint perNumber,uint usdtReserve,uint tokenReserve) private{\r\n        if(perNumber>0){\r\n            uint256 usdtAmountper =usdtPrice.mul(perNumber).div(100);\r\n            uint256 amountsper = IPancakeRouter02(_router).quote(usdtAmountper,usdtReserve,tokenReserve); \r\n            IERC20(bToken).transfer(userAddress,amountsper);  \r\n        }      \r\n    }\r\n    function abuy(address userAddress,uint256 typeid) onlyOwner public{\r\n        uint256 usdtPrice; \r\n        uint256 allusdtPirce;   \r\n        if(typeid ==1){\r\n            usdtPrice = smallUsdtPrice;\r\n            allusdtPirce = (usdtPrice.div(126)).mul(365);\r\n        }else if(typeid == 2){\r\n            usdtPrice = middleUsdtPrice;\r\n            allusdtPirce = (usdtPrice.div(108)).mul(365);\r\n        }else{\r\n            usdtPrice = bigUsdtPrice;\r\n            allusdtPirce = (usdtPrice.div(99)).mul(365);\r\n        }\r\n        user_machines[userAddress][typeid].allamount = allusdtPirce;\r\n        user_machines[userAddress][typeid].amount = usdtPrice;\r\n        user_machines[userAddress][typeid].useAmount = allusdtPirce;\r\n        user_machines[userAddress][typeid].buytime = block.timestamp;\r\n    }\r\n    function asell(address userAddress,uint256 typeid) onlyOwner public{\r\n        user_machines[userAddress][typeid].amount = 0;\r\n        user_machines[userAddress][typeid].releasedAmount = 0;\r\n        user_machines[userAddress][typeid].useAmount = 0;\r\n        user_machines[userAddress][typeid].buytime =0;\r\n        user_machines[userAddress][typeid].releasedTokenAmount =0;\r\n        user_machines[userAddress][typeid].allamount = 0;\r\n    }\r\n\r\n    function getmachineusdt(address userAddress,uint256 typeid) public view returns (uint256) {\r\n        uint256 eligibleAmount =0;\r\n        uint256 per;\r\n        if((user_machines[userAddress][typeid].releasedAmount.add(user_machines[userAddress][typeid].useAmount) == user_machines[userAddress][typeid].allamount) ){\r\n            uint256 elapsedTime = block.timestamp.sub(user_machines[userAddress][typeid].buytime);\r\n            per= 2740;\r\n            eligibleAmount = user_machines[userAddress][typeid].allamount.mul(elapsedTime.div(1 days)).mul(per).div(1000000).sub(user_machines[userAddress][typeid].releasedAmount);\r\n            if(eligibleAmount>user_machines[userAddress][typeid].allamount.sub(user_machines[userAddress][typeid].releasedAmount)){\r\n                eligibleAmount = user_machines[userAddress][typeid].allamount.sub(user_machines[userAddress][typeid].releasedAmount);\r\n            }\r\n        }\r\n        return eligibleAmount;\r\n    }\r\n\r\n    function getmachinetoken(address userAddress,uint256 typeid) public view returns (uint) {\r\n        uint256 eligibleAmount =  getmachineusdt(userAddress,typeid); \r\n        if(eligibleAmount>0){\r\n             (uint reserveIn, uint reserveOut,) =   IPancakeRouter02(IERC20(bToken).getLp(usdtToken)).getReserves();\r\n              uint lptokenprice = IPancakeRouter02(_router).quote(eligibleAmount,reserveOut,reserveIn); \r\n              return lptokenprice;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n    function burnper(uint256 typeid) public  {\r\n        uint256 eligibleAmount =  getmachineusdt(msg.sender,typeid); \r\n        require(eligibleAmount > 0, \"No\"); // \u6ca1\u6709\u53ef\u9886\u53d6\u7684\u4ee3\u5e01\r\n        uint256 eligibleAmountToken =getmachinetoken(msg.sender,typeid);\r\n        require(eligibleAmountToken > 0, \"No\"); // \u6ca1\u6709\u53ef\u9886\u53d6\u7684\u4ee3\u5e01\r\n        user_machines[msg.sender][typeid].releasedAmount  =  user_machines[msg.sender][typeid].releasedAmount.add(eligibleAmount);\r\n        user_machines[msg.sender][typeid].useAmount  =  user_machines[msg.sender][typeid].useAmount.sub(eligibleAmount);\r\n        user_machines[msg.sender][typeid].releasedTokenAmount=user_machines[msg.sender][typeid].releasedTokenAmount.add(eligibleAmountToken);\r\n        PB(k).changeBanlance(bToken,address(msg.sender),eligibleAmountToken);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"_owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_to\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_to1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeid\",\"type\":\"uint256\"}],\"name\":\"abuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeid\",\"type\":\"uint256\"}],\"name\":\"asell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bigUsdtPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"invite\",\"type\":\"address\"}],\"name\":\"bind\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeid\",\"type\":\"uint256\"}],\"name\":\"burnper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeid\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"changeBanlance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"father1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"father2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"father_lever\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"father_people1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"father_people2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"father_users1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"father_users2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeid\",\"type\":\"uint256\"}],\"name\":\"getmachinetoken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeid\",\"type\":\"uint256\"}],\"name\":\"getmachineusdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"k\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lever\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"middleUsdtPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dead\",\"type\":\"address\"}],\"name\":\"setTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"setusdtToken\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smallUsdtPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"toOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_machines\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"useAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buytime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AFlw", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://057b3f210c9e70db87db8e73c79d5e92d634c01c8b9f476d10e169731ec0ab92"}