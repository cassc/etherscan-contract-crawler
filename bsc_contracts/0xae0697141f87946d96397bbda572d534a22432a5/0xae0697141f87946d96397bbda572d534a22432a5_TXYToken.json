{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n}\r\n\r\ninterface ISwapFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TokenDistributor {\r\n    constructor(address token) {\r\n        IERC20(token).approve(msg.sender, uint256(~uint256(0)));\r\n    }\r\n}\r\n\r\ncontract TXYToken is Ownable, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) private _feeWhiteList;\r\n    mapping(address => bool) private _blackList;\r\n\r\n    address public fundAddress;\r\n    address public flowAddress;\r\n    address public shibAddress;\r\n    address public lpAddress;\r\n    string private _name = \"TXY Token\";\r\n    string private _symbol = \"TXYM\";\r\n    uint8 private _decimals = 18;\r\n    uint256 public lpFee = 500;\r\n    uint256 public lpFeeBase = 10000;\r\n    uint256 public numTokensSellToFund;\r\n    uint256 public numTokenToDestroy;\r\n\r\n    uint256 public lpDestroyFee = 500;\r\n    uint256 public lpDestroyFeeBase = 1000;\r\n\r\n    uint256 public lpShiBFee = 400;\r\n    uint256 public lpShiBFeeBase = 1000;\r\n\r\n    uint256 public lpUsdtFee = 100;\r\n    uint256 public lpUsdtFeeBase = 1000;\r\n\r\n    address public mainPair;\r\n    uint256 private _tTotal;\r\n    ISwapRouter public _swapRouter;\r\n\r\n    TokenDistributor _tokenDistributor;\r\n    address private usdt;\r\n    address private dead;\r\n    address private shib;\r\n    bool public inSwap;\r\n    modifier lockTheSwap() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    constructor() {\r\n        numTokenToDestroy = 1000 * 10**_decimals;\r\n        numTokensSellToFund = 1 * 10**(_decimals-1);\r\n\r\n        // 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3   0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n        _swapRouter = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        //  0xD6055D2543BB3A5e60ca7b40c7c369B55e337098   0x55d398326f99059fF775485246999027B3197955\r\n        usdt = address(0x55d398326f99059fF775485246999027B3197955); //ly 0xc600F7Bb18c334a5FF18Ca20119A8781F0b33Db9\r\n        dead = address(0x000000000000000000000000000000000000dEaD);\r\n        shib = address(0x2859e4544C4bB03966803b044A93563Bd2D0DD4D); //xyw 0x934A049c11c1A72A562749D4b81fA27d05A898B3\r\n        fundAddress = address(0xF8Fd58cD16D5dCF49C3EAd30B080B416Cf4f57c0);\r\n        flowAddress = address(0xbBacF28a895ba3401E101b9cA4aFebBc466a1113);\r\n        shibAddress = address(0x486e2E56F1b71557746a2CC9dF6b44B7670b919f);\r\n        lpAddress = address(0xdFF689867Aa300E3bDe4cf56E1c1C859Bdf92337);\r\n        _tTotal = 10000 * 10**_decimals;\r\n\r\n        mainPair = ISwapFactory(_swapRouter.factory()).createPair(\r\n            address(this),\r\n            usdt\r\n        );\r\n        _balances[fundAddress] = _tTotal;\r\n        emit Transfer(address(0), fundAddress, _tTotal);\r\n\r\n        _feeWhiteList[fundAddress] = true;\r\n        _feeWhiteList[address(this)] = true;\r\n        _feeWhiteList[address(_swapRouter)] = true;\r\n\r\n        inSwap = false;\r\n\r\n        _tokenDistributor = new TokenDistributor(usdt);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            );\r\n            unchecked {\r\n                _approve(sender, msg.sender, currentAllowance - amount);\r\n            }\r\n        }\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender] + addedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC20: decreased allowance below zero\"\r\n        );\r\n        unchecked {\r\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"approve from the zero address\");\r\n        require(spender != address(0), \"approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(from != address(0), \"Transfer from the zero address\");\r\n        require(to != address(0), \"Transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        require(!_blackList[from], \"Transfer from the blackList address\");\r\n\r\n        bool takeFee = false;\r\n        if (from == mainPair || to == mainPair) {\r\n            takeFee = true;\r\n            if (_feeWhiteList[from] || _feeWhiteList[to]) {\r\n                takeFee = false;\r\n            }\r\n        } else {\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            bool overMinTokenBalance = contractTokenBalance >=\r\n                numTokensSellToFund;\r\n            if (overMinTokenBalance && !inSwap) {\r\n                uint256 lpUsdtPercent = (lpUsdtFee * 10000) / lpUsdtFeeBase;\r\n                uint256 lpShibPercent = (lpShiBFee * 10000) / lpShiBFeeBase;\r\n                uint256 totalPercent = lpUsdtPercent + lpShibPercent;\r\n                swapTokenForFund(\r\n                    (contractTokenBalance * lpUsdtPercent) / totalPercent\r\n                );\r\n                swapTokensForShiB(\r\n                    (contractTokenBalance * lpShibPercent) / totalPercent\r\n                );\r\n            }\r\n        }\r\n\r\n        _tokenTransfer(from, to, amount, takeFee);\r\n    }\r\n\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount,\r\n        bool takeFee\r\n    ) private {\r\n        uint256 balanceAcmount = balanceOf(sender);\r\n        require(balanceAcmount >= tAmount, \"Insufficient wallet balance\");\r\n        unchecked {\r\n            _balances[sender] = _balances[sender] - tAmount;\r\n        }\r\n\r\n        uint256 feeAmount;\r\n        if (takeFee) {\r\n            feeAmount = (tAmount * lpFee) / lpFeeBase;\r\n\r\n            uint256 deadTokenBalance = _tTotal - balanceOf(dead);\r\n            bool overMinTokenBalance = deadTokenBalance > numTokenToDestroy;\r\n            if (overMinTokenBalance && !inSwap) {\r\n                unchecked {\r\n                    _balances[dead] =\r\n                        _balances[dead] +\r\n                        (feeAmount * lpDestroyFee) /\r\n                        lpDestroyFeeBase;\r\n                }\r\n                emit Transfer(\r\n                    sender,\r\n                    dead,\r\n                    (feeAmount * lpDestroyFee) / lpDestroyFeeBase\r\n                );\r\n            }\r\n\r\n            if (!overMinTokenBalance && !inSwap) {\r\n                unchecked {\r\n                    _balances[flowAddress] =\r\n                        _balances[flowAddress] +\r\n                        (feeAmount * lpDestroyFee) /\r\n                        lpDestroyFeeBase;\r\n                }\r\n                emit Transfer(\r\n                    sender,\r\n                    flowAddress,\r\n                    (feeAmount * lpDestroyFee) / lpDestroyFeeBase\r\n                );\r\n            }\r\n\r\n            if (!inSwap) {\r\n                unchecked {\r\n                    _balances[address(this)] =\r\n                        _balances[address(this)] +\r\n                        (feeAmount * lpUsdtFee) /\r\n                        lpUsdtFeeBase;\r\n                }\r\n                emit Transfer(\r\n                    sender,\r\n                    address(this),\r\n                    (feeAmount * lpUsdtFee) / lpUsdtFeeBase\r\n                );\r\n\r\n                unchecked {\r\n                    _balances[address(this)] =\r\n                        _balances[address(this)] +\r\n                        (feeAmount * lpShiBFee) /\r\n                        lpShiBFeeBase;\r\n                }\r\n                emit Transfer(\r\n                    sender,\r\n                    address(this),\r\n                    (feeAmount * lpShiBFee) / lpShiBFeeBase\r\n                );\r\n            }\r\n        }\r\n\r\n        uint256 rTAmount = tAmount - feeAmount;\r\n        _balances[recipient] = _balances[recipient] + rTAmount;\r\n        emit Transfer(sender, recipient, rTAmount);\r\n    }\r\n\r\n    function swapTokenForFund(uint256 tokenAmount) private lockTheSwap {\r\n        uint256 lpAmount = tokenAmount / 2;\r\n\r\n        IERC20 USDT = IERC20(usdt);\r\n        uint256 initialBalance = USDT.balanceOf(address(_tokenDistributor));\r\n\r\n        swapTokensForUsdt(tokenAmount - lpAmount);\r\n\r\n        uint256 newBalance = USDT.balanceOf(address(_tokenDistributor)) -\r\n            initialBalance; //\r\n\r\n        USDT.transferFrom(\r\n            address(_tokenDistributor),\r\n            address(this),\r\n            newBalance\r\n        );\r\n\r\n        addLiquidityUsdt(lpAmount, newBalance);\r\n    }\r\n\r\n    function addLiquidityUsdt(uint256 tokenAmount, uint256 usdtAmount) private {\r\n        _allowances[address(this)][address(_swapRouter)] = tokenAmount;\r\n        IERC20(usdt).approve(address(_swapRouter), usdtAmount);\r\n        _swapRouter.addLiquidity(\r\n            address(this),\r\n            usdt,\r\n            tokenAmount,\r\n            usdtAmount,\r\n            0,\r\n            0,\r\n            lpAddress,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    event AwapTokensForShiB(\r\n        address shibAddress,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    function swapTokensForShiB(uint256 tokenAmount) private {\r\n        require(tokenAmount > 0, \"too less\");\r\n\r\n        IERC20 USDT = IERC20(shib);\r\n        uint256 initialBalance = USDT.balanceOf(address(shibAddress));\r\n\r\n        // swapTokensForUsdt(tokenAmount);\r\n\r\n        // uint256 newBalance = USDT.balanceOf(address(_tokenDistributor)) - initialBalance;//\r\n\r\n        // USDT.transferFrom(address(_tokenDistributor), address(this), newBalance);\r\n\r\n        //    IERC20(usdt).approve(address(_swapRouter), newBalance);\r\n\r\n        _allowances[address(this)][address(_swapRouter)] = tokenAmount;\r\n        address[] memory path = new address[](3);\r\n        path[0] = address(this);\r\n        path[1] = usdt;\r\n        path[2] = shib;\r\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(shibAddress),\r\n            block.timestamp\r\n        );\r\n        uint256 newBalance = USDT.balanceOf(address(shibAddress)) -\r\n            initialBalance; //\r\n        emit AwapTokensForShiB(\r\n            address(shibAddress),\r\n            newBalance,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapTokensForUsdt(uint256 tokenAmount) private {\r\n        require(tokenAmount > 0, \"too less\");\r\n        _allowances[address(this)][address(_swapRouter)] = tokenAmount;\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = usdt;\r\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(_tokenDistributor),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setFeeWhiteList(address addr, bool enable) external onlyOwner {\r\n        _feeWhiteList[addr] = enable;\r\n    }\r\n\r\n    function isFeeWhiteList(address addr) external view returns (bool) {\r\n        return _feeWhiteList[addr];\r\n    }\r\n\r\n    function addBlackList(address addr) external onlyOwner {\r\n        _blackList[addr] = true;\r\n    }\r\n\r\n    function removeBlackList(address addr) external onlyOwner {\r\n        _blackList[addr] = false;\r\n    }\r\n\r\n    function isBlackList(address addr) external view returns (bool) {\r\n        return _blackList[addr];\r\n    }\r\n\r\n    function claimBalance() public onlyOwner {\r\n        payable(fundAddress).transfer(address(this).balance);\r\n    }\r\n\r\n    function claimToken(address token, uint256 amount) public onlyOwner {\r\n        IERC20(token).transfer(fundAddress, amount);\r\n    }\r\n\r\n    function setNumTokensSellToFund(uint256 amount) public onlyOwner {\r\n        numTokensSellToFund = amount;\r\n    }\r\n\r\n    function setNumTokenToDestroy(uint256 amount) public onlyOwner {\r\n        numTokenToDestroy = amount;\r\n    }\r\n\r\n    function setLpFee(uint256 _lpFee, uint256 _lpFeeBase) public onlyOwner {\r\n        require(_lpFee != 0, \"value is zero\");\r\n        require(_lpFeeBase != 0, \"value is zero\");\r\n        require(_lpFee / _lpFeeBase < 1, \"error value\");\r\n        lpFee = _lpFee;\r\n        lpFeeBase = _lpFeeBase;\r\n    }\r\n\r\n    function setLpDestroyFee(uint256 _lpDestroyFee, uint256 _lpDestroyFeeBase)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_lpDestroyFee != 0, \"value is zero\");\r\n        require(_lpDestroyFeeBase != 0, \"value is zero\");\r\n        require(_lpDestroyFee / _lpDestroyFeeBase < 1, \"error value\");\r\n        lpDestroyFee = _lpDestroyFee;\r\n        lpDestroyFeeBase = _lpDestroyFeeBase;\r\n    }\r\n\r\n    function setLpShiBFee(uint256 _lpShiBFee, uint256 _lpShiBFeeBase)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_lpShiBFee != 0, \"value is zero\");\r\n        require(_lpShiBFeeBase != 0, \"value is zero\");\r\n        require(_lpShiBFee / _lpShiBFeeBase < 1, \"error value\");\r\n        lpShiBFee = _lpShiBFee;\r\n        lpShiBFeeBase = _lpShiBFeeBase;\r\n    }\r\n\r\n    function setLpUsdtFee(uint256 _lpUsdtFee, uint256 _lpUsdtFeeBase)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_lpUsdtFee != 0, \"value is zero\");\r\n        require(_lpUsdtFeeBase != 0, \"value is zero\");\r\n        require(_lpUsdtFee / _lpUsdtFeeBase < 1, \"error value\");\r\n        lpUsdtFee = _lpUsdtFee;\r\n        lpUsdtFeeBase = _lpUsdtFeeBase;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"shibAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AwapTokensForShiB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flowAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isBlackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isFeeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpDestroyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpDestroyFeeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpShiBFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpShiBFeeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpUsdtFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpUsdtFeeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokenToDestroy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellToFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpDestroyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpDestroyFeeBase\",\"type\":\"uint256\"}],\"name\":\"setLpDestroyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpFeeBase\",\"type\":\"uint256\"}],\"name\":\"setLpFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpShiBFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpShiBFeeBase\",\"type\":\"uint256\"}],\"name\":\"setLpShiBFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpUsdtFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpUsdtFeeBase\",\"type\":\"uint256\"}],\"name\":\"setLpUsdtFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setNumTokenToDestroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setNumTokensSellToFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shibAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TXYToken", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e17632dc2864c58604a3f47cf469ca9fbd10ca019d0057f61623d0b19e8bb017"}