{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n}\r\n\r\n/**\r\n * Allows for contract ownership along with multi-address authorization\r\n */\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract PIXMonster is IBEP20, Auth {\r\n    using SafeMath for uint256;  \r\n    address WBNB                 = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address public RESERVE       = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address DEAD                 = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO                 = 0x0000000000000000000000000000000000000000;\r\n    address BUYBACK_TOKEN        = 0x337C218f16dBc290fB841Ee8B97A74DCdAbfeDe8;\r\n\r\n    uint256 feeDenominator = 10000;\r\n    address pixFeeReceiver = 0x48B10e4fe80b4433601CBAab391eAd946e5C89B5;\r\n\r\n    //RESERVE SWAP\r\n    bool reserveSwap = true;\r\n    uint256 public bnbBalanceTooLow = 5000000000000000000;\r\n    uint256 public reserveSwapAmount = 1000000000000000000000;\r\n    uint256 public gasFee = 5200000000000000;\r\n    uint256 public bnbEquivalent = 1000000000000000000;\r\n\r\n    uint256 MAXIMUM_OVER_FEE = 10000;\r\n    uint256 MAXIMUM_FEE_DISCOUNT = 100;\r\n    uint256 DISCOUNT_DENOMINATOR = 100;\r\n\r\n    uint256 BNBToLiquify = 0;\r\n    uint256 BNBToLiquifyFeeAmount = 0;\r\n    uint256 BNBToLiquifyEXTRAFee = 0;\r\n    uint256 BNBToLiquifyOVERFee = 0;\r\n    uint256 BNBToLiquifyFeeDiscount = 0;\r\n    uint256 feeAmount = 0;\r\n    uint256 feeAmountDiscount = 0;\r\n    uint256 amountToBeSentAfterFees = 0;\r\n\r\n    string _name = \"PIX Monster\";\r\n    string _symbol = \"PIX\";\r\n    uint8 _decimals = 0;\r\n\r\n    uint256 _totalSupply = 0;\r\n\r\n    // Info of each preSale pool.\r\n    struct PreSale {\r\n        IBEP20 tokenAddress;\r\n        uint256 bnbEquivalent;\r\n        uint256 totalSupply;\r\n        uint256 decimalDenominator;\r\n        uint256 correctionValue;\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct TokenInfo {\r\n        IBEP20 tokenAddress; \r\n        uint256 pixFee;\r\n        uint256 contractFee;\r\n        uint256 extraFee;\r\n        uint256 overFee;\r\n        uint256 totalFees;\r\n        address feeReceiver;\r\n        bool preSale;\r\n        bool transferAfter;\r\n        bool buyBack;\r\n        address buyBackToken;\r\n        uint256 totalTransfered;\r\n        uint256 totalBought;\r\n    }\r\n    mapping (address => TokenInfo) public tokenInfo;\r\n    mapping (address => PreSale) public preSale;\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n    mapping (address => uint256) public totalFee;\r\n    mapping (address => bool) public isFeeExempt;\r\n    mapping (address => bool) public isBlacklisted;\r\n    mapping (address => uint256) public feeDiscount;\r\n    mapping (address => bool) public haltIfNoBalance;\r\n\r\n    IDEXRouter public router;\r\n    address public pair;\r\n\r\n    event AdminTokenRecovery(address tokenAddress, uint256 tokenAmount);     \r\n\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor () Auth(msg.sender) {\r\n        //router = IDEXRouter(0xD99D1c33F9fC3444f8101754aBC46c52416550D1); // TESTNET ONLY\r\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); // MAINNET ONLY\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = uint256(-1);\r\n        emit Transfer(ZERO, DEAD, _totalSupply); \r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external view override returns (uint8) { return _decimals; }\r\n    function symbol() external view override returns (string memory) { return _symbol; }\r\n    function name() external view override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    function setTokenInfo(\r\n        address _tokenAddress,\r\n        uint256 _pixFee,\r\n        uint256 _contractFee,\r\n        uint256 _extraFee,\r\n        uint256 _overFee,\r\n        address _feeReceiver,\r\n        bool _preSale,\r\n        bool _transferAfter,\r\n        bool _buyBack,\r\n        address _buyBackToken,\r\n        uint256 _totalTransfered,\r\n        uint256 _totalBought\r\n        ) public onlyOwner {\r\n\r\n        TokenInfo storage token = tokenInfo[_tokenAddress];\r\n        token.tokenAddress = IBEP20(_tokenAddress);\r\n        token.pixFee = _pixFee;\r\n        token.contractFee = _contractFee;\r\n        token.extraFee = _extraFee;\r\n        token.overFee = _overFee;\r\n        token.feeReceiver = _feeReceiver;\r\n        token.preSale = _preSale;\r\n        token.transferAfter = _transferAfter;\r\n        token.buyBack = _buyBack;\r\n        token.buyBackToken = _buyBackToken;\r\n        totalFee[_tokenAddress] = _pixFee.add(_contractFee).add(_extraFee);\r\n        token.totalFees = totalFee[_tokenAddress];\r\n        if (_totalTransfered > 0) {\r\n            token.totalTransfered = _totalTransfered;\r\n        }\r\n        if (_totalBought > 0) {\r\n            token.totalBought = _totalBought;\r\n        } \r\n    }    \r\n\r\n    function setPresaleInfo(\r\n        address _tokenAddress,\r\n        uint256 _bnbEquivalent,\r\n        uint256 _supply,\r\n        uint256 _decimalDenominator,\r\n        uint256 _correctionValue\r\n        ) public onlyOwner {\r\n        PreSale storage PIXSale = preSale[_tokenAddress];\r\n        PIXSale.tokenAddress = IBEP20(_tokenAddress);\r\n        PIXSale.bnbEquivalent = _bnbEquivalent;\r\n        PIXSale.totalSupply = _supply;\r\n        PIXSale.decimalDenominator = _decimalDenominator;\r\n        PIXSale.correctionValue = _correctionValue;\r\n    }  \r\n\r\n    function setDiscount(address _address, uint256 _discount) public onlyOwner {\r\n        require(_discount <= MAXIMUM_FEE_DISCOUNT);\r\n        feeDiscount[_address] = _discount;\r\n    }\r\n\r\n    function halt(address _address, bool _enabled) public onlyOwner {\r\n        require(_enabled != haltIfNoBalance[_address]);\r\n        haltIfNoBalance[_address] = _enabled;\r\n    }\r\n\r\n    function setPixFeeReceiver(address _pixFeeReceiver, uint256 _gasFee) public onlyOwner {\r\n        pixFeeReceiver = _pixFeeReceiver;\r\n        gasFee = _gasFee;\r\n    }\r\n\r\n    function blacklist(address _token, bool _isBlacklisted) public onlyOwner {\r\n        require(isBlacklisted[_token] != _isBlacklisted);\r\n        isBlacklisted[_token] = _isBlacklisted;\r\n    }\r\n\r\n    function setReserveConfig(bool _enabled, address _reserveTokenAddress, uint256 _minReserveBalance, uint256 _minBNB) public onlyOwner {\r\n        reserveSwap = _enabled;\r\n        RESERVE = _reserveTokenAddress;\r\n        bnbBalanceTooLow = _minBNB; \r\n        reserveSwapAmount = _minReserveBalance;\r\n    } \r\n\r\n    function PIXTransfer(address _token, address _deliveryAddress, uint256 _amount) external onlyOwner {\r\n        require(!isBlacklisted[_token],\"BLACKLISTED\");\r\n        uint256 amountToLiquify = _amount;\r\n        if (_token != WBNB) {\r\n            require(IBEP20(_token).balanceOf(address(this)) >= _amount);\r\n            IBEP20(_token).transfer(address(_deliveryAddress), _amount);              \r\n        } else {\r\n            require(address(this).balance >= amountToLiquify);\r\n            (bool tmpSuccess,) = payable(_deliveryAddress).call{value: amountToLiquify, gas: 30000}(\"\");\r\n            tmpSuccess = false;            \r\n        }\r\n    }\r\n\r\n    function preSaleCheck(address _token, uint256 _amountBNBToLiquify) public view returns (uint256) {\r\n        PreSale storage PIXSale = preSale[_token];\r\n        uint256 marketCapInBNB = PIXSale.totalSupply.div(PIXSale.bnbEquivalent);\r\n\r\n        uint _numerator  = _amountBNBToLiquify * 10 ** (5);\r\n        uint _quotient =  ((_numerator / marketCapInBNB)) / 10;\r\n        uint256 percentageAmount = _quotient;\r\n        uint256 tokenAmount = PIXSale.totalSupply.mul(percentageAmount).div(feeDenominator).div(PIXSale.decimalDenominator);\r\n        tokenAmount = tokenAmount * PIXSale.correctionValue / 1000000;\r\n        return tokenAmount;\r\n    }\r\n\r\n    function process(address _token, address _deliveryAddress, uint256 _amountBNBToLiquify, uint256 _mintokenAmount) internal swapping {\r\n        //CHECKS CONTRACT INFO\r\n        TokenInfo storage token = tokenInfo[_token];\r\n\r\n        //REQUIREMENTS\r\n        require(!isBlacklisted[_token],\"BLACKLISTED\");\r\n        require(address(this).balance >= _amountBNBToLiquify,\"INSUFFICIENT_BNB_BALANCE\");\r\n        require(\r\n            !haltIfNoBalance[_token] \r\n            || IBEP20(_token).balanceOf(address(this)) >= _mintokenAmount,\r\n            \"HALT_IF_NO_BALANCE\");\r\n\r\n        //SET TRADING CONFIG\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = _token;\r\n\r\n        //CREATE LOCAL VARIABLES\r\n        bool swapHasBeenDone = false;\r\n        uint256 totalAmountSent = 0;\r\n        address deliveryAddress = _deliveryAddress;\r\n        uint256 userFeeDiscount = 0;\r\n\r\n        //RESET VARIABLES\r\n        BNBToLiquify = _amountBNBToLiquify;\r\n        BNBToLiquifyFeeAmount = 0;\r\n        BNBToLiquifyFeeDiscount = 0;\r\n        BNBToLiquifyEXTRAFee = 0;\r\n        BNBToLiquifyOVERFee = 0;\r\n        feeAmount = 0;\r\n        feeAmountDiscount = 0;\r\n        amountToBeSentAfterFees = _mintokenAmount;\r\n        userFeeDiscount = feeDiscount[_deliveryAddress];\r\n\r\n        //UPDATES AMOUNT OF FEES TO BE CHARGED\r\n        if (token.totalFees > 0) {\r\n            BNBToLiquifyFeeAmount = BNBToLiquify.mul(token.totalFees.sub(token.contractFee)).div(feeDenominator);\r\n        }        \r\n        if (token.extraFee > 0 ) {\r\n            BNBToLiquifyEXTRAFee = BNBToLiquify.mul(token.extraFee).div(feeDenominator);\r\n        }        \r\n        if (userFeeDiscount > 0 && token.totalFees > 0) {\r\n            BNBToLiquifyFeeDiscount = BNBToLiquifyFeeAmount.mul(feeDiscount[_deliveryAddress]).div(DISCOUNT_DENOMINATOR);\r\n        }\r\n        if (token.overFee > 0 && IBEP20(_token).balanceOf(address(this))  > _mintokenAmount) {\r\n            BNBToLiquifyOVERFee = BNBToLiquify.mul(token.overFee).div(feeDenominator);\r\n        }\r\n \r\n        //SEND FEES & BUY BACK TOKENS\r\n        if (BNBToLiquifyFeeAmount > 0 && !isFeeExempt[_deliveryAddress]) {\r\n            BNBToLiquify = BNBToLiquify.sub(BNBToLiquifyFeeAmount);\r\n            if (token.pixFee > 0) {\r\n                BNBToLiquifyFeeAmount = BNBToLiquifyFeeAmount.sub(BNBToLiquifyFeeDiscount).add(gasFee).add(BNBToLiquifyOVERFee);\r\n                (bool tmpSuccess,) = payable(pixFeeReceiver).call{value: BNBToLiquifyFeeAmount, gas: 30000}(\"\");\r\n                tmpSuccess = false; \r\n            }\r\n            if (token.pixFee == 0) {\r\n                BNBToLiquifyOVERFee = BNBToLiquifyOVERFee.add(gasFee);\r\n                (bool tmpSuccess,) = payable(pixFeeReceiver).call{value: BNBToLiquifyOVERFee, gas: 30000}(\"\");\r\n                tmpSuccess = false; \r\n            }\r\n            if (!token.buyBack && BNBToLiquifyEXTRAFee > 0) {\r\n                (bool tmpSuccess,) = payable(token.feeReceiver).call{value: BNBToLiquifyEXTRAFee, gas: 30000}(\"\");\r\n                tmpSuccess = false; \r\n            }\r\n            if (token.buyBack && BNBToLiquifyEXTRAFee > 0) {\r\n                buy(BNBToLiquifyEXTRAFee, token.buyBackToken, token.feeReceiver);\r\n            }\r\n        }\r\n\r\n        //DELIVERY PROCESS STARTS HERE IF IT'S NOT BNB\r\n        if (_token != WBNB) {\r\n            uint256 balanceBefore = IBEP20(_token).balanceOf(address(this));\r\n            if (token.transferAfter) {\r\n                deliveryAddress = address(this);\r\n            }\r\n            if (balanceBefore < _mintokenAmount || _mintokenAmount == 0) {\r\n                router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: BNBToLiquify}(\r\n                    0,\r\n                    path,\r\n                    deliveryAddress,\r\n                    block.timestamp\r\n                );\r\n                swapHasBeenDone = true;\r\n                if (deliveryAddress == _deliveryAddress) {\r\n                    totalAmountSent = _mintokenAmount;\r\n                }\r\n                uint256 balanceNow = IBEP20(_token).balanceOf(address(this));\r\n                uint256 amountToBeSent = balanceNow.sub(balanceBefore);\r\n                if (balanceNow > balanceBefore && deliveryAddress != _deliveryAddress) {\r\n                    if (token.preSale) { \r\n                        amountToBeSent = preSaleCheck(_token, _amountBNBToLiquify);\r\n                    }\r\n                    IBEP20(_token).transfer(address(_deliveryAddress), amountToBeSent);\r\n                    totalAmountSent = amountToBeSent;\r\n                } \r\n            } else if (balanceBefore >= _mintokenAmount && _mintokenAmount > 0) {\r\n                feeAmount = _mintokenAmount.mul(token.totalFees).div(feeDenominator);\r\n                feeAmountDiscount = feeAmount.mul(feeDiscount[_deliveryAddress]).div(DISCOUNT_DENOMINATOR);\r\n                feeAmount = feeAmount.sub(feeAmountDiscount);\r\n                amountToBeSentAfterFees = _mintokenAmount.sub(feeAmount);\r\n                if (token.preSale) { \r\n                    amountToBeSentAfterFees = preSaleCheck(_token, _amountBNBToLiquify);\r\n                }\r\n                IBEP20(_token).transfer(address(_deliveryAddress), amountToBeSentAfterFees);\r\n                totalAmountSent = amountToBeSentAfterFees;\r\n            }\r\n\r\n        // IF IT'S BNB, THE DELIVERY WILL HAPPEN HERE\r\n        } else {\r\n            require(address(this).balance >= BNBToLiquify,\"Insufficient BNB Balance\");\r\n            (bool tmpSuccess,) = payable(_deliveryAddress).call{value: BNBToLiquify, gas: 30000}(\"\");\r\n            tmpSuccess = false;\r\n            token.totalTransfered = token.totalTransfered.add(BNBToLiquify);            \r\n        }\r\n\r\n        //UPDATES TOTAL AMOUNTS BOUGHT/TRANSFERED\r\n        if (swapHasBeenDone) {\r\n                token.totalBought = token.totalBought.add(totalAmountSent);          \r\n        } else if (!swapHasBeenDone) {\r\n            if (_token == WBNB) {\r\n                token.totalTransfered = token.totalTransfered.add(BNBToLiquify);\r\n            } else {\r\n                token.totalTransfered = token.totalTransfered.add(totalAmountSent);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    //HERE IS WHERE THE MAGIC HAPPENS\r\n    function criptoNoPix(address _tokenAddress, address _holder, uint256 _amountInBNB, uint256 _mintokenAmount) external onlyOwner {\r\n      require(_amountInBNB > 0 || _mintokenAmount > 0, \"BOTH_AMOUNTS_CANNOT_BE_ZERO\");\r\n      require(_tokenAddress != _holder, \"DUPLICATED_ADDRESS\");\r\n      process(_tokenAddress, _holder, _amountInBNB, _mintokenAmount);\r\n      if (reserveSwap \r\n      && IBEP20(RESERVE).balanceOf(address(this)) >= reserveSwapAmount\r\n      && address(this).balance < bnbBalanceTooLow) { \r\n          adjustBalance(RESERVE, WBNB, reserveSwapAmount, 0, address(this)); \r\n          }\r\n    }\r\n\r\n    function buy(uint256 _amountToLiquify, address _tokenAddress, address _feeReceiver) internal swapping {\r\n        require(address(this).balance >= _amountToLiquify,\"INSUFFICIENT_BNB_BALANCE\");\r\n        //SET TRADING CONFIG\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = _tokenAddress;\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: _amountToLiquify}(\r\n            0,\r\n            path,\r\n            _feeReceiver,\r\n            block.timestamp\r\n        );        \r\n    }\r\n\r\n    function updateBalance(uint256 _amount) external onlyOwner {\r\n        require(reserveSwap);\r\n        adjustBalance(RESERVE, WBNB, _amount, 0, address(this));\r\n    }\r\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n   function adjustBalance(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to\r\n    ) internal swapping {\r\n        //first we need to transfer the amount in tokens from the msg.sender to this contract\r\n        //this contract will have the amount of in tokens\r\n        // IERC20(_tokenIn).transferFrom(msg.sender, address(this), _amountIn);\r\n\r\n        //next we need to allow the uniswapv2 router to spend the token we just sent to this contract\r\n        //by calling IERC20 approve you allow the uniswap contract to spend the tokens in this contract\r\n        if (\r\n            IBEP20(_tokenIn).allowance(address(this), 0x10ED43C718714eb63d5aA57B78B54704E256024E) <\r\n            _amountIn\r\n        ) {\r\n            require(\r\n                IBEP20(_tokenIn).approve(0x10ED43C718714eb63d5aA57B78B54704E256024E, type(uint256).max),\r\n                \"TOKENSWAP::Approve failed\"\r\n            );\r\n        }\r\n\r\n        //path is an array of addresses.\r\n        //this path array will have 3 addresses [tokenIn, WETH, tokenOut]\r\n        //the if statement below takes into account if token in or token out is WETH.  then the path is only 2 addresses\r\n        address[] memory path;\r\n        if (_tokenIn == WBNB || _tokenOut == WBNB) {\r\n            path = new address[](2);\r\n            path[0] = _tokenIn;\r\n            path[1] = _tokenOut;\r\n        } else {\r\n            path = new address[](3);\r\n            path[0] = _tokenIn;\r\n            path[1] = WBNB;\r\n            path[2] = _tokenOut;\r\n        }\r\n        //then we will call swapExactTokensForTokens\r\n        //for the deadline we will pass in block.timestamp\r\n        //the deadline is the latest time the trade is valid for\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                _amountIn,\r\n                _amountOutMin,\r\n                path,\r\n                _to,\r\n                block.timestamp\r\n            );\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, uint256(-1));\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != uint256(-1)){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;            \r\n\r\n    }\r\n\r\n    function withdrawBNB(uint256 amountPercentage, address _walletAddress) external onlyOwner {\r\n        require(_walletAddress != address(this));\r\n        uint256 amountBNB = address(this).balance;\r\n        payable(_walletAddress).transfer(amountBNB * amountPercentage / 100);\r\n    }\r\n\r\n     function withdrawTokens(address _tokenAddress, address _walletAddress) external onlyOwner {\r\n        uint256 tokenBalance = IBEP20(_tokenAddress).balanceOf(address(this));\r\n        IBEP20(_tokenAddress).transfer(address(_walletAddress), tokenBalance);\r\n        emit AdminTokenRecovery(_tokenAddress, tokenBalance);\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_deliveryAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"PIXTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESERVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBlacklisted\",\"type\":\"bool\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbBalanceTooLow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbEquivalent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountInBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintokenAmount\",\"type\":\"uint256\"}],\"name\":\"criptoNoPix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"halt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"haltIfNoBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"preSale\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bnbEquivalent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimalDenominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"correctionValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountBNBToLiquify\",\"type\":\"uint256\"}],\"name\":\"preSaleCheck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveSwapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_discount\",\"type\":\"uint256\"}],\"name\":\"setDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pixFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasFee\",\"type\":\"uint256\"}],\"name\":\"setPixFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bnbEquivalent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimalDenominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_correctionValue\",\"type\":\"uint256\"}],\"name\":\"setPresaleInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_reserveTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBNB\",\"type\":\"uint256\"}],\"name\":\"setReserveConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pixFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_contractFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_extraFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_overFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_preSale\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_transferAfter\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_buyBack\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_buyBackToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalTransfered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalBought\",\"type\":\"uint256\"}],\"name\":\"setTokenInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenInfo\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pixFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"overFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preSale\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"transferAfter\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyBack\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"buyBackToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalTransfered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBought\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PIXMonster", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://70c1367abf1679ce353b9e377068466b3f122f961d8d1452d4a3e405b675f4d5"}