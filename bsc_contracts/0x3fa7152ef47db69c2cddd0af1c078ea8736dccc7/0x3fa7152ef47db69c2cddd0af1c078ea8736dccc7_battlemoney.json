{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function _approve(address owner, address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() \r\n    {   _status = _NOT_ENTERED;     }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ninterface IPancakeRouter01 {\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ncontract battlemoney is Ownable, ReentrancyGuard{\r\n\r\n    using SafeMath for uint256;\r\n\r\n    IPancakeRouter01 public Router;\r\n    IERC20 public AGC;\r\n    IERC20 public USDT;\r\n\r\n    uint256 public miniDeposit = 10; \r\n\r\n    constructor()\r\n    {\r\n       AGC = IERC20(0x6e3fd1DEA627226998dA6e9e0C7EF95F417d6c35);\r\n       USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n       Router = IPancakeRouter01(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    }\r\n    \r\n    function getPrice(uint256 packageamount) \r\n    public \r\n    view \r\n    returns(uint256, uint256)\r\n    {\r\n        require(packageamount.mod(miniDeposit) == 0 && packageamount >= miniDeposit, \"mod err\");\r\n        // no. of tokens in one dollar \r\n        address[] memory path0 = new address[](2);\r\n        path0[0] = address(USDT);\r\n        path0[1] = address(AGC);\r\n        uint256[] memory amounts0 = Router.getAmountsOut(1 ether,path0);\r\n\r\n        return (amounts0[1].mul(packageamount), packageamount.mul(1 ether));\r\n    }\r\n\r\n    function buyWithUSDT(uint256 packageamount)\r\n    public \r\n    nonReentrant\r\n    {\r\n        require(msg.sender == tx.origin,\" External Error \");\r\n        (, uint256 token1) = getPrice(packageamount);\r\n        require(USDT.balanceOf(msg.sender) >= token1,\"Insufficient user USDT balance!\");\r\n        require(USDT.transferFrom(_msgSender(),address(this),token1),\" Approve USDT First \");\r\n    }\r\n\r\n    function buyWithAGC(uint256 packageamount)\r\n    public \r\n    nonReentrant\r\n    {\r\n        require(msg.sender == tx.origin,\" External Error \");\r\n        (uint256 token0,) = getPrice(packageamount);\r\n        require(AGC.balanceOf(msg.sender) >= token0,\"Insufficient user AGC balance!\");\r\n        require(AGC.transferFrom(_msgSender(),address(this),token0),\" Approve AGC First \");\r\n    }\r\n\r\n    function UpdateROUTER(IPancakeRouter01 _Router)\r\n    external\r\n    onlyOwner\r\n    {      Router = _Router;        }\r\n\r\n    function emergencyWithdrawToken()\r\n    external \r\n    onlyOwner\r\n    {   require(AGC.transfer(owner(),(AGC.balanceOf(address(this)))),\"transfer failed!\");   }\r\n\r\n    function emergencyWithdrawUSDTToken()\r\n    external\r\n    onlyOwner\r\n    {   require(USDT.transfer(owner(),(USDT.balanceOf(address(this)))),\"transfer failed!\");   }\r\n\r\n    function WithdrawToken(address _tokenAddress)\r\n    external\r\n    onlyOwner\r\n    {   IERC20(_tokenAddress).transfer(owner(),(IERC20(_tokenAddress).balanceOf(address(this))));   }\r\n\r\n    function updateMiniDeposit(uint256 _miniAmount) \r\n    external \r\n    onlyOwner\r\n    { miniDeposit = _miniAmount; }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AGC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Router\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter01\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPancakeRouter01\",\"name\":\"_Router\",\"type\":\"address\"}],\"name\":\"UpdateROUTER\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"WithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageamount\",\"type\":\"uint256\"}],\"name\":\"buyWithAGC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageamount\",\"type\":\"uint256\"}],\"name\":\"buyWithUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawUSDTToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageamount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miniDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_miniAmount\",\"type\":\"uint256\"}],\"name\":\"updateMiniDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "battlemoney", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cfc4cd6e15c5ed5ffaab62696cd1bf2683b8c84516399531a6d8066ede60ec03"}