{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20Vault {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IERC20MetadataVault is IERC20Vault {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\nabstract contract ContextVault {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract OwnableVault is ContextVault {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"OwnableVaultNFT: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"OwnableVaultNFT: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract ERC20Vault is ContextVault, IERC20Vault, IERC20MetadataVault {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(\r\n        address account\r\n    ) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC20Vault: transfer amount exceeds allowance\"\r\n            );\r\n            unchecked {\r\n                _approve(sender, _msgSender(), currentAllowance - amount);\r\n            }\r\n        }\r\n\r\n        _transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) public virtual returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender] + addedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC20Vault: decreased allowance below zero\"\r\n        );\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20Vault: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20Vault: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(\r\n            senderBalance >= amount,\r\n            \"ERC20Vault: transfer amount exceeds balance\"\r\n        );\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20Vault: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20Vault: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20Vault: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function burn(uint256 amount) public virtual {\r\n        require(_msgSender() != address(0), \"ERC20Vault: burn from the zero address\");\r\n        require(amount > 0, \"ERC20Vault: burn amount exceeds balance\");\r\n        require(_balances[_msgSender()] >= amount, \"ERC20Vault: burn amount exceeds balance\");\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20Vault: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20Vault: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\ninterface IUniswapV2FactoryVault {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2PairVault {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint value,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint amount0,\r\n        uint amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n    external\r\n    view\r\n    returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01Vault {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    payable\r\n    returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02Vault is IUniswapV2Router01Vault {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface ITheVaultTicker {\r\n    function mintNFT(address to, uint256 tokenId) external;\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function buyback(uint256 _tokenId, address newOwner) external;\r\n}\r\n\r\ncontract SakaiVaultProtocol is ERC20Vault, OwnableVault {\r\n    address public committedTokenAddress;\r\n    address public stakingAddress;\r\n    address public charityAddress;\r\n    uint256 public startingAt;\r\n    uint256 public endingAt;\r\n    uint256 public defaultEligibleDays;\r\n    uint256 public eligibleIndex;\r\n    uint256 public startEligibleIndex;\r\n    uint256 public startBalanceAmount;\r\n    uint256 public pricePerTicket;\r\n    uint256 public periodEligible;\r\n    uint256 public pickWinnerLoop;\r\n    uint256 public totalLockedAmountForReward;\r\n\r\n    address public uniswapV2RouterAddress;\r\n    address public busdAddress;\r\n    address public nftAddress;\r\n\r\n    struct Buyers {\r\n        address ownerAddress;\r\n        uint256 amountUSD;\r\n        uint256 amountSAKAI;\r\n        uint256 ticketId;\r\n        uint256 buyAt;\r\n        uint256 claimAt;\r\n        uint256 amountReward;\r\n        uint256 period;\r\n    }\r\n\r\n    mapping(uint256 => Buyers) public ticketBuyers;\r\n\r\n    mapping(uint256 => address) public eligibleAddresses;\r\n    mapping(uint256 => uint256) public eligibleAmounts;\r\n    mapping(uint256 => uint256) public periodAccumulateAmount;\r\n    mapping(uint256 => uint256[]) public periodWinnerIndex;\r\n\r\n    uint256 public percentFirstWinner;\r\n    uint256 public percentSecondWinner;\r\n    uint256 public percentThirdWinner;\r\n    uint256 public percentFourthWinner;\r\n    uint256 public percentStaking;\r\n\r\n    uint256 public percentTaxWithdrawlStaking;\r\n    uint256 public percentTaxWithdrawlCharity;\r\n    bool public isAutoPickWinnerEnable;\r\n\r\n    event UpdateEligibleDays(uint256 _days);\r\n    event ResetEligible(uint256 startingAt, uint256 endingAt, uint256 defaultDays);\r\n    event UpdateCommittedTokenAddress(address _committedTokenAddress);\r\n    event UpdateStakingAddress(address _stakingAddress);\r\n    event UpdateCharityAddress(address _charityAddress);\r\n    event UpdateRouterAddress(address _uniswapV2RouterAddress);\r\n    event UpdateBusdAddress(address _busdAddress);\r\n    event Buy(address _buyer, uint256 _amount, uint256 _numberOfTickets, uint256 _valueInBUSD, uint256 _amountBuy);\r\n    event UpdatePercentWinner(uint256 _percentFirstWinner, uint256 _percentSecondWinner, uint256 _percentThirdWinner, uint256 _percentFourthWinner, uint256 _percentStaking);\r\n    event UpdatePercentTaxClaim(uint256 _percentTaxWithdrawlStaking, uint256 _percentTaxWithdrawlCharity);\r\n    event UpdateNFTAddress(address _nftAddress);\r\n    event ClaimReward(address _claimer, uint256 _tokenId, uint256 _amount);\r\n    event PricePerTicket(uint256 _pricePerTicket);\r\n    event UpdateIsAutoPickWinnerEnable(bool state);\r\n\r\n    constructor(\r\n        address _commitedTokenAddress,\r\n        address _charityAddress,\r\n        address _nftAddress,\r\n        address _usdtAddress\r\n    )  ERC20Vault(\"Sakai Vault Protocol\", \"Vault\") {\r\n        committedTokenAddress = _commitedTokenAddress;\r\n        stakingAddress = msg.sender;\r\n        defaultEligibleDays = 5 days;\r\n        eligibleIndex = 0;\r\n        uniswapV2RouterAddress = getRouterAddress();\r\n        busdAddress = _usdtAddress;\r\n        nftAddress = _nftAddress;\r\n        charityAddress = _charityAddress;\r\n\r\n        percentFirstWinner = 30;\r\n        percentSecondWinner = 10;\r\n        percentThirdWinner = 8;\r\n        percentFourthWinner = 5;\r\n        percentStaking = 47;\r\n\r\n        percentTaxWithdrawlStaking = 3;\r\n        percentTaxWithdrawlCharity = 2;\r\n        pricePerTicket = 10 * 10 ** 18;\r\n\r\n        isAutoPickWinnerEnable = true;\r\n\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getRouterAddress() public view returns (address) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        if (id == 97) return 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\r\n        else if (id == 56) return 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n        else if (id == 1) return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        else return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    }\r\n\r\n    function _resetEligible() internal {\r\n        startingAt = block.timestamp;\r\n        endingAt = startingAt + defaultEligibleDays;\r\n        startEligibleIndex = eligibleIndex;\r\n        startBalanceAmount = 0;\r\n        periodEligible += 1;\r\n        emit ResetEligible(startingAt, endingAt, defaultEligibleDays);\r\n    }\r\n\r\n\r\n    function resetEligible() public onlyOwner {\r\n        require(block.timestamp > endingAt, \"Raffle is still running\");\r\n        _resetEligible();\r\n    }\r\n\r\n    function stopEligible() public onlyOwner {\r\n        require(block.timestamp > endingAt, \"Raffle is still running\");\r\n        startingAt = 0;\r\n        endingAt = 0;\r\n    }\r\n\r\n    function updatePricePerTicket(uint256 _pricePerTicket) public onlyOwner {\r\n        pricePerTicket = _pricePerTicket;\r\n        emit PricePerTicket(_pricePerTicket);\r\n    }\r\n\r\n    function updateIsAutoPickWinner(bool state) public onlyOwner {\r\n        isAutoPickWinnerEnable = state;\r\n        emit UpdateIsAutoPickWinnerEnable(state);\r\n    }\r\n\r\n    function updateDefaultEligibleDays(uint256 _days) public onlyOwner {\r\n        defaultEligibleDays = _days;\r\n        emit UpdateEligibleDays(_days);\r\n    }\r\n\r\n    function updateCommittedTokenAddress(address _committedTokenAddress) public onlyOwner {\r\n        require(_committedTokenAddress != address(0), \"Invalid address\");\r\n        committedTokenAddress = _committedTokenAddress;\r\n        emit UpdateCommittedTokenAddress(_committedTokenAddress);\r\n    }\r\n\r\n    function updateStakingAddress(address _stakingAddress) public onlyOwner {\r\n        require(_stakingAddress != address(0), \"Invalid address\");\r\n        stakingAddress = _stakingAddress;\r\n        emit UpdateStakingAddress(_stakingAddress);\r\n    }\r\n\r\n    function updateCharityAddress(address _charityAddress) public onlyOwner {\r\n        require(_charityAddress != address(0), \"Invalid address\");\r\n        charityAddress = _charityAddress;\r\n        emit UpdateCharityAddress(_charityAddress);\r\n    }\r\n\r\n    function updateRouterAddress(address _uniswapV2RouterAddress) public onlyOwner {\r\n        require(_uniswapV2RouterAddress != address(0), \"Invalid address\");\r\n        uniswapV2RouterAddress = _uniswapV2RouterAddress;\r\n        emit UpdateRouterAddress(_uniswapV2RouterAddress);\r\n    }\r\n\r\n    function updateBusdAddress(address _busdAddress) public onlyOwner {\r\n        require(_busdAddress != address(0), \"Invalid address\");\r\n        busdAddress = _busdAddress;\r\n        emit UpdateBusdAddress(_busdAddress);\r\n    }\r\n\r\n    function updateNFTAddress(address _nftAddress) public onlyOwner {\r\n        require(_nftAddress != address(0), \"Invalid address\");\r\n        nftAddress = _nftAddress;\r\n        emit UpdateNFTAddress(_nftAddress);\r\n    }\r\n\r\n    function updatePercentWinner(uint256 _percentFirstWinner, uint256 _percentSecondWinner, uint256 _percentThirdWinner, uint256 _percentFourthWinner, uint256 _percentStaking) public onlyOwner {\r\n        percentFirstWinner = _percentFirstWinner;\r\n        percentSecondWinner = _percentSecondWinner;\r\n        percentThirdWinner = _percentThirdWinner;\r\n        percentFourthWinner = _percentFourthWinner;\r\n        percentStaking = _percentStaking;\r\n        require(percentFirstWinner + percentSecondWinner + percentThirdWinner + percentFourthWinner + percentStaking == 100, \"Total percent must be 100\");\r\n        emit UpdatePercentWinner(_percentFirstWinner, _percentSecondWinner, _percentThirdWinner, _percentFourthWinner, _percentStaking);\r\n    }\r\n\r\n    function updatePercentTaxClaim(uint256 _percentTaxWithdrawlStaking, uint256 _percentTaxWithdrawlCharity) public onlyOwner {\r\n        percentTaxWithdrawlStaking = _percentTaxWithdrawlStaking;\r\n        percentTaxWithdrawlCharity = _percentTaxWithdrawlCharity;\r\n        require(percentTaxWithdrawlStaking + percentTaxWithdrawlCharity <= 25, \"Total percent must be less than or equal to 25\");\r\n        emit UpdatePercentTaxClaim(_percentTaxWithdrawlStaking, _percentTaxWithdrawlCharity);\r\n    }\r\n\r\n\r\n    function buy(uint256 numberOfTickets) public returns (uint256[] memory) {\r\n        require(startingAt > 0, \"Raffle is not started\");\r\n        require(block.timestamp >= startingAt, \"Raffle is not started\");\r\n        require(numberOfTickets > 0, \"Amount must be greater than 0\");\r\n\r\n        if(isAutoPickWinnerEnable && block.timestamp >= endingAt && (eligibleIndex - startEligibleIndex >= 4)) _pickWinners(true);\r\n\r\n        uint256 amountUSDT = numberOfTickets * pricePerTicket;\r\n        address[] memory path = new address[](2);\r\n        path[0] = busdAddress;\r\n        path[1] = committedTokenAddress;\r\n        uint[] memory amounts = IUniswapV2Router02Vault(uniswapV2RouterAddress).getAmountsOut(amountUSDT, path);\r\n        IERC20Vault(committedTokenAddress).transferFrom(msg.sender, address(this), amounts[1]);\r\n        uint256[] memory ticketIds = new uint256[](numberOfTickets);\r\n        for (uint256 i = 0; i < numberOfTickets; i++) {\r\n            ITheVaultTicker(nftAddress).mintNFT(msg.sender, eligibleIndex);\r\n            eligibleAddresses[eligibleIndex] = msg.sender;\r\n            ticketBuyers[eligibleIndex].ticketId = eligibleIndex;\r\n            ticketBuyers[eligibleIndex].ownerAddress = msg.sender;\r\n            ticketBuyers[eligibleIndex].buyAt = block.timestamp;\r\n            ticketBuyers[eligibleIndex].amountUSD = pricePerTicket;\r\n            ticketBuyers[eligibleIndex].period = periodEligible;\r\n            ticketIds[i] = i;\r\n            eligibleIndex++;\r\n        }\r\n        periodAccumulateAmount[periodEligible] += amounts[1];\r\n        emit Buy(msg.sender, amounts[0], numberOfTickets, amountUSDT, amounts[0]);\r\n        return ticketIds;\r\n    }\r\n\r\n    function _pickWinners(bool withRestart) internal {\r\n        require(block.timestamp > endingAt, \"Raffle is still running\");\r\n        require(eligibleIndex > startEligibleIndex, \"No one is eligible\");\r\n        require((eligibleIndex - startEligibleIndex) >= 4, \"Not enough eligible\");\r\n        uint256 randomFactor = 1001 + periodEligible;\r\n        uint256 totalEligibleAmountPeriod = periodAccumulateAmount[periodEligible];\r\n        uint256[] memory winnerIndex = getRandomNumbers(4, startEligibleIndex, eligibleIndex, randomFactor);\r\n\r\n        periodWinnerIndex[periodEligible] = (winnerIndex);\r\n\r\n        uint256 firstWinnerAmount = totalEligibleAmountPeriod * percentFirstWinner / 100;\r\n        uint256 secondWinnerAmount = totalEligibleAmountPeriod * percentSecondWinner / 100;\r\n        uint256 thirdWinnerAmount = totalEligibleAmountPeriod * percentThirdWinner / 100;\r\n        uint256 fourthWinnerAmount = totalEligibleAmountPeriod * percentFourthWinner / 100;\r\n        uint256 stakingAmount = totalEligibleAmountPeriod * percentStaking / 100;\r\n\r\n        eligibleAmounts[winnerIndex[0]] = firstWinnerAmount;\r\n        eligibleAmounts[winnerIndex[1]] = secondWinnerAmount;\r\n        eligibleAmounts[winnerIndex[2]] = thirdWinnerAmount;\r\n        eligibleAmounts[winnerIndex[3]] = fourthWinnerAmount;\r\n        IERC20Vault(committedTokenAddress).transfer(stakingAddress, stakingAmount);\r\n\r\n        ticketBuyers[winnerIndex[0]].amountReward = firstWinnerAmount;\r\n        ticketBuyers[winnerIndex[1]].amountReward = secondWinnerAmount;\r\n        ticketBuyers[winnerIndex[2]].amountReward = thirdWinnerAmount;\r\n        ticketBuyers[winnerIndex[3]].amountReward = fourthWinnerAmount;\r\n        totalLockedAmountForReward += firstWinnerAmount;\r\n        totalLockedAmountForReward += secondWinnerAmount;\r\n        totalLockedAmountForReward += thirdWinnerAmount;\r\n        totalLockedAmountForReward += fourthWinnerAmount;\r\n\r\n        if(withRestart) {\r\n            _resetEligible();\r\n        } else {\r\n            startingAt = 0;\r\n            endingAt = 0;\r\n        }\r\n    }\r\n\r\n    function pickWinners(bool withRestart) public onlyOwner {\r\n        _pickWinners(withRestart);\r\n    }\r\n\r\n\r\n    function getRandomNumbers(uint256 count, uint256 min, uint256 max, uint256 randomFactor) public returns (uint256[] memory) {\r\n        require(count > 0, \"Count must be greater than 0\");\r\n        require(min < max, \"Invalid range\");\r\n\r\n        uint256[] memory randomNumbers = new uint256[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            randomNumbers[i] = getRandomNumber(min, (max-1), i, randomFactor);\r\n            // Prevent duplicate random numbers\r\n            for (uint256 j = 0; j < i; j++) {\r\n                if (randomNumbers[j] == randomNumbers[i]) {\r\n                    i--;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomNumbers;\r\n    }\r\n\r\n    function getRandomNumber(uint256 min, uint256 max, uint256 loop, uint256 randomFactor) internal returns (uint256) {\r\n        require(min < max, \"Invalid range\");\r\n        pickWinnerLoop += 1;\r\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(((block.timestamp*randomFactor) - (loop*pickWinnerLoop)), msg.sender, block.timestamp))) % (max - min + 1);\r\n        return randomNumber + min;\r\n    }\r\n\r\n    function buyback(uint256 tokenId) public {\r\n        require(eligibleAmounts[tokenId] > 0, \"No reward\");\r\n        require(ITheVaultTicker(nftAddress).ownerOf(tokenId) == msg.sender, \"You are not the owner\");\r\n        if(isAutoPickWinnerEnable && block.timestamp >= endingAt && (eligibleIndex - startEligibleIndex >= 4)) _pickWinners(true);\r\n\r\n        uint256 amount = eligibleAmounts[tokenId];\r\n        totalLockedAmountForReward -= amount;\r\n        if(percentTaxWithdrawlStaking > 0){\r\n            uint256 amountForStaking = amount * (percentTaxWithdrawlStaking) / 100;\r\n            amount -= amountForStaking;\r\n            IERC20Vault(committedTokenAddress).transfer(stakingAddress, amountForStaking);\r\n        }\r\n        if(percentTaxWithdrawlCharity > 0){\r\n            uint256 amountForCharity = amount * (percentTaxWithdrawlCharity) / 100;\r\n            amount -= amountForCharity;\r\n            IERC20Vault(committedTokenAddress).transfer(charityAddress, amountForCharity);\r\n        }\r\n        eligibleAmounts[tokenId] = 0;\r\n        ticketBuyers[tokenId].claimAt = block.timestamp;\r\n        address nftOwner = ITheVaultTicker(nftAddress).ownerOf(tokenId);\r\n        IERC20Vault(committedTokenAddress).transfer(nftOwner, amount);\r\n        ITheVaultTicker(nftAddress).buyback(tokenId, owner());\r\n        emit ClaimReward(nftOwner, tokenId, amount);\r\n    }\r\n\r\n    function getPeriodWinnerIndex(uint256 period) public view returns (uint256[] memory) {\r\n        return periodWinnerIndex[period];\r\n    }\r\n\r\n    function getPeriodWinnerAddress(uint256 period) public view returns(address[] memory) {\r\n        uint256[] memory winnerIndex = periodWinnerIndex[period];\r\n        address[] memory winnerAddress = new address[](winnerIndex.length);\r\n        for(uint256 i = 0; i < winnerIndex.length; i++) {\r\n            winnerAddress[i] = ITheVaultTicker(nftAddress).ownerOf(winnerIndex[i]);\r\n        }\r\n        return winnerAddress;\r\n    }\r\n\r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return periodEligible - 1;\r\n    }\r\n\r\n    function getEligibleByOwner(address _owner) public view returns(uint256[] memory){\r\n        uint256 count = 0;\r\n        for(uint256 i = 0; i < eligibleIndex; i++) {\r\n            if(eligibleAddresses[i] == _owner) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory indexes = new uint256[](count);\r\n\r\n        uint256 selectedId = 0;\r\n        for(uint256 i = 0; i < eligibleIndex; i++) {\r\n            if(eligibleAddresses[i] == _owner) {\r\n                indexes[selectedId] = i;\r\n                selectedId++;\r\n            }\r\n        }\r\n        return indexes;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_commitedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_charityAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numberOfTickets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_valueInBUSD\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountBuy\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_pricePerTicket\",\"type\":\"uint256\"}],\"name\":\"PricePerTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endingAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"defaultDays\",\"type\":\"uint256\"}],\"name\":\"ResetEligible\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_busdAddress\",\"type\":\"address\"}],\"name\":\"UpdateBusdAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_charityAddress\",\"type\":\"address\"}],\"name\":\"UpdateCharityAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_committedTokenAddress\",\"type\":\"address\"}],\"name\":\"UpdateCommittedTokenAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"UpdateEligibleDays\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"UpdateIsAutoPickWinnerEnable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"UpdateNFTAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_percentTaxWithdrawlStaking\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_percentTaxWithdrawlCharity\",\"type\":\"uint256\"}],\"name\":\"UpdatePercentTaxClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_percentFirstWinner\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_percentSecondWinner\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_percentThirdWinner\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_percentFourthWinner\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_percentStaking\",\"type\":\"uint256\"}],\"name\":\"UpdatePercentWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_uniswapV2RouterAddress\",\"type\":\"address\"}],\"name\":\"UpdateRouterAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_stakingAddress\",\"type\":\"address\"}],\"name\":\"UpdateStakingAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTickets\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"buyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"committedTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultEligibleDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eligibleAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eligibleAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eligibleIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endingAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getEligibleByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getPeriodWinnerAddress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getPeriodWinnerIndex\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"randomFactor\",\"type\":\"uint256\"}],\"name\":\"getRandomNumbers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAutoPickWinnerEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentFirstWinner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentFourthWinner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentSecondWinner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentTaxWithdrawlCharity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentTaxWithdrawlStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentThirdWinner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodAccumulateAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodEligible\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodWinnerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pickWinnerLoop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"withRestart\",\"type\":\"bool\"}],\"name\":\"pickWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pricePerTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetEligible\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBalanceAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startEligibleIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopEligible\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketBuyers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSAKAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedAmountForReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2RouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_busdAddress\",\"type\":\"address\"}],\"name\":\"updateBusdAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_charityAddress\",\"type\":\"address\"}],\"name\":\"updateCharityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_committedTokenAddress\",\"type\":\"address\"}],\"name\":\"updateCommittedTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"updateDefaultEligibleDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"updateIsAutoPickWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"updateNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentTaxWithdrawlStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentTaxWithdrawlCharity\",\"type\":\"uint256\"}],\"name\":\"updatePercentTaxClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentFirstWinner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentSecondWinner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentThirdWinner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentFourthWinner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentStaking\",\"type\":\"uint256\"}],\"name\":\"updatePercentWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pricePerTicket\",\"type\":\"uint256\"}],\"name\":\"updatePricePerTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV2RouterAddress\",\"type\":\"address\"}],\"name\":\"updateRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingAddress\",\"type\":\"address\"}],\"name\":\"updateStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SakaiVaultProtocol", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000043b35e89d15b91162dea1c51133c4c93bdd1c4af000000000000000000000000e5c972d724676a6abe928e0cd730738f8e2c0474000000000000000000000000439596ccb842f2a556677ab62f9d985e00128fea00000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://350da37eb5338fc61a7b4afdaf5fa0ed4e962799f617ab6d2c5fab83c7d99c77"}