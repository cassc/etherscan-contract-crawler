{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/oracles/Pancakeswapv2Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {PriceLibrary as Prices} from \\\"../libs/BscPriceLibrary.sol\\\";\\nimport \\\"../libs/FixedPoint.sol\\\";\\nimport \\\"../recipe/PancakeswapV2Library.sol\\\";\\nimport \\\"../interfaces/IUsdcOracle.sol\\\";\\n\\ncontract Pancakeswapv2Oracle is IUsdcOracle, AccessControl {\\n    /* ==========  Libraries  ========== */\\n\\n    using Prices for address;\\n    using Prices for Prices.PriceObservation;\\n    using Prices for Prices.TwoWayAveragePrice;\\n    using FixedPoint for FixedPoint.uq112x112;\\n    using FixedPoint for FixedPoint.uq144x112;\\n\\n    /* ==========  Constants  ========== */\\n\\n    // Period over which prices are observed, each period should have 1 price observation.\\n    // Minimum time elapsed between price observations\\n    uint32 public immutable MINIMUM_OBSERVATION_DELAY;\\n\\n    address public immutable USDC; // 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address public immutable WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public immutable uniswapFactory; // 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\\n\\n    uint32 public immutable maxObservationAge;\\n\\n    /* ==========  Storage  ========== */\\n\\n    uint32 public observationPeriod;\\n    // Price observations for tokens indexed by time period.\\n    mapping(address => mapping(uint256 => Prices.PriceObservation)) internal priceObservations;\\n\\n    /* ==========  Events  ========== */\\n\\n    event PriceUpdated(\\n        address indexed token,\\n        uint224 tokenPriceCumulativeLast,\\n        uint224 ethPriceCumulativeLast\\n    );\\n\\n    /* ==========  Constructor  ========== */\\n\\n    constructor(address _uniswapFactory, uint32 _initialObservationPeriod, address _usdc, address _weth) {\\n        require(_uniswapFactory != address(0), \\\"ERR_UNISWAPV2_FACTORY_INIT\\\");\\n        require(_weth!= address(0), \\\"ERR_WETH_INIT\\\");\\n        uniswapFactory = _uniswapFactory;\\n        USDC = _usdc;\\n        WETH = _weth;\\n        observationPeriod = _initialObservationPeriod;\\n        MINIMUM_OBSERVATION_DELAY = _initialObservationPeriod / 2;\\n        maxObservationAge = _initialObservationPeriod * 2;\\n    }\\n\\n    /* ==========  External Functions  ========== */\\n\\n    function getLastPriceObservation(address token)\\n        external\\n        view\\n        returns (Prices.PriceObservation memory)\\n    {\\n        Prices.PriceObservation memory current = Prices.observeTwoWayPrice(\\n            uniswapFactory,\\n            token,\\n            WETH\\n        );\\n        Prices.PriceObservation memory previous = _getLatestUsableObservation(\\n            token,\\n            current.timestamp\\n        );\\n        return previous;\\n    }\\n\\n    /**\\n     * @dev Gets the price observation at `observationIndex` for `token`.\\n     *\\n     * Note: This does not assert that there is an observation for that index,\\n     * this should be verified by the recipient.\\n     */\\n    function getPriceObservation(address token, uint256 observationIndex)\\n        external\\n        view\\n        returns (Prices.PriceObservation memory)\\n    {\\n        return priceObservations[token][observationIndex];\\n    }\\n\\n    function canUpdatePrice(address token) external view returns (bool) {\\n        Prices.PriceObservation memory newObservation = Prices\\n            .observeTwoWayPrice(uniswapFactory, token, WETH);\\n        // We use the observation's timestamp rather than `now` because the\\n        // UniSwap pair may not have updated the price this block.\\n        uint256 observationIndex = observationIndexOf(newObservation.timestamp);\\n        // If this period already has an observation, return false.\\n        if (priceObservations[token][observationIndex].timestamp != 0)\\n            return false;\\n        // An observation can be made if the last update was at least half a period ago.\\n        uint32 timeElapsed = newObservation.timestamp -\\n            priceObservations[token][observationIndex - 1].timestamp;\\n        return timeElapsed >= MINIMUM_OBSERVATION_DELAY;\\n    }\\n\\n    /**\\n     * @dev Returns the TwoWayAveragePrice structs representing the average price of\\n     * weth in terms of each token in `tokens` and the average price of each token\\n     * in terms of weth.\\n     *\\n     * Note: Requires that the token has a price observation between 0.5\\n     * and 2 periods old.\\n     */\\n    function computeTwoWayAveragePrices(address[] memory tokens)\\n        external\\n        view\\n        returns (Prices.TwoWayAveragePrice[] memory averagePrices, uint256 earliestTimestamp)\\n    {\\n        uint256 len = tokens.length;\\n        averagePrices = new Prices.TwoWayAveragePrice[](len);\\n        uint256 timestamp;\\n        for (uint256 i = 0; i < len; i++) {\\n            (averagePrices[i], timestamp) = computeTwoWayAveragePrice(tokens[i]);\\n            if (timestamp < earliestTimestamp) {\\n                earliestTimestamp = timestamp;\\n            }\\n        }\\n    }\\n\\n    function canUpdateTokenPrices() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates the prices of multiple tokens.\\n     *\\n     * @return updates Array of boolean values indicating which tokens\\n     * successfully updated their prices.\\n     */\\n    function updateTokenPrices(address[] memory tokens)\\n        external\\n        returns (bool[] memory updates)\\n    {\\n        updateWethPrice();\\n        updates = new bool[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            updates[i] = updatePrice(tokens[i]);\\n        }\\n    }\\n\\n    function tokenETHValue(address tokenIn, uint256 amount)\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        if (tokenIn == WETH) {\\n            return (amount, block.timestamp);\\n        }\\n\\n        return computeAverageAmountIn(tokenIn, amount);\\n    }\\n\\n    /**\\n     * @dev Returns the UQ112x112 structs representing the average price of\\n     * weth in terms of each token in `tokens`.\\n     */\\n    function computeAverageEthPrices(address[] memory tokens)\\n        external\\n        view\\n        returns (FixedPoint.uq112x112[] memory averagePrices, uint256 earliestTimestamp)\\n    {\\n        uint256 len = tokens.length;\\n        averagePrices = new FixedPoint.uq112x112[](len);\\n        uint256 timestamp;\\n        for (uint256 i = 0; i < len; i++) {\\n            (averagePrices[i], timestamp) = computeAverageEthPrice(tokens[i]);\\n            if (timestamp < earliestTimestamp) {\\n                earliestTimestamp = timestamp;\\n            }\\n        }\\n    }\\n\\n    /* ==========  Public  Functions  ========== */\\n\\n    /*\\n     * @dev Updates the latest price observation for a token if allowable.\\n     *\\n     * Note: The price can only be updated once per period, and price\\n     * observations must be made at least half a period apart.\\n     *\\n     * @param token Token to update the price of\\n     * @return didUpdate Whether the token price was updated.\\n     */\\n    // update weth price in usdc\\n    function updateWethPrice() public returns (bool) {\\n        Prices.PriceObservation memory newObservation = Prices\\n            .observeTwoWayPrice(uniswapFactory, WETH, USDC);\\n        // We use the observation's timestamp rather than `now` because the\\n        // UniSwap pair may not have updated the price this block.\\n        uint256 observationIndex = observationIndexOf(newObservation.timestamp);\\n\\n        Prices.PriceObservation storage current = priceObservations[WETH][\\n            observationIndex\\n        ];\\n        if (current.timestamp != 0) {\\n            // If an observation has already been made for this period, do not update.\\n            return false;\\n        }\\n\\n        Prices.PriceObservation memory previous = priceObservations[WETH][\\n            observationIndex - 1\\n        ];\\n        uint256 timeElapsed = newObservation.timestamp - previous.timestamp;\\n        if (timeElapsed < MINIMUM_OBSERVATION_DELAY) {\\n            // If less than half a period has passed since the previous observation, do not update.\\n            return false;\\n        }\\n        priceObservations[WETH][observationIndex] = newObservation;\\n        emit PriceUpdated(\\n            WETH,\\n            newObservation.priceCumulativeLast,\\n            newObservation.ethPriceCumulativeLast\\n        );\\n        return true;\\n    }\\n\\n    function updatePrice(address token) public returns (bool) {\\n        if (token == WETH) return true;\\n\\n        Prices.PriceObservation memory newObservation = Prices\\n            .observeTwoWayPrice(uniswapFactory, token, WETH);\\n        // We use the observation's timestamp rather than `now` because the\\n        // UniSwap pair may not have updated the price this block.\\n        uint256 observationIndex = observationIndexOf(newObservation.timestamp);\\n\\n        Prices.PriceObservation storage current = priceObservations[token][\\n            observationIndex\\n        ];\\n        if (current.timestamp != 0) {\\n            // If an observation has already been made for this period, do not update.\\n            return false;\\n        }\\n\\n        Prices.PriceObservation memory previous = priceObservations[token][\\n            observationIndex - 1\\n        ];\\n        uint256 timeElapsed = newObservation.timestamp - previous.timestamp;\\n        if (timeElapsed < MINIMUM_OBSERVATION_DELAY) {\\n            // If less than half a period has passed since the previous observation, do not update.\\n            return false;\\n        }\\n        priceObservations[token][observationIndex] = newObservation;\\n\\n        emit PriceUpdated(\\n            token,\\n            newObservation.priceCumulativeLast,\\n            newObservation.ethPriceCumulativeLast\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Gets the observation index for `timestamp`\\n     */\\n    function observationIndexOf(uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return timestamp / observationPeriod;\\n    }\\n\\n    /**\\n     * @dev Computes the average value in weth of `amountIn` of `token`.\\n     */\\n    function computeAverageAmountOut(\\n        address token,\\n        address referenceToken,\\n        uint256 amountIn\\n    ) public view returns (uint144 amountOut, uint256 timestamp) {\\n        require(token != USDC, \\\"ERR_INVALID_TOKEN\\\");\\n        if (token == WETH) {\\n            require(referenceToken == USDC, \\\"INCORRECT_REFERENCET\\\");\\n        } else {\\n            require(referenceToken == WETH, \\\"INCORRECT_REFERENCET\\\");\\n        }\\n        FixedPoint.uq112x112 memory priceAverage;\\n        (priceAverage, timestamp) = computeAverageTokenPrice(token, referenceToken);\\n        return (priceAverage.mul(amountIn).decode144(), timestamp);\\n    }\\n\\n    /**\\n     * @dev Computes the average value in `token` of `amountOut` of weth.\\n     */\\n    function computeAverageAmountIn(address token, uint256 amountOut)\\n        public\\n        view\\n        returns (uint144 amountIn, uint256 timestamp)\\n    {\\n        FixedPoint.uq112x112 memory priceAverage;\\n        (priceAverage,timestamp) = computeAverageEthPrice(token);\\n        return (priceAverage.mul(amountOut).decode144(), timestamp);\\n    }\\n\\n    function tokenUsdcValue(address tokenIn, uint256 amount)\\n        public\\n        view\\n        override\\n        returns (uint256, uint256)\\n    {\\n        if (tokenIn == USDC) {\\n            return (amount, block.timestamp);\\n        }\\n        return getPrice(tokenIn, USDC, amount);\\n    }\\n\\n    function getPrice(address base, address quote)\\n        external\\n        view\\n        override\\n        returns (uint256, uint256)\\n    {\\n        uint8 decimals = IERC20Metadata(base).decimals();\\n        uint256 amount = 10 ** decimals;\\n        return getPrice(base, quote, amount);\\n    }\\n\\n    function getPrice(address base, address quote, uint256 amount)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        if (base == WETH) {\\n            return computeAverageAmountOut(base, quote, amount);\\n        }\\n        // tokenWETHValue is number of eth we will get for _amount amount of _tokenIn.\\n        (uint256 tokenWETHValue, uint256 timestamp1) = computeAverageAmountOut(\\n            base,\\n            WETH,\\n            amount\\n        );\\n\\n        //  WETHUsdValue is numver of usdc for tokenWETHValue amount of WETH.\\n        (uint256 WETHquoteValue, uint256 timestamp2) = computeAverageAmountOut(\\n            WETH,\\n            quote,\\n            tokenWETHValue\\n        );\\n        uint256 earliestTimestamp = (timestamp1 < timestamp2) ? timestamp1 : timestamp2;\\n        return (WETHquoteValue, earliestTimestamp);\\n    }\\n\\n    /**\\n     * @dev Returns the UQ112x112 struct representing the average price of\\n     * `token` in terms of usdc.\\n     *\\n     * Note: Requires that the token has a price observation between 0.5\\n     * and 2 periods old.\\n     */\\n    function computeAverageTokenPrice(address token, address referenceToken)\\n        public\\n        view\\n        returns (FixedPoint.uq112x112 memory priceAverage, uint256 timestamp)\\n    {\\n        require(token != USDC, \\\"ERR_INVALID_TOKEN\\\");\\n        if (token == WETH) {\\n            require(referenceToken == USDC, \\\"INCORRECT_REFERENCET\\\");\\n        } else {\\n            require(referenceToken == WETH, \\\"INCORRECT_REFERENCET\\\");\\n        }\\n        // Get the current cumulative price\\n        Prices.PriceObservation memory current = Prices.observeTwoWayPrice(\\n            uniswapFactory,\\n            token,\\n            referenceToken\\n        );\\n        // Get the latest usable price\\n        Prices.PriceObservation memory previous = _getLatestUsableObservation(\\n            token,\\n            current.timestamp\\n        );\\n\\n        return (previous.computeAverageTokenPrice(current), previous.timestamp);\\n    }\\n\\n    /**\\n     * @dev Returns the UQ112x112 struct representing the average price of\\n     * weth in terms of `token`.\\n     *\\n     * Note: Requires that the token has a price observation between 0.5\\n     * and 2 periods old.\\n     */\\n    function computeAverageEthPrice(address token)\\n        public\\n        view\\n        returns (FixedPoint.uq112x112 memory priceAverage, uint256 timestamp)\\n    {\\n        // Get the current cumulative price\\n        Prices.PriceObservation memory current = Prices.observeTwoWayPrice(\\n            uniswapFactory,\\n            token,\\n            WETH\\n        );\\n        // Get the latest usable price\\n        Prices.PriceObservation memory previous = _getLatestUsableObservation(\\n            token,\\n            current.timestamp\\n        );\\n\\n        return (previous.computeAverageEthPrice(current), previous.timestamp);\\n    }\\n\\n    /**\\n     * @dev Returns the TwoWayAveragePrice struct representing the average price of\\n     * weth in terms of `token` and the average price of `token` in terms of weth.\\n     *\\n     * Note: Requires that the token has a price observation between 0.5\\n     * and 2 periods old.\\n     */\\n    function computeTwoWayAveragePrice(address token)\\n        public\\n        view\\n        returns (Prices.TwoWayAveragePrice memory, uint256 timestamp)\\n    {\\n        // Get the current cumulative price\\n        Prices.PriceObservation memory current = Prices.observeTwoWayPrice(\\n            uniswapFactory,\\n            token,\\n            WETH\\n        );\\n        // Get the latest usable price\\n        Prices.PriceObservation memory previous = _getLatestUsableObservation(\\n            token,\\n            current.timestamp\\n        );\\n\\n        return (previous.computeTwoWayAveragePrice(current), previous.timestamp);\\n    }\\n\\n    /* ==========  Internal Observation Functions  ========== */\\n\\n    /**\\n     * @dev Gets the latest price observation which is at least half a period older\\n     * than `timestamp` and at most 2 periods older.\\n     *\\n     * @param token Token to get the latest price for\\n     * @param timestamp Reference timestamp for comparison\\n     */\\n    function _getLatestUsableObservation(address token, uint32 timestamp)\\n        internal\\n        view\\n        returns (Prices.PriceObservation memory observation)\\n    {\\n        uint256 observationIndex = observationIndexOf(timestamp);\\n        uint256 periodTimeElapsed = timestamp % observationPeriod;\\n        // uint256 maxAge = maxObservationAge;\\n        // Before looking at the current observation period, check if it is possible\\n        // for an observation in the current period to be more than half a period old.\\n        if (periodTimeElapsed >= MINIMUM_OBSERVATION_DELAY) {\\n            observation = priceObservations[token][observationIndex];\\n            if (\\n                observation.timestamp != 0 &&\\n                timestamp - observation.timestamp >= MINIMUM_OBSERVATION_DELAY\\n            ) {\\n                return observation;\\n            }\\n        }\\n\\n        // Check the observation for the previous period\\n        observation = priceObservations[token][--observationIndex];\\n        uint256 timeElapsed = timestamp - observation.timestamp;\\n        bool usable = observation.timestamp != 0 &&\\n            timeElapsed >= MINIMUM_OBSERVATION_DELAY;\\n        while (!usable) {\\n            observation = priceObservations[token][--observationIndex];\\n            uint256 obsTime = observation.timestamp;\\n            timeElapsed =\\n                timestamp -\\n                (obsTime == 0 ? observationPeriod * observationIndex : obsTime);\\n            usable =\\n                observation.timestamp != 0 &&\\n                timeElapsed >= MINIMUM_OBSERVATION_DELAY;\\n            require(\\n                timeElapsed <= maxObservationAge,\\n                \\\"ERR_USABLE_PRICE_NOT_FOUND\\\"\\n            );\\n        }\\n        return observation;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/BscPriceLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\n/* ==========  Internal Libraries  ========== */\\nimport \\\"./FixedPoint.sol\\\";\\nimport \\\"./UniswapV2OracleLibrary.sol\\\";\\nimport \\\"../recipe/PancakeswapV2Library.sol\\\";\\n\\nlibrary PriceLibrary {\\n    using FixedPoint for FixedPoint.uq112x112;\\n    using FixedPoint for FixedPoint.uq144x112;\\n\\n    /* ========= Structs ========= */\\n\\n    struct PriceObservation {\\n        uint32 timestamp;\\n        uint224 priceCumulativeLast;\\n        uint224 ethPriceCumulativeLast;\\n    }\\n\\n    /**\\n     * @dev Average prices for a token in terms of weth and weth in terms of the token.\\n     *\\n     * Note: The average weth price is not equivalent to the reciprocal of the average\\n     * token price. See the UniSwap whitepaper for more info.\\n     */\\n    struct TwoWayAveragePrice {\\n        uint224 priceAverage;\\n        uint224 ethPriceAverage;\\n    }\\n\\n    /* ========= View Functions ========= */\\n\\n    function pairInitialized(\\n        address uniswapFactory,\\n        address token,\\n        address weth\\n    ) internal view returns (bool) {\\n        address pair = UniswapV2Library.pairFor(uniswapFactory, token, weth);\\n        (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(pair)\\n            .getReserves();\\n        return reserve0 != 0 && reserve1 != 0;\\n    }\\n\\n    function observePrice(\\n        address uniswapFactory,\\n        address tokenIn,\\n        address quoteToken\\n    )\\n        internal\\n        view\\n        returns (\\n            uint32, /* timestamp */\\n            uint224 /* priceCumulativeLast */\\n        )\\n    {\\n        (address token0, address token1) = UniswapV2Library.sortTokens(\\n            tokenIn,\\n            quoteToken\\n        );\\n        address pair = UniswapV2Library.calculatePair(\\n            uniswapFactory,\\n            token0,\\n            token1\\n        );\\n        if (token0 == tokenIn) {\\n            (\\n                uint256 price0Cumulative,\\n                uint32 blockTimestamp\\n            ) = UniswapV2OracleLibrary.currentCumulativePrice0(pair);\\n            return (blockTimestamp, uint224(price0Cumulative));\\n        } else {\\n            (\\n                uint256 price1Cumulative,\\n                uint32 blockTimestamp\\n            ) = UniswapV2OracleLibrary.currentCumulativePrice1(pair);\\n            return (blockTimestamp, uint224(price1Cumulative));\\n        }\\n    }\\n\\n    /**\\n     * @dev Query the current cumulative price of a token in terms of usdc\\n     * and the current cumulative price of usdc in terms of the token.\\n     */\\n    function observeTwoWayPrice(\\n        address uniswapFactory,\\n        address token,\\n        address usdc\\n    ) internal view returns (PriceObservation memory) {\\n        (address token0, address token1) = UniswapV2Library.sortTokens(\\n            token,\\n            usdc\\n        );\\n        address pair = UniswapV2Library.calculatePair(\\n            uniswapFactory,\\n            token0,\\n            token1\\n        );\\n        // Get the sorted token prices\\n        require(pair != address(0), \\\"pair doesn't exist\\\");\\n\\n        (\\n            uint256 price0Cumulative,\\n            uint256 price1Cumulative,\\n            uint32 blockTimestamp\\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n        // Check which token is weth and which is the token,\\n        // then build the price observation.\\n        if (token0 == token) {\\n            return\\n                PriceObservation({\\n                    timestamp: blockTimestamp,\\n                    priceCumulativeLast: uint224(price0Cumulative),\\n                    ethPriceCumulativeLast: uint224(price1Cumulative)\\n                });\\n        } else {\\n            return\\n                PriceObservation({\\n                    timestamp: blockTimestamp,\\n                    priceCumulativeLast: uint224(price1Cumulative),\\n                    ethPriceCumulativeLast: uint224(price0Cumulative)\\n                });\\n        }\\n    }\\n\\n    /* ========= Utility Functions ========= */\\n\\n    /**\\n     * @dev Computes the average price of a token in terms of weth\\n     * and the average price of weth in terms of a token using two\\n     * price observations.\\n     */\\n    function computeTwoWayAveragePrice(\\n        PriceObservation memory observation1,\\n        PriceObservation memory observation2\\n    ) internal pure returns (TwoWayAveragePrice memory) {\\n        uint32 timeElapsed = uint32(\\n            observation2.timestamp - observation1.timestamp\\n        );\\n        FixedPoint.uq112x112 memory priceAverage = UniswapV2OracleLibrary\\n            .computeAveragePrice(\\n                observation1.priceCumulativeLast,\\n                observation2.priceCumulativeLast,\\n                timeElapsed\\n            );\\n        FixedPoint.uq112x112 memory ethPriceAverage = UniswapV2OracleLibrary\\n            .computeAveragePrice(\\n                observation1.ethPriceCumulativeLast,\\n                observation2.ethPriceCumulativeLast,\\n                timeElapsed\\n            );\\n        return\\n            TwoWayAveragePrice({\\n                priceAverage: priceAverage._x,\\n                ethPriceAverage: ethPriceAverage._x\\n            });\\n    }\\n\\n    function computeAveragePrice(\\n        uint32 timestampStart,\\n        uint224 priceCumulativeStart,\\n        uint32 timestampEnd,\\n        uint224 priceCumulativeEnd\\n    ) internal pure returns (FixedPoint.uq112x112 memory) {\\n        return\\n            UniswapV2OracleLibrary.computeAveragePrice(\\n                priceCumulativeStart,\\n                priceCumulativeEnd,\\n                uint32(timestampEnd - timestampStart)\\n            );\\n    }\\n\\n    /**\\n     * @dev Computes the average price of the token the price observations\\n     * are for in terms of weth.\\n     */\\n    function computeAverageTokenPrice(\\n        PriceObservation memory observation1,\\n        PriceObservation memory observation2\\n    ) internal pure returns (FixedPoint.uq112x112 memory) {\\n        return\\n            UniswapV2OracleLibrary.computeAveragePrice(\\n                observation1.priceCumulativeLast,\\n                observation2.priceCumulativeLast,\\n                uint32(observation2.timestamp - observation1.timestamp)\\n            );\\n    }\\n\\n    /**\\n     * @dev Computes the average price of weth in terms of the token\\n     * the price observations are for.\\n     */\\n    function computeAverageEthPrice(\\n        PriceObservation memory observation1,\\n        PriceObservation memory observation2\\n    ) internal pure returns (FixedPoint.uq112x112 memory) {\\n        return\\n            UniswapV2OracleLibrary.computeAveragePrice(\\n                observation1.ethPriceCumulativeLast,\\n                observation2.ethPriceCumulativeLast,\\n                uint32(observation2.timestamp - observation1.timestamp)\\n            );\\n    }\\n\\n    /**\\n     * @dev Compute the average value in weth of `tokenAmount` of the\\n     * token that the average price values are for.\\n     */\\n    function computeAverageEthForTokens(\\n        TwoWayAveragePrice memory prices,\\n        uint256 tokenAmount\\n    ) internal pure returns (uint144) {\\n        return\\n            FixedPoint\\n                .uq112x112(prices.priceAverage)\\n                .mul(tokenAmount)\\n                .decode144();\\n    }\\n\\n    /**\\n     * @dev Compute the average value of `wethAmount` weth in terms of\\n     * the token that the average price values are for.\\n     */\\n    function computeAverageTokensForEth(\\n        TwoWayAveragePrice memory prices,\\n        uint256 wethAmount\\n    ) internal pure returns (uint144) {\\n        return\\n            FixedPoint\\n                .uq112x112(prices.ethPriceAverage)\\n                .mul(wethAmount)\\n                .decode144();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\n/************************************************************************************************\\nFrom https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/FixedPoint.sol\\nCopied from the github repository at commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\\nModifications:\\n- Removed `sqrt` function\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\\n    uint256 private constant Q224 = Q112 << RESOLUTION;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x)\\n        internal\\n        pure\\n        returns (uq112x112 memory)\\n    {\\n        require(x != 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint256 y)\\n        internal\\n        pure\\n        returns (uq144x112 memory)\\n    {\\n        uint256 z;\\n        require(\\n            y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x),\\n            \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\"\\n        );\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator)\\n        internal\\n        pure\\n        returns (uq112x112 memory)\\n    {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    function reciprocal(uq112x112 memory self)\\n        internal\\n        pure\\n        returns (uq112x112 memory)\\n    {\\n        require(self._x != 0, \\\"FixedPoint: ZERO_RECIPROCAL\\\");\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUsdcOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\ninterface IUsdcOracle {\\n    function tokenUsdcValue(address token, uint256 amount) external view \\n        returns (uint256 usdcValue, uint256 oldestObservation);\\n    function getPrice(address base, address quote) external view \\n        returns (uint256 value, uint256 oldestObservation);\\n    function canUpdateTokenPrices() external pure \\n        returns (bool);\\n    function updateTokenPrices(address[] memory tokens) external \\n        returns (bool[] memory updates);\\n}\\n\"\r\n    },\r\n    \"contracts/recipe/PancakeswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB)\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n        (token0, token1) = tokenA < tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\\"ff\\\",\\n                            factory,\\n                            keccak256(abi.encodePacked(token0, token1)),\\n                            hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\\n            pairFor(factory, tokenA, tokenB)\\n        ).getReserves();\\n        (reserveA, reserveB) = tokenA == token0\\n            ? (reserve0, reserve1)\\n            : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\n        require(\\n            reserveA > 0 && reserveB > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        amountB = (amountA * reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        require(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(\\n            reserveIn > 0 && reserveOut > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint256 amountInWithFee = amountIn * (997);\\n        uint256 numerator = amountInWithFee * (reserveOut);\\n        uint256 denominator = reserveIn * (1000) + (amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountIn) {\\n        require(amountOut > 0, \\\"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n        require(\\n            reserveIn > 0 && reserveOut > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint256 numerator = reserveIn * (amountOut) * (1000);\\n        uint256 denominator = (reserveOut - amountOut) * (997);\\n        amountIn = (numerator / denominator) + (1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        address factory,\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\\n                factory,\\n                path[i],\\n                path[i + 1]\\n            );\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\\n                factory,\\n                path[i - 1],\\n                path[i]\\n            );\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    function calculatePair(\\n        address factory,\\n        address token0,\\n        address token1\\n    ) internal pure returns (address pair) {\\n        pair = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\\"ff\\\",\\n                            factory,\\n                            keccak256(abi.encodePacked(token0, token1)),\\n                            hex\\\"00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\\\"\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\n/* ==========  Internal Interfaces  ========== */\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\n\\n/* ==========  Internal Libraries  ========== */\\nimport \\\"./FixedPoint.sol\\\";\\n\\n/************************************************************************************************\\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash 6d03bede0a97c72323fa1c379ed3fdf7231d0b26.\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2**32);\\n    }\\n\\n    // produces the cumulative prices using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(address pair)\\n        internal\\n        view\\n        returns (\\n            uint256 price0Cumulative,\\n            uint256 price1Cumulative,\\n            uint32 blockTimestamp\\n        )\\n    {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        ) = IUniswapV2Pair(pair).getReserves();\\n        require(\\n            reserve0 != 0 && reserve1 != 0,\\n            \\\"UniswapV2OracleLibrary::currentCumulativePrices: Pair has no reserves.\\\"\\n        );\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += (uint256(\\n                FixedPoint.fraction(reserve1, reserve0)._x\\n            ) * timeElapsed);\\n            // counterfactual\\n            price1Cumulative += (uint256(\\n                FixedPoint.fraction(reserve0, reserve1)._x\\n            ) * timeElapsed);\\n        }\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    // only gets the first price\\n    function currentCumulativePrice0(address pair)\\n        internal\\n        view\\n        returns (uint256 price0Cumulative, uint32 blockTimestamp)\\n    {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        ) = IUniswapV2Pair(pair).getReserves();\\n        require(\\n            reserve0 != 0 && reserve1 != 0,\\n            \\\"UniswapV2OracleLibrary::currentCumulativePrice0: Pair has no reserves.\\\"\\n        );\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += (uint256(\\n                FixedPoint.fraction(reserve1, reserve0)._x\\n            ) * timeElapsed);\\n        }\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    // only gets the second price\\n    function currentCumulativePrice1(address pair)\\n        internal\\n        view\\n        returns (uint256 price1Cumulative, uint32 blockTimestamp)\\n    {\\n        blockTimestamp = currentBlockTimestamp();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        ) = IUniswapV2Pair(pair).getReserves();\\n        require(\\n            reserve0 != 0 && reserve1 != 0,\\n            \\\"UniswapV2OracleLibrary::currentCumulativePrice1: Pair has no reserves.\\\"\\n        );\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price1Cumulative += (uint256(\\n                FixedPoint.fraction(reserve0, reserve1)._x\\n            ) * timeElapsed);\\n        }\\n    }\\n\\n    function computeAveragePrice(\\n        uint224 priceCumulativeStart,\\n        uint224 priceCumulativeEnd,\\n        uint32 timeElapsed\\n    ) internal pure returns (FixedPoint.uq112x112 memory priceAverage) {\\n        // overflow is desired.\\n        priceAverage = FixedPoint.uq112x112(\\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapFactory\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_initialObservationPeriod\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint224\",\"name\":\"tokenPriceCumulativeLast\",\"type\":\"uint224\"},{\"indexed\":false,\"internalType\":\"uint224\",\"name\":\"ethPriceCumulativeLast\",\"type\":\"uint224\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_OBSERVATION_DELAY\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"canUpdatePrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canUpdateTokenPrices\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"computeAverageAmountIn\",\"outputs\":[{\"internalType\":\"uint144\",\"name\":\"amountIn\",\"type\":\"uint144\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referenceToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"computeAverageAmountOut\",\"outputs\":[{\"internalType\":\"uint144\",\"name\":\"amountOut\",\"type\":\"uint144\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"computeAverageEthPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint224\",\"name\":\"_x\",\"type\":\"uint224\"}],\"internalType\":\"struct FixedPoint.uq112x112\",\"name\":\"priceAverage\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"computeAverageEthPrices\",\"outputs\":[{\"components\":[{\"internalType\":\"uint224\",\"name\":\"_x\",\"type\":\"uint224\"}],\"internalType\":\"struct FixedPoint.uq112x112[]\",\"name\":\"averagePrices\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"earliestTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referenceToken\",\"type\":\"address\"}],\"name\":\"computeAverageTokenPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint224\",\"name\":\"_x\",\"type\":\"uint224\"}],\"internalType\":\"struct FixedPoint.uq112x112\",\"name\":\"priceAverage\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"computeTwoWayAveragePrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint224\",\"name\":\"priceAverage\",\"type\":\"uint224\"},{\"internalType\":\"uint224\",\"name\":\"ethPriceAverage\",\"type\":\"uint224\"}],\"internalType\":\"struct PriceLibrary.TwoWayAveragePrice\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"computeTwoWayAveragePrices\",\"outputs\":[{\"components\":[{\"internalType\":\"uint224\",\"name\":\"priceAverage\",\"type\":\"uint224\"},{\"internalType\":\"uint224\",\"name\":\"ethPriceAverage\",\"type\":\"uint224\"}],\"internalType\":\"struct PriceLibrary.TwoWayAveragePrice[]\",\"name\":\"averagePrices\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"earliestTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLastPriceObservation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"priceCumulativeLast\",\"type\":\"uint224\"},{\"internalType\":\"uint224\",\"name\":\"ethPriceCumulativeLast\",\"type\":\"uint224\"}],\"internalType\":\"struct PriceLibrary.PriceObservation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"observationIndex\",\"type\":\"uint256\"}],\"name\":\"getPriceObservation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"priceCumulativeLast\",\"type\":\"uint224\"},{\"internalType\":\"uint224\",\"name\":\"ethPriceCumulativeLast\",\"type\":\"uint224\"}],\"internalType\":\"struct PriceLibrary.PriceObservation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxObservationAge\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"observationIndexOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"observationPeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenETHValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenUsdcValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"updatePrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"updateTokenPrices\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"updates\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateWethPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Pancakeswapv2Oracle", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ca143ce32fe78f1f7019d7d551a6402fc5350c7300000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}